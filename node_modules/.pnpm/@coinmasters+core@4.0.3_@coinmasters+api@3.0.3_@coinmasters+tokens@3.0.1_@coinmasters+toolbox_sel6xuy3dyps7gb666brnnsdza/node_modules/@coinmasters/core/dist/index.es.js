var Ke = Object.defineProperty;
var je = (e, t, n) => t in e ? Ke(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var T = (e, t, n) => (je(e, typeof t != "symbol" ? t + "" : t, n), n), Xe = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
};
var w = (e, t, n) => (Xe(e, t, "read from private field"), n ? n.call(e) : t.get(e)), x = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
};
var Ye = Object.defineProperty, Je = (e, t, n) => t in e ? Ye(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, v = (e, t, n) => (Je(e, typeof t != "symbol" ? t + "" : t, n), n);
const An = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !0, internalType: "address", name: "spender", type: "address" },
      { indexed: !1, internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "from", type: "address" },
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "success", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "success", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "success", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  }
], Qe = [
  {
    inputs: [{ internalType: "address", name: "rune", type: "address" }],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !0, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "Deposit",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferAllowance",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOut",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !1, internalType: "address", name: "target", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "address", name: "finalAsset", type: "address" },
      { indexed: !1, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOutAndCall",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        indexed: !1,
        internalType: "struct THORChain_Router.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "VaultTransfer",
    type: "event"
  },
  {
    inputs: [],
    name: "RUNE",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "deposit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" },
      { internalType: "uint256", name: "expiration", type: "uint256" }
    ],
    name: "depositWithExpiry",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address payable", name: "asgard", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        internalType: "struct THORChain_Router.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "returnVaultAssets",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address", name: "newVault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferAllowance",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "to", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "aggregator", type: "address" },
      { internalType: "address", name: "finalToken", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOutAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "vault", type: "address" },
      { internalType: "address", name: "token", type: "address" }
    ],
    name: "vaultAllowance",
    outputs: [{ internalType: "uint256", name: "amount", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  }
], Ze = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !0, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "Deposit",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferAllowance",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOut",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !1, internalType: "address", name: "target", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "address", name: "finalAsset", type: "address" },
      { indexed: !1, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOutAndCall",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        indexed: !1,
        internalType: "struct AvaxRouter.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "VaultTransfer",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "deposit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" },
      { internalType: "uint256", name: "expiration", type: "uint256" }
    ],
    name: "depositWithExpiry",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address payable", name: "asgard", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        internalType: "struct AvaxRouter.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "returnVaultAssets",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address", name: "newVault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferAllowance",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "to", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "target", type: "address" },
      { internalType: "address", name: "finalToken", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOutAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "vault", type: "address" },
      { internalType: "address", name: "token", type: "address" }
    ],
    name: "vaultAllowance",
    outputs: [{ internalType: "uint256", name: "amount", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  }
], ze = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !0, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "Deposit",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferAllowance",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOut",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !1, internalType: "address", name: "target", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "address", name: "finalAsset", type: "address" },
      { indexed: !1, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOutAndCall",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        indexed: !1,
        internalType: "struct THORChain_Router.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "VaultTransfer",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" },
      { internalType: "uint256", name: "expiration", type: "uint256" }
    ],
    name: "depositWithExpiry",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address payable", name: "asgard", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        internalType: "struct THORChain_Router.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "returnVaultAssets",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address", name: "newVault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferAllowance",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "to", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "target", type: "address" },
      { internalType: "address", name: "finalToken", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOutAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "vault", type: "address" },
      { internalType: "address", name: "token", type: "address" }
    ],
    name: "vaultAllowance",
    outputs: [{ internalType: "uint256", name: "amount", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  }
];
var et = /* @__PURE__ */ ((e) => (e.TC_SUPPORTED_TO_TC_SUPPORTED = "TC-TC", e.TC_SUPPORTED_TO_ETH = "TC-ERC20", e.TC_SUPPORTED_TO_AVAX = "TC-ARC20", e.TC_SUPPORTED_TO_BSC = "TC-BEP20", e.ETH_TO_TC_SUPPORTED = "ERC20-TC", e.ETH_TO_ETH = "ERC20-ERC20", e.ETH_TO_AVAX = "ERC20-ARC20", e.ETH_TO_BSC = "ERC20-BEP20", e.AVAX_TO_TC_SUPPORTED = "ARC20-TC", e.AVAX_TO_ETH = "ARC20-ERC20", e.AVAX_TO_AVAX = "ARC20-ARC20", e.AVAX_TO_BSC = "ARC20-BEP20", e.BSC_TO_TC_SUPPORTED = "BEP20-TC", e.BSC_TO_ETH = "BEP20-ERC20", e.BSC_TO_AVAX = "BEP20-ARC20", e.BSC_TO_BSC = "BEP20-BEP20", e))(et || {});
const tt = [
  "ERC20-ERC20",
  "ARC20-ARC20",
  "BEP20-BEP20"
  /* BSC_TO_BSC */
], nt = [
  "ERC20-TC",
  "ERC20-ARC20",
  "ERC20-BEP20",
  "ARC20-TC",
  "ARC20-ERC20",
  "ARC20-BEP20",
  "BEP20-TC",
  "BEP20-ERC20",
  "BEP20-ARC20"
  /* BSC_TO_AVAX */
], at = [
  "TC-TC",
  "TC-ERC20",
  "TC-ARC20",
  "TC-BEP20"
  /* TC_SUPPORTED_TO_BSC */
];
var Me = /* @__PURE__ */ ((e) => (e.VALIDATION_ERROR = "VALIDATION_ERROR", e.REQUEST_PARAMETER_ERROR = "REQUEST_PARAMETER_ERROR", e.RESPONSE_PARSING_ERROR = "RESPONSE_PARSING_ERROR", e.UNSUPPORTED = "UNSUPPORTED", e.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", e.INCOMPATIBLE_ASSETS_OPERATIONS = "INCOMPATIBLE_ASSETS_OPERATIONS", e.SERVICE_UNAVAILABLE = "SERVICE_UNAVAILABLE", e.DOWN_FOR_MAINTENANCE = "DOWN_FOR_MAINTENANCE", e.MISSING_INBOUND_INFO = "MISSING_INBOUND_INFO", e.QUOTE_FETCHING_ERROR = "QUOTE_FETCHING_ERROR", e.AIRDROP_ERROR = "AIRDROP_ERROR", e.UNHANDLED_ERROR = "UNHANDLED_ERROR", e))(Me || {}), st = /* @__PURE__ */ ((e) => (e.HEALTH_CONTROLLER = "1000", e.LIQUIDITY_CONTROLLER = "1001", e.PROVIDER_CONTROLLER = "1002", e.QUOTE_CONTROLLER = "1003", e.SWAP_CONTROLLER = "1004", e.UTIL_CONTROLLER = "1005", e.AIRDROP_CONTROLLER = "1006", e.PROVIDER = "2000", e.ASSET = "2001", e.TOKEN_LIST = "2002", e.QUOTE = "2100", e.QUOTE_TXN_DETAILS = "2101", e.THORCHAIN_PROVIDER = "3000", e.UNISWAPV2_ETH_PROVIDER = "3001", e.UNISWAPV3_ETH_PROVIDER = "3002", e.SUSHISWAP_ETH_PROVIDER = "3003", e.PANCAKESWAP_BSC_PROVIDER = "3004", e.PANCAKESWAP_ETH_PROVIDER = "3005", e.ONEINCH_ETH_PROVIDER = "3006", e.ONEINCH_BSC_PROVIDER = "3007", e.ONEINCH_AVAX_PROVIDER = "3008", e.ZEROX_ETH_PROVIDER = "3009", e.WOOFI_AVAX_PROVIDER = "3010", e.PANGOLIN_AVAX_PROVIDER = "3011", e.TRADERJOE_AVAX_PROVIDER = "3012", e.KYBER_ETH_PROVIDER = "3013", e.KYBER_AVAX_PROVIDER = "3014", e.WOOFI_BSC_PROVIDER = "3015", e.STARGATE_PROVIDER = "3016", e.PROVIDER_UTIL = "4000", e.TXN_DETAILS = "5000", e.AIRDROP_UTIL = "6000", e))(st || {}), y = /* @__PURE__ */ ((e) => (e.INVALID_INPUT_PARAMETERS = "1000", e.UNKNOWN_PROVIDERS = "1001", e.CANNOT_FIND_INBOUND_ADDRESS = "1002", e.NO_INBOUND_ADDRESSES = "1003", e.CHAIN_HALTED_OR_UNSUPPORTED = "1004", e.MISSING_INPUT_PARAMETER = "1005", e.INVALID_TYPE_GENERIC = "1100", e.INVALID_NUMBER_STRING = "1101", e.INVALID_NUMBER = "1102", e.INVALID_BOOLEAN = "1103", e.INVALID_OBJECT = "1104", e.INVALID_ARRAY = "1105", e.SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2000", e.SELL_BUY_ASSETS_ARE_THE_SAME = "2001", e.MISSING_SOURCE_ADDRESS_FOR_SYNTH = "2002", e.AFF_ADDRESS_AND_BPS_OR_NEITHER = "2003", e.AFF_ADDRESS_TOO_LONG = "2004", e.AFF_BPS_INTEGER_0_100 = "2005", e.SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN = "2006", e.DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN = "2007", e.PREFERRED_PROFVIDER_NOT_SUPPORTED = "2008", e.DESTINATION_ADDRESS_SMART_CONTRACT = "2009", e.BUY_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2010", e.SOURCE_ADDRESS_SMART_CONTRACT = "2011", e.INVALID_PROVIDER = "2100", e.MISSING_CROSS_CHAIN_PROVIDER = "2101", e.MISSING_AVAX_PROVIDER = "2102", e.MISSING_BSC_PROVIDER = "2103", e.MISSING_ETH_PROVIDER = "2104", e.INVALID_PROVIDER_FOR_SWAP_OUT = "2105", e.MISSING_ARB_PROVIDER = "2106", e.INVALID_CHAIN = "2200", e.INVALID_ASSET = "2201", e.INVALID_ASSET_IDENTIFIER = "2202", e.UNSUPPORTED_CHAIN = "2204", e.UNSUPPORTED_ASSET = "2203", e.UNSUPPORTED_ASSET_FOR_SWAPOUT = "2205", e.INVALID_SOURCE_ADDRESS = "2300", e.INVALID_DESTINATION_ADDRESS = "2301", e.THORNODE_QUOTE_GENERIC_ERROR = "3000", e.NOT_ENOUGH_SYNTH_BALANCE = "3001", e.SYNTH_MINTING_CAP_REACHED = "3002", e.INVALID_QUOTE_MODE = "4000", e.NO_QUOTES = "4001", e.SERVICE_UNAVAILABLE_GENERIC = "5000", e.MISSING_GAS_DATA_GENERIC = "5100", e.MISSING_TOKEN_INFO_GENERIC = "5200", e.CANT_FIND_TOKEN_LIST = "5201", e.NO_PRICE = "5202", e.PRICE_IS_STALE = "5203", e.ADDRESS_NOT_WHITELISTED = "6000", e.ADDRESS_ALREADY_CLAIMED = "6001", e.TEMPORARY_ERROR = "9999", e))(y || {});
const it = {
  [y.INVALID_INPUT_PARAMETERS]: "Invalid input parameters: {0}.",
  [y.UNKNOWN_PROVIDERS]: "Unknown providers: {0}.",
  [y.CANNOT_FIND_INBOUND_ADDRESS]: "Cannot find inbound address.",
  [y.NO_INBOUND_ADDRESSES]: "No inbound addresses.",
  [y.CHAIN_HALTED_OR_UNSUPPORTED]: "Chain {0} halted or unsupported.",
  [y.MISSING_INPUT_PARAMETER]: "Missing input parameter: {0}.",
  [y.INVALID_TYPE_GENERIC]: "Invalid type",
  [y.INVALID_NUMBER_STRING]: "Invalid number string.",
  [y.INVALID_NUMBER]: "Invalid number.",
  [y.INVALID_BOOLEAN]: "Invalid boolean.",
  [y.INVALID_OBJECT]: "Invalid object.",
  [y.INVALID_ARRAY]: "Invalid array.",
  [y.SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER]: "Sell amount must be a positive integer.",
  [y.SELL_BUY_ASSETS_ARE_THE_SAME]: "Sell and buy assets are the same.",
  [y.MISSING_SOURCE_ADDRESS_FOR_SYNTH]: "Source address is required for synth quote.",
  [y.AFF_ADDRESS_AND_BPS_OR_NEITHER]: "Must provide affiliateAddress and affiliateBasisPoints params, or neither.",
  [y.AFF_ADDRESS_TOO_LONG]: "affiliateAddress too long: 3 characters max.",
  [y.AFF_BPS_INTEGER_0_100]: "affiliateBasisPoints must be an integer between 0 and 100.",
  [y.SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN]: "Source address {0} invalid for sell chain.",
  [y.DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN]: "Destination address {0} invalid for buy chain.",
  [y.PREFERRED_PROFVIDER_NOT_SUPPORTED]: "Preferred provider not supported.",
  [y.DESTINATION_ADDRESS_SMART_CONTRACT]: "Destination address is a smart contract.",
  [y.BUY_AMOUNT_MUST_BE_POSITIVE_INTEGER]: "Buy amount must be a positive integer.",
  [y.INVALID_PROVIDER]: "Invalid provider {0}.",
  [y.MISSING_CROSS_CHAIN_PROVIDER]: "Missing cross-chain provider.",
  [y.MISSING_AVAX_PROVIDER]: "Missing AVAX provider.",
  [y.MISSING_BSC_PROVIDER]: "Missing BSC provider.",
  [y.MISSING_ETH_PROVIDER]: "Missing ETH provider.",
  [y.MISSING_ARB_PROVIDER]: "Missing ARB provider.",
  [y.INVALID_PROVIDER_FOR_SWAP_OUT]: "Invalid provider for swap out.",
  [y.INVALID_CHAIN]: "Invalid chain {0}.",
  [y.INVALID_ASSET]: "Invalid asset {0}.",
  [y.UNSUPPORTED_CHAIN]: "Unsupported chain {0}.",
  [y.UNSUPPORTED_ASSET]: "Unsupported asset {0}.",
  [y.UNSUPPORTED_ASSET_FOR_SWAPOUT]: "Unsupported asset {0} for swap out.",
  [y.THORNODE_QUOTE_GENERIC_ERROR]: "ThorNode quote generic error.",
  [y.INVALID_SOURCE_ADDRESS]: "Invalid source address {0}",
  [y.INVALID_DESTINATION_ADDRESS]: "Invalid destination address {0}",
  [y.NOT_ENOUGH_SYNTH_BALANCE]: "Source address doesn't have enough synth balance for this quote.",
  [y.SYNTH_MINTING_CAP_REACHED]: "Synth minting cap reached.",
  [y.INVALID_QUOTE_MODE]: "Invalid quote mode.",
  [y.NO_QUOTES]: "No quotes to service this request.",
  [y.SERVICE_UNAVAILABLE_GENERIC]: "Service unavailable.",
  [y.MISSING_GAS_DATA_GENERIC]: "Missing gas data.",
  [y.MISSING_TOKEN_INFO_GENERIC]: "Missing token info.",
  [y.CANT_FIND_TOKEN_LIST]: "Can't find tokenlist {0}.",
  [y.NO_PRICE]: "No price for asset {0}.",
  [y.PRICE_IS_STALE]: "Price is stale for asset {0}.",
  [y.ADDRESS_NOT_WHITELISTED]: "Address {0} not whitelisted for airdrop.",
  [y.ADDRESS_ALREADY_CLAIMED]: "Address {0} already claimed the airdrop."
}, pe = (e, t) => {
  let n = it[e];
  for (let a = 0; a < t.length; a++)
    n = n.replace(`{${a}}`, t[a]);
  return t.length === 0 ? n.replace("{0}", "") : n;
};
let Rn = class Ne extends Error {
  constructor({
    status: t,
    revision: n,
    module: a,
    code: i,
    message: r,
    type: o,
    options: { shouldLog: p, shouldThrow: d, shouldTrace: l } = {
      shouldLog: !0,
      shouldThrow: !0,
      shouldTrace: !0
    },
    displayMessageParams: u
  }) {
    const c = r || pe(i, u || []) || "";
    super(c), v(this, "status"), v(this, "revision"), v(this, "type"), v(this, "module"), v(this, "code"), v(this, "message"), v(this, "display"), v(this, "stack"), v(this, "options"), v(this, "displayMessageParams"), this.status = t, this.revision = n || "NO_REVISION", this.module = a, this.message = c, this.display = pe(i, u || []), this.code = i, this.type = o || Me.UNHANDLED_ERROR, this.options = {
      shouldLog: p || !0,
      shouldTrace: l || !0,
      shouldThrow: d || !1
    }, this.displayMessageParams = u || [], this.options.shouldTrace && Error.captureStackTrace(this);
  }
  static fromErrorInfo(t) {
    return new Ne(t);
  }
  toErrorInfo() {
    return { ...this, identifier: this.identifier };
  }
  get identifier() {
    return `${this.revision}-${this.type || "NO_TYPE"}-${this.module}-${this.code}`;
  }
  get displayMessage() {
    return pe(this.code, this.displayMessageParams || []);
  }
  handle() {
    const t = `[${this.identifier}]: ${this.message}`;
    if (this.options.shouldLog && console.error(t, `
`, this.stack || ""), this.options.shouldThrow)
      throw Error(t, { cause: this.stack });
    return this.toErrorInfo();
  }
};
var s = /* @__PURE__ */ ((e) => (e.Arbitrum = "ARB", e.Avalanche = "AVAX", e.Base = "BASE", e.Binance = "BNB", e.BinanceSmartChain = "BSC", e.Bitcoin = "BTC", e.BitcoinCash = "BCH", e.Cosmos = "GAIA", e.Dash = "DASH", e.Digibyte = "DGB", e.Dogecoin = "DOGE", e.EOS = "EOS", e.Ethereum = "ETH", e.Kujira = "KUJI", e.Litecoin = "LTC", e.Maya = "MAYA", e.Optimism = "OP", e.Osmosis = "OSMO", e.Polygon = "MATIC", e.Ripple = "XRP", e.THORChain = "THOR", e.Zcash = "ZEC", e))(s || {});
function gn(e) {
  switch (e) {
    case "ARB":
      return "ARB";
    case "AVAX":
      return "AVAX";
    case "BASE":
      return "BASE";
    case "BNB":
      return "BNB";
    case "BSC":
      return "BSC";
    case "BTC":
      return "BTC";
    case "BCH":
      return "BCH";
    case "GAIA":
      return "GAIA";
    case "DASH":
      return "DASH";
    case "DGB":
      return "DGB";
    case "DOGE":
      return "DOGE";
    case "EOS":
      return "EOS";
    case "ETH":
      return "ETH";
    case "KUJI":
      return "KUJI";
    case "LTC":
      return "LTC";
    case "MAYA":
      return "MAYA";
    case "OP":
      return "OP";
    case "OSMO":
      return "OSMO";
    case "MATIC":
      return "MATIC";
    case "XRP":
      return "XRP";
    case "THOR":
      return "THOR";
    case "ZEC":
      return "ZEC";
    default:
      return;
  }
}
const rt = {
  ARB: "eip155:42161",
  AVAX: "eip155:43114",
  BSC: "eip155:56",
  BNB: "binance:bnb-beacon-chain",
  BCH: "bip122:000000000000000000651ef99cb9fcbe",
  BTC: "bip122:000000000019d6689c085ae165831e93",
  BASE: "eip155:8453",
  GAIA: "cosmos:cosmoshub-4",
  DASH: "bip122:dash-hash",
  DGB: "bip122:digibytes-hash",
  DOGE: "bip122:00000000001a91e3dace36e2be3bf030",
  KUJI: "cosmos:kaiyo-1",
  EOS: "eos:cf057bbfb72640471fd910bcb67639c2",
  ETH: "eip155:1",
  LTC: "bip122:12a765e31ffd4059bada1e25190f6e98",
  MAYA: "cosmos:maya-mainnet-v1",
  OP: "eip155:10",
  OSMO: "cosmos:osmosis-1",
  MATIC: "eip155:137",
  XRP: "ripple:unknown",
  THOR: "cosmos:thorchain-mainnet-v1",
  ZEC: "bip122:0000000000196a45"
}, ot = {};
for (const e in s) {
  const t = rt[s[e]];
  ot[t] = s[e];
}
var pt = /* @__PURE__ */ ((e) => (e.ARB = "0x0000000000000000000000000000000000000000", e.AVAX = "0x0000000000000000000000000000000000000000", e.ETH = "0x0000000000000000000000000000000000000000", e.BSC = "0x0000000000000000000000000000000000000000", e.MATIC = "0x0000000000000000000000000000000000001010", e.OP = "0x4200000000000000000000000000000000000042", e))(pt || {}), dt = /* @__PURE__ */ ((e) => (e.ARB = "m/44'/60'/0'/0", e.AVAX = "m/44'/60'/0'/0", e.BASE = "m/44'/60'/0'/0", e.BCH = "m/44'/145'/0'/0", e.BNB = "m/44'/714'/0'/0", e.BSC = "m/44'/60'/0'/0", e.BTC = "m/84'/0'/0'/0", e.DOGE = "m/44'/3'/0'/0", e.DASH = "m/44'/5'/0'/0", e.DGB = "m/44'/20'/0'/0", e.ETH = "m/44'/60'/0'/0", e.EOS = "m/44'/194'/0'/0", e.GAIA = "m/44'/118'/0'/0", e.KUJI = "m/44'/118'/0'/0", e.LTC = "m/84'/2'/0'/0", e.MATIC = "m/44'/60'/0'/0", e.MAYA = "m/44'/931'/0'/0", e.OP = "m/44'/60'/0'/0", e.OSMO = "m/44'/118'/0'/0", e.XRP = "m/44'/144'/0'/0", e.THOR = "m/44'/931'/0'/0", e.ZEC = "m/44'/133'/0'/0", e))(dt || {});
const On = {
  ARB: [44, 60, 0, 0, 0],
  AVAX: [44, 60, 0, 0, 0],
  BASE: [44, 60, 0, 0, 0],
  BCH: [44, 145, 0, 0, 0],
  BNB: [44, 714, 0, 0, 0],
  BSC: [44, 60, 0, 0, 0],
  BTC: [84, 0, 0, 0, 0],
  DASH: [44, 5, 0, 0, 0],
  DGB: [44, 20, 0, 0, 0],
  DOGE: [44, 3, 0, 0, 0],
  EOS: [44, 194, 0, 0, 0],
  ETH: [44, 60, 0, 0, 0],
  GAIA: [44, 118, 0, 0, 0],
  KUJI: [44, 118, 0, 0, 0],
  LTC: [84, 2, 0, 0, 0],
  MATIC: [44, 60, 0, 0, 0],
  MAYA: [44, 931, 0, 0, 0],
  OP: [44, 60, 0, 0, 0],
  OSMO: [44, 118, 0, 0, 0],
  XRP: [44, 144, 0, 0, 0],
  THOR: [44, 931, 0, 0, 0],
  ZEC: [44, 133, 0, 0, 0]
};
var E = /* @__PURE__ */ ((e) => (e[e.ARB = 18] = "ARB", e[e.AVAX = 18] = "AVAX", e[e.BCH = 8] = "BCH", e[e.BNB = 8] = "BNB", e[e.BSC = 18] = "BSC", e[e.BTC = 8] = "BTC", e[e.DASH = 8] = "DASH", e[e.DGB = 8] = "DGB", e[e.DOGE = 8] = "DOGE", e[e.ETH = 18] = "ETH", e[e.EOS = 6] = "EOS", e[e.GAIA = 6] = "GAIA", e[e.KUJI = 6] = "KUJI", e[e.LTC = 8] = "LTC", e[e.MATIC = 18] = "MATIC", e[e.MAYA = 10] = "MAYA", e[e.OP = 18] = "OP", e[e.OSMO = 6] = "OSMO", e[e.XRP = 6] = "XRP", e[e.THOR = 8] = "THOR", e[e.ZEC = 8] = "ZEC", e))(E || {});
const Q = [
  "ETH",
  "AVAX",
  "BSC",
  "ARB",
  // Chain.Base,
  "OP",
  "MATIC"
  /* Polygon */
], Sn = [
  "BTC",
  "BCH",
  "DASH",
  "DGB",
  "DOGE",
  "LTC",
  "ZEC"
  /* Zcash */
], In = [
  "GAIA",
  "THOR",
  "BNB",
  "OSMO"
  /* Osmosis */
], Cn = [
  "AVAX",
  "BNB",
  "BSC",
  "BTC",
  "BCH",
  "GAIA",
  "DOGE",
  "ETH",
  "LTC",
  "THOR"
  /* THORChain */
];
var be = /* @__PURE__ */ ((e) => (e.Arbitrum = "42161", e.ArbitrumHex = "0xa4b1", e.Avalanche = "43114", e.AvalancheHex = "0xa86a", e.Base = "8453", e.Binance = "Binance-Chain-Tigris", e.BinanceSmartChain = "56", e.BinanceSmartChainHex = "0x38", e.Bitcoin = "bitcoin", e.BitcoinCash = "bitcoincash", e.Cosmos = "cosmoshub-4", e.Dash = "dash", e.Dogecoin = "dogecoin", e.Kujira = "kaiyo-1", e.Ethereum = "1", e.EthereumHex = "0x1", e.Litecoin = "litecoin", e.Maya = "mayachain-mainnet-v1", e.MayaStagenet = "mayachain-stagenet-v1", e.Optimism = "10", e.OptimismHex = "0xa", e.Osmosis = "osmosis-1", e.Polygon = "137", e.PolygonHex = "0x89", e.THORChain = "thorchain-mainnet-v1", e.THORChainStagenet = "thorchain-stagenet-v2", e))(be || {}), De = /* @__PURE__ */ ((e) => (e.Arbitrum = "https://arb1.arbitrum.io/rpc", e.Avalanche = "https://node-router.thorswap.net/avalanche-c", e.Binance = "https://base.llamarpc.com", e.BinanceSmartChain = "https://bsc-dataseed.binance.org", e.Bitcoin = "https://node-router.thorswap.net/bitcoin", e.BitcoinCash = "https://node-router.thorswap.net/bitcoin-cash", e.Cosmos = "https://node-router.thorswap.net/cosmos/rpc", e.Kujira = "https://rpc-kujira.synergynodes.com/", e.Dash = "https://dash.nownodes.io", e.Dogecoin = "https://node-router.thorswap.net/dogecoin", e.Ethereum = "https://node-router.thorswap.net/ethereum", e.Litecoin = "https://node-router.thorswap.net/litecoin", e.Maya = "https://tendermint.mayachain.info", e.MayaStagenet = "https://stagenet.tendermint.mayachain.info", e.Optimism = "https://mainnet.optimism.io", e.Osmosis = "https://rpc-osmosis.keplr.app", e.Polygon = "https://polygon-rpc.com", e.THORChain = "https://rpc.thorswap.net", e.THORChainStagenet = "https://stagenet-rpc.ninerealms.com", e))(De || {}), W = /* @__PURE__ */ ((e) => (e.Cosmos = "https://node-router.thorswap.net/cosmos/rest", e.Kujira = "https://lcd-kujira.synergynodes.com/", e.MayanodeMainnet = "https://mayanode.mayachain.info", e.MayanodeStagenet = "https://stagenet.mayanode.mayachain.info", e.ThornodeMainnet = "https://thornode.thorswap.net", e.ThornodeStagenet = "https://stagenet-thornode.ninerealms.com", e.ThorswapApi = "https://api.thorswap.net", e.ThorswapStatic = "https://static.thorswap.net", e))(W || {});
const ie = Object.values(s), ut = Object.keys(s), we = ie.reduce(
  (e, t) => {
    const n = ut.find((a) => s[a] === t);
    return n && (e[t] = n), e;
  },
  {}
), lt = ie.reduce(
  (e, t) => (e[t] = be[we[t]], e),
  {}
), yt = ie.reduce(
  (e, t) => (e[t] = De[we[t]], e),
  {}
), vn = ie.reduce(
  (e, t) => {
    const n = `${we[t]}Hex`;
    return e[t] = be[n], e;
  },
  {}
), Mn = {
  "0xa4b1": "ARB",
  42161: "ARB",
  "0xa86a": "AVAX",
  43114: "AVAX",
  "0x38": "BSC",
  56: "BSC",
  "Binance-Chain-Tigris": "BNB",
  bitcoincash: "BCH",
  bitcoin: "BTC",
  "cosmoshub-4": "GAIA",
  8453: "BASE",
  dash: "DASH",
  dogecoin: "DOGE",
  "0x1": "ETH",
  "kaiyo-1": "KUJI",
  1: "ETH",
  litecoin: "LTC",
  "mayachain-stagenet-v1": "MAYA",
  "mayachain-mainnet-v1": "MAYA",
  "0xa": "OP",
  10: "OP",
  "osmosis-1": "OSMO",
  "0x89": "MATIC",
  137: "MATIC",
  "thorchain-stagenet-v2": "THOR",
  "thorchain-mainnet-v1": "THOR"
  /* THORChain */
}, Be = {
  ARB: "https://arbiscan.io",
  AVAX: "https://snowtrace.io",
  BSC: "https://bscscan.com",
  BNB: "https://explorer.binance.org",
  BCH: "https://www.blockchain.com/bch",
  BTC: "https://blockstream.info",
  BASE: "https://basescan.org",
  GAIA: "https://cosmos.bigdipper.live",
  DASH: "https://blockchair.com/dash",
  DGB: "https://chainz.cryptoid.info/dgb",
  DOGE: "https://blockchair.com/dogecoin",
  KUJI: "https://finder.kujira.network/kaiyo-1",
  EOS: "https://eosauthority.com/",
  ETH: "https://etherscan.io",
  LTC: "https://ltc.bitaps.com",
  MAYA: "https://www.mayascan.org",
  OP: "https://optimistic.etherscan.io",
  OSMO: "https://www.mintscan.io/osmosis",
  MATIC: "https://polygonscan.com",
  XRP: "https://xrpscan.com",
  THOR: "https://runescan.io",
  ZEC: "https://z.cash/ecosystem/zcash-explorer"
};
var ct = /* @__PURE__ */ ((e) => (e[e.NoError = 36864] = "NoError", e))(ct || {}), f = /* @__PURE__ */ ((e) => (e.BOND = "BOND", e.DEPOSIT = "+", e.LEAVE = "LEAVE", e.THORNAME_REGISTER = "~", e.UNBOND = "UNBOND", e.WITHDRAW = "-", e.OPEN_LOAN = "$+", e.CLOSE_LOAN = "$-", e))(f || {}), F = /* @__PURE__ */ ((e) => (e.Average = "average", e.Fast = "fast", e.Fastest = "fastest", e))(F || {}), mt = /* @__PURE__ */ ((e) => (e.KEYSTORE = "KEYSTORE", e.KEEPKEY = "KEEPKEY", e.XDEFI = "XDEFI", e.METAMASK = "METAMASK", e.COINBASE_WEB = "COINBASE_WEB", e.TREZOR = "TREZOR", e.TRUSTWALLET_WEB = "TRUSTWALLET_WEB", e.LEDGER = "LEDGER", e.KEPLR = "KEPLR", e.OKX = "OKX", e.BRAVE = "BRAVE", e.WALLETCONNECT = "WALLETCONNECT", e))(mt || {});
const Y = [
  s.Arbitrum,
  s.Avalanche,
  s.Binance,
  s.BinanceSmartChain,
  s.Bitcoin,
  s.BitcoinCash,
  s.Cosmos,
  s.Dogecoin,
  s.Ethereum,
  s.Litecoin,
  s.Optimism,
  s.Polygon,
  s.THORChain
], Nn = {
  BRAVE: Q,
  COINBASE_WEB: Q,
  KEPLR: [s.Cosmos],
  KEYSTORE: Y,
  LEDGER: Y,
  TREZOR: [
    s.Bitcoin,
    s.BitcoinCash,
    s.Litecoin,
    s.Dogecoin,
    s.Ethereum
  ],
  KEEPKEY: Y,
  METAMASK: [
    s.Arbitrum,
    s.Avalanche,
    s.BinanceSmartChain,
    s.Bitcoin,
    s.BitcoinCash,
    s.Cosmos,
    s.Dogecoin,
    s.Ethereum,
    s.Litecoin,
    s.Optimism,
    s.Polygon,
    s.THORChain
  ],
  TRUSTWALLET_WEB: Q,
  XDEFI: Y,
  WALLETCONNECT: [
    s.Ethereum,
    s.Binance,
    s.BinanceSmartChain,
    s.Avalanche,
    s.THORChain
  ],
  OKX: [
    s.Ethereum,
    s.Avalanche,
    s.BinanceSmartChain,
    s.Bitcoin,
    s.Cosmos
  ]
};
var Tt = Object.defineProperty, ht = (e, t, n) => t in e ? Tt(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, I = (e, t, n) => (ht(e, typeof t != "symbol" ? t + "" : t, n), n), _t = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
}, $ = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, R = (e, t, n) => (_t(e, t, "access private method"), n);
const ft = "0x313ce567", xe = async ({ chain: e, to: t }) => {
  try {
    const { result: n } = await Ae.post(yt[e], {
      headers: {
        accept: "*/*",
        "content-type": "application/json",
        "cache-control": "no-cache"
      },
      body: JSON.stringify({
        id: 44,
        jsonrpc: "2.0",
        method: "eth_call",
        params: [{ to: t.toLowerCase(), data: ft }, "latest"]
      })
    });
    return parseInt(BigInt(n).toString());
  } catch (n) {
    return console.error(n), E[e];
  }
}, bt = async (e) => {
  if (e === s.Ethereum)
    return E.ETH;
  const [, t] = e.split("-");
  return t != null && t.startsWith("0x") ? xe({ chain: s.Ethereum, to: t }) : E.ETH;
}, wt = async (e) => {
  const [, t] = e.split("-");
  return t != null && t.startsWith("0x") ? xe({ chain: s.Avalanche, to: t.toLowerCase() }) : E.AVAX;
}, Et = async (e) => (e === s.BinanceSmartChain, E.BSC), At = async ({ chain: e, symbol: t }) => {
  switch (e) {
    case s.Ethereum:
      return bt(t);
    case s.Avalanche:
      return wt(t);
    case s.BinanceSmartChain:
      return Et(t);
    default:
      return E[e];
  }
}, Rt = {
  [F.Average]: 1.2,
  [F.Fast]: 1.5,
  [F.Fastest]: 2
}, Pe = ({ chain: e, symbol: t }) => {
  switch (e) {
    case s.Bitcoin:
    case s.BitcoinCash:
    case s.Dash:
    case s.Digibyte:
    case s.Digibyte:
    case s.Zcash:
    case s.Ripple:
    case s.Litecoin:
    case s.Dogecoin:
    case s.Binance:
    case s.Ethereum:
    case s.Avalanche:
      return t === e;
    case s.Arbitrum:
    case s.Optimism:
      return t === "ETH";
    case s.Maya:
      return t === "CACAO";
    case s.Kujira:
      return t === "KUJI";
    case s.Cosmos:
      return t === "ATOM";
    case s.Polygon:
      return t === "MATIC";
    case s.BinanceSmartChain:
      return t === "BNB";
    case s.THORChain:
      return t === "RUNE";
  }
}, gt = (e) => {
  switch (e) {
    case "ETH.THOR":
      return { identifier: "ETH.THOR-0xa5f2211b9b8170f694421f2046281775e8468044", decimal: 18 };
    case "ETH.vTHOR":
      return { identifier: "ETH.vTHOR-0x815c23eca83261b6ec689b60cc4a58b54bc24d8d", decimal: 18 };
    case s.Cosmos:
      return { identifier: "GAIA.ATOM", decimal: E[e] };
    case s.THORChain:
      return { identifier: "THOR.RUNE", decimal: E[e] };
    case s.BinanceSmartChain:
      return { identifier: "BSC.BNB", decimal: E[e] };
    case s.Maya:
      return { identifier: "MAYA.CACAO", decimal: E.MAYA };
    case "MAYA.MAYA":
      return { identifier: "MAYA.MAYA", decimal: 4 };
    case s.Kujira:
    case s.Arbitrum:
    case s.Optimism:
    case s.BitcoinCash:
    case s.Litecoin:
    case s.Dogecoin:
    case s.Binance:
    case s.Avalanche:
    case s.Polygon:
    case s.Bitcoin:
    case s.Ethereum:
      return { identifier: `${e}.${e}`, decimal: E[e] };
  }
}, Ot = ({ chain: e, symbol: t }) => {
  if (t.includes("/"))
    return "Synth";
  switch (e) {
    case s.Bitcoin:
    case s.BitcoinCash:
    case s.Dogecoin:
    case s.Litecoin:
    case s.Maya:
    case s.THORChain:
      return "Native";
    case s.Cosmos:
      return t === "ATOM" ? "Native" : s.Cosmos;
    case s.Kujira:
      return t === s.Kujira ? "Native" : s.Kujira;
    case s.Binance:
      return t === s.Binance ? "Native" : "BEP2";
    case s.BinanceSmartChain:
      return t === s.Binance ? "Native" : "BEP20";
    case s.Ethereum:
      return t === s.Ethereum ? "Native" : "ERC20";
    case s.Avalanche:
      return t === s.Avalanche ? "Native" : s.Avalanche;
    case s.Polygon:
      return t === s.Polygon ? "Native" : "POLYGON";
    case s.Arbitrum:
      return [s.Ethereum, s.Arbitrum].includes(t) ? "Native" : "ARBITRUM";
    case s.Optimism:
      return [s.Ethereum, s.Optimism].includes(t) ? "Native" : "OPTIMISM";
  }
}, Dn = (e) => {
  var t;
  const [n, ...a] = e.split("."), i = e.includes("/"), r = a.join("."), o = (t = r == null ? void 0 : r.split("-")) == null ? void 0 : t[0];
  return { chain: n, symbol: r, ticker: o, synth: i };
}, St = new RegExp(
  /(.)\1{6}|\.ORG|\.NET|\.FINANCE|\.COM|WWW|HTTP|\\\\|\/\/|[\s$%:[\]]/,
  "gmi"
), It = (e) => {
  const [t, n] = e.split(".");
  if (!Q.includes(t))
    return !0;
  const [, a] = n.split("-");
  return Pe({ chain: t, symbol: n }) || !!a;
}, Bn = (e) => e.filter((t) => {
  const n = `${t.chain}.${t.symbol}`;
  return !St.test(n) && It(n) && t.value !== "0";
}), Ct = ({
  liquidityUnits: e,
  poolUnits: t,
  runeDepth: n
}) => {
  const a = g(e), i = g(t), r = g(n), o = a.mul(r), p = i.mul(i).mul(2), d = i.mul(a).mul(2), l = a.mul(a), u = i.mul(i).mul(i);
  return o.mul(p.sub(d).add(l)).div(u);
}, vt = ({
  liquidityUnits: e,
  poolUnits: t,
  assetDepth: n
}) => {
  const a = g(e), i = g(t), r = g(n), o = a.mul(r), p = i.mul(i).mul(2), d = i.mul(a).mul(2), l = a.mul(a), u = o.mul(p.sub(d).add(l)), c = i.mul(i).mul(i);
  return u.div(c);
}, xn = ({
  percent: e,
  runeDepth: t,
  liquidityUnits: n,
  poolUnits: a
}) => Ct({ runeDepth: t, liquidityUnits: n, poolUnits: a }).mul(e), Pn = ({
  percent: e,
  assetDepth: t,
  liquidityUnits: n,
  poolUnits: a
}) => vt({ assetDepth: t, liquidityUnits: n, poolUnits: a }).mul(e), g = (e) => D.fromBigInt(BigInt(e), E.THOR), Mt = ({
  liquidityUnits: e,
  poolUnits: t,
  runeDepth: n,
  assetDepth: a
}) => ({
  assetAmount: g(a).mul(e).div(t),
  runeAmount: g(n).mul(e).div(t)
}), Ln = ({
  liquidityUnits: e,
  poolUnits: t,
  runeDepth: n,
  assetDepth: a,
  percent: i
}) => Object.fromEntries(
  Object.entries(Mt({ liquidityUnits: e, poolUnits: t, runeDepth: n, assetDepth: a })).map(
    ([r, o]) => [r, o.mul(i)]
  )
), Vn = ({
  runeDepth: e,
  poolUnits: t,
  assetDepth: n,
  liquidityUnits: a,
  runeAmount: i,
  assetAmount: r
}) => {
  const o = new D({ value: e, decimal: 8 }), p = new D({ value: n, decimal: 8 }), d = new D({ value: t, decimal: 8 }), l = new D({ value: i, decimal: 8 }), u = new D({ value: r, decimal: 8 }), c = l.mul(p), h = u.mul(o), b = l.mul(u), _ = o.mul(p), A = d.mul(c.add(h.add(b.mul(2)))), O = c.add(h.add(_.mul(2))), S = A.div(O), B = g(a).add(S);
  if (S.getBaseValue("number") === 0)
    return B.div(d).getBaseValue("number");
  const oe = d.add(B);
  return B.div(oe).getBaseValue("number");
}, Un = ({
  runeAmount: e,
  assetAmount: t,
  runeDepth: n,
  assetDepth: a
}) => {
  if (e === "0" || t === "0" || n === "0" || a === "0")
    return 0;
  const i = g(n), r = g(a), o = g(t), p = g(e), d = o.mul(i).sub(r.mul(p)), l = r.mul(p).add(i.mul(r));
  return Math.abs(d.div(l).getBaseValue("number"));
}, Nt = ({
  symbol: e,
  ticker: t,
  chain: n
}) => n === "ETH" && t !== "ETH" ? `${t}-${e.slice(-3)}` : e, N = (e, t) => {
  switch (e) {
    case f.LEAVE:
    case f.BOND: {
      const { address: n } = t;
      return `${e}:${n}`;
    }
    case f.UNBOND: {
      const { address: n, unbondAmount: a } = t;
      return `${e}:${n}:${a * 10 ** 8}`;
    }
    case f.THORNAME_REGISTER: {
      const { name: n, chain: a, address: i, owner: r } = t;
      return `${e}:${n}:${a}:${i}${r ? `:${r}` : ""}`;
    }
    case f.DEPOSIT: {
      const { chain: n, symbol: a, address: i, singleSide: r } = t;
      return r ? `${e}:${n}/${a}::t:0` : `${e}:${n}.${a}:${i || ""}:t:0`;
    }
    case f.WITHDRAW: {
      const { chain: n, ticker: a, symbol: i, basisPoints: r, targetAssetString: o, singleSide: p } = t, d = !p && o ? `:${o}` : "", l = Nt({ chain: n, symbol: i, ticker: a });
      return `${e}:${n}${p ? "/" : "."}${l}:${r}${d}`;
    }
    case f.OPEN_LOAN:
    case f.CLOSE_LOAN: {
      const { asset: n, address: a } = t;
      return `${e}:${n}:${a}`;
    }
    default:
      return "";
  }
}, Hn = (e) => {
  if (e < 0)
    throw new Error("Invalid number of year");
  return 10 + e;
}, $n = (e) => {
  if (e.length > 30)
    return !1;
  const t = /^[a-zA-Z0-9+_-]+$/g;
  return !!e.match(t);
}, kn = ([e, t, n, a, i]) => `${e}'/${t}'/${n}'/${a}${typeof i != "number" ? "" : `/${i}`}`;
class Re extends Error {
  constructor(t, n, a) {
    const i = t.status || t.status === 0 ? t.status : "", r = t.statusText || "", o = `${i} ${r}`.trim(), p = o ? `status code ${o}` : "an unknown error";
    super(`Request failed with ${p}`), Object.defineProperty(this, "response", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "request", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "options", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "HTTPError", this.response = t, this.request = n, this.options = a;
  }
}
class Le extends Error {
  constructor(t) {
    super("Request timed out"), Object.defineProperty(this, "request", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "TimeoutError", this.request = t;
  }
}
const Z = (e) => e !== null && typeof e == "object", J = (...e) => {
  for (const t of e)
    if ((!Z(t) || Array.isArray(t)) && t !== void 0)
      throw new TypeError("The `options` argument must be an object");
  return Ee({}, ...e);
}, Ve = (e = {}, t = {}) => {
  const n = new globalThis.Headers(e), a = t instanceof globalThis.Headers, i = new globalThis.Headers(t);
  for (const [r, o] of i.entries())
    a && o === "undefined" || o === void 0 ? n.delete(r) : n.set(r, o);
  return n;
}, Ee = (...e) => {
  let t = {}, n = {};
  for (const a of e)
    if (Array.isArray(a))
      Array.isArray(t) || (t = []), t = [...t, ...a];
    else if (Z(a)) {
      for (let [i, r] of Object.entries(a))
        Z(r) && i in t && (r = Ee(t[i], r)), t = { ...t, [i]: r };
      Z(a.headers) && (n = Ve(n, a.headers), t.headers = n);
    }
  return t;
}, Dt = (() => {
  let e = !1, t = !1;
  const n = typeof globalThis.ReadableStream == "function", a = typeof globalThis.Request == "function";
  return n && a && (t = new globalThis.Request("https://empty.invalid", {
    body: new globalThis.ReadableStream(),
    method: "POST",
    // @ts-expect-error - Types are outdated.
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type")), e && !t;
})(), Bt = typeof globalThis.AbortController == "function", xt = typeof globalThis.ReadableStream == "function", Pt = typeof globalThis.FormData == "function", Ue = ["get", "post", "put", "patch", "head", "delete"], Lt = {
  json: "application/json",
  text: "text/*",
  formData: "multipart/form-data",
  arrayBuffer: "*/*",
  blob: "*/*"
}, de = 2147483647, He = Symbol("stop"), Vt = {
  json: !0,
  parseJson: !0,
  searchParams: !0,
  prefixUrl: !0,
  retry: !0,
  timeout: !0,
  hooks: !0,
  throwHttpErrors: !0,
  onDownloadProgress: !0,
  fetch: !0
}, Ut = {
  method: !0,
  headers: !0,
  body: !0,
  mode: !0,
  credentials: !0,
  cache: !0,
  redirect: !0,
  referrer: !0,
  referrerPolicy: !0,
  integrity: !0,
  keepalive: !0,
  signal: !0,
  window: !0,
  dispatcher: !0,
  duplex: !0
}, Ht = (e) => Ue.includes(e) ? e.toUpperCase() : e, $t = ["get", "put", "head", "delete", "options", "trace"], kt = [408, 413, 429, 500, 502, 503, 504], $e = [413, 429, 503], ge = {
  limit: 2,
  methods: $t,
  statusCodes: kt,
  afterStatusCodes: $e,
  maxRetryAfter: Number.POSITIVE_INFINITY,
  backoffLimit: Number.POSITIVE_INFINITY,
  delay: (e) => 0.3 * 2 ** (e - 1) * 1e3
}, Ft = (e = {}) => {
  if (typeof e == "number")
    return {
      ...ge,
      limit: e
    };
  if (e.methods && !Array.isArray(e.methods))
    throw new Error("retry.methods must be an array");
  if (e.statusCodes && !Array.isArray(e.statusCodes))
    throw new Error("retry.statusCodes must be an array");
  return {
    ...ge,
    ...e,
    afterStatusCodes: $e
  };
};
async function Gt(e, t, n, a) {
  return new Promise((i, r) => {
    const o = setTimeout(() => {
      n && n.abort(), r(new Le(e));
    }, a.timeout);
    a.fetch(e, t).then(i).catch(r).then(() => {
      clearTimeout(o);
    });
  });
}
async function Wt(e, { signal: t }) {
  return new Promise((n, a) => {
    t && (t.throwIfAborted(), t.addEventListener("abort", i, { once: !0 }));
    function i() {
      clearTimeout(r), a(t.reason);
    }
    const r = setTimeout(() => {
      t == null || t.removeEventListener("abort", i), n();
    }, e);
  });
}
const qt = (e, t) => {
  const n = {};
  for (const a in t)
    !(a in Ut) && !(a in Vt) && !(a in e) && (n[a] = t[a]);
  return n;
};
class te {
  static create(t, n) {
    const a = new te(t, n), i = async () => {
      if (typeof a._options.timeout == "number" && a._options.timeout > de)
        throw new RangeError(`The \`timeout\` option cannot be greater than ${de}`);
      await Promise.resolve();
      let o = await a._fetch();
      for (const p of a._options.hooks.afterResponse) {
        const d = await p(a.request, a._options, a._decorateResponse(o.clone()));
        d instanceof globalThis.Response && (o = d);
      }
      if (a._decorateResponse(o), !o.ok && a._options.throwHttpErrors) {
        let p = new Re(o, a.request, a._options);
        for (const d of a._options.hooks.beforeError)
          p = await d(p);
        throw p;
      }
      if (a._options.onDownloadProgress) {
        if (typeof a._options.onDownloadProgress != "function")
          throw new TypeError("The `onDownloadProgress` option must be a function");
        if (!xt)
          throw new Error("Streams are not supported in your environment. `ReadableStream` is missing.");
        return a._stream(o.clone(), a._options.onDownloadProgress);
      }
      return o;
    }, r = a._options.retry.methods.includes(a.request.method.toLowerCase()) ? a._retry(i) : i();
    for (const [o, p] of Object.entries(Lt))
      r[o] = async () => {
        a.request.headers.set("accept", a.request.headers.get("accept") || p);
        const d = (await r).clone();
        if (o === "json") {
          if (d.status === 204 || (await d.clone().arrayBuffer()).byteLength === 0)
            return "";
          if (n.parseJson)
            return n.parseJson(await d.text());
        }
        return d[o]();
      };
    return r;
  }
  // eslint-disable-next-line complexity
  constructor(t, n = {}) {
    if (Object.defineProperty(this, "request", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "abortController", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_retryCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_input", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_options", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._input = t, this._options = {
      // TODO: credentials can be removed when the spec change is implemented in all browsers. Context: https://www.chromestatus.com/feature/4539473312350208
      credentials: this._input.credentials || "same-origin",
      ...n,
      headers: Ve(this._input.headers, n.headers),
      hooks: Ee({
        beforeRequest: [],
        beforeRetry: [],
        beforeError: [],
        afterResponse: []
      }, n.hooks),
      method: Ht(n.method ?? this._input.method),
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      prefixUrl: String(n.prefixUrl || ""),
      retry: Ft(n.retry),
      throwHttpErrors: n.throwHttpErrors !== !1,
      timeout: n.timeout ?? 1e4,
      fetch: n.fetch ?? globalThis.fetch.bind(globalThis)
    }, typeof this._input != "string" && !(this._input instanceof URL || this._input instanceof globalThis.Request))
      throw new TypeError("`input` must be a string, URL, or Request");
    if (this._options.prefixUrl && typeof this._input == "string") {
      if (this._input.startsWith("/"))
        throw new Error("`input` must not begin with a slash when using `prefixUrl`");
      this._options.prefixUrl.endsWith("/") || (this._options.prefixUrl += "/"), this._input = this._options.prefixUrl + this._input;
    }
    if (Bt) {
      if (this.abortController = new globalThis.AbortController(), this._options.signal) {
        const a = this._options.signal;
        this._options.signal.addEventListener("abort", () => {
          this.abortController.abort(a.reason);
        });
      }
      this._options.signal = this.abortController.signal;
    }
    if (Dt && (this._options.duplex = "half"), this.request = new globalThis.Request(this._input, this._options), this._options.searchParams) {
      const a = "?" + (typeof this._options.searchParams == "string" ? this._options.searchParams.replace(/^\?/, "") : new URLSearchParams(this._options.searchParams).toString()), i = this.request.url.replace(/(?:\?.*?)?(?=#|$)/, a);
      (Pt && this._options.body instanceof globalThis.FormData || this._options.body instanceof URLSearchParams) && !(this._options.headers && this._options.headers["content-type"]) && this.request.headers.delete("content-type"), this.request = new globalThis.Request(new globalThis.Request(i, { ...this.request }), this._options);
    }
    this._options.json !== void 0 && (this._options.body = JSON.stringify(this._options.json), this.request.headers.set("content-type", this._options.headers.get("content-type") ?? "application/json"), this.request = new globalThis.Request(this.request, { body: this._options.body }));
  }
  _calculateRetryDelay(t) {
    if (this._retryCount++, this._retryCount < this._options.retry.limit && !(t instanceof Le)) {
      if (t instanceof Re) {
        if (!this._options.retry.statusCodes.includes(t.response.status))
          return 0;
        const a = t.response.headers.get("Retry-After");
        if (a && this._options.retry.afterStatusCodes.includes(t.response.status)) {
          let i = Number(a);
          return Number.isNaN(i) ? i = Date.parse(a) - Date.now() : i *= 1e3, this._options.retry.maxRetryAfter !== void 0 && i > this._options.retry.maxRetryAfter ? 0 : i;
        }
        if (t.response.status === 413)
          return 0;
      }
      const n = this._options.retry.delay(this._retryCount);
      return Math.min(this._options.retry.backoffLimit, n);
    }
    return 0;
  }
  _decorateResponse(t) {
    return this._options.parseJson && (t.json = async () => this._options.parseJson(await t.text())), t;
  }
  async _retry(t) {
    try {
      return await t();
    } catch (n) {
      const a = Math.min(this._calculateRetryDelay(n), de);
      if (a !== 0 && this._retryCount > 0) {
        await Wt(a, { signal: this._options.signal });
        for (const i of this._options.hooks.beforeRetry)
          if (await i({
            request: this.request,
            options: this._options,
            error: n,
            retryCount: this._retryCount
          }) === He)
            return;
        return this._retry(t);
      }
      throw n;
    }
  }
  async _fetch() {
    for (const n of this._options.hooks.beforeRequest) {
      const a = await n(this.request, this._options);
      if (a instanceof Request) {
        this.request = a;
        break;
      }
      if (a instanceof Response)
        return a;
    }
    const t = qt(this.request, this._options);
    return this._options.timeout === !1 ? this._options.fetch(this.request.clone(), t) : Gt(this.request.clone(), t, this.abortController, this._options);
  }
  /* istanbul ignore next */
  _stream(t, n) {
    const a = Number(t.headers.get("content-length")) || 0;
    let i = 0;
    return t.status === 204 ? (n && n({ percent: 1, totalBytes: a, transferredBytes: i }, new Uint8Array()), new globalThis.Response(null, {
      status: t.status,
      statusText: t.statusText,
      headers: t.headers
    })) : new globalThis.Response(new globalThis.ReadableStream({
      async start(r) {
        const o = t.body.getReader();
        n && n({ percent: 0, transferredBytes: 0, totalBytes: a }, new Uint8Array());
        async function p() {
          const { done: d, value: l } = await o.read();
          if (d) {
            r.close();
            return;
          }
          if (n) {
            i += l.byteLength;
            const u = a === 0 ? 0 : i / a;
            n({ percent: u, transferredBytes: i, totalBytes: a }, l);
          }
          r.enqueue(l), await p();
        }
        await p();
      }
    }), {
      status: t.status,
      statusText: t.statusText,
      headers: t.headers
    });
  }
}
/*! MIT License © Sindre Sorhus */
const ye = (e) => {
  const t = (n, a) => te.create(n, J(e, a));
  for (const n of Ue)
    t[n] = (a, i) => te.create(a, J(e, i, { method: n }));
  return t.create = (n) => ye(J(n)), t.extend = (n) => ye(J(e, n)), t.stop = He, t;
}, Kt = ye(), jt = Kt, Xt = typeof window < "u" ? {} : { referrer: "https://sk.thorswap.net", referer: "https://sk.thorswap.net" }, Oe = jt.create({ headers: Xt }), Ae = {
  get: (e, t) => Oe.get(e, t).json(),
  post: (e, t) => Oe.post(e, t).json()
}, Se = Object.values(s), Yt = (e = "") => {
  const t = e.toUpperCase(), [n] = t.split(".");
  if (Se.includes(n))
    return !0;
  const [a] = t.split("/");
  if (Se.includes(a))
    return !0;
  throw new Error(
    `Invalid identifier: ${e}. Expected format: <Chain>.<Ticker> or <Chain>.<Ticker>-<ContractAddress>`
  );
}, q = 8, L = (e) => 10n ** BigInt(e), G = (e) => Math.log10(parseFloat(e.toString()));
function re({
  value: e,
  bigIntDecimal: t = q,
  decimal: n = q
}) {
  const a = e < 0n;
  let i = e.toString().substring(a ? 1 : 0);
  const r = n - (i.length - 1);
  r > 0 && (i = "0".repeat(r) + i);
  const o = i.length - n;
  let p = i.slice(-n);
  return parseInt(p[t]) >= 5 ? p = `${p.substring(0, t - 1)}${(parseInt(p[t - 1]) + 1).toString()}` : p = p.substring(0, t), `${a ? "-" : ""}${i.slice(0, o)}.${p}`.replace(
    /\.?0*$/,
    ""
  );
}
var U, k, P, H, ce, ke, z, ue, ne, me;
const Jt = class Fe {
  constructor(t) {
    $(this, U), $(this, P), $(this, ce), $(this, z), $(this, ne), I(this, "decimalMultiplier", 10n ** 8n), I(this, "bigIntValue", 0n), I(this, "decimal");
    const n = he(t), a = typeof t == "object";
    this.decimal = a ? t.decimal : void 0, this.decimalMultiplier = a && "decimalMultiplier" in t ? t.decimalMultiplier : L(Math.max(Ge(ae(n)), this.decimal || 0)), R(this, ce, ke).call(this, n);
  }
  static fromBigInt(t, n) {
    return new Fe({
      decimal: n,
      value: re({ value: t, bigIntDecimal: n, decimal: n })
    });
  }
  static shiftDecimals({
    value: t,
    from: n,
    to: a
  }) {
    return this.fromBigInt(
      t.getBaseValue("bigint") * L(a) / L(n),
      a
    );
  }
  set(t) {
    return new this.constructor({ decimal: this.decimal, value: t, identifier: this.toString() });
  }
  add(...t) {
    return R(this, U, k).call(this, "add", ...t);
  }
  sub(...t) {
    return R(this, U, k).call(this, "sub", ...t);
  }
  mul(...t) {
    return R(this, U, k).call(this, "mul", ...t);
  }
  div(...t) {
    return R(this, U, k).call(this, "div", ...t);
  }
  gt(t) {
    return R(this, P, H).call(this, "gt", t);
  }
  gte(t) {
    return R(this, P, H).call(this, "gte", t);
  }
  lt(t) {
    return R(this, P, H).call(this, "lt", t);
  }
  lte(t) {
    return R(this, P, H).call(this, "lte", t);
  }
  eqValue(t) {
    return R(this, P, H).call(this, "eqValue", t);
  }
  // @ts-expect-error False positive
  getValue(t) {
    const n = this.formatBigIntToSafeValue(
      this.bigIntValue,
      this.decimal || G(this.decimalMultiplier)
    );
    switch (t) {
      case "number":
        return Number(n);
      case "string":
        return n;
      case "bigint":
        return this.bigIntValue * 10n ** BigInt(this.decimal || 8n) / this.decimalMultiplier;
    }
  }
  // @ts-expect-error
  getBaseValue(t) {
    const n = this.decimalMultiplier / L(this.decimal || E.THOR), a = this.bigIntValue / n;
    switch (t) {
      case "number":
        return Number(a);
      case "string":
        return a.toString();
      case "bigint":
        return a;
    }
  }
  getBigIntValue(t, n) {
    if (!n && typeof t == "object")
      return t.bigIntValue;
    const a = he(t), i = ae(a);
    return i === "0" || i === "undefined" ? 0n : R(this, ne, me).call(this, i, n);
  }
  toSignificant(t = 6) {
    const [n, a] = this.getValue("string").split("."), i = n || "", r = a || "";
    if ((parseInt(i) ? i.length + r.length : r.length) <= t)
      return this.getValue("string");
    if (i.length >= t)
      return i.slice(0, t).padEnd(i.length, "0");
    if (parseInt(i))
      return `${i}.${r.slice(0, t - i.length)}`.padEnd(
        t - i.length,
        "0"
      );
    const o = parseInt(r), p = `${o}`.slice(0, t);
    return `0.${p.padStart(
      r.length - `${o}`.length + p.length,
      "0"
    )}`;
  }
  toFixed(t = 6) {
    const [n, a] = this.getValue("string").split("."), i = n || "", r = a || "";
    if (parseInt(i))
      return `${i}.${r.slice(0, t)}`.padEnd(t, "0");
    const o = parseInt(r), p = `${o}`.slice(0, t);
    return `0.${p.padStart(
      r.length - `${o}`.length + p.length,
      "0"
    )}`;
  }
  toAbbreviation(t = 2) {
    const n = this.getValue("number"), a = ["", "K", "M", "B", "T", "Q", "Qi", "S"], i = Math.floor(Math.log10(Math.abs(n)) / 3), r = a[i];
    if (!r)
      return this.getValue("string");
    const o = 10 ** (i * 3);
    return `${(n / o).toFixed(t)}${r}`;
  }
  toCurrency(t = "$", {
    currencyPosition: n = "start",
    decimal: a = 2,
    decimalSeparator: i = ".",
    thousandSeparator: r = ","
  } = {}) {
    const o = this.getValue("number"), [p, d = ""] = o.toFixed(6).split("."), l = p.replace(/\B(?=(\d{3})+(?!\d))/g, r), u = !p && !d ? "0.00" : p === "0" ? `${parseFloat(`0.${d}`)}`.replace(".", i) : `${l}${parseInt(d) ? `${i}${d.slice(0, a)}` : ""}`;
    return `${n === "start" ? t : ""}${u}${n === "end" ? t : ""}`;
  }
  formatBigIntToSafeValue(t, n) {
    const a = n || this.decimal || q, i = Math.max(
      a,
      G(this.decimalMultiplier)
    ), r = t < 0n, o = t.toString().substring(r ? 1 : 0), p = i - (o.length - 1), d = p > 0 ? "0".repeat(p) + o : o, l = d.length - i;
    let u = d.slice(-i);
    return parseInt(u[a]) >= 5 ? u = `${u.substring(0, a - 1)}${(parseInt(u[a - 1]) + 1).toString()}` : u = u.substring(0, a), `${r ? "-" : ""}${d.slice(
      0,
      l
    )}.${u}`.replace(/\.?0*$/, "");
  }
};
U = /* @__PURE__ */ new WeakSet(), k = function(e, ...t) {
  const n = R(this, z, ue).call(this, this, ...t), a = Math.max(n, G(this.decimalMultiplier)), i = L(a), r = t.reduce(
    (p, d) => {
      const l = this.getBigIntValue(d, a);
      switch (e) {
        case "add":
          return p + l;
        case "sub":
          return p - l;
        case "mul":
          return p * l / i;
        case "div": {
          if (l === 0n)
            throw new RangeError("Division by zero");
          return p * i / l;
        }
        default:
          return p;
      }
    },
    //normalize is to precision multiplier base
    this.bigIntValue * i / this.decimalMultiplier
  ), o = re({
    bigIntDecimal: a,
    decimal: a,
    value: r
  });
  return new this.constructor({
    decimalMultiplier: L(a),
    decimal: this.decimal,
    value: o,
    identifier: this.toString()
  });
}, P = /* @__PURE__ */ new WeakSet(), H = function(e, ...t) {
  const n = R(this, z, ue).call(this, this, ...t), a = this.getBigIntValue(t[0], n), i = this.getBigIntValue(this, n);
  switch (e) {
    case "gt":
      return i > a;
    case "gte":
      return i >= a;
    case "lt":
      return i < a;
    case "lte":
      return i <= a;
    case "eqValue":
      return i === a;
  }
}, ce = /* @__PURE__ */ new WeakSet(), ke = function(e) {
  const t = ae(e) || "0";
  this.bigIntValue = R(this, ne, me).call(this, t);
}, z = /* @__PURE__ */ new WeakSet(), ue = function(...e) {
  const t = e.map((n) => typeof n == "object" ? n.decimal || G(n.decimalMultiplier) : Ge(ae(n))).filter(Boolean);
  return Math.max(...t, q);
}, ne = /* @__PURE__ */ new WeakSet(), me = function(e, t) {
  const n = t ? L(t) : this.decimalMultiplier, a = G(n), [i = "", r = ""] = e.split(".");
  return BigInt(`${i}${r.padEnd(a, "0")}`);
};
let Te = Jt;
const Qt = Intl.NumberFormat("fullwide", {
  useGrouping: !1,
  maximumFractionDigits: 20
});
function ae(e) {
  const t = `${typeof e == "number" ? Qt.format(e) : he(e)}`.replaceAll(",", ".").split(".");
  return t.length > 1 ? `${t.slice(0, -1).join("")}.${t.at(-1)}` : t[0];
}
function Ge(e) {
  var t;
  const n = ((t = e.split(".")[1]) == null ? void 0 : t.length) || 0;
  return Math.max(n, q);
}
function he(e) {
  return typeof e == "object" ? "getValue" in e ? e.getValue("string") : e.value : e;
}
const ee = (e, t) => typeof e == "bigint" ? re({ value: e, bigIntDecimal: t, decimal: t }) : e;
let _e;
const Ie = (e) => {
  if (!_e)
    throw new Error("Static assets not loaded, call await AssetValue.loadStaticAssets() first");
  return _e.get(e.toUpperCase()) || { decimal: E.THOR, identifier: "" };
}, Ce = async (e, t = 0) => {
  Yt(e);
  const n = await At(fe(e)), a = ee(t, n);
  return new M({ decimal: n, value: a, identifier: e });
};
class M extends Te {
  constructor(t) {
    const n = "identifier" in t ? t.identifier : `${t.chain}.${t.symbol}`;
    super(
      t.value instanceof Te ? t.value : { decimal: t.decimal, value: t.value }
    ), I(this, "address"), I(this, "chain"), I(this, "isGasAsset", !1), I(this, "isSynthetic", !1), I(this, "symbol"), I(this, "tax"), I(this, "ticker"), I(this, "type");
    const a = fe(n);
    this.type = Ot(a), this.chain = a.chain, this.ticker = a.ticker, this.symbol = a.symbol, this.address = a.address, this.isSynthetic = a.isSynthetic, this.isGasAsset = a.isGasAsset, this.tax = t.tax;
  }
  toString(t = !1) {
    const n = this.isSynthetic ? this.symbol : this.ticker;
    return t ? (
      // ETH/THOR-0xa5f2211b9b8170f694421f2046281775e8468044 | USDT
      n
    ) : (
      // THOR.ETH/ETH | ETH.USDT-0x1234567890
      `${this.chain}.${this.symbol}`
    );
  }
  toUrl() {
    return this.isSynthetic ? `${this.chain}.${this.symbol.replace("/", ".")}` : this.toString();
  }
  eq({ chain: t, symbol: n }) {
    return this.chain === t && this.symbol === n;
  }
  static async fromString(t, n = 0) {
    return Ce(t, n);
  }
  static fromStringSync(t, n = 0) {
    const { isSynthetic: a } = fe(t), {
      tax: i,
      decimal: r,
      identifier: o
    } = Ie(t), p = ee(n, r);
    return o ? new M({ tax: i, decimal: r, identifier: o, value: p }) : a ? new M({ tax: i, decimal: 8, identifier: t, value: p }) : void 0;
  }
  static async fromIdentifier(t, n = 0) {
    return Ce(t, n);
  }
  static fromIdentifierSync(t, n = 0) {
    const { decimal: a, identifier: i } = Ie(t), r = ee(n, a);
    return new M({ decimal: a, identifier: i, value: r });
  }
  static fromChainOrSignature(t, n = 0) {
    const { decimal: a, identifier: i } = gt(t), r = ee(n, a);
    return new M({ value: r, decimal: a, identifier: i });
  }
  static async loadStaticAssets() {
    return new Promise(
      async (t, n) => {
        try {
          const {
            // Omit ThorchainList from import to avoid decimals conflict (TC uses 8 for all)
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            ThorchainList: a,
            NativeList: i,
            ...r
          } = await import("@coinmasters/tokens");
          _e = [i, ...Object.values(r)].reduce(
            (o, { tokens: p }) => (p.forEach(({ identifier: d, chain: l, ...u }) => {
              const c = "decimals" in u ? u.decimals : E[l];
              o.set(d, { identifier: d, decimal: c });
            }), o),
            /* @__PURE__ */ new Map()
          ), t({ ok: !0 });
        } catch (a) {
          console.error(a), n({
            ok: !1,
            error: a,
            message: "Couldn't load static assets. Ensure you have installed @coinmasters/tokens package"
          });
        }
      }
    );
  }
}
const le = (e) => {
  const t = M.fromChainOrSignature(e);
  switch (e) {
    case s.Bitcoin:
    case s.Litecoin:
    case s.BitcoinCash:
      return t.set(10001e-8);
    case s.Dogecoin:
      return t.set(1.00000001);
    case s.Avalanche:
    case s.Ethereum:
      return t.set(1e-8);
    case s.THORChain:
    case s.Maya:
      return t.set(0);
    default:
      return t.set(1e-8);
  }
}, fe = (e) => {
  const t = e.slice(0, 14).includes("/"), [n, a] = e.split(".").pop().split("/"), i = e.includes(".") && !t ? e : `${s.THORChain}.${a}`, [r, o] = i.split("."), [p, d] = (t ? a : o).split("-");
  return {
    address: d == null ? void 0 : d.toLowerCase(),
    chain: r,
    isGasAsset: Pe({ chain: r, symbol: o }),
    isSynthetic: t,
    symbol: (t ? `${n}/` : "") + (d ? `${p}-${(d == null ? void 0 : d.toLowerCase()) ?? ""}` : o),
    ticker: p
  };
}, Zt = {
  /**
   * Core
   */
  core_wallet_connection_not_found: 10001,
  core_estimated_max_spendable_chain_not_supported: 10002,
  core_extend_error: 10003,
  core_inbound_data_not_found: 10004,
  core_approve_asset_address_or_from_not_found: 10005,
  core_chain_halted: 10099,
  /**
   * Core - Wallet Connection
   */
  core_wallet_xdefi_not_installed: 10101,
  core_wallet_evmwallet_not_installed: 10102,
  core_wallet_walletconnect_not_installed: 10103,
  core_wallet_keystore_not_installed: 10104,
  core_wallet_ledger_not_installed: 10105,
  core_wallet_trezor_not_installed: 10106,
  core_wallet_keplr_not_installed: 10107,
  core_wallet_okx_not_installed: 10108,
  core_wallet_keepkey_not_installed: 10109,
  /**
   * Core - Swap
   */
  core_swap_invalid_params: 10200,
  core_swap_route_not_complete: 10201,
  core_swap_asset_not_recognized: 10202,
  core_swap_contract_not_found: 10203,
  core_swap_route_transaction_not_found: 10204,
  core_swap_contract_not_supported: 10205,
  core_swap_transaction_error: 10206,
  core_swap_quote_mode_not_supported: 10207,
  /**
   * Core - Transaction
   */
  core_transaction_deposit_error: 10301,
  core_transaction_create_liquidity_rune_error: 10302,
  core_transaction_create_liquidity_asset_error: 10303,
  core_transaction_create_liquidity_invalid_params: 10304,
  core_transaction_add_liquidity_invalid_params: 10305,
  core_transaction_add_liquidity_no_rune_address: 10306,
  core_transaction_add_liquidity_rune_error: 10307,
  core_transaction_add_liquidity_asset_error: 10308,
  core_transaction_withdraw_error: 10309,
  core_transaction_deposit_to_pool_error: 10310,
  core_transaction_deposit_insufficient_funds_error: 10311,
  core_transaction_deposit_gas_error: 10312,
  core_transaction_invalid_sender_address: 10313,
  core_transaction_deposit_server_error: 10313,
  /**
   * Wallets
   */
  wallet_ledger_connection_error: 20001,
  /**
   * Helpers
   */
  helpers_number_different_decimals: 99101
};
class m extends Error {
  constructor(t, n) {
    console.error(n, { stack: n == null ? void 0 : n.stack, message: n == null ? void 0 : n.message }), super(t, { cause: { code: Zt[t], message: t } }), Object.setPrototypeOf(this, m.prototype);
  }
}
class D extends Te {
  eq(t) {
    return this.eqValue(t);
  }
  static fromBigInt(t, n) {
    return new D({
      decimal: n,
      value: re({ value: t, bigIntDecimal: n, decimal: n })
    });
  }
}
const zt = [
  {
    inputs: [{ internalType: "address", name: "_ttp", type: "address" }],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tcRouter", type: "address" },
      { internalType: "address", name: "tcVault", type: "address" },
      { internalType: "string", name: "tcMemo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "router", type: "address" },
      { internalType: "bytes", name: "data", type: "bytes" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], en = [
  {
    inputs: [
      { internalType: "address", name: "_ttp", type: "address" },
      { internalType: "address", name: "_weth", type: "address" },
      { internalType: "address", name: "_swapRouter", type: "address" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "address", name: "from", type: "address" },
      { indexed: !1, internalType: "address", name: "token", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "uint256", name: "out", type: "uint256" },
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "vault", type: "address" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "SwapIn",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "address", name: "token", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" }
    ],
    name: "SwapOut",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address", name: "vault", type: "address" },
      { internalType: "string", name: "memo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" }
    ],
    name: "swapOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "swapRouter",
    outputs: [{ internalType: "contract IWoofi", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "weth",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], tn = [
  {
    inputs: [{ internalType: "address", name: "_ttp", type: "address" }],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "address", name: "from", type: "address" },
      { indexed: !1, internalType: "address", name: "token", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "uint256", name: "out", type: "uint256" },
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "vault", type: "address" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "SwapIn",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address", name: "vault", type: "address" },
      { internalType: "string", name: "memo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "swapRouter", type: "address" },
      { internalType: "bytes", name: "data", type: "bytes" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], nn = [
  {
    inputs: [{ internalType: "address", name: "_ttp", type: "address" }],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tcRouter", type: "address" },
      { internalType: "address", name: "tcVault", type: "address" },
      { internalType: "string", name: "tcMemo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "router", type: "address" },
      { internalType: "bytes", name: "data", type: "bytes" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], an = [
  {
    inputs: [
      { internalType: "address", name: "_ttp", type: "address" },
      { internalType: "address", name: "_wbnb", type: "address" },
      { internalType: "address", name: "_swapRouter", type: "address" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "address", name: "from", type: "address" },
      { indexed: !1, internalType: "address", name: "token", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "uint256", name: "out", type: "uint256" },
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "vault", type: "address" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "SwapIn",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "address", name: "token", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" }
    ],
    name: "SwapOut",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address", name: "vault", type: "address" },
      { internalType: "string", name: "memo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" }
    ],
    name: "swapOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "swapRouter",
    outputs: [{ internalType: "contract IPancakeRouterV2", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "wbnb",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], sn = [
  {
    inputs: [
      { internalType: "address", name: "_ttp", type: "address" },
      { internalType: "address", name: "_weth", type: "address" },
      { internalType: "address", name: "_swapRouter", type: "address" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tcRouter", type: "address" },
      { internalType: "address", name: "tcVault", type: "address" },
      { internalType: "string", name: "tcMemo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" }
    ],
    name: "swapOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "swapRouter",
    outputs: [{ internalType: "contract IUniswapRouterV2AVAX", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "weth",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], rn = [
  {
    inputs: [
      { internalType: "address", name: "_ttp", type: "address" },
      { internalType: "address", name: "_weth", type: "address" },
      { internalType: "address", name: "_swapRouter", type: "address" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tcRouter", type: "address" },
      { internalType: "address", name: "tcVault", type: "address" },
      { internalType: "string", name: "tcMemo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" }
    ],
    name: "swapOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "swapRouter",
    outputs: [{ internalType: "contract IUniswapRouterV2", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "weth",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], on = [
  {
    inputs: [
      { internalType: "address", name: "_ttp", type: "address" },
      { internalType: "address", name: "_weth", type: "address" },
      { internalType: "address", name: "_swapRouter", type: "address" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tcRouter", type: "address" },
      { internalType: "address", name: "tcVault", type: "address" },
      { internalType: "string", name: "tcMemo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" }
    ],
    name: "swapOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "swapRouter",
    outputs: [{ internalType: "contract IUniswapRouterV2AVAX", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "weth",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], pn = [
  {
    inputs: [
      { internalType: "address", name: "_ttp", type: "address" },
      { internalType: "address", name: "_weth", type: "address" },
      { internalType: "address", name: "_swapRouter", type: "address" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tcRouter", type: "address" },
      { internalType: "address", name: "tcVault", type: "address" },
      { internalType: "string", name: "tcMemo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" }
    ],
    name: "swapOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "swapRouter",
    outputs: [{ internalType: "contract IUniswapRouterV2", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "weth",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], dn = [
  {
    inputs: [
      { internalType: "address", name: "_ttp", type: "address" },
      { internalType: "address", name: "_weth", type: "address" },
      { internalType: "address", name: "_swapRouter", type: "address" },
      { internalType: "address", name: "_legToken", type: "address" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "legToken",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tcRouter", type: "address" },
      { internalType: "address", name: "tcVault", type: "address" },
      { internalType: "string", name: "tcMemo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" }
    ],
    name: "swapOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "swapRouter",
    outputs: [{ internalType: "contract IUniswapRouterV2", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "weth",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], un = [
  {
    inputs: [
      { internalType: "address", name: "_ttp", type: "address" },
      { internalType: "address", name: "_weth", type: "address" },
      { internalType: "address", name: "_swapRouter", type: "address" },
      { internalType: "uint24", name: "_poolFee", type: "uint24" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "poolFee",
    outputs: [{ internalType: "uint24", name: "", type: "uint24" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tcRouter", type: "address" },
      { internalType: "address", name: "tcVault", type: "address" },
      { internalType: "string", name: "tcMemo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" }
    ],
    name: "swapOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "swapRouter",
    outputs: [{ internalType: "contract IUniswapRouterV3", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "weth",
    outputs: [{ internalType: "contract IWETH9", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], ln = [
  {
    inputs: [
      { internalType: "address", name: "_ttp", type: "address" },
      { internalType: "address", name: "_weth", type: "address" },
      { internalType: "address", name: "_swapRouter", type: "address" },
      { internalType: "uint24", name: "_poolFee", type: "uint24" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "poolFee",
    outputs: [{ internalType: "uint24", name: "", type: "uint24" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tcRouter", type: "address" },
      { internalType: "address", name: "tcVault", type: "address" },
      { internalType: "string", name: "tcMemo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" }
    ],
    name: "swapOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "swapRouter",
    outputs: [{ internalType: "contract IUniswapRouterV3", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "weth",
    outputs: [{ internalType: "contract IWETH9", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], yn = [
  {
    inputs: [
      { internalType: "address", name: "_ttp", type: "address" },
      { internalType: "address", name: "_weth", type: "address" },
      { internalType: "address", name: "_swapRouter", type: "address" },
      { internalType: "uint24", name: "_poolFee", type: "uint24" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "poolFee",
    outputs: [{ internalType: "uint24", name: "", type: "uint24" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tcRouter", type: "address" },
      { internalType: "address", name: "tcVault", type: "address" },
      { internalType: "string", name: "tcMemo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" }
    ],
    name: "swapOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "swapRouter",
    outputs: [{ internalType: "contract IUniswapRouterV3", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "weth",
    outputs: [{ internalType: "contract IWETH9", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], cn = [
  {
    inputs: [
      { internalType: "address", name: "_ttp", type: "address" },
      { internalType: "address", name: "_weth", type: "address" },
      { internalType: "address", name: "_swapRouter", type: "address" },
      { internalType: "uint24", name: "_poolFee", type: "uint24" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "poolFee",
    outputs: [{ internalType: "uint24", name: "", type: "uint24" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tcRouter", type: "address" },
      { internalType: "address", name: "tcVault", type: "address" },
      { internalType: "string", name: "tcMemo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" }
    ],
    name: "swapOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "swapRouter",
    outputs: [{ internalType: "contract IUniswapRouterV3", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "weth",
    outputs: [{ internalType: "contract IWETH9", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], We = {
  ["0x7C38b8B2efF28511ECc14a621e263857Fb5771d3".toLowerCase()]: zt,
  ["0xB6fA6f1DcD686F4A573Fd243a6FABb4ba36Ba98c".toLowerCase()]: tn,
  ["0xd31f7e39afECEc4855fecc51b693F9A0Cec49fd2".toLowerCase()]: nn
}, mn = {
  ...We,
  // AVAX
  ["0x942c6dA485FD6cEf255853ef83a149d43A73F18a".toLowerCase()]: sn,
  ["0x5505BE604dFA8A1ad402A71f8A357fba47F9bf5a".toLowerCase()]: en,
  ["0x3b7DbdD635B99cEa39D3d95Dbd0217F05e55B212".toLowerCase()]: on,
  // BSC
  ["0x30912B38618D3D37De3191A4FFE982C65a9aEC2E".toLowerCase()]: an,
  // ETH
  ["0xbf365e79aA44A2164DA135100C57FDB6635ae870".toLowerCase()]: rn,
  ["0x86904Eb2b3c743400D03f929F2246EfA80B91215".toLowerCase()]: pn,
  ["0x3660dE6C56cFD31998397652941ECe42118375DA".toLowerCase()]: dn,
  ["0xBd68cBe6c247e2c3a0e36B8F0e24964914f26Ee8".toLowerCase()]: un,
  ["0xe4ddca21881bac219af7f217703db0475d2a9f02".toLowerCase()]: ln,
  ["0x11733abf0cdb43298f7e949c930188451a9a9ef2".toLowerCase()]: yn,
  ["0xb33874810e5395eb49d8bd7e912631db115d5a03".toLowerCase()]: cn
}, Tn = ({
  streamSwap: e,
  contractAddress: t,
  recipient: n,
  toChecksumAddress: a,
  calldata: {
    amount: i,
    amountOutMin: r = "",
    data: o = "",
    deadline: p,
    memo: d,
    router: l,
    memoStreamingSwap: u,
    tcMemo: c,
    tcRouter: h,
    tcVault: b,
    vault: _,
    token: A
  }
}) => {
  const O = !!We[t.toLowerCase()];
  if (O && !l)
    throw new Error("Router is required on calldata for swapIn with GenericContract");
  const S = c || d, B = e && u || S;
  if (!b && !_)
    throw new Error("TC Vault is required on calldata");
  if (!h && !l)
    throw new Error("TC Router is required on calldata");
  if (!B)
    throw new Error("TC Memo is required on calldata");
  if (!A)
    throw new Error("Token is required on calldata");
  const oe = [
    // v2 contracts don't have tcVault, tcRouter, tcMemo but vault, router, memo
    a(h || l),
    a(b || _),
    B.replace("{recipientAddress}", n),
    a(A),
    i
  ], qe = O ? [a(l), o, p] : [r, p];
  return [...oe, ...qe];
}, hn = ({ chain: e, txHash: t }) => {
  const n = Be[e];
  switch (e) {
    case s.Binance:
    case s.Bitcoin:
    case s.BitcoinCash:
    case s.Maya:
    case s.Kujira:
    case s.THORChain:
      return `${n}/tx/${t.startsWith("0x") ? t.slice(2) : t}`;
    case s.Arbitrum:
    case s.Avalanche:
    case s.BinanceSmartChain:
    case s.Ethereum:
    case s.Optimism:
    case s.Polygon:
      return `${n}/tx/${t.startsWith("0x") ? t : `0x${t}`}`;
    case s.Cosmos:
      return `${n}/transactions/${t}`;
    case s.Dogecoin:
      return `${n}/transaction/${t.toLowerCase()}`;
    case s.Litecoin:
      return `${n}/${t}`;
    default:
      throw new Error(`Unsupported chain: ${e}`);
  }
}, _n = ({ chain: e, address: t }) => {
  const n = Be[e];
  switch (e) {
    case s.Arbitrum:
    case s.Avalanche:
    case s.Binance:
    case s.BinanceSmartChain:
    case s.Bitcoin:
    case s.BitcoinCash:
    case s.Dogecoin:
    case s.Ethereum:
    case s.Maya:
    case s.Optimism:
    case s.Polygon:
    case s.Kujira:
    case s.THORChain:
      return `${n}/address/${t}`;
    case s.Cosmos:
      return `${n}/account/${t}`;
    case s.Litecoin:
      return `${n}/${t}`;
    default:
      throw new Error(`Unsupported chain: ${e}`);
  }
}, fn = (e) => {
  const t = e ? W.ThornodeStagenet : W.ThornodeMainnet;
  return Ae.get(`${t}/thorchain/inbound_addresses`);
}, bn = (e) => {
  const t = e ? W.ThornodeStagenet : W.ThornodeMainnet;
  return Ae.get(`${t}/thorchain/mimir`);
}, ve = () => Object.values(s).reduce(
  (e, t) => (e[t] = null, e),
  {}
), wn = async ({
  chain: e,
  address: t
}) => {
  if (!t)
    return !1;
  switch (e) {
    case s.Bitcoin:
      return !t.startsWith("bc1p");
    default:
      return !0;
  }
};
var V, se, K, C, j, X;
class Fn {
  constructor({ stagenet: t } = {}) {
    T(this, "connectedChains", ve());
    T(this, "connectedWallets", ve());
    T(this, "stagenet", !1);
    T(this, "getAddress", (t) => {
      var n;
      return ((n = this.connectedChains[t]) == null ? void 0 : n.address) || "";
    });
    T(this, "getExplorerTxUrl", (t, n) => hn({ chain: t, txHash: n }));
    T(this, "getWallet", (t) => this.connectedWallets[t]);
    T(this, "getExplorerAddressUrl", (t, n) => _n({ chain: t, address: n }));
    T(this, "getBalance", async (t, n) => {
      const a = await this.getWalletByChain(t, n);
      return (a == null ? void 0 : a.balance) || [];
    });
    T(this, "swap", async ({ streamSwap: t, recipient: n, route: a, feeOptionKey: i }) => {
      var p, d;
      const { quoteMode: r } = a.meta, o = r.startsWith("ERC20-") ? s.Ethereum : r.startsWith("ARC20-") ? s.Avalanche : s.BinanceSmartChain;
      if (!a.complete)
        throw new m("core_swap_route_not_complete");
      try {
        if (tt.includes(r)) {
          const l = this.connectedWallets[o];
          if (!(l != null && l.sendTransaction))
            throw new m("core_wallet_connection_not_found");
          if (!(t ? (p = a == null ? void 0 : a.streamingSwap) == null ? void 0 : p.transaction : a == null ? void 0 : a.transaction))
            throw new m("core_swap_route_transaction_not_found");
          const { data: c, from: h, to: b, value: _ } = a.transaction, A = {
            data: c,
            from: h,
            to: b.toLowerCase(),
            chainId: BigInt(lt[o]),
            value: _ ? BigInt(_) : 0n
          };
          return l.sendTransaction(A, i);
        }
        if (at.includes(r)) {
          if (!a.calldata.fromAsset)
            throw new m("core_swap_asset_not_recognized");
          const l = await M.fromString(a.calldata.fromAsset);
          if (!l)
            throw new m("core_swap_asset_not_recognized");
          const { address: u } = await w(this, V).call(this, l.chain), {
            contract: c,
            calldata: { expiration: h, amountIn: b, memo: _, memoStreamingSwap: A }
          } = a, O = l.add(D.fromBigInt(BigInt(b), l.decimal)), S = t && A || _;
          return this.deposit({
            expiration: h,
            assetValue: O,
            memo: S,
            feeOptionKey: i,
            router: c,
            recipient: u
          });
        }
        if (nt.includes(r)) {
          const { calldata: l, contract: u } = a;
          if (!u)
            throw new m("core_swap_contract_not_found");
          const c = this.connectedWallets[o], h = this.getAddress(o);
          if (!(c != null && c.sendTransaction) || !h)
            throw new m("core_wallet_connection_not_found");
          const { getProvider: b, toChecksumAddress: _ } = await import("@coinmasters/toolbox-evm"), A = b(o), O = mn[u.toLowerCase()];
          if (!O)
            throw new m("core_swap_contract_not_supported", { contractAddress: u });
          const B = await (await ((d = c.createContract) == null ? void 0 : d.call(c, u, O, A))).getFunction("swapIn").populateTransaction(
            ...Tn({
              streamSwap: t,
              toChecksumAddress: _,
              contractAddress: u,
              recipient: n,
              calldata: l
            }),
            { from: h }
          );
          return c.sendTransaction(B, i);
        }
        throw new m("core_swap_quote_mode_not_supported", { quoteMode: r });
      } catch (l) {
        throw new m("core_swap_transaction_error", l);
      }
    });
    T(this, "getWalletByChain", async (t, n) => {
      var o, p, d, l, u;
      const a = this.getAddress(t);
      if (console.log("getWalletByChain: address: ", a), !a)
        return null;
      console.log("chain: ", t), console.log("address: ", a);
      let i = [];
      (o = this.getWallet(t)) != null && o.getPubkeys && (i = await ((p = this.getWallet(t)) == null ? void 0 : p.getPubkeys())), console.log(" getWalletByChain " + t + ": pubkeys: ", i);
      let r = [];
      if (i.length === 0)
        console.log("Get balance for Address! address: " + a), console.log("Get balance for Address! chain: " + t), r = await ((d = this.getWallet(t)) == null ? void 0 : d.getBalance([{ address: a }])), console.log("balance: ", r);
      else {
        console.log(t + " pubkeys: ", i);
        let c = 0;
        for (let h = 0; h < i.length; h++) {
          const b = i[h];
          console.log("Get balance for xpub!"), console.log("getBalance: ", b);
          let _ = await ((l = this.getWallet(t)) == null ? void 0 : l.getBalance([{ pubkey: b }]));
          _ = _[0].toFixed(_.decimal), isNaN(_) && (_ = 0), i[h].balance = _, c += _;
        }
        r = [M.fromChainOrSignature(t, c)];
      }
      return this.connectedChains[t] = {
        address: a,
        pubkeys: i,
        balance: r,
        walletType: (u = this.connectedChains[t]) == null ? void 0 : u.walletType
      }, { ...this.connectedChains[t] };
    });
    T(this, "approveAssetValue", (t, n) => w(this, K).call(this, { assetValue: t, type: "approve", contractAddress: n }));
    T(this, "isAssetValueApproved", (t, n) => w(this, K).call(this, { assetValue: t, contractAddress: n, type: "checkOnly" }));
    T(this, "validateAddress", ({ address: t, chain: n }) => {
      var a, i;
      return (i = (a = this.getWallet(n)) == null ? void 0 : a.validateAddress) == null ? void 0 : i.call(a, t);
    });
    T(this, "transfer", async (t) => {
      const n = this.connectedWallets[t.assetValue.chain];
      if (!n)
        throw new m("core_wallet_connection_not_found");
      try {
        return await n.transfer(w(this, X).call(this, t));
      } catch (a) {
        throw new m("core_swap_transaction_error", a);
      }
    });
    T(this, "deposit", async ({
      assetValue: t,
      recipient: n,
      router: a,
      ...i
    }) => {
      const { chain: r, symbol: o, ticker: p } = t, d = this.connectedWallets[r];
      if (!await wn({ address: await (d == null ? void 0 : d.getAddress()), chain: r }))
        throw new m("core_transaction_invalid_sender_address");
      if (!d)
        throw new m("core_wallet_connection_not_found");
      const l = w(this, X).call(this, { assetValue: t, recipient: n, router: a, ...i });
      try {
        switch (r) {
          case s.THORChain: {
            const u = d;
            return await (n === "" ? u.deposit(l) : u.transfer(l));
          }
          case s.Ethereum:
          case s.BinanceSmartChain:
          case s.Avalanche: {
            const { getChecksumAddressFromAsset: u } = await import("@coinmasters/toolbox-evm"), c = r === s.Avalanche ? Ze : r === s.BinanceSmartChain ? ze : Qe;
            return await d.call({
              abi: c,
              contractAddress: a || (await w(this, V).call(this, r)).router,
              funcName: "depositWithExpiry",
              funcParams: [
                n,
                u({ chain: r, symbol: o, ticker: p }, r),
                t.getBaseValue("string"),
                l.memo,
                i.expiration || parseInt(`${((/* @__PURE__ */ new Date()).getTime() + 15 * 60 * 1e3) / 1e3}`)
              ],
              txOverrides: {
                from: l.from,
                value: t.isGasAsset ? t.getBaseValue("bigint") : void 0
              }
            });
          }
          default:
            return await d.transfer(l);
        }
      } catch (u) {
        const c = ((u == null ? void 0 : u.message) || (u == null ? void 0 : u.toString())).toLowerCase(), h = c == null ? void 0 : c.includes("insufficient funds"), b = c == null ? void 0 : c.includes("gas"), _ = c == null ? void 0 : c.includes("server"), A = h ? "core_transaction_deposit_insufficient_funds_error" : b ? "core_transaction_deposit_gas_error" : _ ? "core_transaction_deposit_server_error" : "core_transaction_deposit_error";
        throw new m(A, u);
      }
    });
    /**
     * TC related Methods
     */
    T(this, "createLiquidity", async ({
      runeAssetValue: t,
      assetValue: n
    }) => {
      if (t.lte(0) || n.lte(0))
        throw new m("core_transaction_create_liquidity_invalid_params");
      let a = "", i = "";
      try {
        a = await w(this, C).call(this, {
          assetValue: t,
          memo: N(f.DEPOSIT, {
            ...n,
            address: this.getAddress(n.chain)
          })
        });
      } catch (r) {
        throw new m("core_transaction_create_liquidity_rune_error", r);
      }
      try {
        i = await w(this, C).call(this, {
          assetValue: n,
          memo: N(f.DEPOSIT, {
            ...n,
            address: this.getAddress(s.THORChain)
          })
        });
      } catch (r) {
        throw new m("core_transaction_create_liquidity_asset_error", r);
      }
      return { runeTx: a, assetTx: i };
    });
    T(this, "addLiquidity", async ({
      runeAssetValue: t,
      assetValue: n,
      runeAddr: a,
      assetAddr: i,
      isPendingSymmAsset: r,
      mode: o = "sym"
    }) => {
      const { chain: p, symbol: d } = n, l = o === "sym", u = (t == null ? void 0 : t.gt(0)) && (l || o === "rune"), c = (n == null ? void 0 : n.gt(0)) && (l || o === "asset"), h = r || u, b = h ? a || this.getAddress(s.THORChain) : "", _ = l || o === "asset" ? i || this.getAddress(p) : "";
      if (!u && !c)
        throw new m("core_transaction_add_liquidity_invalid_params");
      if (h && !b)
        throw new m("core_transaction_add_liquidity_no_rune_address");
      let A, O;
      if (u && t)
        try {
          A = await w(this, C).call(this, {
            assetValue: t,
            memo: N(f.DEPOSIT, { chain: p, symbol: d, address: _ })
          });
        } catch (S) {
          throw new m("core_transaction_add_liquidity_rune_error", S);
        }
      if (c && n)
        try {
          O = await w(this, C).call(this, {
            assetValue: n,
            memo: N(f.DEPOSIT, { chain: p, symbol: d, address: b })
          });
        } catch (S) {
          throw new m("core_transaction_add_liquidity_asset_error", S);
        }
      return { runeTx: A, assetTx: O };
    });
    T(this, "addLiquidityPart", ({
      assetValue: t,
      poolAddress: n,
      address: a,
      symmetric: i
    }) => {
      if (i && !a)
        throw new m("core_transaction_add_liquidity_invalid_params");
      const r = i && a || "";
      return w(this, C).call(this, { assetValue: t, memo: `+:${n}:${r}:t:0` });
    });
    T(this, "withdraw", async ({
      memo: t,
      assetValue: n,
      percent: a,
      from: i,
      to: r
    }) => {
      const o = r === "rune" ? M.fromChainOrSignature(s.THORChain) : i === "sym" && r === "sym" || i === "rune" || i === "asset" ? void 0 : n, p = le(i === "asset" ? n.chain : s.THORChain), d = t || N(f.WITHDRAW, {
        symbol: n.symbol,
        chain: n.chain,
        ticker: n.ticker,
        basisPoints: Math.max(1e4, Math.round(a * 100)),
        targetAssetString: o == null ? void 0 : o.toString(),
        singleSide: !1
      });
      return w(this, C).call(this, { assetValue: p, memo: d });
    });
    T(this, "savings", async ({
      assetValue: t,
      memo: n,
      percent: a,
      type: i
    }) => {
      const r = i === "add" ? f.DEPOSIT : f.WITHDRAW, o = n || N(r, {
        ticker: t.ticker,
        symbol: t.symbol,
        chain: t.chain,
        singleSide: !0,
        basisPoints: a ? Math.min(1e4, Math.round(a * 100)) : void 0
      }), p = r === f.DEPOSIT ? t : le(t.chain);
      return w(this, C).call(this, { memo: o, assetValue: p });
    });
    T(this, "loan", ({
      assetValue: t,
      memo: n,
      minAmount: a,
      type: i
    }) => w(this, C).call(this, {
      assetValue: t,
      memo: n || N(i === "open" ? f.OPEN_LOAN : f.CLOSE_LOAN, {
        asset: t.toString(),
        minAmount: a.toString(),
        address: this.getAddress(t.chain)
      })
    }));
    T(this, "nodeAction", ({
      type: t,
      assetValue: n,
      address: a
    }) => {
      const i = t === "bond" ? f.BOND : t === "unbond" ? f.UNBOND : f.LEAVE, r = N(i, {
        address: a,
        unbondAmount: t === "unbond" ? n.getBaseValue("number") : void 0
      });
      return w(this, j).call(this, {
        memo: r,
        assetValue: t === "bond" ? n : le(s.THORChain)
      });
    });
    T(this, "registerThorname", ({
      assetValue: t,
      ...n
    }) => w(this, j).call(this, { assetValue: t, memo: N(f.THORNAME_REGISTER, n) }));
    T(this, "extend", ({ wallets: t, config: n, apis: a = {}, rpcUrls: i = {} }) => {
      try {
        t.forEach((r) => {
          this[r.connectMethodName] = r.connect({
            addChain: w(this, se),
            config: n || {},
            apis: a,
            rpcUrls: i
          });
        });
      } catch (r) {
        throw new m("core_extend_error", r);
      }
    });
    T(this, "estimateMaxSendableAmount", async ({
      chain: t,
      params: n
    }) => {
      const a = this.getWallet(t);
      switch (t) {
        case s.Arbitrum:
        case s.Avalanche:
        case s.BinanceSmartChain:
        case s.Ethereum:
        case s.Optimism:
        case s.Polygon: {
          const { estimateMaxSendableAmount: i } = await import("@coinmasters/toolbox-evm");
          return i({
            ...n,
            toolbox: a
          });
        }
        case s.Bitcoin:
        case s.BitcoinCash:
        case s.Dogecoin:
        case s.Litecoin:
          return a.estimateMaxSendableAmount(n);
        case s.Binance:
        case s.THORChain:
        case s.Cosmos: {
          const { estimateMaxSendableAmount: i } = await import("@coinmasters/toolbox-cosmos");
          return i({
            ...n,
            toolbox: a
          });
        }
        default:
          throw new m("core_estimated_max_spendable_chain_not_supported");
      }
    });
    /**
     * Wallet connection methods
     */
    T(this, "connectXDEFI", async (t) => {
      throw new m("core_wallet_xdefi_not_installed");
    });
    T(this, "connectEVMWallet", async (t, n) => {
      throw new m("core_wallet_evmwallet_not_installed");
    });
    T(this, "connectWalletconnect", async (t, n) => {
      throw new m("core_wallet_walletconnect_not_installed");
    });
    T(this, "connectKeystore", async (t, n) => {
      throw new m("core_wallet_keystore_not_installed");
    });
    T(this, "connectKeepkey", async (t, n) => {
      throw new m("core_wallet_keepkey_not_installed");
    });
    T(this, "connectLedger", async (t, n) => {
      throw new m("core_wallet_ledger_not_installed");
    });
    T(this, "connectTrezor", async (t, n) => {
      throw new m("core_wallet_trezor_not_installed");
    });
    T(this, "connectKeplr", async (t) => {
      throw new m("core_wallet_keplr_not_installed");
    });
    T(this, "connectOkx", async (t) => {
      throw new m("core_wallet_okx_not_installed");
    });
    T(this, "disconnectChain", (t) => {
      this.connectedChains[t] = null, this.connectedWallets[t] = null;
    });
    x(this, V, async (t) => {
      if (t === s.THORChain)
        return {
          gas_rate: "0",
          router: "0",
          address: "",
          halted: !1,
          chain: s.THORChain
        };
      const a = (await fn(this.stagenet)).find((i) => i.chain === t);
      if (!a)
        throw new m("core_inbound_data_not_found");
      if (a != null && a.halted)
        throw new m("core_chain_halted");
      return a;
    });
    x(this, se, ({ chain: t, wallet: n, walletMethods: a }) => {
      this.connectedChains[t] = n, this.connectedWallets[t] = a;
    });
    x(this, K, async ({
      assetValue: t,
      type: n = "checkOnly",
      contractAddress: a
    }) => {
      const { address: i, chain: r, isGasAsset: o, isSynthetic: p } = t, d = [s.Ethereum, s.Avalanche, s.BinanceSmartChain].includes(r);
      if (d && o || !d || p)
        return !0;
      const u = this.connectedWallets[r], c = n === "checkOnly" ? u == null ? void 0 : u.isApproved : u == null ? void 0 : u.approve;
      if (!c)
        throw new m("core_wallet_connection_not_found");
      const h = this.getAddress(r);
      if (!i || !h)
        throw new m("core_approve_asset_address_or_from_not_found");
      const b = a || (await w(this, V).call(this, r)).router;
      return c({
        amount: t.getBaseValue("bigint"),
        assetAddress: i,
        from: h,
        spenderAddress: b
      });
    });
    x(this, C, async ({
      assetValue: t,
      memo: n,
      feeOptionKey: a = F.Fast
    }) => {
      const {
        gas_rate: i,
        router: r,
        address: o
      } = await w(this, V).call(this, t.chain), p = (parseInt(i) || 0) * Rt[a];
      return this.deposit({
        assetValue: t,
        recipient: o,
        memo: n,
        router: r,
        feeRate: p
      });
    });
    x(this, j, async ({ memo: t, assetValue: n }) => {
      const a = await bn(this.stagenet);
      if (a.HALTCHAINGLOBAL >= 1 || a.HALTTHORCHAIN >= 1)
        throw new m("core_chain_halted");
      return this.deposit({ assetValue: n, recipient: "", memo: t });
    });
    x(this, X, ({ assetValue: t, ...n }) => ({
      ...n,
      memo: n.memo || "",
      from: this.getAddress(t.chain),
      assetValue: t
    }));
    this.stagenet = !!t;
  }
}
V = new WeakMap(), se = new WeakMap(), K = new WeakMap(), C = new WeakMap(), j = new WeakMap(), X = new WeakMap();
export {
  tt as AGG_SWAP,
  Rn as ApiError,
  W as ApiUrl,
  M as AssetValue,
  E as BaseDecimal,
  Te as BigIntArithmetics,
  s as Chain,
  be as ChainId,
  Mn as ChainIdToChain,
  lt as ChainToChainId,
  Be as ChainToExplorerUrl,
  vn as ChainToHexChainId,
  rt as ChainToNetworkId,
  yt as ChainToRPC,
  pt as ContractAddress,
  In as CosmosChainList,
  dt as DerivationPath,
  y as ERROR_CODE,
  st as ERROR_MODULE,
  Me as ERROR_TYPE,
  Q as EVMChainList,
  ct as ErrorCode,
  F as FeeOption,
  f as MemoType,
  On as NetworkDerivationPath,
  ot as NetworkIdToChain,
  et as QuoteMode,
  De as RPCUrl,
  Ae as RequestClient,
  nt as SWAP_IN,
  at as SWAP_OUT,
  Fn as SwapKitCore,
  m as SwapKitError,
  D as SwapKitNumber,
  Ze as TCAvalancheDepositABI,
  ze as TCBscDepositABI,
  Qe as TCEthereumVaultAbi,
  Cn as TCSupportedChainList,
  Sn as UTXOChainList,
  mt as WalletOption,
  Dn as assetFromString,
  Nn as availableChainsByWallet,
  kn as derivationPathToString,
  An as erc20ABI,
  Bn as filterAssets,
  re as formatBigIntToSafeValue,
  Rt as gasFeeMultiplier,
  Ot as getAssetType,
  vt as getAsymmetricAssetShare,
  Pn as getAsymmetricAssetWithdrawAmount,
  Ct as getAsymmetricRuneShare,
  xn as getAsymmetricRuneWithdrawAmount,
  gn as getChainEnumValue,
  gt as getCommonAssetInfo,
  At as getDecimal,
  Vn as getEstimatedPoolShare,
  Un as getLiquiditySlippage,
  N as getMemoFor,
  le as getMinAmountByChain,
  Mt as getSymmetricPoolShare,
  Ln as getSymmetricWithdraw,
  Hn as getTHORNameCost,
  Pe as isGasAsset,
  $n as validateTHORName
};
