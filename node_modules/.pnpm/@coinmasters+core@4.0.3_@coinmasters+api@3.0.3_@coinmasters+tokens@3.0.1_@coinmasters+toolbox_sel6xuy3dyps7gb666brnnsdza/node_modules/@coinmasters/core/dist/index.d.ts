import type { ARBToolbox } from '@coinmasters/toolbox-evm';
import { AssetValue } from '@coinmasters/helpers';
import type { AVAXToolbox } from '@coinmasters/toolbox-evm';
import type { BCHToolbox } from '@coinmasters/toolbox-utxo';
import type { BinanceToolbox } from '@coinmasters/toolbox-cosmos';
import type { BSCToolbox } from '@coinmasters/toolbox-evm';
import type { BTCToolbox } from '@coinmasters/toolbox-utxo';
import { Chain } from '@coinmasters/types';
import type { DepositParam } from '@coinmasters/toolbox-cosmos';
import type { DOGEToolbox } from '@coinmasters/toolbox-utxo';
import type { ETHToolbox } from '@coinmasters/toolbox-evm';
import type { EVMWalletOptions } from '@coinmasters/types';
import type { ExtendParams } from '@coinmasters/types';
import type { FeeOption } from '@coinmasters/types';
import type { GaiaToolbox } from '@coinmasters/toolbox-cosmos';
import type { KujiraToolbox } from '@coinmasters/toolbox-cosmos';
import type { LTCToolbox } from '@coinmasters/toolbox-utxo';
import type { MATICToolbox } from '@coinmasters/toolbox-evm';
import type { OPToolbox } from '@coinmasters/toolbox-evm';
import type { QuoteRoute } from '@coinmasters/api';
import type { SwapKitNumber } from '@coinmasters/helpers';
import type { ThorchainToolboxType } from '@coinmasters/toolbox-cosmos';
import type { ThornameRegisterParam } from '@coinmasters/helpers';
import type { WalletOption } from '@coinmasters/types';

export declare type AddLiquidityTxns = {
    runeTx?: string;
    assetTx?: string;
};

declare type BaseWalletMethods = {
    getAddress: () => Promise<string> | string;
    getPubkey: (path: any) => Promise<string> | string;
};

export declare type ChainWallet = {
    address: string;
    pubkeys: any;
    balance: AssetValue[];
    walletType: WalletOption;
};

export declare type CoreTxParams = {
    assetValue: AssetValue;
    recipient: string;
    memo?: string;
    feeOptionKey?: FeeOption;
    feeRate?: number;
    data?: string;
    from?: string;
    expiration?: number;
};

export declare type CosmosBasedWallet<T extends typeof BinanceToolbox | typeof GaiaToolbox> = BaseWalletMethods & ReturnType<T> & {
    transfer: (params: CoreTxParams) => Promise<string>;
};

export declare type EVMWallet<T extends typeof AVAXToolbox | typeof BSCToolbox | typeof ETHToolbox | typeof OPToolbox> = BaseWalletMethods & ReturnType<T> & {
    transfer: (params: CoreTxParams) => Promise<string>;
};

export declare class SwapKitCore<T = ''> {

    connectedChains: Wallet;
    connectedWallets: WalletMethods;
    readonly stagenet: boolean;
    constructor({ stagenet }?: {
        stagenet?: boolean;
    } | undefined);
    getAddress: (chain: Chain) => string;
    getExplorerTxUrl: (chain: Chain, txHash: string) => string;
    getWallet: (chain: Chain) => any;
    getExplorerAddressUrl: (chain: Chain, address: string) => string;
    getBalance: (chain: Chain, potentialScamFilter?: boolean) => Promise<AssetValue[]>;
    swap: ({ streamSwap, recipient, route, feeOptionKey }: SwapParams) => Promise<any>;
    getWalletByChain: (chain: Chain, potentialScamFilter?: boolean) => Promise<{
        address?: string | undefined;
        pubkeys?: any;
        balance?: AssetValue[] | undefined;
        walletType?: WalletOption | undefined;
    } | null>;
    approveAssetValue: (assetValue: AssetValue, contractAddress?: string) => Promise<string | true>;
    isAssetValueApproved: (assetValue: AssetValue, contractAddress?: string) => Promise<boolean>;
    validateAddress: ({ address, chain }: {
        address: string;
        chain: Chain;
    }) => any;
    transfer: (params: CoreTxParams & {
        router?: string;
    }) => Promise<any>;
    deposit: ({ assetValue, recipient, router, ...rest }: CoreTxParams & {
        router?: string | undefined;
    }) => Promise<any>;
    /**
     * TC related Methods
     */
    createLiquidity: ({ runeAssetValue, assetValue, }: {
        runeAssetValue: AssetValue;
        assetValue: AssetValue;
    }) => Promise<{
        runeTx: string;
        assetTx: string;
    }>;
    addLiquidity: ({ runeAssetValue, assetValue, runeAddr, assetAddr, isPendingSymmAsset, mode, }: {
        runeAssetValue: AssetValue;
        assetValue: AssetValue;
        isPendingSymmAsset?: boolean | undefined;
        runeAddr?: string | undefined;
        assetAddr?: string | undefined;
        mode?: "sym" | "rune" | "asset" | undefined;
    }) => Promise<{
        runeTx: any;
        assetTx: any;
    }>;
    addLiquidityPart: ({ assetValue, poolAddress, address, symmetric, }: {
        assetValue: AssetValue;
        address?: string | undefined;
        poolAddress: string;
        symmetric: boolean;
    }) => Promise<any>;
    withdraw: ({ memo, assetValue, percent, from, to, }: {
        memo?: string | undefined;
        assetValue: AssetValue;
        percent: number;
        from: 'sym' | 'rune' | 'asset';
        to: 'sym' | 'rune' | 'asset';
    }) => Promise<any>;
    savings: ({ assetValue, memo, percent, type, }: {
        assetValue: AssetValue;
        memo?: string | undefined;
    } & ({
        type: 'add';
        percent?: undefined;
    } | {
        type: 'withdraw';
        percent: number;
    })) => Promise<any>;
    loan: ({ assetValue, memo, minAmount, type, }: {
        assetValue: AssetValue;
        memo?: string | undefined;
        minAmount: AssetValue;
        type: 'open' | 'close';
    }) => Promise<any>;
    nodeAction: ({ type, assetValue, address, }: {
        address: string;
    } & ({
        type: 'bond' | 'unbond';
        assetValue: AssetValue;
    } | {
        type: 'leave';
        assetValue?: undefined;
    })) => Promise<any>;
    registerThorname: ({ assetValue, ...param }: ThornameRegisterParam & {
        assetValue: AssetValue;
    }) => Promise<any>;
    extend: ({ wallets, config, apis, rpcUrls }: ExtendParams<T>) => void;
    estimateMaxSendableAmount: ({ chain, params, }: {
        chain: Chain;
        params: {
            from: string;
            recipient: string;
            assetValue: AssetValue;
        };
    }) => Promise<any>;
    /**
     * Wallet connection methods
     */
    connectXDEFI: (_chains: Chain[]) => Promise<void>;
    connectEVMWallet: (_chains: Chain[] | Chain, _wallet: EVMWalletOptions) => Promise<void>;
    connectWalletconnect: (_chains: Chain[], _options?: any) => Promise<void>;
    connectKeystore: (_chains: Chain[], _phrase: string) => Promise<void>;
    connectKeepkey: (_chains: Chain[], paths: any) => Promise<string>;
    connectLedger: (_chains: Chain, _derivationPath: number[]) => Promise<void>;
    connectTrezor: (_chains: Chain, _derivationPath: number[]) => Promise<void>;
    connectKeplr: (_chain: Chain) => Promise<void>;
    connectOkx: (_chains: Chain[]) => Promise<void>;
    disconnectChain: (chain: Chain) => void;
}

export declare type SwapParams = {
    recipient: string;
    streamSwap?: boolean;
    route: QuoteRoute;
    feeOptionKey: FeeOption;
};

export declare type ThorchainWallet = BaseWalletMethods & ThorchainToolboxType & {
    transfer: (params: CoreTxParams) => Promise<string>;
    deposit: (params: DepositParam) => Promise<string>;
};

export declare type UpgradeParams = {
    runeAmount: SwapKitNumber;
    recipient: string;
};

export declare type UTXOWallet<T extends typeof BCHToolbox | typeof BTCToolbox | typeof DOGEToolbox | typeof LTCToolbox> = BaseWalletMethods & ReturnType<T> & {
    transfer: (prams: CoreTxParams) => Promise<string>;
};

export declare type Wallet = Record<Chain, ChainWallet | null>;

export declare type WalletMethods = {
    [Chain.Arbitrum]: EVMWallet<typeof ARBToolbox> | null;
    [Chain.Avalanche]: EVMWallet<typeof AVAXToolbox> | null;
    [Chain.BinanceSmartChain]: EVMWallet<typeof BSCToolbox> | null;
    [Chain.Binance]: CosmosBasedWallet<typeof BinanceToolbox> | null;
    [Chain.BitcoinCash]: UTXOWallet<typeof BCHToolbox> | null;
    [Chain.Bitcoin]: UTXOWallet<typeof BTCToolbox> | null;
    [Chain.Cosmos]: CosmosBasedWallet<typeof GaiaToolbox> | null;
    [Chain.Dogecoin]: UTXOWallet<typeof DOGEToolbox> | null;
    [Chain.Ethereum]: EVMWallet<typeof ETHToolbox> | null;
    [Chain.Kujira]: CosmosBasedWallet<typeof KujiraToolbox> | null;
    [Chain.Litecoin]: UTXOWallet<typeof LTCToolbox> | null;
    [Chain.Maya]: ThorchainWallet | null;
    [Chain.Optimism]: EVMWallet<typeof OPToolbox> | null;
    [Chain.Polygon]: EVMWallet<typeof MATICToolbox> | null;
    [Chain.THORChain]: ThorchainWallet | null;
};


export * from "@coinmasters/helpers";
export * from "@coinmasters/types";

export { }
