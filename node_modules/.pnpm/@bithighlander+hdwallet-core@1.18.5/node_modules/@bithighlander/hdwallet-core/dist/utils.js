"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isIndexable = exports.compatibleBufferConcat = exports.checkBufferConcat = exports.untouchable = exports.mustBeDefined = exports.toArrayBuffer = exports.relativePath = exports.hardenedPath = exports.satsFromStr = exports.slip44ByCoin = exports.base64toHEX = exports.stripHexPrefixAndLower = exports.stripHexPrefix = exports.takeFirstOfManyEvents = exports.bip32Like = exports.addressNListToBIP32 = exports.bip32ToAddressNList = exports.arrayify = exports.toHexString = exports.fromHexString = exports.isArray = exports.LONG_TIMEOUT = exports.DEFAULT_TIMEOUT = void 0;
const Rx = __importStar(require("rxjs"));
const RxOp = __importStar(require("rxjs/operators"));
exports.DEFAULT_TIMEOUT = 5000; // 5 seconds
exports.LONG_TIMEOUT = 5 * 60 * 1000; // 5 minutes
exports.isArray = Array.isArray ||
    function (obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
    };
// These helper functions marshal hex into and out of UInt8Arrays which are consumed by protobuf js
const fromHexString = (hexString) => {
    const match = hexString.match(/.{1,2}/g) || [];
    return new Uint8Array(match.map((byte) => parseInt(byte, 16)));
};
exports.fromHexString = fromHexString;
// export const toHexString = (bytes: number[]) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '')
function toHexString(arr) {
    return Array.prototype.map.call(arr, (x) => ("00" + x.toString(16)).slice(-2)).join("");
}
exports.toHexString = toHexString;
// Copying this from ethers.js until their elliptic dep stops being circular
function arrayify(value) {
    if (value === null) {
        throw new Error("cannot convert null value to array");
    }
    else if (typeof value !== "string") {
        throw new Error("can only convert hex strings");
    }
    let match = value.match(/^(0x)?[0-9a-fA-F]*$/);
    if (!match) {
        throw new Error("invalid hexadecimal string");
    }
    if (match[1] !== "0x") {
        throw new Error("hex string must have 0x prefix");
    }
    value = value.substring(2);
    if (value.length % 2) {
        value = "0" + value;
    }
    const result = [];
    for (let i = 0; i < value.length; i += 2) {
        result.push(parseInt(value.substr(i, 2), 16));
    }
    return new Uint8Array(result);
}
exports.arrayify = arrayify;
const HARDENED = 0x80000000;
function bip32ToAddressNList(path) {
    if (!bip32Like(path)) {
        throw new Error(`Not a bip32 path: '${path}'`);
    }
    if (/^m\//i.test(path)) {
        path = path.slice(2);
    }
    const segments = path.split("/");
    if (segments.length === 1 && segments[0] === "")
        return [];
    const ret = new Array(segments.length);
    for (let i = 0; i < segments.length; i++) {
        const tmp = /(\d+)([hH\']?)/.exec(segments[i]);
        if (tmp === null) {
            throw new Error("Invalid input");
        }
        ret[i] = parseInt(tmp[1], 10);
        if (ret[i] >= HARDENED) {
            throw new Error("Invalid child index");
        }
        if (tmp[2] === "h" || tmp[2] === "H" || tmp[2] === "'") {
            ret[i] += HARDENED;
        }
        else if (tmp[2].length !== 0) {
            throw new Error("Invalid modifier");
        }
    }
    return ret;
}
exports.bip32ToAddressNList = bip32ToAddressNList;
function addressNListToBIP32(address) {
    return `m/${address.map((num) => (num >= HARDENED ? `${num - HARDENED}'` : num)).join("/")}`;
}
exports.addressNListToBIP32 = addressNListToBIP32;
function bip32Like(path) {
    if (path == "m/")
        return true;
    return /^m(((\/[0-9]+h)+|(\/[0-9]+H)+|(\/[0-9]+')*)((\/[0-9]+)*))$/.test(path);
}
exports.bip32Like = bip32Like;
function takeFirstOfManyEvents(eventEmitter, events) {
    return Rx.merge(...events.map((event) => Rx.fromEvent(eventEmitter, event))).pipe(RxOp.first());
}
exports.takeFirstOfManyEvents = takeFirstOfManyEvents;
function stripHexPrefix(value) {
    return value.replace("0x", "");
}
exports.stripHexPrefix = stripHexPrefix;
function stripHexPrefixAndLower(value) {
    return stripHexPrefix(value).toLowerCase();
}
exports.stripHexPrefixAndLower = stripHexPrefixAndLower;
function base64toHEX(base64) {
    var raw = atob(base64);
    var HEX = "";
    for (let i = 0; i < raw.length; i++) {
        var _hex = raw.charCodeAt(i).toString(16);
        HEX += _hex.length == 2 ? _hex : "0" + _hex;
    }
    return "0x" + HEX.toUpperCase();
}
exports.base64toHEX = base64toHEX;
// https://github.com/satoshilabs/slips/blob/master/slip-0044.md
const slip44Table = Object.freeze({
    Bitcoin: 0,
    Testnet: 1,
    BitcoinCash: 145,
    BitcoinGold: 156,
    Litecoin: 2,
    Dash: 5,
    DigiByte: 20,
    Dogecoin: 3,
    BitcoinSV: 236,
    Ethereum: 60,
    Atom: 118,
    Osmo: 118,
    Binance: 714,
    Ripple: 144,
    Eos: 194,
    Fio: 235,
    Thorchain: 931,
    Rune: 931,
    Cardano: 1815,
    Secret: 529,
    Terra: 330,
    Kava: 459,
});
function slip44ByCoin(coin) {
    return slip44Table[coin];
}
exports.slip44ByCoin = slip44ByCoin;
function satsFromStr(coins) {
    let index = coins.indexOf(".");
    let exponent = index > 0 ? 8 - (coins.length - index - 1) : 8;
    return Number(coins.replace(/\./g, "")) * 10 ** exponent;
}
exports.satsFromStr = satsFromStr;
function hardenedPath(path) {
    return path.filter((segment) => segment >= 0x80000000);
}
exports.hardenedPath = hardenedPath;
function relativePath(path) {
    return path.filter((segment) => segment < 0x80000000);
}
exports.relativePath = relativePath;
function toArrayBuffer(x) {
    if (x instanceof ArrayBuffer)
        return x;
    return x.buffer.slice(x.byteOffset, x.byteOffset + x.byteLength);
}
exports.toArrayBuffer = toArrayBuffer;
function mustBeDefined(x) {
    if (x === null || x === undefined)
        throw new Error("expected a value");
    return x;
}
exports.mustBeDefined = mustBeDefined;
// Returns a copyable object which satisfies any type constraint but produces a runtime error if
// accessed in any other way. Useful as dummy data for required parameters. (Probably a bad idea
// in production.)
function untouchable(message) {
    const out = new Proxy({}, new Proxy({}, { get(_, p) {
            return (_, p2) => {
                if (p === "get" && p2 === "valueOf")
                    return () => out;
                throw new Error(`${String(p)}(${String(p2)}): ${message}`);
            };
        } }));
    return out;
}
exports.untouchable = untouchable;
// Webpack 4's Buffer.concat() polyfill requires Buffer[] instead of Uint8Array[]. This is a
// kludgy compatibility hack until everything gets bumped to Webpack 5.
let needCompatibleBufferConcat = undefined;
function checkBufferConcat() {
    if (needCompatibleBufferConcat === undefined) {
        try {
            Buffer.concat([new Uint8Array()]);
            needCompatibleBufferConcat = false;
        }
        catch (_a) {
            needCompatibleBufferConcat = true;
        }
    }
    return needCompatibleBufferConcat;
}
exports.checkBufferConcat = checkBufferConcat;
function compatibleBufferConcat(list) {
    if (!checkBufferConcat())
        return Buffer.concat(list);
    return Buffer.concat(list.map(x => Buffer.isBuffer(x) ? x : Buffer.from(x)));
}
exports.compatibleBufferConcat = compatibleBufferConcat;
/**
 * Type guard for things that might have (string-keyed) properties. Useful to make
 * TypeScript happy when you want to check if an object of unknown type has a particular
 * property set.
 * @example
 * try {
 *   foo();
 * } catch (e: unknown) {
 *   // Not allowed because there's no index signature for `unknown`:
 *   // if (e.bar === "baz") return "foobar";
 *   if (isIndexable(e) && e.bar === "baz") return "foobar";
 *   throw e;
 * }
 * @example
 * isIndexable({}) === true
 * @example
 * isIndexable(() => {}) === true
 * @example
 * isIndexable(Object.create(null)) === true
 * @example
 * isIndexable(String("foo")) === true
 * @example
 * isIndexable(null) === false
 * @example
 * isIndexable(3.14) === false
 * @example
 * isIndexable("foo") === false
 */
function isIndexable(x) {
    return x !== null && ["object", "function"].includes(typeof x);
}
exports.isIndexable = isIndexable;
//# sourceMappingURL=utils.js.map