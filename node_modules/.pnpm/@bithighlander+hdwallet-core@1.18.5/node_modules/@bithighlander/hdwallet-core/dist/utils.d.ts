/// <reference types="node" />
import * as eventemitter2 from "eventemitter2";
import * as Rx from "rxjs";
import { BIP32Path, Coin } from "./wallet";
export declare type Constructor<T = {}> = new (...args: any[]) => T;
export declare const DEFAULT_TIMEOUT = 5000;
export declare const LONG_TIMEOUT: number;
export declare const isArray: (arg: any) => arg is any[];
export declare const fromHexString: (hexString: string) => Uint8Array;
export declare function toHexString(arr: Uint8Array): string;
export declare function arrayify(value: string): Uint8Array;
export declare function bip32ToAddressNList(path: string): number[];
export declare function addressNListToBIP32(address: number[]): string;
export declare function bip32Like(path: string): boolean;
export declare function takeFirstOfManyEvents(eventEmitter: eventemitter2.EventEmitter2, events: string[]): Rx.Observable<{}>;
export declare function stripHexPrefix(value: string): string;
export declare function stripHexPrefixAndLower(value: string): string;
export declare function base64toHEX(base64: string): string;
declare const slip44Table: Readonly<{
    readonly Bitcoin: 0;
    readonly Testnet: 1;
    readonly BitcoinCash: 145;
    readonly BitcoinGold: 156;
    readonly Litecoin: 2;
    readonly Dash: 5;
    readonly DigiByte: 20;
    readonly Dogecoin: 3;
    readonly BitcoinSV: 236;
    readonly Ethereum: 60;
    readonly Atom: 118;
    readonly Osmo: 118;
    readonly Binance: 714;
    readonly Ripple: 144;
    readonly Eos: 194;
    readonly Fio: 235;
    readonly Thorchain: 931;
    readonly Rune: 931;
    readonly Cardano: 1815;
    readonly Secret: 529;
    readonly Terra: 330;
    readonly Kava: 459;
}>;
declare type Slip44ByCoin<T> = (T extends keyof typeof slip44Table ? typeof slip44Table[T] : number | undefined);
export declare function slip44ByCoin<T extends Coin>(coin: T): Slip44ByCoin<T>;
export declare function satsFromStr(coins: string): number;
export declare function hardenedPath(path: BIP32Path): BIP32Path;
export declare function relativePath(path: BIP32Path): BIP32Path;
export declare function toArrayBuffer(x: ArrayBuffer | ArrayBufferView): ArrayBuffer;
export declare function mustBeDefined<T>(x: T): NonNullable<T>;
export declare function untouchable(message: string): any;
export declare function checkBufferConcat(): boolean;
export declare function compatibleBufferConcat(list: Uint8Array[]): Buffer;
/**
 * Type guard for things that might have (string-keyed) properties. Useful to make
 * TypeScript happy when you want to check if an object of unknown type has a particular
 * property set.
 * @example
 * try {
 *   foo();
 * } catch (e: unknown) {
 *   // Not allowed because there's no index signature for `unknown`:
 *   // if (e.bar === "baz") return "foobar";
 *   if (isIndexable(e) && e.bar === "baz") return "foobar";
 *   throw e;
 * }
 * @example
 * isIndexable({}) === true
 * @example
 * isIndexable(() => {}) === true
 * @example
 * isIndexable(Object.create(null)) === true
 * @example
 * isIndexable(String("foo")) === true
 * @example
 * isIndexable(null) === false
 * @example
 * isIndexable(3.14) === false
 * @example
 * isIndexable("foo") === false
 */
export declare function isIndexable(x: unknown): x is Record<string | number | symbol, unknown>;
export {};
//# sourceMappingURL=utils.d.ts.map