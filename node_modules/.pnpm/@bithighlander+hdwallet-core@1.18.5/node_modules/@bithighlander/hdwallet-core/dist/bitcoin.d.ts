import { BIP32Path, Coin, ExchangeType, HDWallet, HDWalletInfo, PathDescription } from "./wallet";
declare type MakeFalsy<T> = T extends boolean ? false : undefined;
declare type DistributiveKeyOf<T> = T extends any ? keyof T : never;
declare type DistributiveFalsyValueOf<T, U> = T extends any ? (U extends keyof T ? MakeFalsy<T[U]> : never) : never;
declare type FalsyValuesOfUnion<T> = {
    [Prop in DistributiveKeyOf<T>]?: DistributiveFalsyValueOf<T, Prop>;
};
declare type OnlyNecessaryProps<T, U> = T & Omit<FalsyValuesOfUnion<U>, keyof T>;
declare type GuardedUnionInner<T, U> = T extends any ? OnlyNecessaryProps<T, U> : never;
declare type GuardedUnion<T> = GuardedUnionInner<T, T>;
export declare type BTCGetAddress = {
    coin: Coin;
    addressNList: BIP32Path;
    scriptType?: BTCInputScriptType;
    showDisplay?: boolean;
};
export interface BitcoinScriptSig {
    hex: string;
}
/**
 * Deserialized representation of an already-signed input of a transaction.
 */
interface BitcoinInputBase {
    sequence: number;
}
export declare type BitcoinInput = GuardedUnion<(BitcoinInputBase & {
    coinbase: string;
}) | (BitcoinInputBase & {
    scriptSig: BitcoinScriptSig;
    txid: string;
    vout: number;
})>;
/**
 * Deserialized representation of an already-signed output of a transaction.
 */
export interface BitcoinOutput {
    value: string;
    scriptPubKey: BitcoinScriptSig;
}
/**
 * De-serialized representation of an already-signed transaction.
 */
export interface BitcoinTxBase {
    version: number;
    locktime: number;
    vin: Array<BitcoinInput>;
    vout: Array<BitcoinOutput>;
}
declare type BitcoinTxDIP2 = BitcoinTxBase & {
    type: number;
    extraPayload: string;
};
export declare type BitcoinTx = GuardedUnion<BitcoinTxBase | BitcoinTxDIP2>;
/**
 * Input for a transaction we're about to sign.
 */
declare type BTCSignTxInputBase = {
    vout: number;
    addressNList: BIP32Path;
    amount?: string;
};
declare type BTCSignTxInputNativeBase = BTCSignTxInputBase & {
    txid: string;
};
declare type BTCSignTxInputNativeSegwitBase = BTCSignTxInputNativeBase & {
    scriptType: BTCInputScriptType.SpendWitness | BTCInputScriptType.SpendP2SHWitness;
};
declare type BTCSignTxInputNativeSegwitWithHex = BTCSignTxInputNativeSegwitBase & {
    hex: string;
};
declare type BTCSignTxInputNativeSegwitWithTx = BTCSignTxInputNativeSegwitBase & {
    tx: BitcoinTx;
    vout: number;
    amount: string;
};
declare type BTCSignTxInputNativeSegwit = BTCSignTxInputNativeSegwitWithHex | BTCSignTxInputNativeSegwitWithTx;
declare type BTCSignTxInputNativeNonSegwit = BTCSignTxInputNativeBase & {
    scriptType: Exclude<BTCInputScriptType, BTCSignTxInputNativeSegwit["scriptType"]>;
    hex: string;
};
declare type BTCSignTxInputNativeUnguarded = BTCSignTxInputNativeSegwit | BTCSignTxInputNativeNonSegwit;
export declare type BTCSignTxInputNative = GuardedUnion<BTCSignTxInputNativeUnguarded>;
declare type BTCSignTxInputKKBase = BTCSignTxInputBase & {
    txid: string;
    amount: string;
    sequence?: number;
};
declare type BTCSignTxInputKKSegwit = BTCSignTxInputKKBase & {
    scriptType: BTCInputScriptType.SpendWitness | BTCInputScriptType.SpendP2SHWitness | BTCInputScriptType.External;
    hex?: string;
};
declare type BTCSignTxInputKKNonSegwit = BTCSignTxInputKKBase & {
    scriptType: Exclude<BTCInputScriptType, BTCSignTxInputKKSegwit["scriptType"]>;
} & ({
    tx: BitcoinTx;
} | {
    hex: string;
});
declare type BTCSignTxInputKKUnguarded = BTCSignTxInputKKNonSegwit | BTCSignTxInputKKSegwit;
export declare type BTCSignTxInputKK = GuardedUnion<BTCSignTxInputKKUnguarded>;
export declare type BTCSignTxInputTrezor = BTCSignTxInputBase & {
    txid: string;
    amount: string;
    scriptType: BTCInputScriptType;
};
export declare type BTCSignTxInputLedger = BTCSignTxInputBase & {
    addressNList: BIP32Path;
    scriptType: BTCInputScriptType;
    hex: string;
};
export declare type BTCSignTxInput = BTCSignTxInputNative & BTCSignTxInputKK & BTCSignTxInputTrezor & BTCSignTxInputLedger;
export declare type BTCSignTxInputUnguarded = BTCSignTxInputNativeUnguarded & BTCSignTxInputKKUnguarded & BTCSignTxInputTrezor & BTCSignTxInputLedger;
export declare type BTCSignTxInputSafe = {
    addressNList: BIP32Path;
    scriptType: BTCInputScriptType;
    hex: string;
    txid: string;
    amount: string;
    vout: number;
};
/**
 * Output for a transaction we're about to sign.
 */
export declare type BTCSignTxOutputSpend = {
    addressType?: BTCOutputAddressType.Spend;
    amount: string;
    address: string;
};
export declare type BTCSignTxOutputSpendP2PKH = {
    addressType?: BTCOutputAddressType.Spend;
    amount: string;
    address: string;
    scriptType: BTCOutputScriptType.PayToAddress;
};
export declare type BTCSignTxOutputSpendP2SH = {
    addressType?: BTCOutputAddressType.Spend;
    amount: string;
    address: string;
    scriptType: BTCOutputScriptType.PayToMultisig | BTCOutputScriptType.PayToP2SHWitness;
};
export declare type BTCSignTxOutputSpendP2WPKH = {
    addressType?: BTCOutputAddressType.Spend;
    amount: string;
    address: string;
    scriptType: BTCOutputScriptType.PayToWitness;
};
export declare type BTCSignTxOutputTransfer = {
    addressType: BTCOutputAddressType.Transfer;
    amount: string;
    /** bip32 path for destination (device must `btcSupportsSecureTransfer()`) */
    addressNList: BIP32Path;
    scriptType: BTCOutputScriptType;
};
export declare type BTCSignTxOutputChange = {
    addressType: BTCOutputAddressType.Change;
    amount: string;
    /** bip32 path for destination (device must `btcSupportsSecureTransfer()`) */
    addressNList: BIP32Path;
    scriptType: BTCOutputScriptType;
    isChange: true;
};
export declare type BTCSignTxOutputExchange = {
    /**
     * Device must `btcSupportsNativeShapeShift()`
     */
    addressType: BTCOutputAddressType.Exchange;
    amount: string;
    exchangeType: ExchangeType;
};
export declare type BTCSignTxOutputMemo = {
    addressType?: BTCOutputAddressType.Spend;
    amount?: "0";
    opReturnData: string | Uint8Array;
};
export declare type BTCSignTxOutput = GuardedUnion<BTCSignTxOutputSpend | BTCSignTxOutputSpendP2PKH | BTCSignTxOutputSpendP2SH | BTCSignTxOutputSpendP2WPKH | BTCSignTxOutputTransfer | BTCSignTxOutputChange | BTCSignTxOutputExchange | BTCSignTxOutputMemo>;
export interface BTCSignTx {
    coin: string;
    inputs: Array<BTCSignTxInput>;
    outputs: Array<BTCSignTxOutput>;
    version?: number;
    locktime?: number;
    opReturnData?: string;
    vaultAddress?: string;
}
export declare type BTCSignTxKK = Omit<BTCSignTx, "inputs"> & {
    inputs: Array<BTCSignTxInputKK>;
};
export declare type BTCSignTxNative = Omit<BTCSignTx, "inputs"> & {
    inputs: Array<BTCSignTxInputNative>;
};
export declare type BTCSignTxTrezor = Omit<BTCSignTx, "inputs"> & {
    inputs: Array<BTCSignTxInputTrezor>;
};
export declare type BTCSignTxLedger = Omit<BTCSignTx, "inputs"> & {
    inputs: Array<BTCSignTxInputLedger>;
};
export interface BTCSignedTx {
    signatures: Array<string>;
    /** hex string representation of the raw, signed transaction */
    serializedTx: string;
}
export declare enum BTCInputScriptType {
    CashAddr = "cashaddr",
    Bech32 = "bech32",
    SpendAddress = "p2pkh",
    SpendMultisig = "p2sh",
    External = "external",
    SpendWitness = "p2wpkh",
    SpendP2SHWitness = "p2sh-p2wpkh"
}
export declare enum BTCOutputScriptType {
    PayToAddress = "p2pkh",
    PayToMultisig = "p2sh",
    Bech32 = "bech32",
    PayToWitness = "p2wpkh",
    PayToP2SHWitness = "p2sh-p2wpkh"
}
export declare enum BTCOutputAddressType {
    Spend = "spend",
    Transfer = "transfer",
    Change = "change",
    Exchange = "exchange"
}
export interface BTCSignMessage {
    addressNList: BIP32Path;
    coin: Coin;
    scriptType?: BTCInputScriptType;
    message: string;
}
export interface BTCSignedMessage {
    address: string;
    signature: string;
}
export interface BTCVerifyMessage {
    address: string;
    message: string;
    signature: string;
    coin: Coin;
}
export interface BTCGetAccountPaths {
    coin: Coin;
    accountIdx: number;
    scriptType?: BTCInputScriptType;
}
export interface BTCAccountPath {
    coin: Coin;
    scriptType: BTCInputScriptType;
    addressNList: BIP32Path;
}
export interface BTCWalletInfo extends HDWalletInfo {
    readonly _supportsBTCInfo: boolean;
    /**
     * Does the device support the given UTXO coin?
     */
    btcSupportsCoin(coin: Coin): Promise<boolean>;
    /**
     * Does the device support the given script type for the given coin?
     * Assumes that `btcSupportsCoin(coin)` for the given coin.
     */
    btcSupportsScriptType(coin: Coin, scriptType?: BTCInputScriptType): Promise<boolean>;
    /**
     * Does the device support internal transfers without the user needing to
     * confirm the destination address?
     */
    btcSupportsSecureTransfer(): Promise<boolean>;
    /**
     * Does the device support `/sendamountProto2` style ShapeShift trades?
     */
    btcSupportsNativeShapeShift(): boolean;
    /**
     * Returns a list of bip32 paths for a given account index in preferred order
     * from most to least preferred.
     *
     * For forked coins, eg. BSV, this would return:
     ```plaintext
        p2pkh m/44'/236'/a'
        p2pkh m/44'/230'/a'
        p2pkh m/44'/0'/a'
     ```
     *
     * For BTC it might return:
     ```plaintext
        p2sh-p2pkh m/49'/0'/a'
        p2pkh      m/44'/0'/a'
        p2sh-p2wsh m/44'/0'/a'
     ```
     */
    btcGetAccountPaths(msg: BTCGetAccountPaths): Array<BTCAccountPath>;
    /**
     * Does the device support spending from the combined accounts?
     * The list is assumed to contain unique entries.
     */
    btcIsSameAccount(msg: Array<BTCAccountPath>): boolean;
    /**
     * Returns the "next" account path, if any.
     */
    btcNextAccountPath(msg: BTCAccountPath): BTCAccountPath | undefined;
}
export interface BTCWallet extends BTCWalletInfo, HDWallet {
    readonly _supportsBTC: boolean;
    btcGetAddress(msg: BTCGetAddress): Promise<string | null>;
    btcSignTx(msg: BTCSignTx): Promise<BTCSignedTx | null>;
    btcSignMessage(msg: BTCSignMessage): Promise<BTCSignedMessage | null>;
    btcVerifyMessage(msg: BTCVerifyMessage): Promise<boolean | null>;
}
export declare function unknownUTXOPath(path: BIP32Path, coin: Coin, scriptType?: BTCInputScriptType): PathDescription;
export declare function describeUTXOPath(path: BIP32Path, coin: Coin, scriptType: BTCInputScriptType): PathDescription;
export declare function legacyAccount(coin: Coin, slip44: number, accountIdx: number): BTCAccountPath;
export declare function segwitAccount(coin: Coin, slip44: number, accountIdx: number): BTCAccountPath;
export declare function segwitNativeAccount(coin: Coin, slip44: number, accountIdx: number): BTCAccountPath;
export {};
//# sourceMappingURL=bitcoin.d.ts.map