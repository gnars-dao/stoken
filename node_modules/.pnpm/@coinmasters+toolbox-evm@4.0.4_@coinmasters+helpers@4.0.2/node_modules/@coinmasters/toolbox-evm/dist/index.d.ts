import type { Asset } from '@coinmasters/types';
import { AssetValue } from '@coinmasters/helpers';
import { BaseDecimal } from '@coinmasters/types';
import type { BigNumberish } from 'ethers';
import { BrowserProvider } from 'ethers';
import { Chain } from '@coinmasters/types';
import { ChainId } from '@coinmasters/types';
import { Contract } from 'ethers';
import { ContractTransaction } from 'ethers';
import { Eip1193Provider } from 'ethers';
import { EVMChain } from '@coinmasters/types';
import type { EVMTxBaseParams } from '@coinmasters/types';
import { FeeOption } from '@coinmasters/types';
import { Fragment } from 'ethers';
import { HDNodeWallet } from 'ethers';
import { JsonFragment } from 'ethers';
import { JsonRpcProvider } from 'ethers';
import { JsonRpcSigner } from 'ethers';
import { Provider } from 'ethers';
import { RPCUrl } from '@coinmasters/types';
import { Signer } from 'ethers';
import type { Transaction } from 'ethers';
import { TransactionRequest } from 'ethers';
import { TransactionResponse } from 'ethers';
import { WalletOption } from '@coinmasters/types';
import { WalletTxParams } from '@coinmasters/types';

export declare const addAccountsChangedCallback: (callback: () => void) => void;

export declare const addEVMWalletNetwork: (provider: BrowserProvider, networkParams: NetworkParams) => Promise<any>;

export declare interface AddressInfo {
    address: string;
    ETH: {
        balance: number;
        totalIn?: number;
        totalOut?: number;
        price: PriceInfo;
    };
    contractInfo?: {
        creatorAddress: string;
        transactionHash: string;
        timestamp: string;
    };
    tokenInfo?: TokenInfo;
    tokens?: TokenBalance[];
    countTxs: number;
}

export declare type ApprovedParams = {
    assetAddress: string;
    spenderAddress: string;
    from: string;
};

export declare type ApproveParams = {
    assetAddress: string;
    spenderAddress: string;
    feeOptionKey?: FeeOption;
    amount?: BigNumberish;
    from: string;
    gasLimitFallback?: BigNumberish;
    nonce?: number;
};

export declare const ARBToolbox: ({ api, provider, signer, covalentApiKey, }: {
    api?: {
        getBalance: (address: any) => Promise<{
            value: string;
            decimal: number;
            chain: Chain;
            symbol: string;
        }[]>;
    } | undefined;
    covalentApiKey: string;
    signer: Signer;
    provider: JsonRpcProvider | BrowserProvider;
}) => {
    getNetworkParams: () => {
        chainId: ChainId;
        chainName: string;
        nativeCurrency: {
            name: string;
            symbol: Chain;
            decimals: BaseDecimal;
        };
        rpcUrls: RPCUrl[];
        blockExplorerUrls: string[];
    };
    estimateGasPrices: () => Promise<{
        average: {
            gasPrice: bigint;
        };
        fast: {
            gasPrice: bigint;
        };
        fastest: {
            gasPrice: bigint;
        };
    }>;
    getBalance: (address: any, potentialScamFilter?: boolean) => Promise<{
        address: any;
        chain: Chain;
        isGasAsset: boolean;
        isSynthetic: boolean;
        symbol: string;
        tax?: {
            buy: number;
            sell: number;
        } | undefined;
        ticker: string;
        type: Chain.Avalanche | Chain.Cosmos | Chain.Kujira | "Synth" | "Native" | "BEP2" | "BEP20" | "ERC20" | "POLYGON" | "ARBITRUM" | "OPTIMISM" | undefined;
        decimalMultiplier: bigint;
        bigIntValue: bigint;
        decimal?: number | undefined;
    }[]>;
    approve: (params: ApproveParams) => Promise<string>;
    approvedAmount: (params: ApprovedParams) => Promise<bigint>;
    broadcastTransaction: ((signedTx: string) => Promise<TransactionResponse>) | ((signedTx: string) => Promise<TransactionResponse>);
    call: (params: CallParams) => Promise<unknown>;
    createContract: (address: string, abi: readonly (JsonFragment | Fragment)[], provider: Provider) => Promise<Contract>;
    createContractTxObject: (params: CallParams) => Promise<ContractTransaction>;
    EIP1193SendTransaction: (tx: EIP1559TxParams) => Promise<string>;
    estimateCall: (params: EstimateCallParams) => Promise<bigint>;
    estimateGasLimit: ({ assetValue, recipient, memo, }: WalletTxParams & {
        assetValue: AssetValue;
    }) => Promise<bigint>;
    isApproved: (params: IsApprovedParams) => Promise<boolean>;
    sendTransaction: (params: EIP1559TxParams, feeOption: FeeOption) => Promise<string | TransactionResponse>;
    transfer: (params: TransferParams) => Promise<string | TransactionResponse>;
    validateAddress: (address: string) => boolean;
};

export declare const AVAXToolbox: ({ api, provider, signer, covalentApiKey, }: {
    api?: {
        getBalance: (address: any) => Promise<{
            value: string;
            decimal: number;
            chain: Chain;
            symbol: string;
        }[]>;
    } | undefined;
    covalentApiKey: string;
    signer: Signer;
    provider: JsonRpcProvider | BrowserProvider;
}) => {
    getNetworkParams: () => {
        chainId: ChainId;
        chainName: string;
        nativeCurrency: {
            name: string;
            symbol: Chain;
            decimals: BaseDecimal;
        };
        rpcUrls: string[];
        blockExplorerUrls: string[];
    };
    getBalance: (address: any, potentialScamFilter?: boolean) => Promise<{
        address: any;
        chain: Chain;
        isGasAsset: boolean;
        isSynthetic: boolean;
        symbol: string;
        tax?: {
            buy: number;
            sell: number;
        } | undefined;
        ticker: string;
        type: Chain.Avalanche | Chain.Cosmos | Chain.Kujira | "Synth" | "Native" | "BEP2" | "BEP20" | "ERC20" | "POLYGON" | "ARBITRUM" | "OPTIMISM" | undefined;
        decimalMultiplier: bigint;
        bigIntValue: bigint;
        decimal?: number | undefined;
    }[]>;
    approve: (params: ApproveParams) => Promise<string>;
    approvedAmount: (params: ApprovedParams) => Promise<bigint>;
    broadcastTransaction: ((signedTx: string) => Promise<TransactionResponse>) | ((signedTx: string) => Promise<TransactionResponse>);
    call: (params: CallParams) => Promise<unknown>;
    createContract: (address: string, abi: readonly (JsonFragment | Fragment)[], provider: Provider) => Promise<Contract>;
    createContractTxObject: (params: CallParams) => Promise<ContractTransaction>;
    EIP1193SendTransaction: (tx: EIP1559TxParams) => Promise<string>;
    estimateCall: (params: EstimateCallParams) => Promise<bigint>;
    estimateGasLimit: ({ assetValue, recipient, memo, }: WalletTxParams & {
        assetValue: AssetValue;
    }) => Promise<bigint>;
    estimateGasPrices: () => Promise<{
        average: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
        fast: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
        fastest: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
    } | {
        average: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
        fast: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
        fastest: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
    }>;
    isApproved: (params: IsApprovedParams) => Promise<boolean>;
    sendTransaction: (params: EIP1559TxParams, feeOption: FeeOption) => Promise<string | TransactionResponse>;
    transfer: (params: TransferParams) => Promise<string | TransactionResponse>;
    validateAddress: (address: string) => boolean;
};

export declare const BaseEVMToolbox: ({ provider, signer, isEIP1559Compatible, }: {
    signer?: Signer | JsonRpcSigner | HDNodeWallet | undefined;
    provider: Provider | BrowserProvider;
    isEIP1559Compatible?: boolean | undefined;
}) => {
    approve: (params: ApproveParams) => Promise<string>;
    approvedAmount: (params: ApprovedParams) => Promise<bigint>;
    broadcastTransaction: ((signedTx: string) => Promise<TransactionResponse>) | ((signedTx: string) => Promise<TransactionResponse>);
    call: (params: CallParams) => Promise<unknown>;
    createContract: (address: string, abi: readonly (JsonFragment | Fragment)[], provider: Provider) => Promise<Contract>;
    createContractTxObject: (params: CallParams) => Promise<ContractTransaction>;
    EIP1193SendTransaction: (tx: EIP1559TxParams) => Promise<string>;
    estimateCall: (params: EstimateCallParams) => Promise<bigint>;
    estimateGasLimit: ({ assetValue, recipient, memo, }: WalletTxParams & {
        assetValue: AssetValue;
    }) => Promise<bigint>;
    estimateGasPrices: () => Promise<{
        average: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
        fast: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
        fastest: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
    } | {
        average: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
        fast: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
        fastest: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
    }>;
    isApproved: (params: IsApprovedParams) => Promise<boolean>;
    sendTransaction: (params: EIP1559TxParams, feeOption: FeeOption) => Promise<string | TransactionResponse>;
    transfer: (params: TransferParams) => Promise<string | TransactionResponse>;
    validateAddress: (address: string) => boolean;
};

export declare const BSCToolbox: ({ api, provider, signer, covalentApiKey, }: {
    api?: {
        getBalance: (address: any) => Promise<{
            value: string;
            decimal: number;
            chain: Chain;
            symbol: string;
        }[]>;
    } | undefined;
    covalentApiKey: string;
    signer: Signer;
    provider: JsonRpcProvider | BrowserProvider;
}) => {
    call: (params: CallParams) => Promise<unknown>;
    getNetworkParams: () => {
        chainId: ChainId;
        chainName: string;
        nativeCurrency: {
            name: string;
            symbol: Chain;
            decimals: BaseDecimal;
        };
        rpcUrls: string[];
        blockExplorerUrls: string[];
    };
    getBalance: (address: any, potentialScamFilter?: boolean) => Promise<{
        address: any;
        chain: Chain;
        isGasAsset: boolean;
        isSynthetic: boolean;
        symbol: string;
        tax?: {
            buy: number;
            sell: number;
        } | undefined;
        ticker: string;
        type: Chain.Avalanche | Chain.Cosmos | Chain.Kujira | "Synth" | "Native" | "BEP2" | "BEP20" | "ERC20" | "POLYGON" | "ARBITRUM" | "OPTIMISM" | undefined;
        decimalMultiplier: bigint;
        bigIntValue: bigint;
        decimal?: number | undefined;
    }[]>;
    approve: (params: ApproveParams) => Promise<string>;
    approvedAmount: (params: ApprovedParams) => Promise<bigint>;
    broadcastTransaction: ((signedTx: string) => Promise<TransactionResponse>) | ((signedTx: string) => Promise<TransactionResponse>);
    createContract: (address: string, abi: readonly (JsonFragment | Fragment)[], provider: Provider) => Promise<Contract>;
    createContractTxObject: (params: CallParams) => Promise<ContractTransaction>;
    EIP1193SendTransaction: (tx: EIP1559TxParams) => Promise<string>;
    estimateCall: (params: EstimateCallParams) => Promise<bigint>;
    estimateGasLimit: ({ assetValue, recipient, memo, }: WalletTxParams & {
        assetValue: AssetValue;
    }) => Promise<bigint>;
    estimateGasPrices: () => Promise<{
        average: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
        fast: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
        fastest: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
    } | {
        average: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
        fast: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
        fastest: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
    }>;
    isApproved: (params: IsApprovedParams) => Promise<boolean>;
    sendTransaction: (params: EIP1559TxParams, feeOption: FeeOption) => Promise<string | TransactionResponse>;
    transfer: (params: TransferParams) => Promise<string | TransactionResponse>;
    validateAddress: (address: string) => boolean;
};

export declare type CallParams = {
    callProvider?: ReturnType<typeof getProvider>;
    contractAddress: string;
    abi: readonly JsonFragment[];
    funcName: string;
    funcParams?: unknown[];
    txOverrides?: Partial<Transaction>;
    feeOption?: FeeOption;
};

export declare const covalentApi: ({ apiKey, chainId }: {
    apiKey: string;
    chainId: ChainId;
}) => {
    getBalance: (address: any) => Promise<{
        value: string;
        decimal: number;
        chain: Chain;
        symbol: string;
    }[]>;
};

export declare type CovalentApiType = ReturnType<typeof covalentApi>;

export declare const EIP1193SendTransaction: (provider: Provider | BrowserProvider, { from, to, data, value }: EVMTxParams | ContractTransaction) => Promise<string>;

export declare type EIP1559TxParams<T = bigint> = EVMTxBaseParams<T> & {
    type?: number;
    maxFeePerGas?: T;
    maxPriorityFeePerGas?: T;
};

export declare type EstimateCallParams = Pick<CallParams, 'contractAddress' | 'abi' | 'funcName' | 'funcParams' | 'txOverrides'>;

export declare const estimateMaxSendableAmount: ({ toolbox, from, memo, feeOptionKey, assetValue, abi, funcName, funcParams, contractAddress, txOverrides, }: EVMMaxSendableAmountsParams) => Promise<AssetValue>;

export declare type EthereumWindowProvider = BrowserProvider & {
    isMetaMask?: boolean;
    on: (event: string, callback?: () => void) => void;
    isBraveWallet?: boolean;
    isCoinbaseWallet?: boolean;
    isOkxWallet?: boolean;
    overrideIsMetaMask?: boolean;
    selectedProvider?: EthereumWindowProvider;
    isTrust?: boolean;
    __XDEFI?: boolean;
};

export declare enum EthNetwork {
    Test = "goerli",
    Main = "homestead"
}

export declare const ethplorerApi: (apiKey?: string) => {
    getBalance: (address: string) => Promise<{
        chain: Chain;
        symbol: string;
        value: string;
        decimal: number;
    }[]>;
};

export declare type EthplorerApiType = ReturnType<typeof ethplorerApi>;

export declare const ETHToolbox: ({ api, ethplorerApiKey, signer, provider, }: {
    api?: {
        getBalance: (address: string) => Promise<{
            chain: Chain;
            symbol: string;
            value: string;
            decimal: number;
        }[]>;
    } | undefined;
    ethplorerApiKey: string;
    signer?: Signer | JsonRpcSigner | undefined;
    provider: JsonRpcProvider | BrowserProvider;
}) => {
    getBalance: (address: any, potentialScamFilter?: boolean) => Promise<{
        address: any;
        chain: Chain;
        isGasAsset: boolean;
        isSynthetic: boolean;
        symbol: string;
        tax?: {
            buy: number;
            sell: number;
        } | undefined;
        ticker: string;
        type: Chain.Avalanche | Chain.Cosmos | Chain.Kujira | "Synth" | "Native" | "BEP2" | "BEP20" | "ERC20" | "POLYGON" | "ARBITRUM" | "OPTIMISM" | undefined;
        decimalMultiplier: bigint;
        bigIntValue: bigint;
        decimal?: number | undefined;
    }[]>;
    approve: (params: ApproveParams) => Promise<string>;
    approvedAmount: (params: ApprovedParams) => Promise<bigint>;
    broadcastTransaction: ((signedTx: string) => Promise<TransactionResponse>) | ((signedTx: string) => Promise<TransactionResponse>);
    call: (params: CallParams) => Promise<unknown>;
    createContract: (address: string, abi: readonly (JsonFragment | Fragment)[], provider: Provider) => Promise<Contract>;
    createContractTxObject: (params: CallParams) => Promise<ContractTransaction>;
    EIP1193SendTransaction: (tx: EIP1559TxParams) => Promise<string>;
    estimateCall: (params: EstimateCallParams) => Promise<bigint>;
    estimateGasLimit: ({ assetValue, recipient, memo, }: WalletTxParams & {
        assetValue: AssetValue;
    }) => Promise<bigint>;
    estimateGasPrices: () => Promise<{
        average: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
        fast: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
        fastest: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
    } | {
        average: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
        fast: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
        fastest: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
    }>;
    isApproved: (params: IsApprovedParams) => Promise<boolean>;
    sendTransaction: (params: EIP1559TxParams, feeOption: FeeOption) => Promise<string | TransactionResponse>;
    transfer: (params: TransferParams) => Promise<string | TransactionResponse>;
    validateAddress: (address: string) => boolean;
};

export declare type EVMMaxSendableAmountsParams = {
    from: string;
    toolbox: EVMToolbox;
    assetValue: AssetValue;
    feeOptionKey?: FeeOption;
    memo?: string;
    abi?: readonly JsonFragment[];
    funcName?: string;
    contractAddress?: string;
    funcParams?: unknown[];
    txOverrides?: Partial<Transaction>;
};

export declare type EVMToolbox = ReturnType<typeof AVAXToolbox | typeof ETHToolbox | typeof BSCToolbox | typeof OPToolbox | typeof ARBToolbox | typeof MATICToolbox>;

export declare type EVMTxParams = EIP1559TxParams | LegacyEVMTxParams;

export declare const getBalance: ({ provider, api, address, chain, potentialScamFilter, }: {
    provider: JsonRpcProvider | BrowserProvider;
    api: CovalentApiType | EthplorerApiType;
    address: any;
    chain: EVMChain;
    potentialScamFilter?: boolean | undefined;
}) => Promise<{
    address: any;
    chain: Chain;
    isGasAsset: boolean;
    isSynthetic: boolean;
    symbol: string;
    tax?: {
        buy: number;
        sell: number;
    } | undefined;
    ticker: string;
    type: Chain.Avalanche | Chain.Cosmos | Chain.Kujira | "Synth" | "Native" | "BEP2" | "BEP20" | "ERC20" | "POLYGON" | "ARBITRUM" | "OPTIMISM" | undefined;
    decimalMultiplier: bigint;
    bigIntValue: bigint;
    decimal?: number | undefined;
}[]>;

export declare const getChecksumAddressFromAsset: (asset: Asset, chain: EVMChain) => string;

export declare const getETHDefaultWallet: () => WalletOption.METAMASK | WalletOption.COINBASE_WEB | WalletOption.TRUSTWALLET_WEB | WalletOption.BRAVE;

export declare const getProvider: (chain: EVMChain, customUrl?: string) => JsonRpcProvider;

export declare const getTokenAddress: ({ chain, symbol, ticker }: Asset, baseAssetChain: EVMChain) => string | null;

export declare const getToolboxByChain: (chain: EVMChain) => Promise<(({ api, provider, signer, covalentApiKey, }: {
    api?: {
        getBalance: (address: any) => Promise<{
            value: string;
            decimal: number;
            chain: Chain;
            symbol: string;
        }[]>;
    } | undefined;
    covalentApiKey: string;
    signer: Signer;
    provider: BrowserProvider | JsonRpcProvider;
}) => {
    getNetworkParams: () => {
        chainId: ChainId;
        chainName: string;
        nativeCurrency: {
            name: string;
            symbol: Chain;
            decimals: BaseDecimal;
        };
        rpcUrls: string[];
        blockExplorerUrls: string[];
    };
    getBalance: (address: any, potentialScamFilter?: boolean | undefined) => Promise<{
        address: any;
        chain: Chain;
        isGasAsset: boolean;
        isSynthetic: boolean;
        symbol: string;
        tax?: {
            buy: number;
            sell: number;
        } | undefined;
        ticker: string;
        type: Chain.Avalanche | Chain.Cosmos | Chain.Kujira | "Synth" | "Native" | "BEP2" | "BEP20" | "ERC20" | "POLYGON" | "ARBITRUM" | "OPTIMISM" | undefined;
        decimalMultiplier: bigint;
        bigIntValue: bigint;
        decimal?: number | undefined;
    }[]>;
    approve: (params: ApproveParams) => Promise<string>;
    approvedAmount: (params: ApprovedParams) => Promise<bigint>;
    broadcastTransaction: ((signedTx: string) => Promise<TransactionResponse>) | ((signedTx: string) => Promise<TransactionResponse>);
    call: (params: CallParams) => Promise<unknown>;
    createContract: (address: string, abi: readonly (JsonFragment | Fragment)[], provider: Provider) => Promise<Contract>;
    createContractTxObject: (params: CallParams) => Promise<ContractTransaction>;
    EIP1193SendTransaction: (tx: EIP1559TxParams) => Promise<string>;
    estimateCall: (params: EstimateCallParams) => Promise<bigint>;
    estimateGasLimit: ({ assetValue, recipient, memo, }: WalletTxParams & {
        assetValue: AssetValue;
    }) => Promise<bigint>;
    estimateGasPrices: () => Promise<{
        average: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
        fast: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
        fastest: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
    } | {
        average: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
        fast: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
        fastest: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
    }>;
    isApproved: (params: IsApprovedParams) => Promise<boolean>;
    sendTransaction: (params: EIP1559TxParams, feeOption: FeeOption) => Promise<string | TransactionResponse>;
    transfer: (params: TransferParams) => Promise<string | TransactionResponse>;
    validateAddress: (address: string) => boolean;
}) | (({ api, ethplorerApiKey, signer, provider, }: {
    api?: {
        getBalance: (address: string) => Promise<{
            chain: Chain;
            symbol: string;
            value: string;
            decimal: number;
        }[]>;
    } | undefined;
    ethplorerApiKey: string;
    signer?: Signer | JsonRpcSigner | undefined;
    provider: BrowserProvider | JsonRpcProvider;
}) => {
    getBalance: (address: any, potentialScamFilter?: boolean | undefined) => Promise<{
        address: any;
        chain: Chain;
        isGasAsset: boolean;
        isSynthetic: boolean;
        symbol: string;
        tax?: {
            buy: number;
            sell: number;
        } | undefined;
        ticker: string;
        type: Chain.Avalanche | Chain.Cosmos | Chain.Kujira | "Synth" | "Native" | "BEP2" | "BEP20" | "ERC20" | "POLYGON" | "ARBITRUM" | "OPTIMISM" | undefined;
        decimalMultiplier: bigint;
        bigIntValue: bigint;
        decimal?: number | undefined;
    }[]>;
    approve: (params: ApproveParams) => Promise<string>;
    approvedAmount: (params: ApprovedParams) => Promise<bigint>;
    broadcastTransaction: ((signedTx: string) => Promise<TransactionResponse>) | ((signedTx: string) => Promise<TransactionResponse>);
    call: (params: CallParams) => Promise<unknown>;
    createContract: (address: string, abi: readonly (JsonFragment | Fragment)[], provider: Provider) => Promise<Contract>;
    createContractTxObject: (params: CallParams) => Promise<ContractTransaction>;
    EIP1193SendTransaction: (tx: EIP1559TxParams) => Promise<string>;
    estimateCall: (params: EstimateCallParams) => Promise<bigint>;
    estimateGasLimit: ({ assetValue, recipient, memo, }: WalletTxParams & {
        assetValue: AssetValue;
    }) => Promise<bigint>;
    estimateGasPrices: () => Promise<{
        average: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
        fast: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
        fastest: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
    } | {
        average: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
        fast: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
        fastest: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
    }>;
    isApproved: (params: IsApprovedParams) => Promise<boolean>;
    sendTransaction: (params: EIP1559TxParams, feeOption: FeeOption) => Promise<string | TransactionResponse>;
    transfer: (params: TransferParams) => Promise<string | TransactionResponse>;
    validateAddress: (address: string) => boolean;
}) | (({ api, provider, signer, covalentApiKey, }: {
    api?: {
        getBalance: (address: any) => Promise<{
            value: string;
            decimal: number;
            chain: Chain;
            symbol: string;
        }[]>;
    } | undefined;
    covalentApiKey: string;
    signer: Signer;
    provider: BrowserProvider | JsonRpcProvider;
}) => {
    estimateTotalGasCost: (tx: TransactionRequest) => Promise<any>;
    estimateL1GasCost: (tx: TransactionRequest) => Promise<any>;
    estimateL2GasCost: (tx: TransactionRequest) => Promise<any>;
    getL1GasPrice: () => Promise<bigint>;
    estimateL1Gas: (tx: TransactionRequest) => Promise<any>;
    getNetworkParams: () => {
        chainId: ChainId;
        chainName: string;
        nativeCurrency: {
            name: string;
            symbol: Chain;
            decimals: BaseDecimal;
        };
        rpcUrls: RPCUrl[];
        blockExplorerUrls: string[];
    };
    estimateGasPrices: () => Promise<{
        average: {
            l1GasPrice: bigint;
            gasPrice: bigint | null;
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
        };
        fast: {
            l1GasPrice: bigint;
            gasPrice: bigint;
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
        };
        fastest: {
            l1GasPrice: bigint;
            gasPrice: bigint;
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
        };
    }>;
    getBalance: (address: any, potentialScamFilter?: boolean | undefined) => Promise<{
        address: any;
        chain: Chain;
        isGasAsset: boolean;
        isSynthetic: boolean;
        symbol: string;
        tax?: {
            buy: number;
            sell: number;
        } | undefined;
        ticker: string;
        type: Chain.Avalanche | Chain.Cosmos | Chain.Kujira | "Synth" | "Native" | "BEP2" | "BEP20" | "ERC20" | "POLYGON" | "ARBITRUM" | "OPTIMISM" | undefined;
        decimalMultiplier: bigint;
        bigIntValue: bigint;
        decimal?: number | undefined;
    }[]>;
    approve: (params: ApproveParams) => Promise<string>;
    approvedAmount: (params: ApprovedParams) => Promise<bigint>;
    broadcastTransaction: ((signedTx: string) => Promise<TransactionResponse>) | ((signedTx: string) => Promise<TransactionResponse>);
    call: (params: CallParams) => Promise<unknown>;
    createContract: (address: string, abi: readonly (JsonFragment | Fragment)[], provider: Provider) => Promise<Contract>;
    createContractTxObject: (params: CallParams) => Promise<ContractTransaction>;
    EIP1193SendTransaction: (tx: EIP1559TxParams) => Promise<string>;
    estimateCall: (params: EstimateCallParams) => Promise<bigint>;
    estimateGasLimit: ({ assetValue, recipient, memo, }: WalletTxParams & {
        assetValue: AssetValue;
    }) => Promise<bigint>;
    isApproved: (params: IsApprovedParams) => Promise<boolean>;
    sendTransaction: (params: EIP1559TxParams, feeOption: FeeOption) => Promise<string | TransactionResponse>;
    transfer: (params: TransferParams) => Promise<string | TransactionResponse>;
    validateAddress: (address: string) => boolean;
}) | (({ api, provider, signer, covalentApiKey, }: {
    api?: {
        getBalance: (address: any) => Promise<{
            value: string;
            decimal: number;
            chain: Chain;
            symbol: string;
        }[]>;
    } | undefined;
    covalentApiKey: string;
    signer: Signer;
    provider: BrowserProvider | JsonRpcProvider;
}) => {
    getNetworkParams: () => {
        chainId: ChainId;
        chainName: string;
        nativeCurrency: {
            name: string;
            symbol: Chain;
            decimals: BaseDecimal;
        };
        rpcUrls: RPCUrl[];
        blockExplorerUrls: string[];
    };
    estimateGasPrices: () => Promise<{
        average: {
            gasPrice: bigint;
        };
        fast: {
            gasPrice: bigint;
        };
        fastest: {
            gasPrice: bigint;
        };
    }>;
    getBalance: (address: any, potentialScamFilter?: boolean | undefined) => Promise<{
        address: any;
        chain: Chain;
        isGasAsset: boolean;
        isSynthetic: boolean;
        symbol: string;
        tax?: {
            buy: number;
            sell: number;
        } | undefined;
        ticker: string;
        type: Chain.Avalanche | Chain.Cosmos | Chain.Kujira | "Synth" | "Native" | "BEP2" | "BEP20" | "ERC20" | "POLYGON" | "ARBITRUM" | "OPTIMISM" | undefined;
        decimalMultiplier: bigint;
        bigIntValue: bigint;
        decimal?: number | undefined;
    }[]>;
    approve: (params: ApproveParams) => Promise<string>;
    approvedAmount: (params: ApprovedParams) => Promise<bigint>;
    broadcastTransaction: ((signedTx: string) => Promise<TransactionResponse>) | ((signedTx: string) => Promise<TransactionResponse>);
    call: (params: CallParams) => Promise<unknown>;
    createContract: (address: string, abi: readonly (JsonFragment | Fragment)[], provider: Provider) => Promise<Contract>;
    createContractTxObject: (params: CallParams) => Promise<ContractTransaction>;
    EIP1193SendTransaction: (tx: EIP1559TxParams) => Promise<string>;
    estimateCall: (params: EstimateCallParams) => Promise<bigint>;
    estimateGasLimit: ({ assetValue, recipient, memo, }: WalletTxParams & {
        assetValue: AssetValue;
    }) => Promise<bigint>;
    isApproved: (params: IsApprovedParams) => Promise<boolean>;
    sendTransaction: (params: EIP1559TxParams, feeOption: FeeOption) => Promise<string | TransactionResponse>;
    transfer: (params: TransferParams) => Promise<string | TransactionResponse>;
    validateAddress: (address: string) => boolean;
})>;

export declare const getWeb3WalletMethods: ({ ethereumWindowProvider, chain, covalentApiKey, ethplorerApiKey, }: {
    ethereumWindowProvider: Eip1193Provider | undefined;
    chain: Chain;
    covalentApiKey?: string | undefined;
    ethplorerApiKey?: string | undefined;
}) => Promise<{
    getBalance: (address: any, potentialScamFilter?: boolean | undefined) => Promise<{
        address: any;
        chain: Chain;
        isGasAsset: boolean;
        isSynthetic: boolean;
        symbol: string;
        tax?: {
            buy: number;
            sell: number;
        } | undefined;
        ticker: string;
        type: Chain.Avalanche | Chain.Cosmos | Chain.Kujira | "Synth" | "Native" | "BEP2" | "BEP20" | "ERC20" | "POLYGON" | "ARBITRUM" | "OPTIMISM" | undefined;
        decimalMultiplier: bigint;
        bigIntValue: bigint;
        decimal?: number | undefined;
    }[]>;
    approve: (params: ApproveParams) => Promise<string>;
    approvedAmount: (params: ApprovedParams) => Promise<bigint>;
    broadcastTransaction: ((signedTx: string) => Promise<TransactionResponse>) | ((signedTx: string) => Promise<TransactionResponse>);
    call: (params: CallParams) => Promise<unknown>;
    createContract: (address: string, abi: readonly (JsonFragment | Fragment)[], provider: Provider) => Promise<Contract>;
    createContractTxObject: (params: CallParams) => Promise<ContractTransaction>;
    EIP1193SendTransaction: (tx: EIP1559TxParams) => Promise<string>;
    estimateCall: (params: EstimateCallParams) => Promise<bigint>;
    estimateGasLimit: ({ assetValue, recipient, memo, }: WalletTxParams & {
        assetValue: AssetValue;
    }) => Promise<bigint>;
    estimateGasPrices: () => Promise<{
        average: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
        fast: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
        fastest: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
    } | {
        average: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
        fast: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
        fastest: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
    }>;
    isApproved: (params: IsApprovedParams) => Promise<boolean>;
    sendTransaction: (params: EIP1559TxParams, feeOption: FeeOption) => Promise<string | TransactionResponse>;
    transfer: (params: TransferParams) => Promise<string | TransactionResponse>;
    validateAddress: (address: string) => boolean;
} & {}>;

export declare type IsApprovedParams = ApprovedParams & {
    amount?: BigNumberish;
};

export declare const isDetected: (walletOption: WalletOption) => boolean;

export declare const isWeb3Detected: () => boolean;

export declare type LegacyEVMTxParams<T = bigint> = EVMTxBaseParams<T> & {
    gasPrice?: T;
};

export declare const MATICToolbox: ({ api, provider, signer, covalentApiKey, }: {
    api?: {
        getBalance: (address: any) => Promise<{
            value: string;
            decimal: number;
            chain: Chain;
            symbol: string;
        }[]>;
    } | undefined;
    covalentApiKey: string;
    signer: Signer;
    provider: JsonRpcProvider | BrowserProvider;
}) => {
    getNetworkParams: () => {
        chainId: ChainId;
        chainName: string;
        nativeCurrency: {
            name: string;
            symbol: Chain;
            decimals: BaseDecimal;
        };
        rpcUrls: RPCUrl[];
        blockExplorerUrls: string[];
    };
    getBalance: (address: any, potentialScamFilter?: boolean) => Promise<{
        address: any;
        chain: Chain;
        isGasAsset: boolean;
        isSynthetic: boolean;
        symbol: string;
        tax?: {
            buy: number;
            sell: number;
        } | undefined;
        ticker: string;
        type: Chain.Avalanche | Chain.Cosmos | Chain.Kujira | "Synth" | "Native" | "BEP2" | "BEP20" | "ERC20" | "POLYGON" | "ARBITRUM" | "OPTIMISM" | undefined;
        decimalMultiplier: bigint;
        bigIntValue: bigint;
        decimal?: number | undefined;
    }[]>;
    approve: (params: ApproveParams) => Promise<string>;
    approvedAmount: (params: ApprovedParams) => Promise<bigint>;
    broadcastTransaction: ((signedTx: string) => Promise<TransactionResponse>) | ((signedTx: string) => Promise<TransactionResponse>);
    call: (params: CallParams) => Promise<unknown>;
    createContract: (address: string, abi: readonly (JsonFragment | Fragment)[], provider: Provider) => Promise<Contract>;
    createContractTxObject: (params: CallParams) => Promise<ContractTransaction>;
    EIP1193SendTransaction: (tx: EIP1559TxParams) => Promise<string>;
    estimateCall: (params: EstimateCallParams) => Promise<bigint>;
    estimateGasLimit: ({ assetValue, recipient, memo, }: WalletTxParams & {
        assetValue: AssetValue;
    }) => Promise<bigint>;
    estimateGasPrices: () => Promise<{
        average: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
        fast: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
        fastest: {
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
            gasPrice?: undefined;
        };
    } | {
        average: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
        fast: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
        fastest: {
            gasPrice: bigint;
            maxFeePerGas?: undefined;
            maxPriorityFeePerGas?: undefined;
        };
    }>;
    isApproved: (params: IsApprovedParams) => Promise<boolean>;
    sendTransaction: (params: EIP1559TxParams, feeOption: FeeOption) => Promise<string | TransactionResponse>;
    transfer: (params: TransferParams) => Promise<string | TransactionResponse>;
    validateAddress: (address: string) => boolean;
};

export declare const MAX_APPROVAL: bigint;

declare type NetworkParams = {
    chainId: ChainId;
    chainName: string;
    nativeCurrency: {
        name: string;
        symbol: string;
        decimals: number;
    };
    rpcUrls: string[];
    blockExplorerUrls: string[];
};

export declare const OPToolbox: ({ api, provider, signer, covalentApiKey, }: {
    api?: {
        getBalance: (address: any) => Promise<{
            value: string;
            decimal: number;
            chain: Chain;
            symbol: string;
        }[]>;
    } | undefined;
    covalentApiKey: string;
    signer: Signer;
    provider: JsonRpcProvider | BrowserProvider;
}) => {
    estimateTotalGasCost: (tx: TransactionRequest) => Promise<any>;
    estimateL1GasCost: (tx: TransactionRequest) => Promise<any>;
    estimateL2GasCost: (tx: TransactionRequest) => Promise<any>;
    getL1GasPrice: () => Promise<bigint>;
    estimateL1Gas: (tx: TransactionRequest) => Promise<any>;
    getNetworkParams: () => {
        chainId: ChainId;
        chainName: string;
        nativeCurrency: {
            name: string;
            symbol: Chain;
            decimals: BaseDecimal;
        };
        rpcUrls: RPCUrl[];
        blockExplorerUrls: string[];
    };
    estimateGasPrices: () => Promise<{
        average: {
            l1GasPrice: bigint;
            gasPrice: bigint | null;
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
        };
        fast: {
            l1GasPrice: bigint;
            gasPrice: bigint;
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
        };
        fastest: {
            l1GasPrice: bigint;
            gasPrice: bigint;
            maxFeePerGas: bigint;
            maxPriorityFeePerGas: bigint;
        };
    }>;
    getBalance: (address: any, potentialScamFilter?: boolean) => Promise<{
        address: any;
        chain: Chain;
        isGasAsset: boolean;
        isSynthetic: boolean;
        symbol: string;
        tax?: {
            buy: number;
            sell: number;
        } | undefined;
        ticker: string;
        type: Chain.Avalanche | Chain.Cosmos | Chain.Kujira | "Synth" | "Native" | "BEP2" | "BEP20" | "ERC20" | "POLYGON" | "ARBITRUM" | "OPTIMISM" | undefined;
        decimalMultiplier: bigint;
        bigIntValue: bigint;
        decimal?: number | undefined;
    }[]>;
    approve: (params: ApproveParams) => Promise<string>;
    approvedAmount: (params: ApprovedParams) => Promise<bigint>;
    broadcastTransaction: ((signedTx: string) => Promise<TransactionResponse>) | ((signedTx: string) => Promise<TransactionResponse>);
    call: (params: CallParams) => Promise<unknown>;
    createContract: (address: string, abi: readonly (JsonFragment | Fragment)[], provider: Provider) => Promise<Contract>;
    createContractTxObject: (params: CallParams) => Promise<ContractTransaction>;
    EIP1193SendTransaction: (tx: EIP1559TxParams) => Promise<string>;
    estimateCall: (params: EstimateCallParams) => Promise<bigint>;
    estimateGasLimit: ({ assetValue, recipient, memo, }: WalletTxParams & {
        assetValue: AssetValue;
    }) => Promise<bigint>;
    isApproved: (params: IsApprovedParams) => Promise<boolean>;
    sendTransaction: (params: EIP1559TxParams, feeOption: FeeOption) => Promise<string | TransactionResponse>;
    transfer: (params: TransferParams) => Promise<string | TransactionResponse>;
    validateAddress: (address: string) => boolean;
};

export declare const prepareNetworkSwitch: <T extends {
    [key: string]: (...args: any[]) => any;
}>({ toolbox, chainId, provider, }: {
    toolbox: T;
    chainId: ChainId;
    provider?: BrowserProvider | undefined;
}) => T & {};

declare interface PriceInfo {
    rate: number;
    diff: number;
    diff7d?: number;
    ts: number;
    marketCapUsd?: number;
    availableSupply?: number;
    volume24h?: number;
    diff30d?: number;
    volDiff1?: number;
    volDiff7?: number;
    volDiff30?: number;
    currency?: string;
}

export declare const switchEVMWalletNetwork: (provider: BrowserProvider, chainId?: ChainId) => Promise<any>;

/**
 * Exported helper functions
 */
export declare const toChecksumAddress: (address: string) => string;

export declare const toHexString: (value: bigint) => string;

declare interface TokenBalance {
    tokenInfo: TokenInfo;
    balance: number;
    rawBalance: string;
    totalIn?: number;
    totalOut?: number;
}

declare interface TokenInfo {
    address: string;
    decimals: string;
    name: string;
    owner: string;
    symbol: string;
    totalSupply: string;
    lastUpdated: number;
    issuancesCount: number;
    holdersCount: number;
    image?: string;
    description?: string;
    website?: string;
    twitter?: string;
    facebook?: string;
    coingecko?: string;
    ethTransfersCount: number;
    price: boolean | PriceInfo | unknown;
    publicTags?: string[];
    txsCount?: number;
    transfersCount?: number;
}

export declare type TransferParams = WalletTxParams & {
    gasLimit?: bigint;
    gasPrice?: bigint;
    maxFeePerGas?: bigint;
    maxPriorityFeePerGas?: bigint;
    data?: string;
    from: string;
    nonce?: number;
    assetValue: AssetValue;
};

export declare const wrapMethodWithNetworkSwitch: <T extends (...args: any[]) => any>(func: T, provider: BrowserProvider, chainId: ChainId) => T;

export { }
