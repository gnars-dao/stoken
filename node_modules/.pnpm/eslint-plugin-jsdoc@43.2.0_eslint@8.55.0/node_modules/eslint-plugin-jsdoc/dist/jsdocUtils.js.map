{"version":3,"file":"jsdocUtils.js","names":["_jsdoccomment","require","_WarnSettings","_interopRequireDefault","_getDefaultTagStructureForMode","_tagNames","_hasReturnValue","obj","__esModule","default","tagStructure","setTagStructure","mode","getDefaultTagStructureForMode","flattenRoots","params","root","hasRestElement","hasPropertyRest","rests","names","reduce","acc","cur","Array","isArray","nms","flattened","inner","filter","Boolean","push","concat","isRestProperty","restElement","name","getPropertiesFromPropertySignature","propSignature","type","undefined","typeAnnotation","key","members","map","member","getFunctionParameterNames","functionNode","checkDefaultObjects","_functionNode$value","getParamName","param","isProperty","_param$left","_param$left3","hasLeftTypeAnnotation","left","_typeAnnotation$typeA","propertyNames","annotationParamName","hasLeftName","_param$left2","properties","roots","prop","value","elements","idx","right","raw","_param$left4","includes","argument","parameter","Error","hasParams","length","getJsdocTagsDeep","jsdoc","targetTagName","ret","tag","tags","entries","modeWarnSettings","WarnSettings","getTagNamesForMode","context","jsdocTags","typeScriptTags","closureTags","hasBeenWarned","report","loc","start","column","line","message","markSettingAsWarned","getPreferredTagName","tagPreference","_Object$entries$find","prefValues","Object","values","some","prefVal","replacement","tagPreferenceFixed","fromEntries","replace","prototype","hasOwnProperty","call","tagNames","preferredTagName","find","aliases","isValidTag","definedTags","validTagNames","keys","flat","additionalTags","allTags","hasTag","targetTagLower","toLowerCase","doc","hasATag","targetTagNames","mayBeUndefinedTypeTag","tagType","trim","parsedTypes","tryParse","elem","ensureMap","has","set","Map","get","overrideTagStructure","structuredTags","tagMap","required","tagStruct","requiredName","requiredType","typeOrNameRequired","getTagStructureForMode","isNamepathDefiningTag","tagMustHaveTypePosition","tagMightHaveTypePosition","namepathTypes","Set","tagMightHaveNamePosition","tagMightHaveNamepath","tagMustHaveNamePosition","tagMightHaveEitherTypeOrNamePosition","tagMustHaveEitherTypeOrNamePosition","tagMissingRequiredTypeOrNamepath","mustHaveTypePosition","mightHaveTypePosition","hasTypePosition","hasNameOrNamepathPosition","mustHaveEither","hasEither","hasNonFunctionYield","node","checkYieldReturnValue","body","bodyNode","arguments","element","expression","test","consequent","alternate","block","handler","finalizer","cases","someCase","nde","declarations","id","init","expressions","subExpression","property","computed","quasi","object","source","parent","hasYieldValue","generator","hasThrowValue","innerFunction","async","parseClosureTemplateTag","split","enforcedContexts","defaultContexts","settings","_context$options$","contexts","options","getContextObject","checkJsdoc","selInfo","lastIndex","selector","comment","bind","old","args","filterTags","tagsWithNamesAndDescriptions","getTagsByType","descName","tagsWithoutNames","tagsWithNames","tagName","tagWithName","getIndent","sourceCode","_sourceCode$text$matc","text","match","isConstructor","_node$parent","kind","isGetter","_node$parent2","isSetter","_node$parent3","hasAccessorPair","sourceKind","sourceName","oppositeKind","children","exemptSpeciaMethods","schema","hasSchemaOption","_context$options$2","schemaProperties","checkGetters","checkSetters","dropPathSegmentQuotes","str","comparePaths","otherPathName","pathDoesNotBeginWith","startsWith","getRegexFromString","regexString","requiredFlags","flags","regex","uniqueFlags","join","RegExp","_default","hasReturnValue","hasValueOrExecutorHasNonEmptyResolveValue","exports","module"],"sources":["../src/jsdocUtils.js"],"sourcesContent":["/* eslint-disable jsdoc/no-undefined-types */\n\nimport {\n  tryParse,\n} from '@es-joy/jsdoccomment';\nimport WarnSettings from './WarnSettings';\nimport getDefaultTagStructureForMode from './getDefaultTagStructureForMode';\nimport {\n  jsdocTags,\n  closureTags,\n  typeScriptTags,\n} from './tagNames';\nimport {\n  hasReturnValue,\n  hasValueOrExecutorHasNonEmptyResolveValue,\n} from './utils/hasReturnValue';\n\n/**\n * @typedef {\"jsdoc\"|\"typescript\"|\"closure\"} ParserMode\n */\n\nlet tagStructure;\n\nconst setTagStructure = (mode) => {\n  tagStructure = getDefaultTagStructureForMode(mode);\n};\n\n// Given a nested array of property names, reduce them to a single array,\n// appending the name of the root element along the way if present.\nconst flattenRoots = (params, root = '') => {\n  let hasRestElement = false;\n  let hasPropertyRest = false;\n  const rests = [];\n\n  const names = params.reduce((acc, cur) => {\n    if (Array.isArray(cur)) {\n      let nms;\n      if (Array.isArray(cur[1])) {\n        nms = cur[1];\n      } else {\n        if (cur[1].hasRestElement) {\n          hasRestElement = true;\n        }\n\n        if (cur[1].hasPropertyRest) {\n          hasPropertyRest = true;\n        }\n\n        nms = cur[1].names;\n      }\n\n      const flattened = flattenRoots(nms, root ? `${root}.${cur[0]}` : cur[0]);\n      if (flattened.hasRestElement) {\n        hasRestElement = true;\n      }\n\n      if (flattened.hasPropertyRest) {\n        hasPropertyRest = true;\n      }\n\n      const inner = [\n        root ? `${root}.${cur[0]}` : cur[0],\n        ...flattened.names,\n      ].filter(Boolean);\n      rests.push(false, ...flattened.rests);\n\n      return acc.concat(inner);\n    }\n\n    if (typeof cur === 'object') {\n      if (cur.isRestProperty) {\n        hasPropertyRest = true;\n        rests.push(true);\n      } else {\n        rests.push(false);\n      }\n\n      if (cur.restElement) {\n        hasRestElement = true;\n      }\n\n      acc.push(root ? `${root}.${cur.name}` : cur.name);\n    } else if (typeof cur !== 'undefined') {\n      rests.push(false);\n      acc.push(root ? `${root}.${cur}` : cur);\n    }\n\n    return acc;\n  }, []);\n\n  return {\n    hasPropertyRest,\n    hasRestElement,\n    names,\n    rests,\n  };\n};\n\n/**\n * @param {object} propSignature\n * @returns {undefined|Array|string}\n */\nconst getPropertiesFromPropertySignature = (propSignature) => {\n  if (\n    propSignature.type === 'TSIndexSignature' ||\n    propSignature.type === 'TSConstructSignatureDeclaration' ||\n    propSignature.type === 'TSCallSignatureDeclaration'\n  ) {\n    return undefined;\n  }\n\n  if (propSignature.typeAnnotation && propSignature.typeAnnotation.typeAnnotation.type === 'TSTypeLiteral') {\n    return [\n      propSignature.key.name, propSignature.typeAnnotation.typeAnnotation.members.map((member) => {\n        return getPropertiesFromPropertySignature(member);\n      }),\n    ];\n  }\n\n  return propSignature.key.name;\n};\n\n/**\n * @param {object} functionNode\n * @param {boolean} checkDefaultObjects\n * @returns {Array}\n */\nconst getFunctionParameterNames = (\n  functionNode, checkDefaultObjects,\n) => {\n  // eslint-disable-next-line complexity\n  const getParamName = (param, isProperty) => {\n    const hasLeftTypeAnnotation = 'left' in param && 'typeAnnotation' in param.left;\n\n    if ('typeAnnotation' in param || hasLeftTypeAnnotation) {\n      const typeAnnotation = hasLeftTypeAnnotation ? param.left.typeAnnotation : param.typeAnnotation;\n\n      if (typeAnnotation?.typeAnnotation?.type === 'TSTypeLiteral') {\n        const propertyNames = typeAnnotation.typeAnnotation.members.map((member) => {\n          return getPropertiesFromPropertySignature(member);\n        });\n        const flattened = {\n          ...flattenRoots(propertyNames),\n          annotationParamName: param.name,\n        };\n        const hasLeftName = 'left' in param && 'name' in param.left;\n\n        if ('name' in param || hasLeftName) {\n          return [\n            hasLeftName ? param.left.name : param.name, flattened,\n          ];\n        }\n\n        return [\n          undefined, flattened,\n        ];\n      }\n    }\n\n    if ('name' in param) {\n      return param.name;\n    }\n\n    if ('left' in param && 'name' in param.left) {\n      return param.left.name;\n    }\n\n    if (param.type === 'ObjectPattern' || param.left?.type === 'ObjectPattern') {\n      const properties = param.properties || param.left?.properties;\n      const roots = properties.map((prop) => {\n        return getParamName(prop, true);\n      });\n\n      return [\n        undefined, flattenRoots(roots),\n      ];\n    }\n\n    if (param.type === 'Property') {\n      // eslint-disable-next-line default-case\n      switch (param.value.type) {\n      case 'ArrayPattern':\n        return [\n          param.key.name, param.value.elements.map((prop, idx) => {\n            return {\n              name: idx,\n              restElement: prop.type === 'RestElement',\n            };\n          }),\n        ];\n      case 'ObjectPattern':\n        return [\n          param.key.name, param.value.properties.map((prop) => {\n            return getParamName(prop, isProperty);\n          }),\n        ];\n      case 'AssignmentPattern': {\n        // eslint-disable-next-line default-case\n        switch (param.value.left.type) {\n        case 'Identifier':\n          // Default parameter\n          if (checkDefaultObjects && param.value.right.type === 'ObjectExpression') {\n            return [\n              param.key.name, param.value.right.properties.map((prop) => {\n                return getParamName(prop, isProperty);\n              }),\n            ];\n          }\n\n          break;\n        case 'ObjectPattern':\n          return [\n            param.key.name, param.value.left.properties.map((prop) => {\n              return getParamName(prop, isProperty);\n            }),\n          ];\n        case 'ArrayPattern':\n          return [\n            param.key.name, param.value.left.elements.map((prop, idx) => {\n              return {\n                name: idx,\n                restElement: prop.type === 'RestElement',\n              };\n            }),\n          ];\n        }\n      }\n      }\n\n      switch (param.key.type) {\n      case 'Identifier':\n        return param.key.name;\n\n      // The key of an object could also be a string or number\n      case 'Literal':\n        return param.key.raw ||\n          // istanbul ignore next -- `raw` may not be present in all parsers\n          param.key.value;\n\n      // case 'MemberExpression':\n      default:\n        // Todo: We should really create a structure (and a corresponding\n        //   option analogous to `checkRestProperty`) which allows for\n        //   (and optionally requires) dynamic properties to have a single\n        //   line of documentation\n        return undefined;\n      }\n    }\n\n    if (param.type === 'ArrayPattern' || param.left?.type === 'ArrayPattern') {\n      const elements = param.elements || param.left?.elements;\n      const roots = elements.map((prop, idx) => {\n        return {\n          name: `\"${idx}\"`,\n          restElement: prop?.type === 'RestElement',\n        };\n      });\n\n      return [\n        undefined, flattenRoots(roots),\n      ];\n    }\n\n    if ([\n      'RestElement', 'ExperimentalRestProperty',\n    ].includes(param.type)) {\n      return {\n        isRestProperty: isProperty,\n        name: param.argument.name,\n        restElement: true,\n      };\n    }\n\n    if (param.type === 'TSParameterProperty') {\n      return getParamName(param.parameter, true);\n    }\n\n    throw new Error(`Unsupported function signature format: \\`${param.type}\\`.`);\n  };\n\n  if (!functionNode) {\n    return [];\n  }\n\n  return (functionNode.params || functionNode.value?.params || []).map((param) => {\n    return getParamName(param);\n  });\n};\n\n/**\n * @param {Node} functionNode\n * @returns {Integer}\n */\nconst hasParams = (functionNode) => {\n  // Should also check `functionNode.value.params` if supporting `MethodDefinition`\n  return functionNode.params.length;\n};\n\n/**\n * Gets all names of the target type, including those that refer to a path, e.g.\n * \"@param foo; @param foo.bar\".\n *\n * @param {object} jsdoc\n * @param {string} targetTagName\n * @returns {Array<object>}\n */\nconst getJsdocTagsDeep = (jsdoc, targetTagName) => {\n  const ret = [];\n  for (const [\n    idx,\n    {\n      name,\n      tag,\n      type,\n    },\n  ] of jsdoc.tags.entries()) {\n    if (tag !== targetTagName) {\n      continue;\n    }\n\n    ret.push({\n      idx,\n      name,\n      type,\n    });\n  }\n\n  return ret;\n};\n\nconst modeWarnSettings = WarnSettings();\n\n/**\n * @param {string} mode\n * @param context\n */\nconst getTagNamesForMode = (mode, context) => {\n  switch (mode) {\n  case 'jsdoc':\n    return jsdocTags;\n  case 'typescript':\n    return typeScriptTags;\n  case 'closure': case 'permissive':\n    return closureTags;\n  default:\n    if (!modeWarnSettings.hasBeenWarned(context, 'mode')) {\n      context.report({\n        loc: {\n          start: {\n            column: 1,\n            line: 1,\n          },\n        },\n        message: `Unrecognized value \\`${mode}\\` for \\`settings.jsdoc.mode\\`.`,\n      });\n      modeWarnSettings.markSettingAsWarned(context, 'mode');\n    }\n\n    // We'll avoid breaking too many other rules\n    return jsdocTags;\n  }\n};\n\n/**\n * @param context\n * @param {ParserMode} mode\n * @param {string} name\n * @param {object} tagPreference\n * @returns {string|object}\n */\nconst getPreferredTagName = (\n  context,\n  mode,\n  name,\n  tagPreference = {},\n) => {\n  const prefValues = Object.values(tagPreference);\n  if (prefValues.includes(name) || prefValues.some((prefVal) => {\n    return prefVal && typeof prefVal === 'object' && prefVal.replacement === name;\n  })) {\n    return name;\n  }\n\n  // Allow keys to have a 'tag ' prefix to avoid upstream bug in ESLint\n  // that disallows keys that conflict with Object.prototype,\n  // e.g. 'tag constructor' for 'constructor':\n  // https://github.com/eslint/eslint/issues/13289\n  // https://github.com/gajus/eslint-plugin-jsdoc/issues/537\n  const tagPreferenceFixed = Object.fromEntries(\n    Object\n      .entries(tagPreference)\n      .map(([\n        key,\n        value,\n      ]) => {\n        return [\n          key.replace(/^tag /u, ''), value,\n        ];\n      }),\n  );\n\n  if (Object.prototype.hasOwnProperty.call(tagPreferenceFixed, name)) {\n    return tagPreferenceFixed[name];\n  }\n\n  const tagNames = getTagNamesForMode(mode, context);\n\n  const preferredTagName = Object.entries(tagNames).find(([\n    , aliases,\n  ]) => {\n    return aliases.includes(name);\n  })?.[0];\n  if (preferredTagName) {\n    return preferredTagName;\n  }\n\n  return name;\n};\n\n/**\n * @param context\n * @param {ParserMode} mode\n * @param {string} name\n * @param {Array} definedTags\n * @returns {boolean}\n */\nconst isValidTag = (\n  context,\n  mode,\n  name,\n  definedTags,\n) => {\n  const tagNames = getTagNamesForMode(mode, context);\n\n  const validTagNames = Object.keys(tagNames).concat(Object.values(tagNames).flat());\n  const additionalTags = definedTags;\n  const allTags = validTagNames.concat(additionalTags);\n\n  return allTags.includes(name);\n};\n\n/**\n * @param {object} jsdoc\n * @param {string} targetTagName\n * @returns {boolean}\n */\nconst hasTag = (jsdoc, targetTagName) => {\n  const targetTagLower = targetTagName.toLowerCase();\n\n  return jsdoc.tags.some((doc) => {\n    return doc.tag.toLowerCase() === targetTagLower;\n  });\n};\n\n/**\n * @param {object} jsdoc\n * @param {Array} targetTagNames\n * @returns {boolean}\n */\nconst hasATag = (jsdoc, targetTagNames) => {\n  return targetTagNames.some((targetTagName) => {\n    return hasTag(jsdoc, targetTagName);\n  });\n};\n\n/**\n * Checks if the JSDoc comment has an undefined type.\n *\n * @param {JsDocTag} tag\n *   the tag which should be checked.\n * @param {\"jsdoc\"|\"closure\"|\"typescript\"} mode\n * @returns {boolean}\n *   true in case a defined type is undeclared; otherwise false.\n */\nconst mayBeUndefinedTypeTag = (tag, mode) => {\n  // The function should not continue in the event the type is not defined...\n  if (typeof tag === 'undefined' || tag === null) {\n    return true;\n  }\n\n  // .. same applies if it declares an `{undefined}` or `{void}` type\n  const tagType = tag.type.trim();\n\n  // Exit early if matching\n  if (\n    tagType === 'undefined' || tagType === 'void' ||\n    tagType === '*' || tagType === 'any'\n  ) {\n    return true;\n  }\n\n  let parsedTypes;\n  try {\n    parsedTypes = tryParse(\n      tagType,\n      mode === 'permissive' ? undefined : [\n        mode,\n      ],\n    );\n  } catch {\n    // Ignore\n  }\n\n  if (\n    // We do not traverse deeply as it could be, e.g., `Promise<void>`\n    parsedTypes &&\n    parsedTypes.type === 'JsdocTypeUnion' &&\n    parsedTypes.elements.find((elem) => {\n      return elem.type === 'JsdocTypeUndefined' ||\n        elem.type === 'JsdocTypeName' && elem.value === 'void';\n    })) {\n    return true;\n  }\n\n  // In any other case, a type is present\n  return false;\n};\n\n/**\n * @param map\n * @param tag\n * @returns {Map}\n */\nconst ensureMap = (map, tag) => {\n  if (!map.has(tag)) {\n    map.set(tag, new Map());\n  }\n\n  return map.get(tag);\n};\n\n/**\n * @param structuredTags\n * @param tagMap\n */\nconst overrideTagStructure = (structuredTags, tagMap = tagStructure) => {\n  for (const [\n    tag,\n    {\n      name,\n      type,\n      required = [],\n    },\n  ] of Object.entries(structuredTags)) {\n    const tagStruct = ensureMap(tagMap, tag);\n\n    tagStruct.set('nameContents', name);\n    tagStruct.set('typeAllowed', type);\n\n    const requiredName = required.includes('name');\n    if (requiredName && name === false) {\n      throw new Error('Cannot add \"name\" to `require` with the tag\\'s `name` set to `false`');\n    }\n\n    tagStruct.set('nameRequired', requiredName);\n\n    const requiredType = required.includes('type');\n    if (requiredType && type === false) {\n      throw new Error('Cannot add \"type\" to `require` with the tag\\'s `type` set to `false`');\n    }\n\n    tagStruct.set('typeRequired', requiredType);\n\n    const typeOrNameRequired = required.includes('typeOrNameRequired');\n    if (typeOrNameRequired && name === false) {\n      throw new Error('Cannot add \"typeOrNameRequired\" to `require` with the tag\\'s `name` set to `false`');\n    }\n\n    if (typeOrNameRequired && type === false) {\n      throw new Error('Cannot add \"typeOrNameRequired\" to `require` with the tag\\'s `type` set to `false`');\n    }\n\n    tagStruct.set('typeOrNameRequired', typeOrNameRequired);\n  }\n};\n\n/**\n * @param mode\n * @param structuredTags\n * @returns {Map}\n */\nconst getTagStructureForMode = (mode, structuredTags) => {\n  const tagStruct = getDefaultTagStructureForMode(mode);\n\n  try {\n    overrideTagStructure(structuredTags, tagStruct);\n  } catch {\n    //\n  }\n\n  return tagStruct;\n};\n\n/**\n * @param tag\n * @param {Map} tagMap\n * @returns {boolean}\n */\nconst isNamepathDefiningTag = (tag, tagMap = tagStructure) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  return tagStruct.get('nameContents') === 'namepath-defining';\n};\n\n/**\n * @param tag\n * @param {Map} tagMap\n * @returns {boolean}\n */\nconst tagMustHaveTypePosition = (tag, tagMap = tagStructure) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  return tagStruct.get('typeRequired');\n};\n\n/**\n * @param tag\n * @param {Map} tagMap\n * @returns {boolean}\n */\nconst tagMightHaveTypePosition = (tag, tagMap = tagStructure) => {\n  if (tagMustHaveTypePosition(tag, tagMap)) {\n    return true;\n  }\n\n  const tagStruct = ensureMap(tagMap, tag);\n\n  const ret = tagStruct.get('typeAllowed');\n\n  return ret === undefined ? true : ret;\n};\n\nconst namepathTypes = new Set([\n  'namepath-defining', 'namepath-referencing',\n]);\n\n/**\n * @param tag\n * @param {Map} tagMap\n * @returns {boolean}\n */\nconst tagMightHaveNamePosition = (tag, tagMap = tagStructure) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  const ret = tagStruct.get('nameContents');\n\n  return ret === undefined ? true : Boolean(ret);\n};\n\n/**\n * @param tag\n * @param {Map} tagMap\n * @returns {boolean}\n */\nconst tagMightHaveNamepath = (tag, tagMap = tagStructure) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  return namepathTypes.has(tagStruct.get('nameContents'));\n};\n\n/**\n * @param tag\n * @param {Map} tagMap\n * @returns {boolean}\n */\nconst tagMustHaveNamePosition = (tag, tagMap = tagStructure) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  return tagStruct.get('nameRequired');\n};\n\n/**\n * @param tag\n * @param {Map} tagMap\n * @returns {boolean}\n */\nconst tagMightHaveEitherTypeOrNamePosition = (tag, tagMap) => {\n  return tagMightHaveTypePosition(tag, tagMap) || tagMightHaveNamepath(tag, tagMap);\n};\n\n/**\n * @param tag\n * @param {Map} tagMap\n * @returns {boolean}\n */\nconst tagMustHaveEitherTypeOrNamePosition = (tag, tagMap) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  return tagStruct.get('typeOrNameRequired');\n};\n\n/**\n * @param tag\n * @param {Map} tagMap\n * @returns {boolean}\n */\nconst tagMissingRequiredTypeOrNamepath = (tag, tagMap = tagStructure) => {\n  const mustHaveTypePosition = tagMustHaveTypePosition(tag.tag, tagMap);\n  const mightHaveTypePosition = tagMightHaveTypePosition(tag.tag, tagMap);\n  const hasTypePosition = mightHaveTypePosition && Boolean(tag.type);\n  const hasNameOrNamepathPosition = (\n    tagMustHaveNamePosition(tag.tag, tagMap) ||\n    tagMightHaveNamepath(tag.tag, tagMap)\n  ) && Boolean(tag.name);\n  const mustHaveEither = tagMustHaveEitherTypeOrNamePosition(tag.tag, tagMap);\n  const hasEither = tagMightHaveEitherTypeOrNamePosition(tag.tag, tagMap) &&\n    (hasTypePosition || hasNameOrNamepathPosition);\n\n  return mustHaveEither && !hasEither && !mustHaveTypePosition;\n};\n\n// eslint-disable-next-line complexity\nconst hasNonFunctionYield = (node, checkYieldReturnValue) => {\n  if (!node) {\n    return false;\n  }\n\n  switch (node.type) {\n  case 'BlockStatement': {\n    return node.body.some((bodyNode) => {\n      return ![\n        'ArrowFunctionExpression',\n        'FunctionDeclaration',\n        'FunctionExpression',\n      ].includes(bodyNode.type) && hasNonFunctionYield(\n        bodyNode, checkYieldReturnValue,\n      );\n    });\n  }\n\n  // istanbul ignore next -- In Babel?\n  case 'OptionalCallExpression':\n  case 'CallExpression':\n    return node.arguments.some((element) => {\n      return hasNonFunctionYield(element, checkYieldReturnValue);\n    });\n  case 'ChainExpression':\n  case 'ExpressionStatement': {\n    return hasNonFunctionYield(node.expression, checkYieldReturnValue);\n  }\n\n  case 'LabeledStatement':\n  case 'WhileStatement':\n  case 'DoWhileStatement':\n  case 'ForStatement':\n  case 'ForInStatement':\n  case 'ForOfStatement':\n  case 'WithStatement': {\n    return hasNonFunctionYield(node.body, checkYieldReturnValue);\n  }\n\n  case 'ConditionalExpression':\n  case 'IfStatement': {\n    return hasNonFunctionYield(node.test, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.consequent, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.alternate, checkYieldReturnValue);\n  }\n\n  case 'TryStatement': {\n    return hasNonFunctionYield(node.block, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.handler && node.handler.body, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.finalizer, checkYieldReturnValue);\n  }\n\n  case 'SwitchStatement': {\n    return node.cases.some(\n      (someCase) => {\n        return someCase.consequent.some((nde) => {\n          return hasNonFunctionYield(nde, checkYieldReturnValue);\n        });\n      },\n    );\n  }\n\n  case 'ArrayPattern':\n  case 'ArrayExpression':\n    return node.elements.some((element) => {\n      return hasNonFunctionYield(element, checkYieldReturnValue);\n    });\n  case 'AssignmentPattern':\n    return hasNonFunctionYield(node.right, checkYieldReturnValue);\n\n  case 'VariableDeclaration': {\n    return node.declarations.some((nde) => {\n      return hasNonFunctionYield(nde, checkYieldReturnValue);\n    });\n  }\n\n  case 'VariableDeclarator': {\n    return hasNonFunctionYield(node.id, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.init, checkYieldReturnValue);\n  }\n\n  case 'AssignmentExpression':\n  case 'BinaryExpression':\n  case 'LogicalExpression': {\n    return hasNonFunctionYield(node.left, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.right, checkYieldReturnValue);\n  }\n\n  // Comma\n  case 'SequenceExpression':\n  case 'TemplateLiteral':\n    return node.expressions.some((subExpression) => {\n      return hasNonFunctionYield(subExpression, checkYieldReturnValue);\n    });\n\n  case 'ObjectPattern':\n  case 'ObjectExpression':\n    return node.properties.some((property) => {\n      return hasNonFunctionYield(property, checkYieldReturnValue);\n    });\n\n  // istanbul ignore next -- In Babel?\n  case 'PropertyDefinition':\n  /* eslint-disable no-fallthrough */\n  // istanbul ignore next -- In Babel?\n  case 'ObjectProperty':\n  // istanbul ignore next -- In Babel?\n  case 'ClassProperty':\n  case 'Property':\n  /* eslint-enable no-fallthrough */\n    return node.computed && hasNonFunctionYield(node.key, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.value, checkYieldReturnValue);\n  // istanbul ignore next -- In Babel?\n  case 'ObjectMethod':\n    // istanbul ignore next -- In Babel?\n    return node.computed && hasNonFunctionYield(node.key, checkYieldReturnValue) ||\n      node.arguments.some((nde) => {\n        return hasNonFunctionYield(nde, checkYieldReturnValue);\n      });\n\n  case 'SpreadElement':\n  case 'UnaryExpression':\n    return hasNonFunctionYield(node.argument, checkYieldReturnValue);\n\n  case 'TaggedTemplateExpression':\n    return hasNonFunctionYield(node.quasi, checkYieldReturnValue);\n\n  // ?.\n  // istanbul ignore next -- In Babel?\n  case 'OptionalMemberExpression':\n  case 'MemberExpression':\n    return hasNonFunctionYield(node.object, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.property, checkYieldReturnValue);\n\n  // istanbul ignore next -- In Babel?\n  case 'Import':\n  case 'ImportExpression':\n    return hasNonFunctionYield(node.source, checkYieldReturnValue);\n\n  case 'ReturnStatement': {\n    if (node.argument === null) {\n      return false;\n    }\n\n    return hasNonFunctionYield(node.argument, checkYieldReturnValue);\n  }\n\n  case 'YieldExpression': {\n    if (checkYieldReturnValue) {\n      if (node.parent.type === 'VariableDeclarator') {\n        return true;\n      }\n\n      return false;\n    }\n\n    // void return does not count.\n    if (node.argument === null) {\n      return false;\n    }\n\n    return true;\n  }\n\n  default: {\n    return false;\n  }\n  }\n};\n\n/**\n * Checks if a node has a return statement. Void return does not count.\n *\n * @param {object} node\n * @returns {boolean}\n */\nconst hasYieldValue = (node, checkYieldReturnValue) => {\n  return node.generator && (\n    node.expression || hasNonFunctionYield(node.body, checkYieldReturnValue)\n  );\n};\n\n/**\n * Checks if a node has a throws statement.\n *\n * @param {object} node\n * @param {boolean} innerFunction\n * @returns {boolean}\n */\n// eslint-disable-next-line complexity\nconst hasThrowValue = (node, innerFunction) => {\n  if (!node) {\n    return false;\n  }\n\n  // There are cases where a function may execute its inner function which\n  //   throws, but we're treating functions atomically rather than trying to\n  //   follow them\n  switch (node.type) {\n  case 'FunctionExpression':\n  case 'FunctionDeclaration':\n  case 'ArrowFunctionExpression': {\n    return !innerFunction && !node.async && hasThrowValue(node.body, true);\n  }\n\n  case 'BlockStatement': {\n    return node.body.some((bodyNode) => {\n      return bodyNode.type !== 'FunctionDeclaration' && hasThrowValue(bodyNode);\n    });\n  }\n\n  case 'LabeledStatement':\n  case 'WhileStatement':\n  case 'DoWhileStatement':\n  case 'ForStatement':\n  case 'ForInStatement':\n  case 'ForOfStatement':\n  case 'WithStatement': {\n    return hasThrowValue(node.body);\n  }\n\n  case 'IfStatement': {\n    return hasThrowValue(node.consequent) || hasThrowValue(node.alternate);\n  }\n\n  // We only consider it to throw an error if the catch or finally blocks throw an error.\n  case 'TryStatement': {\n    return hasThrowValue(node.handler && node.handler.body) ||\n        hasThrowValue(node.finalizer);\n  }\n\n  case 'SwitchStatement': {\n    return node.cases.some(\n      (someCase) => {\n        return someCase.consequent.some((nde) => {\n          return hasThrowValue(nde);\n        });\n      },\n    );\n  }\n\n  case 'ThrowStatement': {\n    return true;\n  }\n\n  default: {\n    return false;\n  }\n  }\n};\n\n/**\n * @param {string} tag\n */\n/*\nconst isInlineTag = (tag) => {\n  return /^(@link|@linkcode|@linkplain|@tutorial) /u.test(tag);\n};\n*/\n\n/**\n * Parses GCC Generic/Template types\n *\n * @see {https://github.com/google/closure-compiler/wiki/Generic-Types}\n * @see {https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#template}\n * @param {JsDocTag} tag\n * @returns {Array<string>}\n */\nconst parseClosureTemplateTag = (tag) => {\n  return tag.name\n    .split(',')\n    .map((type) => {\n      return type.trim().replace(/^\\[(?<name>.*?)=.*\\]$/u, '$<name>');\n    });\n};\n\n/**\n * @typedef {true|string[]} DefaultContexts\n */\n\n/**\n * Checks user option for `contexts` array, defaulting to\n *   contexts designated by the rule. Returns an array of\n *   ESTree AST types, indicating allowable contexts.\n *\n * @param {*} context\n * @param {DefaultContexts} defaultContexts\n * @param settings\n * @returns {string[]}\n */\nconst enforcedContexts = (context, defaultContexts, settings) => {\n  const contexts = context.options[0]?.contexts || settings.contexts || (defaultContexts === true ? [\n    'ArrowFunctionExpression',\n    'FunctionDeclaration',\n    'FunctionExpression',\n    'TSDeclareFunction',\n  ] : defaultContexts);\n\n  return contexts;\n};\n\n/**\n * @param {string[]} contexts\n * @param {Function} checkJsdoc\n * @param {Function} handler\n */\nconst getContextObject = (contexts, checkJsdoc, handler) => {\n  const properties = {};\n\n  for (const [\n    idx,\n    prop,\n  ] of contexts.entries()) {\n    let property;\n    let value;\n\n    if (typeof prop === 'object') {\n      const selInfo = {\n        lastIndex: idx,\n        selector: prop.context,\n      };\n      if (prop.comment) {\n        property = prop.context;\n        value = checkJsdoc.bind(\n          null, {\n            ...selInfo,\n            comment: prop.comment,\n          }, handler.bind(null, prop.comment),\n        );\n      } else {\n        property = prop.context;\n        value = checkJsdoc.bind(null, selInfo, null);\n      }\n    } else {\n      const selInfo = {\n        lastIndex: idx,\n        selector: prop,\n      };\n      property = prop;\n      value = checkJsdoc.bind(null, selInfo, null);\n    }\n\n    const old = properties[property];\n    properties[property] = old ? function (...args) {\n      old(...args);\n      value(...args);\n    } : value;\n  }\n\n  return properties;\n};\n\nconst filterTags = (tags, filter) => {\n  return tags.filter((tag) => {\n    return filter(tag);\n  });\n};\n\nconst tagsWithNamesAndDescriptions = new Set([\n  'param', 'arg', 'argument', 'property', 'prop',\n  'template',\n\n  // These two are parsed by our custom parser as though having a `name`\n  'returns', 'return',\n]);\n\nconst getTagsByType = (context, mode, tags, tagPreference) => {\n  const descName = getPreferredTagName(context, mode, 'description', tagPreference);\n  const tagsWithoutNames = [];\n  const tagsWithNames = filterTags(tags, (tag) => {\n    const {\n      tag: tagName,\n    } = tag;\n    const tagWithName = tagsWithNamesAndDescriptions.has(tagName);\n    if (!tagWithName && tagName !== descName) {\n      tagsWithoutNames.push(tag);\n    }\n\n    return tagWithName;\n  });\n\n  return {\n    tagsWithNames,\n    tagsWithoutNames,\n  };\n};\n\nconst getIndent = (sourceCode) => {\n  return (sourceCode.text.match(/^\\n*([ \\t]+)/u)?.[1] ?? '') + ' ';\n};\n\nconst isConstructor = (node) => {\n  return node?.type === 'MethodDefinition' && node.kind === 'constructor' ||\n    node?.parent?.kind === 'constructor';\n};\n\nconst isGetter = (node) => {\n  return node && node.parent?.kind === 'get';\n};\n\nconst isSetter = (node) => {\n  return node && node.parent?.kind === 'set';\n};\n\nconst hasAccessorPair = (node) => {\n  const {\n    type,\n    kind: sourceKind,\n    key: {\n      name: sourceName,\n    },\n  } = node;\n  const oppositeKind = sourceKind === 'get' ? 'set' : 'get';\n\n  const children = type === 'MethodDefinition' ? 'body' : 'properties';\n\n  return node.parent[children].some(({\n    kind,\n    key: {\n      name,\n    },\n  }) => {\n    return kind === oppositeKind && name === sourceName;\n  });\n};\n\nconst exemptSpeciaMethods = (jsdoc, node, context, schema) => {\n  const hasSchemaOption = (prop) => {\n    const schemaProperties = schema[0].properties;\n\n    return context.options[0]?.[prop] ??\n      (schemaProperties[prop] && schemaProperties[prop].default);\n  };\n\n  const checkGetters = hasSchemaOption('checkGetters');\n  const checkSetters = hasSchemaOption('checkSetters');\n\n  return !hasSchemaOption('checkConstructors') &&\n    (\n      isConstructor(node) ||\n      hasATag(jsdoc, [\n        'class',\n        'constructor',\n      ])) ||\n  isGetter(node) && (\n    !checkGetters ||\n    checkGetters === 'no-setter' && hasAccessorPair(node.parent)\n  ) ||\n  isSetter(node) && (\n    !checkSetters ||\n    checkSetters === 'no-getter' && hasAccessorPair(node.parent)\n  );\n};\n\n/**\n * Since path segments may be unquoted (if matching a reserved word,\n * identifier or numeric literal) or single or double quoted, in either\n * the `@param` or in source, we need to strip the quotes to give a fair\n * comparison.\n *\n * @param {string} str\n * @returns {string}\n */\nconst dropPathSegmentQuotes = (str) => {\n  return str.replace(/\\.(['\"])(.*)\\1/gu, '.$2');\n};\n\n/**\n * @param {string} name\n * @returns {(otherPathName: string) => void}\n */\nconst comparePaths = (name) => {\n  return (otherPathName) => {\n    return otherPathName === name ||\n      dropPathSegmentQuotes(otherPathName) === dropPathSegmentQuotes(name);\n  };\n};\n\n/**\n * @param {string} name\n * @param {string} otherPathName\n * @returns {boolean}\n */\nconst pathDoesNotBeginWith = (name, otherPathName) => {\n  return !name.startsWith(otherPathName) &&\n    !dropPathSegmentQuotes(name).startsWith(dropPathSegmentQuotes(otherPathName));\n};\n\n/**\n * @param {string} regexString\n * @param {string} requiredFlags\n * @returns {RegExp}\n */\nconst getRegexFromString = (regexString, requiredFlags) => {\n  const match = regexString.match(/^\\/(.*)\\/([gimyus]*)$/us);\n  let flags = 'u';\n  let regex = regexString;\n  if (match) {\n    [\n      , regex,\n      flags,\n    ] = match;\n    if (!flags) {\n      flags = 'u';\n    }\n  }\n\n  const uniqueFlags = [\n    ...new Set(flags + (requiredFlags || '')),\n  ];\n  flags = uniqueFlags.join('');\n\n  return new RegExp(regex, flags);\n};\n\nexport default {\n  comparePaths,\n  dropPathSegmentQuotes,\n  enforcedContexts,\n  exemptSpeciaMethods,\n  filterTags,\n  flattenRoots,\n  getContextObject,\n  getFunctionParameterNames,\n  getIndent,\n  getJsdocTagsDeep,\n  getPreferredTagName,\n  getRegexFromString,\n  getTagsByType,\n  getTagStructureForMode,\n  hasATag,\n  hasParams,\n  hasReturnValue,\n  hasTag,\n  hasThrowValue,\n  hasValueOrExecutorHasNonEmptyResolveValue,\n  hasYieldValue,\n  isConstructor,\n  isGetter,\n  isNamepathDefiningTag,\n  isSetter,\n  isValidTag,\n  mayBeUndefinedTypeTag,\n  overrideTagStructure,\n  parseClosureTemplateTag,\n  pathDoesNotBeginWith,\n  setTagStructure,\n  tagMightHaveNamepath,\n  tagMightHaveNamePosition,\n  tagMightHaveTypePosition,\n  tagMissingRequiredTypeOrNamepath,\n  tagMustHaveNamePosition,\n  tagMustHaveTypePosition,\n};\n"],"mappings":"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"}