{"version":3,"file":"sortTags.js","names":["_defaultTagOrder","_interopRequireDefault","require","_iterateJsdoc","obj","__esModule","default","_default","iterateJsdoc","context","jsdoc","utils","linesBetween","tagSequence","defaultTagOrder","alphabetizeExtras","reportTagGroupSpacing","reportIntraTagGroupSpacing","options","tagList","flatMap","tags","otherPos","indexOf","endPos","length","ongoingCount","idx","tag","entries","originalIndex","source","originalLine","firstChangedTagLine","firstChangedTagIndex","sortedTags","JSON","parse","stringify","sort","tagNew","tagOld","checkOrSetFirstChanged","newPos","oldPos","preferredNewPos","preferredOldPos","undefined","lastTagsOfGroup","badLastTagsOfGroup","countTagEmptyLines","reduce","acc","tokens","description","name","type","end","tg","empty","innerIdx","currentTag","lastTag","includes","some","tgs","push","ct","fixer","currIdx","newIdx","emptyLine","seedTokens","delimiter","start","existingEmptyLines","_jsdoc$source$newIdx","nextTokens","lineDiff","lines","Array","from","splice","srcIdx","src","number","reportJSDoc","tagIdx","foundFirstTag","nextIdx","ignore","lastTagOfGroup","_jsdoc$source$nextIdx","_jsdoc$source$nextIdx2","firstLine","getFirstLine","fix","itemsToMoveRange","keys","unchangedPriorTagDescriptions","slice","initialOffset","removeTag","changedTags","extraTagCount","changedTag","addTag","addLine","join","iterateAllJsdocs","meta","docs","url","fixable","schema","additionalProperties","properties","items","exports","module"],"sources":["../../src/rules/sortTags.js"],"sourcesContent":["import defaultTagOrder from '../defaultTagOrder';\nimport iterateJsdoc from '../iterateJsdoc';\n\n// eslint-disable-next-line complexity -- Temporary\nexport default iterateJsdoc(({\n  context,\n  jsdoc,\n  utils,\n}) => {\n  const {\n    linesBetween = 1,\n    tagSequence = defaultTagOrder,\n    alphabetizeExtras = false,\n    reportTagGroupSpacing = true,\n    reportIntraTagGroupSpacing = true,\n  } = context.options[0] || {};\n\n  const tagList = tagSequence.flatMap((obj) => {\n    /* typeof obj === 'string' ? obj : */\n    return obj.tags;\n  });\n\n  const otherPos = tagList.indexOf('-other');\n  const endPos = otherPos > -1 ? otherPos : tagList.length;\n\n  let ongoingCount = 0;\n  for (const [\n    idx,\n    tag,\n  ] of jsdoc.tags.entries()) {\n    tag.originalIndex = idx;\n    ongoingCount += tag.source.length;\n    tag.originalLine = ongoingCount;\n  }\n\n  let firstChangedTagLine;\n  let firstChangedTagIndex;\n  const sortedTags = JSON.parse(JSON.stringify(jsdoc.tags));\n  sortedTags.sort(({\n    tag: tagNew,\n  }, {\n    originalIndex,\n    originalLine,\n    tag: tagOld,\n  }) => {\n    // Optimize: Just keep relative positions if the same tag name\n    if (tagNew === tagOld) {\n      return 0;\n    }\n\n    const checkOrSetFirstChanged = () => {\n      if (!firstChangedTagLine || originalLine < firstChangedTagLine) {\n        firstChangedTagLine = originalLine;\n        firstChangedTagIndex = originalIndex;\n      }\n    };\n\n    const newPos = tagList.indexOf(tagNew);\n    const oldPos = tagList.indexOf(tagOld);\n\n    const preferredNewPos = newPos === -1 ? endPos : newPos;\n    const preferredOldPos = oldPos === -1 ? endPos : oldPos;\n\n    if (preferredNewPos < preferredOldPos) {\n      checkOrSetFirstChanged();\n      return -1;\n    }\n\n    if (preferredNewPos > preferredOldPos) {\n      return 1;\n    }\n\n    // preferredNewPos === preferredOldPos\n    if (\n      !alphabetizeExtras ||\n\n      // Optimize: If tagNew (or tagOld which is the same) was found in the\n      //   priority array, it can maintain its relative positionâ€”without need\n      //   of alphabetizing (secondary sorting)\n      newPos >= 0\n    ) {\n      return 0;\n    }\n\n    if (tagNew < tagOld) {\n      checkOrSetFirstChanged();\n      return -1;\n    }\n\n    // tagNew > tagOld\n    return 1;\n  });\n\n  if (firstChangedTagLine === undefined) {\n    // Should be ordered by now\n\n    const lastTagsOfGroup = [];\n    const badLastTagsOfGroup = [];\n\n    const countTagEmptyLines = (tag) => {\n      return tag.source.reduce((acc, {\n        tokens: {\n          description,\n          name,\n          type,\n          end,\n          tag: tg,\n        },\n      }) => {\n        const empty = !tg && !type && !name && !description;\n        // Reset the count so long as there is content\n        return empty ? acc + (empty && !end) : 0;\n      }, 0);\n    };\n\n    let idx = 0;\n    for (const {\n      tags,\n    } of tagSequence) {\n      let innerIdx;\n      let currentTag;\n      let lastTag;\n      do {\n        currentTag = jsdoc.tags[idx];\n        if (!currentTag) {\n          idx++;\n          break;\n        }\n\n        innerIdx = tags.indexOf(currentTag.tag);\n\n        if (\n          innerIdx === -1 &&\n          // eslint-disable-next-line no-loop-func -- Safe\n          (!tags.includes('-other') || tagSequence.some(({\n            tags: tgs,\n          }) => {\n            return tgs.includes(currentTag.tag);\n          }))\n        ) {\n          idx++;\n          break;\n        }\n\n        lastTag = currentTag;\n\n        idx++;\n      } while (true);\n\n      idx--;\n\n      if (lastTag) {\n        lastTagsOfGroup.push(lastTag);\n        const ct = countTagEmptyLines(lastTag);\n        if (\n          ct !== linesBetween &&\n          // Use another rule for adding to end (should be of interest outside this rule)\n          jsdoc.tags[idx]\n        ) {\n          badLastTagsOfGroup.push([\n            lastTag, ct,\n          ]);\n        }\n      }\n    }\n\n    if (reportTagGroupSpacing && badLastTagsOfGroup.length) {\n      const fixer = (tg) => {\n        return () => {\n          // Due to https://github.com/syavorsky/comment-parser/issues/110 ,\n          //  we have to modify `jsdoc.source` rather than just modify tags\n          //  directly\n          for (const [\n            currIdx,\n            {\n              tokens,\n            },\n          ] of jsdoc.source.entries()) {\n            if (tokens.tag !== '@' + tg.tag) {\n              continue;\n            }\n\n            // Cannot be `tokens.end`, as dropped off last tag, so safe to\n            //  go on\n            let newIdx = currIdx;\n\n            const emptyLine = () => {\n              return {\n                tokens: utils.seedTokens({\n                  delimiter: '*',\n                  start: jsdoc.source[newIdx - 1].tokens.start,\n                }),\n              };\n            };\n\n            let existingEmptyLines = 0;\n            while (true) {\n              const nextTokens = jsdoc.source[++newIdx]?.tokens;\n\n              /* istanbul ignore if -- Guard */\n              if (!nextTokens) {\n                return;\n              }\n\n              // Should be no `nextTokens.end` to worry about since ignored\n              //  if not followed by tag\n\n              if (nextTokens.tag) {\n                // Haven't made it to last tag instance yet, so keep looking\n                if (nextTokens.tag === tokens.tag) {\n                  existingEmptyLines = 0;\n                  continue;\n                }\n\n                const lineDiff = linesBetween - existingEmptyLines;\n                if (lineDiff > 0) {\n                  const lines = Array.from({\n                    length: lineDiff,\n                  }, () => {\n                    return emptyLine();\n                  });\n                  jsdoc.source.splice(newIdx, 0, ...lines);\n                } else {\n                  // lineDiff < 0\n                  jsdoc.source.splice(\n                    newIdx + lineDiff,\n                    -lineDiff,\n                  );\n                }\n\n                break;\n              }\n\n              const empty = !nextTokens.type && !nextTokens.name &&\n                !nextTokens.description;\n\n              if (empty) {\n                existingEmptyLines++;\n              } else {\n                // Has content again, so reset empty line count\n                existingEmptyLines = 0;\n              }\n            }\n\n            break;\n          }\n\n          for (const [\n            srcIdx,\n            src,\n          ] of jsdoc.source.entries()) {\n            src.number = srcIdx;\n          }\n        };\n      };\n\n      for (const [\n        tg,\n        ct,\n      ] of badLastTagsOfGroup) {\n        utils.reportJSDoc(\n          'Tag groups do not have the expected whitespace',\n          tg,\n          fixer(tg, ct),\n        );\n      }\n\n      return;\n    }\n\n    if (!reportIntraTagGroupSpacing) {\n      return;\n    }\n\n    for (const [\n      tagIdx,\n      tag,\n    ] of jsdoc.tags.entries()) {\n      if (!jsdoc.tags[tagIdx + 1] || lastTagsOfGroup.includes(tag)) {\n        continue;\n      }\n\n      const ct = countTagEmptyLines(tag);\n      if (ct) {\n        // eslint-disable-next-line complexity -- Temporary\n        const fixer = () => {\n          let foundFirstTag = false;\n          let currentTag;\n          for (const [\n            currIdx,\n            {\n              tokens: {\n                description,\n                name,\n                type,\n                end,\n                tag: tg,\n              },\n            },\n          ] of jsdoc.source.entries()) {\n            if (tg) {\n              foundFirstTag = true;\n              currentTag = tg;\n            }\n\n            if (!foundFirstTag) {\n              continue;\n            }\n\n            if (currentTag && !tg && !type && !name && !description && !end) {\n              let nextIdx = currIdx;\n\n              let ignore = true;\n              // Even if a tag of the same name as the last tags in a group,\n              //  could still be an earlier tag in that group\n\n              // eslint-disable-next-line no-loop-func -- Safe\n              if (lastTagsOfGroup.some((lastTagOfGroup) => {\n                return currentTag === '@' + lastTagOfGroup.tag;\n              })) {\n                while (true) {\n                  const nextTokens = jsdoc.source[++nextIdx]?.tokens;\n                  if (!nextTokens) {\n                    break;\n                  }\n\n                  if (!nextTokens.tag) {\n                    continue;\n                  }\n\n                  // Followed by the same tag name, so not actually last in group,\n                  //   and of interest\n                  if (nextTokens.tag === currentTag) {\n                    ignore = false;\n                  }\n                }\n              } else {\n                while (true) {\n                  const nextTokens = jsdoc.source[++nextIdx]?.tokens;\n                  if (!nextTokens || nextTokens.end) {\n                    break;\n                  }\n\n                  // Not the very last tag, so don't ignore\n                  if (nextTokens.tag) {\n                    ignore = false;\n                    break;\n                  }\n                }\n              }\n\n              if (!ignore) {\n                jsdoc.source.splice(currIdx, 1);\n                for (const [\n                  srcIdx,\n                  src,\n                ] of jsdoc.source.entries()) {\n                  src.number = srcIdx;\n                }\n              }\n            }\n          }\n        };\n\n        utils.reportJSDoc(\n          'Intra-group tags have unexpected whitespace',\n          tag,\n          fixer,\n        );\n      }\n    }\n\n    return;\n  }\n\n  const firstLine = utils.getFirstLine();\n\n  const fix = () => {\n    const itemsToMoveRange = [\n      ...Array.from({\n        length: jsdoc.tags.length - firstChangedTagIndex,\n      }).keys(),\n    ];\n\n    const unchangedPriorTagDescriptions = jsdoc.tags.slice(\n      0,\n      firstChangedTagIndex,\n    ).reduce((ct, {\n      source,\n    }) => {\n      return ct + source.length - 1;\n    }, 0);\n\n    // This offset includes not only the offset from where the first tag\n    //   must begin, and the additional offset of where the first changed\n    //   tag begins, but it must also account for prior descriptions\n    const initialOffset = firstLine + firstChangedTagIndex +\n\n      // May be the first tag, so don't try finding a prior one if so\n      unchangedPriorTagDescriptions;\n\n    // Use `firstChangedTagLine` for line number to begin reporting/splicing\n    for (const idx of itemsToMoveRange) {\n      utils.removeTag(idx + firstChangedTagIndex);\n    }\n\n    const changedTags = sortedTags.slice(firstChangedTagIndex);\n    let extraTagCount = 0;\n\n    for (const idx of itemsToMoveRange) {\n      const changedTag = changedTags[idx];\n\n      utils.addTag(\n        changedTag.tag,\n        extraTagCount + initialOffset + idx,\n        {\n          ...changedTag.source[0].tokens,\n\n          // `comment-parser` puts the `end` within the `tags` section, so\n          //   avoid adding another to jsdoc.source\n          end: '',\n        },\n      );\n\n      for (const {\n        tokens,\n      } of changedTag.source.slice(1)) {\n        if (!tokens.end) {\n          utils.addLine(\n            extraTagCount + initialOffset + idx + 1,\n            {\n              ...tokens,\n              end: '',\n            },\n          );\n          extraTagCount++;\n        }\n      }\n    }\n  };\n\n  utils.reportJSDoc(\n    `Tags are not in the prescribed order: ${\n      tagList.join(', ') || '(alphabetical)'\n    }`,\n    jsdoc.tags[firstChangedTagIndex],\n    fix,\n    true,\n  );\n}, {\n  iterateAllJsdocs: true,\n  meta: {\n    docs: {\n      description: 'Sorts tags by a specified sequence according to tag name.',\n      url: 'https://github.com/gajus/eslint-plugin-jsdoc#eslint-plugin-jsdoc-rules-sort-tags',\n    },\n    fixable: 'code',\n    schema: [\n      {\n        additionalProperties: false,\n        properties: {\n          alphabetizeExtras: {\n            type: 'boolean',\n          },\n          linesBetween: {\n            type: 'integer',\n          },\n          reportIntraTagGroupSpacing: {\n            type: 'boolean',\n          },\n          reportTagGroupSpacing: {\n            type: 'boolean',\n          },\n          tagSequence: {\n            items: {\n              properties: {\n                tags: {\n                  items: {\n                    type: 'string',\n                  },\n                  type: 'array',\n                },\n              },\n              type: 'object',\n            },\n            type: 'array',\n          },\n        },\n        type: 'object',\n      },\n    ],\n    type: 'suggestion',\n  },\n});\n"],"mappings":"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"}