var q = Object.defineProperty;
var Z = (e, n, a) => n in e ? q(e, n, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[n] = a;
var C = (e, n, a) => (Z(e, typeof n != "symbol" ? n + "" : n, a), a);
import { makeSignDoc } from "@cosmjs/amino";
import { fromBase64 } from "@cosmjs/encoding";
import { Int53 } from "@cosmjs/math";
import { encodePubkey, makeAuthInfoBytes } from "@cosmjs/proto-signing";
import { StargateClient } from "@cosmjs/stargate";
import { Signer } from "@ethersproject/abstract-signer";
var t = /* @__PURE__ */ ((e) => (e.INVALID_INPUT_PARAMETERS = "1000", e.UNKNOWN_PROVIDERS = "1001", e.CANNOT_FIND_INBOUND_ADDRESS = "1002", e.NO_INBOUND_ADDRESSES = "1003", e.CHAIN_HALTED_OR_UNSUPPORTED = "1004", e.MISSING_INPUT_PARAMETER = "1005", e.INVALID_TYPE_GENERIC = "1100", e.INVALID_NUMBER_STRING = "1101", e.INVALID_NUMBER = "1102", e.INVALID_BOOLEAN = "1103", e.INVALID_OBJECT = "1104", e.INVALID_ARRAY = "1105", e.SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2000", e.SELL_BUY_ASSETS_ARE_THE_SAME = "2001", e.MISSING_SOURCE_ADDRESS_FOR_SYNTH = "2002", e.AFF_ADDRESS_AND_BPS_OR_NEITHER = "2003", e.AFF_ADDRESS_TOO_LONG = "2004", e.AFF_BPS_INTEGER_0_100 = "2005", e.SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN = "2006", e.DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN = "2007", e.PREFERRED_PROFVIDER_NOT_SUPPORTED = "2008", e.DESTINATION_ADDRESS_SMART_CONTRACT = "2009", e.BUY_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2010", e.SOURCE_ADDRESS_SMART_CONTRACT = "2011", e.INVALID_PROVIDER = "2100", e.MISSING_CROSS_CHAIN_PROVIDER = "2101", e.MISSING_AVAX_PROVIDER = "2102", e.MISSING_BSC_PROVIDER = "2103", e.MISSING_ETH_PROVIDER = "2104", e.INVALID_PROVIDER_FOR_SWAP_OUT = "2105", e.MISSING_ARB_PROVIDER = "2106", e.INVALID_CHAIN = "2200", e.INVALID_ASSET = "2201", e.INVALID_ASSET_IDENTIFIER = "2202", e.UNSUPPORTED_CHAIN = "2204", e.UNSUPPORTED_ASSET = "2203", e.UNSUPPORTED_ASSET_FOR_SWAPOUT = "2205", e.THORNODE_QUOTE_GENERIC_ERROR = "3000", e.NOT_ENOUGH_SYNTH_BALANCE = "3001", e.SYNTH_MINTING_CAP_REACHED = "3002", e.INVALID_QUOTE_MODE = "4000", e.NO_QUOTES = "4001", e.SERVICE_UNAVAILABLE_GENERIC = "5000", e.MISSING_GAS_DATA_GENERIC = "5100", e.MISSING_TOKEN_INFO_GENERIC = "5200", e.CANT_FIND_TOKEN_LIST = "5201", e.NO_PRICE = "5202", e.PRICE_IS_STALE = "5203", e.ADDRESS_NOT_WHITELISTED = "6000", e.ADDRESS_ALREADY_CLAIMED = "6001", e.TEMPORARY_ERROR = "9999", e))(t || {});
t.INVALID_INPUT_PARAMETERS + "", t.UNKNOWN_PROVIDERS + "", t.CANNOT_FIND_INBOUND_ADDRESS + "", t.NO_INBOUND_ADDRESSES + "", t.CHAIN_HALTED_OR_UNSUPPORTED + "", t.MISSING_INPUT_PARAMETER + "", t.INVALID_TYPE_GENERIC + "", t.INVALID_NUMBER_STRING + "", t.INVALID_NUMBER + "", t.INVALID_BOOLEAN + "", t.INVALID_OBJECT + "", t.INVALID_ARRAY + "", t.SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER + "", t.SELL_BUY_ASSETS_ARE_THE_SAME + "", t.MISSING_SOURCE_ADDRESS_FOR_SYNTH + "", t.AFF_ADDRESS_AND_BPS_OR_NEITHER + "", t.AFF_ADDRESS_TOO_LONG + "", t.AFF_BPS_INTEGER_0_100 + "", t.SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN + "", t.DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN + "", t.PREFERRED_PROFVIDER_NOT_SUPPORTED + "", t.DESTINATION_ADDRESS_SMART_CONTRACT + "", t.BUY_AMOUNT_MUST_BE_POSITIVE_INTEGER + "", t.INVALID_PROVIDER + "", t.MISSING_CROSS_CHAIN_PROVIDER + "", t.MISSING_AVAX_PROVIDER + "", t.MISSING_BSC_PROVIDER + "", t.MISSING_ETH_PROVIDER + "", t.MISSING_ARB_PROVIDER + "", t.INVALID_PROVIDER_FOR_SWAP_OUT + "", t.INVALID_CHAIN + "", t.INVALID_ASSET + "", t.UNSUPPORTED_CHAIN + "", t.UNSUPPORTED_ASSET + "", t.UNSUPPORTED_ASSET_FOR_SWAPOUT + "", t.THORNODE_QUOTE_GENERIC_ERROR + "", t.NOT_ENOUGH_SYNTH_BALANCE + "", t.SYNTH_MINTING_CAP_REACHED + "", t.INVALID_QUOTE_MODE + "", t.NO_QUOTES + "", t.SERVICE_UNAVAILABLE_GENERIC + "", t.MISSING_GAS_DATA_GENERIC + "", t.MISSING_TOKEN_INFO_GENERIC + "", t.CANT_FIND_TOKEN_LIST + "", t.NO_PRICE + "", t.PRICE_IS_STALE + "", t.ADDRESS_NOT_WHITELISTED + "", t.ADDRESS_ALREADY_CLAIMED + "";
var i = /* @__PURE__ */ ((e) => (e.Arbitrum = "ARB", e.Avalanche = "AVAX", e.Binance = "BNB", e.BinanceSmartChain = "BSC", e.Bitcoin = "BTC", e.BitcoinCash = "BCH", e.Cosmos = "GAIA", e.Dogecoin = "DOGE", e.Ethereum = "ETH", e.Litecoin = "LTC", e.Optimism = "OP", e.Polygon = "MATIC", e.THORChain = "THOR", e))(i || {}), T = /* @__PURE__ */ ((e) => (e.Arbitrum = "42161", e.ArbitrumHex = "0xa4b1", e.Avalanche = "43114", e.AvalancheHex = "0xa86a", e.Binance = "Binance-Chain-Tigris", e.BinanceHex = "", e.BinanceSmartChain = "56", e.BinanceSmartChainHex = "0x38", e.Bitcoin = "bitcoin", e.BitcoinHex = "", e.BitcoinCash = "bitcoincash", e.BitcoinCashHex = "", e.Cosmos = "cosmoshub-4", e.CosmosHex = "", e.Dogecoin = "dogecoin", e.DogecoinHex = "", e.Ethereum = "1", e.EthereumHex = "0x1", e.Litecoin = "litecoin", e.LitecoinHex = "", e.Optimism = "10", e.OptimismHex = "0xa", e.Polygon = "137", e.PolygonHex = "0x89", e.THORChain = "thorchain-mainnet-v1", e.THORChainHex = "", e.THORChainStagenet = "thorchain-stagenet-v2", e))(T || {}), _ = /* @__PURE__ */ ((e) => (e.Arbitrum = "https://arb1.arbitrum.io/rpc", e.Avalanche = "https://node-router.thorswap.net/avalanche-c", e.Binance = "", e.BinanceSmartChain = "https://bsc-dataseed.binance.org", e.Bitcoin = "https://node-router.thorswap.net/bitcoin", e.BitcoinCash = "https://node-router.thorswap.net/bitcoin-cash", e.Cosmos = "https://node-router.thorswap.net/cosmos/rpc", e.Dogecoin = "https://node-router.thorswap.net/dogecoin", e.Ethereum = "https://node-router.thorswap.net/ethereum", e.Litecoin = "https://node-router.thorswap.net/litecoin", e.Optimism = "https://mainnet.optimism.io", e.Polygon = "https://polygon-rpc.com", e.THORChain = "https://rpc.thorswap.net", e.THORChainStagenet = "https://stagenet-rpc.ninerealms.com", e))(_ || {});
const p = Object.values(i), v = Object.keys(i), o = p.reduce(
  (e, n) => {
    const a = v.find((c) => i[c] === n);
    return a && (e[n] = a), e;
  },
  {}
);
p.reduce(
  (e, n) => (e[n] = T[o[n]], e),
  {}
);
p.reduce(
  (e, n) => (e[n] = _[o[n]], e),
  {}
);
p.reduce(
  (e, n) => (e[n] = T[`${o[n]}Hex`], e),
  {}
);
var U = /* @__PURE__ */ ((e) => (e.KEYSTORE = "KEYSTORE", e.XDEFI = "XDEFI", e.METAMASK = "METAMASK", e.COINBASE_WEB = "COINBASE_WEB", e.TREZOR = "TREZOR", e.KEEPKEY = "KEEPKEY", e.TRUSTWALLET_WEB = "TRUSTWALLET_WEB", e.LEDGER = "LEDGER", e.KEPLR = "KEPLR", e.OKX = "OKX", e.BRAVE = "BRAVE", e.WALLETCONNECT = "WALLETCONNECT", e))(U || {});
const DEFAULT_RELAY_URL = "wss://relay.walletconnect.com", ETHEREUM_MAINNET_ID = "eip155:1", BSC_MAINNET_ID = "eip155:56", AVALACHE_MAINNET_ID = "eip155:43114", THORCHAIN_MAINNET_ID = "cosmos:thorchain", BINANCE_MAINNET_ID = "cosmos:Binance-Chain-Tigris", DEFAULT_LOGGER = "debug", DEFAULT_APP_METADATA = {
  name: "THORSwap",
  description: "THORSwap multi-chain dex aggregator powered by THORChain",
  url: "https://app.thorswap.finance/",
  icons: ["https://static.thorswap.finance/logo.png"]
};
var DEFAULT_EIP155_METHODS = /* @__PURE__ */ ((e) => (e.ETH_SEND_TRANSACTION = "eth_sendTransaction", e.ETH_SIGN = "eth_sign", e.PERSONAL_SIGN = "personal_sign", e.ETH_SIGN_TYPED_DATA = "eth_signTypedData", e))(DEFAULT_EIP155_METHODS || {}), DEFAULT_EIP_155_EVENTS = /* @__PURE__ */ ((e) => (e.ETH_CHAIN_CHANGED = "chainChanged", e.ETH_ACCOUNTS_CHANGED = "accountsChanged", e))(DEFAULT_EIP_155_EVENTS || {}), DEFAULT_COSMOS_METHODS = /* @__PURE__ */ ((e) => (e.COSMOS_SIGN_DIRECT = "cosmos_signDirect", e.COSMOS_SIGN_AMINO = "cosmos_signAmino", e.COSMOS_GET_ACCOUNTS = "cosmos_getAccounts", e))(DEFAULT_COSMOS_METHODS || {}), DEFAULT_COSMOS_EVENTS = /* @__PURE__ */ ((e) => {
})(), DEFAULT_SOLANA_METHODS = /* @__PURE__ */ ((e) => (e.SOL_SIGN_TRANSACTION = "solana_signTransaction", e.SOL_SIGN_MESSAGE = "solana_signMessage", e))(DEFAULT_SOLANA_METHODS || {}), DEFAULT_SOLANA_EVENTS = /* @__PURE__ */ ((e) => {
})(), DEFAULT_POLKADOT_METHODS = /* @__PURE__ */ ((e) => (e.POLKADOT_SIGN_TRANSACTION = "polkadot_signTransaction", e.POLKADOT_SIGN_MESSAGE = "polkadot_signMessage", e))(DEFAULT_POLKADOT_METHODS || {}), DEFAULT_POLKADOT_EVENTS = /* @__PURE__ */ ((e) => {
})(), DEFAULT_NEAR_METHODS = /* @__PURE__ */ ((e) => (e.NEAR_SIGN_IN = "near_signIn", e.NEAR_SIGN_OUT = "near_signOut", e.NEAR_GET_ACCOUNTS = "near_getAccounts", e.NEAR_SIGN_AND_SEND_TRANSACTION = "near_signAndSendTransaction", e.NEAR_SIGN_AND_SEND_TRANSACTIONS = "near_signAndSendTransactions", e))(DEFAULT_NEAR_METHODS || {}), DEFAULT_NEAR_EVENTS = /* @__PURE__ */ ((e) => {
})();
const WC_SUPPORTED_CHAINS = [
  i.Binance,
  i.BinanceSmartChain,
  i.Ethereum,
  i.THORChain,
  i.Avalanche
];
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function getAugmentedNamespace(e) {
  if (e.__esModule)
    return e;
  var n = e.default;
  if (typeof n == "function") {
    var a = function c() {
      return this instanceof c ? Reflect.construct(n, arguments, this.constructor) : n.apply(this, arguments);
    };
    a.prototype = n.prototype;
  } else
    a = {};
  return Object.defineProperty(a, "__esModule", { value: !0 }), Object.keys(e).forEach(function(c) {
    var u = Object.getOwnPropertyDescriptor(e, c);
    Object.defineProperty(a, c, u.get ? u : {
      enumerable: !0,
      get: function() {
        return e[c];
      }
    });
  }), a;
}
var signing = {}, multisig = {}, indexMinimal = {}, minimal$1 = {}, aspromise = asPromise;
function asPromise(e, n) {
  for (var a = new Array(arguments.length - 1), c = 0, u = 2, h = !0; u < arguments.length; )
    a[c++] = arguments[u++];
  return new Promise(function(y, f) {
    a[c] = function(E) {
      if (h)
        if (h = !1, E)
          f(E);
        else {
          for (var I = new Array(arguments.length - 1), A = 0; A < I.length; )
            I[A++] = arguments[A];
          y.apply(null, I);
        }
    };
    try {
      e.apply(n || null, a);
    } catch (l) {
      h && (h = !1, f(l));
    }
  });
}
var base64$1 = {};
(function(e) {
  var n = e;
  n.length = function(y) {
    var f = y.length;
    if (!f)
      return 0;
    for (var l = 0; --f % 4 > 1 && y.charAt(f) === "="; )
      ++l;
    return Math.ceil(y.length * 3) / 4 - l;
  };
  for (var a = new Array(64), c = new Array(123), u = 0; u < 64; )
    c[a[u] = u < 26 ? u + 65 : u < 52 ? u + 71 : u < 62 ? u - 4 : u - 59 | 43] = u++;
  n.encode = function(y, f, l) {
    for (var E = null, I = [], A = 0, D = 0, R; f < l; ) {
      var M = y[f++];
      switch (D) {
        case 0:
          I[A++] = a[M >> 2], R = (M & 3) << 4, D = 1;
          break;
        case 1:
          I[A++] = a[R | M >> 4], R = (M & 15) << 2, D = 2;
          break;
        case 2:
          I[A++] = a[R | M >> 6], I[A++] = a[M & 63], D = 0;
          break;
      }
      A > 8191 && ((E || (E = [])).push(String.fromCharCode.apply(String, I)), A = 0);
    }
    return D && (I[A++] = a[R], I[A++] = 61, D === 1 && (I[A++] = 61)), E ? (A && E.push(String.fromCharCode.apply(String, I.slice(0, A))), E.join("")) : String.fromCharCode.apply(String, I.slice(0, A));
  };
  var h = "invalid encoding";
  n.decode = function(y, f, l) {
    for (var E = l, I = 0, A, D = 0; D < y.length; ) {
      var R = y.charCodeAt(D++);
      if (R === 61 && I > 1)
        break;
      if ((R = c[R]) === void 0)
        throw Error(h);
      switch (I) {
        case 0:
          A = R, I = 1;
          break;
        case 1:
          f[l++] = A << 2 | (R & 48) >> 4, A = R, I = 2;
          break;
        case 2:
          f[l++] = (A & 15) << 4 | (R & 60) >> 2, A = R, I = 3;
          break;
        case 3:
          f[l++] = (A & 3) << 6 | R, I = 0;
          break;
      }
    }
    if (I === 1)
      throw Error(h);
    return l - E;
  }, n.test = function(y) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(y);
  };
})(base64$1);
var eventemitter = EventEmitter;
function EventEmitter() {
  this._listeners = {};
}
EventEmitter.prototype.on = function(n, a, c) {
  return (this._listeners[n] || (this._listeners[n] = [])).push({
    fn: a,
    ctx: c || this
  }), this;
};
EventEmitter.prototype.off = function(n, a) {
  if (n === void 0)
    this._listeners = {};
  else if (a === void 0)
    this._listeners[n] = [];
  else
    for (var c = this._listeners[n], u = 0; u < c.length; )
      c[u].fn === a ? c.splice(u, 1) : ++u;
  return this;
};
EventEmitter.prototype.emit = function(n) {
  var a = this._listeners[n];
  if (a) {
    for (var c = [], u = 1; u < arguments.length; )
      c.push(arguments[u++]);
    for (u = 0; u < a.length; )
      a[u].fn.apply(a[u++].ctx, c);
  }
  return this;
};
var float = factory(factory);
function factory(e) {
  return typeof Float32Array < "u" ? function() {
    var n = new Float32Array([-0]), a = new Uint8Array(n.buffer), c = a[3] === 128;
    function u(f, l, E) {
      n[0] = f, l[E] = a[0], l[E + 1] = a[1], l[E + 2] = a[2], l[E + 3] = a[3];
    }
    function h(f, l, E) {
      n[0] = f, l[E] = a[3], l[E + 1] = a[2], l[E + 2] = a[1], l[E + 3] = a[0];
    }
    e.writeFloatLE = c ? u : h, e.writeFloatBE = c ? h : u;
    function m(f, l) {
      return a[0] = f[l], a[1] = f[l + 1], a[2] = f[l + 2], a[3] = f[l + 3], n[0];
    }
    function y(f, l) {
      return a[3] = f[l], a[2] = f[l + 1], a[1] = f[l + 2], a[0] = f[l + 3], n[0];
    }
    e.readFloatLE = c ? m : y, e.readFloatBE = c ? y : m;
  }() : function() {
    function n(c, u, h, m) {
      var y = u < 0 ? 1 : 0;
      if (y && (u = -u), u === 0)
        c(1 / u > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), h, m);
      else if (isNaN(u))
        c(2143289344, h, m);
      else if (u > 34028234663852886e22)
        c((y << 31 | 2139095040) >>> 0, h, m);
      else if (u < 11754943508222875e-54)
        c((y << 31 | Math.round(u / 1401298464324817e-60)) >>> 0, h, m);
      else {
        var f = Math.floor(Math.log(u) / Math.LN2), l = Math.round(u * Math.pow(2, -f) * 8388608) & 8388607;
        c((y << 31 | f + 127 << 23 | l) >>> 0, h, m);
      }
    }
    e.writeFloatLE = n.bind(null, writeUintLE), e.writeFloatBE = n.bind(null, writeUintBE);
    function a(c, u, h) {
      var m = c(u, h), y = (m >> 31) * 2 + 1, f = m >>> 23 & 255, l = m & 8388607;
      return f === 255 ? l ? NaN : y * (1 / 0) : f === 0 ? y * 1401298464324817e-60 * l : y * Math.pow(2, f - 150) * (l + 8388608);
    }
    e.readFloatLE = a.bind(null, readUintLE), e.readFloatBE = a.bind(null, readUintBE);
  }(), typeof Float64Array < "u" ? function() {
    var n = new Float64Array([-0]), a = new Uint8Array(n.buffer), c = a[7] === 128;
    function u(f, l, E) {
      n[0] = f, l[E] = a[0], l[E + 1] = a[1], l[E + 2] = a[2], l[E + 3] = a[3], l[E + 4] = a[4], l[E + 5] = a[5], l[E + 6] = a[6], l[E + 7] = a[7];
    }
    function h(f, l, E) {
      n[0] = f, l[E] = a[7], l[E + 1] = a[6], l[E + 2] = a[5], l[E + 3] = a[4], l[E + 4] = a[3], l[E + 5] = a[2], l[E + 6] = a[1], l[E + 7] = a[0];
    }
    e.writeDoubleLE = c ? u : h, e.writeDoubleBE = c ? h : u;
    function m(f, l) {
      return a[0] = f[l], a[1] = f[l + 1], a[2] = f[l + 2], a[3] = f[l + 3], a[4] = f[l + 4], a[5] = f[l + 5], a[6] = f[l + 6], a[7] = f[l + 7], n[0];
    }
    function y(f, l) {
      return a[7] = f[l], a[6] = f[l + 1], a[5] = f[l + 2], a[4] = f[l + 3], a[3] = f[l + 4], a[2] = f[l + 5], a[1] = f[l + 6], a[0] = f[l + 7], n[0];
    }
    e.readDoubleLE = c ? m : y, e.readDoubleBE = c ? y : m;
  }() : function() {
    function n(c, u, h, m, y, f) {
      var l = m < 0 ? 1 : 0;
      if (l && (m = -m), m === 0)
        c(0, y, f + u), c(1 / m > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), y, f + h);
      else if (isNaN(m))
        c(0, y, f + u), c(2146959360, y, f + h);
      else if (m > 17976931348623157e292)
        c(0, y, f + u), c((l << 31 | 2146435072) >>> 0, y, f + h);
      else {
        var E;
        if (m < 22250738585072014e-324)
          E = m / 5e-324, c(E >>> 0, y, f + u), c((l << 31 | E / 4294967296) >>> 0, y, f + h);
        else {
          var I = Math.floor(Math.log(m) / Math.LN2);
          I === 1024 && (I = 1023), E = m * Math.pow(2, -I), c(E * 4503599627370496 >>> 0, y, f + u), c((l << 31 | I + 1023 << 20 | E * 1048576 & 1048575) >>> 0, y, f + h);
        }
      }
    }
    e.writeDoubleLE = n.bind(null, writeUintLE, 0, 4), e.writeDoubleBE = n.bind(null, writeUintBE, 4, 0);
    function a(c, u, h, m, y) {
      var f = c(m, y + u), l = c(m, y + h), E = (l >> 31) * 2 + 1, I = l >>> 20 & 2047, A = 4294967296 * (l & 1048575) + f;
      return I === 2047 ? A ? NaN : E * (1 / 0) : I === 0 ? E * 5e-324 * A : E * Math.pow(2, I - 1075) * (A + 4503599627370496);
    }
    e.readDoubleLE = a.bind(null, readUintLE, 0, 4), e.readDoubleBE = a.bind(null, readUintBE, 4, 0);
  }(), e;
}
function writeUintLE(e, n, a) {
  n[a] = e & 255, n[a + 1] = e >>> 8 & 255, n[a + 2] = e >>> 16 & 255, n[a + 3] = e >>> 24;
}
function writeUintBE(e, n, a) {
  n[a] = e >>> 24, n[a + 1] = e >>> 16 & 255, n[a + 2] = e >>> 8 & 255, n[a + 3] = e & 255;
}
function readUintLE(e, n) {
  return (e[n] | e[n + 1] << 8 | e[n + 2] << 16 | e[n + 3] << 24) >>> 0;
}
function readUintBE(e, n) {
  return (e[n] << 24 | e[n + 1] << 16 | e[n + 2] << 8 | e[n + 3]) >>> 0;
}
var inquire_1 = inquire;
function inquire(moduleName) {
  try {
    var mod = eval("quire".replace(/^/, "re"))(moduleName);
    if (mod && (mod.length || Object.keys(mod).length))
      return mod;
  } catch (e) {
  }
  return null;
}
var utf8$2 = {};
(function(e) {
  var n = e;
  n.length = function(c) {
    for (var u = 0, h = 0, m = 0; m < c.length; ++m)
      h = c.charCodeAt(m), h < 128 ? u += 1 : h < 2048 ? u += 2 : (h & 64512) === 55296 && (c.charCodeAt(m + 1) & 64512) === 56320 ? (++m, u += 4) : u += 3;
    return u;
  }, n.read = function(c, u, h) {
    var m = h - u;
    if (m < 1)
      return "";
    for (var y = null, f = [], l = 0, E; u < h; )
      E = c[u++], E < 128 ? f[l++] = E : E > 191 && E < 224 ? f[l++] = (E & 31) << 6 | c[u++] & 63 : E > 239 && E < 365 ? (E = ((E & 7) << 18 | (c[u++] & 63) << 12 | (c[u++] & 63) << 6 | c[u++] & 63) - 65536, f[l++] = 55296 + (E >> 10), f[l++] = 56320 + (E & 1023)) : f[l++] = (E & 15) << 12 | (c[u++] & 63) << 6 | c[u++] & 63, l > 8191 && ((y || (y = [])).push(String.fromCharCode.apply(String, f)), l = 0);
    return y ? (l && y.push(String.fromCharCode.apply(String, f.slice(0, l))), y.join("")) : String.fromCharCode.apply(String, f.slice(0, l));
  }, n.write = function(c, u, h) {
    for (var m = h, y, f, l = 0; l < c.length; ++l)
      y = c.charCodeAt(l), y < 128 ? u[h++] = y : y < 2048 ? (u[h++] = y >> 6 | 192, u[h++] = y & 63 | 128) : (y & 64512) === 55296 && ((f = c.charCodeAt(l + 1)) & 64512) === 56320 ? (y = 65536 + ((y & 1023) << 10) + (f & 1023), ++l, u[h++] = y >> 18 | 240, u[h++] = y >> 12 & 63 | 128, u[h++] = y >> 6 & 63 | 128, u[h++] = y & 63 | 128) : (u[h++] = y >> 12 | 224, u[h++] = y >> 6 & 63 | 128, u[h++] = y & 63 | 128);
    return h - m;
  };
})(utf8$2);
var pool_1 = pool;
function pool(e, n, a) {
  var c = a || 8192, u = c >>> 1, h = null, m = c;
  return function(f) {
    if (f < 1 || f > u)
      return e(f);
    m + f > c && (h = e(c), m = 0);
    var l = n.call(h, m, m += f);
    return m & 7 && (m = (m | 7) + 1), l;
  };
}
var longbits, hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits)
    return longbits;
  hasRequiredLongbits = 1, longbits = n;
  var e = requireMinimal();
  function n(h, m) {
    this.lo = h >>> 0, this.hi = m >>> 0;
  }
  var a = n.zero = new n(0, 0);
  a.toNumber = function() {
    return 0;
  }, a.zzEncode = a.zzDecode = function() {
    return this;
  }, a.length = function() {
    return 1;
  };
  var c = n.zeroHash = "\0\0\0\0\0\0\0\0";
  n.fromNumber = function(m) {
    if (m === 0)
      return a;
    var y = m < 0;
    y && (m = -m);
    var f = m >>> 0, l = (m - f) / 4294967296 >>> 0;
    return y && (l = ~l >>> 0, f = ~f >>> 0, ++f > 4294967295 && (f = 0, ++l > 4294967295 && (l = 0))), new n(f, l);
  }, n.from = function(m) {
    if (typeof m == "number")
      return n.fromNumber(m);
    if (e.isString(m))
      if (e.Long)
        m = e.Long.fromString(m);
      else
        return n.fromNumber(parseInt(m, 10));
    return m.low || m.high ? new n(m.low >>> 0, m.high >>> 0) : a;
  }, n.prototype.toNumber = function(m) {
    if (!m && this.hi >>> 31) {
      var y = ~this.lo + 1 >>> 0, f = ~this.hi >>> 0;
      return y || (f = f + 1 >>> 0), -(y + f * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  }, n.prototype.toLong = function(m) {
    return e.Long ? new e.Long(this.lo | 0, this.hi | 0, !!m) : { low: this.lo | 0, high: this.hi | 0, unsigned: !!m };
  };
  var u = String.prototype.charCodeAt;
  return n.fromHash = function(m) {
    return m === c ? a : new n(
      (u.call(m, 0) | u.call(m, 1) << 8 | u.call(m, 2) << 16 | u.call(m, 3) << 24) >>> 0,
      (u.call(m, 4) | u.call(m, 5) << 8 | u.call(m, 6) << 16 | u.call(m, 7) << 24) >>> 0
    );
  }, n.prototype.toHash = function() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  }, n.prototype.zzEncode = function() {
    var m = this.hi >> 31;
    return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ m) >>> 0, this.lo = (this.lo << 1 ^ m) >>> 0, this;
  }, n.prototype.zzDecode = function() {
    var m = -(this.lo & 1);
    return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ m) >>> 0, this.hi = (this.hi >>> 1 ^ m) >>> 0, this;
  }, n.prototype.length = function() {
    var m = this.lo, y = (this.lo >>> 28 | this.hi << 4) >>> 0, f = this.hi >>> 24;
    return f === 0 ? y === 0 ? m < 16384 ? m < 128 ? 1 : 2 : m < 2097152 ? 3 : 4 : y < 16384 ? y < 128 ? 5 : 6 : y < 2097152 ? 7 : 8 : f < 128 ? 9 : 10;
  }, longbits;
}
var hasRequiredMinimal;
function requireMinimal() {
  return hasRequiredMinimal || (hasRequiredMinimal = 1, function(e) {
    var n = e;
    n.asPromise = aspromise, n.base64 = base64$1, n.EventEmitter = eventemitter, n.float = float, n.inquire = inquire_1, n.utf8 = utf8$2, n.pool = pool_1, n.LongBits = requireLongbits(), n.isNode = !!(typeof commonjsGlobal < "u" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node), n.global = n.isNode && commonjsGlobal || typeof window < "u" && window || typeof self < "u" && self || commonjsGlobal, n.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    ), n.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    ), n.isInteger = Number.isInteger || /* istanbul ignore next */
    function(h) {
      return typeof h == "number" && isFinite(h) && Math.floor(h) === h;
    }, n.isString = function(h) {
      return typeof h == "string" || h instanceof String;
    }, n.isObject = function(h) {
      return h && typeof h == "object";
    }, n.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    n.isSet = function(h, m) {
      var y = h[m];
      return y != null && h.hasOwnProperty(m) ? typeof y != "object" || (Array.isArray(y) ? y.length : Object.keys(y).length) > 0 : !1;
    }, n.Buffer = function() {
      try {
        var u = n.inquire("buffer").Buffer;
        return u.prototype.utf8Write ? u : (
          /* istanbul ignore next */
          null
        );
      } catch {
        return null;
      }
    }(), n._Buffer_from = null, n._Buffer_allocUnsafe = null, n.newBuffer = function(h) {
      return typeof h == "number" ? n.Buffer ? n._Buffer_allocUnsafe(h) : new n.Array(h) : n.Buffer ? n._Buffer_from(h) : typeof Uint8Array > "u" ? h : new Uint8Array(h);
    }, n.Array = typeof Uint8Array < "u" ? Uint8Array : Array, n.Long = /* istanbul ignore next */
    n.global.dcodeIO && /* istanbul ignore next */
    n.global.dcodeIO.Long || /* istanbul ignore next */
    n.global.Long || n.inquire("long"), n.key2Re = /^true|false|0|1$/, n.key32Re = /^-?(?:0|[1-9][0-9]*)$/, n.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, n.longToHash = function(h) {
      return h ? n.LongBits.from(h).toHash() : n.LongBits.zeroHash;
    }, n.longFromHash = function(h, m) {
      var y = n.LongBits.fromHash(h);
      return n.Long ? n.Long.fromBits(y.lo, y.hi, m) : y.toNumber(!!m);
    };
    function a(u, h, m) {
      for (var y = Object.keys(h), f = 0; f < y.length; ++f)
        (u[y[f]] === void 0 || !m) && (u[y[f]] = h[y[f]]);
      return u;
    }
    n.merge = a, n.lcFirst = function(h) {
      return h.charAt(0).toLowerCase() + h.substring(1);
    };
    function c(u) {
      function h(m, y) {
        if (!(this instanceof h))
          return new h(m, y);
        Object.defineProperty(this, "message", { get: function() {
          return m;
        } }), Error.captureStackTrace ? Error.captureStackTrace(this, h) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), y && a(this, y);
      }
      return (h.prototype = Object.create(Error.prototype)).constructor = h, Object.defineProperty(h.prototype, "name", { get: function() {
        return u;
      } }), h.prototype.toString = function() {
        return this.name + ": " + this.message;
      }, h;
    }
    n.newError = c, n.ProtocolError = c("ProtocolError"), n.oneOfGetter = function(h) {
      for (var m = {}, y = 0; y < h.length; ++y)
        m[h[y]] = 1;
      return function() {
        for (var f = Object.keys(this), l = f.length - 1; l > -1; --l)
          if (m[f[l]] === 1 && this[f[l]] !== void 0 && this[f[l]] !== null)
            return f[l];
      };
    }, n.oneOfSetter = function(h) {
      return function(m) {
        for (var y = 0; y < h.length; ++y)
          h[y] !== m && delete this[h[y]];
      };
    }, n.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: !0
    }, n._configure = function() {
      var u = n.Buffer;
      if (!u) {
        n._Buffer_from = n._Buffer_allocUnsafe = null;
        return;
      }
      n._Buffer_from = u.from !== Uint8Array.from && u.from || /* istanbul ignore next */
      function(m, y) {
        return new u(m, y);
      }, n._Buffer_allocUnsafe = u.allocUnsafe || /* istanbul ignore next */
      function(m) {
        return new u(m);
      };
    };
  }(minimal$1)), minimal$1;
}
var writer = Writer$1, util$4 = requireMinimal(), BufferWriter$1, LongBits$1 = util$4.LongBits, base64 = util$4.base64, utf8$1 = util$4.utf8;
function Op(e, n, a) {
  this.fn = e, this.len = n, this.next = void 0, this.val = a;
}
function noop() {
}
function State(e) {
  this.head = e.head, this.tail = e.tail, this.len = e.len, this.next = e.states;
}
function Writer$1() {
  this.len = 0, this.head = new Op(noop, 0, 0), this.tail = this.head, this.states = null;
}
var create$1 = function e() {
  return util$4.Buffer ? function() {
    return (Writer$1.create = function() {
      return new BufferWriter$1();
    })();
  } : function() {
    return new Writer$1();
  };
};
Writer$1.create = create$1();
Writer$1.alloc = function e(n) {
  return new util$4.Array(n);
};
util$4.Array !== Array && (Writer$1.alloc = util$4.pool(Writer$1.alloc, util$4.Array.prototype.subarray));
Writer$1.prototype._push = function e(n, a, c) {
  return this.tail = this.tail.next = new Op(n, a, c), this.len += a, this;
};
function writeByte(e, n, a) {
  n[a] = e & 255;
}
function writeVarint32(e, n, a) {
  for (; e > 127; )
    n[a++] = e & 127 | 128, e >>>= 7;
  n[a] = e;
}
function VarintOp(e, n) {
  this.len = e, this.next = void 0, this.val = n;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
Writer$1.prototype.uint32 = function e(n) {
  return this.len += (this.tail = this.tail.next = new VarintOp(
    (n = n >>> 0) < 128 ? 1 : n < 16384 ? 2 : n < 2097152 ? 3 : n < 268435456 ? 4 : 5,
    n
  )).len, this;
};
Writer$1.prototype.int32 = function e(n) {
  return n < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(n)) : this.uint32(n);
};
Writer$1.prototype.sint32 = function e(n) {
  return this.uint32((n << 1 ^ n >> 31) >>> 0);
};
function writeVarint64(e, n, a) {
  for (; e.hi; )
    n[a++] = e.lo & 127 | 128, e.lo = (e.lo >>> 7 | e.hi << 25) >>> 0, e.hi >>>= 7;
  for (; e.lo > 127; )
    n[a++] = e.lo & 127 | 128, e.lo = e.lo >>> 7;
  n[a++] = e.lo;
}
Writer$1.prototype.uint64 = function e(n) {
  var a = LongBits$1.from(n);
  return this._push(writeVarint64, a.length(), a);
};
Writer$1.prototype.int64 = Writer$1.prototype.uint64;
Writer$1.prototype.sint64 = function e(n) {
  var a = LongBits$1.from(n).zzEncode();
  return this._push(writeVarint64, a.length(), a);
};
Writer$1.prototype.bool = function e(n) {
  return this._push(writeByte, 1, n ? 1 : 0);
};
function writeFixed32(e, n, a) {
  n[a] = e & 255, n[a + 1] = e >>> 8 & 255, n[a + 2] = e >>> 16 & 255, n[a + 3] = e >>> 24;
}
Writer$1.prototype.fixed32 = function e(n) {
  return this._push(writeFixed32, 4, n >>> 0);
};
Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32;
Writer$1.prototype.fixed64 = function e(n) {
  var a = LongBits$1.from(n);
  return this._push(writeFixed32, 4, a.lo)._push(writeFixed32, 4, a.hi);
};
Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64;
Writer$1.prototype.float = function e(n) {
  return this._push(util$4.float.writeFloatLE, 4, n);
};
Writer$1.prototype.double = function e(n) {
  return this._push(util$4.float.writeDoubleLE, 8, n);
};
var writeBytes = util$4.Array.prototype.set ? function e(n, a, c) {
  a.set(n, c);
} : function e(n, a, c) {
  for (var u = 0; u < n.length; ++u)
    a[c + u] = n[u];
};
Writer$1.prototype.bytes = function e(n) {
  var a = n.length >>> 0;
  if (!a)
    return this._push(writeByte, 1, 0);
  if (util$4.isString(n)) {
    var c = Writer$1.alloc(a = base64.length(n));
    base64.decode(n, c, 0), n = c;
  }
  return this.uint32(a)._push(writeBytes, a, n);
};
Writer$1.prototype.string = function e(n) {
  var a = utf8$1.length(n);
  return a ? this.uint32(a)._push(utf8$1.write, a, n) : this._push(writeByte, 1, 0);
};
Writer$1.prototype.fork = function e() {
  return this.states = new State(this), this.head = this.tail = new Op(noop, 0, 0), this.len = 0, this;
};
Writer$1.prototype.reset = function e() {
  return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Op(noop, 0, 0), this.len = 0), this;
};
Writer$1.prototype.ldelim = function e() {
  var n = this.head, a = this.tail, c = this.len;
  return this.reset().uint32(c), c && (this.tail.next = n.next, this.tail = a, this.len += c), this;
};
Writer$1.prototype.finish = function e() {
  for (var n = this.head.next, a = this.constructor.alloc(this.len), c = 0; n; )
    n.fn(n.val, a, c), c += n.len, n = n.next;
  return a;
};
Writer$1._configure = function(e) {
  BufferWriter$1 = e, Writer$1.create = create$1(), BufferWriter$1._configure();
};
var writer_buffer = BufferWriter, Writer = writer;
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util$3 = requireMinimal();
function BufferWriter() {
  Writer.call(this);
}
BufferWriter._configure = function() {
  BufferWriter.alloc = util$3._Buffer_allocUnsafe, BufferWriter.writeBytesBuffer = util$3.Buffer && util$3.Buffer.prototype instanceof Uint8Array && util$3.Buffer.prototype.set.name === "set" ? function(n, a, c) {
    a.set(n, c);
  } : function(n, a, c) {
    if (n.copy)
      n.copy(a, c, 0, n.length);
    else
      for (var u = 0; u < n.length; )
        a[c++] = n[u++];
  };
};
BufferWriter.prototype.bytes = function e(n) {
  util$3.isString(n) && (n = util$3._Buffer_from(n, "base64"));
  var a = n.length >>> 0;
  return this.uint32(a), a && this._push(BufferWriter.writeBytesBuffer, a, n), this;
};
function writeStringBuffer(e, n, a) {
  e.length < 40 ? util$3.utf8.write(e, n, a) : n.utf8Write ? n.utf8Write(e, a) : n.write(e, a);
}
BufferWriter.prototype.string = function e(n) {
  var a = util$3.Buffer.byteLength(n);
  return this.uint32(a), a && this._push(writeStringBuffer, a, n), this;
};
BufferWriter._configure();
var reader = Reader$1, util$2 = requireMinimal(), BufferReader$1, LongBits = util$2.LongBits, utf8 = util$2.utf8;
function indexOutOfRange(e, n) {
  return RangeError("index out of range: " + e.pos + " + " + (n || 1) + " > " + e.len);
}
function Reader$1(e) {
  this.buf = e, this.pos = 0, this.len = e.length;
}
var create_array = typeof Uint8Array < "u" ? function e(n) {
  if (n instanceof Uint8Array || Array.isArray(n))
    return new Reader$1(n);
  throw Error("illegal buffer");
} : function e(n) {
  if (Array.isArray(n))
    return new Reader$1(n);
  throw Error("illegal buffer");
}, create = function e() {
  return util$2.Buffer ? function(a) {
    return (Reader$1.create = function(u) {
      return util$2.Buffer.isBuffer(u) ? new BufferReader$1(u) : create_array(u);
    })(a);
  } : create_array;
};
Reader$1.create = create();
Reader$1.prototype._slice = util$2.Array.prototype.subarray || /* istanbul ignore next */
util$2.Array.prototype.slice;
Reader$1.prototype.uint32 = function e() {
  var n = 4294967295;
  return function() {
    if (n = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (n = (n | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (n = (n | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (n = (n | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (n = (n | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128))
      return n;
    if ((this.pos += 5) > this.len)
      throw this.pos = this.len, indexOutOfRange(this, 10);
    return n;
  };
}();
Reader$1.prototype.int32 = function e() {
  return this.uint32() | 0;
};
Reader$1.prototype.sint32 = function e() {
  var n = this.uint32();
  return n >>> 1 ^ -(n & 1) | 0;
};
function readLongVarint() {
  var e = new LongBits(0, 0), n = 0;
  if (this.len - this.pos > 4) {
    for (; n < 4; ++n)
      if (e.lo = (e.lo | (this.buf[this.pos] & 127) << n * 7) >>> 0, this.buf[this.pos++] < 128)
        return e;
    if (e.lo = (e.lo | (this.buf[this.pos] & 127) << 28) >>> 0, e.hi = (e.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128)
      return e;
    n = 0;
  } else {
    for (; n < 3; ++n) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (e.lo = (e.lo | (this.buf[this.pos] & 127) << n * 7) >>> 0, this.buf[this.pos++] < 128)
        return e;
    }
    return e.lo = (e.lo | (this.buf[this.pos++] & 127) << n * 7) >>> 0, e;
  }
  if (this.len - this.pos > 4) {
    for (; n < 5; ++n)
      if (e.hi = (e.hi | (this.buf[this.pos] & 127) << n * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return e;
  } else
    for (; n < 5; ++n) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (e.hi = (e.hi | (this.buf[this.pos] & 127) << n * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return e;
    }
  throw Error("invalid varint encoding");
}
Reader$1.prototype.bool = function e() {
  return this.uint32() !== 0;
};
function readFixed32_end(e, n) {
  return (e[n - 4] | e[n - 3] << 8 | e[n - 2] << 16 | e[n - 1] << 24) >>> 0;
}
Reader$1.prototype.fixed32 = function e() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4);
};
Reader$1.prototype.sfixed32 = function e() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4) | 0;
};
function readFixed64() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 8);
  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
Reader$1.prototype.float = function e() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  var n = util$2.float.readFloatLE(this.buf, this.pos);
  return this.pos += 4, n;
};
Reader$1.prototype.double = function e() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 4);
  var n = util$2.float.readDoubleLE(this.buf, this.pos);
  return this.pos += 8, n;
};
Reader$1.prototype.bytes = function e() {
  var n = this.uint32(), a = this.pos, c = this.pos + n;
  if (c > this.len)
    throw indexOutOfRange(this, n);
  return this.pos += n, Array.isArray(this.buf) ? this.buf.slice(a, c) : a === c ? new this.buf.constructor(0) : this._slice.call(this.buf, a, c);
};
Reader$1.prototype.string = function e() {
  var n = this.bytes();
  return utf8.read(n, 0, n.length);
};
Reader$1.prototype.skip = function e(n) {
  if (typeof n == "number") {
    if (this.pos + n > this.len)
      throw indexOutOfRange(this, n);
    this.pos += n;
  } else
    do
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
    while (this.buf[this.pos++] & 128);
  return this;
};
Reader$1.prototype.skipType = function(e) {
  switch (e) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      for (; (e = this.uint32() & 7) !== 4; )
        this.skipType(e);
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + e + " at offset " + this.pos);
  }
  return this;
};
Reader$1._configure = function(e) {
  BufferReader$1 = e, Reader$1.create = create(), BufferReader$1._configure();
  var n = util$2.Long ? "toLong" : (
    /* istanbul ignore next */
    "toNumber"
  );
  util$2.merge(Reader$1.prototype, {
    int64: function() {
      return readLongVarint.call(this)[n](!1);
    },
    uint64: function() {
      return readLongVarint.call(this)[n](!0);
    },
    sint64: function() {
      return readLongVarint.call(this).zzDecode()[n](!1);
    },
    fixed64: function() {
      return readFixed64.call(this)[n](!0);
    },
    sfixed64: function() {
      return readFixed64.call(this)[n](!1);
    }
  });
};
var reader_buffer = BufferReader, Reader = reader;
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util$1 = requireMinimal();
function BufferReader(e) {
  Reader.call(this, e);
}
BufferReader._configure = function() {
  util$1.Buffer && (BufferReader.prototype._slice = util$1.Buffer.prototype.slice);
};
BufferReader.prototype.string = function e() {
  var n = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + n, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + n, this.len));
};
BufferReader._configure();
var rpc = {}, service = Service, util = requireMinimal();
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
function Service(e, n, a) {
  if (typeof e != "function")
    throw TypeError("rpcImpl must be a function");
  util.EventEmitter.call(this), this.rpcImpl = e, this.requestDelimited = !!n, this.responseDelimited = !!a;
}
Service.prototype.rpcCall = function e(n, a, c, u, h) {
  if (!u)
    throw TypeError("request must be specified");
  var m = this;
  if (!h)
    return util.asPromise(e, m, n, a, c, u);
  if (!m.rpcImpl) {
    setTimeout(function() {
      h(Error("already ended"));
    }, 0);
    return;
  }
  try {
    return m.rpcImpl(
      n,
      a[m.requestDelimited ? "encodeDelimited" : "encode"](u).finish(),
      function(f, l) {
        if (f)
          return m.emit("error", f, n), h(f);
        if (l === null) {
          m.end(
            /* endedByRPC */
            !0
          );
          return;
        }
        if (!(l instanceof c))
          try {
            l = c[m.responseDelimited ? "decodeDelimited" : "decode"](l);
          } catch (E) {
            return m.emit("error", E, n), h(E);
          }
        return m.emit("data", l, n), h(null, l);
      }
    );
  } catch (y) {
    m.emit("error", y, n), setTimeout(function() {
      h(y);
    }, 0);
    return;
  }
};
Service.prototype.end = function e(n) {
  return this.rpcImpl && (n || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
};
(function(e) {
  var n = e;
  n.Service = service;
})(rpc);
var roots = {};
(function(e) {
  var n = e;
  n.build = "minimal", n.Writer = writer, n.BufferWriter = writer_buffer, n.Reader = reader, n.BufferReader = reader_buffer, n.util = requireMinimal(), n.rpc = rpc, n.roots = roots, n.configure = a;
  function a() {
    n.util._configure(), n.Writer._configure(n.BufferWriter), n.Reader._configure(n.BufferReader);
  }
  a();
})(indexMinimal);
var minimal = indexMinimal, helpers = {}, long = Long, wasm = null;
try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    13,
    2,
    96,
    0,
    1,
    127,
    96,
    4,
    127,
    127,
    127,
    127,
    1,
    127,
    3,
    7,
    6,
    0,
    1,
    1,
    1,
    1,
    1,
    6,
    6,
    1,
    127,
    1,
    65,
    0,
    11,
    7,
    50,
    6,
    3,
    109,
    117,
    108,
    0,
    1,
    5,
    100,
    105,
    118,
    95,
    115,
    0,
    2,
    5,
    100,
    105,
    118,
    95,
    117,
    0,
    3,
    5,
    114,
    101,
    109,
    95,
    115,
    0,
    4,
    5,
    114,
    101,
    109,
    95,
    117,
    0,
    5,
    8,
    103,
    101,
    116,
    95,
    104,
    105,
    103,
    104,
    0,
    0,
    10,
    191,
    1,
    6,
    4,
    0,
    35,
    0,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    126,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    127,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    128,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    129,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    130,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11
  ])), {}).exports;
} catch (e) {
}
function Long(e, n, a) {
  this.low = e | 0, this.high = n | 0, this.unsigned = !!a;
}
Long.prototype.__isLong__;
Object.defineProperty(Long.prototype, "__isLong__", { value: !0 });
function isLong(e) {
  return (e && e.__isLong__) === !0;
}
Long.isLong = isLong;
var INT_CACHE = {}, UINT_CACHE = {};
function fromInt(e, n) {
  var a, c, u;
  return n ? (e >>>= 0, (u = 0 <= e && e < 256) && (c = UINT_CACHE[e], c) ? c : (a = fromBits(e, (e | 0) < 0 ? -1 : 0, !0), u && (UINT_CACHE[e] = a), a)) : (e |= 0, (u = -128 <= e && e < 128) && (c = INT_CACHE[e], c) ? c : (a = fromBits(e, e < 0 ? -1 : 0, !1), u && (INT_CACHE[e] = a), a));
}
Long.fromInt = fromInt;
function fromNumber(e, n) {
  if (isNaN(e))
    return n ? UZERO : ZERO;
  if (n) {
    if (e < 0)
      return UZERO;
    if (e >= TWO_PWR_64_DBL)
      return MAX_UNSIGNED_VALUE;
  } else {
    if (e <= -TWO_PWR_63_DBL)
      return MIN_VALUE;
    if (e + 1 >= TWO_PWR_63_DBL)
      return MAX_VALUE;
  }
  return e < 0 ? fromNumber(-e, n).neg() : fromBits(e % TWO_PWR_32_DBL | 0, e / TWO_PWR_32_DBL | 0, n);
}
Long.fromNumber = fromNumber;
function fromBits(e, n, a) {
  return new Long(e, n, a);
}
Long.fromBits = fromBits;
var pow_dbl = Math.pow;
function fromString(e, n, a) {
  if (e.length === 0)
    throw Error("empty string");
  if (e === "NaN" || e === "Infinity" || e === "+Infinity" || e === "-Infinity")
    return ZERO;
  if (typeof n == "number" ? (a = n, n = !1) : n = !!n, a = a || 10, a < 2 || 36 < a)
    throw RangeError("radix");
  var c;
  if ((c = e.indexOf("-")) > 0)
    throw Error("interior hyphen");
  if (c === 0)
    return fromString(e.substring(1), n, a).neg();
  for (var u = fromNumber(pow_dbl(a, 8)), h = ZERO, m = 0; m < e.length; m += 8) {
    var y = Math.min(8, e.length - m), f = parseInt(e.substring(m, m + y), a);
    if (y < 8) {
      var l = fromNumber(pow_dbl(a, y));
      h = h.mul(l).add(fromNumber(f));
    } else
      h = h.mul(u), h = h.add(fromNumber(f));
  }
  return h.unsigned = n, h;
}
Long.fromString = fromString;
function fromValue(e, n) {
  return typeof e == "number" ? fromNumber(e, n) : typeof e == "string" ? fromString(e, n) : fromBits(e.low, e.high, typeof n == "boolean" ? n : e.unsigned);
}
Long.fromValue = fromValue;
var TWO_PWR_16_DBL = 65536, TWO_PWR_24_DBL = 1 << 24, TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL, TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL, TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2, TWO_PWR_24 = fromInt(TWO_PWR_24_DBL), ZERO = fromInt(0);
Long.ZERO = ZERO;
var UZERO = fromInt(0, !0);
Long.UZERO = UZERO;
var ONE = fromInt(1);
Long.ONE = ONE;
var UONE = fromInt(1, !0);
Long.UONE = UONE;
var NEG_ONE = fromInt(-1);
Long.NEG_ONE = NEG_ONE;
var MAX_VALUE = fromBits(-1, 2147483647, !1);
Long.MAX_VALUE = MAX_VALUE;
var MAX_UNSIGNED_VALUE = fromBits(-1, -1, !0);
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
var MIN_VALUE = fromBits(0, -2147483648, !1);
Long.MIN_VALUE = MIN_VALUE;
var LongPrototype = Long.prototype;
LongPrototype.toInt = function e() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
LongPrototype.toNumber = function e() {
  return this.unsigned ? (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0) : this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};
LongPrototype.toString = function e(n) {
  if (n = n || 10, n < 2 || 36 < n)
    throw RangeError("radix");
  if (this.isZero())
    return "0";
  if (this.isNegative())
    if (this.eq(MIN_VALUE)) {
      var a = fromNumber(n), c = this.div(a), u = c.mul(a).sub(this);
      return c.toString(n) + u.toInt().toString(n);
    } else
      return "-" + this.neg().toString(n);
  for (var h = fromNumber(pow_dbl(n, 6), this.unsigned), m = this, y = ""; ; ) {
    var f = m.div(h), l = m.sub(f.mul(h)).toInt() >>> 0, E = l.toString(n);
    if (m = f, m.isZero())
      return E + y;
    for (; E.length < 6; )
      E = "0" + E;
    y = "" + E + y;
  }
};
LongPrototype.getHighBits = function e() {
  return this.high;
};
LongPrototype.getHighBitsUnsigned = function e() {
  return this.high >>> 0;
};
LongPrototype.getLowBits = function e() {
  return this.low;
};
LongPrototype.getLowBitsUnsigned = function e() {
  return this.low >>> 0;
};
LongPrototype.getNumBitsAbs = function e() {
  if (this.isNegative())
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  for (var n = this.high != 0 ? this.high : this.low, a = 31; a > 0 && !(n & 1 << a); a--)
    ;
  return this.high != 0 ? a + 33 : a + 1;
};
LongPrototype.isZero = function e() {
  return this.high === 0 && this.low === 0;
};
LongPrototype.eqz = LongPrototype.isZero;
LongPrototype.isNegative = function e() {
  return !this.unsigned && this.high < 0;
};
LongPrototype.isPositive = function e() {
  return this.unsigned || this.high >= 0;
};
LongPrototype.isOdd = function e() {
  return (this.low & 1) === 1;
};
LongPrototype.isEven = function e() {
  return (this.low & 1) === 0;
};
LongPrototype.equals = function e(n) {
  return isLong(n) || (n = fromValue(n)), this.unsigned !== n.unsigned && this.high >>> 31 === 1 && n.high >>> 31 === 1 ? !1 : this.high === n.high && this.low === n.low;
};
LongPrototype.eq = LongPrototype.equals;
LongPrototype.notEquals = function e(n) {
  return !this.eq(
    /* validates */
    n
  );
};
LongPrototype.neq = LongPrototype.notEquals;
LongPrototype.ne = LongPrototype.notEquals;
LongPrototype.lessThan = function e(n) {
  return this.comp(
    /* validates */
    n
  ) < 0;
};
LongPrototype.lt = LongPrototype.lessThan;
LongPrototype.lessThanOrEqual = function e(n) {
  return this.comp(
    /* validates */
    n
  ) <= 0;
};
LongPrototype.lte = LongPrototype.lessThanOrEqual;
LongPrototype.le = LongPrototype.lessThanOrEqual;
LongPrototype.greaterThan = function e(n) {
  return this.comp(
    /* validates */
    n
  ) > 0;
};
LongPrototype.gt = LongPrototype.greaterThan;
LongPrototype.greaterThanOrEqual = function e(n) {
  return this.comp(
    /* validates */
    n
  ) >= 0;
};
LongPrototype.gte = LongPrototype.greaterThanOrEqual;
LongPrototype.ge = LongPrototype.greaterThanOrEqual;
LongPrototype.compare = function e(n) {
  if (isLong(n) || (n = fromValue(n)), this.eq(n))
    return 0;
  var a = this.isNegative(), c = n.isNegative();
  return a && !c ? -1 : !a && c ? 1 : this.unsigned ? n.high >>> 0 > this.high >>> 0 || n.high === this.high && n.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(n).isNegative() ? -1 : 1;
};
LongPrototype.comp = LongPrototype.compare;
LongPrototype.negate = function e() {
  return !this.unsigned && this.eq(MIN_VALUE) ? MIN_VALUE : this.not().add(ONE);
};
LongPrototype.neg = LongPrototype.negate;
LongPrototype.add = function e(n) {
  isLong(n) || (n = fromValue(n));
  var a = this.high >>> 16, c = this.high & 65535, u = this.low >>> 16, h = this.low & 65535, m = n.high >>> 16, y = n.high & 65535, f = n.low >>> 16, l = n.low & 65535, E = 0, I = 0, A = 0, D = 0;
  return D += h + l, A += D >>> 16, D &= 65535, A += u + f, I += A >>> 16, A &= 65535, I += c + y, E += I >>> 16, I &= 65535, E += a + m, E &= 65535, fromBits(A << 16 | D, E << 16 | I, this.unsigned);
};
LongPrototype.subtract = function e(n) {
  return isLong(n) || (n = fromValue(n)), this.add(n.neg());
};
LongPrototype.sub = LongPrototype.subtract;
LongPrototype.multiply = function e(n) {
  if (this.isZero())
    return ZERO;
  if (isLong(n) || (n = fromValue(n)), wasm) {
    var a = wasm.mul(
      this.low,
      this.high,
      n.low,
      n.high
    );
    return fromBits(a, wasm.get_high(), this.unsigned);
  }
  if (n.isZero())
    return ZERO;
  if (this.eq(MIN_VALUE))
    return n.isOdd() ? MIN_VALUE : ZERO;
  if (n.eq(MIN_VALUE))
    return this.isOdd() ? MIN_VALUE : ZERO;
  if (this.isNegative())
    return n.isNegative() ? this.neg().mul(n.neg()) : this.neg().mul(n).neg();
  if (n.isNegative())
    return this.mul(n.neg()).neg();
  if (this.lt(TWO_PWR_24) && n.lt(TWO_PWR_24))
    return fromNumber(this.toNumber() * n.toNumber(), this.unsigned);
  var c = this.high >>> 16, u = this.high & 65535, h = this.low >>> 16, m = this.low & 65535, y = n.high >>> 16, f = n.high & 65535, l = n.low >>> 16, E = n.low & 65535, I = 0, A = 0, D = 0, R = 0;
  return R += m * E, D += R >>> 16, R &= 65535, D += h * E, A += D >>> 16, D &= 65535, D += m * l, A += D >>> 16, D &= 65535, A += u * E, I += A >>> 16, A &= 65535, A += h * l, I += A >>> 16, A &= 65535, A += m * f, I += A >>> 16, A &= 65535, I += c * E + u * l + h * f + m * y, I &= 65535, fromBits(D << 16 | R, I << 16 | A, this.unsigned);
};
LongPrototype.mul = LongPrototype.multiply;
LongPrototype.divide = function e(n) {
  if (isLong(n) || (n = fromValue(n)), n.isZero())
    throw Error("division by zero");
  if (wasm) {
    if (!this.unsigned && this.high === -2147483648 && n.low === -1 && n.high === -1)
      return this;
    var a = (this.unsigned ? wasm.div_u : wasm.div_s)(
      this.low,
      this.high,
      n.low,
      n.high
    );
    return fromBits(a, wasm.get_high(), this.unsigned);
  }
  if (this.isZero())
    return this.unsigned ? UZERO : ZERO;
  var c, u, h;
  if (this.unsigned) {
    if (n.unsigned || (n = n.toUnsigned()), n.gt(this))
      return UZERO;
    if (n.gt(this.shru(1)))
      return UONE;
    h = UZERO;
  } else {
    if (this.eq(MIN_VALUE)) {
      if (n.eq(ONE) || n.eq(NEG_ONE))
        return MIN_VALUE;
      if (n.eq(MIN_VALUE))
        return ONE;
      var m = this.shr(1);
      return c = m.div(n).shl(1), c.eq(ZERO) ? n.isNegative() ? ONE : NEG_ONE : (u = this.sub(n.mul(c)), h = c.add(u.div(n)), h);
    } else if (n.eq(MIN_VALUE))
      return this.unsigned ? UZERO : ZERO;
    if (this.isNegative())
      return n.isNegative() ? this.neg().div(n.neg()) : this.neg().div(n).neg();
    if (n.isNegative())
      return this.div(n.neg()).neg();
    h = ZERO;
  }
  for (u = this; u.gte(n); ) {
    c = Math.max(1, Math.floor(u.toNumber() / n.toNumber()));
    for (var y = Math.ceil(Math.log(c) / Math.LN2), f = y <= 48 ? 1 : pow_dbl(2, y - 48), l = fromNumber(c), E = l.mul(n); E.isNegative() || E.gt(u); )
      c -= f, l = fromNumber(c, this.unsigned), E = l.mul(n);
    l.isZero() && (l = ONE), h = h.add(l), u = u.sub(E);
  }
  return h;
};
LongPrototype.div = LongPrototype.divide;
LongPrototype.modulo = function e(n) {
  if (isLong(n) || (n = fromValue(n)), wasm) {
    var a = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
      this.low,
      this.high,
      n.low,
      n.high
    );
    return fromBits(a, wasm.get_high(), this.unsigned);
  }
  return this.sub(this.div(n).mul(n));
};
LongPrototype.mod = LongPrototype.modulo;
LongPrototype.rem = LongPrototype.modulo;
LongPrototype.not = function e() {
  return fromBits(~this.low, ~this.high, this.unsigned);
};
LongPrototype.and = function e(n) {
  return isLong(n) || (n = fromValue(n)), fromBits(this.low & n.low, this.high & n.high, this.unsigned);
};
LongPrototype.or = function e(n) {
  return isLong(n) || (n = fromValue(n)), fromBits(this.low | n.low, this.high | n.high, this.unsigned);
};
LongPrototype.xor = function e(n) {
  return isLong(n) || (n = fromValue(n)), fromBits(this.low ^ n.low, this.high ^ n.high, this.unsigned);
};
LongPrototype.shiftLeft = function e(n) {
  return isLong(n) && (n = n.toInt()), (n &= 63) === 0 ? this : n < 32 ? fromBits(this.low << n, this.high << n | this.low >>> 32 - n, this.unsigned) : fromBits(0, this.low << n - 32, this.unsigned);
};
LongPrototype.shl = LongPrototype.shiftLeft;
LongPrototype.shiftRight = function e(n) {
  return isLong(n) && (n = n.toInt()), (n &= 63) === 0 ? this : n < 32 ? fromBits(this.low >>> n | this.high << 32 - n, this.high >> n, this.unsigned) : fromBits(this.high >> n - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
LongPrototype.shr = LongPrototype.shiftRight;
LongPrototype.shiftRightUnsigned = function e(n) {
  if (isLong(n) && (n = n.toInt()), n &= 63, n === 0)
    return this;
  var a = this.high;
  if (n < 32) {
    var c = this.low;
    return fromBits(c >>> n | a << 32 - n, a >>> n, this.unsigned);
  } else
    return n === 32 ? fromBits(a, 0, this.unsigned) : fromBits(a >>> n - 32, 0, this.unsigned);
};
LongPrototype.shru = LongPrototype.shiftRightUnsigned;
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
LongPrototype.toSigned = function e() {
  return this.unsigned ? fromBits(this.low, this.high, !1) : this;
};
LongPrototype.toUnsigned = function e() {
  return this.unsigned ? this : fromBits(this.low, this.high, !0);
};
LongPrototype.toBytes = function e(n) {
  return n ? this.toBytesLE() : this.toBytesBE();
};
LongPrototype.toBytesLE = function e() {
  var n = this.high, a = this.low;
  return [
    a & 255,
    a >>> 8 & 255,
    a >>> 16 & 255,
    a >>> 24,
    n & 255,
    n >>> 8 & 255,
    n >>> 16 & 255,
    n >>> 24
  ];
};
LongPrototype.toBytesBE = function e() {
  var n = this.high, a = this.low;
  return [
    n >>> 24,
    n >>> 16 & 255,
    n >>> 8 & 255,
    n & 255,
    a >>> 24,
    a >>> 16 & 255,
    a >>> 8 & 255,
    a & 255
  ];
};
Long.fromBytes = function e(n, a, c) {
  return c ? Long.fromBytesLE(n, a) : Long.fromBytesBE(n, a);
};
Long.fromBytesLE = function e(n, a) {
  return new Long(
    n[0] | n[1] << 8 | n[2] << 16 | n[3] << 24,
    n[4] | n[5] << 8 | n[6] << 16 | n[7] << 24,
    a
  );
};
Long.fromBytesBE = function e(n, a) {
  return new Long(
    n[4] << 24 | n[5] << 16 | n[6] << 8 | n[7],
    n[0] << 24 | n[1] << 16 | n[2] << 8 | n[3],
    a
  );
};
var __createBinding$3 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(e, n, a, c) {
  c === void 0 && (c = a);
  var u = Object.getOwnPropertyDescriptor(n, a);
  (!u || ("get" in u ? !n.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
    return n[a];
  } }), Object.defineProperty(e, c, u);
} : function(e, n, a, c) {
  c === void 0 && (c = a), e[c] = n[a];
}), __setModuleDefault$3 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), __importStar$3 = commonjsGlobal && commonjsGlobal.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var a in e)
      a !== "default" && Object.prototype.hasOwnProperty.call(e, a) && __createBinding$3(n, e, a);
  return __setModuleDefault$3(n, e), n;
}, __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(helpers, "__esModule", { value: !0 });
helpers.fromJsonTimestamp = helpers.fromTimestamp = helpers.toTimestamp = helpers.setPaginationParams = helpers.isObject = helpers.isSet = helpers.fromDuration = helpers.toDuration = helpers.omitDefault = helpers.base64FromBytes = helpers.bytesFromBase64 = helpers.Long = void 0;
const _m0$3 = __importStar$3(minimal), long_1 = __importDefault(long);
helpers.Long = long_1.default;
_m0$3.util.Long !== long_1.default && (_m0$3.util.Long = long_1.default, _m0$3.configure());
var globalThis$1 = (() => {
  if (typeof globalThis$1 < "u")
    return globalThis$1;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal < "u")
    return commonjsGlobal;
  throw "Unable to locate global object";
})();
const atob = globalThis$1.atob || ((e) => globalThis$1.Buffer.from(e, "base64").toString("binary"));
function bytesFromBase64(e) {
  const n = atob(e), a = new Uint8Array(n.length);
  for (let c = 0; c < n.length; ++c)
    a[c] = n.charCodeAt(c);
  return a;
}
helpers.bytesFromBase64 = bytesFromBase64;
const btoa = globalThis$1.btoa || ((e) => globalThis$1.Buffer.from(e, "binary").toString("base64"));
function base64FromBytes(e) {
  const n = [];
  return e.forEach((a) => {
    n.push(String.fromCharCode(a));
  }), btoa(n.join(""));
}
helpers.base64FromBytes = base64FromBytes;
function omitDefault(e) {
  if (typeof e == "string")
    return e === "" ? void 0 : e;
  if (typeof e == "number")
    return e === 0 ? void 0 : e;
  if (long_1.default.isLong(e))
    return e.isZero() ? void 0 : e;
  throw new Error(`Got unsupported type ${typeof e}`);
}
helpers.omitDefault = omitDefault;
function toDuration(e) {
  return {
    seconds: long_1.default.fromNumber(Math.floor(parseInt(e) / 1e9)),
    nanos: parseInt(e) % 1e9
  };
}
helpers.toDuration = toDuration;
function fromDuration(e) {
  return (parseInt(e.seconds.toString()) * 1e9 + e.nanos).toString();
}
helpers.fromDuration = fromDuration;
function isSet(e) {
  return e != null;
}
helpers.isSet = isSet;
function isObject(e) {
  return typeof e == "object" && e !== null;
}
helpers.isObject = isObject;
const setPaginationParams = (e, n) => (n && (typeof (n == null ? void 0 : n.countTotal) < "u" && (e.params["pagination.count_total"] = n.countTotal), typeof (n == null ? void 0 : n.key) < "u" && (e.params["pagination.key"] = Buffer.from(n.key).toString("base64")), typeof (n == null ? void 0 : n.limit) < "u" && (e.params["pagination.limit"] = n.limit.toString()), typeof (n == null ? void 0 : n.offset) < "u" && (e.params["pagination.offset"] = n.offset.toString()), typeof (n == null ? void 0 : n.reverse) < "u" && (e.params["pagination.reverse"] = n.reverse)), e);
helpers.setPaginationParams = setPaginationParams;
function toTimestamp(e) {
  const n = numberToLong(e.getTime() / 1e3), a = e.getTime() % 1e3 * 1e6;
  return {
    seconds: n,
    nanos: a
  };
}
helpers.toTimestamp = toTimestamp;
function fromTimestamp(e) {
  let n = e.seconds.toNumber() * 1e3;
  return n += e.nanos / 1e6, new Date(n);
}
helpers.fromTimestamp = fromTimestamp;
const timestampFromJSON = (e) => ({
  seconds: isSet(e.seconds) ? long_1.default.fromValue(e.seconds) : long_1.default.ZERO,
  nanos: isSet(e.nanos) ? Number(e.nanos) : 0
});
function fromJsonTimestamp(e) {
  return e instanceof Date ? toTimestamp(e) : typeof e == "string" ? toTimestamp(new Date(e)) : timestampFromJSON(e);
}
helpers.fromJsonTimestamp = fromJsonTimestamp;
function numberToLong(e) {
  return long_1.default.fromNumber(e);
}
var __createBinding$2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(e, n, a, c) {
  c === void 0 && (c = a);
  var u = Object.getOwnPropertyDescriptor(n, a);
  (!u || ("get" in u ? !n.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
    return n[a];
  } }), Object.defineProperty(e, c, u);
} : function(e, n, a, c) {
  c === void 0 && (c = a), e[c] = n[a];
}), __setModuleDefault$2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), __importStar$2 = commonjsGlobal && commonjsGlobal.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var a in e)
      a !== "default" && Object.prototype.hasOwnProperty.call(e, a) && __createBinding$2(n, e, a);
  return __setModuleDefault$2(n, e), n;
};
Object.defineProperty(multisig, "__esModule", { value: !0 });
multisig.CompactBitArray = multisig.MultiSignature = multisig.protobufPackage = void 0;
const _m0$2 = __importStar$2(minimal), helpers_1$2 = helpers;
multisig.protobufPackage = "cosmos.crypto.multisig.v1beta1";
function createBaseMultiSignature() {
  return {
    signatures: []
  };
}
multisig.MultiSignature = {
  encode(e, n = _m0$2.Writer.create()) {
    for (const a of e.signatures)
      n.uint32(10).bytes(a);
    return n;
  },
  decode(e, n) {
    const a = e instanceof _m0$2.Reader ? e : new _m0$2.Reader(e);
    let c = n === void 0 ? a.len : a.pos + n;
    const u = createBaseMultiSignature();
    for (; a.pos < c; ) {
      const h = a.uint32();
      switch (h >>> 3) {
        case 1:
          u.signatures.push(a.bytes());
          break;
        default:
          a.skipType(h & 7);
          break;
      }
    }
    return u;
  },
  fromJSON(e) {
    return {
      signatures: Array.isArray(e == null ? void 0 : e.signatures) ? e.signatures.map((n) => (0, helpers_1$2.bytesFromBase64)(n)) : []
    };
  },
  toJSON(e) {
    const n = {};
    return e.signatures ? n.signatures = e.signatures.map((a) => (0, helpers_1$2.base64FromBytes)(a !== void 0 ? a : new Uint8Array())) : n.signatures = [], n;
  },
  fromPartial(e) {
    var a;
    const n = createBaseMultiSignature();
    return n.signatures = ((a = e.signatures) == null ? void 0 : a.map((c) => c)) || [], n;
  }
};
function createBaseCompactBitArray() {
  return {
    extraBitsStored: 0,
    elems: new Uint8Array()
  };
}
multisig.CompactBitArray = {
  encode(e, n = _m0$2.Writer.create()) {
    return e.extraBitsStored !== 0 && n.uint32(8).uint32(e.extraBitsStored), e.elems.length !== 0 && n.uint32(18).bytes(e.elems), n;
  },
  decode(e, n) {
    const a = e instanceof _m0$2.Reader ? e : new _m0$2.Reader(e);
    let c = n === void 0 ? a.len : a.pos + n;
    const u = createBaseCompactBitArray();
    for (; a.pos < c; ) {
      const h = a.uint32();
      switch (h >>> 3) {
        case 1:
          u.extraBitsStored = a.uint32();
          break;
        case 2:
          u.elems = a.bytes();
          break;
        default:
          a.skipType(h & 7);
          break;
      }
    }
    return u;
  },
  fromJSON(e) {
    return {
      extraBitsStored: (0, helpers_1$2.isSet)(e.extraBitsStored) ? Number(e.extraBitsStored) : 0,
      elems: (0, helpers_1$2.isSet)(e.elems) ? (0, helpers_1$2.bytesFromBase64)(e.elems) : new Uint8Array()
    };
  },
  toJSON(e) {
    const n = {};
    return e.extraBitsStored !== void 0 && (n.extraBitsStored = Math.round(e.extraBitsStored)), e.elems !== void 0 && (n.elems = (0, helpers_1$2.base64FromBytes)(e.elems !== void 0 ? e.elems : new Uint8Array())), n;
  },
  fromPartial(e) {
    const n = createBaseCompactBitArray();
    return n.extraBitsStored = e.extraBitsStored ?? 0, n.elems = e.elems ?? new Uint8Array(), n;
  }
};
var any = {}, __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(e, n, a, c) {
  c === void 0 && (c = a);
  var u = Object.getOwnPropertyDescriptor(n, a);
  (!u || ("get" in u ? !n.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
    return n[a];
  } }), Object.defineProperty(e, c, u);
} : function(e, n, a, c) {
  c === void 0 && (c = a), e[c] = n[a];
}), __setModuleDefault$1 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var a in e)
      a !== "default" && Object.prototype.hasOwnProperty.call(e, a) && __createBinding$1(n, e, a);
  return __setModuleDefault$1(n, e), n;
};
Object.defineProperty(any, "__esModule", { value: !0 });
any.Any = any.protobufPackage = void 0;
const _m0$1 = __importStar$1(minimal), helpers_1$1 = helpers;
any.protobufPackage = "google.protobuf";
function createBaseAny() {
  return {
    typeUrl: "",
    value: new Uint8Array()
  };
}
any.Any = {
  encode(e, n = _m0$1.Writer.create()) {
    return e.typeUrl !== "" && n.uint32(10).string(e.typeUrl), e.value.length !== 0 && n.uint32(18).bytes(e.value), n;
  },
  decode(e, n) {
    const a = e instanceof _m0$1.Reader ? e : new _m0$1.Reader(e);
    let c = n === void 0 ? a.len : a.pos + n;
    const u = createBaseAny();
    for (; a.pos < c; ) {
      const h = a.uint32();
      switch (h >>> 3) {
        case 1:
          u.typeUrl = a.string();
          break;
        case 2:
          u.value = a.bytes();
          break;
        default:
          a.skipType(h & 7);
          break;
      }
    }
    return u;
  },
  fromJSON(e) {
    return {
      typeUrl: (0, helpers_1$1.isSet)(e.typeUrl) ? String(e.typeUrl) : "",
      value: (0, helpers_1$1.isSet)(e.value) ? (0, helpers_1$1.bytesFromBase64)(e.value) : new Uint8Array()
    };
  },
  toJSON(e) {
    const n = {};
    return e.typeUrl !== void 0 && (n.typeUrl = e.typeUrl), e.value !== void 0 && (n.value = (0, helpers_1$1.base64FromBytes)(e.value !== void 0 ? e.value : new Uint8Array())), n;
  },
  fromPartial(e) {
    const n = createBaseAny();
    return n.typeUrl = e.typeUrl ?? "", n.value = e.value ?? new Uint8Array(), n;
  }
};
(function(e) {
  var n = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(g, S, O, w) {
    w === void 0 && (w = O);
    var b = Object.getOwnPropertyDescriptor(S, O);
    (!b || ("get" in b ? !S.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
      return S[O];
    } }), Object.defineProperty(g, w, b);
  } : function(g, S, O, w) {
    w === void 0 && (w = O), g[w] = S[O];
  }), a = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(g, S) {
    Object.defineProperty(g, "default", { enumerable: !0, value: S });
  } : function(g, S) {
    g.default = S;
  }), c = commonjsGlobal && commonjsGlobal.__importStar || function(g) {
    if (g && g.__esModule)
      return g;
    var S = {};
    if (g != null)
      for (var O in g)
        O !== "default" && Object.prototype.hasOwnProperty.call(g, O) && n(S, g, O);
    return a(S, g), S;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.SignatureDescriptor_Data_Multi = e.SignatureDescriptor_Data_Single = e.SignatureDescriptor_Data = e.SignatureDescriptor = e.SignatureDescriptors = e.signModeToJSON = e.signModeFromJSON = e.SignMode = e.protobufPackage = void 0;
  const u = multisig, h = any, m = helpers, y = c(minimal);
  e.protobufPackage = "cosmos.tx.signing.v1beta1";
  var f;
  (function(g) {
    g[g.SIGN_MODE_UNSPECIFIED = 0] = "SIGN_MODE_UNSPECIFIED", g[g.SIGN_MODE_DIRECT = 1] = "SIGN_MODE_DIRECT", g[g.SIGN_MODE_TEXTUAL = 2] = "SIGN_MODE_TEXTUAL", g[g.SIGN_MODE_DIRECT_AUX = 3] = "SIGN_MODE_DIRECT_AUX", g[g.SIGN_MODE_LEGACY_AMINO_JSON = 127] = "SIGN_MODE_LEGACY_AMINO_JSON", g[g.SIGN_MODE_EIP_191 = 191] = "SIGN_MODE_EIP_191", g[g.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(f = e.SignMode || (e.SignMode = {}));
  function l(g) {
    switch (g) {
      case 0:
      case "SIGN_MODE_UNSPECIFIED":
        return f.SIGN_MODE_UNSPECIFIED;
      case 1:
      case "SIGN_MODE_DIRECT":
        return f.SIGN_MODE_DIRECT;
      case 2:
      case "SIGN_MODE_TEXTUAL":
        return f.SIGN_MODE_TEXTUAL;
      case 3:
      case "SIGN_MODE_DIRECT_AUX":
        return f.SIGN_MODE_DIRECT_AUX;
      case 127:
      case "SIGN_MODE_LEGACY_AMINO_JSON":
        return f.SIGN_MODE_LEGACY_AMINO_JSON;
      case 191:
      case "SIGN_MODE_EIP_191":
        return f.SIGN_MODE_EIP_191;
      case -1:
      case "UNRECOGNIZED":
      default:
        return f.UNRECOGNIZED;
    }
  }
  e.signModeFromJSON = l;
  function E(g) {
    switch (g) {
      case f.SIGN_MODE_UNSPECIFIED:
        return "SIGN_MODE_UNSPECIFIED";
      case f.SIGN_MODE_DIRECT:
        return "SIGN_MODE_DIRECT";
      case f.SIGN_MODE_TEXTUAL:
        return "SIGN_MODE_TEXTUAL";
      case f.SIGN_MODE_DIRECT_AUX:
        return "SIGN_MODE_DIRECT_AUX";
      case f.SIGN_MODE_LEGACY_AMINO_JSON:
        return "SIGN_MODE_LEGACY_AMINO_JSON";
      case f.SIGN_MODE_EIP_191:
        return "SIGN_MODE_EIP_191";
      case f.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.signModeToJSON = E;
  function I() {
    return {
      signatures: []
    };
  }
  e.SignatureDescriptors = {
    encode(g, S = y.Writer.create()) {
      for (const O of g.signatures)
        e.SignatureDescriptor.encode(O, S.uint32(10).fork()).ldelim();
      return S;
    },
    decode(g, S) {
      const O = g instanceof y.Reader ? g : new y.Reader(g);
      let w = S === void 0 ? O.len : O.pos + S;
      const b = I();
      for (; O.pos < w; ) {
        const P = O.uint32();
        switch (P >>> 3) {
          case 1:
            b.signatures.push(e.SignatureDescriptor.decode(O, O.uint32()));
            break;
          default:
            O.skipType(P & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(g) {
      return {
        signatures: Array.isArray(g == null ? void 0 : g.signatures) ? g.signatures.map((S) => e.SignatureDescriptor.fromJSON(S)) : []
      };
    },
    toJSON(g) {
      const S = {};
      return g.signatures ? S.signatures = g.signatures.map((O) => O ? e.SignatureDescriptor.toJSON(O) : void 0) : S.signatures = [], S;
    },
    fromPartial(g) {
      var O;
      const S = I();
      return S.signatures = ((O = g.signatures) == null ? void 0 : O.map((w) => e.SignatureDescriptor.fromPartial(w))) || [], S;
    }
  };
  function A() {
    return {
      publicKey: void 0,
      data: void 0,
      sequence: m.Long.UZERO
    };
  }
  e.SignatureDescriptor = {
    encode(g, S = y.Writer.create()) {
      return g.publicKey !== void 0 && h.Any.encode(g.publicKey, S.uint32(10).fork()).ldelim(), g.data !== void 0 && e.SignatureDescriptor_Data.encode(g.data, S.uint32(18).fork()).ldelim(), g.sequence.isZero() || S.uint32(24).uint64(g.sequence), S;
    },
    decode(g, S) {
      const O = g instanceof y.Reader ? g : new y.Reader(g);
      let w = S === void 0 ? O.len : O.pos + S;
      const b = A();
      for (; O.pos < w; ) {
        const P = O.uint32();
        switch (P >>> 3) {
          case 1:
            b.publicKey = h.Any.decode(O, O.uint32());
            break;
          case 2:
            b.data = e.SignatureDescriptor_Data.decode(O, O.uint32());
            break;
          case 3:
            b.sequence = O.uint64();
            break;
          default:
            O.skipType(P & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(g) {
      return {
        publicKey: (0, m.isSet)(g.publicKey) ? h.Any.fromJSON(g.publicKey) : void 0,
        data: (0, m.isSet)(g.data) ? e.SignatureDescriptor_Data.fromJSON(g.data) : void 0,
        sequence: (0, m.isSet)(g.sequence) ? m.Long.fromValue(g.sequence) : m.Long.UZERO
      };
    },
    toJSON(g) {
      const S = {};
      return g.publicKey !== void 0 && (S.publicKey = g.publicKey ? h.Any.toJSON(g.publicKey) : void 0), g.data !== void 0 && (S.data = g.data ? e.SignatureDescriptor_Data.toJSON(g.data) : void 0), g.sequence !== void 0 && (S.sequence = (g.sequence || m.Long.UZERO).toString()), S;
    },
    fromPartial(g) {
      const S = A();
      return S.publicKey = g.publicKey !== void 0 && g.publicKey !== null ? h.Any.fromPartial(g.publicKey) : void 0, S.data = g.data !== void 0 && g.data !== null ? e.SignatureDescriptor_Data.fromPartial(g.data) : void 0, S.sequence = g.sequence !== void 0 && g.sequence !== null ? m.Long.fromValue(g.sequence) : m.Long.UZERO, S;
    }
  };
  function D() {
    return {
      single: void 0,
      multi: void 0
    };
  }
  e.SignatureDescriptor_Data = {
    encode(g, S = y.Writer.create()) {
      return g.single !== void 0 && e.SignatureDescriptor_Data_Single.encode(g.single, S.uint32(10).fork()).ldelim(), g.multi !== void 0 && e.SignatureDescriptor_Data_Multi.encode(g.multi, S.uint32(18).fork()).ldelim(), S;
    },
    decode(g, S) {
      const O = g instanceof y.Reader ? g : new y.Reader(g);
      let w = S === void 0 ? O.len : O.pos + S;
      const b = D();
      for (; O.pos < w; ) {
        const P = O.uint32();
        switch (P >>> 3) {
          case 1:
            b.single = e.SignatureDescriptor_Data_Single.decode(O, O.uint32());
            break;
          case 2:
            b.multi = e.SignatureDescriptor_Data_Multi.decode(O, O.uint32());
            break;
          default:
            O.skipType(P & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(g) {
      return {
        single: (0, m.isSet)(g.single) ? e.SignatureDescriptor_Data_Single.fromJSON(g.single) : void 0,
        multi: (0, m.isSet)(g.multi) ? e.SignatureDescriptor_Data_Multi.fromJSON(g.multi) : void 0
      };
    },
    toJSON(g) {
      const S = {};
      return g.single !== void 0 && (S.single = g.single ? e.SignatureDescriptor_Data_Single.toJSON(g.single) : void 0), g.multi !== void 0 && (S.multi = g.multi ? e.SignatureDescriptor_Data_Multi.toJSON(g.multi) : void 0), S;
    },
    fromPartial(g) {
      const S = D();
      return S.single = g.single !== void 0 && g.single !== null ? e.SignatureDescriptor_Data_Single.fromPartial(g.single) : void 0, S.multi = g.multi !== void 0 && g.multi !== null ? e.SignatureDescriptor_Data_Multi.fromPartial(g.multi) : void 0, S;
    }
  };
  function R() {
    return {
      mode: 0,
      signature: new Uint8Array()
    };
  }
  e.SignatureDescriptor_Data_Single = {
    encode(g, S = y.Writer.create()) {
      return g.mode !== 0 && S.uint32(8).int32(g.mode), g.signature.length !== 0 && S.uint32(18).bytes(g.signature), S;
    },
    decode(g, S) {
      const O = g instanceof y.Reader ? g : new y.Reader(g);
      let w = S === void 0 ? O.len : O.pos + S;
      const b = R();
      for (; O.pos < w; ) {
        const P = O.uint32();
        switch (P >>> 3) {
          case 1:
            b.mode = O.int32();
            break;
          case 2:
            b.signature = O.bytes();
            break;
          default:
            O.skipType(P & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(g) {
      return {
        mode: (0, m.isSet)(g.mode) ? l(g.mode) : 0,
        signature: (0, m.isSet)(g.signature) ? (0, m.bytesFromBase64)(g.signature) : new Uint8Array()
      };
    },
    toJSON(g) {
      const S = {};
      return g.mode !== void 0 && (S.mode = E(g.mode)), g.signature !== void 0 && (S.signature = (0, m.base64FromBytes)(g.signature !== void 0 ? g.signature : new Uint8Array())), S;
    },
    fromPartial(g) {
      const S = R();
      return S.mode = g.mode ?? 0, S.signature = g.signature ?? new Uint8Array(), S;
    }
  };
  function M() {
    return {
      bitarray: void 0,
      signatures: []
    };
  }
  e.SignatureDescriptor_Data_Multi = {
    encode(g, S = y.Writer.create()) {
      g.bitarray !== void 0 && u.CompactBitArray.encode(g.bitarray, S.uint32(10).fork()).ldelim();
      for (const O of g.signatures)
        e.SignatureDescriptor_Data.encode(O, S.uint32(18).fork()).ldelim();
      return S;
    },
    decode(g, S) {
      const O = g instanceof y.Reader ? g : new y.Reader(g);
      let w = S === void 0 ? O.len : O.pos + S;
      const b = M();
      for (; O.pos < w; ) {
        const P = O.uint32();
        switch (P >>> 3) {
          case 1:
            b.bitarray = u.CompactBitArray.decode(O, O.uint32());
            break;
          case 2:
            b.signatures.push(e.SignatureDescriptor_Data.decode(O, O.uint32()));
            break;
          default:
            O.skipType(P & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(g) {
      return {
        bitarray: (0, m.isSet)(g.bitarray) ? u.CompactBitArray.fromJSON(g.bitarray) : void 0,
        signatures: Array.isArray(g == null ? void 0 : g.signatures) ? g.signatures.map((S) => e.SignatureDescriptor_Data.fromJSON(S)) : []
      };
    },
    toJSON(g) {
      const S = {};
      return g.bitarray !== void 0 && (S.bitarray = g.bitarray ? u.CompactBitArray.toJSON(g.bitarray) : void 0), g.signatures ? S.signatures = g.signatures.map((O) => O ? e.SignatureDescriptor_Data.toJSON(O) : void 0) : S.signatures = [], S;
    },
    fromPartial(g) {
      var O;
      const S = M();
      return S.bitarray = g.bitarray !== void 0 && g.bitarray !== null ? u.CompactBitArray.fromPartial(g.bitarray) : void 0, S.signatures = ((O = g.signatures) == null ? void 0 : O.map((w) => e.SignatureDescriptor_Data.fromPartial(w))) || [], S;
    }
  };
})(signing);
var tx = {}, coin = {}, __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(e, n, a, c) {
  c === void 0 && (c = a);
  var u = Object.getOwnPropertyDescriptor(n, a);
  (!u || ("get" in u ? !n.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
    return n[a];
  } }), Object.defineProperty(e, c, u);
} : function(e, n, a, c) {
  c === void 0 && (c = a), e[c] = n[a];
}), __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var a in e)
      a !== "default" && Object.prototype.hasOwnProperty.call(e, a) && __createBinding(n, e, a);
  return __setModuleDefault(n, e), n;
};
Object.defineProperty(coin, "__esModule", { value: !0 });
coin.DecProto = coin.IntProto = coin.DecCoin = coin.Coin = coin.protobufPackage = void 0;
const _m0 = __importStar(minimal), helpers_1 = helpers;
coin.protobufPackage = "cosmos.base.v1beta1";
function createBaseCoin() {
  return {
    denom: "",
    amount: ""
  };
}
coin.Coin = {
  encode(e, n = _m0.Writer.create()) {
    return e.denom !== "" && n.uint32(10).string(e.denom), e.amount !== "" && n.uint32(18).string(e.amount), n;
  },
  decode(e, n) {
    const a = e instanceof _m0.Reader ? e : new _m0.Reader(e);
    let c = n === void 0 ? a.len : a.pos + n;
    const u = createBaseCoin();
    for (; a.pos < c; ) {
      const h = a.uint32();
      switch (h >>> 3) {
        case 1:
          u.denom = a.string();
          break;
        case 2:
          u.amount = a.string();
          break;
        default:
          a.skipType(h & 7);
          break;
      }
    }
    return u;
  },
  fromJSON(e) {
    return {
      denom: (0, helpers_1.isSet)(e.denom) ? String(e.denom) : "",
      amount: (0, helpers_1.isSet)(e.amount) ? String(e.amount) : ""
    };
  },
  toJSON(e) {
    const n = {};
    return e.denom !== void 0 && (n.denom = e.denom), e.amount !== void 0 && (n.amount = e.amount), n;
  },
  fromPartial(e) {
    const n = createBaseCoin();
    return n.denom = e.denom ?? "", n.amount = e.amount ?? "", n;
  }
};
function createBaseDecCoin() {
  return {
    denom: "",
    amount: ""
  };
}
coin.DecCoin = {
  encode(e, n = _m0.Writer.create()) {
    return e.denom !== "" && n.uint32(10).string(e.denom), e.amount !== "" && n.uint32(18).string(e.amount), n;
  },
  decode(e, n) {
    const a = e instanceof _m0.Reader ? e : new _m0.Reader(e);
    let c = n === void 0 ? a.len : a.pos + n;
    const u = createBaseDecCoin();
    for (; a.pos < c; ) {
      const h = a.uint32();
      switch (h >>> 3) {
        case 1:
          u.denom = a.string();
          break;
        case 2:
          u.amount = a.string();
          break;
        default:
          a.skipType(h & 7);
          break;
      }
    }
    return u;
  },
  fromJSON(e) {
    return {
      denom: (0, helpers_1.isSet)(e.denom) ? String(e.denom) : "",
      amount: (0, helpers_1.isSet)(e.amount) ? String(e.amount) : ""
    };
  },
  toJSON(e) {
    const n = {};
    return e.denom !== void 0 && (n.denom = e.denom), e.amount !== void 0 && (n.amount = e.amount), n;
  },
  fromPartial(e) {
    const n = createBaseDecCoin();
    return n.denom = e.denom ?? "", n.amount = e.amount ?? "", n;
  }
};
function createBaseIntProto() {
  return {
    int: ""
  };
}
coin.IntProto = {
  encode(e, n = _m0.Writer.create()) {
    return e.int !== "" && n.uint32(10).string(e.int), n;
  },
  decode(e, n) {
    const a = e instanceof _m0.Reader ? e : new _m0.Reader(e);
    let c = n === void 0 ? a.len : a.pos + n;
    const u = createBaseIntProto();
    for (; a.pos < c; ) {
      const h = a.uint32();
      switch (h >>> 3) {
        case 1:
          u.int = a.string();
          break;
        default:
          a.skipType(h & 7);
          break;
      }
    }
    return u;
  },
  fromJSON(e) {
    return {
      int: (0, helpers_1.isSet)(e.int) ? String(e.int) : ""
    };
  },
  toJSON(e) {
    const n = {};
    return e.int !== void 0 && (n.int = e.int), n;
  },
  fromPartial(e) {
    const n = createBaseIntProto();
    return n.int = e.int ?? "", n;
  }
};
function createBaseDecProto() {
  return {
    dec: ""
  };
}
coin.DecProto = {
  encode(e, n = _m0.Writer.create()) {
    return e.dec !== "" && n.uint32(10).string(e.dec), n;
  },
  decode(e, n) {
    const a = e instanceof _m0.Reader ? e : new _m0.Reader(e);
    let c = n === void 0 ? a.len : a.pos + n;
    const u = createBaseDecProto();
    for (; a.pos < c; ) {
      const h = a.uint32();
      switch (h >>> 3) {
        case 1:
          u.dec = a.string();
          break;
        default:
          a.skipType(h & 7);
          break;
      }
    }
    return u;
  },
  fromJSON(e) {
    return {
      dec: (0, helpers_1.isSet)(e.dec) ? String(e.dec) : ""
    };
  },
  toJSON(e) {
    const n = {};
    return e.dec !== void 0 && (n.dec = e.dec), n;
  },
  fromPartial(e) {
    const n = createBaseDecProto();
    return n.dec = e.dec ?? "", n;
  }
};
(function(e) {
  var n = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(r, s, d, B) {
    B === void 0 && (B = d);
    var N = Object.getOwnPropertyDescriptor(s, d);
    (!N || ("get" in N ? !s.__esModule : N.writable || N.configurable)) && (N = { enumerable: !0, get: function() {
      return s[d];
    } }), Object.defineProperty(r, B, N);
  } : function(r, s, d, B) {
    B === void 0 && (B = d), r[B] = s[d];
  }), a = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(r, s) {
    Object.defineProperty(r, "default", { enumerable: !0, value: s });
  } : function(r, s) {
    r.default = s;
  }), c = commonjsGlobal && commonjsGlobal.__importStar || function(r) {
    if (r && r.__esModule)
      return r;
    var s = {};
    if (r != null)
      for (var d in r)
        d !== "default" && Object.prototype.hasOwnProperty.call(r, d) && n(s, r, d);
    return a(s, r), s;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.AuxSignerData = e.Tip = e.Fee = e.ModeInfo_Multi = e.ModeInfo_Single = e.ModeInfo = e.SignerInfo = e.AuthInfo = e.TxBody = e.SignDocDirectAux = e.SignDoc = e.TxRaw = e.Tx = e.protobufPackage = void 0;
  const u = any, h = signing, m = multisig, y = coin, f = helpers, l = c(minimal);
  e.protobufPackage = "cosmos.tx.v1beta1";
  function E() {
    return {
      body: void 0,
      authInfo: void 0,
      signatures: []
    };
  }
  e.Tx = {
    encode(r, s = l.Writer.create()) {
      r.body !== void 0 && e.TxBody.encode(r.body, s.uint32(10).fork()).ldelim(), r.authInfo !== void 0 && e.AuthInfo.encode(r.authInfo, s.uint32(18).fork()).ldelim();
      for (const d of r.signatures)
        s.uint32(26).bytes(d);
      return s;
    },
    decode(r, s) {
      const d = r instanceof l.Reader ? r : new l.Reader(r);
      let B = s === void 0 ? d.len : d.pos + s;
      const N = E();
      for (; d.pos < B; ) {
        const L = d.uint32();
        switch (L >>> 3) {
          case 1:
            N.body = e.TxBody.decode(d, d.uint32());
            break;
          case 2:
            N.authInfo = e.AuthInfo.decode(d, d.uint32());
            break;
          case 3:
            N.signatures.push(d.bytes());
            break;
          default:
            d.skipType(L & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(r) {
      return {
        body: (0, f.isSet)(r.body) ? e.TxBody.fromJSON(r.body) : void 0,
        authInfo: (0, f.isSet)(r.authInfo) ? e.AuthInfo.fromJSON(r.authInfo) : void 0,
        signatures: Array.isArray(r == null ? void 0 : r.signatures) ? r.signatures.map((s) => (0, f.bytesFromBase64)(s)) : []
      };
    },
    toJSON(r) {
      const s = {};
      return r.body !== void 0 && (s.body = r.body ? e.TxBody.toJSON(r.body) : void 0), r.authInfo !== void 0 && (s.authInfo = r.authInfo ? e.AuthInfo.toJSON(r.authInfo) : void 0), r.signatures ? s.signatures = r.signatures.map((d) => (0, f.base64FromBytes)(d !== void 0 ? d : new Uint8Array())) : s.signatures = [], s;
    },
    fromPartial(r) {
      var d;
      const s = E();
      return s.body = r.body !== void 0 && r.body !== null ? e.TxBody.fromPartial(r.body) : void 0, s.authInfo = r.authInfo !== void 0 && r.authInfo !== null ? e.AuthInfo.fromPartial(r.authInfo) : void 0, s.signatures = ((d = r.signatures) == null ? void 0 : d.map((B) => B)) || [], s;
    }
  };
  function I() {
    return {
      bodyBytes: new Uint8Array(),
      authInfoBytes: new Uint8Array(),
      signatures: []
    };
  }
  e.TxRaw = {
    encode(r, s = l.Writer.create()) {
      r.bodyBytes.length !== 0 && s.uint32(10).bytes(r.bodyBytes), r.authInfoBytes.length !== 0 && s.uint32(18).bytes(r.authInfoBytes);
      for (const d of r.signatures)
        s.uint32(26).bytes(d);
      return s;
    },
    decode(r, s) {
      const d = r instanceof l.Reader ? r : new l.Reader(r);
      let B = s === void 0 ? d.len : d.pos + s;
      const N = I();
      for (; d.pos < B; ) {
        const L = d.uint32();
        switch (L >>> 3) {
          case 1:
            N.bodyBytes = d.bytes();
            break;
          case 2:
            N.authInfoBytes = d.bytes();
            break;
          case 3:
            N.signatures.push(d.bytes());
            break;
          default:
            d.skipType(L & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(r) {
      return {
        bodyBytes: (0, f.isSet)(r.bodyBytes) ? (0, f.bytesFromBase64)(r.bodyBytes) : new Uint8Array(),
        authInfoBytes: (0, f.isSet)(r.authInfoBytes) ? (0, f.bytesFromBase64)(r.authInfoBytes) : new Uint8Array(),
        signatures: Array.isArray(r == null ? void 0 : r.signatures) ? r.signatures.map((s) => (0, f.bytesFromBase64)(s)) : []
      };
    },
    toJSON(r) {
      const s = {};
      return r.bodyBytes !== void 0 && (s.bodyBytes = (0, f.base64FromBytes)(r.bodyBytes !== void 0 ? r.bodyBytes : new Uint8Array())), r.authInfoBytes !== void 0 && (s.authInfoBytes = (0, f.base64FromBytes)(r.authInfoBytes !== void 0 ? r.authInfoBytes : new Uint8Array())), r.signatures ? s.signatures = r.signatures.map((d) => (0, f.base64FromBytes)(d !== void 0 ? d : new Uint8Array())) : s.signatures = [], s;
    },
    fromPartial(r) {
      var d;
      const s = I();
      return s.bodyBytes = r.bodyBytes ?? new Uint8Array(), s.authInfoBytes = r.authInfoBytes ?? new Uint8Array(), s.signatures = ((d = r.signatures) == null ? void 0 : d.map((B) => B)) || [], s;
    }
  };
  function A() {
    return {
      bodyBytes: new Uint8Array(),
      authInfoBytes: new Uint8Array(),
      chainId: "",
      accountNumber: f.Long.UZERO
    };
  }
  e.SignDoc = {
    encode(r, s = l.Writer.create()) {
      return r.bodyBytes.length !== 0 && s.uint32(10).bytes(r.bodyBytes), r.authInfoBytes.length !== 0 && s.uint32(18).bytes(r.authInfoBytes), r.chainId !== "" && s.uint32(26).string(r.chainId), r.accountNumber.isZero() || s.uint32(32).uint64(r.accountNumber), s;
    },
    decode(r, s) {
      const d = r instanceof l.Reader ? r : new l.Reader(r);
      let B = s === void 0 ? d.len : d.pos + s;
      const N = A();
      for (; d.pos < B; ) {
        const L = d.uint32();
        switch (L >>> 3) {
          case 1:
            N.bodyBytes = d.bytes();
            break;
          case 2:
            N.authInfoBytes = d.bytes();
            break;
          case 3:
            N.chainId = d.string();
            break;
          case 4:
            N.accountNumber = d.uint64();
            break;
          default:
            d.skipType(L & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(r) {
      return {
        bodyBytes: (0, f.isSet)(r.bodyBytes) ? (0, f.bytesFromBase64)(r.bodyBytes) : new Uint8Array(),
        authInfoBytes: (0, f.isSet)(r.authInfoBytes) ? (0, f.bytesFromBase64)(r.authInfoBytes) : new Uint8Array(),
        chainId: (0, f.isSet)(r.chainId) ? String(r.chainId) : "",
        accountNumber: (0, f.isSet)(r.accountNumber) ? f.Long.fromValue(r.accountNumber) : f.Long.UZERO
      };
    },
    toJSON(r) {
      const s = {};
      return r.bodyBytes !== void 0 && (s.bodyBytes = (0, f.base64FromBytes)(r.bodyBytes !== void 0 ? r.bodyBytes : new Uint8Array())), r.authInfoBytes !== void 0 && (s.authInfoBytes = (0, f.base64FromBytes)(r.authInfoBytes !== void 0 ? r.authInfoBytes : new Uint8Array())), r.chainId !== void 0 && (s.chainId = r.chainId), r.accountNumber !== void 0 && (s.accountNumber = (r.accountNumber || f.Long.UZERO).toString()), s;
    },
    fromPartial(r) {
      const s = A();
      return s.bodyBytes = r.bodyBytes ?? new Uint8Array(), s.authInfoBytes = r.authInfoBytes ?? new Uint8Array(), s.chainId = r.chainId ?? "", s.accountNumber = r.accountNumber !== void 0 && r.accountNumber !== null ? f.Long.fromValue(r.accountNumber) : f.Long.UZERO, s;
    }
  };
  function D() {
    return {
      bodyBytes: new Uint8Array(),
      publicKey: void 0,
      chainId: "",
      accountNumber: f.Long.UZERO,
      sequence: f.Long.UZERO,
      tip: void 0
    };
  }
  e.SignDocDirectAux = {
    encode(r, s = l.Writer.create()) {
      return r.bodyBytes.length !== 0 && s.uint32(10).bytes(r.bodyBytes), r.publicKey !== void 0 && u.Any.encode(r.publicKey, s.uint32(18).fork()).ldelim(), r.chainId !== "" && s.uint32(26).string(r.chainId), r.accountNumber.isZero() || s.uint32(32).uint64(r.accountNumber), r.sequence.isZero() || s.uint32(40).uint64(r.sequence), r.tip !== void 0 && e.Tip.encode(r.tip, s.uint32(50).fork()).ldelim(), s;
    },
    decode(r, s) {
      const d = r instanceof l.Reader ? r : new l.Reader(r);
      let B = s === void 0 ? d.len : d.pos + s;
      const N = D();
      for (; d.pos < B; ) {
        const L = d.uint32();
        switch (L >>> 3) {
          case 1:
            N.bodyBytes = d.bytes();
            break;
          case 2:
            N.publicKey = u.Any.decode(d, d.uint32());
            break;
          case 3:
            N.chainId = d.string();
            break;
          case 4:
            N.accountNumber = d.uint64();
            break;
          case 5:
            N.sequence = d.uint64();
            break;
          case 6:
            N.tip = e.Tip.decode(d, d.uint32());
            break;
          default:
            d.skipType(L & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(r) {
      return {
        bodyBytes: (0, f.isSet)(r.bodyBytes) ? (0, f.bytesFromBase64)(r.bodyBytes) : new Uint8Array(),
        publicKey: (0, f.isSet)(r.publicKey) ? u.Any.fromJSON(r.publicKey) : void 0,
        chainId: (0, f.isSet)(r.chainId) ? String(r.chainId) : "",
        accountNumber: (0, f.isSet)(r.accountNumber) ? f.Long.fromValue(r.accountNumber) : f.Long.UZERO,
        sequence: (0, f.isSet)(r.sequence) ? f.Long.fromValue(r.sequence) : f.Long.UZERO,
        tip: (0, f.isSet)(r.tip) ? e.Tip.fromJSON(r.tip) : void 0
      };
    },
    toJSON(r) {
      const s = {};
      return r.bodyBytes !== void 0 && (s.bodyBytes = (0, f.base64FromBytes)(r.bodyBytes !== void 0 ? r.bodyBytes : new Uint8Array())), r.publicKey !== void 0 && (s.publicKey = r.publicKey ? u.Any.toJSON(r.publicKey) : void 0), r.chainId !== void 0 && (s.chainId = r.chainId), r.accountNumber !== void 0 && (s.accountNumber = (r.accountNumber || f.Long.UZERO).toString()), r.sequence !== void 0 && (s.sequence = (r.sequence || f.Long.UZERO).toString()), r.tip !== void 0 && (s.tip = r.tip ? e.Tip.toJSON(r.tip) : void 0), s;
    },
    fromPartial(r) {
      const s = D();
      return s.bodyBytes = r.bodyBytes ?? new Uint8Array(), s.publicKey = r.publicKey !== void 0 && r.publicKey !== null ? u.Any.fromPartial(r.publicKey) : void 0, s.chainId = r.chainId ?? "", s.accountNumber = r.accountNumber !== void 0 && r.accountNumber !== null ? f.Long.fromValue(r.accountNumber) : f.Long.UZERO, s.sequence = r.sequence !== void 0 && r.sequence !== null ? f.Long.fromValue(r.sequence) : f.Long.UZERO, s.tip = r.tip !== void 0 && r.tip !== null ? e.Tip.fromPartial(r.tip) : void 0, s;
    }
  };
  function R() {
    return {
      messages: [],
      memo: "",
      timeoutHeight: f.Long.UZERO,
      extensionOptions: [],
      nonCriticalExtensionOptions: []
    };
  }
  e.TxBody = {
    encode(r, s = l.Writer.create()) {
      for (const d of r.messages)
        u.Any.encode(d, s.uint32(10).fork()).ldelim();
      r.memo !== "" && s.uint32(18).string(r.memo), r.timeoutHeight.isZero() || s.uint32(24).uint64(r.timeoutHeight);
      for (const d of r.extensionOptions)
        u.Any.encode(d, s.uint32(8186).fork()).ldelim();
      for (const d of r.nonCriticalExtensionOptions)
        u.Any.encode(d, s.uint32(16378).fork()).ldelim();
      return s;
    },
    decode(r, s) {
      const d = r instanceof l.Reader ? r : new l.Reader(r);
      let B = s === void 0 ? d.len : d.pos + s;
      const N = R();
      for (; d.pos < B; ) {
        const L = d.uint32();
        switch (L >>> 3) {
          case 1:
            N.messages.push(u.Any.decode(d, d.uint32()));
            break;
          case 2:
            N.memo = d.string();
            break;
          case 3:
            N.timeoutHeight = d.uint64();
            break;
          case 1023:
            N.extensionOptions.push(u.Any.decode(d, d.uint32()));
            break;
          case 2047:
            N.nonCriticalExtensionOptions.push(u.Any.decode(d, d.uint32()));
            break;
          default:
            d.skipType(L & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(r) {
      return {
        messages: Array.isArray(r == null ? void 0 : r.messages) ? r.messages.map((s) => u.Any.fromJSON(s)) : [],
        memo: (0, f.isSet)(r.memo) ? String(r.memo) : "",
        timeoutHeight: (0, f.isSet)(r.timeoutHeight) ? f.Long.fromValue(r.timeoutHeight) : f.Long.UZERO,
        extensionOptions: Array.isArray(r == null ? void 0 : r.extensionOptions) ? r.extensionOptions.map((s) => u.Any.fromJSON(s)) : [],
        nonCriticalExtensionOptions: Array.isArray(r == null ? void 0 : r.nonCriticalExtensionOptions) ? r.nonCriticalExtensionOptions.map((s) => u.Any.fromJSON(s)) : []
      };
    },
    toJSON(r) {
      const s = {};
      return r.messages ? s.messages = r.messages.map((d) => d ? u.Any.toJSON(d) : void 0) : s.messages = [], r.memo !== void 0 && (s.memo = r.memo), r.timeoutHeight !== void 0 && (s.timeoutHeight = (r.timeoutHeight || f.Long.UZERO).toString()), r.extensionOptions ? s.extensionOptions = r.extensionOptions.map((d) => d ? u.Any.toJSON(d) : void 0) : s.extensionOptions = [], r.nonCriticalExtensionOptions ? s.nonCriticalExtensionOptions = r.nonCriticalExtensionOptions.map((d) => d ? u.Any.toJSON(d) : void 0) : s.nonCriticalExtensionOptions = [], s;
    },
    fromPartial(r) {
      var d, B, N;
      const s = R();
      return s.messages = ((d = r.messages) == null ? void 0 : d.map((L) => u.Any.fromPartial(L))) || [], s.memo = r.memo ?? "", s.timeoutHeight = r.timeoutHeight !== void 0 && r.timeoutHeight !== null ? f.Long.fromValue(r.timeoutHeight) : f.Long.UZERO, s.extensionOptions = ((B = r.extensionOptions) == null ? void 0 : B.map((L) => u.Any.fromPartial(L))) || [], s.nonCriticalExtensionOptions = ((N = r.nonCriticalExtensionOptions) == null ? void 0 : N.map((L) => u.Any.fromPartial(L))) || [], s;
    }
  };
  function M() {
    return {
      signerInfos: [],
      fee: void 0,
      tip: void 0
    };
  }
  e.AuthInfo = {
    encode(r, s = l.Writer.create()) {
      for (const d of r.signerInfos)
        e.SignerInfo.encode(d, s.uint32(10).fork()).ldelim();
      return r.fee !== void 0 && e.Fee.encode(r.fee, s.uint32(18).fork()).ldelim(), r.tip !== void 0 && e.Tip.encode(r.tip, s.uint32(26).fork()).ldelim(), s;
    },
    decode(r, s) {
      const d = r instanceof l.Reader ? r : new l.Reader(r);
      let B = s === void 0 ? d.len : d.pos + s;
      const N = M();
      for (; d.pos < B; ) {
        const L = d.uint32();
        switch (L >>> 3) {
          case 1:
            N.signerInfos.push(e.SignerInfo.decode(d, d.uint32()));
            break;
          case 2:
            N.fee = e.Fee.decode(d, d.uint32());
            break;
          case 3:
            N.tip = e.Tip.decode(d, d.uint32());
            break;
          default:
            d.skipType(L & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(r) {
      return {
        signerInfos: Array.isArray(r == null ? void 0 : r.signerInfos) ? r.signerInfos.map((s) => e.SignerInfo.fromJSON(s)) : [],
        fee: (0, f.isSet)(r.fee) ? e.Fee.fromJSON(r.fee) : void 0,
        tip: (0, f.isSet)(r.tip) ? e.Tip.fromJSON(r.tip) : void 0
      };
    },
    toJSON(r) {
      const s = {};
      return r.signerInfos ? s.signerInfos = r.signerInfos.map((d) => d ? e.SignerInfo.toJSON(d) : void 0) : s.signerInfos = [], r.fee !== void 0 && (s.fee = r.fee ? e.Fee.toJSON(r.fee) : void 0), r.tip !== void 0 && (s.tip = r.tip ? e.Tip.toJSON(r.tip) : void 0), s;
    },
    fromPartial(r) {
      var d;
      const s = M();
      return s.signerInfos = ((d = r.signerInfos) == null ? void 0 : d.map((B) => e.SignerInfo.fromPartial(B))) || [], s.fee = r.fee !== void 0 && r.fee !== null ? e.Fee.fromPartial(r.fee) : void 0, s.tip = r.tip !== void 0 && r.tip !== null ? e.Tip.fromPartial(r.tip) : void 0, s;
    }
  };
  function g() {
    return {
      publicKey: void 0,
      modeInfo: void 0,
      sequence: f.Long.UZERO
    };
  }
  e.SignerInfo = {
    encode(r, s = l.Writer.create()) {
      return r.publicKey !== void 0 && u.Any.encode(r.publicKey, s.uint32(10).fork()).ldelim(), r.modeInfo !== void 0 && e.ModeInfo.encode(r.modeInfo, s.uint32(18).fork()).ldelim(), r.sequence.isZero() || s.uint32(24).uint64(r.sequence), s;
    },
    decode(r, s) {
      const d = r instanceof l.Reader ? r : new l.Reader(r);
      let B = s === void 0 ? d.len : d.pos + s;
      const N = g();
      for (; d.pos < B; ) {
        const L = d.uint32();
        switch (L >>> 3) {
          case 1:
            N.publicKey = u.Any.decode(d, d.uint32());
            break;
          case 2:
            N.modeInfo = e.ModeInfo.decode(d, d.uint32());
            break;
          case 3:
            N.sequence = d.uint64();
            break;
          default:
            d.skipType(L & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(r) {
      return {
        publicKey: (0, f.isSet)(r.publicKey) ? u.Any.fromJSON(r.publicKey) : void 0,
        modeInfo: (0, f.isSet)(r.modeInfo) ? e.ModeInfo.fromJSON(r.modeInfo) : void 0,
        sequence: (0, f.isSet)(r.sequence) ? f.Long.fromValue(r.sequence) : f.Long.UZERO
      };
    },
    toJSON(r) {
      const s = {};
      return r.publicKey !== void 0 && (s.publicKey = r.publicKey ? u.Any.toJSON(r.publicKey) : void 0), r.modeInfo !== void 0 && (s.modeInfo = r.modeInfo ? e.ModeInfo.toJSON(r.modeInfo) : void 0), r.sequence !== void 0 && (s.sequence = (r.sequence || f.Long.UZERO).toString()), s;
    },
    fromPartial(r) {
      const s = g();
      return s.publicKey = r.publicKey !== void 0 && r.publicKey !== null ? u.Any.fromPartial(r.publicKey) : void 0, s.modeInfo = r.modeInfo !== void 0 && r.modeInfo !== null ? e.ModeInfo.fromPartial(r.modeInfo) : void 0, s.sequence = r.sequence !== void 0 && r.sequence !== null ? f.Long.fromValue(r.sequence) : f.Long.UZERO, s;
    }
  };
  function S() {
    return {
      single: void 0,
      multi: void 0
    };
  }
  e.ModeInfo = {
    encode(r, s = l.Writer.create()) {
      return r.single !== void 0 && e.ModeInfo_Single.encode(r.single, s.uint32(10).fork()).ldelim(), r.multi !== void 0 && e.ModeInfo_Multi.encode(r.multi, s.uint32(18).fork()).ldelim(), s;
    },
    decode(r, s) {
      const d = r instanceof l.Reader ? r : new l.Reader(r);
      let B = s === void 0 ? d.len : d.pos + s;
      const N = S();
      for (; d.pos < B; ) {
        const L = d.uint32();
        switch (L >>> 3) {
          case 1:
            N.single = e.ModeInfo_Single.decode(d, d.uint32());
            break;
          case 2:
            N.multi = e.ModeInfo_Multi.decode(d, d.uint32());
            break;
          default:
            d.skipType(L & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(r) {
      return {
        single: (0, f.isSet)(r.single) ? e.ModeInfo_Single.fromJSON(r.single) : void 0,
        multi: (0, f.isSet)(r.multi) ? e.ModeInfo_Multi.fromJSON(r.multi) : void 0
      };
    },
    toJSON(r) {
      const s = {};
      return r.single !== void 0 && (s.single = r.single ? e.ModeInfo_Single.toJSON(r.single) : void 0), r.multi !== void 0 && (s.multi = r.multi ? e.ModeInfo_Multi.toJSON(r.multi) : void 0), s;
    },
    fromPartial(r) {
      const s = S();
      return s.single = r.single !== void 0 && r.single !== null ? e.ModeInfo_Single.fromPartial(r.single) : void 0, s.multi = r.multi !== void 0 && r.multi !== null ? e.ModeInfo_Multi.fromPartial(r.multi) : void 0, s;
    }
  };
  function O() {
    return {
      mode: 0
    };
  }
  e.ModeInfo_Single = {
    encode(r, s = l.Writer.create()) {
      return r.mode !== 0 && s.uint32(8).int32(r.mode), s;
    },
    decode(r, s) {
      const d = r instanceof l.Reader ? r : new l.Reader(r);
      let B = s === void 0 ? d.len : d.pos + s;
      const N = O();
      for (; d.pos < B; ) {
        const L = d.uint32();
        switch (L >>> 3) {
          case 1:
            N.mode = d.int32();
            break;
          default:
            d.skipType(L & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(r) {
      return {
        mode: (0, f.isSet)(r.mode) ? (0, h.signModeFromJSON)(r.mode) : 0
      };
    },
    toJSON(r) {
      const s = {};
      return r.mode !== void 0 && (s.mode = (0, h.signModeToJSON)(r.mode)), s;
    },
    fromPartial(r) {
      const s = O();
      return s.mode = r.mode ?? 0, s;
    }
  };
  function w() {
    return {
      bitarray: void 0,
      modeInfos: []
    };
  }
  e.ModeInfo_Multi = {
    encode(r, s = l.Writer.create()) {
      r.bitarray !== void 0 && m.CompactBitArray.encode(r.bitarray, s.uint32(10).fork()).ldelim();
      for (const d of r.modeInfos)
        e.ModeInfo.encode(d, s.uint32(18).fork()).ldelim();
      return s;
    },
    decode(r, s) {
      const d = r instanceof l.Reader ? r : new l.Reader(r);
      let B = s === void 0 ? d.len : d.pos + s;
      const N = w();
      for (; d.pos < B; ) {
        const L = d.uint32();
        switch (L >>> 3) {
          case 1:
            N.bitarray = m.CompactBitArray.decode(d, d.uint32());
            break;
          case 2:
            N.modeInfos.push(e.ModeInfo.decode(d, d.uint32()));
            break;
          default:
            d.skipType(L & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(r) {
      return {
        bitarray: (0, f.isSet)(r.bitarray) ? m.CompactBitArray.fromJSON(r.bitarray) : void 0,
        modeInfos: Array.isArray(r == null ? void 0 : r.modeInfos) ? r.modeInfos.map((s) => e.ModeInfo.fromJSON(s)) : []
      };
    },
    toJSON(r) {
      const s = {};
      return r.bitarray !== void 0 && (s.bitarray = r.bitarray ? m.CompactBitArray.toJSON(r.bitarray) : void 0), r.modeInfos ? s.modeInfos = r.modeInfos.map((d) => d ? e.ModeInfo.toJSON(d) : void 0) : s.modeInfos = [], s;
    },
    fromPartial(r) {
      var d;
      const s = w();
      return s.bitarray = r.bitarray !== void 0 && r.bitarray !== null ? m.CompactBitArray.fromPartial(r.bitarray) : void 0, s.modeInfos = ((d = r.modeInfos) == null ? void 0 : d.map((B) => e.ModeInfo.fromPartial(B))) || [], s;
    }
  };
  function b() {
    return {
      amount: [],
      gasLimit: f.Long.UZERO,
      payer: "",
      granter: ""
    };
  }
  e.Fee = {
    encode(r, s = l.Writer.create()) {
      for (const d of r.amount)
        y.Coin.encode(d, s.uint32(10).fork()).ldelim();
      return r.gasLimit.isZero() || s.uint32(16).uint64(r.gasLimit), r.payer !== "" && s.uint32(26).string(r.payer), r.granter !== "" && s.uint32(34).string(r.granter), s;
    },
    decode(r, s) {
      const d = r instanceof l.Reader ? r : new l.Reader(r);
      let B = s === void 0 ? d.len : d.pos + s;
      const N = b();
      for (; d.pos < B; ) {
        const L = d.uint32();
        switch (L >>> 3) {
          case 1:
            N.amount.push(y.Coin.decode(d, d.uint32()));
            break;
          case 2:
            N.gasLimit = d.uint64();
            break;
          case 3:
            N.payer = d.string();
            break;
          case 4:
            N.granter = d.string();
            break;
          default:
            d.skipType(L & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(r) {
      return {
        amount: Array.isArray(r == null ? void 0 : r.amount) ? r.amount.map((s) => y.Coin.fromJSON(s)) : [],
        gasLimit: (0, f.isSet)(r.gasLimit) ? f.Long.fromValue(r.gasLimit) : f.Long.UZERO,
        payer: (0, f.isSet)(r.payer) ? String(r.payer) : "",
        granter: (0, f.isSet)(r.granter) ? String(r.granter) : ""
      };
    },
    toJSON(r) {
      const s = {};
      return r.amount ? s.amount = r.amount.map((d) => d ? y.Coin.toJSON(d) : void 0) : s.amount = [], r.gasLimit !== void 0 && (s.gasLimit = (r.gasLimit || f.Long.UZERO).toString()), r.payer !== void 0 && (s.payer = r.payer), r.granter !== void 0 && (s.granter = r.granter), s;
    },
    fromPartial(r) {
      var d;
      const s = b();
      return s.amount = ((d = r.amount) == null ? void 0 : d.map((B) => y.Coin.fromPartial(B))) || [], s.gasLimit = r.gasLimit !== void 0 && r.gasLimit !== null ? f.Long.fromValue(r.gasLimit) : f.Long.UZERO, s.payer = r.payer ?? "", s.granter = r.granter ?? "", s;
    }
  };
  function P() {
    return {
      amount: [],
      tipper: ""
    };
  }
  e.Tip = {
    encode(r, s = l.Writer.create()) {
      for (const d of r.amount)
        y.Coin.encode(d, s.uint32(10).fork()).ldelim();
      return r.tipper !== "" && s.uint32(18).string(r.tipper), s;
    },
    decode(r, s) {
      const d = r instanceof l.Reader ? r : new l.Reader(r);
      let B = s === void 0 ? d.len : d.pos + s;
      const N = P();
      for (; d.pos < B; ) {
        const L = d.uint32();
        switch (L >>> 3) {
          case 1:
            N.amount.push(y.Coin.decode(d, d.uint32()));
            break;
          case 2:
            N.tipper = d.string();
            break;
          default:
            d.skipType(L & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(r) {
      return {
        amount: Array.isArray(r == null ? void 0 : r.amount) ? r.amount.map((s) => y.Coin.fromJSON(s)) : [],
        tipper: (0, f.isSet)(r.tipper) ? String(r.tipper) : ""
      };
    },
    toJSON(r) {
      const s = {};
      return r.amount ? s.amount = r.amount.map((d) => d ? y.Coin.toJSON(d) : void 0) : s.amount = [], r.tipper !== void 0 && (s.tipper = r.tipper), s;
    },
    fromPartial(r) {
      var d;
      const s = P();
      return s.amount = ((d = r.amount) == null ? void 0 : d.map((B) => y.Coin.fromPartial(B))) || [], s.tipper = r.tipper ?? "", s;
    }
  };
  function F() {
    return {
      address: "",
      signDoc: void 0,
      mode: 0,
      sig: new Uint8Array()
    };
  }
  e.AuxSignerData = {
    encode(r, s = l.Writer.create()) {
      return r.address !== "" && s.uint32(10).string(r.address), r.signDoc !== void 0 && e.SignDocDirectAux.encode(r.signDoc, s.uint32(18).fork()).ldelim(), r.mode !== 0 && s.uint32(24).int32(r.mode), r.sig.length !== 0 && s.uint32(34).bytes(r.sig), s;
    },
    decode(r, s) {
      const d = r instanceof l.Reader ? r : new l.Reader(r);
      let B = s === void 0 ? d.len : d.pos + s;
      const N = F();
      for (; d.pos < B; ) {
        const L = d.uint32();
        switch (L >>> 3) {
          case 1:
            N.address = d.string();
            break;
          case 2:
            N.signDoc = e.SignDocDirectAux.decode(d, d.uint32());
            break;
          case 3:
            N.mode = d.int32();
            break;
          case 4:
            N.sig = d.bytes();
            break;
          default:
            d.skipType(L & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(r) {
      return {
        address: (0, f.isSet)(r.address) ? String(r.address) : "",
        signDoc: (0, f.isSet)(r.signDoc) ? e.SignDocDirectAux.fromJSON(r.signDoc) : void 0,
        mode: (0, f.isSet)(r.mode) ? (0, h.signModeFromJSON)(r.mode) : 0,
        sig: (0, f.isSet)(r.sig) ? (0, f.bytesFromBase64)(r.sig) : new Uint8Array()
      };
    },
    toJSON(r) {
      const s = {};
      return r.address !== void 0 && (s.address = r.address), r.signDoc !== void 0 && (s.signDoc = r.signDoc ? e.SignDocDirectAux.toJSON(r.signDoc) : void 0), r.mode !== void 0 && (s.mode = (0, h.signModeToJSON)(r.mode)), r.sig !== void 0 && (s.sig = (0, f.base64FromBytes)(r.sig !== void 0 ? r.sig : new Uint8Array())), s;
    },
    fromPartial(r) {
      const s = F();
      return s.address = r.address ?? "", s.signDoc = r.signDoc !== void 0 && r.signDoc !== null ? e.SignDocDirectAux.fromPartial(r.signDoc) : void 0, s.mode = r.mode ?? 0, s.sig = r.sig ?? new Uint8Array(), s;
    }
  };
})(tx);
const getAddressFromAccount = (e) => {
  try {
    return e.split(":")[2];
  } catch {
    throw new Error("Invalid WalletConnect account");
  }
}, getAddressByChain = (e, n) => getAddressFromAccount(
  n.find((a) => a.startsWith(chainToChainId(e))) || ""
), chainToChainId = (e) => {
  switch (e) {
    case i.Avalanche:
      return AVALACHE_MAINNET_ID;
    case i.BinanceSmartChain:
      return BSC_MAINNET_ID;
    case i.Ethereum:
      return ETHEREUM_MAINNET_ID;
    case i.Binance:
      return BINANCE_MAINNET_ID;
    case i.THORChain:
      return THORCHAIN_MAINNET_ID;
    default:
      return "";
  }
};
class WalletconnectSigner extends Signer {
  constructor({ chain: a, provider: c, walletconnect: u }) {
    super();
    C(this, "chain");
    C(this, "walletconnect");
    C(this, "address");
    C(this, "provider");
    C(this, "getAddress", async () => {
      if (!this.walletconnect)
        throw new Error("Missing walletconnect");
      return this.address || (this.address = getAddressByChain(this.chain, this.walletconnect.accounts)), this.address;
    });
    C(this, "signMessage", async (a) => {
      var u;
      const c = await ((u = this.walletconnect) == null ? void 0 : u.client.request({
        chainId: chainToChainId(this.chain),
        topic: this.walletconnect.session.topic,
        request: {
          method: DEFAULT_EIP155_METHODS.ETH_SIGN,
          params: [a]
        }
      }));
      return c.startsWith("0x") ? c : `0x${c}`;
    });
    C(this, "signTransaction", () => {
      throw new Error("signTransaction not implemented for walletconnect");
    });
    C(this, "sendTransaction", async ({ from: a, to: c, value: u, data: h }) => {
      var f;
      const { BigNumber: m } = await import("@ethersproject/bignumber"), y = {
        from: a,
        to: c,
        value: m.from(u || 0).toHexString(),
        data: h
      };
      return (f = this.walletconnect) == null ? void 0 : f.client.request({
        chainId: chainToChainId(this.chain),
        topic: this.walletconnect.session.topic,
        request: {
          method: DEFAULT_EIP155_METHODS.ETH_SEND_TRANSACTION,
          params: [y]
        }
      });
    });
    C(this, "connect", (a) => new WalletconnectSigner({
      chain: this.chain,
      walletconnect: this.walletconnect,
      provider: a
    }));
    this.chain = a, this.walletconnect = u, this.provider = c, this.address = "";
  }
}
const getEVMSigner = async ({
  chain: e,
  walletconnect: n,
  provider: a
}) => new WalletconnectSigner({ chain: e, walletconnect: n, provider: a }), getNamespacesFromChains = (e) => {
  const n = [];
  return e.forEach((a) => {
    const [c] = a.split(":");
    n.includes(c) || n.push(c);
  }), n;
}, getSupportedMethodsByNamespace = (e) => {
  switch (e) {
    case "eip155":
      return Object.values(DEFAULT_EIP155_METHODS);
    case "cosmos":
      return Object.values(DEFAULT_COSMOS_METHODS);
    case "solana":
      return Object.values(DEFAULT_SOLANA_METHODS);
    case "polkadot":
      return Object.values(DEFAULT_POLKADOT_METHODS);
    case "near":
      return Object.values(DEFAULT_NEAR_METHODS);
    default:
      throw new Error(`No default methods for namespace: ${e}`);
  }
}, getSupportedEventsByNamespace = (e) => {
  switch (e) {
    case "eip155":
      return Object.values(DEFAULT_EIP_155_EVENTS);
    case "cosmos":
      return [];
    case "solana":
      return Object.values(DEFAULT_SOLANA_EVENTS);
    case "polkadot":
      return Object.values(DEFAULT_POLKADOT_EVENTS);
    case "near":
      return Object.values(DEFAULT_NEAR_EVENTS);
    default:
      throw new Error(`No default events for namespace: ${e}`);
  }
}, getRequiredNamespaces = (e) => {
  const n = getNamespacesFromChains(e);
  return Object.fromEntries(
    n.map((a) => [
      a,
      {
        methods: getSupportedMethodsByNamespace(a),
        chains: e.filter((c) => c.startsWith(a)),
        events: getSupportedEventsByNamespace(a)
      }
    ])
  );
}, THORCHAIN_GAS_FEE = "500000000", DEFAULT_THORCHAIN_FEE = {
  amount: [],
  gas: THORCHAIN_GAS_FEE
};
i.Binance, i.BinanceSmartChain, i.Ethereum, i.THORChain, i.Avalanche;
const getToolbox = async ({
  chain: e,
  ethplorerApiKey: n,
  covalentApiKey: a = "",
  walletconnect: c,
  address: u,
  session: h,
  stagenet: m = !1
}) => {
  const y = u;
  switch (e) {
    case i.Avalanche:
    case i.BinanceSmartChain:
    case i.Ethereum: {
      if (e === i.Ethereum && !n)
        throw new Error("Ethplorer API key not found");
      if (e !== i.Ethereum && !a)
        throw new Error("Covalent API key not found");
      const { getProvider: f, ETHToolbox: l, AVAXToolbox: E, BSCToolbox: I } = await import("@pioneer-platform/toolbox-evm"), A = f(e), D = await getEVMSigner({ walletconnect: c, chain: e, provider: A });
      return e === i.Ethereum ? l({ provider: A, signer: D, ethplorerApiKey: n }) : e === i.Avalanche ? E({ provider: A, signer: D, covalentApiKey: a }) : I({ provider: A, signer: D, covalentApiKey: a });
    }
    case i.Binance: {
      const { sortObject: f, BinanceToolbox: l } = await import("@pioneer-platform/toolbox-cosmos"), E = l();
      return { ...E, transfer: async (A) => {
        var r;
        const D = await E.getAccount(y), R = A.amount.amount().toString(), { transaction: M, signMsg: g } = await E.createTransactionAndSignMsg({
          from: y,
          to: A.recipient,
          amount: R,
          asset: A.asset.ticker,
          memo: A.memo
        }), S = f({
          account_number: D.account_number.toString(),
          chain_id: T.Binance,
          data: null,
          memo: A.memo,
          msgs: [g],
          sequence: D.sequence.toString(),
          source: "0"
        }), O = await (c == null ? void 0 : c.client.request({
          chainId: BINANCE_MAINNET_ID,
          topic: h.topic,
          request: {
            method: DEFAULT_COSMOS_METHODS.COSMOS_SIGN_AMINO,
            params: { signerAddress: u, signDoc: S }
          }
        })), w = Buffer.from(O.signature, "hex"), b = E.getPublicKey(O.publicKey), P = M.addSignature(b, w);
        return (r = (await E.sendRawTransaction(P.serialize(), !0))[0]) == null ? void 0 : r.hash;
      } };
    }
    case i.THORChain: {
      const { ThorchainToolbox: f } = await import("@pioneer-platform/toolbox-cosmos"), l = f({ stagenet: m }), E = (D) => (
        //@ts-ignore
        c == null ? void 0 : c.client.request({
          chainId: THORCHAIN_MAINNET_ID,
          topic: h.topic,
          request: {
            method: DEFAULT_COSMOS_METHODS.COSMOS_SIGN_AMINO,
            params: { signerAddress: u, signDoc: D }
          }
        })
      );
      return { ...l, transfer: async (D) => {
        var G;
        const R = await l.getAccount(y);
        if (!R)
          throw new Error("Account not found");
        if (!R.pubkey)
          throw new Error("Account pubkey not found");
        const { accountNumber: M, sequence: g = 0 } = R, O = {
          type: "thorchain/MsgSend",
          value: {
            amount: [
              {
                amount: D.amount.amount().toString(),
                denom: (G = D.asset) == null ? void 0 : G.symbol.toLowerCase()
              }
            ],
            from_address: u,
            to_address: D.recipient
          }
        }, w = makeSignDoc(
          [O],
          DEFAULT_THORCHAIN_FEE,
          T.THORChain,
          D.memo,
          M == null ? void 0 : M.toString(),
          (g == null ? void 0 : g.toString()) || "0"
        ), b = await E(w), P = {
          msg: [O],
          fee: DEFAULT_THORCHAIN_FEE,
          memo: D.memo,
          signatures: [
            {
              // The request coming from TW Android are different from those coming from iOS.
              ...typeof b.signature == "string" ? b : b.signature,
              sequence: g == null ? void 0 : g.toString()
            }
          ]
        }, F = await l.createDefaultAminoTypes(), r = await l.createDefaultRegistry(), s = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: {
            messages: P.msg.map((J) => F.fromAmino(J)),
            memo: P.memo
          }
        }, d = signing.SignMode.SIGN_MODE_LEGACY_AMINO_JSON, B = r.encode(s), N = Int53.fromString(P.fee.gas).toNumber(), L = encodePubkey(R.pubkey), $ = makeAuthInfoBytes(
          [{ pubkey: L, sequence: g }],
          P.fee.amount,
          N,
          void 0,
          void 0,
          d
        ), H = tx.TxRaw.fromPartial({
          bodyBytes: B,
          authInfoBytes: $,
          signatures: [
            fromBase64(
              typeof b.signature == "string" ? b.signature : b.signature.signature
            )
          ]
        }), W = tx.TxRaw.encode(H).finish();
        return (await (await StargateClient.connect(
          m ? _.THORChainStagenet : _.THORChain
        )).broadcastTx(W)).transactionHash;
      }, deposit: async ({ asset: D, amount: R, memo: M }) => {
        const g = await l.getAccount(u);
        if (!D)
          throw new Error("invalid asset to deposit");
        if (!g)
          throw new Error("Account not found");
        if (!g.pubkey)
          throw new Error("Account pubkey not found");
        const { accountNumber: S, sequence: O = 0 } = g, w = makeSignDoc(
          [l.createDepositMessage(D, R, u, M)],
          DEFAULT_THORCHAIN_FEE,
          T.THORChain,
          M,
          S == null ? void 0 : S.toString(),
          (O == null ? void 0 : O.toString()) || "0"
        ), b = await E(w), P = {
          msg: [l.createDepositMessage(D, R, u, M, !0)],
          fee: DEFAULT_THORCHAIN_FEE,
          memo: M,
          signatures: [
            {
              // The request coming from TW Android are different from those coming from iOS.
              ...typeof b.signature == "string" ? b : b.signature,
              sequence: O == null ? void 0 : O.toString()
            }
          ]
        }, F = await l.createDefaultAminoTypes(), r = await l.createDefaultRegistry(), s = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: {
            messages: P.msg.map((G) => F.fromAmino(G)),
            memo: P.memo
          }
        }, d = signing.SignMode.SIGN_MODE_LEGACY_AMINO_JSON, B = r.encode(s), N = Int53.fromString(P.fee.gas).toNumber(), L = encodePubkey(g.pubkey), $ = makeAuthInfoBytes(
          [{ pubkey: L, sequence: O }],
          P.fee.amount,
          N,
          void 0,
          void 0,
          d
        ), H = tx.TxRaw.fromPartial({
          bodyBytes: B,
          authInfoBytes: $,
          signatures: [
            fromBase64(
              typeof b.signature == "string" ? b.signature : b.signature.signature
            )
          ]
        }), W = tx.TxRaw.encode(H).finish();
        return (await (await StargateClient.connect(
          m ? _.THORChainStagenet : _.THORChain
        )).broadcastTx(W)).transactionHash;
      } };
    }
    default:
      throw new Error("Chain is not supported");
  }
}, getWalletconnect = async (e, n, a) => {
  try {
    if (!n)
      throw new Error("Error while setting up walletconnect connection: Project ID not specified");
    const c = getRequiredNamespaces(e.map(chainToChainId)), { WalletConnectModalSign: u } = await import("./index-1ca6cee9.js").then((f) => f.i), h = new u({
      logger: DEFAULT_LOGGER,
      relayUrl: DEFAULT_RELAY_URL,
      projectId: n,
      metadata: (a == null ? void 0 : a.metadata) || DEFAULT_APP_METADATA,
      ...a == null ? void 0 : a.core
    }), m = await h.connect({
      requiredNamespaces: c
    }), y = Object.values(m.namespaces).map((f) => f.accounts).flat();
    return { session: m, accounts: y, client: h };
  } catch (c) {
    console.error(c);
  } finally {
  }
}, connectWalletconnect = ({
  addChain: e,
  config: { ethplorerApiKey: n, walletConnectProjectId: a, covalentApiKey: c, stagenet: u = !1 }
}) => async (h, m) => {
  const y = h.filter((A) => WC_SUPPORTED_CHAINS.includes(A)), f = await getWalletconnect(
    y,
    a,
    m
  );
  if (!f)
    throw new Error("Unable to establish connection through walletconnect");
  const { session: l, accounts: E } = f, I = y.map(async (A) => {
    const D = getAddressByChain(A, E), R = await getToolbox({
      session: l,
      address: D,
      chain: A,
      walletconnect: f,
      ethplorerApiKey: n,
      covalentApiKey: c,
      stagenet: u
    }), M = async (g) => {
      const S = await R.getAccount(g), [O] = await (f == null ? void 0 : f.client.request({
        chainId: THORCHAIN_MAINNET_ID,
        topic: l.topic,
        request: {
          method: DEFAULT_COSMOS_METHODS.COSMOS_GET_ACCOUNTS,
          params: {}
        }
      }));
      return {
        ...S,
        address: O.address,
        pubkey: {
          type: O.algo,
          value: O.pubkey
        }
      };
    };
    e({
      chain: A,
      walletMethods: {
        ...R,
        getAddress: () => D,
        getAccount: A === i.THORChain ? M : R
      },
      wallet: { address: D, balance: [], walletType: U.WALLETCONNECT }
    });
  });
  return await Promise.all(I), !0;
}, walletconnectWallet = {
  connectMethodName: "connectWalletconnect",
  connect: connectWalletconnect
};
export {
  AVALACHE_MAINNET_ID as A,
  BSC_MAINNET_ID as B,
  DEFAULT_RELAY_URL as D,
  ETHEREUM_MAINNET_ID as E,
  THORCHAIN_MAINNET_ID as T,
  WC_SUPPORTED_CHAINS as W,
  getDefaultExportFromCjs as a,
  BINANCE_MAINNET_ID as b,
  commonjsGlobal as c,
  DEFAULT_LOGGER as d,
  DEFAULT_APP_METADATA as e,
  DEFAULT_EIP155_METHODS as f,
  getAugmentedNamespace as g,
  DEFAULT_EIP_155_EVENTS as h,
  DEFAULT_COSMOS_METHODS as i,
  DEFAULT_COSMOS_EVENTS as j,
  DEFAULT_SOLANA_METHODS as k,
  DEFAULT_SOLANA_EVENTS as l,
  DEFAULT_POLKADOT_METHODS as m,
  DEFAULT_POLKADOT_EVENTS as n,
  DEFAULT_NEAR_METHODS as o,
  DEFAULT_NEAR_EVENTS as p,
  walletconnectWallet as w
};
