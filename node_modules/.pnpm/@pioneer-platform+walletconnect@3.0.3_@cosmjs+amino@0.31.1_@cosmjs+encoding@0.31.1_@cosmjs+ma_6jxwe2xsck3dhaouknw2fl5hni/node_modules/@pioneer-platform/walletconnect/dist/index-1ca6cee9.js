import vs, { EventEmitter as zt } from "events";
import { g as $o, c as _t, a as jc } from "./index-388a25bb.js";
import Bc from "crypto";
const qc = Symbol(), tn = Object.getPrototypeOf, Zi = /* @__PURE__ */ new WeakMap(), zc = (t) => t && (Zi.has(t) ? Zi.get(t) : tn(t) === Object.prototype || tn(t) === Array.prototype), Kc = (t) => zc(t) && t[qc] || null, rn = (t, e = !0) => {
  Zi.set(t, e);
}, Ui = (t) => typeof t == "object" && t !== null, kt = /* @__PURE__ */ new WeakMap(), ci = /* @__PURE__ */ new WeakSet(), Vc = (t = Object.is, e = (p, E) => new Proxy(p, E), r = (p) => Ui(p) && !ci.has(p) && (Array.isArray(p) || !(Symbol.iterator in p)) && !(p instanceof WeakMap) && !(p instanceof WeakSet) && !(p instanceof Error) && !(p instanceof Number) && !(p instanceof Date) && !(p instanceof String) && !(p instanceof RegExp) && !(p instanceof ArrayBuffer), i = (p) => p.configurable && p.enumerable && p.writable, s = (p) => {
  switch (p.status) {
    case "fulfilled":
      return p.value;
    case "rejected":
      throw p.reason;
    default:
      throw p;
  }
}, o = /* @__PURE__ */ new WeakMap(), u = (p, E, x = s) => {
  const v = o.get(p);
  if ((v == null ? void 0 : v[0]) === E)
    return v[1];
  const I = Array.isArray(p) ? [] : Object.create(Object.getPrototypeOf(p));
  return rn(I, !0), o.set(p, [E, I]), Reflect.ownKeys(p).forEach((N) => {
    if (Object.getOwnPropertyDescriptor(I, N))
      return;
    const R = Reflect.get(p, N), K = {
      value: R,
      enumerable: !0,
      // This is intentional to avoid copying with proxy-compare.
      // It's still non-writable, so it avoids assigning a value.
      configurable: !0
    };
    if (ci.has(R))
      rn(R, !1);
    else if (R instanceof Promise)
      delete K.value, K.get = () => x(R);
    else if (kt.has(R)) {
      const [m, O] = kt.get(
        R
      );
      K.value = u(
        m,
        O(),
        x
      );
    }
    Object.defineProperty(I, N, K);
  }), Object.preventExtensions(I);
}, c = /* @__PURE__ */ new WeakMap(), h = [1, 1], d = (p) => {
  if (!Ui(p))
    throw new Error("object required");
  const E = c.get(p);
  if (E)
    return E;
  let x = h[0];
  const v = /* @__PURE__ */ new Set(), I = (L, F = ++h[0]) => {
    x !== F && (x = F, v.forEach((z) => z(L, F)));
  };
  let N = h[1];
  const R = (L = ++h[1]) => (N !== L && !v.size && (N = L, m.forEach(([F]) => {
    const z = F[1](L);
    z > x && (x = z);
  })), x), K = (L) => (F, z) => {
    const b = [...F];
    b[1] = [L, ...b[1]], I(b, z);
  }, m = /* @__PURE__ */ new Map(), O = (L, F) => {
    if (v.size) {
      const z = F[3](K(L));
      m.set(L, [F, z]);
    } else
      m.set(L, [F]);
  }, y = (L) => {
    var F;
    const z = m.get(L);
    z && (m.delete(L), (F = z[1]) == null || F.call(z));
  }, _ = (L) => (v.add(L), v.size === 1 && m.forEach(([z, b], A) => {
    const k = z[3](K(A));
    m.set(A, [z, k]);
  }), () => {
    v.delete(L), v.size === 0 && m.forEach(([z, b], A) => {
      b && (b(), m.set(A, [z]));
    });
  }), f = Array.isArray(p) ? [] : Object.create(Object.getPrototypeOf(p)), n = (L, F, z, b, A) => {
    if (L && (t(F, b) || c.has(b) && t(F, c.get(b))))
      return;
    y(z), Ui(b) && (b = Kc(b) || b);
    let k = b;
    if (b instanceof Promise)
      b.then((B) => {
        b.status = "fulfilled", b.value = B, I(["resolve", [z], B]);
      }).catch((B) => {
        b.status = "rejected", b.reason = B, I(["reject", [z], B]);
      });
    else {
      !kt.has(b) && r(b) && (k = d(b));
      const B = !ci.has(k) && kt.get(k);
      B && O(z, B);
    }
    A(k), I(["set", [z], b, F]);
  }, P = e(f, {
    deleteProperty(L, F) {
      const z = Reflect.get(L, F);
      y(F);
      const b = Reflect.deleteProperty(L, F);
      return b && I(["delete", [F], z]), b;
    },
    set(L, F, z, b) {
      const A = Reflect.has(L, F), k = Reflect.get(L, F, b);
      return n(A, k, F, z, (B) => {
        Reflect.set(L, F, B, b);
      }), !0;
    },
    defineProperty(L, F, z) {
      if (i(z)) {
        const b = Reflect.getOwnPropertyDescriptor(L, F);
        if (!b || i(b))
          return n(
            !!b && "value" in b,
            b == null ? void 0 : b.value,
            F,
            z.value,
            (A) => {
              Reflect.defineProperty(L, F, {
                ...z,
                value: A
              });
            }
          ), !0;
      }
      return Reflect.defineProperty(L, F, z);
    }
  });
  c.set(p, P);
  const U = [
    f,
    R,
    u,
    _
  ];
  return kt.set(P, U), Reflect.ownKeys(p).forEach((L) => {
    const F = Object.getOwnPropertyDescriptor(
      p,
      L
    );
    "value" in F && (P[L] = p[L], delete F.value, delete F.writable), Object.defineProperty(f, L, F);
  }), P;
}) => [
  // public functions
  d,
  // shared state
  kt,
  ci,
  // internal things
  t,
  e,
  r,
  i,
  s,
  o,
  u,
  c,
  h
], [Hc] = Vc();
function Xt(t = {}) {
  return Hc(t);
}
function fr(t, e, r) {
  const i = kt.get(t);
  let s;
  const o = [], u = i[3];
  let c = !1;
  const d = u((p) => {
    if (o.push(p), r) {
      e(o.splice(0));
      return;
    }
    s || (s = Promise.resolve().then(() => {
      s = void 0, c && e(o.splice(0));
    }));
  });
  return c = !0, () => {
    c = !1, d();
  };
}
function Wc(t, e) {
  const r = kt.get(t), [i, s, o] = r;
  return o(i, s(), e);
}
const Xe = Xt({ history: ["ConnectWallet"], view: "ConnectWallet", data: void 0 }), jo = { state: Xe, subscribe(t) {
  return fr(Xe, () => t(Xe));
}, push(t, e) {
  t !== Xe.view && (Xe.view = t, e && (Xe.data = e), Xe.history.push(t));
}, reset(t) {
  Xe.view = t, Xe.history = [t];
}, replace(t) {
  Xe.history.length > 1 && (Xe.history[Xe.history.length - 1] = t, Xe.view = t);
}, goBack() {
  if (Xe.history.length > 1) {
    Xe.history.pop();
    const [t] = Xe.history.slice(-1);
    Xe.view = t;
  }
}, setData(t) {
  Xe.data = t;
} }, ut = { WALLETCONNECT_DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE", WCM_VERSION: "WCM_VERSION", RECOMMENDED_WALLET_AMOUNT: 9, isMobile() {
  return typeof window < "u" ? !!(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)) : !1;
}, isAndroid() {
  return ut.isMobile() && navigator.userAgent.toLowerCase().includes("android");
}, isIos() {
  const t = navigator.userAgent.toLowerCase();
  return ut.isMobile() && (t.includes("iphone") || t.includes("ipad"));
}, isHttpUrl(t) {
  return t.startsWith("http://") || t.startsWith("https://");
}, isArray(t) {
  return Array.isArray(t) && t.length > 0;
}, formatNativeUrl(t, e, r) {
  if (ut.isHttpUrl(t))
    return this.formatUniversalUrl(t, e, r);
  let i = t;
  i.includes("://") || (i = t.replaceAll("/", "").replaceAll(":", ""), i = `${i}://`), i.endsWith("/") || (i = `${i}/`), this.setWalletConnectDeepLink(i, r);
  const s = encodeURIComponent(e);
  return `${i}wc?uri=${s}`;
}, formatUniversalUrl(t, e, r) {
  if (!ut.isHttpUrl(t))
    return this.formatNativeUrl(t, e, r);
  let i = t;
  i.endsWith("/") || (i = `${i}/`), this.setWalletConnectDeepLink(i, r);
  const s = encodeURIComponent(e);
  return `${i}wc?uri=${s}`;
}, async wait(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}, openHref(t, e) {
  window.open(t, e, "noreferrer noopener");
}, setWalletConnectDeepLink(t, e) {
  try {
    localStorage.setItem(ut.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({ href: t, name: e }));
  } catch {
    console.info("Unable to set WalletConnect deep link");
  }
}, setWalletConnectAndroidDeepLink(t) {
  try {
    const [e] = t.split("?");
    localStorage.setItem(ut.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({ href: e, name: "Android" }));
  } catch {
    console.info("Unable to set WalletConnect android deep link");
  }
}, removeWalletConnectDeepLink() {
  try {
    localStorage.removeItem(ut.WALLETCONNECT_DEEPLINK_CHOICE);
  } catch {
    console.info("Unable to remove WalletConnect deep link");
  }
}, setModalVersionInStorage() {
  try {
    typeof localStorage < "u" && localStorage.setItem(ut.WCM_VERSION, "2.6.1");
  } catch {
    console.info("Unable to set Web3Modal version in storage");
  }
}, getWalletRouterData() {
  var t;
  const e = (t = jo.state.data) == null ? void 0 : t.Wallet;
  if (!e)
    throw new Error('Missing "Wallet" view data');
  return e;
} }, kc = typeof location < "u" && (location.hostname.includes("localhost") || location.protocol.includes("https")), nt = Xt({ enabled: kc, userSessionId: "", events: [], connectedWalletId: void 0 }), Gc = { state: nt, subscribe(t) {
  return fr(nt.events, () => t(Wc(nt.events[nt.events.length - 1])));
}, initialize() {
  nt.enabled && typeof (crypto == null ? void 0 : crypto.randomUUID) < "u" && (nt.userSessionId = crypto.randomUUID());
}, setConnectedWalletId(t) {
  nt.connectedWalletId = t;
}, click(t) {
  if (nt.enabled) {
    const e = { type: "CLICK", name: t.name, userSessionId: nt.userSessionId, timestamp: Date.now(), data: t };
    nt.events.push(e);
  }
}, track(t) {
  if (nt.enabled) {
    const e = { type: "TRACK", name: t.name, userSessionId: nt.userSessionId, timestamp: Date.now(), data: t };
    nt.events.push(e);
  }
}, view(t) {
  if (nt.enabled) {
    const e = { type: "VIEW", name: t.name, userSessionId: nt.userSessionId, timestamp: Date.now(), data: t };
    nt.events.push(e);
  }
} }, Rt = Xt({ chains: void 0, walletConnectUri: void 0, isAuth: !1, isCustomDesktop: !1, isCustomMobile: !1, isDataLoaded: !1, isUiLoaded: !1 }), Tt = { state: Rt, subscribe(t) {
  return fr(Rt, () => t(Rt));
}, setChains(t) {
  Rt.chains = t;
}, setWalletConnectUri(t) {
  Rt.walletConnectUri = t;
}, setIsCustomDesktop(t) {
  Rt.isCustomDesktop = t;
}, setIsCustomMobile(t) {
  Rt.isCustomMobile = t;
}, setIsDataLoaded(t) {
  Rt.isDataLoaded = t;
}, setIsUiLoaded(t) {
  Rt.isUiLoaded = t;
}, setIsAuth(t) {
  Rt.isAuth = t;
} }, ui = Xt({ projectId: "", mobileWallets: void 0, desktopWallets: void 0, walletImages: void 0, chains: void 0, enableAuthMode: !1, enableExplorer: !0, explorerExcludedWalletIds: void 0, explorerRecommendedWalletIds: void 0, termsOfServiceUrl: void 0, privacyPolicyUrl: void 0 }), Dr = { state: ui, subscribe(t) {
  return fr(ui, () => t(ui));
}, setConfig(t) {
  var e, r;
  Gc.initialize(), Tt.setChains(t.chains), Tt.setIsAuth(!!t.enableAuthMode), Tt.setIsCustomMobile(!!((e = t.mobileWallets) != null && e.length)), Tt.setIsCustomDesktop(!!((r = t.desktopWallets) != null && r.length)), ut.setModalVersionInStorage(), Object.assign(ui, t);
} };
var Yc = Object.defineProperty, sn = Object.getOwnPropertySymbols, Jc = Object.prototype.hasOwnProperty, Xc = Object.prototype.propertyIsEnumerable, nn = (t, e, r) => e in t ? Yc(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Qc = (t, e) => {
  for (var r in e || (e = {}))
    Jc.call(e, r) && nn(t, r, e[r]);
  if (sn)
    for (var r of sn(e))
      Xc.call(e, r) && nn(t, r, e[r]);
  return t;
};
const es = "https://explorer-api.walletconnect.com", ts = "wcm", rs = "js-2.6.1";
async function hi(t, e) {
  const r = Qc({ sdkType: ts, sdkVersion: rs }, e), i = new URL(t, es);
  return i.searchParams.append("projectId", Dr.state.projectId), Object.entries(r).forEach(([s, o]) => {
    o && i.searchParams.append(s, String(o));
  }), (await fetch(i)).json();
}
const ir = { async getDesktopListings(t) {
  return hi("/w3m/v1/getDesktopListings", t);
}, async getMobileListings(t) {
  return hi("/w3m/v1/getMobileListings", t);
}, async getInjectedListings(t) {
  return hi("/w3m/v1/getInjectedListings", t);
}, async getAllListings(t) {
  return hi("/w3m/v1/getAllListings", t);
}, getWalletImageUrl(t) {
  return `${es}/w3m/v1/getWalletImage/${t}?projectId=${Dr.state.projectId}&sdkType=${ts}&sdkVersion=${rs}`;
}, getAssetImageUrl(t) {
  return `${es}/w3m/v1/getAssetImage/${t}?projectId=${Dr.state.projectId}&sdkType=${ts}&sdkVersion=${rs}`;
} };
var Zc = Object.defineProperty, on = Object.getOwnPropertySymbols, eu = Object.prototype.hasOwnProperty, tu = Object.prototype.propertyIsEnumerable, an = (t, e, r) => e in t ? Zc(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, ru = (t, e) => {
  for (var r in e || (e = {}))
    eu.call(e, r) && an(t, r, e[r]);
  if (on)
    for (var r of on(e))
      tu.call(e, r) && an(t, r, e[r]);
  return t;
};
const cn = ut.isMobile(), Pt = Xt({ wallets: { listings: [], total: 0, page: 1 }, search: { listings: [], total: 0, page: 1 }, recomendedWallets: [] }), vy = { state: Pt, async getRecomendedWallets() {
  const { explorerRecommendedWalletIds: t, explorerExcludedWalletIds: e } = Dr.state;
  if (t === "NONE" || e === "ALL" && !t)
    return Pt.recomendedWallets;
  if (ut.isArray(t)) {
    const r = { recommendedIds: t.join(",") }, { listings: i } = await ir.getAllListings(r), s = Object.values(i);
    s.sort((o, u) => {
      const c = t.indexOf(o.id), h = t.indexOf(u.id);
      return c - h;
    }), Pt.recomendedWallets = s;
  } else {
    const { chains: r, isAuth: i } = Tt.state, s = r == null ? void 0 : r.join(","), o = ut.isArray(e), u = { page: 1, sdks: i ? "auth_v1" : void 0, entries: ut.RECOMMENDED_WALLET_AMOUNT, chains: s, version: 2, excludedIds: o ? e.join(",") : void 0 }, { listings: c } = cn ? await ir.getMobileListings(u) : await ir.getDesktopListings(u);
    Pt.recomendedWallets = Object.values(c);
  }
  return Pt.recomendedWallets;
}, async getWallets(t) {
  const e = ru({}, t), { explorerRecommendedWalletIds: r, explorerExcludedWalletIds: i } = Dr.state, { recomendedWallets: s } = Pt;
  if (i === "ALL")
    return Pt.wallets;
  s.length ? e.excludedIds = s.map((E) => E.id).join(",") : ut.isArray(r) && (e.excludedIds = r.join(",")), ut.isArray(i) && (e.excludedIds = [e.excludedIds, i].filter(Boolean).join(",")), Tt.state.isAuth && (e.sdks = "auth_v1");
  const { page: o, search: u } = t, { listings: c, total: h } = cn ? await ir.getMobileListings(e) : await ir.getDesktopListings(e), d = Object.values(c), p = u ? "search" : "wallets";
  return Pt[p] = { listings: [...Pt[p].listings, ...d], total: h, page: o ?? 1 }, { listings: d, total: h };
}, getWalletImageUrl(t) {
  return ir.getWalletImageUrl(t);
}, getAssetImageUrl(t) {
  return ir.getAssetImageUrl(t);
}, resetSearch() {
  Pt.search = { listings: [], total: 0, page: 1 };
} }, br = Xt({ open: !1 }), Li = { state: br, subscribe(t) {
  return fr(br, () => t(br));
}, async open(t) {
  return new Promise((e) => {
    const { isUiLoaded: r, isDataLoaded: i } = Tt.state;
    if (ut.removeWalletConnectDeepLink(), Tt.setWalletConnectUri(t == null ? void 0 : t.uri), Tt.setChains(t == null ? void 0 : t.chains), jo.reset("ConnectWallet"), r && i)
      br.open = !0, e();
    else {
      const s = setInterval(() => {
        const o = Tt.state;
        o.isUiLoaded && o.isDataLoaded && (clearInterval(s), br.open = !0, e());
      }, 200);
    }
  });
}, close() {
  br.open = !1;
} };
var iu = Object.defineProperty, un = Object.getOwnPropertySymbols, su = Object.prototype.hasOwnProperty, nu = Object.prototype.propertyIsEnumerable, hn = (t, e, r) => e in t ? iu(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, ou = (t, e) => {
  for (var r in e || (e = {}))
    su.call(e, r) && hn(t, r, e[r]);
  if (un)
    for (var r of un(e))
      nu.call(e, r) && hn(t, r, e[r]);
  return t;
};
function au() {
  return typeof matchMedia < "u" && matchMedia("(prefers-color-scheme: dark)").matches;
}
const Nr = Xt({ themeMode: au() ? "dark" : "light" }), ln = { state: Nr, subscribe(t) {
  return fr(Nr, () => t(Nr));
}, setThemeConfig(t) {
  const { themeMode: e, themeVariables: r } = t;
  e && (Nr.themeMode = e), r && (Nr.themeVariables = ou({}, r));
} }, sr = Xt({ open: !1, message: "", variant: "success" }), Ey = { state: sr, subscribe(t) {
  return fr(sr, () => t(sr));
}, openToast(t, e) {
  sr.open = !0, sr.message = t, sr.variant = e;
}, closeToast() {
  sr.open = !1;
} };
let cu = class {
  constructor(e) {
    this.openModal = Li.open, this.closeModal = Li.close, this.subscribeModal = Li.subscribe, this.setTheme = ln.setThemeConfig, ln.setThemeConfig(e), Dr.setConfig(e), this.initUi();
  }
  async initUi() {
    if (typeof window < "u") {
      await import("./index-a449efd6.js");
      const e = document.createElement("wcm-modal");
      document.body.insertAdjacentElement("beforeend", e), Tt.setIsUiLoaded(!0);
    }
  }
};
var Ei = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var is = function(t, e) {
  return is = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, i) {
    r.__proto__ = i;
  } || function(r, i) {
    for (var s in i)
      i.hasOwnProperty(s) && (r[s] = i[s]);
  }, is(t, e);
};
function uu(t, e) {
  is(t, e);
  function r() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
}
var ss = function() {
  return ss = Object.assign || function(e) {
    for (var r, i = 1, s = arguments.length; i < s; i++) {
      r = arguments[i];
      for (var o in r)
        Object.prototype.hasOwnProperty.call(r, o) && (e[o] = r[o]);
    }
    return e;
  }, ss.apply(this, arguments);
};
function hu(t, e) {
  var r = {};
  for (var i in t)
    Object.prototype.hasOwnProperty.call(t, i) && e.indexOf(i) < 0 && (r[i] = t[i]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var s = 0, i = Object.getOwnPropertySymbols(t); s < i.length; s++)
      e.indexOf(i[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, i[s]) && (r[i[s]] = t[i[s]]);
  return r;
}
function lu(t, e, r, i) {
  var s = arguments.length, o = s < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, r) : i, u;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    o = Reflect.decorate(t, e, r, i);
  else
    for (var c = t.length - 1; c >= 0; c--)
      (u = t[c]) && (o = (s < 3 ? u(o) : s > 3 ? u(e, r, o) : u(e, r)) || o);
  return s > 3 && o && Object.defineProperty(e, r, o), o;
}
function fu(t, e) {
  return function(r, i) {
    e(r, i, t);
  };
}
function du(t, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(t, e);
}
function pu(t, e, r, i) {
  function s(o) {
    return o instanceof r ? o : new r(function(u) {
      u(o);
    });
  }
  return new (r || (r = Promise))(function(o, u) {
    function c(p) {
      try {
        d(i.next(p));
      } catch (E) {
        u(E);
      }
    }
    function h(p) {
      try {
        d(i.throw(p));
      } catch (E) {
        u(E);
      }
    }
    function d(p) {
      p.done ? o(p.value) : s(p.value).then(c, h);
    }
    d((i = i.apply(t, e || [])).next());
  });
}
function gu(t, e) {
  var r = { label: 0, sent: function() {
    if (o[0] & 1)
      throw o[1];
    return o[1];
  }, trys: [], ops: [] }, i, s, o, u;
  return u = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
    return this;
  }), u;
  function c(d) {
    return function(p) {
      return h([d, p]);
    };
  }
  function h(d) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; r; )
      try {
        if (i = 1, s && (o = d[0] & 2 ? s.return : d[0] ? s.throw || ((o = s.return) && o.call(s), 0) : s.next) && !(o = o.call(s, d[1])).done)
          return o;
        switch (s = 0, o && (d = [d[0] & 2, o.value]), d[0]) {
          case 0:
          case 1:
            o = d;
            break;
          case 4:
            return r.label++, { value: d[1], done: !1 };
          case 5:
            r.label++, s = d[1], d = [0];
            continue;
          case 7:
            d = r.ops.pop(), r.trys.pop();
            continue;
          default:
            if (o = r.trys, !(o = o.length > 0 && o[o.length - 1]) && (d[0] === 6 || d[0] === 2)) {
              r = 0;
              continue;
            }
            if (d[0] === 3 && (!o || d[1] > o[0] && d[1] < o[3])) {
              r.label = d[1];
              break;
            }
            if (d[0] === 6 && r.label < o[1]) {
              r.label = o[1], o = d;
              break;
            }
            if (o && r.label < o[2]) {
              r.label = o[2], r.ops.push(d);
              break;
            }
            o[2] && r.ops.pop(), r.trys.pop();
            continue;
        }
        d = e.call(t, r);
      } catch (p) {
        d = [6, p], s = 0;
      } finally {
        i = o = 0;
      }
    if (d[0] & 5)
      throw d[1];
    return { value: d[0] ? d[1] : void 0, done: !0 };
  }
}
function yu(t, e, r, i) {
  i === void 0 && (i = r), t[i] = e[r];
}
function bu(t, e) {
  for (var r in t)
    r !== "default" && !e.hasOwnProperty(r) && (e[r] = t[r]);
}
function ns(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], i = 0;
  if (r)
    return r.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && i >= t.length && (t = void 0), { value: t && t[i++], done: !t };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Bo(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r)
    return t;
  var i = r.call(t), s, o = [], u;
  try {
    for (; (e === void 0 || e-- > 0) && !(s = i.next()).done; )
      o.push(s.value);
  } catch (c) {
    u = { error: c };
  } finally {
    try {
      s && !s.done && (r = i.return) && r.call(i);
    } finally {
      if (u)
        throw u.error;
    }
  }
  return o;
}
function wu() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t = t.concat(Bo(arguments[e]));
  return t;
}
function _u() {
  for (var t = 0, e = 0, r = arguments.length; e < r; e++)
    t += arguments[e].length;
  for (var i = Array(t), s = 0, e = 0; e < r; e++)
    for (var o = arguments[e], u = 0, c = o.length; u < c; u++, s++)
      i[s] = o[u];
  return i;
}
function kr(t) {
  return this instanceof kr ? (this.v = t, this) : new kr(t);
}
function mu(t, e, r) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var i = r.apply(t, e || []), s, o = [];
  return s = {}, u("next"), u("throw"), u("return"), s[Symbol.asyncIterator] = function() {
    return this;
  }, s;
  function u(x) {
    i[x] && (s[x] = function(v) {
      return new Promise(function(I, N) {
        o.push([x, v, I, N]) > 1 || c(x, v);
      });
    });
  }
  function c(x, v) {
    try {
      h(i[x](v));
    } catch (I) {
      E(o[0][3], I);
    }
  }
  function h(x) {
    x.value instanceof kr ? Promise.resolve(x.value.v).then(d, p) : E(o[0][2], x);
  }
  function d(x) {
    c("next", x);
  }
  function p(x) {
    c("throw", x);
  }
  function E(x, v) {
    x(v), o.shift(), o.length && c(o[0][0], o[0][1]);
  }
}
function vu(t) {
  var e, r;
  return e = {}, i("next"), i("throw", function(s) {
    throw s;
  }), i("return"), e[Symbol.iterator] = function() {
    return this;
  }, e;
  function i(s, o) {
    e[s] = t[s] ? function(u) {
      return (r = !r) ? { value: kr(t[s](u)), done: s === "return" } : o ? o(u) : u;
    } : o;
  }
}
function Eu(t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], r;
  return e ? e.call(t) : (t = typeof ns == "function" ? ns(t) : t[Symbol.iterator](), r = {}, i("next"), i("throw"), i("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r);
  function i(o) {
    r[o] = t[o] && function(u) {
      return new Promise(function(c, h) {
        u = t[o](u), s(c, h, u.done, u.value);
      });
    };
  }
  function s(o, u, c, h) {
    Promise.resolve(h).then(function(d) {
      o({ value: d, done: c });
    }, u);
  }
}
function Du(t, e) {
  return Object.defineProperty ? Object.defineProperty(t, "raw", { value: e }) : t.raw = e, t;
}
function Su(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var r in t)
      Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
  return e.default = t, e;
}
function Iu(t) {
  return t && t.__esModule ? t : { default: t };
}
function xu(t, e) {
  if (!e.has(t))
    throw new TypeError("attempted to get private field on non-instance");
  return e.get(t);
}
function Ou(t, e, r) {
  if (!e.has(t))
    throw new TypeError("attempted to set private field on non-instance");
  return e.set(t, r), r;
}
const Au = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return ss;
  },
  __asyncDelegator: vu,
  __asyncGenerator: mu,
  __asyncValues: Eu,
  __await: kr,
  __awaiter: pu,
  __classPrivateFieldGet: xu,
  __classPrivateFieldSet: Ou,
  __createBinding: yu,
  __decorate: lu,
  __exportStar: bu,
  __extends: uu,
  __generator: gu,
  __importDefault: Iu,
  __importStar: Su,
  __makeTemplateObject: Du,
  __metadata: du,
  __param: fu,
  __read: Bo,
  __rest: hu,
  __spread: wu,
  __spreadArrays: _u,
  __values: ns
}, Symbol.toStringTag, { value: "Module" })), It = /* @__PURE__ */ $o(Au);
var Yr = {};
Object.defineProperty(Yr, "__esModule", { value: !0 });
function Cu(t) {
  if (typeof t != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof t}`);
  try {
    return JSON.parse(t);
  } catch {
    return t;
  }
}
Yr.safeJsonParse = Cu;
function Tu(t) {
  return typeof t == "string" ? t : JSON.stringify(t, (e, r) => typeof r > "u" ? null : r);
}
Yr.safeJsonStringify = Tu;
var Rr = { exports: {} }, fn;
function Nu() {
  return fn || (fn = 1, function() {
    let t;
    function e() {
    }
    t = e, t.prototype.getItem = function(r) {
      return this.hasOwnProperty(r) ? String(this[r]) : null;
    }, t.prototype.setItem = function(r, i) {
      this[r] = String(i);
    }, t.prototype.removeItem = function(r) {
      delete this[r];
    }, t.prototype.clear = function() {
      const r = this;
      Object.keys(r).forEach(function(i) {
        r[i] = void 0, delete r[i];
      });
    }, t.prototype.key = function(r) {
      return r = r || 0, Object.keys(this)[r];
    }, t.prototype.__defineGetter__("length", function() {
      return Object.keys(this).length;
    }), typeof _t < "u" && _t.localStorage ? Rr.exports = _t.localStorage : typeof window < "u" && window.localStorage ? Rr.exports = window.localStorage : Rr.exports = new e();
  }()), Rr.exports;
}
var Fi = {}, Pr = {}, dn;
function Ru() {
  if (dn)
    return Pr;
  dn = 1, Object.defineProperty(Pr, "__esModule", { value: !0 }), Pr.IKeyValueStorage = void 0;
  class t {
  }
  return Pr.IKeyValueStorage = t, Pr;
}
var Ur = {}, pn;
function Pu() {
  if (pn)
    return Ur;
  pn = 1, Object.defineProperty(Ur, "__esModule", { value: !0 }), Ur.parseEntry = void 0;
  const t = Yr;
  function e(r) {
    var i;
    return [r[0], t.safeJsonParse((i = r[1]) !== null && i !== void 0 ? i : "")];
  }
  return Ur.parseEntry = e, Ur;
}
var gn;
function Uu() {
  return gn || (gn = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const e = It;
    e.__exportStar(Ru(), t), e.__exportStar(Pu(), t);
  }(Fi)), Fi;
}
Object.defineProperty(Ei, "__esModule", { value: !0 });
Ei.KeyValueStorage = void 0;
const _r = It, yn = Yr, Lu = _r.__importDefault(Nu()), Fu = Uu();
class qo {
  constructor() {
    this.localStorage = Lu.default;
  }
  getKeys() {
    return _r.__awaiter(this, void 0, void 0, function* () {
      return Object.keys(this.localStorage);
    });
  }
  getEntries() {
    return _r.__awaiter(this, void 0, void 0, function* () {
      return Object.entries(this.localStorage).map(Fu.parseEntry);
    });
  }
  getItem(e) {
    return _r.__awaiter(this, void 0, void 0, function* () {
      const r = this.localStorage.getItem(e);
      if (r !== null)
        return yn.safeJsonParse(r);
    });
  }
  setItem(e, r) {
    return _r.__awaiter(this, void 0, void 0, function* () {
      this.localStorage.setItem(e, yn.safeJsonStringify(r));
    });
  }
  removeItem(e) {
    return _r.__awaiter(this, void 0, void 0, function* () {
      this.localStorage.removeItem(e);
    });
  }
}
Ei.KeyValueStorage = qo;
var Mu = Ei.default = qo, Sr = {}, Lr = {}, Q = {}, Mi = {}, Fr = {}, bn;
function $u() {
  if (bn)
    return Fr;
  bn = 1, Object.defineProperty(Fr, "__esModule", { value: !0 }), Fr.delay = void 0;
  function t(e) {
    return new Promise((r) => {
      setTimeout(() => {
        r(!0);
      }, e);
    });
  }
  return Fr.delay = t, Fr;
}
var nr = {}, $i = {}, or = {}, wn;
function ju() {
  return wn || (wn = 1, Object.defineProperty(or, "__esModule", { value: !0 }), or.ONE_THOUSAND = or.ONE_HUNDRED = void 0, or.ONE_HUNDRED = 100, or.ONE_THOUSAND = 1e3), or;
}
var ji = {}, _n;
function Bu() {
  return _n || (_n = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ONE_YEAR = t.FOUR_WEEKS = t.THREE_WEEKS = t.TWO_WEEKS = t.ONE_WEEK = t.THIRTY_DAYS = t.SEVEN_DAYS = t.FIVE_DAYS = t.THREE_DAYS = t.ONE_DAY = t.TWENTY_FOUR_HOURS = t.TWELVE_HOURS = t.SIX_HOURS = t.THREE_HOURS = t.ONE_HOUR = t.SIXTY_MINUTES = t.THIRTY_MINUTES = t.TEN_MINUTES = t.FIVE_MINUTES = t.ONE_MINUTE = t.SIXTY_SECONDS = t.THIRTY_SECONDS = t.TEN_SECONDS = t.FIVE_SECONDS = t.ONE_SECOND = void 0, t.ONE_SECOND = 1, t.FIVE_SECONDS = 5, t.TEN_SECONDS = 10, t.THIRTY_SECONDS = 30, t.SIXTY_SECONDS = 60, t.ONE_MINUTE = t.SIXTY_SECONDS, t.FIVE_MINUTES = t.ONE_MINUTE * 5, t.TEN_MINUTES = t.ONE_MINUTE * 10, t.THIRTY_MINUTES = t.ONE_MINUTE * 30, t.SIXTY_MINUTES = t.ONE_MINUTE * 60, t.ONE_HOUR = t.SIXTY_MINUTES, t.THREE_HOURS = t.ONE_HOUR * 3, t.SIX_HOURS = t.ONE_HOUR * 6, t.TWELVE_HOURS = t.ONE_HOUR * 12, t.TWENTY_FOUR_HOURS = t.ONE_HOUR * 24, t.ONE_DAY = t.TWENTY_FOUR_HOURS, t.THREE_DAYS = t.ONE_DAY * 3, t.FIVE_DAYS = t.ONE_DAY * 5, t.SEVEN_DAYS = t.ONE_DAY * 7, t.THIRTY_DAYS = t.ONE_DAY * 30, t.ONE_WEEK = t.SEVEN_DAYS, t.TWO_WEEKS = t.ONE_WEEK * 2, t.THREE_WEEKS = t.ONE_WEEK * 3, t.FOUR_WEEKS = t.ONE_WEEK * 4, t.ONE_YEAR = t.ONE_DAY * 365;
  }(ji)), ji;
}
var mn;
function zo() {
  return mn || (mn = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const e = It;
    e.__exportStar(ju(), t), e.__exportStar(Bu(), t);
  }($i)), $i;
}
var vn;
function qu() {
  if (vn)
    return nr;
  vn = 1, Object.defineProperty(nr, "__esModule", { value: !0 }), nr.fromMiliseconds = nr.toMiliseconds = void 0;
  const t = zo();
  function e(i) {
    return i * t.ONE_THOUSAND;
  }
  nr.toMiliseconds = e;
  function r(i) {
    return Math.floor(i / t.ONE_THOUSAND);
  }
  return nr.fromMiliseconds = r, nr;
}
var En;
function zu() {
  return En || (En = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const e = It;
    e.__exportStar($u(), t), e.__exportStar(qu(), t);
  }(Mi)), Mi;
}
var wr = {}, Dn;
function Ku() {
  if (Dn)
    return wr;
  Dn = 1, Object.defineProperty(wr, "__esModule", { value: !0 }), wr.Watch = void 0;
  class t {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(r) {
      if (this.timestamps.has(r))
        throw new Error(`Watch already started for label: ${r}`);
      this.timestamps.set(r, { started: Date.now() });
    }
    stop(r) {
      const i = this.get(r);
      if (typeof i.elapsed < "u")
        throw new Error(`Watch already stopped for label: ${r}`);
      const s = Date.now() - i.started;
      this.timestamps.set(r, { started: i.started, elapsed: s });
    }
    get(r) {
      const i = this.timestamps.get(r);
      if (typeof i > "u")
        throw new Error(`No timestamp found for label: ${r}`);
      return i;
    }
    elapsed(r) {
      const i = this.get(r);
      return i.elapsed || Date.now() - i.started;
    }
  }
  return wr.Watch = t, wr.default = t, wr;
}
var Bi = {}, Mr = {}, Sn;
function Vu() {
  if (Sn)
    return Mr;
  Sn = 1, Object.defineProperty(Mr, "__esModule", { value: !0 }), Mr.IWatch = void 0;
  class t {
  }
  return Mr.IWatch = t, Mr;
}
var In;
function Hu() {
  return In || (In = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), It.__exportStar(Vu(), t);
  }(Bi)), Bi;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = It;
  e.__exportStar(zu(), t), e.__exportStar(Ku(), t), e.__exportStar(Hu(), t), e.__exportStar(zo(), t);
})(Q);
var qi = {}, $r = {};
let dr = class {
};
const Wu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  IEvents: dr
}, Symbol.toStringTag, { value: "Module" })), ku = /* @__PURE__ */ $o(Wu);
var xn;
function Gu() {
  if (xn)
    return $r;
  xn = 1, Object.defineProperty($r, "__esModule", { value: !0 }), $r.IHeartBeat = void 0;
  const t = ku;
  class e extends t.IEvents {
    constructor(i) {
      super();
    }
  }
  return $r.IHeartBeat = e, $r;
}
var On;
function Ko() {
  return On || (On = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), It.__exportStar(Gu(), t);
  }(qi)), qi;
}
var zi = {}, ar = {}, An;
function Yu() {
  if (An)
    return ar;
  An = 1, Object.defineProperty(ar, "__esModule", { value: !0 }), ar.HEARTBEAT_EVENTS = ar.HEARTBEAT_INTERVAL = void 0;
  const t = Q;
  return ar.HEARTBEAT_INTERVAL = t.FIVE_SECONDS, ar.HEARTBEAT_EVENTS = {
    pulse: "heartbeat_pulse"
  }, ar;
}
var Cn;
function Vo() {
  return Cn || (Cn = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), It.__exportStar(Yu(), t);
  }(zi)), zi;
}
var Tn;
function Ju() {
  if (Tn)
    return Lr;
  Tn = 1, Object.defineProperty(Lr, "__esModule", { value: !0 }), Lr.HeartBeat = void 0;
  const t = It, e = vs, r = Q, i = Ko(), s = Vo();
  class o extends i.IHeartBeat {
    constructor(c) {
      super(c), this.events = new e.EventEmitter(), this.interval = s.HEARTBEAT_INTERVAL, this.interval = (c == null ? void 0 : c.interval) || s.HEARTBEAT_INTERVAL;
    }
    static init(c) {
      return t.__awaiter(this, void 0, void 0, function* () {
        const h = new o(c);
        return yield h.init(), h;
      });
    }
    init() {
      return t.__awaiter(this, void 0, void 0, function* () {
        yield this.initialize();
      });
    }
    stop() {
      clearInterval(this.intervalRef);
    }
    on(c, h) {
      this.events.on(c, h);
    }
    once(c, h) {
      this.events.once(c, h);
    }
    off(c, h) {
      this.events.off(c, h);
    }
    removeListener(c, h) {
      this.events.removeListener(c, h);
    }
    initialize() {
      return t.__awaiter(this, void 0, void 0, function* () {
        this.intervalRef = setInterval(() => this.pulse(), r.toMiliseconds(this.interval));
      });
    }
    pulse() {
      this.events.emit(s.HEARTBEAT_EVENTS.pulse);
    }
  }
  return Lr.HeartBeat = o, Lr;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = It;
  e.__exportStar(Ju(), t), e.__exportStar(Ko(), t), e.__exportStar(Vo(), t);
})(Sr);
var _e = {}, Ki, Nn;
function Xu() {
  if (Nn)
    return Ki;
  Nn = 1;
  function t(r) {
    try {
      return JSON.stringify(r);
    } catch {
      return '"[Circular]"';
    }
  }
  Ki = e;
  function e(r, i, s) {
    var o = s && s.stringify || t, u = 1;
    if (typeof r == "object" && r !== null) {
      var c = i.length + u;
      if (c === 1)
        return r;
      var h = new Array(c);
      h[0] = o(r);
      for (var d = 1; d < c; d++)
        h[d] = o(i[d]);
      return h.join(" ");
    }
    if (typeof r != "string")
      return r;
    var p = i.length;
    if (p === 0)
      return r;
    for (var E = "", x = 1 - u, v = -1, I = r && r.length || 0, N = 0; N < I; ) {
      if (r.charCodeAt(N) === 37 && N + 1 < I) {
        switch (v = v > -1 ? v : 0, r.charCodeAt(N + 1)) {
          case 100:
          case 102:
            if (x >= p || i[x] == null)
              break;
            v < N && (E += r.slice(v, N)), E += Number(i[x]), v = N + 2, N++;
            break;
          case 105:
            if (x >= p || i[x] == null)
              break;
            v < N && (E += r.slice(v, N)), E += Math.floor(Number(i[x])), v = N + 2, N++;
            break;
          case 79:
          case 111:
          case 106:
            if (x >= p || i[x] === void 0)
              break;
            v < N && (E += r.slice(v, N));
            var R = typeof i[x];
            if (R === "string") {
              E += "'" + i[x] + "'", v = N + 2, N++;
              break;
            }
            if (R === "function") {
              E += i[x].name || "<anonymous>", v = N + 2, N++;
              break;
            }
            E += o(i[x]), v = N + 2, N++;
            break;
          case 115:
            if (x >= p)
              break;
            v < N && (E += r.slice(v, N)), E += String(i[x]), v = N + 2, N++;
            break;
          case 37:
            v < N && (E += r.slice(v, N)), E += "%", v = N + 2, N++, x--;
            break;
        }
        ++x;
      }
      ++N;
    }
    return v === -1 ? r : (v < I && (E += r.slice(v)), E);
  }
  return Ki;
}
var Vi, Rn;
function Qu() {
  if (Rn)
    return Vi;
  Rn = 1;
  const t = Xu();
  Vi = s;
  const e = _().console || {}, r = {
    mapHttpRequest: I,
    mapHttpResponse: I,
    wrapRequestSerializer: N,
    wrapResponseSerializer: N,
    wrapErrorSerializer: N,
    req: I,
    res: I,
    err: x
  };
  function i(f, n) {
    return Array.isArray(f) ? f.filter(function(P) {
      return P !== "!stdSerializers.err";
    }) : f === !0 ? Object.keys(n) : !1;
  }
  function s(f) {
    f = f || {}, f.browser = f.browser || {};
    const n = f.browser.transmit;
    if (n && typeof n.send != "function")
      throw Error("pino: transmit option must have a send function");
    const l = f.browser.write || e;
    f.browser.write && (f.browser.asObject = !0);
    const P = f.serializers || {}, U = i(f.browser.serialize, P);
    let L = f.browser.serialize;
    Array.isArray(f.browser.serialize) && f.browser.serialize.indexOf("!stdSerializers.err") > -1 && (L = !1);
    const F = ["error", "fatal", "warn", "info", "debug", "trace"];
    typeof l == "function" && (l.error = l.fatal = l.warn = l.info = l.debug = l.trace = l), f.enabled === !1 && (f.level = "silent");
    const z = f.level || "info", b = Object.create(l);
    b.log || (b.log = R), Object.defineProperty(b, "levelVal", {
      get: k
    }), Object.defineProperty(b, "level", {
      get: B,
      set: $
    });
    const A = {
      transmit: n,
      serialize: U,
      asObject: f.browser.asObject,
      levels: F,
      timestamp: v(f)
    };
    b.levels = s.levels, b.level = z, b.setMaxListeners = b.getMaxListeners = b.emit = b.addListener = b.on = b.prependListener = b.once = b.prependOnceListener = b.removeListener = b.removeAllListeners = b.listeners = b.listenerCount = b.eventNames = b.write = b.flush = R, b.serializers = P, b._serialize = U, b._stdErrSerialize = L, b.child = q, n && (b._logEvent = E());
    function k() {
      return this.level === "silent" ? 1 / 0 : this.levels.values[this.level];
    }
    function B() {
      return this._level;
    }
    function $(M) {
      if (M !== "silent" && !this.levels.values[M])
        throw Error("unknown level " + M);
      this._level = M, o(A, b, "error", "log"), o(A, b, "fatal", "error"), o(A, b, "warn", "error"), o(A, b, "info", "log"), o(A, b, "debug", "log"), o(A, b, "trace", "log");
    }
    function q(M, V) {
      if (!M)
        throw new Error("missing bindings for child Pino");
      V = V || {}, U && M.serializers && (V.serializers = M.serializers);
      const te = V.serializers;
      if (U && te) {
        var H = Object.assign({}, P, te), Z = f.browser.serialize === !0 ? Object.keys(H) : U;
        delete M.serializers, h([M], Z, H, this._stdErrSerialize);
      }
      function J(ee) {
        this._childLevel = (ee._childLevel | 0) + 1, this.error = d(ee, M, "error"), this.fatal = d(ee, M, "fatal"), this.warn = d(ee, M, "warn"), this.info = d(ee, M, "info"), this.debug = d(ee, M, "debug"), this.trace = d(ee, M, "trace"), H && (this.serializers = H, this._serialize = Z), n && (this._logEvent = E(
          [].concat(ee._logEvent.bindings, M)
        ));
      }
      return J.prototype = this, new J(this);
    }
    return b;
  }
  s.levels = {
    values: {
      fatal: 60,
      error: 50,
      warn: 40,
      info: 30,
      debug: 20,
      trace: 10
    },
    labels: {
      10: "trace",
      20: "debug",
      30: "info",
      40: "warn",
      50: "error",
      60: "fatal"
    }
  }, s.stdSerializers = r, s.stdTimeFunctions = Object.assign({}, { nullTime: K, epochTime: m, unixTime: O, isoTime: y });
  function o(f, n, l, P) {
    const U = Object.getPrototypeOf(n);
    n[l] = n.levelVal > n.levels.values[l] ? R : U[l] ? U[l] : e[l] || e[P] || R, u(f, n, l);
  }
  function u(f, n, l) {
    !f.transmit && n[l] === R || (n[l] = function(P) {
      return function() {
        const L = f.timestamp(), F = new Array(arguments.length), z = Object.getPrototypeOf && Object.getPrototypeOf(this) === e ? e : this;
        for (var b = 0; b < F.length; b++)
          F[b] = arguments[b];
        if (f.serialize && !f.asObject && h(F, this._serialize, this.serializers, this._stdErrSerialize), f.asObject ? P.call(z, c(this, l, F, L)) : P.apply(z, F), f.transmit) {
          const A = f.transmit.level || n.level, k = s.levels.values[A], B = s.levels.values[l];
          if (B < k)
            return;
          p(this, {
            ts: L,
            methodLevel: l,
            methodValue: B,
            transmitLevel: A,
            transmitValue: s.levels.values[f.transmit.level || n.level],
            send: f.transmit.send,
            val: n.levelVal
          }, F);
        }
      };
    }(n[l]));
  }
  function c(f, n, l, P) {
    f._serialize && h(l, f._serialize, f.serializers, f._stdErrSerialize);
    const U = l.slice();
    let L = U[0];
    const F = {};
    P && (F.time = P), F.level = s.levels.values[n];
    let z = (f._childLevel | 0) + 1;
    if (z < 1 && (z = 1), L !== null && typeof L == "object") {
      for (; z-- && typeof U[0] == "object"; )
        Object.assign(F, U.shift());
      L = U.length ? t(U.shift(), U) : void 0;
    } else
      typeof L == "string" && (L = t(U.shift(), U));
    return L !== void 0 && (F.msg = L), F;
  }
  function h(f, n, l, P) {
    for (const U in f)
      if (P && f[U] instanceof Error)
        f[U] = s.stdSerializers.err(f[U]);
      else if (typeof f[U] == "object" && !Array.isArray(f[U]))
        for (const L in f[U])
          n && n.indexOf(L) > -1 && L in l && (f[U][L] = l[L](f[U][L]));
  }
  function d(f, n, l) {
    return function() {
      const P = new Array(1 + arguments.length);
      P[0] = n;
      for (var U = 1; U < P.length; U++)
        P[U] = arguments[U - 1];
      return f[l].apply(this, P);
    };
  }
  function p(f, n, l) {
    const P = n.send, U = n.ts, L = n.methodLevel, F = n.methodValue, z = n.val, b = f._logEvent.bindings;
    h(
      l,
      f._serialize || Object.keys(f.serializers),
      f.serializers,
      f._stdErrSerialize === void 0 ? !0 : f._stdErrSerialize
    ), f._logEvent.ts = U, f._logEvent.messages = l.filter(function(A) {
      return b.indexOf(A) === -1;
    }), f._logEvent.level.label = L, f._logEvent.level.value = F, P(L, f._logEvent, z), f._logEvent = E(b);
  }
  function E(f) {
    return {
      ts: 0,
      messages: [],
      bindings: f || [],
      level: { label: "", value: 0 }
    };
  }
  function x(f) {
    const n = {
      type: f.constructor.name,
      msg: f.message,
      stack: f.stack
    };
    for (const l in f)
      n[l] === void 0 && (n[l] = f[l]);
    return n;
  }
  function v(f) {
    return typeof f.timestamp == "function" ? f.timestamp : f.timestamp === !1 ? K : m;
  }
  function I() {
    return {};
  }
  function N(f) {
    return f;
  }
  function R() {
  }
  function K() {
    return !1;
  }
  function m() {
    return Date.now();
  }
  function O() {
    return Math.round(Date.now() / 1e3);
  }
  function y() {
    return new Date(Date.now()).toISOString();
  }
  function _() {
    function f(n) {
      return typeof n < "u" && n;
    }
    try {
      return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
        get: function() {
          return delete Object.prototype.globalThis, this.globalThis = this;
        },
        configurable: !0
      }), globalThis;
    } catch {
      return f(self) || f(window) || f(this) || {};
    }
  }
  return Vi;
}
var cr = {}, Pn;
function Ho() {
  return Pn || (Pn = 1, Object.defineProperty(cr, "__esModule", { value: !0 }), cr.PINO_CUSTOM_CONTEXT_KEY = cr.PINO_LOGGER_DEFAULTS = void 0, cr.PINO_LOGGER_DEFAULTS = {
    level: "info"
  }, cr.PINO_CUSTOM_CONTEXT_KEY = "custom_context"), cr;
}
var ht = {}, Un;
function Zu() {
  if (Un)
    return ht;
  Un = 1, Object.defineProperty(ht, "__esModule", { value: !0 }), ht.generateChildLogger = ht.formatChildLoggerContext = ht.getLoggerContext = ht.setBrowserLoggerContext = ht.getBrowserLoggerContext = ht.getDefaultLoggerOptions = void 0;
  const t = Ho();
  function e(c) {
    return Object.assign(Object.assign({}, c), { level: (c == null ? void 0 : c.level) || t.PINO_LOGGER_DEFAULTS.level });
  }
  ht.getDefaultLoggerOptions = e;
  function r(c, h = t.PINO_CUSTOM_CONTEXT_KEY) {
    return c[h] || "";
  }
  ht.getBrowserLoggerContext = r;
  function i(c, h, d = t.PINO_CUSTOM_CONTEXT_KEY) {
    return c[d] = h, c;
  }
  ht.setBrowserLoggerContext = i;
  function s(c, h = t.PINO_CUSTOM_CONTEXT_KEY) {
    let d = "";
    return typeof c.bindings > "u" ? d = r(c, h) : d = c.bindings().context || "", d;
  }
  ht.getLoggerContext = s;
  function o(c, h, d = t.PINO_CUSTOM_CONTEXT_KEY) {
    const p = s(c, d);
    return p.trim() ? `${p}/${h}` : h;
  }
  ht.formatChildLoggerContext = o;
  function u(c, h, d = t.PINO_CUSTOM_CONTEXT_KEY) {
    const p = o(c, h, d), E = c.child({ context: p });
    return i(E, p, d);
  }
  return ht.generateChildLogger = u, ht;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.pino = void 0;
  const e = It, r = e.__importDefault(Qu());
  Object.defineProperty(t, "pino", { enumerable: !0, get: function() {
    return r.default;
  } }), e.__exportStar(Ho(), t), e.__exportStar(Zu(), t);
})(_e);
let eh = class extends dr {
  constructor(e) {
    super(), this.opts = e, this.protocol = "wc", this.version = 2;
  }
}, th = class extends dr {
  constructor(e, r) {
    super(), this.core = e, this.logger = r, this.records = /* @__PURE__ */ new Map();
  }
}, rh = class {
  constructor(e, r) {
    this.logger = e, this.core = r;
  }
}, ih = class extends dr {
  constructor(e, r) {
    super(), this.relayer = e, this.logger = r;
  }
}, sh = class extends dr {
  constructor(e) {
    super();
  }
}, nh = class {
  constructor(e, r, i, s) {
    this.core = e, this.logger = r, this.name = i;
  }
};
class oh extends dr {
  constructor(e, r) {
    super(), this.relayer = e, this.logger = r;
  }
}
class ah extends dr {
  constructor(e, r) {
    super(), this.core = e, this.logger = r;
  }
}
let ch = class {
  constructor(e, r) {
    this.projectId = e, this.logger = r;
  }
}, uh = class {
  constructor(e) {
    this.opts = e, this.protocol = "wc", this.version = 2;
  }
}, hh = class {
  constructor(e) {
    this.client = e;
  }
};
const lh = (t) => JSON.stringify(t, (e, r) => typeof r == "bigint" ? r.toString() + "n" : r), fh = (t) => {
  const e = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, r = t.replace(e, '$1"$2n"$3');
  return JSON.parse(r, (i, s) => typeof s == "string" && s.match(/^\d+n$/) ? BigInt(s.substring(0, s.length - 1)) : s);
};
function Wo(t) {
  if (typeof t != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof t}`);
  try {
    return fh(t);
  } catch {
    return t;
  }
}
function Es(t) {
  return typeof t == "string" ? t : lh(t) || "";
}
var Ds = {}, Ir = {}, Di = {}, Si = {};
Object.defineProperty(Si, "__esModule", { value: !0 });
Si.BrowserRandomSource = void 0;
const Ln = 65536;
class dh {
  constructor() {
    this.isAvailable = !1, this.isInstantiated = !1;
    const e = typeof self < "u" ? self.crypto || self.msCrypto : null;
    e && e.getRandomValues !== void 0 && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Browser random byte generator is not available.");
    const r = new Uint8Array(e);
    for (let i = 0; i < r.length; i += Ln)
      this._crypto.getRandomValues(r.subarray(i, i + Math.min(r.length - i, Ln)));
    return r;
  }
}
Si.BrowserRandomSource = dh;
function ph(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Ii = {}, mt = {};
Object.defineProperty(mt, "__esModule", { value: !0 });
function gh(t) {
  for (var e = 0; e < t.length; e++)
    t[e] = 0;
  return t;
}
mt.wipe = gh;
Object.defineProperty(Ii, "__esModule", { value: !0 });
Ii.NodeRandomSource = void 0;
const yh = mt;
class bh {
  constructor() {
    if (this.isAvailable = !1, this.isInstantiated = !1, typeof ph < "u") {
      const e = Bc;
      e && e.randomBytes && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);
    }
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Node.js random byte generator is not available.");
    let r = this._crypto.randomBytes(e);
    if (r.length !== e)
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    const i = new Uint8Array(e);
    for (let s = 0; s < i.length; s++)
      i[s] = r[s];
    return (0, yh.wipe)(r), i;
  }
}
Ii.NodeRandomSource = bh;
Object.defineProperty(Di, "__esModule", { value: !0 });
Di.SystemRandomSource = void 0;
const wh = Si, _h = Ii;
class mh {
  constructor() {
    if (this.isAvailable = !1, this.name = "", this._source = new wh.BrowserRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Browser";
      return;
    }
    if (this._source = new _h.NodeRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Node";
      return;
    }
  }
  randomBytes(e) {
    if (!this.isAvailable)
      throw new Error("System random byte generator is not available.");
    return this._source.randomBytes(e);
  }
}
Di.SystemRandomSource = mh;
var se = {}, ko = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  function e(c, h) {
    var d = c >>> 16 & 65535, p = c & 65535, E = h >>> 16 & 65535, x = h & 65535;
    return p * x + (d * x + p * E << 16 >>> 0) | 0;
  }
  t.mul = Math.imul || e;
  function r(c, h) {
    return c + h | 0;
  }
  t.add = r;
  function i(c, h) {
    return c - h | 0;
  }
  t.sub = i;
  function s(c, h) {
    return c << h | c >>> 32 - h;
  }
  t.rotl = s;
  function o(c, h) {
    return c << 32 - h | c >>> h;
  }
  t.rotr = o;
  function u(c) {
    return typeof c == "number" && isFinite(c) && Math.floor(c) === c;
  }
  t.isInteger = Number.isInteger || u, t.MAX_SAFE_INTEGER = 9007199254740991, t.isSafeInteger = function(c) {
    return t.isInteger(c) && c >= -t.MAX_SAFE_INTEGER && c <= t.MAX_SAFE_INTEGER;
  };
})(ko);
Object.defineProperty(se, "__esModule", { value: !0 });
var Go = ko;
function vh(t, e) {
  return e === void 0 && (e = 0), (t[e + 0] << 8 | t[e + 1]) << 16 >> 16;
}
se.readInt16BE = vh;
function Eh(t, e) {
  return e === void 0 && (e = 0), (t[e + 0] << 8 | t[e + 1]) >>> 0;
}
se.readUint16BE = Eh;
function Dh(t, e) {
  return e === void 0 && (e = 0), (t[e + 1] << 8 | t[e]) << 16 >> 16;
}
se.readInt16LE = Dh;
function Sh(t, e) {
  return e === void 0 && (e = 0), (t[e + 1] << 8 | t[e]) >>> 0;
}
se.readUint16LE = Sh;
function Yo(t, e, r) {
  return e === void 0 && (e = new Uint8Array(2)), r === void 0 && (r = 0), e[r + 0] = t >>> 8, e[r + 1] = t >>> 0, e;
}
se.writeUint16BE = Yo;
se.writeInt16BE = Yo;
function Jo(t, e, r) {
  return e === void 0 && (e = new Uint8Array(2)), r === void 0 && (r = 0), e[r + 0] = t >>> 0, e[r + 1] = t >>> 8, e;
}
se.writeUint16LE = Jo;
se.writeInt16LE = Jo;
function os(t, e) {
  return e === void 0 && (e = 0), t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3];
}
se.readInt32BE = os;
function as(t, e) {
  return e === void 0 && (e = 0), (t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3]) >>> 0;
}
se.readUint32BE = as;
function cs(t, e) {
  return e === void 0 && (e = 0), t[e + 3] << 24 | t[e + 2] << 16 | t[e + 1] << 8 | t[e];
}
se.readInt32LE = cs;
function us(t, e) {
  return e === void 0 && (e = 0), (t[e + 3] << 24 | t[e + 2] << 16 | t[e + 1] << 8 | t[e]) >>> 0;
}
se.readUint32LE = us;
function pi(t, e, r) {
  return e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0), e[r + 0] = t >>> 24, e[r + 1] = t >>> 16, e[r + 2] = t >>> 8, e[r + 3] = t >>> 0, e;
}
se.writeUint32BE = pi;
se.writeInt32BE = pi;
function gi(t, e, r) {
  return e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0), e[r + 0] = t >>> 0, e[r + 1] = t >>> 8, e[r + 2] = t >>> 16, e[r + 3] = t >>> 24, e;
}
se.writeUint32LE = gi;
se.writeInt32LE = gi;
function Ih(t, e) {
  e === void 0 && (e = 0);
  var r = os(t, e), i = os(t, e + 4);
  return r * 4294967296 + i - (i >> 31) * 4294967296;
}
se.readInt64BE = Ih;
function xh(t, e) {
  e === void 0 && (e = 0);
  var r = as(t, e), i = as(t, e + 4);
  return r * 4294967296 + i;
}
se.readUint64BE = xh;
function Oh(t, e) {
  e === void 0 && (e = 0);
  var r = cs(t, e), i = cs(t, e + 4);
  return i * 4294967296 + r - (r >> 31) * 4294967296;
}
se.readInt64LE = Oh;
function Ah(t, e) {
  e === void 0 && (e = 0);
  var r = us(t, e), i = us(t, e + 4);
  return i * 4294967296 + r;
}
se.readUint64LE = Ah;
function Xo(t, e, r) {
  return e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0), pi(t / 4294967296 >>> 0, e, r), pi(t >>> 0, e, r + 4), e;
}
se.writeUint64BE = Xo;
se.writeInt64BE = Xo;
function Qo(t, e, r) {
  return e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0), gi(t >>> 0, e, r), gi(t / 4294967296 >>> 0, e, r + 4), e;
}
se.writeUint64LE = Qo;
se.writeInt64LE = Qo;
function Ch(t, e, r) {
  if (r === void 0 && (r = 0), t % 8 !== 0)
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  if (t / 8 > e.length - r)
    throw new Error("readUintBE: array is too short for the given bitLength");
  for (var i = 0, s = 1, o = t / 8 + r - 1; o >= r; o--)
    i += e[o] * s, s *= 256;
  return i;
}
se.readUintBE = Ch;
function Th(t, e, r) {
  if (r === void 0 && (r = 0), t % 8 !== 0)
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  if (t / 8 > e.length - r)
    throw new Error("readUintLE: array is too short for the given bitLength");
  for (var i = 0, s = 1, o = r; o < r + t / 8; o++)
    i += e[o] * s, s *= 256;
  return i;
}
se.readUintLE = Th;
function Nh(t, e, r, i) {
  if (r === void 0 && (r = new Uint8Array(t / 8)), i === void 0 && (i = 0), t % 8 !== 0)
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  if (!Go.isSafeInteger(e))
    throw new Error("writeUintBE value must be an integer");
  for (var s = 1, o = t / 8 + i - 1; o >= i; o--)
    r[o] = e / s & 255, s *= 256;
  return r;
}
se.writeUintBE = Nh;
function Rh(t, e, r, i) {
  if (r === void 0 && (r = new Uint8Array(t / 8)), i === void 0 && (i = 0), t % 8 !== 0)
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  if (!Go.isSafeInteger(e))
    throw new Error("writeUintLE value must be an integer");
  for (var s = 1, o = i; o < i + t / 8; o++)
    r[o] = e / s & 255, s *= 256;
  return r;
}
se.writeUintLE = Rh;
function Ph(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat32(e);
}
se.readFloat32BE = Ph;
function Uh(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat32(e, !0);
}
se.readFloat32LE = Uh;
function Lh(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat64(e);
}
se.readFloat64BE = Lh;
function Fh(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat64(e, !0);
}
se.readFloat64LE = Fh;
function Mh(t, e, r) {
  e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0);
  var i = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return i.setFloat32(r, t), e;
}
se.writeFloat32BE = Mh;
function $h(t, e, r) {
  e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0);
  var i = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return i.setFloat32(r, t, !0), e;
}
se.writeFloat32LE = $h;
function jh(t, e, r) {
  e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0);
  var i = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return i.setFloat64(r, t), e;
}
se.writeFloat64BE = jh;
function Bh(t, e, r) {
  e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0);
  var i = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return i.setFloat64(r, t, !0), e;
}
se.writeFloat64LE = Bh;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.randomStringForEntropy = t.randomString = t.randomUint32 = t.randomBytes = t.defaultRandomSource = void 0;
  const e = Di, r = se, i = mt;
  t.defaultRandomSource = new e.SystemRandomSource();
  function s(d, p = t.defaultRandomSource) {
    return p.randomBytes(d);
  }
  t.randomBytes = s;
  function o(d = t.defaultRandomSource) {
    const p = s(4, d), E = (0, r.readUint32LE)(p);
    return (0, i.wipe)(p), E;
  }
  t.randomUint32 = o;
  const u = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function c(d, p = u, E = t.defaultRandomSource) {
    if (p.length < 2)
      throw new Error("randomString charset is too short");
    if (p.length > 256)
      throw new Error("randomString charset is too long");
    let x = "";
    const v = p.length, I = 256 - 256 % v;
    for (; d > 0; ) {
      const N = s(Math.ceil(d * 256 / I), E);
      for (let R = 0; R < N.length && d > 0; R++) {
        const K = N[R];
        K < I && (x += p.charAt(K % v), d--);
      }
      (0, i.wipe)(N);
    }
    return x;
  }
  t.randomString = c;
  function h(d, p = u, E = t.defaultRandomSource) {
    const x = Math.ceil(d / (Math.log(p.length) / Math.LN2));
    return c(x, p, E);
  }
  t.randomStringForEntropy = h;
})(Ir);
var Zo = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = se, r = mt;
  t.DIGEST_LENGTH = 64, t.BLOCK_SIZE = 128;
  var i = (
    /** @class */
    function() {
      function c() {
        this.digestLength = t.DIGEST_LENGTH, this.blockSize = t.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return c.prototype._initState = function() {
        this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209;
      }, c.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, c.prototype.clean = function() {
        r.wipe(this._buffer), r.wipe(this._tempHi), r.wipe(this._tempLo), this.reset();
      }, c.prototype.update = function(h, d) {
        if (d === void 0 && (d = h.length), this._finished)
          throw new Error("SHA512: can't update because hash was finished.");
        var p = 0;
        if (this._bytesHashed += d, this._bufferLength > 0) {
          for (; this._bufferLength < t.BLOCK_SIZE && d > 0; )
            this._buffer[this._bufferLength++] = h[p++], d--;
          this._bufferLength === this.blockSize && (o(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (d >= this.blockSize && (p = o(this._tempHi, this._tempLo, this._stateHi, this._stateLo, h, p, d), d %= this.blockSize); d > 0; )
          this._buffer[this._bufferLength++] = h[p++], d--;
        return this;
      }, c.prototype.finish = function(h) {
        if (!this._finished) {
          var d = this._bytesHashed, p = this._bufferLength, E = d / 536870912 | 0, x = d << 3, v = d % 128 < 112 ? 128 : 256;
          this._buffer[p] = 128;
          for (var I = p + 1; I < v - 8; I++)
            this._buffer[I] = 0;
          e.writeUint32BE(E, this._buffer, v - 8), e.writeUint32BE(x, this._buffer, v - 4), o(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, v), this._finished = !0;
        }
        for (var I = 0; I < this.digestLength / 8; I++)
          e.writeUint32BE(this._stateHi[I], h, I * 8), e.writeUint32BE(this._stateLo[I], h, I * 8 + 4);
        return this;
      }, c.prototype.digest = function() {
        var h = new Uint8Array(this.digestLength);
        return this.finish(h), h;
      }, c.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          stateHi: new Int32Array(this._stateHi),
          stateLo: new Int32Array(this._stateLo),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, c.prototype.restoreState = function(h) {
        return this._stateHi.set(h.stateHi), this._stateLo.set(h.stateLo), this._bufferLength = h.bufferLength, h.buffer && this._buffer.set(h.buffer), this._bytesHashed = h.bytesHashed, this._finished = !1, this;
      }, c.prototype.cleanSavedState = function(h) {
        r.wipe(h.stateHi), r.wipe(h.stateLo), h.buffer && r.wipe(h.buffer), h.bufferLength = 0, h.bytesHashed = 0;
      }, c;
    }()
  );
  t.SHA512 = i;
  var s = new Int32Array([
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ]);
  function o(c, h, d, p, E, x, v) {
    for (var I = d[0], N = d[1], R = d[2], K = d[3], m = d[4], O = d[5], y = d[6], _ = d[7], f = p[0], n = p[1], l = p[2], P = p[3], U = p[4], L = p[5], F = p[6], z = p[7], b, A, k, B, $, q, M, V; v >= 128; ) {
      for (var te = 0; te < 16; te++) {
        var H = 8 * te + x;
        c[te] = e.readUint32BE(E, H), h[te] = e.readUint32BE(E, H + 4);
      }
      for (var te = 0; te < 80; te++) {
        var Z = I, J = N, ee = R, T = K, C = m, D = O, a = y, w = _, W = f, Y = n, le = l, be = P, de = U, ve = L, Le = F, Te = z;
        if (b = _, A = z, $ = A & 65535, q = A >>> 16, M = b & 65535, V = b >>> 16, b = (m >>> 14 | U << 32 - 14) ^ (m >>> 18 | U << 32 - 18) ^ (U >>> 41 - 32 | m << 32 - (41 - 32)), A = (U >>> 14 | m << 32 - 14) ^ (U >>> 18 | m << 32 - 18) ^ (m >>> 41 - 32 | U << 32 - (41 - 32)), $ += A & 65535, q += A >>> 16, M += b & 65535, V += b >>> 16, b = m & O ^ ~m & y, A = U & L ^ ~U & F, $ += A & 65535, q += A >>> 16, M += b & 65535, V += b >>> 16, b = s[te * 2], A = s[te * 2 + 1], $ += A & 65535, q += A >>> 16, M += b & 65535, V += b >>> 16, b = c[te % 16], A = h[te % 16], $ += A & 65535, q += A >>> 16, M += b & 65535, V += b >>> 16, q += $ >>> 16, M += q >>> 16, V += M >>> 16, k = M & 65535 | V << 16, B = $ & 65535 | q << 16, b = k, A = B, $ = A & 65535, q = A >>> 16, M = b & 65535, V = b >>> 16, b = (I >>> 28 | f << 32 - 28) ^ (f >>> 34 - 32 | I << 32 - (34 - 32)) ^ (f >>> 39 - 32 | I << 32 - (39 - 32)), A = (f >>> 28 | I << 32 - 28) ^ (I >>> 34 - 32 | f << 32 - (34 - 32)) ^ (I >>> 39 - 32 | f << 32 - (39 - 32)), $ += A & 65535, q += A >>> 16, M += b & 65535, V += b >>> 16, b = I & N ^ I & R ^ N & R, A = f & n ^ f & l ^ n & l, $ += A & 65535, q += A >>> 16, M += b & 65535, V += b >>> 16, q += $ >>> 16, M += q >>> 16, V += M >>> 16, w = M & 65535 | V << 16, Te = $ & 65535 | q << 16, b = T, A = be, $ = A & 65535, q = A >>> 16, M = b & 65535, V = b >>> 16, b = k, A = B, $ += A & 65535, q += A >>> 16, M += b & 65535, V += b >>> 16, q += $ >>> 16, M += q >>> 16, V += M >>> 16, T = M & 65535 | V << 16, be = $ & 65535 | q << 16, N = Z, R = J, K = ee, m = T, O = C, y = D, _ = a, I = w, n = W, l = Y, P = le, U = be, L = de, F = ve, z = Le, f = Te, te % 16 === 15)
          for (var H = 0; H < 16; H++)
            b = c[H], A = h[H], $ = A & 65535, q = A >>> 16, M = b & 65535, V = b >>> 16, b = c[(H + 9) % 16], A = h[(H + 9) % 16], $ += A & 65535, q += A >>> 16, M += b & 65535, V += b >>> 16, k = c[(H + 1) % 16], B = h[(H + 1) % 16], b = (k >>> 1 | B << 32 - 1) ^ (k >>> 8 | B << 32 - 8) ^ k >>> 7, A = (B >>> 1 | k << 32 - 1) ^ (B >>> 8 | k << 32 - 8) ^ (B >>> 7 | k << 32 - 7), $ += A & 65535, q += A >>> 16, M += b & 65535, V += b >>> 16, k = c[(H + 14) % 16], B = h[(H + 14) % 16], b = (k >>> 19 | B << 32 - 19) ^ (B >>> 61 - 32 | k << 32 - (61 - 32)) ^ k >>> 6, A = (B >>> 19 | k << 32 - 19) ^ (k >>> 61 - 32 | B << 32 - (61 - 32)) ^ (B >>> 6 | k << 32 - 6), $ += A & 65535, q += A >>> 16, M += b & 65535, V += b >>> 16, q += $ >>> 16, M += q >>> 16, V += M >>> 16, c[H] = M & 65535 | V << 16, h[H] = $ & 65535 | q << 16;
      }
      b = I, A = f, $ = A & 65535, q = A >>> 16, M = b & 65535, V = b >>> 16, b = d[0], A = p[0], $ += A & 65535, q += A >>> 16, M += b & 65535, V += b >>> 16, q += $ >>> 16, M += q >>> 16, V += M >>> 16, d[0] = I = M & 65535 | V << 16, p[0] = f = $ & 65535 | q << 16, b = N, A = n, $ = A & 65535, q = A >>> 16, M = b & 65535, V = b >>> 16, b = d[1], A = p[1], $ += A & 65535, q += A >>> 16, M += b & 65535, V += b >>> 16, q += $ >>> 16, M += q >>> 16, V += M >>> 16, d[1] = N = M & 65535 | V << 16, p[1] = n = $ & 65535 | q << 16, b = R, A = l, $ = A & 65535, q = A >>> 16, M = b & 65535, V = b >>> 16, b = d[2], A = p[2], $ += A & 65535, q += A >>> 16, M += b & 65535, V += b >>> 16, q += $ >>> 16, M += q >>> 16, V += M >>> 16, d[2] = R = M & 65535 | V << 16, p[2] = l = $ & 65535 | q << 16, b = K, A = P, $ = A & 65535, q = A >>> 16, M = b & 65535, V = b >>> 16, b = d[3], A = p[3], $ += A & 65535, q += A >>> 16, M += b & 65535, V += b >>> 16, q += $ >>> 16, M += q >>> 16, V += M >>> 16, d[3] = K = M & 65535 | V << 16, p[3] = P = $ & 65535 | q << 16, b = m, A = U, $ = A & 65535, q = A >>> 16, M = b & 65535, V = b >>> 16, b = d[4], A = p[4], $ += A & 65535, q += A >>> 16, M += b & 65535, V += b >>> 16, q += $ >>> 16, M += q >>> 16, V += M >>> 16, d[4] = m = M & 65535 | V << 16, p[4] = U = $ & 65535 | q << 16, b = O, A = L, $ = A & 65535, q = A >>> 16, M = b & 65535, V = b >>> 16, b = d[5], A = p[5], $ += A & 65535, q += A >>> 16, M += b & 65535, V += b >>> 16, q += $ >>> 16, M += q >>> 16, V += M >>> 16, d[5] = O = M & 65535 | V << 16, p[5] = L = $ & 65535 | q << 16, b = y, A = F, $ = A & 65535, q = A >>> 16, M = b & 65535, V = b >>> 16, b = d[6], A = p[6], $ += A & 65535, q += A >>> 16, M += b & 65535, V += b >>> 16, q += $ >>> 16, M += q >>> 16, V += M >>> 16, d[6] = y = M & 65535 | V << 16, p[6] = F = $ & 65535 | q << 16, b = _, A = z, $ = A & 65535, q = A >>> 16, M = b & 65535, V = b >>> 16, b = d[7], A = p[7], $ += A & 65535, q += A >>> 16, M += b & 65535, V += b >>> 16, q += $ >>> 16, M += q >>> 16, V += M >>> 16, d[7] = _ = M & 65535 | V << 16, p[7] = z = $ & 65535 | q << 16, x += 128, v -= 128;
    }
    return x;
  }
  function u(c) {
    var h = new i();
    h.update(c);
    var d = h.digest();
    return h.clean(), d;
  }
  t.hash = u;
})(Zo);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.convertSecretKeyToX25519 = t.convertPublicKeyToX25519 = t.verify = t.sign = t.extractPublicKeyFromSecretKey = t.generateKeyPair = t.generateKeyPairFromSeed = t.SEED_LENGTH = t.SECRET_KEY_LENGTH = t.PUBLIC_KEY_LENGTH = t.SIGNATURE_LENGTH = void 0;
  const e = Ir, r = Zo, i = mt;
  t.SIGNATURE_LENGTH = 64, t.PUBLIC_KEY_LENGTH = 32, t.SECRET_KEY_LENGTH = 64, t.SEED_LENGTH = 32;
  function s(T) {
    const C = new Float64Array(16);
    if (T)
      for (let D = 0; D < T.length; D++)
        C[D] = T[D];
    return C;
  }
  const o = new Uint8Array(32);
  o[0] = 9;
  const u = s(), c = s([1]), h = s([
    30883,
    4953,
    19914,
    30187,
    55467,
    16705,
    2637,
    112,
    59544,
    30585,
    16505,
    36039,
    65139,
    11119,
    27886,
    20995
  ]), d = s([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
  ]), p = s([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
  ]), E = s([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
  ]), x = s([
    41136,
    18958,
    6951,
    50414,
    58488,
    44335,
    6150,
    12099,
    55207,
    15867,
    153,
    11085,
    57099,
    20417,
    9344,
    11139
  ]);
  function v(T, C) {
    for (let D = 0; D < 16; D++)
      T[D] = C[D] | 0;
  }
  function I(T) {
    let C = 1;
    for (let D = 0; D < 16; D++) {
      let a = T[D] + C + 65535;
      C = Math.floor(a / 65536), T[D] = a - C * 65536;
    }
    T[0] += C - 1 + 37 * (C - 1);
  }
  function N(T, C, D) {
    const a = ~(D - 1);
    for (let w = 0; w < 16; w++) {
      const W = a & (T[w] ^ C[w]);
      T[w] ^= W, C[w] ^= W;
    }
  }
  function R(T, C) {
    const D = s(), a = s();
    for (let w = 0; w < 16; w++)
      a[w] = C[w];
    I(a), I(a), I(a);
    for (let w = 0; w < 2; w++) {
      D[0] = a[0] - 65517;
      for (let Y = 1; Y < 15; Y++)
        D[Y] = a[Y] - 65535 - (D[Y - 1] >> 16 & 1), D[Y - 1] &= 65535;
      D[15] = a[15] - 32767 - (D[14] >> 16 & 1);
      const W = D[15] >> 16 & 1;
      D[14] &= 65535, N(a, D, 1 - W);
    }
    for (let w = 0; w < 16; w++)
      T[2 * w] = a[w] & 255, T[2 * w + 1] = a[w] >> 8;
  }
  function K(T, C) {
    let D = 0;
    for (let a = 0; a < 32; a++)
      D |= T[a] ^ C[a];
    return (1 & D - 1 >>> 8) - 1;
  }
  function m(T, C) {
    const D = new Uint8Array(32), a = new Uint8Array(32);
    return R(D, T), R(a, C), K(D, a);
  }
  function O(T) {
    const C = new Uint8Array(32);
    return R(C, T), C[0] & 1;
  }
  function y(T, C) {
    for (let D = 0; D < 16; D++)
      T[D] = C[2 * D] + (C[2 * D + 1] << 8);
    T[15] &= 32767;
  }
  function _(T, C, D) {
    for (let a = 0; a < 16; a++)
      T[a] = C[a] + D[a];
  }
  function f(T, C, D) {
    for (let a = 0; a < 16; a++)
      T[a] = C[a] - D[a];
  }
  function n(T, C, D) {
    let a, w, W = 0, Y = 0, le = 0, be = 0, de = 0, ve = 0, Le = 0, Te = 0, ye = 0, pe = 0, fe = 0, ue = 0, ce = 0, ae = 0, oe = 0, re = 0, he = 0, ge = 0, ie = 0, we = 0, me = 0, De = 0, Se = 0, Ee = 0, xt = 0, Nt = 0, Kt = 0, bt = 0, Zt = 0, Ar = 0, ti = 0, Fe = D[0], Ne = D[1], Me = D[2], $e = D[3], je = D[4], Re = D[5], Ke = D[6], Ve = D[7], He = D[8], We = D[9], ke = D[10], ze = D[11], Be = D[12], Oe = D[13], Ge = D[14], Ye = D[15];
    a = C[0], W += a * Fe, Y += a * Ne, le += a * Me, be += a * $e, de += a * je, ve += a * Re, Le += a * Ke, Te += a * Ve, ye += a * He, pe += a * We, fe += a * ke, ue += a * ze, ce += a * Be, ae += a * Oe, oe += a * Ge, re += a * Ye, a = C[1], Y += a * Fe, le += a * Ne, be += a * Me, de += a * $e, ve += a * je, Le += a * Re, Te += a * Ke, ye += a * Ve, pe += a * He, fe += a * We, ue += a * ke, ce += a * ze, ae += a * Be, oe += a * Oe, re += a * Ge, he += a * Ye, a = C[2], le += a * Fe, be += a * Ne, de += a * Me, ve += a * $e, Le += a * je, Te += a * Re, ye += a * Ke, pe += a * Ve, fe += a * He, ue += a * We, ce += a * ke, ae += a * ze, oe += a * Be, re += a * Oe, he += a * Ge, ge += a * Ye, a = C[3], be += a * Fe, de += a * Ne, ve += a * Me, Le += a * $e, Te += a * je, ye += a * Re, pe += a * Ke, fe += a * Ve, ue += a * He, ce += a * We, ae += a * ke, oe += a * ze, re += a * Be, he += a * Oe, ge += a * Ge, ie += a * Ye, a = C[4], de += a * Fe, ve += a * Ne, Le += a * Me, Te += a * $e, ye += a * je, pe += a * Re, fe += a * Ke, ue += a * Ve, ce += a * He, ae += a * We, oe += a * ke, re += a * ze, he += a * Be, ge += a * Oe, ie += a * Ge, we += a * Ye, a = C[5], ve += a * Fe, Le += a * Ne, Te += a * Me, ye += a * $e, pe += a * je, fe += a * Re, ue += a * Ke, ce += a * Ve, ae += a * He, oe += a * We, re += a * ke, he += a * ze, ge += a * Be, ie += a * Oe, we += a * Ge, me += a * Ye, a = C[6], Le += a * Fe, Te += a * Ne, ye += a * Me, pe += a * $e, fe += a * je, ue += a * Re, ce += a * Ke, ae += a * Ve, oe += a * He, re += a * We, he += a * ke, ge += a * ze, ie += a * Be, we += a * Oe, me += a * Ge, De += a * Ye, a = C[7], Te += a * Fe, ye += a * Ne, pe += a * Me, fe += a * $e, ue += a * je, ce += a * Re, ae += a * Ke, oe += a * Ve, re += a * He, he += a * We, ge += a * ke, ie += a * ze, we += a * Be, me += a * Oe, De += a * Ge, Se += a * Ye, a = C[8], ye += a * Fe, pe += a * Ne, fe += a * Me, ue += a * $e, ce += a * je, ae += a * Re, oe += a * Ke, re += a * Ve, he += a * He, ge += a * We, ie += a * ke, we += a * ze, me += a * Be, De += a * Oe, Se += a * Ge, Ee += a * Ye, a = C[9], pe += a * Fe, fe += a * Ne, ue += a * Me, ce += a * $e, ae += a * je, oe += a * Re, re += a * Ke, he += a * Ve, ge += a * He, ie += a * We, we += a * ke, me += a * ze, De += a * Be, Se += a * Oe, Ee += a * Ge, xt += a * Ye, a = C[10], fe += a * Fe, ue += a * Ne, ce += a * Me, ae += a * $e, oe += a * je, re += a * Re, he += a * Ke, ge += a * Ve, ie += a * He, we += a * We, me += a * ke, De += a * ze, Se += a * Be, Ee += a * Oe, xt += a * Ge, Nt += a * Ye, a = C[11], ue += a * Fe, ce += a * Ne, ae += a * Me, oe += a * $e, re += a * je, he += a * Re, ge += a * Ke, ie += a * Ve, we += a * He, me += a * We, De += a * ke, Se += a * ze, Ee += a * Be, xt += a * Oe, Nt += a * Ge, Kt += a * Ye, a = C[12], ce += a * Fe, ae += a * Ne, oe += a * Me, re += a * $e, he += a * je, ge += a * Re, ie += a * Ke, we += a * Ve, me += a * He, De += a * We, Se += a * ke, Ee += a * ze, xt += a * Be, Nt += a * Oe, Kt += a * Ge, bt += a * Ye, a = C[13], ae += a * Fe, oe += a * Ne, re += a * Me, he += a * $e, ge += a * je, ie += a * Re, we += a * Ke, me += a * Ve, De += a * He, Se += a * We, Ee += a * ke, xt += a * ze, Nt += a * Be, Kt += a * Oe, bt += a * Ge, Zt += a * Ye, a = C[14], oe += a * Fe, re += a * Ne, he += a * Me, ge += a * $e, ie += a * je, we += a * Re, me += a * Ke, De += a * Ve, Se += a * He, Ee += a * We, xt += a * ke, Nt += a * ze, Kt += a * Be, bt += a * Oe, Zt += a * Ge, Ar += a * Ye, a = C[15], re += a * Fe, he += a * Ne, ge += a * Me, ie += a * $e, we += a * je, me += a * Re, De += a * Ke, Se += a * Ve, Ee += a * He, xt += a * We, Nt += a * ke, Kt += a * ze, bt += a * Be, Zt += a * Oe, Ar += a * Ge, ti += a * Ye, W += 38 * he, Y += 38 * ge, le += 38 * ie, be += 38 * we, de += 38 * me, ve += 38 * De, Le += 38 * Se, Te += 38 * Ee, ye += 38 * xt, pe += 38 * Nt, fe += 38 * Kt, ue += 38 * bt, ce += 38 * Zt, ae += 38 * Ar, oe += 38 * ti, w = 1, a = W + w + 65535, w = Math.floor(a / 65536), W = a - w * 65536, a = Y + w + 65535, w = Math.floor(a / 65536), Y = a - w * 65536, a = le + w + 65535, w = Math.floor(a / 65536), le = a - w * 65536, a = be + w + 65535, w = Math.floor(a / 65536), be = a - w * 65536, a = de + w + 65535, w = Math.floor(a / 65536), de = a - w * 65536, a = ve + w + 65535, w = Math.floor(a / 65536), ve = a - w * 65536, a = Le + w + 65535, w = Math.floor(a / 65536), Le = a - w * 65536, a = Te + w + 65535, w = Math.floor(a / 65536), Te = a - w * 65536, a = ye + w + 65535, w = Math.floor(a / 65536), ye = a - w * 65536, a = pe + w + 65535, w = Math.floor(a / 65536), pe = a - w * 65536, a = fe + w + 65535, w = Math.floor(a / 65536), fe = a - w * 65536, a = ue + w + 65535, w = Math.floor(a / 65536), ue = a - w * 65536, a = ce + w + 65535, w = Math.floor(a / 65536), ce = a - w * 65536, a = ae + w + 65535, w = Math.floor(a / 65536), ae = a - w * 65536, a = oe + w + 65535, w = Math.floor(a / 65536), oe = a - w * 65536, a = re + w + 65535, w = Math.floor(a / 65536), re = a - w * 65536, W += w - 1 + 37 * (w - 1), w = 1, a = W + w + 65535, w = Math.floor(a / 65536), W = a - w * 65536, a = Y + w + 65535, w = Math.floor(a / 65536), Y = a - w * 65536, a = le + w + 65535, w = Math.floor(a / 65536), le = a - w * 65536, a = be + w + 65535, w = Math.floor(a / 65536), be = a - w * 65536, a = de + w + 65535, w = Math.floor(a / 65536), de = a - w * 65536, a = ve + w + 65535, w = Math.floor(a / 65536), ve = a - w * 65536, a = Le + w + 65535, w = Math.floor(a / 65536), Le = a - w * 65536, a = Te + w + 65535, w = Math.floor(a / 65536), Te = a - w * 65536, a = ye + w + 65535, w = Math.floor(a / 65536), ye = a - w * 65536, a = pe + w + 65535, w = Math.floor(a / 65536), pe = a - w * 65536, a = fe + w + 65535, w = Math.floor(a / 65536), fe = a - w * 65536, a = ue + w + 65535, w = Math.floor(a / 65536), ue = a - w * 65536, a = ce + w + 65535, w = Math.floor(a / 65536), ce = a - w * 65536, a = ae + w + 65535, w = Math.floor(a / 65536), ae = a - w * 65536, a = oe + w + 65535, w = Math.floor(a / 65536), oe = a - w * 65536, a = re + w + 65535, w = Math.floor(a / 65536), re = a - w * 65536, W += w - 1 + 37 * (w - 1), T[0] = W, T[1] = Y, T[2] = le, T[3] = be, T[4] = de, T[5] = ve, T[6] = Le, T[7] = Te, T[8] = ye, T[9] = pe, T[10] = fe, T[11] = ue, T[12] = ce, T[13] = ae, T[14] = oe, T[15] = re;
  }
  function l(T, C) {
    n(T, C, C);
  }
  function P(T, C) {
    const D = s();
    let a;
    for (a = 0; a < 16; a++)
      D[a] = C[a];
    for (a = 253; a >= 0; a--)
      l(D, D), a !== 2 && a !== 4 && n(D, D, C);
    for (a = 0; a < 16; a++)
      T[a] = D[a];
  }
  function U(T, C) {
    const D = s();
    let a;
    for (a = 0; a < 16; a++)
      D[a] = C[a];
    for (a = 250; a >= 0; a--)
      l(D, D), a !== 1 && n(D, D, C);
    for (a = 0; a < 16; a++)
      T[a] = D[a];
  }
  function L(T, C) {
    const D = s(), a = s(), w = s(), W = s(), Y = s(), le = s(), be = s(), de = s(), ve = s();
    f(D, T[1], T[0]), f(ve, C[1], C[0]), n(D, D, ve), _(a, T[0], T[1]), _(ve, C[0], C[1]), n(a, a, ve), n(w, T[3], C[3]), n(w, w, d), n(W, T[2], C[2]), _(W, W, W), f(Y, a, D), f(le, W, w), _(be, W, w), _(de, a, D), n(T[0], Y, le), n(T[1], de, be), n(T[2], be, le), n(T[3], Y, de);
  }
  function F(T, C, D) {
    for (let a = 0; a < 4; a++)
      N(T[a], C[a], D);
  }
  function z(T, C) {
    const D = s(), a = s(), w = s();
    P(w, C[2]), n(D, C[0], w), n(a, C[1], w), R(T, a), T[31] ^= O(D) << 7;
  }
  function b(T, C, D) {
    v(T[0], u), v(T[1], c), v(T[2], c), v(T[3], u);
    for (let a = 255; a >= 0; --a) {
      const w = D[a / 8 | 0] >> (a & 7) & 1;
      F(T, C, w), L(C, T), L(T, T), F(T, C, w);
    }
  }
  function A(T, C) {
    const D = [s(), s(), s(), s()];
    v(D[0], p), v(D[1], E), v(D[2], c), n(D[3], p, E), b(T, D, C);
  }
  function k(T) {
    if (T.length !== t.SEED_LENGTH)
      throw new Error(`ed25519: seed must be ${t.SEED_LENGTH} bytes`);
    const C = (0, r.hash)(T);
    C[0] &= 248, C[31] &= 127, C[31] |= 64;
    const D = new Uint8Array(32), a = [s(), s(), s(), s()];
    A(a, C), z(D, a);
    const w = new Uint8Array(64);
    return w.set(T), w.set(D, 32), {
      publicKey: D,
      secretKey: w
    };
  }
  t.generateKeyPairFromSeed = k;
  function B(T) {
    const C = (0, e.randomBytes)(32, T), D = k(C);
    return (0, i.wipe)(C), D;
  }
  t.generateKeyPair = B;
  function $(T) {
    if (T.length !== t.SECRET_KEY_LENGTH)
      throw new Error(`ed25519: secret key must be ${t.SECRET_KEY_LENGTH} bytes`);
    return new Uint8Array(T.subarray(32));
  }
  t.extractPublicKeyFromSecretKey = $;
  const q = new Float64Array([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ]);
  function M(T, C) {
    let D, a, w, W;
    for (a = 63; a >= 32; --a) {
      for (D = 0, w = a - 32, W = a - 12; w < W; ++w)
        C[w] += D - 16 * C[a] * q[w - (a - 32)], D = Math.floor((C[w] + 128) / 256), C[w] -= D * 256;
      C[w] += D, C[a] = 0;
    }
    for (D = 0, w = 0; w < 32; w++)
      C[w] += D - (C[31] >> 4) * q[w], D = C[w] >> 8, C[w] &= 255;
    for (w = 0; w < 32; w++)
      C[w] -= D * q[w];
    for (a = 0; a < 32; a++)
      C[a + 1] += C[a] >> 8, T[a] = C[a] & 255;
  }
  function V(T) {
    const C = new Float64Array(64);
    for (let D = 0; D < 64; D++)
      C[D] = T[D];
    for (let D = 0; D < 64; D++)
      T[D] = 0;
    M(T, C);
  }
  function te(T, C) {
    const D = new Float64Array(64), a = [s(), s(), s(), s()], w = (0, r.hash)(T.subarray(0, 32));
    w[0] &= 248, w[31] &= 127, w[31] |= 64;
    const W = new Uint8Array(64);
    W.set(w.subarray(32), 32);
    const Y = new r.SHA512();
    Y.update(W.subarray(32)), Y.update(C);
    const le = Y.digest();
    Y.clean(), V(le), A(a, le), z(W, a), Y.reset(), Y.update(W.subarray(0, 32)), Y.update(T.subarray(32)), Y.update(C);
    const be = Y.digest();
    V(be);
    for (let de = 0; de < 32; de++)
      D[de] = le[de];
    for (let de = 0; de < 32; de++)
      for (let ve = 0; ve < 32; ve++)
        D[de + ve] += be[de] * w[ve];
    return M(W.subarray(32), D), W;
  }
  t.sign = te;
  function H(T, C) {
    const D = s(), a = s(), w = s(), W = s(), Y = s(), le = s(), be = s();
    return v(T[2], c), y(T[1], C), l(w, T[1]), n(W, w, h), f(w, w, T[2]), _(W, T[2], W), l(Y, W), l(le, Y), n(be, le, Y), n(D, be, w), n(D, D, W), U(D, D), n(D, D, w), n(D, D, W), n(D, D, W), n(T[0], D, W), l(a, T[0]), n(a, a, W), m(a, w) && n(T[0], T[0], x), l(a, T[0]), n(a, a, W), m(a, w) ? -1 : (O(T[0]) === C[31] >> 7 && f(T[0], u, T[0]), n(T[3], T[0], T[1]), 0);
  }
  function Z(T, C, D) {
    const a = new Uint8Array(32), w = [s(), s(), s(), s()], W = [s(), s(), s(), s()];
    if (D.length !== t.SIGNATURE_LENGTH)
      throw new Error(`ed25519: signature must be ${t.SIGNATURE_LENGTH} bytes`);
    if (H(W, T))
      return !1;
    const Y = new r.SHA512();
    Y.update(D.subarray(0, 32)), Y.update(T), Y.update(C);
    const le = Y.digest();
    return V(le), b(w, W, le), A(W, D.subarray(32)), L(w, W), z(a, w), !K(D, a);
  }
  t.verify = Z;
  function J(T) {
    let C = [s(), s(), s(), s()];
    if (H(C, T))
      throw new Error("Ed25519: invalid public key");
    let D = s(), a = s(), w = C[1];
    _(D, c, w), f(a, c, w), P(a, a), n(D, D, a);
    let W = new Uint8Array(32);
    return R(W, D), W;
  }
  t.convertPublicKeyToX25519 = J;
  function ee(T) {
    const C = (0, r.hash)(T.subarray(0, 32));
    C[0] &= 248, C[31] &= 127, C[31] |= 64;
    const D = new Uint8Array(C.subarray(0, 32));
    return (0, i.wipe)(C), D;
  }
  t.convertSecretKeyToX25519 = ee;
})(Ds);
const qh = "EdDSA", zh = "JWT", ea = ".", ta = "base64url", Kh = "utf8", Vh = "utf8", Hh = ":", Wh = "did", kh = "key", Fn = "base58btc", Gh = "z", Yh = "K36", Jh = 32;
function Ss(t) {
  return globalThis.Buffer != null ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t;
}
function ra(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Ss(globalThis.Buffer.allocUnsafe(t)) : new Uint8Array(t);
}
function hs(t, e) {
  e || (e = t.reduce((s, o) => s + o.length, 0));
  const r = ra(e);
  let i = 0;
  for (const s of t)
    r.set(s, i), i += s.length;
  return Ss(r);
}
function Xh(t, e) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), i = 0; i < r.length; i++)
    r[i] = 255;
  for (var s = 0; s < t.length; s++) {
    var o = t.charAt(s), u = o.charCodeAt(0);
    if (r[u] !== 255)
      throw new TypeError(o + " is ambiguous");
    r[u] = s;
  }
  var c = t.length, h = t.charAt(0), d = Math.log(c) / Math.log(256), p = Math.log(256) / Math.log(c);
  function E(I) {
    if (I instanceof Uint8Array || (ArrayBuffer.isView(I) ? I = new Uint8Array(I.buffer, I.byteOffset, I.byteLength) : Array.isArray(I) && (I = Uint8Array.from(I))), !(I instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (I.length === 0)
      return "";
    for (var N = 0, R = 0, K = 0, m = I.length; K !== m && I[K] === 0; )
      K++, N++;
    for (var O = (m - K) * p + 1 >>> 0, y = new Uint8Array(O); K !== m; ) {
      for (var _ = I[K], f = 0, n = O - 1; (_ !== 0 || f < R) && n !== -1; n--, f++)
        _ += 256 * y[n] >>> 0, y[n] = _ % c >>> 0, _ = _ / c >>> 0;
      if (_ !== 0)
        throw new Error("Non-zero carry");
      R = f, K++;
    }
    for (var l = O - R; l !== O && y[l] === 0; )
      l++;
    for (var P = h.repeat(N); l < O; ++l)
      P += t.charAt(y[l]);
    return P;
  }
  function x(I) {
    if (typeof I != "string")
      throw new TypeError("Expected String");
    if (I.length === 0)
      return new Uint8Array();
    var N = 0;
    if (I[N] !== " ") {
      for (var R = 0, K = 0; I[N] === h; )
        R++, N++;
      for (var m = (I.length - N) * d + 1 >>> 0, O = new Uint8Array(m); I[N]; ) {
        var y = r[I.charCodeAt(N)];
        if (y === 255)
          return;
        for (var _ = 0, f = m - 1; (y !== 0 || _ < K) && f !== -1; f--, _++)
          y += c * O[f] >>> 0, O[f] = y % 256 >>> 0, y = y / 256 >>> 0;
        if (y !== 0)
          throw new Error("Non-zero carry");
        K = _, N++;
      }
      if (I[N] !== " ") {
        for (var n = m - K; n !== m && O[n] === 0; )
          n++;
        for (var l = new Uint8Array(R + (m - n)), P = R; n !== m; )
          l[P++] = O[n++];
        return l;
      }
    }
  }
  function v(I) {
    var N = x(I);
    if (N)
      return N;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: E,
    decodeUnsafe: x,
    decode: v
  };
}
var Qh = Xh, Zh = Qh;
const el = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
    return t;
  if (t instanceof ArrayBuffer)
    return new Uint8Array(t);
  if (ArrayBuffer.isView(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, tl = (t) => new TextEncoder().encode(t), rl = (t) => new TextDecoder().decode(t);
class il {
  constructor(e, r, i) {
    this.name = e, this.prefix = r, this.baseEncode = i;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class sl {
  constructor(e, r, i) {
    if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = i;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return ia(this, e);
  }
}
class nl {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return ia(this, e);
  }
  decode(e) {
    const r = e[0], i = this.decoders[r];
    if (i)
      return i.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const ia = (t, e) => new nl({
  ...t.decoders || { [t.prefix]: t },
  ...e.decoders || { [e.prefix]: e }
});
class ol {
  constructor(e, r, i, s) {
    this.name = e, this.prefix = r, this.baseEncode = i, this.baseDecode = s, this.encoder = new il(e, r, i), this.decoder = new sl(e, r, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const xi = ({ name: t, prefix: e, encode: r, decode: i }) => new ol(t, e, r, i), Jr = ({ prefix: t, name: e, alphabet: r }) => {
  const { encode: i, decode: s } = Zh(r, e);
  return xi({
    prefix: t,
    name: e,
    encode: i,
    decode: (o) => el(s(o))
  });
}, al = (t, e, r, i) => {
  const s = {};
  for (let p = 0; p < e.length; ++p)
    s[e[p]] = p;
  let o = t.length;
  for (; t[o - 1] === "="; )
    --o;
  const u = new Uint8Array(o * r / 8 | 0);
  let c = 0, h = 0, d = 0;
  for (let p = 0; p < o; ++p) {
    const E = s[t[p]];
    if (E === void 0)
      throw new SyntaxError(`Non-${i} character`);
    h = h << r | E, c += r, c >= 8 && (c -= 8, u[d++] = 255 & h >> c);
  }
  if (c >= r || 255 & h << 8 - c)
    throw new SyntaxError("Unexpected end of data");
  return u;
}, cl = (t, e, r) => {
  const i = e[e.length - 1] === "=", s = (1 << r) - 1;
  let o = "", u = 0, c = 0;
  for (let h = 0; h < t.length; ++h)
    for (c = c << 8 | t[h], u += 8; u > r; )
      u -= r, o += e[s & c >> u];
  if (u && (o += e[s & c << r - u]), i)
    for (; o.length * r & 7; )
      o += "=";
  return o;
}, rt = ({ name: t, prefix: e, bitsPerChar: r, alphabet: i }) => xi({
  prefix: e,
  name: t,
  encode(s) {
    return cl(s, i, r);
  },
  decode(s) {
    return al(s, i, r, t);
  }
}), ul = xi({
  prefix: "\0",
  name: "identity",
  encode: (t) => rl(t),
  decode: (t) => tl(t)
}), hl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: ul
}, Symbol.toStringTag, { value: "Module" })), ll = rt({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), fl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: ll
}, Symbol.toStringTag, { value: "Module" })), dl = rt({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), pl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: dl
}, Symbol.toStringTag, { value: "Module" })), gl = Jr({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), yl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: gl
}, Symbol.toStringTag, { value: "Module" })), bl = rt({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), wl = rt({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), _l = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: bl,
  base16upper: wl
}, Symbol.toStringTag, { value: "Module" })), ml = rt({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), vl = rt({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), El = rt({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), Dl = rt({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), Sl = rt({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), Il = rt({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), xl = rt({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), Ol = rt({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), Al = rt({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), Cl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: ml,
  base32hex: Sl,
  base32hexpad: xl,
  base32hexpadupper: Ol,
  base32hexupper: Il,
  base32pad: El,
  base32padupper: Dl,
  base32upper: vl,
  base32z: Al
}, Symbol.toStringTag, { value: "Module" })), Tl = Jr({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), Nl = Jr({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), Rl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: Tl,
  base36upper: Nl
}, Symbol.toStringTag, { value: "Module" })), Pl = Jr({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), Ul = Jr({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), Ll = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: Pl,
  base58flickr: Ul
}, Symbol.toStringTag, { value: "Module" })), Fl = rt({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), Ml = rt({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), $l = rt({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), jl = rt({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), Bl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: Fl,
  base64pad: Ml,
  base64url: $l,
  base64urlpad: jl
}, Symbol.toStringTag, { value: "Module" })), sa = Array.from(""), ql = sa.reduce((t, e, r) => (t[r] = e, t), []), zl = sa.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);
function Kl(t) {
  return t.reduce((e, r) => (e += ql[r], e), "");
}
function Vl(t) {
  const e = [];
  for (const r of t) {
    const i = zl[r.codePointAt(0)];
    if (i === void 0)
      throw new Error(`Non-base256emoji character: ${r}`);
    e.push(i);
  }
  return new Uint8Array(e);
}
const Hl = xi({
  prefix: "",
  name: "base256emoji",
  encode: Kl,
  decode: Vl
}), Wl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: Hl
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const Mn = {
  ...hl,
  ...fl,
  ...pl,
  ...yl,
  ..._l,
  ...Cl,
  ...Rl,
  ...Ll,
  ...Bl,
  ...Wl
};
function na(t, e, r, i) {
  return {
    name: t,
    prefix: e,
    encoder: {
      name: t,
      prefix: e,
      encode: r
    },
    decoder: { decode: i }
  };
}
const $n = na("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), Hi = na("ascii", "a", (t) => {
  let e = "a";
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = ra(t.length);
  for (let r = 0; r < t.length; r++)
    e[r] = t.charCodeAt(r);
  return e;
}), oa = {
  utf8: $n,
  "utf-8": $n,
  hex: Mn.base16,
  latin1: Hi,
  ascii: Hi,
  binary: Hi,
  ...Mn
};
function pt(t, e = "utf8") {
  const r = oa[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString("utf8") : r.encoder.encode(t).substring(1);
}
function yt(t, e = "utf8") {
  const r = oa[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Ss(globalThis.Buffer.from(t, "utf-8")) : r.decoder.decode(`${r.prefix}${t}`);
}
function yi(t) {
  return pt(yt(Es(t), Kh), ta);
}
function aa(t) {
  const e = yt(Yh, Fn), r = Gh + pt(hs([e, t]), Fn);
  return [Wh, kh, r].join(Hh);
}
function kl(t) {
  return pt(t, ta);
}
function Gl(t) {
  return yt([yi(t.header), yi(t.payload)].join(ea), Vh);
}
function Yl(t) {
  return [
    yi(t.header),
    yi(t.payload),
    kl(t.signature)
  ].join(ea);
}
function jn(t = Ir.randomBytes(Jh)) {
  return Ds.generateKeyPairFromSeed(t);
}
async function Jl(t, e, r, i, s = Q.fromMiliseconds(Date.now())) {
  const o = { alg: qh, typ: zh }, u = aa(i.publicKey), c = s + r, h = { iss: u, sub: t, aud: e, iat: s, exp: c }, d = Gl({ header: o, payload: h }), p = Ds.sign(i.secretKey, d);
  return Yl({ header: o, payload: h, signature: p });
}
var Is = {}, Oi = {};
Object.defineProperty(Oi, "__esModule", { value: !0 });
var ot = se, ls = mt, Xl = 20;
function Ql(t, e, r) {
  for (var i = 1634760805, s = 857760878, o = 2036477234, u = 1797285236, c = r[3] << 24 | r[2] << 16 | r[1] << 8 | r[0], h = r[7] << 24 | r[6] << 16 | r[5] << 8 | r[4], d = r[11] << 24 | r[10] << 16 | r[9] << 8 | r[8], p = r[15] << 24 | r[14] << 16 | r[13] << 8 | r[12], E = r[19] << 24 | r[18] << 16 | r[17] << 8 | r[16], x = r[23] << 24 | r[22] << 16 | r[21] << 8 | r[20], v = r[27] << 24 | r[26] << 16 | r[25] << 8 | r[24], I = r[31] << 24 | r[30] << 16 | r[29] << 8 | r[28], N = e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0], R = e[7] << 24 | e[6] << 16 | e[5] << 8 | e[4], K = e[11] << 24 | e[10] << 16 | e[9] << 8 | e[8], m = e[15] << 24 | e[14] << 16 | e[13] << 8 | e[12], O = i, y = s, _ = o, f = u, n = c, l = h, P = d, U = p, L = E, F = x, z = v, b = I, A = N, k = R, B = K, $ = m, q = 0; q < Xl; q += 2)
    O = O + n | 0, A ^= O, A = A >>> 32 - 16 | A << 16, L = L + A | 0, n ^= L, n = n >>> 32 - 12 | n << 12, y = y + l | 0, k ^= y, k = k >>> 32 - 16 | k << 16, F = F + k | 0, l ^= F, l = l >>> 32 - 12 | l << 12, _ = _ + P | 0, B ^= _, B = B >>> 32 - 16 | B << 16, z = z + B | 0, P ^= z, P = P >>> 32 - 12 | P << 12, f = f + U | 0, $ ^= f, $ = $ >>> 32 - 16 | $ << 16, b = b + $ | 0, U ^= b, U = U >>> 32 - 12 | U << 12, _ = _ + P | 0, B ^= _, B = B >>> 32 - 8 | B << 8, z = z + B | 0, P ^= z, P = P >>> 32 - 7 | P << 7, f = f + U | 0, $ ^= f, $ = $ >>> 32 - 8 | $ << 8, b = b + $ | 0, U ^= b, U = U >>> 32 - 7 | U << 7, y = y + l | 0, k ^= y, k = k >>> 32 - 8 | k << 8, F = F + k | 0, l ^= F, l = l >>> 32 - 7 | l << 7, O = O + n | 0, A ^= O, A = A >>> 32 - 8 | A << 8, L = L + A | 0, n ^= L, n = n >>> 32 - 7 | n << 7, O = O + l | 0, $ ^= O, $ = $ >>> 32 - 16 | $ << 16, z = z + $ | 0, l ^= z, l = l >>> 32 - 12 | l << 12, y = y + P | 0, A ^= y, A = A >>> 32 - 16 | A << 16, b = b + A | 0, P ^= b, P = P >>> 32 - 12 | P << 12, _ = _ + U | 0, k ^= _, k = k >>> 32 - 16 | k << 16, L = L + k | 0, U ^= L, U = U >>> 32 - 12 | U << 12, f = f + n | 0, B ^= f, B = B >>> 32 - 16 | B << 16, F = F + B | 0, n ^= F, n = n >>> 32 - 12 | n << 12, _ = _ + U | 0, k ^= _, k = k >>> 32 - 8 | k << 8, L = L + k | 0, U ^= L, U = U >>> 32 - 7 | U << 7, f = f + n | 0, B ^= f, B = B >>> 32 - 8 | B << 8, F = F + B | 0, n ^= F, n = n >>> 32 - 7 | n << 7, y = y + P | 0, A ^= y, A = A >>> 32 - 8 | A << 8, b = b + A | 0, P ^= b, P = P >>> 32 - 7 | P << 7, O = O + l | 0, $ ^= O, $ = $ >>> 32 - 8 | $ << 8, z = z + $ | 0, l ^= z, l = l >>> 32 - 7 | l << 7;
  ot.writeUint32LE(O + i | 0, t, 0), ot.writeUint32LE(y + s | 0, t, 4), ot.writeUint32LE(_ + o | 0, t, 8), ot.writeUint32LE(f + u | 0, t, 12), ot.writeUint32LE(n + c | 0, t, 16), ot.writeUint32LE(l + h | 0, t, 20), ot.writeUint32LE(P + d | 0, t, 24), ot.writeUint32LE(U + p | 0, t, 28), ot.writeUint32LE(L + E | 0, t, 32), ot.writeUint32LE(F + x | 0, t, 36), ot.writeUint32LE(z + v | 0, t, 40), ot.writeUint32LE(b + I | 0, t, 44), ot.writeUint32LE(A + N | 0, t, 48), ot.writeUint32LE(k + R | 0, t, 52), ot.writeUint32LE(B + K | 0, t, 56), ot.writeUint32LE($ + m | 0, t, 60);
}
function ca(t, e, r, i, s) {
  if (s === void 0 && (s = 0), t.length !== 32)
    throw new Error("ChaCha: key size must be 32 bytes");
  if (i.length < r.length)
    throw new Error("ChaCha: destination is shorter than source");
  var o, u;
  if (s === 0) {
    if (e.length !== 8 && e.length !== 12)
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    o = new Uint8Array(16), u = o.length - e.length, o.set(e, u);
  } else {
    if (e.length !== 16)
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    o = e, u = s;
  }
  for (var c = new Uint8Array(64), h = 0; h < r.length; h += 64) {
    Ql(c, o, t);
    for (var d = h; d < h + 64 && d < r.length; d++)
      i[d] = r[d] ^ c[d - h];
    ef(o, 0, u);
  }
  return ls.wipe(c), s === 0 && ls.wipe(o), i;
}
Oi.streamXOR = ca;
function Zl(t, e, r, i) {
  return i === void 0 && (i = 0), ls.wipe(r), ca(t, e, r, r, i);
}
Oi.stream = Zl;
function ef(t, e, r) {
  for (var i = 1; r--; )
    i = i + (t[e] & 255) | 0, t[e] = i & 255, i >>>= 8, e++;
  if (i > 0)
    throw new Error("ChaCha: counter overflow");
}
var ua = {}, Qt = {};
Object.defineProperty(Qt, "__esModule", { value: !0 });
function tf(t, e, r) {
  return ~(t - 1) & e | t - 1 & r;
}
Qt.select = tf;
function rf(t, e) {
  return (t | 0) - (e | 0) - 1 >>> 31 & 1;
}
Qt.lessOrEqual = rf;
function ha(t, e) {
  if (t.length !== e.length)
    return 0;
  for (var r = 0, i = 0; i < t.length; i++)
    r |= t[i] ^ e[i];
  return 1 & r - 1 >>> 8;
}
Qt.compare = ha;
function sf(t, e) {
  return t.length === 0 || e.length === 0 ? !1 : ha(t, e) !== 0;
}
Qt.equal = sf;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = Qt, r = mt;
  t.DIGEST_LENGTH = 16;
  var i = (
    /** @class */
    function() {
      function u(c) {
        this.digestLength = t.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
        var h = c[0] | c[1] << 8;
        this._r[0] = h & 8191;
        var d = c[2] | c[3] << 8;
        this._r[1] = (h >>> 13 | d << 3) & 8191;
        var p = c[4] | c[5] << 8;
        this._r[2] = (d >>> 10 | p << 6) & 7939;
        var E = c[6] | c[7] << 8;
        this._r[3] = (p >>> 7 | E << 9) & 8191;
        var x = c[8] | c[9] << 8;
        this._r[4] = (E >>> 4 | x << 12) & 255, this._r[5] = x >>> 1 & 8190;
        var v = c[10] | c[11] << 8;
        this._r[6] = (x >>> 14 | v << 2) & 8191;
        var I = c[12] | c[13] << 8;
        this._r[7] = (v >>> 11 | I << 5) & 8065;
        var N = c[14] | c[15] << 8;
        this._r[8] = (I >>> 8 | N << 8) & 8191, this._r[9] = N >>> 5 & 127, this._pad[0] = c[16] | c[17] << 8, this._pad[1] = c[18] | c[19] << 8, this._pad[2] = c[20] | c[21] << 8, this._pad[3] = c[22] | c[23] << 8, this._pad[4] = c[24] | c[25] << 8, this._pad[5] = c[26] | c[27] << 8, this._pad[6] = c[28] | c[29] << 8, this._pad[7] = c[30] | c[31] << 8;
      }
      return u.prototype._blocks = function(c, h, d) {
        for (var p = this._fin ? 0 : 2048, E = this._h[0], x = this._h[1], v = this._h[2], I = this._h[3], N = this._h[4], R = this._h[5], K = this._h[6], m = this._h[7], O = this._h[8], y = this._h[9], _ = this._r[0], f = this._r[1], n = this._r[2], l = this._r[3], P = this._r[4], U = this._r[5], L = this._r[6], F = this._r[7], z = this._r[8], b = this._r[9]; d >= 16; ) {
          var A = c[h + 0] | c[h + 1] << 8;
          E += A & 8191;
          var k = c[h + 2] | c[h + 3] << 8;
          x += (A >>> 13 | k << 3) & 8191;
          var B = c[h + 4] | c[h + 5] << 8;
          v += (k >>> 10 | B << 6) & 8191;
          var $ = c[h + 6] | c[h + 7] << 8;
          I += (B >>> 7 | $ << 9) & 8191;
          var q = c[h + 8] | c[h + 9] << 8;
          N += ($ >>> 4 | q << 12) & 8191, R += q >>> 1 & 8191;
          var M = c[h + 10] | c[h + 11] << 8;
          K += (q >>> 14 | M << 2) & 8191;
          var V = c[h + 12] | c[h + 13] << 8;
          m += (M >>> 11 | V << 5) & 8191;
          var te = c[h + 14] | c[h + 15] << 8;
          O += (V >>> 8 | te << 8) & 8191, y += te >>> 5 | p;
          var H = 0, Z = H;
          Z += E * _, Z += x * (5 * b), Z += v * (5 * z), Z += I * (5 * F), Z += N * (5 * L), H = Z >>> 13, Z &= 8191, Z += R * (5 * U), Z += K * (5 * P), Z += m * (5 * l), Z += O * (5 * n), Z += y * (5 * f), H += Z >>> 13, Z &= 8191;
          var J = H;
          J += E * f, J += x * _, J += v * (5 * b), J += I * (5 * z), J += N * (5 * F), H = J >>> 13, J &= 8191, J += R * (5 * L), J += K * (5 * U), J += m * (5 * P), J += O * (5 * l), J += y * (5 * n), H += J >>> 13, J &= 8191;
          var ee = H;
          ee += E * n, ee += x * f, ee += v * _, ee += I * (5 * b), ee += N * (5 * z), H = ee >>> 13, ee &= 8191, ee += R * (5 * F), ee += K * (5 * L), ee += m * (5 * U), ee += O * (5 * P), ee += y * (5 * l), H += ee >>> 13, ee &= 8191;
          var T = H;
          T += E * l, T += x * n, T += v * f, T += I * _, T += N * (5 * b), H = T >>> 13, T &= 8191, T += R * (5 * z), T += K * (5 * F), T += m * (5 * L), T += O * (5 * U), T += y * (5 * P), H += T >>> 13, T &= 8191;
          var C = H;
          C += E * P, C += x * l, C += v * n, C += I * f, C += N * _, H = C >>> 13, C &= 8191, C += R * (5 * b), C += K * (5 * z), C += m * (5 * F), C += O * (5 * L), C += y * (5 * U), H += C >>> 13, C &= 8191;
          var D = H;
          D += E * U, D += x * P, D += v * l, D += I * n, D += N * f, H = D >>> 13, D &= 8191, D += R * _, D += K * (5 * b), D += m * (5 * z), D += O * (5 * F), D += y * (5 * L), H += D >>> 13, D &= 8191;
          var a = H;
          a += E * L, a += x * U, a += v * P, a += I * l, a += N * n, H = a >>> 13, a &= 8191, a += R * f, a += K * _, a += m * (5 * b), a += O * (5 * z), a += y * (5 * F), H += a >>> 13, a &= 8191;
          var w = H;
          w += E * F, w += x * L, w += v * U, w += I * P, w += N * l, H = w >>> 13, w &= 8191, w += R * n, w += K * f, w += m * _, w += O * (5 * b), w += y * (5 * z), H += w >>> 13, w &= 8191;
          var W = H;
          W += E * z, W += x * F, W += v * L, W += I * U, W += N * P, H = W >>> 13, W &= 8191, W += R * l, W += K * n, W += m * f, W += O * _, W += y * (5 * b), H += W >>> 13, W &= 8191;
          var Y = H;
          Y += E * b, Y += x * z, Y += v * F, Y += I * L, Y += N * U, H = Y >>> 13, Y &= 8191, Y += R * P, Y += K * l, Y += m * n, Y += O * f, Y += y * _, H += Y >>> 13, Y &= 8191, H = (H << 2) + H | 0, H = H + Z | 0, Z = H & 8191, H = H >>> 13, J += H, E = Z, x = J, v = ee, I = T, N = C, R = D, K = a, m = w, O = W, y = Y, h += 16, d -= 16;
        }
        this._h[0] = E, this._h[1] = x, this._h[2] = v, this._h[3] = I, this._h[4] = N, this._h[5] = R, this._h[6] = K, this._h[7] = m, this._h[8] = O, this._h[9] = y;
      }, u.prototype.finish = function(c, h) {
        h === void 0 && (h = 0);
        var d = new Uint16Array(10), p, E, x, v;
        if (this._leftover) {
          for (v = this._leftover, this._buffer[v++] = 1; v < 16; v++)
            this._buffer[v] = 0;
          this._fin = 1, this._blocks(this._buffer, 0, 16);
        }
        for (p = this._h[1] >>> 13, this._h[1] &= 8191, v = 2; v < 10; v++)
          this._h[v] += p, p = this._h[v] >>> 13, this._h[v] &= 8191;
        for (this._h[0] += p * 5, p = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += p, p = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += p, d[0] = this._h[0] + 5, p = d[0] >>> 13, d[0] &= 8191, v = 1; v < 10; v++)
          d[v] = this._h[v] + p, p = d[v] >>> 13, d[v] &= 8191;
        for (d[9] -= 8192, E = (p ^ 1) - 1, v = 0; v < 10; v++)
          d[v] &= E;
        for (E = ~E, v = 0; v < 10; v++)
          this._h[v] = this._h[v] & E | d[v];
        for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, x = this._h[0] + this._pad[0], this._h[0] = x & 65535, v = 1; v < 8; v++)
          x = (this._h[v] + this._pad[v] | 0) + (x >>> 16) | 0, this._h[v] = x & 65535;
        return c[h + 0] = this._h[0] >>> 0, c[h + 1] = this._h[0] >>> 8, c[h + 2] = this._h[1] >>> 0, c[h + 3] = this._h[1] >>> 8, c[h + 4] = this._h[2] >>> 0, c[h + 5] = this._h[2] >>> 8, c[h + 6] = this._h[3] >>> 0, c[h + 7] = this._h[3] >>> 8, c[h + 8] = this._h[4] >>> 0, c[h + 9] = this._h[4] >>> 8, c[h + 10] = this._h[5] >>> 0, c[h + 11] = this._h[5] >>> 8, c[h + 12] = this._h[6] >>> 0, c[h + 13] = this._h[6] >>> 8, c[h + 14] = this._h[7] >>> 0, c[h + 15] = this._h[7] >>> 8, this._finished = !0, this;
      }, u.prototype.update = function(c) {
        var h = 0, d = c.length, p;
        if (this._leftover) {
          p = 16 - this._leftover, p > d && (p = d);
          for (var E = 0; E < p; E++)
            this._buffer[this._leftover + E] = c[h + E];
          if (d -= p, h += p, this._leftover += p, this._leftover < 16)
            return this;
          this._blocks(this._buffer, 0, 16), this._leftover = 0;
        }
        if (d >= 16 && (p = d - d % 16, this._blocks(c, h, p), h += p, d -= p), d) {
          for (var E = 0; E < d; E++)
            this._buffer[this._leftover + E] = c[h + E];
          this._leftover += d;
        }
        return this;
      }, u.prototype.digest = function() {
        if (this._finished)
          throw new Error("Poly1305 was finished");
        var c = new Uint8Array(16);
        return this.finish(c), c;
      }, u.prototype.clean = function() {
        return r.wipe(this._buffer), r.wipe(this._r), r.wipe(this._h), r.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this;
      }, u;
    }()
  );
  t.Poly1305 = i;
  function s(u, c) {
    var h = new i(u);
    h.update(c);
    var d = h.digest();
    return h.clean(), d;
  }
  t.oneTimeAuth = s;
  function o(u, c) {
    return u.length !== t.DIGEST_LENGTH || c.length !== t.DIGEST_LENGTH ? !1 : e.equal(u, c);
  }
  t.equal = o;
})(ua);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = Oi, r = ua, i = mt, s = se, o = Qt;
  t.KEY_LENGTH = 32, t.NONCE_LENGTH = 12, t.TAG_LENGTH = 16;
  var u = new Uint8Array(16), c = (
    /** @class */
    function() {
      function h(d) {
        if (this.nonceLength = t.NONCE_LENGTH, this.tagLength = t.TAG_LENGTH, d.length !== t.KEY_LENGTH)
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        this._key = new Uint8Array(d);
      }
      return h.prototype.seal = function(d, p, E, x) {
        if (d.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        var v = new Uint8Array(16);
        v.set(d, v.length - d.length);
        var I = new Uint8Array(32);
        e.stream(this._key, v, I, 4);
        var N = p.length + this.tagLength, R;
        if (x) {
          if (x.length !== N)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          R = x;
        } else
          R = new Uint8Array(N);
        return e.streamXOR(this._key, v, p, R, 4), this._authenticate(R.subarray(R.length - this.tagLength, R.length), I, R.subarray(0, R.length - this.tagLength), E), i.wipe(v), R;
      }, h.prototype.open = function(d, p, E, x) {
        if (d.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        if (p.length < this.tagLength)
          return null;
        var v = new Uint8Array(16);
        v.set(d, v.length - d.length);
        var I = new Uint8Array(32);
        e.stream(this._key, v, I, 4);
        var N = new Uint8Array(this.tagLength);
        if (this._authenticate(N, I, p.subarray(0, p.length - this.tagLength), E), !o.equal(N, p.subarray(p.length - this.tagLength, p.length)))
          return null;
        var R = p.length - this.tagLength, K;
        if (x) {
          if (x.length !== R)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          K = x;
        } else
          K = new Uint8Array(R);
        return e.streamXOR(this._key, v, p.subarray(0, p.length - this.tagLength), K, 4), i.wipe(v), K;
      }, h.prototype.clean = function() {
        return i.wipe(this._key), this;
      }, h.prototype._authenticate = function(d, p, E, x) {
        var v = new r.Poly1305(p);
        x && (v.update(x), x.length % 16 > 0 && v.update(u.subarray(x.length % 16))), v.update(E), E.length % 16 > 0 && v.update(u.subarray(E.length % 16));
        var I = new Uint8Array(8);
        x && s.writeUint64LE(x.length, I), v.update(I), s.writeUint64LE(E.length, I), v.update(I);
        for (var N = v.digest(), R = 0; R < N.length; R++)
          d[R] = N[R];
        v.clean(), i.wipe(N), i.wipe(I);
      }, h;
    }()
  );
  t.ChaCha20Poly1305 = c;
})(Is);
var la = {}, Xr = {}, xs = {};
Object.defineProperty(xs, "__esModule", { value: !0 });
function nf(t) {
  return typeof t.saveState < "u" && typeof t.restoreState < "u" && typeof t.cleanSavedState < "u";
}
xs.isSerializableHash = nf;
Object.defineProperty(Xr, "__esModule", { value: !0 });
var Ut = xs, of = Qt, af = mt, fa = (
  /** @class */
  function() {
    function t(e, r) {
      this._finished = !1, this._inner = new e(), this._outer = new e(), this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
      var i = new Uint8Array(this.blockSize);
      r.length > this.blockSize ? this._inner.update(r).finish(i).clean() : i.set(r);
      for (var s = 0; s < i.length; s++)
        i[s] ^= 54;
      this._inner.update(i);
      for (var s = 0; s < i.length; s++)
        i[s] ^= 106;
      this._outer.update(i), Ut.isSerializableHash(this._inner) && Ut.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), af.wipe(i);
    }
    return t.prototype.reset = function() {
      if (!Ut.isSerializableHash(this._inner) || !Ut.isSerializableHash(this._outer))
        throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, t.prototype.clean = function() {
      Ut.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), Ut.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean();
    }, t.prototype.update = function(e) {
      return this._inner.update(e), this;
    }, t.prototype.finish = function(e) {
      return this._finished ? (this._outer.finish(e), this) : (this._inner.finish(e), this._outer.update(e.subarray(0, this.digestLength)).finish(e), this._finished = !0, this);
    }, t.prototype.digest = function() {
      var e = new Uint8Array(this.digestLength);
      return this.finish(e), e;
    }, t.prototype.saveState = function() {
      if (!Ut.isSerializableHash(this._inner))
        throw new Error("hmac: can't saveState() because hash doesn't implement it");
      return this._inner.saveState();
    }, t.prototype.restoreState = function(e) {
      if (!Ut.isSerializableHash(this._inner) || !Ut.isSerializableHash(this._outer))
        throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      return this._inner.restoreState(e), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, t.prototype.cleanSavedState = function(e) {
      if (!Ut.isSerializableHash(this._inner))
        throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      this._inner.cleanSavedState(e);
    }, t;
  }()
);
Xr.HMAC = fa;
function cf(t, e, r) {
  var i = new fa(t, e);
  i.update(r);
  var s = i.digest();
  return i.clean(), s;
}
Xr.hmac = cf;
Xr.equal = of.equal;
Object.defineProperty(la, "__esModule", { value: !0 });
var Bn = Xr, qn = mt, uf = (
  /** @class */
  function() {
    function t(e, r, i, s) {
      i === void 0 && (i = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = e, this._info = s;
      var o = Bn.hmac(this._hash, i, r);
      this._hmac = new Bn.HMAC(e, o), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length;
    }
    return t.prototype._fillBuffer = function() {
      this._counter[0]++;
      var e = this._counter[0];
      if (e === 0)
        throw new Error("hkdf: cannot expand more");
      this._hmac.reset(), e > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0;
    }, t.prototype.expand = function(e) {
      for (var r = new Uint8Array(e), i = 0; i < r.length; i++)
        this._bufpos === this._buffer.length && this._fillBuffer(), r[i] = this._buffer[this._bufpos++];
      return r;
    }, t.prototype.clean = function() {
      this._hmac.clean(), qn.wipe(this._buffer), qn.wipe(this._counter), this._bufpos = 0;
    }, t;
  }()
), hf = la.HKDF = uf, Ai = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = se, r = mt;
  t.DIGEST_LENGTH = 32, t.BLOCK_SIZE = 64;
  var i = (
    /** @class */
    function() {
      function c() {
        this.digestLength = t.DIGEST_LENGTH, this.blockSize = t.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return c.prototype._initState = function() {
        this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225;
      }, c.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, c.prototype.clean = function() {
        r.wipe(this._buffer), r.wipe(this._temp), this.reset();
      }, c.prototype.update = function(h, d) {
        if (d === void 0 && (d = h.length), this._finished)
          throw new Error("SHA256: can't update because hash was finished.");
        var p = 0;
        if (this._bytesHashed += d, this._bufferLength > 0) {
          for (; this._bufferLength < this.blockSize && d > 0; )
            this._buffer[this._bufferLength++] = h[p++], d--;
          this._bufferLength === this.blockSize && (o(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (d >= this.blockSize && (p = o(this._temp, this._state, h, p, d), d %= this.blockSize); d > 0; )
          this._buffer[this._bufferLength++] = h[p++], d--;
        return this;
      }, c.prototype.finish = function(h) {
        if (!this._finished) {
          var d = this._bytesHashed, p = this._bufferLength, E = d / 536870912 | 0, x = d << 3, v = d % 64 < 56 ? 64 : 128;
          this._buffer[p] = 128;
          for (var I = p + 1; I < v - 8; I++)
            this._buffer[I] = 0;
          e.writeUint32BE(E, this._buffer, v - 8), e.writeUint32BE(x, this._buffer, v - 4), o(this._temp, this._state, this._buffer, 0, v), this._finished = !0;
        }
        for (var I = 0; I < this.digestLength / 4; I++)
          e.writeUint32BE(this._state[I], h, I * 4);
        return this;
      }, c.prototype.digest = function() {
        var h = new Uint8Array(this.digestLength);
        return this.finish(h), h;
      }, c.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, c.prototype.restoreState = function(h) {
        return this._state.set(h.state), this._bufferLength = h.bufferLength, h.buffer && this._buffer.set(h.buffer), this._bytesHashed = h.bytesHashed, this._finished = !1, this;
      }, c.prototype.cleanSavedState = function(h) {
        r.wipe(h.state), h.buffer && r.wipe(h.buffer), h.bufferLength = 0, h.bytesHashed = 0;
      }, c;
    }()
  );
  t.SHA256 = i;
  var s = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function o(c, h, d, p, E) {
    for (; E >= 64; ) {
      for (var x = h[0], v = h[1], I = h[2], N = h[3], R = h[4], K = h[5], m = h[6], O = h[7], y = 0; y < 16; y++) {
        var _ = p + y * 4;
        c[y] = e.readUint32BE(d, _);
      }
      for (var y = 16; y < 64; y++) {
        var f = c[y - 2], n = (f >>> 17 | f << 32 - 17) ^ (f >>> 19 | f << 32 - 19) ^ f >>> 10;
        f = c[y - 15];
        var l = (f >>> 7 | f << 32 - 7) ^ (f >>> 18 | f << 32 - 18) ^ f >>> 3;
        c[y] = (n + c[y - 7] | 0) + (l + c[y - 16] | 0);
      }
      for (var y = 0; y < 64; y++) {
        var n = (((R >>> 6 | R << 26) ^ (R >>> 11 | R << 21) ^ (R >>> 25 | R << 7)) + (R & K ^ ~R & m) | 0) + (O + (s[y] + c[y] | 0) | 0) | 0, l = ((x >>> 2 | x << 32 - 2) ^ (x >>> 13 | x << 32 - 13) ^ (x >>> 22 | x << 32 - 22)) + (x & v ^ x & I ^ v & I) | 0;
        O = m, m = K, K = R, R = N + n | 0, N = I, I = v, v = x, x = n + l | 0;
      }
      h[0] += x, h[1] += v, h[2] += I, h[3] += N, h[4] += R, h[5] += K, h[6] += m, h[7] += O, p += 64, E -= 64;
    }
    return p;
  }
  function u(c) {
    var h = new i();
    h.update(c);
    var d = h.digest();
    return h.clean(), d;
  }
  t.hash = u;
})(Ai);
var Os = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.sharedKey = t.generateKeyPair = t.generateKeyPairFromSeed = t.scalarMultBase = t.scalarMult = t.SHARED_KEY_LENGTH = t.SECRET_KEY_LENGTH = t.PUBLIC_KEY_LENGTH = void 0;
  const e = Ir, r = mt;
  t.PUBLIC_KEY_LENGTH = 32, t.SECRET_KEY_LENGTH = 32, t.SHARED_KEY_LENGTH = 32;
  function i(y) {
    const _ = new Float64Array(16);
    if (y)
      for (let f = 0; f < y.length; f++)
        _[f] = y[f];
    return _;
  }
  const s = new Uint8Array(32);
  s[0] = 9;
  const o = i([56129, 1]);
  function u(y) {
    let _ = 1;
    for (let f = 0; f < 16; f++) {
      let n = y[f] + _ + 65535;
      _ = Math.floor(n / 65536), y[f] = n - _ * 65536;
    }
    y[0] += _ - 1 + 37 * (_ - 1);
  }
  function c(y, _, f) {
    const n = ~(f - 1);
    for (let l = 0; l < 16; l++) {
      const P = n & (y[l] ^ _[l]);
      y[l] ^= P, _[l] ^= P;
    }
  }
  function h(y, _) {
    const f = i(), n = i();
    for (let l = 0; l < 16; l++)
      n[l] = _[l];
    u(n), u(n), u(n);
    for (let l = 0; l < 2; l++) {
      f[0] = n[0] - 65517;
      for (let U = 1; U < 15; U++)
        f[U] = n[U] - 65535 - (f[U - 1] >> 16 & 1), f[U - 1] &= 65535;
      f[15] = n[15] - 32767 - (f[14] >> 16 & 1);
      const P = f[15] >> 16 & 1;
      f[14] &= 65535, c(n, f, 1 - P);
    }
    for (let l = 0; l < 16; l++)
      y[2 * l] = n[l] & 255, y[2 * l + 1] = n[l] >> 8;
  }
  function d(y, _) {
    for (let f = 0; f < 16; f++)
      y[f] = _[2 * f] + (_[2 * f + 1] << 8);
    y[15] &= 32767;
  }
  function p(y, _, f) {
    for (let n = 0; n < 16; n++)
      y[n] = _[n] + f[n];
  }
  function E(y, _, f) {
    for (let n = 0; n < 16; n++)
      y[n] = _[n] - f[n];
  }
  function x(y, _, f) {
    let n, l, P = 0, U = 0, L = 0, F = 0, z = 0, b = 0, A = 0, k = 0, B = 0, $ = 0, q = 0, M = 0, V = 0, te = 0, H = 0, Z = 0, J = 0, ee = 0, T = 0, C = 0, D = 0, a = 0, w = 0, W = 0, Y = 0, le = 0, be = 0, de = 0, ve = 0, Le = 0, Te = 0, ye = f[0], pe = f[1], fe = f[2], ue = f[3], ce = f[4], ae = f[5], oe = f[6], re = f[7], he = f[8], ge = f[9], ie = f[10], we = f[11], me = f[12], De = f[13], Se = f[14], Ee = f[15];
    n = _[0], P += n * ye, U += n * pe, L += n * fe, F += n * ue, z += n * ce, b += n * ae, A += n * oe, k += n * re, B += n * he, $ += n * ge, q += n * ie, M += n * we, V += n * me, te += n * De, H += n * Se, Z += n * Ee, n = _[1], U += n * ye, L += n * pe, F += n * fe, z += n * ue, b += n * ce, A += n * ae, k += n * oe, B += n * re, $ += n * he, q += n * ge, M += n * ie, V += n * we, te += n * me, H += n * De, Z += n * Se, J += n * Ee, n = _[2], L += n * ye, F += n * pe, z += n * fe, b += n * ue, A += n * ce, k += n * ae, B += n * oe, $ += n * re, q += n * he, M += n * ge, V += n * ie, te += n * we, H += n * me, Z += n * De, J += n * Se, ee += n * Ee, n = _[3], F += n * ye, z += n * pe, b += n * fe, A += n * ue, k += n * ce, B += n * ae, $ += n * oe, q += n * re, M += n * he, V += n * ge, te += n * ie, H += n * we, Z += n * me, J += n * De, ee += n * Se, T += n * Ee, n = _[4], z += n * ye, b += n * pe, A += n * fe, k += n * ue, B += n * ce, $ += n * ae, q += n * oe, M += n * re, V += n * he, te += n * ge, H += n * ie, Z += n * we, J += n * me, ee += n * De, T += n * Se, C += n * Ee, n = _[5], b += n * ye, A += n * pe, k += n * fe, B += n * ue, $ += n * ce, q += n * ae, M += n * oe, V += n * re, te += n * he, H += n * ge, Z += n * ie, J += n * we, ee += n * me, T += n * De, C += n * Se, D += n * Ee, n = _[6], A += n * ye, k += n * pe, B += n * fe, $ += n * ue, q += n * ce, M += n * ae, V += n * oe, te += n * re, H += n * he, Z += n * ge, J += n * ie, ee += n * we, T += n * me, C += n * De, D += n * Se, a += n * Ee, n = _[7], k += n * ye, B += n * pe, $ += n * fe, q += n * ue, M += n * ce, V += n * ae, te += n * oe, H += n * re, Z += n * he, J += n * ge, ee += n * ie, T += n * we, C += n * me, D += n * De, a += n * Se, w += n * Ee, n = _[8], B += n * ye, $ += n * pe, q += n * fe, M += n * ue, V += n * ce, te += n * ae, H += n * oe, Z += n * re, J += n * he, ee += n * ge, T += n * ie, C += n * we, D += n * me, a += n * De, w += n * Se, W += n * Ee, n = _[9], $ += n * ye, q += n * pe, M += n * fe, V += n * ue, te += n * ce, H += n * ae, Z += n * oe, J += n * re, ee += n * he, T += n * ge, C += n * ie, D += n * we, a += n * me, w += n * De, W += n * Se, Y += n * Ee, n = _[10], q += n * ye, M += n * pe, V += n * fe, te += n * ue, H += n * ce, Z += n * ae, J += n * oe, ee += n * re, T += n * he, C += n * ge, D += n * ie, a += n * we, w += n * me, W += n * De, Y += n * Se, le += n * Ee, n = _[11], M += n * ye, V += n * pe, te += n * fe, H += n * ue, Z += n * ce, J += n * ae, ee += n * oe, T += n * re, C += n * he, D += n * ge, a += n * ie, w += n * we, W += n * me, Y += n * De, le += n * Se, be += n * Ee, n = _[12], V += n * ye, te += n * pe, H += n * fe, Z += n * ue, J += n * ce, ee += n * ae, T += n * oe, C += n * re, D += n * he, a += n * ge, w += n * ie, W += n * we, Y += n * me, le += n * De, be += n * Se, de += n * Ee, n = _[13], te += n * ye, H += n * pe, Z += n * fe, J += n * ue, ee += n * ce, T += n * ae, C += n * oe, D += n * re, a += n * he, w += n * ge, W += n * ie, Y += n * we, le += n * me, be += n * De, de += n * Se, ve += n * Ee, n = _[14], H += n * ye, Z += n * pe, J += n * fe, ee += n * ue, T += n * ce, C += n * ae, D += n * oe, a += n * re, w += n * he, W += n * ge, Y += n * ie, le += n * we, be += n * me, de += n * De, ve += n * Se, Le += n * Ee, n = _[15], Z += n * ye, J += n * pe, ee += n * fe, T += n * ue, C += n * ce, D += n * ae, a += n * oe, w += n * re, W += n * he, Y += n * ge, le += n * ie, be += n * we, de += n * me, ve += n * De, Le += n * Se, Te += n * Ee, P += 38 * J, U += 38 * ee, L += 38 * T, F += 38 * C, z += 38 * D, b += 38 * a, A += 38 * w, k += 38 * W, B += 38 * Y, $ += 38 * le, q += 38 * be, M += 38 * de, V += 38 * ve, te += 38 * Le, H += 38 * Te, l = 1, n = P + l + 65535, l = Math.floor(n / 65536), P = n - l * 65536, n = U + l + 65535, l = Math.floor(n / 65536), U = n - l * 65536, n = L + l + 65535, l = Math.floor(n / 65536), L = n - l * 65536, n = F + l + 65535, l = Math.floor(n / 65536), F = n - l * 65536, n = z + l + 65535, l = Math.floor(n / 65536), z = n - l * 65536, n = b + l + 65535, l = Math.floor(n / 65536), b = n - l * 65536, n = A + l + 65535, l = Math.floor(n / 65536), A = n - l * 65536, n = k + l + 65535, l = Math.floor(n / 65536), k = n - l * 65536, n = B + l + 65535, l = Math.floor(n / 65536), B = n - l * 65536, n = $ + l + 65535, l = Math.floor(n / 65536), $ = n - l * 65536, n = q + l + 65535, l = Math.floor(n / 65536), q = n - l * 65536, n = M + l + 65535, l = Math.floor(n / 65536), M = n - l * 65536, n = V + l + 65535, l = Math.floor(n / 65536), V = n - l * 65536, n = te + l + 65535, l = Math.floor(n / 65536), te = n - l * 65536, n = H + l + 65535, l = Math.floor(n / 65536), H = n - l * 65536, n = Z + l + 65535, l = Math.floor(n / 65536), Z = n - l * 65536, P += l - 1 + 37 * (l - 1), l = 1, n = P + l + 65535, l = Math.floor(n / 65536), P = n - l * 65536, n = U + l + 65535, l = Math.floor(n / 65536), U = n - l * 65536, n = L + l + 65535, l = Math.floor(n / 65536), L = n - l * 65536, n = F + l + 65535, l = Math.floor(n / 65536), F = n - l * 65536, n = z + l + 65535, l = Math.floor(n / 65536), z = n - l * 65536, n = b + l + 65535, l = Math.floor(n / 65536), b = n - l * 65536, n = A + l + 65535, l = Math.floor(n / 65536), A = n - l * 65536, n = k + l + 65535, l = Math.floor(n / 65536), k = n - l * 65536, n = B + l + 65535, l = Math.floor(n / 65536), B = n - l * 65536, n = $ + l + 65535, l = Math.floor(n / 65536), $ = n - l * 65536, n = q + l + 65535, l = Math.floor(n / 65536), q = n - l * 65536, n = M + l + 65535, l = Math.floor(n / 65536), M = n - l * 65536, n = V + l + 65535, l = Math.floor(n / 65536), V = n - l * 65536, n = te + l + 65535, l = Math.floor(n / 65536), te = n - l * 65536, n = H + l + 65535, l = Math.floor(n / 65536), H = n - l * 65536, n = Z + l + 65535, l = Math.floor(n / 65536), Z = n - l * 65536, P += l - 1 + 37 * (l - 1), y[0] = P, y[1] = U, y[2] = L, y[3] = F, y[4] = z, y[5] = b, y[6] = A, y[7] = k, y[8] = B, y[9] = $, y[10] = q, y[11] = M, y[12] = V, y[13] = te, y[14] = H, y[15] = Z;
  }
  function v(y, _) {
    x(y, _, _);
  }
  function I(y, _) {
    const f = i();
    for (let n = 0; n < 16; n++)
      f[n] = _[n];
    for (let n = 253; n >= 0; n--)
      v(f, f), n !== 2 && n !== 4 && x(f, f, _);
    for (let n = 0; n < 16; n++)
      y[n] = f[n];
  }
  function N(y, _) {
    const f = new Uint8Array(32), n = new Float64Array(80), l = i(), P = i(), U = i(), L = i(), F = i(), z = i();
    for (let B = 0; B < 31; B++)
      f[B] = y[B];
    f[31] = y[31] & 127 | 64, f[0] &= 248, d(n, _);
    for (let B = 0; B < 16; B++)
      P[B] = n[B];
    l[0] = L[0] = 1;
    for (let B = 254; B >= 0; --B) {
      const $ = f[B >>> 3] >>> (B & 7) & 1;
      c(l, P, $), c(U, L, $), p(F, l, U), E(l, l, U), p(U, P, L), E(P, P, L), v(L, F), v(z, l), x(l, U, l), x(U, P, F), p(F, l, U), E(l, l, U), v(P, l), E(U, L, z), x(l, U, o), p(l, l, L), x(U, U, l), x(l, L, z), x(L, P, n), v(P, F), c(l, P, $), c(U, L, $);
    }
    for (let B = 0; B < 16; B++)
      n[B + 16] = l[B], n[B + 32] = U[B], n[B + 48] = P[B], n[B + 64] = L[B];
    const b = n.subarray(32), A = n.subarray(16);
    I(b, b), x(A, A, b);
    const k = new Uint8Array(32);
    return h(k, A), k;
  }
  t.scalarMult = N;
  function R(y) {
    return N(y, s);
  }
  t.scalarMultBase = R;
  function K(y) {
    if (y.length !== t.SECRET_KEY_LENGTH)
      throw new Error(`x25519: seed must be ${t.SECRET_KEY_LENGTH} bytes`);
    const _ = new Uint8Array(y);
    return {
      publicKey: R(_),
      secretKey: _
    };
  }
  t.generateKeyPairFromSeed = K;
  function m(y) {
    const _ = (0, e.randomBytes)(32, y), f = K(_);
    return (0, r.wipe)(_), f;
  }
  t.generateKeyPair = m;
  function O(y, _, f = !1) {
    if (y.length !== t.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect secret key length");
    if (_.length !== t.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect public key length");
    const n = N(y, _);
    if (f) {
      let l = 0;
      for (let P = 0; P < n.length; P++)
        l |= n[P];
      if (l === 0)
        throw new Error("X25519: invalid shared key");
    }
    return n;
  }
  t.sharedKey = O;
})(Os);
var zn = globalThis && globalThis.__spreadArray || function(t, e, r) {
  if (r || arguments.length === 2)
    for (var i = 0, s = e.length, o; i < s; i++)
      (o || !(i in e)) && (o || (o = Array.prototype.slice.call(e, 0, i)), o[i] = e[i]);
  return t.concat(o || Array.prototype.slice.call(e));
}, lf = (
  /** @class */
  function() {
    function t(e, r, i) {
      this.name = e, this.version = r, this.os = i, this.type = "browser";
    }
    return t;
  }()
), ff = (
  /** @class */
  function() {
    function t(e) {
      this.version = e, this.type = "node", this.name = "node", this.os = process.platform;
    }
    return t;
  }()
), df = (
  /** @class */
  function() {
    function t(e, r, i, s) {
      this.name = e, this.version = r, this.os = i, this.bot = s, this.type = "bot-device";
    }
    return t;
  }()
), pf = (
  /** @class */
  function() {
    function t() {
      this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null;
    }
    return t;
  }()
), gf = (
  /** @class */
  function() {
    function t() {
      this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
    }
    return t;
  }()
), yf = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, bf = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, Kn = 3, wf = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", yf]
], Vn = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function _f(t) {
  return t ? Hn(t) : typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new gf() : typeof navigator < "u" ? Hn(navigator.userAgent) : Ef();
}
function mf(t) {
  return t !== "" && wf.reduce(function(e, r) {
    var i = r[0], s = r[1];
    if (e)
      return e;
    var o = s.exec(t);
    return !!o && [i, o];
  }, !1);
}
function Hn(t) {
  var e = mf(t);
  if (!e)
    return null;
  var r = e[0], i = e[1];
  if (r === "searchbot")
    return new pf();
  var s = i[1] && i[1].split(".").join("_").split("_").slice(0, 3);
  s ? s.length < Kn && (s = zn(zn([], s, !0), Df(Kn - s.length), !0)) : s = [];
  var o = s.join("."), u = vf(t), c = bf.exec(t);
  return c && c[1] ? new df(r, o, u, c[1]) : new lf(r, o, u);
}
function vf(t) {
  for (var e = 0, r = Vn.length; e < r; e++) {
    var i = Vn[e], s = i[0], o = i[1], u = o.exec(t);
    if (u)
      return s;
  }
  return null;
}
function Ef() {
  var t = typeof process < "u" && process.version;
  return t ? new ff(process.version.slice(1)) : null;
}
function Df(t) {
  for (var e = [], r = 0; r < t; r++)
    e.push("0");
  return e;
}
var Ie = {};
Object.defineProperty(Ie, "__esModule", { value: !0 });
Ie.getLocalStorage = Ie.getLocalStorageOrThrow = Ie.getCrypto = Ie.getCryptoOrThrow = pa = Ie.getLocation = Ie.getLocationOrThrow = As = Ie.getNavigator = Ie.getNavigatorOrThrow = da = Ie.getDocument = Ie.getDocumentOrThrow = Ie.getFromWindowOrThrow = Ie.getFromWindow = void 0;
function pr(t) {
  let e;
  return typeof window < "u" && typeof window[t] < "u" && (e = window[t]), e;
}
Ie.getFromWindow = pr;
function xr(t) {
  const e = pr(t);
  if (!e)
    throw new Error(`${t} is not defined in Window`);
  return e;
}
Ie.getFromWindowOrThrow = xr;
function Sf() {
  return xr("document");
}
Ie.getDocumentOrThrow = Sf;
function If() {
  return pr("document");
}
var da = Ie.getDocument = If;
function xf() {
  return xr("navigator");
}
Ie.getNavigatorOrThrow = xf;
function Of() {
  return pr("navigator");
}
var As = Ie.getNavigator = Of;
function Af() {
  return xr("location");
}
Ie.getLocationOrThrow = Af;
function Cf() {
  return pr("location");
}
var pa = Ie.getLocation = Cf;
function Tf() {
  return xr("crypto");
}
Ie.getCryptoOrThrow = Tf;
function Nf() {
  return pr("crypto");
}
Ie.getCrypto = Nf;
function Rf() {
  return xr("localStorage");
}
Ie.getLocalStorageOrThrow = Rf;
function Pf() {
  return pr("localStorage");
}
Ie.getLocalStorage = Pf;
var Cs = {};
Object.defineProperty(Cs, "__esModule", { value: !0 });
var ga = Cs.getWindowMetadata = void 0;
const Wn = Ie;
function Uf() {
  let t, e;
  try {
    t = Wn.getDocumentOrThrow(), e = Wn.getLocationOrThrow();
  } catch {
    return null;
  }
  function r() {
    const E = t.getElementsByTagName("link"), x = [];
    for (let v = 0; v < E.length; v++) {
      const I = E[v], N = I.getAttribute("rel");
      if (N && N.toLowerCase().indexOf("icon") > -1) {
        const R = I.getAttribute("href");
        if (R)
          if (R.toLowerCase().indexOf("https:") === -1 && R.toLowerCase().indexOf("http:") === -1 && R.indexOf("//") !== 0) {
            let K = e.protocol + "//" + e.host;
            if (R.indexOf("/") === 0)
              K += R;
            else {
              const m = e.pathname.split("/");
              m.pop();
              const O = m.join("/");
              K += O + "/" + R;
            }
            x.push(K);
          } else if (R.indexOf("//") === 0) {
            const K = e.protocol + R;
            x.push(K);
          } else
            x.push(R);
      }
    }
    return x;
  }
  function i(...E) {
    const x = t.getElementsByTagName("meta");
    for (let v = 0; v < x.length; v++) {
      const I = x[v], N = ["itemprop", "property", "name"].map((R) => I.getAttribute(R)).filter((R) => R ? E.includes(R) : !1);
      if (N.length && N) {
        const R = I.getAttribute("content");
        if (R)
          return R;
      }
    }
    return "";
  }
  function s() {
    let E = i("name", "og:site_name", "og:title", "twitter:title");
    return E || (E = t.title), E;
  }
  function o() {
    return i("description", "og:description", "twitter:description", "keywords");
  }
  const u = s(), c = o(), h = e.origin, d = r();
  return {
    description: c,
    url: h,
    icons: d,
    name: u
  };
}
ga = Cs.getWindowMetadata = Uf;
var Gr = {}, Lf = (t) => encodeURIComponent(t).replace(/[!'()*]/g, (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`), ya = "%[a-f0-9]{2}", kn = new RegExp("(" + ya + ")|([^%]+?)", "gi"), Gn = new RegExp("(" + ya + ")+", "gi");
function fs(t, e) {
  try {
    return [decodeURIComponent(t.join(""))];
  } catch {
  }
  if (t.length === 1)
    return t;
  e = e || 1;
  var r = t.slice(0, e), i = t.slice(e);
  return Array.prototype.concat.call([], fs(r), fs(i));
}
function Ff(t) {
  try {
    return decodeURIComponent(t);
  } catch {
    for (var e = t.match(kn) || [], r = 1; r < e.length; r++)
      t = fs(e, r).join(""), e = t.match(kn) || [];
    return t;
  }
}
function Mf(t) {
  for (var e = {
    "%FE%FF": "",
    "%FF%FE": ""
  }, r = Gn.exec(t); r; ) {
    try {
      e[r[0]] = decodeURIComponent(r[0]);
    } catch {
      var i = Ff(r[0]);
      i !== r[0] && (e[r[0]] = i);
    }
    r = Gn.exec(t);
  }
  e["%C2"] = "";
  for (var s = Object.keys(e), o = 0; o < s.length; o++) {
    var u = s[o];
    t = t.replace(new RegExp(u, "g"), e[u]);
  }
  return t;
}
var $f = function(t) {
  if (typeof t != "string")
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof t + "`");
  try {
    return t = t.replace(/\+/g, " "), decodeURIComponent(t);
  } catch {
    return Mf(t);
  }
}, jf = (t, e) => {
  if (!(typeof t == "string" && typeof e == "string"))
    throw new TypeError("Expected the arguments to be of type `string`");
  if (e === "")
    return [t];
  const r = t.indexOf(e);
  return r === -1 ? [t] : [
    t.slice(0, r),
    t.slice(r + e.length)
  ];
}, Bf = function(t, e) {
  for (var r = {}, i = Object.keys(t), s = Array.isArray(e), o = 0; o < i.length; o++) {
    var u = i[o], c = t[u];
    (s ? e.indexOf(u) !== -1 : e(u, c, t)) && (r[u] = c);
  }
  return r;
};
(function(t) {
  const e = Lf, r = $f, i = jf, s = Bf, o = (m) => m == null, u = Symbol("encodeFragmentIdentifier");
  function c(m) {
    switch (m.arrayFormat) {
      case "index":
        return (O) => (y, _) => {
          const f = y.length;
          return _ === void 0 || m.skipNull && _ === null || m.skipEmptyString && _ === "" ? y : _ === null ? [...y, [p(O, m), "[", f, "]"].join("")] : [
            ...y,
            [p(O, m), "[", p(f, m), "]=", p(_, m)].join("")
          ];
        };
      case "bracket":
        return (O) => (y, _) => _ === void 0 || m.skipNull && _ === null || m.skipEmptyString && _ === "" ? y : _ === null ? [...y, [p(O, m), "[]"].join("")] : [...y, [p(O, m), "[]=", p(_, m)].join("")];
      case "colon-list-separator":
        return (O) => (y, _) => _ === void 0 || m.skipNull && _ === null || m.skipEmptyString && _ === "" ? y : _ === null ? [...y, [p(O, m), ":list="].join("")] : [...y, [p(O, m), ":list=", p(_, m)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const O = m.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (y) => (_, f) => f === void 0 || m.skipNull && f === null || m.skipEmptyString && f === "" ? _ : (f = f === null ? "" : f, _.length === 0 ? [[p(y, m), O, p(f, m)].join("")] : [[_, p(f, m)].join(m.arrayFormatSeparator)]);
      }
      default:
        return (O) => (y, _) => _ === void 0 || m.skipNull && _ === null || m.skipEmptyString && _ === "" ? y : _ === null ? [...y, p(O, m)] : [...y, [p(O, m), "=", p(_, m)].join("")];
    }
  }
  function h(m) {
    let O;
    switch (m.arrayFormat) {
      case "index":
        return (y, _, f) => {
          if (O = /\[(\d*)\]$/.exec(y), y = y.replace(/\[\d*\]$/, ""), !O) {
            f[y] = _;
            return;
          }
          f[y] === void 0 && (f[y] = {}), f[y][O[1]] = _;
        };
      case "bracket":
        return (y, _, f) => {
          if (O = /(\[\])$/.exec(y), y = y.replace(/\[\]$/, ""), !O) {
            f[y] = _;
            return;
          }
          if (f[y] === void 0) {
            f[y] = [_];
            return;
          }
          f[y] = [].concat(f[y], _);
        };
      case "colon-list-separator":
        return (y, _, f) => {
          if (O = /(:list)$/.exec(y), y = y.replace(/:list$/, ""), !O) {
            f[y] = _;
            return;
          }
          if (f[y] === void 0) {
            f[y] = [_];
            return;
          }
          f[y] = [].concat(f[y], _);
        };
      case "comma":
      case "separator":
        return (y, _, f) => {
          const n = typeof _ == "string" && _.includes(m.arrayFormatSeparator), l = typeof _ == "string" && !n && E(_, m).includes(m.arrayFormatSeparator);
          _ = l ? E(_, m) : _;
          const P = n || l ? _.split(m.arrayFormatSeparator).map((U) => E(U, m)) : _ === null ? _ : E(_, m);
          f[y] = P;
        };
      case "bracket-separator":
        return (y, _, f) => {
          const n = /(\[\])$/.test(y);
          if (y = y.replace(/\[\]$/, ""), !n) {
            f[y] = _ && E(_, m);
            return;
          }
          const l = _ === null ? [] : _.split(m.arrayFormatSeparator).map((P) => E(P, m));
          if (f[y] === void 0) {
            f[y] = l;
            return;
          }
          f[y] = [].concat(f[y], l);
        };
      default:
        return (y, _, f) => {
          if (f[y] === void 0) {
            f[y] = _;
            return;
          }
          f[y] = [].concat(f[y], _);
        };
    }
  }
  function d(m) {
    if (typeof m != "string" || m.length !== 1)
      throw new TypeError("arrayFormatSeparator must be single character string");
  }
  function p(m, O) {
    return O.encode ? O.strict ? e(m) : encodeURIComponent(m) : m;
  }
  function E(m, O) {
    return O.decode ? r(m) : m;
  }
  function x(m) {
    return Array.isArray(m) ? m.sort() : typeof m == "object" ? x(Object.keys(m)).sort((O, y) => Number(O) - Number(y)).map((O) => m[O]) : m;
  }
  function v(m) {
    const O = m.indexOf("#");
    return O !== -1 && (m = m.slice(0, O)), m;
  }
  function I(m) {
    let O = "";
    const y = m.indexOf("#");
    return y !== -1 && (O = m.slice(y)), O;
  }
  function N(m) {
    m = v(m);
    const O = m.indexOf("?");
    return O === -1 ? "" : m.slice(O + 1);
  }
  function R(m, O) {
    return O.parseNumbers && !Number.isNaN(Number(m)) && typeof m == "string" && m.trim() !== "" ? m = Number(m) : O.parseBooleans && m !== null && (m.toLowerCase() === "true" || m.toLowerCase() === "false") && (m = m.toLowerCase() === "true"), m;
  }
  function K(m, O) {
    O = Object.assign({
      decode: !0,
      sort: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: !1,
      parseBooleans: !1
    }, O), d(O.arrayFormatSeparator);
    const y = h(O), _ = /* @__PURE__ */ Object.create(null);
    if (typeof m != "string" || (m = m.trim().replace(/^[?#&]/, ""), !m))
      return _;
    for (const f of m.split("&")) {
      if (f === "")
        continue;
      let [n, l] = i(O.decode ? f.replace(/\+/g, " ") : f, "=");
      l = l === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(O.arrayFormat) ? l : E(l, O), y(E(n, O), l, _);
    }
    for (const f of Object.keys(_)) {
      const n = _[f];
      if (typeof n == "object" && n !== null)
        for (const l of Object.keys(n))
          n[l] = R(n[l], O);
      else
        _[f] = R(n, O);
    }
    return O.sort === !1 ? _ : (O.sort === !0 ? Object.keys(_).sort() : Object.keys(_).sort(O.sort)).reduce((f, n) => {
      const l = _[n];
      return l && typeof l == "object" && !Array.isArray(l) ? f[n] = x(l) : f[n] = l, f;
    }, /* @__PURE__ */ Object.create(null));
  }
  t.extract = N, t.parse = K, t.stringify = (m, O) => {
    if (!m)
      return "";
    O = Object.assign({
      encode: !0,
      strict: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, O), d(O.arrayFormatSeparator);
    const y = (l) => O.skipNull && o(m[l]) || O.skipEmptyString && m[l] === "", _ = c(O), f = {};
    for (const l of Object.keys(m))
      y(l) || (f[l] = m[l]);
    const n = Object.keys(f);
    return O.sort !== !1 && n.sort(O.sort), n.map((l) => {
      const P = m[l];
      return P === void 0 ? "" : P === null ? p(l, O) : Array.isArray(P) ? P.length === 0 && O.arrayFormat === "bracket-separator" ? p(l, O) + "[]" : P.reduce(_(l), []).join("&") : p(l, O) + "=" + p(P, O);
    }).filter((l) => l.length > 0).join("&");
  }, t.parseUrl = (m, O) => {
    O = Object.assign({
      decode: !0
    }, O);
    const [y, _] = i(m, "#");
    return Object.assign(
      {
        url: y.split("?")[0] || "",
        query: K(N(m), O)
      },
      O && O.parseFragmentIdentifier && _ ? { fragmentIdentifier: E(_, O) } : {}
    );
  }, t.stringifyUrl = (m, O) => {
    O = Object.assign({
      encode: !0,
      strict: !0,
      [u]: !0
    }, O);
    const y = v(m.url).split("?")[0] || "", _ = t.extract(m.url), f = t.parse(_, { sort: !1 }), n = Object.assign(f, m.query);
    let l = t.stringify(n, O);
    l && (l = `?${l}`);
    let P = I(m.url);
    return m.fragmentIdentifier && (P = `#${O[u] ? p(m.fragmentIdentifier, O) : m.fragmentIdentifier}`), `${y}${l}${P}`;
  }, t.pick = (m, O, y) => {
    y = Object.assign({
      parseFragmentIdentifier: !0,
      [u]: !1
    }, y);
    const { url: _, query: f, fragmentIdentifier: n } = t.parseUrl(m, y);
    return t.stringifyUrl({
      url: _,
      query: s(f, O),
      fragmentIdentifier: n
    }, y);
  }, t.exclude = (m, O, y) => {
    const _ = Array.isArray(O) ? (f) => !O.includes(f) : (f, n) => !O(f, n);
    return t.pick(m, _, y);
  };
})(Gr);
const qf = {
  waku: {
    publish: "waku_publish",
    batchPublish: "waku_batchPublish",
    subscribe: "waku_subscribe",
    batchSubscribe: "waku_batchSubscribe",
    subscription: "waku_subscription",
    unsubscribe: "waku_unsubscribe",
    batchUnsubscribe: "waku_batchUnsubscribe"
  },
  irn: {
    publish: "irn_publish",
    batchPublish: "irn_batchPublish",
    subscribe: "irn_subscribe",
    batchSubscribe: "irn_batchSubscribe",
    subscription: "irn_subscription",
    unsubscribe: "irn_unsubscribe",
    batchUnsubscribe: "irn_batchUnsubscribe"
  },
  iridium: {
    publish: "iridium_publish",
    batchPublish: "iridium_batchPublish",
    subscribe: "iridium_subscribe",
    batchSubscribe: "iridium_batchSubscribe",
    subscription: "iridium_subscription",
    unsubscribe: "iridium_unsubscribe",
    batchUnsubscribe: "iridium_batchUnsubscribe"
  }
};
function ba(t, e) {
  return t.includes(":") ? [t] : e.chains || [];
}
const wa = "base10", dt = "base16", ds = "base64pad", Ts = "utf8", _a = 0, gr = 1, zf = 0, Yn = 1, ps = 12, Ns = 32;
function Kf() {
  const t = Os.generateKeyPair();
  return { privateKey: pt(t.secretKey, dt), publicKey: pt(t.publicKey, dt) };
}
function gs() {
  const t = Ir.randomBytes(Ns);
  return pt(t, dt);
}
function Vf(t, e) {
  const r = Os.sharedKey(yt(t, dt), yt(e, dt)), i = new hf(Ai.SHA256, r).expand(Ns);
  return pt(i, dt);
}
function Hf(t) {
  const e = Ai.hash(yt(t, dt));
  return pt(e, dt);
}
function Er(t) {
  const e = Ai.hash(yt(t, Ts));
  return pt(e, dt);
}
function Wf(t) {
  return yt(`${t}`, wa);
}
function Qr(t) {
  return Number(pt(t, wa));
}
function kf(t) {
  const e = Wf(typeof t.type < "u" ? t.type : _a);
  if (Qr(e) === gr && typeof t.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const r = typeof t.senderPublicKey < "u" ? yt(t.senderPublicKey, dt) : void 0, i = typeof t.iv < "u" ? yt(t.iv, dt) : Ir.randomBytes(ps), s = new Is.ChaCha20Poly1305(yt(t.symKey, dt)).seal(i, yt(t.message, Ts));
  return Yf({ type: e, sealed: s, iv: i, senderPublicKey: r });
}
function Gf(t) {
  const e = new Is.ChaCha20Poly1305(yt(t.symKey, dt)), { sealed: r, iv: i } = bi(t.encoded), s = e.open(i, r);
  if (s === null)
    throw new Error("Failed to decrypt");
  return pt(s, Ts);
}
function Yf(t) {
  if (Qr(t.type) === gr) {
    if (typeof t.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return pt(hs([t.type, t.senderPublicKey, t.iv, t.sealed]), ds);
  }
  return pt(hs([t.type, t.iv, t.sealed]), ds);
}
function bi(t) {
  const e = yt(t, ds), r = e.slice(zf, Yn), i = Yn;
  if (Qr(r) === gr) {
    const c = i + Ns, h = c + ps, d = e.slice(i, c), p = e.slice(c, h), E = e.slice(h);
    return { type: r, sealed: E, iv: p, senderPublicKey: d };
  }
  const s = i + ps, o = e.slice(i, s), u = e.slice(s);
  return { type: r, sealed: u, iv: o };
}
function Jf(t, e) {
  const r = bi(t);
  return ma({ type: Qr(r.type), senderPublicKey: typeof r.senderPublicKey < "u" ? pt(r.senderPublicKey, dt) : void 0, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey });
}
function ma(t) {
  const e = (t == null ? void 0 : t.type) || _a;
  if (e === gr) {
    if (typeof (t == null ? void 0 : t.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (t == null ? void 0 : t.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: e, senderPublicKey: t == null ? void 0 : t.senderPublicKey, receiverPublicKey: t == null ? void 0 : t.receiverPublicKey };
}
function Jn(t) {
  return t.type === gr && typeof t.senderPublicKey == "string" && typeof t.receiverPublicKey == "string";
}
var Xf = Object.defineProperty, Xn = Object.getOwnPropertySymbols, Qf = Object.prototype.hasOwnProperty, Zf = Object.prototype.propertyIsEnumerable, Qn = (t, e, r) => e in t ? Xf(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Zn = (t, e) => {
  for (var r in e || (e = {}))
    Qf.call(e, r) && Qn(t, r, e[r]);
  if (Xn)
    for (var r of Xn(e))
      Zf.call(e, r) && Qn(t, r, e[r]);
  return t;
};
const ed = "ReactNative", Yt = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, td = "js";
function Rs() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function va() {
  return !da() && !!As() && navigator.product === ed;
}
function Ps() {
  return !Rs() && !!As();
}
function Us() {
  return va() ? Yt.reactNative : Rs() ? Yt.node : Ps() ? Yt.browser : Yt.unknown;
}
function rd(t, e) {
  let r = Gr.parse(t);
  return r = Zn(Zn({}, r), e), t = Gr.stringify(r), t;
}
function id() {
  return ga() || { name: "", description: "", url: "", icons: [""] };
}
function sd() {
  if (Us() === Yt.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: r, Version: i } = global.Platform;
    return [r, i].join("-");
  }
  const t = _f();
  if (t === null)
    return "unknown";
  const e = t.os ? t.os.replace(" ", "").toLowerCase() : "unknown";
  return t.type === "browser" ? [e, t.name, t.version].join("-") : [e, t.version].join("-");
}
function nd() {
  var t;
  const e = Us();
  return e === Yt.browser ? [e, ((t = pa()) == null ? void 0 : t.host) || "unknown"].join(":") : e;
}
function od(t, e, r) {
  const i = sd(), s = nd();
  return [[t, e].join("-"), [td, r].join("-"), i, s].join("/");
}
function ad({ protocol: t, version: e, relayUrl: r, sdkVersion: i, auth: s, projectId: o, useOnCloseEvent: u }) {
  const c = r.split("?"), h = od(t, e, i), d = { auth: s, ua: h, projectId: o, useOnCloseEvent: u || void 0 }, p = rd(c[1] || "", d);
  return c[0] + "?" + p;
}
function lr(t, e) {
  return t.filter((r) => e.includes(r)).length === t.length;
}
function Ea(t) {
  return Object.fromEntries(t.entries());
}
function Da(t) {
  return new Map(Object.entries(t));
}
function mr(t = Q.FIVE_MINUTES, e) {
  const r = Q.toMiliseconds(t || Q.FIVE_MINUTES);
  let i, s, o;
  return { resolve: (u) => {
    o && i && (clearTimeout(o), i(u));
  }, reject: (u) => {
    o && s && (clearTimeout(o), s(u));
  }, done: () => new Promise((u, c) => {
    o = setTimeout(() => {
      c(new Error(e));
    }, r), i = u, s = c;
  }) };
}
function wi(t, e, r) {
  return new Promise(async (i, s) => {
    const o = setTimeout(() => s(new Error(r)), e);
    try {
      const u = await t;
      i(u);
    } catch (u) {
      s(u);
    }
    clearTimeout(o);
  });
}
function Sa(t, e) {
  if (typeof e == "string" && e.startsWith(`${t}:`))
    return e;
  if (t.toLowerCase() === "topic") {
    if (typeof e != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (t.toLowerCase() === "id") {
    if (typeof e != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${t}`);
}
function cd(t) {
  return Sa("topic", t);
}
function ud(t) {
  return Sa("id", t);
}
function Ia(t) {
  const [e, r] = t.split(":"), i = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof r == "string")
    i.topic = r;
  else if (e === "id" && Number.isInteger(Number(r)))
    i.id = Number(r);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${r}`);
  return i;
}
function At(t, e) {
  return Q.fromMiliseconds((e || Date.now()) + Q.toMiliseconds(t));
}
function Gt(t) {
  return Date.now() >= Q.toMiliseconds(t);
}
function qe(t, e) {
  return `${t}${e ? `:${e}` : ""}`;
}
async function hd({ id: t, topic: e, wcDeepLink: r }) {
  try {
    if (!r)
      return;
    const i = typeof r == "string" ? JSON.parse(r) : r;
    let s = i == null ? void 0 : i.href;
    if (typeof s != "string")
      return;
    s.endsWith("/") && (s = s.slice(0, -1));
    const o = `${s}/wc?requestId=${t}&sessionTopic=${e}`, u = Us();
    u === Yt.browser ? o.startsWith("https://") ? window.open(o, "_blank", "noreferrer noopener") : window.open(o, "_self", "noreferrer noopener") : u === Yt.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(o);
  } catch (i) {
    console.error(i);
  }
}
const ld = "irn";
function ys(t) {
  return (t == null ? void 0 : t.relay) || { protocol: ld };
}
function fi(t) {
  const e = qf[t];
  if (typeof e > "u")
    throw new Error(`Relay Protocol not supported: ${t}`);
  return e;
}
var fd = Object.defineProperty, eo = Object.getOwnPropertySymbols, dd = Object.prototype.hasOwnProperty, pd = Object.prototype.propertyIsEnumerable, to = (t, e, r) => e in t ? fd(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, gd = (t, e) => {
  for (var r in e || (e = {}))
    dd.call(e, r) && to(t, r, e[r]);
  if (eo)
    for (var r of eo(e))
      pd.call(e, r) && to(t, r, e[r]);
  return t;
};
function yd(t, e = "-") {
  const r = {}, i = "relay" + e;
  return Object.keys(t).forEach((s) => {
    if (s.startsWith(i)) {
      const o = s.replace(i, ""), u = t[s];
      r[o] = u;
    }
  }), r;
}
function bd(t) {
  const e = t.indexOf(":"), r = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0, i = t.substring(0, e), s = t.substring(e + 1, r).split("@"), o = typeof r < "u" ? t.substring(r) : "", u = Gr.parse(o);
  return { protocol: i, topic: wd(s[0]), version: parseInt(s[1], 10), symKey: u.symKey, relay: yd(u) };
}
function wd(t) {
  return t.startsWith("//") ? t.substring(2) : t;
}
function _d(t, e = "-") {
  const r = "relay", i = {};
  return Object.keys(t).forEach((s) => {
    const o = r + e + s;
    t[s] && (i[o] = t[s]);
  }), i;
}
function md(t) {
  return `${t.protocol}:${t.topic}@${t.version}?` + Gr.stringify(gd({ symKey: t.symKey }, _d(t.relay)));
}
function Or(t) {
  const e = [];
  return t.forEach((r) => {
    const [i, s] = r.split(":");
    e.push(`${i}:${s}`);
  }), e;
}
function vd(t) {
  const e = [];
  return Object.values(t).forEach((r) => {
    e.push(...Or(r.accounts));
  }), e;
}
function Ed(t, e) {
  const r = [];
  return Object.values(t).forEach((i) => {
    Or(i.accounts).includes(e) && r.push(...i.methods);
  }), r;
}
function Dd(t, e) {
  const r = [];
  return Object.values(t).forEach((i) => {
    Or(i.accounts).includes(e) && r.push(...i.events);
  }), r;
}
function Sd(t, e) {
  const r = di(t, e);
  if (r)
    throw new Error(r.message);
  const i = {};
  for (const [s, o] of Object.entries(t))
    i[s] = { methods: o.methods, events: o.events, chains: o.accounts.map((u) => `${u.split(":")[0]}:${u.split(":")[1]}`) };
  return i;
}
const Id = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, xd = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function G(t, e) {
  const { message: r, code: i } = xd[t];
  return { message: e ? `${r} ${e}` : r, code: i };
}
function Ze(t, e) {
  const { message: r, code: i } = Id[t];
  return { message: e ? `${r} ${e}` : r, code: i };
}
function Zr(t, e) {
  return Array.isArray(t) ? typeof e < "u" && t.length ? t.every(e) : !0 : !1;
}
function Hr(t) {
  return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length;
}
function ft(t) {
  return typeof t > "u";
}
function et(t, e) {
  return e && ft(t) ? !0 : typeof t == "string" && !!t.trim().length;
}
function Ls(t, e) {
  return e && ft(t) ? !0 : typeof t == "number" && !isNaN(t);
}
function Od(t, e) {
  const { requiredNamespaces: r } = e, i = Object.keys(t.namespaces), s = Object.keys(r);
  let o = !0;
  return lr(s, i) ? (i.forEach((u) => {
    const { accounts: c, methods: h, events: d } = t.namespaces[u], p = Or(c), E = r[u];
    (!lr(ba(u, E), p) || !lr(E.methods, h) || !lr(E.events, d)) && (o = !1);
  }), o) : !1;
}
function _i(t) {
  return et(t, !1) && t.includes(":") ? t.split(":").length === 2 : !1;
}
function Ad(t) {
  if (et(t, !1) && t.includes(":")) {
    const e = t.split(":");
    if (e.length === 3) {
      const r = e[0] + ":" + e[1];
      return !!e[2] && _i(r);
    }
  }
  return !1;
}
function Cd(t) {
  if (et(t, !1))
    try {
      return typeof new URL(t) < "u";
    } catch {
      return !1;
    }
  return !1;
}
function Td(t) {
  var e;
  return (e = t == null ? void 0 : t.proposer) == null ? void 0 : e.publicKey;
}
function Nd(t) {
  return t == null ? void 0 : t.topic;
}
function Rd(t, e) {
  let r = null;
  return et(t == null ? void 0 : t.publicKey, !1) || (r = G("MISSING_OR_INVALID", `${e} controller public key should be a string`)), r;
}
function ro(t) {
  let e = !0;
  return Zr(t) ? t.length && (e = t.every((r) => et(r, !1))) : e = !1, e;
}
function Pd(t, e, r) {
  let i = null;
  return Zr(e) && e.length ? e.forEach((s) => {
    i || _i(s) || (i = Ze("UNSUPPORTED_CHAINS", `${r}, chain ${s} should be a string and conform to "namespace:chainId" format`));
  }) : _i(t) || (i = Ze("UNSUPPORTED_CHAINS", `${r}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), i;
}
function Ud(t, e, r) {
  let i = null;
  return Object.entries(t).forEach(([s, o]) => {
    if (i)
      return;
    const u = Pd(s, ba(s, o), `${e} ${r}`);
    u && (i = u);
  }), i;
}
function Ld(t, e) {
  let r = null;
  return Zr(t) ? t.forEach((i) => {
    r || Ad(i) || (r = Ze("UNSUPPORTED_ACCOUNTS", `${e}, account ${i} should be a string and conform to "namespace:chainId:address" format`));
  }) : r = Ze("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), r;
}
function Fd(t, e) {
  let r = null;
  return Object.values(t).forEach((i) => {
    if (r)
      return;
    const s = Ld(i == null ? void 0 : i.accounts, `${e} namespace`);
    s && (r = s);
  }), r;
}
function Md(t, e) {
  let r = null;
  return ro(t == null ? void 0 : t.methods) ? ro(t == null ? void 0 : t.events) || (r = Ze("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : r = Ze("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), r;
}
function xa(t, e) {
  let r = null;
  return Object.values(t).forEach((i) => {
    if (r)
      return;
    const s = Md(i, `${e}, namespace`);
    s && (r = s);
  }), r;
}
function $d(t, e, r) {
  let i = null;
  if (t && Hr(t)) {
    const s = xa(t, e);
    s && (i = s);
    const o = Ud(t, e, r);
    o && (i = o);
  } else
    i = G("MISSING_OR_INVALID", `${e}, ${r} should be an object with data`);
  return i;
}
function di(t, e) {
  let r = null;
  if (t && Hr(t)) {
    const i = xa(t, e);
    i && (r = i);
    const s = Fd(t, e);
    s && (r = s);
  } else
    r = G("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
  return r;
}
function Oa(t) {
  return et(t.protocol, !0);
}
function jd(t, e) {
  let r = !1;
  return e && !t ? r = !0 : t && Zr(t) && t.length && t.forEach((i) => {
    r = Oa(i);
  }), r;
}
function Bd(t) {
  return typeof t == "number";
}
function gt(t) {
  return typeof t < "u" && typeof t !== null;
}
function qd(t) {
  return !(!t || typeof t != "object" || !t.code || !Ls(t.code, !1) || !t.message || !et(t.message, !1));
}
function zd(t) {
  return !(ft(t) || !et(t.method, !1));
}
function Kd(t) {
  return !(ft(t) || ft(t.result) && ft(t.error) || !Ls(t.id, !1) || !et(t.jsonrpc, !1));
}
function Vd(t) {
  return !(ft(t) || !et(t.name, !1));
}
function io(t, e) {
  return !(!_i(e) || !vd(t).includes(e));
}
function Hd(t, e, r) {
  return et(r, !1) ? Ed(t, e).includes(r) : !1;
}
function Wd(t, e, r) {
  return et(r, !1) ? Dd(t, e).includes(r) : !1;
}
function so(t, e, r) {
  let i = null;
  const s = kd(t), o = Gd(e), u = Object.keys(s), c = Object.keys(o), h = no(Object.keys(t)), d = no(Object.keys(e)), p = h.filter((E) => !d.includes(E));
  return p.length && (i = G("NON_CONFORMING_NAMESPACES", `${r} namespaces keys don't satisfy requiredNamespaces.
      Required: ${p.toString()}
      Received: ${Object.keys(e).toString()}`)), lr(u, c) || (i = G("NON_CONFORMING_NAMESPACES", `${r} namespaces chains don't satisfy required namespaces.
      Required: ${u.toString()}
      Approved: ${c.toString()}`)), Object.keys(e).forEach((E) => {
    if (!E.includes(":") || i)
      return;
    const x = Or(e[E].accounts);
    x.includes(E) || (i = G("NON_CONFORMING_NAMESPACES", `${r} namespaces accounts don't satisfy namespace accounts for ${E}
        Required: ${E}
        Approved: ${x.toString()}`));
  }), u.forEach((E) => {
    i || (lr(s[E].methods, o[E].methods) ? lr(s[E].events, o[E].events) || (i = G("NON_CONFORMING_NAMESPACES", `${r} namespaces events don't satisfy namespace events for ${E}`)) : i = G("NON_CONFORMING_NAMESPACES", `${r} namespaces methods don't satisfy namespace methods for ${E}`));
  }), i;
}
function kd(t) {
  const e = {};
  return Object.keys(t).forEach((r) => {
    var i;
    r.includes(":") ? e[r] = t[r] : (i = t[r].chains) == null || i.forEach((s) => {
      e[s] = { methods: t[r].methods, events: t[r].events };
    });
  }), e;
}
function no(t) {
  return [...new Set(t.map((e) => e.includes(":") ? e.split(":")[0] : e))];
}
function Gd(t) {
  const e = {};
  return Object.keys(t).forEach((r) => {
    if (r.includes(":"))
      e[r] = t[r];
    else {
      const i = Or(t[r].accounts);
      i == null || i.forEach((s) => {
        e[s] = { accounts: t[r].accounts.filter((o) => o.includes(`${s}:`)), methods: t[r].methods, events: t[r].events };
      });
    }
  }), e;
}
function Yd(t, e) {
  return Ls(t, !1) && t <= e.max && t >= e.min;
}
const Jd = "PARSE_ERROR", Xd = "INVALID_REQUEST", Qd = "METHOD_NOT_FOUND", Zd = "INVALID_PARAMS", Aa = "INTERNAL_ERROR", Fs = "SERVER_ERROR", ep = [-32700, -32600, -32601, -32602, -32603], Wr = {
  [Jd]: { code: -32700, message: "Parse error" },
  [Xd]: { code: -32600, message: "Invalid Request" },
  [Qd]: { code: -32601, message: "Method not found" },
  [Zd]: { code: -32602, message: "Invalid params" },
  [Aa]: { code: -32603, message: "Internal error" },
  [Fs]: { code: -32e3, message: "Server error" }
}, Ca = Fs;
function tp(t) {
  return ep.includes(t);
}
function oo(t) {
  return Object.keys(Wr).includes(t) ? Wr[t] : Wr[Ca];
}
function rp(t) {
  const e = Object.values(Wr).find((r) => r.code === t);
  return e || Wr[Ca];
}
function ip(t, e, r) {
  return t.message.includes("getaddrinfo ENOTFOUND") || t.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${r} RPC url at ${e}`) : t;
}
var Ta = {}, jt = {}, ao;
function sp() {
  if (ao)
    return jt;
  ao = 1, Object.defineProperty(jt, "__esModule", { value: !0 }), jt.isBrowserCryptoAvailable = jt.getSubtleCrypto = jt.getBrowerCrypto = void 0;
  function t() {
    return (_t === null || _t === void 0 ? void 0 : _t.crypto) || (_t === null || _t === void 0 ? void 0 : _t.msCrypto) || {};
  }
  jt.getBrowerCrypto = t;
  function e() {
    const i = t();
    return i.subtle || i.webkitSubtle;
  }
  jt.getSubtleCrypto = e;
  function r() {
    return !!t() && !!e();
  }
  return jt.isBrowserCryptoAvailable = r, jt;
}
var Bt = {}, co;
function np() {
  if (co)
    return Bt;
  co = 1, Object.defineProperty(Bt, "__esModule", { value: !0 }), Bt.isBrowser = Bt.isNode = Bt.isReactNative = void 0;
  function t() {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative";
  }
  Bt.isReactNative = t;
  function e() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
  }
  Bt.isNode = e;
  function r() {
    return !t() && !e();
  }
  return Bt.isBrowser = r, Bt;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = It;
  e.__exportStar(sp(), t), e.__exportStar(np(), t);
})(Ta);
function Na(t = 3) {
  const e = Date.now() * Math.pow(10, t), r = Math.floor(Math.random() * Math.pow(10, t));
  return e + r;
}
function Ms(t = 6) {
  return BigInt(Na(t));
}
function Ci(t, e, r) {
  return {
    id: r || Na(),
    jsonrpc: "2.0",
    method: t,
    params: e
  };
}
function $s(t, e) {
  return {
    id: t,
    jsonrpc: "2.0",
    result: e
  };
}
function js(t, e, r) {
  return {
    id: t,
    jsonrpc: "2.0",
    error: op(e, r)
  };
}
function op(t, e) {
  return typeof t > "u" ? oo(Aa) : (typeof t == "string" && (t = Object.assign(Object.assign({}, oo(Fs)), { message: t })), typeof e < "u" && (t.data = e), tp(t.code) && (t = rp(t.code)), t);
}
class ap {
}
class cp extends ap {
  constructor() {
    super();
  }
}
class up extends cp {
  constructor(e) {
    super();
  }
}
const hp = "^wss?:";
function lp(t) {
  const e = t.match(new RegExp(/^\w+:/, "gi"));
  if (!(!e || !e.length))
    return e[0];
}
function fp(t, e) {
  const r = lp(t);
  return typeof r > "u" ? !1 : new RegExp(e).test(r);
}
function uo(t) {
  return fp(t, hp);
}
function dp(t) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(t);
}
function Ra(t) {
  return typeof t == "object" && "id" in t && "jsonrpc" in t && t.jsonrpc === "2.0";
}
function Bs(t) {
  return Ra(t) && "method" in t;
}
function Ti(t) {
  return Ra(t) && (qt(t) || Ct(t));
}
function qt(t) {
  return "result" in t;
}
function Ct(t) {
  return "error" in t;
}
class pp extends up {
  constructor(e) {
    super(e), this.events = new zt(), this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(e), this.connection.connected && this.registerEventListeners();
  }
  async connect(e = this.connection) {
    await this.open(e);
  }
  async disconnect() {
    await this.close();
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async request(e, r) {
    return this.requestStrict(Ci(e.method, e.params || [], e.id || Ms().toString()), r);
  }
  async requestStrict(e, r) {
    return new Promise(async (i, s) => {
      if (!this.connection.connected)
        try {
          await this.open();
        } catch (o) {
          s(o);
        }
      this.events.on(`${e.id}`, (o) => {
        Ct(o) ? s(o.error) : i(o.result);
      });
      try {
        await this.connection.send(e, r);
      } catch (o) {
        s(o);
      }
    });
  }
  setConnection(e = this.connection) {
    return e;
  }
  onPayload(e) {
    this.events.emit("payload", e), Ti(e) ? this.events.emit(`${e.id}`, e) : this.events.emit("message", {
      type: e.method,
      data: e.params
    });
  }
  onClose(e) {
    e && e.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(e = this.connection) {
    this.connection === e && this.connection.connected || (this.connection.connected && this.close(), typeof e == "string" && (await this.connection.open(e), e = this.connection), this.connection = this.setConnection(e), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (e) => this.onPayload(e)), this.connection.on("close", (e) => this.onClose(e)), this.connection.on("error", (e) => this.events.emit("error", e)), this.connection.on("register_error", (e) => this.onClose()), this.hasRegisteredEventListeners = !0);
  }
}
var Wi, ho;
function gp() {
  return ho || (ho = 1, Wi = function() {
    throw new Error(
      "ws does not work in the browser. Browser clients must use the native WebSocket object"
    );
  }), Wi;
}
const yp = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : gp(), bp = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u", lo = (t) => t.split("?")[0], fo = 10, wp = yp();
class _p {
  constructor(e) {
    if (this.url = e, this.events = new zt(), this.registering = !1, !uo(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, r) => {
      if (typeof this.socket > "u") {
        r(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (i) => {
        this.onClose(i), e();
      }, this.socket.close();
    });
  }
  async send(e, r) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(Es(e));
    } catch (i) {
      this.onError(e.id, i);
    }
  }
  register(e = this.url) {
    if (!uo(e))
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const r = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= r || this.events.listenerCount("open") >= r) && this.events.setMaxListeners(r + 1), new Promise((i, s) => {
        this.events.once("register_error", (o) => {
          this.resetMaxListeners(), s(o);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u")
            return s(new Error("WebSocket connection is missing or invalid"));
          i(this.socket);
        });
      });
    }
    return this.url = e, this.registering = !0, new Promise((r, i) => {
      const s = Ta.isReactNative() ? void 0 : { rejectUnauthorized: !dp(e) }, o = new wp(e, [], s);
      bp() ? o.onerror = (u) => {
        const c = u;
        i(this.emitError(c.error));
      } : o.on("error", (u) => {
        i(this.emitError(u));
      }), o.onopen = () => {
        this.onOpen(o), r(o);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (r) => this.onPayload(r), e.onclose = (r) => this.onClose(r), this.socket = e, this.registering = !1, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = !1, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u")
      return;
    const r = typeof e.data == "string" ? Wo(e.data) : e.data;
    this.events.emit("payload", r);
  }
  onError(e, r) {
    const i = this.parseError(r), s = i.message || i.toString(), o = js(e, s);
    this.events.emit("payload", o);
  }
  parseError(e, r = this.url) {
    return ip(e, lo(r), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > fo && this.events.setMaxListeners(fo);
  }
  emitError(e) {
    const r = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${lo(this.url)}`));
    return this.events.emit("register_error", r), r;
  }
}
var mi = { exports: {} };
mi.exports;
(function(t, e) {
  var r = 200, i = "__lodash_hash_undefined__", s = 1, o = 2, u = 9007199254740991, c = "[object Arguments]", h = "[object Array]", d = "[object AsyncFunction]", p = "[object Boolean]", E = "[object Date]", x = "[object Error]", v = "[object Function]", I = "[object GeneratorFunction]", N = "[object Map]", R = "[object Number]", K = "[object Null]", m = "[object Object]", O = "[object Promise]", y = "[object Proxy]", _ = "[object RegExp]", f = "[object Set]", n = "[object String]", l = "[object Symbol]", P = "[object Undefined]", U = "[object WeakMap]", L = "[object ArrayBuffer]", F = "[object DataView]", z = "[object Float32Array]", b = "[object Float64Array]", A = "[object Int8Array]", k = "[object Int16Array]", B = "[object Int32Array]", $ = "[object Uint8Array]", q = "[object Uint8ClampedArray]", M = "[object Uint16Array]", V = "[object Uint32Array]", te = /[\\^$.*+?()[\]{}|]/g, H = /^\[object .+?Constructor\]$/, Z = /^(?:0|[1-9]\d*)$/, J = {};
  J[z] = J[b] = J[A] = J[k] = J[B] = J[$] = J[q] = J[M] = J[V] = !0, J[c] = J[h] = J[L] = J[p] = J[F] = J[E] = J[x] = J[v] = J[N] = J[R] = J[m] = J[_] = J[f] = J[n] = J[U] = !1;
  var ee = typeof _t == "object" && _t && _t.Object === Object && _t, T = typeof self == "object" && self && self.Object === Object && self, C = ee || T || Function("return this")(), D = e && !e.nodeType && e, a = D && !0 && t && !t.nodeType && t, w = a && a.exports === D, W = w && ee.process, Y = function() {
    try {
      return W && W.binding && W.binding("util");
    } catch {
    }
  }(), le = Y && Y.isTypedArray;
  function be(g, S) {
    for (var j = -1, X = g == null ? 0 : g.length, xe = 0, ne = []; ++j < X; ) {
      var Pe = g[j];
      S(Pe, j, g) && (ne[xe++] = Pe);
    }
    return ne;
  }
  function de(g, S) {
    for (var j = -1, X = S.length, xe = g.length; ++j < X; )
      g[xe + j] = S[j];
    return g;
  }
  function ve(g, S) {
    for (var j = -1, X = g == null ? 0 : g.length; ++j < X; )
      if (S(g[j], j, g))
        return !0;
    return !1;
  }
  function Le(g, S) {
    for (var j = -1, X = Array(g); ++j < g; )
      X[j] = S(j);
    return X;
  }
  function Te(g) {
    return function(S) {
      return g(S);
    };
  }
  function ye(g, S) {
    return g.has(S);
  }
  function pe(g, S) {
    return g == null ? void 0 : g[S];
  }
  function fe(g) {
    var S = -1, j = Array(g.size);
    return g.forEach(function(X, xe) {
      j[++S] = [xe, X];
    }), j;
  }
  function ue(g, S) {
    return function(j) {
      return g(S(j));
    };
  }
  function ce(g) {
    var S = -1, j = Array(g.size);
    return g.forEach(function(X) {
      j[++S] = X;
    }), j;
  }
  var ae = Array.prototype, oe = Function.prototype, re = Object.prototype, he = C["__core-js_shared__"], ge = oe.toString, ie = re.hasOwnProperty, we = function() {
    var g = /[^.]+$/.exec(he && he.keys && he.keys.IE_PROTO || "");
    return g ? "Symbol(src)_1." + g : "";
  }(), me = re.toString, De = RegExp(
    "^" + ge.call(ie).replace(te, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), Se = w ? C.Buffer : void 0, Ee = C.Symbol, xt = C.Uint8Array, Nt = re.propertyIsEnumerable, Kt = ae.splice, bt = Ee ? Ee.toStringTag : void 0, Zt = Object.getOwnPropertySymbols, Ar = Se ? Se.isBuffer : void 0, ti = ue(Object.keys, Object), Fe = yr(C, "DataView"), Ne = yr(C, "Map"), Me = yr(C, "Promise"), $e = yr(C, "Set"), je = yr(C, "WeakMap"), Re = yr(Object, "create"), Ke = tr(Fe), Ve = tr(Ne), He = tr(Me), We = tr($e), ke = tr(je), ze = Ee ? Ee.prototype : void 0, Be = ze ? ze.valueOf : void 0;
  function Oe(g) {
    var S = -1, j = g == null ? 0 : g.length;
    for (this.clear(); ++S < j; ) {
      var X = g[S];
      this.set(X[0], X[1]);
    }
  }
  function Ge() {
    this.__data__ = Re ? Re(null) : {}, this.size = 0;
  }
  function Ye(g) {
    var S = this.has(g) && delete this.__data__[g];
    return this.size -= S ? 1 : 0, S;
  }
  function Qa(g) {
    var S = this.__data__;
    if (Re) {
      var j = S[g];
      return j === i ? void 0 : j;
    }
    return ie.call(S, g) ? S[g] : void 0;
  }
  function Za(g) {
    var S = this.__data__;
    return Re ? S[g] !== void 0 : ie.call(S, g);
  }
  function ec(g, S) {
    var j = this.__data__;
    return this.size += this.has(g) ? 0 : 1, j[g] = Re && S === void 0 ? i : S, this;
  }
  Oe.prototype.clear = Ge, Oe.prototype.delete = Ye, Oe.prototype.get = Qa, Oe.prototype.has = Za, Oe.prototype.set = ec;
  function Mt(g) {
    var S = -1, j = g == null ? 0 : g.length;
    for (this.clear(); ++S < j; ) {
      var X = g[S];
      this.set(X[0], X[1]);
    }
  }
  function tc() {
    this.__data__ = [], this.size = 0;
  }
  function rc(g) {
    var S = this.__data__, j = ii(S, g);
    if (j < 0)
      return !1;
    var X = S.length - 1;
    return j == X ? S.pop() : Kt.call(S, j, 1), --this.size, !0;
  }
  function ic(g) {
    var S = this.__data__, j = ii(S, g);
    return j < 0 ? void 0 : S[j][1];
  }
  function sc(g) {
    return ii(this.__data__, g) > -1;
  }
  function nc(g, S) {
    var j = this.__data__, X = ii(j, g);
    return X < 0 ? (++this.size, j.push([g, S])) : j[X][1] = S, this;
  }
  Mt.prototype.clear = tc, Mt.prototype.delete = rc, Mt.prototype.get = ic, Mt.prototype.has = sc, Mt.prototype.set = nc;
  function er(g) {
    var S = -1, j = g == null ? 0 : g.length;
    for (this.clear(); ++S < j; ) {
      var X = g[S];
      this.set(X[0], X[1]);
    }
  }
  function oc() {
    this.size = 0, this.__data__ = {
      hash: new Oe(),
      map: new (Ne || Mt)(),
      string: new Oe()
    };
  }
  function ac(g) {
    var S = si(this, g).delete(g);
    return this.size -= S ? 1 : 0, S;
  }
  function cc(g) {
    return si(this, g).get(g);
  }
  function uc(g) {
    return si(this, g).has(g);
  }
  function hc(g, S) {
    var j = si(this, g), X = j.size;
    return j.set(g, S), this.size += j.size == X ? 0 : 1, this;
  }
  er.prototype.clear = oc, er.prototype.delete = ac, er.prototype.get = cc, er.prototype.has = uc, er.prototype.set = hc;
  function ri(g) {
    var S = -1, j = g == null ? 0 : g.length;
    for (this.__data__ = new er(); ++S < j; )
      this.add(g[S]);
  }
  function lc(g) {
    return this.__data__.set(g, i), this;
  }
  function fc(g) {
    return this.__data__.has(g);
  }
  ri.prototype.add = ri.prototype.push = lc, ri.prototype.has = fc;
  function Vt(g) {
    var S = this.__data__ = new Mt(g);
    this.size = S.size;
  }
  function dc() {
    this.__data__ = new Mt(), this.size = 0;
  }
  function pc(g) {
    var S = this.__data__, j = S.delete(g);
    return this.size = S.size, j;
  }
  function gc(g) {
    return this.__data__.get(g);
  }
  function yc(g) {
    return this.__data__.has(g);
  }
  function bc(g, S) {
    var j = this.__data__;
    if (j instanceof Mt) {
      var X = j.__data__;
      if (!Ne || X.length < r - 1)
        return X.push([g, S]), this.size = ++j.size, this;
      j = this.__data__ = new er(X);
    }
    return j.set(g, S), this.size = j.size, this;
  }
  Vt.prototype.clear = dc, Vt.prototype.delete = pc, Vt.prototype.get = gc, Vt.prototype.has = yc, Vt.prototype.set = bc;
  function wc(g, S) {
    var j = ni(g), X = !j && Pc(g), xe = !j && !X && Pi(g), ne = !j && !X && !xe && Zs(g), Pe = j || X || xe || ne, Je = Pe ? Le(g.length, String) : [], tt = Je.length;
    for (var Ce in g)
      (S || ie.call(g, Ce)) && !(Pe && // Safari 9 has enumerable `arguments.length` in strict mode.
      (Ce == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      xe && (Ce == "offset" || Ce == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      ne && (Ce == "buffer" || Ce == "byteLength" || Ce == "byteOffset") || // Skip index properties.
      Ac(Ce, tt))) && Je.push(Ce);
    return Je;
  }
  function ii(g, S) {
    for (var j = g.length; j--; )
      if (Ys(g[j][0], S))
        return j;
    return -1;
  }
  function _c(g, S, j) {
    var X = S(g);
    return ni(g) ? X : de(X, j(g));
  }
  function Cr(g) {
    return g == null ? g === void 0 ? P : K : bt && bt in Object(g) ? xc(g) : Rc(g);
  }
  function Hs(g) {
    return Tr(g) && Cr(g) == c;
  }
  function Ws(g, S, j, X, xe) {
    return g === S ? !0 : g == null || S == null || !Tr(g) && !Tr(S) ? g !== g && S !== S : mc(g, S, j, X, Ws, xe);
  }
  function mc(g, S, j, X, xe, ne) {
    var Pe = ni(g), Je = ni(S), tt = Pe ? h : Ht(g), Ce = Je ? h : Ht(S);
    tt = tt == c ? m : tt, Ce = Ce == c ? m : Ce;
    var wt = tt == m, Ot = Ce == m, st = tt == Ce;
    if (st && Pi(g)) {
      if (!Pi(S))
        return !1;
      Pe = !0, wt = !1;
    }
    if (st && !wt)
      return ne || (ne = new Vt()), Pe || Zs(g) ? ks(g, S, j, X, xe, ne) : Sc(g, S, tt, j, X, xe, ne);
    if (!(j & s)) {
      var vt = wt && ie.call(g, "__wrapped__"), Et = Ot && ie.call(S, "__wrapped__");
      if (vt || Et) {
        var Wt = vt ? g.value() : g, $t = Et ? S.value() : S;
        return ne || (ne = new Vt()), xe(Wt, $t, j, X, ne);
      }
    }
    return st ? (ne || (ne = new Vt()), Ic(g, S, j, X, xe, ne)) : !1;
  }
  function vc(g) {
    if (!Qs(g) || Tc(g))
      return !1;
    var S = Js(g) ? De : H;
    return S.test(tr(g));
  }
  function Ec(g) {
    return Tr(g) && Xs(g.length) && !!J[Cr(g)];
  }
  function Dc(g) {
    if (!Nc(g))
      return ti(g);
    var S = [];
    for (var j in Object(g))
      ie.call(g, j) && j != "constructor" && S.push(j);
    return S;
  }
  function ks(g, S, j, X, xe, ne) {
    var Pe = j & s, Je = g.length, tt = S.length;
    if (Je != tt && !(Pe && tt > Je))
      return !1;
    var Ce = ne.get(g);
    if (Ce && ne.get(S))
      return Ce == S;
    var wt = -1, Ot = !0, st = j & o ? new ri() : void 0;
    for (ne.set(g, S), ne.set(S, g); ++wt < Je; ) {
      var vt = g[wt], Et = S[wt];
      if (X)
        var Wt = Pe ? X(Et, vt, wt, S, g, ne) : X(vt, Et, wt, g, S, ne);
      if (Wt !== void 0) {
        if (Wt)
          continue;
        Ot = !1;
        break;
      }
      if (st) {
        if (!ve(S, function($t, rr) {
          if (!ye(st, rr) && (vt === $t || xe(vt, $t, j, X, ne)))
            return st.push(rr);
        })) {
          Ot = !1;
          break;
        }
      } else if (!(vt === Et || xe(vt, Et, j, X, ne))) {
        Ot = !1;
        break;
      }
    }
    return ne.delete(g), ne.delete(S), Ot;
  }
  function Sc(g, S, j, X, xe, ne, Pe) {
    switch (j) {
      case F:
        if (g.byteLength != S.byteLength || g.byteOffset != S.byteOffset)
          return !1;
        g = g.buffer, S = S.buffer;
      case L:
        return !(g.byteLength != S.byteLength || !ne(new xt(g), new xt(S)));
      case p:
      case E:
      case R:
        return Ys(+g, +S);
      case x:
        return g.name == S.name && g.message == S.message;
      case _:
      case n:
        return g == S + "";
      case N:
        var Je = fe;
      case f:
        var tt = X & s;
        if (Je || (Je = ce), g.size != S.size && !tt)
          return !1;
        var Ce = Pe.get(g);
        if (Ce)
          return Ce == S;
        X |= o, Pe.set(g, S);
        var wt = ks(Je(g), Je(S), X, xe, ne, Pe);
        return Pe.delete(g), wt;
      case l:
        if (Be)
          return Be.call(g) == Be.call(S);
    }
    return !1;
  }
  function Ic(g, S, j, X, xe, ne) {
    var Pe = j & s, Je = Gs(g), tt = Je.length, Ce = Gs(S), wt = Ce.length;
    if (tt != wt && !Pe)
      return !1;
    for (var Ot = tt; Ot--; ) {
      var st = Je[Ot];
      if (!(Pe ? st in S : ie.call(S, st)))
        return !1;
    }
    var vt = ne.get(g);
    if (vt && ne.get(S))
      return vt == S;
    var Et = !0;
    ne.set(g, S), ne.set(S, g);
    for (var Wt = Pe; ++Ot < tt; ) {
      st = Je[Ot];
      var $t = g[st], rr = S[st];
      if (X)
        var en = Pe ? X(rr, $t, st, S, g, ne) : X($t, rr, st, g, S, ne);
      if (!(en === void 0 ? $t === rr || xe($t, rr, j, X, ne) : en)) {
        Et = !1;
        break;
      }
      Wt || (Wt = st == "constructor");
    }
    if (Et && !Wt) {
      var oi = g.constructor, ai = S.constructor;
      oi != ai && "constructor" in g && "constructor" in S && !(typeof oi == "function" && oi instanceof oi && typeof ai == "function" && ai instanceof ai) && (Et = !1);
    }
    return ne.delete(g), ne.delete(S), Et;
  }
  function Gs(g) {
    return _c(g, Fc, Oc);
  }
  function si(g, S) {
    var j = g.__data__;
    return Cc(S) ? j[typeof S == "string" ? "string" : "hash"] : j.map;
  }
  function yr(g, S) {
    var j = pe(g, S);
    return vc(j) ? j : void 0;
  }
  function xc(g) {
    var S = ie.call(g, bt), j = g[bt];
    try {
      g[bt] = void 0;
      var X = !0;
    } catch {
    }
    var xe = me.call(g);
    return X && (S ? g[bt] = j : delete g[bt]), xe;
  }
  var Oc = Zt ? function(g) {
    return g == null ? [] : (g = Object(g), be(Zt(g), function(S) {
      return Nt.call(g, S);
    }));
  } : Mc, Ht = Cr;
  (Fe && Ht(new Fe(new ArrayBuffer(1))) != F || Ne && Ht(new Ne()) != N || Me && Ht(Me.resolve()) != O || $e && Ht(new $e()) != f || je && Ht(new je()) != U) && (Ht = function(g) {
    var S = Cr(g), j = S == m ? g.constructor : void 0, X = j ? tr(j) : "";
    if (X)
      switch (X) {
        case Ke:
          return F;
        case Ve:
          return N;
        case He:
          return O;
        case We:
          return f;
        case ke:
          return U;
      }
    return S;
  });
  function Ac(g, S) {
    return S = S ?? u, !!S && (typeof g == "number" || Z.test(g)) && g > -1 && g % 1 == 0 && g < S;
  }
  function Cc(g) {
    var S = typeof g;
    return S == "string" || S == "number" || S == "symbol" || S == "boolean" ? g !== "__proto__" : g === null;
  }
  function Tc(g) {
    return !!we && we in g;
  }
  function Nc(g) {
    var S = g && g.constructor, j = typeof S == "function" && S.prototype || re;
    return g === j;
  }
  function Rc(g) {
    return me.call(g);
  }
  function tr(g) {
    if (g != null) {
      try {
        return ge.call(g);
      } catch {
      }
      try {
        return g + "";
      } catch {
      }
    }
    return "";
  }
  function Ys(g, S) {
    return g === S || g !== g && S !== S;
  }
  var Pc = Hs(function() {
    return arguments;
  }()) ? Hs : function(g) {
    return Tr(g) && ie.call(g, "callee") && !Nt.call(g, "callee");
  }, ni = Array.isArray;
  function Uc(g) {
    return g != null && Xs(g.length) && !Js(g);
  }
  var Pi = Ar || $c;
  function Lc(g, S) {
    return Ws(g, S);
  }
  function Js(g) {
    if (!Qs(g))
      return !1;
    var S = Cr(g);
    return S == v || S == I || S == d || S == y;
  }
  function Xs(g) {
    return typeof g == "number" && g > -1 && g % 1 == 0 && g <= u;
  }
  function Qs(g) {
    var S = typeof g;
    return g != null && (S == "object" || S == "function");
  }
  function Tr(g) {
    return g != null && typeof g == "object";
  }
  var Zs = le ? Te(le) : Ec;
  function Fc(g) {
    return Uc(g) ? wc(g) : Dc(g);
  }
  function Mc() {
    return [];
  }
  function $c() {
    return !1;
  }
  t.exports = Lc;
})(mi, mi.exports);
var mp = mi.exports;
const vp = /* @__PURE__ */ jc(mp);
function Ep(t, e) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), i = 0; i < r.length; i++)
    r[i] = 255;
  for (var s = 0; s < t.length; s++) {
    var o = t.charAt(s), u = o.charCodeAt(0);
    if (r[u] !== 255)
      throw new TypeError(o + " is ambiguous");
    r[u] = s;
  }
  var c = t.length, h = t.charAt(0), d = Math.log(c) / Math.log(256), p = Math.log(256) / Math.log(c);
  function E(I) {
    if (I instanceof Uint8Array || (ArrayBuffer.isView(I) ? I = new Uint8Array(I.buffer, I.byteOffset, I.byteLength) : Array.isArray(I) && (I = Uint8Array.from(I))), !(I instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (I.length === 0)
      return "";
    for (var N = 0, R = 0, K = 0, m = I.length; K !== m && I[K] === 0; )
      K++, N++;
    for (var O = (m - K) * p + 1 >>> 0, y = new Uint8Array(O); K !== m; ) {
      for (var _ = I[K], f = 0, n = O - 1; (_ !== 0 || f < R) && n !== -1; n--, f++)
        _ += 256 * y[n] >>> 0, y[n] = _ % c >>> 0, _ = _ / c >>> 0;
      if (_ !== 0)
        throw new Error("Non-zero carry");
      R = f, K++;
    }
    for (var l = O - R; l !== O && y[l] === 0; )
      l++;
    for (var P = h.repeat(N); l < O; ++l)
      P += t.charAt(y[l]);
    return P;
  }
  function x(I) {
    if (typeof I != "string")
      throw new TypeError("Expected String");
    if (I.length === 0)
      return new Uint8Array();
    var N = 0;
    if (I[N] !== " ") {
      for (var R = 0, K = 0; I[N] === h; )
        R++, N++;
      for (var m = (I.length - N) * d + 1 >>> 0, O = new Uint8Array(m); I[N]; ) {
        var y = r[I.charCodeAt(N)];
        if (y === 255)
          return;
        for (var _ = 0, f = m - 1; (y !== 0 || _ < K) && f !== -1; f--, _++)
          y += c * O[f] >>> 0, O[f] = y % 256 >>> 0, y = y / 256 >>> 0;
        if (y !== 0)
          throw new Error("Non-zero carry");
        K = _, N++;
      }
      if (I[N] !== " ") {
        for (var n = m - K; n !== m && O[n] === 0; )
          n++;
        for (var l = new Uint8Array(R + (m - n)), P = R; n !== m; )
          l[P++] = O[n++];
        return l;
      }
    }
  }
  function v(I) {
    var N = x(I);
    if (N)
      return N;
    throw new Error(`Non-${e} character`);
  }
  return { encode: E, decodeUnsafe: x, decode: v };
}
var Dp = Ep, Sp = Dp;
const Pa = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
    return t;
  if (t instanceof ArrayBuffer)
    return new Uint8Array(t);
  if (ArrayBuffer.isView(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, Ip = (t) => new TextEncoder().encode(t), xp = (t) => new TextDecoder().decode(t);
class Op {
  constructor(e, r, i) {
    this.name = e, this.prefix = r, this.baseEncode = i;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class Ap {
  constructor(e, r, i) {
    if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = i;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return Ua(this, e);
  }
}
class Cp {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return Ua(this, e);
  }
  decode(e) {
    const r = e[0], i = this.decoders[r];
    if (i)
      return i.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const Ua = (t, e) => new Cp({ ...t.decoders || { [t.prefix]: t }, ...e.decoders || { [e.prefix]: e } });
class Tp {
  constructor(e, r, i, s) {
    this.name = e, this.prefix = r, this.baseEncode = i, this.baseDecode = s, this.encoder = new Op(e, r, i), this.decoder = new Ap(e, r, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const Ni = ({ name: t, prefix: e, encode: r, decode: i }) => new Tp(t, e, r, i), ei = ({ prefix: t, name: e, alphabet: r }) => {
  const { encode: i, decode: s } = Sp(r, e);
  return Ni({ prefix: t, name: e, encode: i, decode: (o) => Pa(s(o)) });
}, Np = (t, e, r, i) => {
  const s = {};
  for (let p = 0; p < e.length; ++p)
    s[e[p]] = p;
  let o = t.length;
  for (; t[o - 1] === "="; )
    --o;
  const u = new Uint8Array(o * r / 8 | 0);
  let c = 0, h = 0, d = 0;
  for (let p = 0; p < o; ++p) {
    const E = s[t[p]];
    if (E === void 0)
      throw new SyntaxError(`Non-${i} character`);
    h = h << r | E, c += r, c >= 8 && (c -= 8, u[d++] = 255 & h >> c);
  }
  if (c >= r || 255 & h << 8 - c)
    throw new SyntaxError("Unexpected end of data");
  return u;
}, Rp = (t, e, r) => {
  const i = e[e.length - 1] === "=", s = (1 << r) - 1;
  let o = "", u = 0, c = 0;
  for (let h = 0; h < t.length; ++h)
    for (c = c << 8 | t[h], u += 8; u > r; )
      u -= r, o += e[s & c >> u];
  if (u && (o += e[s & c << r - u]), i)
    for (; o.length * r & 7; )
      o += "=";
  return o;
}, it = ({ name: t, prefix: e, bitsPerChar: r, alphabet: i }) => Ni({ prefix: e, name: t, encode(s) {
  return Rp(s, i, r);
}, decode(s) {
  return Np(s, i, r, t);
} }), Pp = Ni({ prefix: "\0", name: "identity", encode: (t) => xp(t), decode: (t) => Ip(t) });
var Up = Object.freeze({ __proto__: null, identity: Pp });
const Lp = it({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Fp = Object.freeze({ __proto__: null, base2: Lp });
const Mp = it({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var $p = Object.freeze({ __proto__: null, base8: Mp });
const jp = ei({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Bp = Object.freeze({ __proto__: null, base10: jp });
const qp = it({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), zp = it({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Kp = Object.freeze({ __proto__: null, base16: qp, base16upper: zp });
const Vp = it({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), Hp = it({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), Wp = it({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), kp = it({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), Gp = it({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), Yp = it({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), Jp = it({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), Xp = it({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), Qp = it({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Zp = Object.freeze({ __proto__: null, base32: Vp, base32upper: Hp, base32pad: Wp, base32padupper: kp, base32hex: Gp, base32hexupper: Yp, base32hexpad: Jp, base32hexpadupper: Xp, base32z: Qp });
const eg = ei({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), tg = ei({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var rg = Object.freeze({ __proto__: null, base36: eg, base36upper: tg });
const ig = ei({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), sg = ei({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var ng = Object.freeze({ __proto__: null, base58btc: ig, base58flickr: sg });
const og = it({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), ag = it({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), cg = it({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), ug = it({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var hg = Object.freeze({ __proto__: null, base64: og, base64pad: ag, base64url: cg, base64urlpad: ug });
const La = Array.from(""), lg = La.reduce((t, e, r) => (t[r] = e, t), []), fg = La.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);
function dg(t) {
  return t.reduce((e, r) => (e += lg[r], e), "");
}
function pg(t) {
  const e = [];
  for (const r of t) {
    const i = fg[r.codePointAt(0)];
    if (i === void 0)
      throw new Error(`Non-base256emoji character: ${r}`);
    e.push(i);
  }
  return new Uint8Array(e);
}
const gg = Ni({ prefix: "", name: "base256emoji", encode: dg, decode: pg });
var yg = Object.freeze({ __proto__: null, base256emoji: gg }), bg = Fa, po = 128, wg = 127, _g = ~wg, mg = Math.pow(2, 31);
function Fa(t, e, r) {
  e = e || [], r = r || 0;
  for (var i = r; t >= mg; )
    e[r++] = t & 255 | po, t /= 128;
  for (; t & _g; )
    e[r++] = t & 255 | po, t >>>= 7;
  return e[r] = t | 0, Fa.bytes = r - i + 1, e;
}
var vg = bs, Eg = 128, go = 127;
function bs(t, i) {
  var r = 0, i = i || 0, s = 0, o = i, u, c = t.length;
  do {
    if (o >= c)
      throw bs.bytes = 0, new RangeError("Could not decode varint");
    u = t[o++], r += s < 28 ? (u & go) << s : (u & go) * Math.pow(2, s), s += 7;
  } while (u >= Eg);
  return bs.bytes = o - i, r;
}
var Dg = Math.pow(2, 7), Sg = Math.pow(2, 14), Ig = Math.pow(2, 21), xg = Math.pow(2, 28), Og = Math.pow(2, 35), Ag = Math.pow(2, 42), Cg = Math.pow(2, 49), Tg = Math.pow(2, 56), Ng = Math.pow(2, 63), Rg = function(t) {
  return t < Dg ? 1 : t < Sg ? 2 : t < Ig ? 3 : t < xg ? 4 : t < Og ? 5 : t < Ag ? 6 : t < Cg ? 7 : t < Tg ? 8 : t < Ng ? 9 : 10;
}, Pg = { encode: bg, decode: vg, encodingLength: Rg }, Ma = Pg;
const yo = (t, e, r = 0) => (Ma.encode(t, e, r), e), bo = (t) => Ma.encodingLength(t), ws = (t, e) => {
  const r = e.byteLength, i = bo(t), s = i + bo(r), o = new Uint8Array(s + r);
  return yo(t, o, 0), yo(r, o, i), o.set(e, s), new Ug(t, r, e, o);
};
class Ug {
  constructor(e, r, i, s) {
    this.code = e, this.size = r, this.digest = i, this.bytes = s;
  }
}
const $a = ({ name: t, code: e, encode: r }) => new Lg(t, e, r);
class Lg {
  constructor(e, r, i) {
    this.name = e, this.code = r, this.encode = i;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const r = this.encode(e);
      return r instanceof Uint8Array ? ws(this.code, r) : r.then((i) => ws(this.code, i));
    } else
      throw Error("Unknown type, must be binary type");
  }
}
const ja = (t) => async (e) => new Uint8Array(await crypto.subtle.digest(t, e)), Fg = $a({ name: "sha2-256", code: 18, encode: ja("SHA-256") }), Mg = $a({ name: "sha2-512", code: 19, encode: ja("SHA-512") });
var $g = Object.freeze({ __proto__: null, sha256: Fg, sha512: Mg });
const Ba = 0, jg = "identity", qa = Pa, Bg = (t) => ws(Ba, qa(t)), qg = { code: Ba, name: jg, encode: qa, digest: Bg };
var zg = Object.freeze({ __proto__: null, identity: qg });
new TextEncoder(), new TextDecoder();
const wo = { ...Up, ...Fp, ...$p, ...Bp, ...Kp, ...Zp, ...rg, ...ng, ...hg, ...yg };
({ ...$g, ...zg });
function za(t) {
  return globalThis.Buffer != null ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t;
}
function Kg(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? za(globalThis.Buffer.allocUnsafe(t)) : new Uint8Array(t);
}
function Ka(t, e, r, i) {
  return { name: t, prefix: e, encoder: { name: t, prefix: e, encode: r }, decoder: { decode: i } };
}
const _o = Ka("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), ki = Ka("ascii", "a", (t) => {
  let e = "a";
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = Kg(t.length);
  for (let r = 0; r < t.length; r++)
    e[r] = t.charCodeAt(r);
  return e;
}), Vg = { utf8: _o, "utf-8": _o, hex: wo.base16, latin1: ki, ascii: ki, binary: ki, ...wo };
function Hg(t, e = "utf8") {
  const r = Vg[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? za(globalThis.Buffer.from(t, "utf-8")) : r.decoder.decode(`${r.prefix}${t}`);
}
const Va = "wc", Wg = 2, qs = "core", Jt = `${Va}@2:${qs}:`, kg = { name: qs, logger: "error" }, Gg = { database: ":memory:" }, Yg = "crypto", mo = "client_ed25519_seed", Jg = Q.ONE_DAY, Xg = "keychain", Qg = "0.3", Zg = "messages", e0 = "0.3", t0 = Q.SIX_HOURS, r0 = "publisher", Ha = "irn", i0 = "error", Wa = "wss://relay.walletconnect.com", vo = "wss://relay.walletconnect.org", s0 = "relayer", Ue = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" }, n0 = "_subscription", jr = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" }, o0 = Q.ONE_SECOND / 2, a0 = "2.9.1", c0 = 1e4, u0 = "0.3", h0 = "WALLETCONNECT_CLIENT_ID", Ft = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" }, l0 = "subscription", f0 = "0.3", d0 = Q.FIVE_SECONDS * 1e3, p0 = "pairing", g0 = "0.3", Br = { wc_pairingDelete: { req: { ttl: Q.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: Q.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: Q.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: Q.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: Q.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: Q.ONE_DAY, prompt: !1, tag: 0 } } }, Lt = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" }, y0 = "history", b0 = "0.3", w0 = "expirer", St = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" }, _0 = "0.3", Gi = "verify-api", Eo = "https://verify.walletconnect.com";
class m0 {
  constructor(e, r) {
    this.core = e, this.logger = r, this.keychain = /* @__PURE__ */ new Map(), this.name = Xg, this.version = Qg, this.initialized = !1, this.storagePrefix = Jt, this.init = async () => {
      if (!this.initialized) {
        const i = await this.getKeyChain();
        typeof i < "u" && (this.keychain = i), this.initialized = !0;
      }
    }, this.has = (i) => (this.isInitialized(), this.keychain.has(i)), this.set = async (i, s) => {
      this.isInitialized(), this.keychain.set(i, s), await this.persist();
    }, this.get = (i) => {
      this.isInitialized();
      const s = this.keychain.get(i);
      if (typeof s > "u") {
        const { message: o } = G("NO_MATCHING_KEY", `${this.name}: ${i}`);
        throw new Error(o);
      }
      return s;
    }, this.del = async (i) => {
      this.isInitialized(), this.keychain.delete(i), await this.persist();
    }, this.core = e, this.logger = _e.generateChildLogger(r, this.name);
  }
  get context() {
    return _e.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, Ea(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Da(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = G("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class v0 {
  constructor(e, r, i) {
    this.core = e, this.logger = r, this.name = Yg, this.initialized = !1, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = !0);
    }, this.hasKeys = (s) => (this.isInitialized(), this.keychain.has(s)), this.getClientId = async () => {
      this.isInitialized();
      const s = await this.getClientSeed(), o = jn(s);
      return aa(o.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const s = Kf();
      return this.setPrivateKey(s.publicKey, s.privateKey);
    }, this.signJWT = async (s) => {
      this.isInitialized();
      const o = await this.getClientSeed(), u = jn(o), c = gs();
      return await Jl(c, s, Jg, u);
    }, this.generateSharedKey = (s, o, u) => {
      this.isInitialized();
      const c = this.getPrivateKey(s), h = Vf(c, o);
      return this.setSymKey(h, u);
    }, this.setSymKey = async (s, o) => {
      this.isInitialized();
      const u = o || Hf(s);
      return await this.keychain.set(u, s), u;
    }, this.deleteKeyPair = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.deleteSymKey = async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }, this.encode = async (s, o, u) => {
      this.isInitialized();
      const c = ma(u), h = Es(o);
      if (Jn(c)) {
        const x = c.senderPublicKey, v = c.receiverPublicKey;
        s = await this.generateSharedKey(x, v);
      }
      const d = this.getSymKey(s), { type: p, senderPublicKey: E } = c;
      return kf({ type: p, symKey: d, message: h, senderPublicKey: E });
    }, this.decode = async (s, o, u) => {
      this.isInitialized();
      const c = Jf(o, u);
      if (Jn(c)) {
        const h = c.receiverPublicKey, d = c.senderPublicKey;
        s = await this.generateSharedKey(h, d);
      }
      try {
        const h = this.getSymKey(s), d = Gf({ symKey: h, encoded: o });
        return Wo(d);
      } catch (h) {
        this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`), this.logger.error(h);
      }
    }, this.getPayloadType = (s) => {
      const o = bi(s);
      return Qr(o.type);
    }, this.getPayloadSenderPublicKey = (s) => {
      const o = bi(s);
      return o.senderPublicKey ? pt(o.senderPublicKey, dt) : void 0;
    }, this.core = e, this.logger = _e.generateChildLogger(r, this.name), this.keychain = i || new m0(this.core, this.logger);
  }
  get context() {
    return _e.getLoggerContext(this.logger);
  }
  async setPrivateKey(e, r) {
    return await this.keychain.set(e, r), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(mo);
    } catch {
      e = gs(), await this.keychain.set(mo, e);
    }
    return Hg(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = G("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class E0 extends rh {
  constructor(e, r) {
    super(e, r), this.logger = e, this.core = r, this.messages = /* @__PURE__ */ new Map(), this.name = Zg, this.version = e0, this.initialized = !1, this.storagePrefix = Jt, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i = await this.getRelayerMessages();
          typeof i < "u" && (this.messages = i), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i);
        } finally {
          this.initialized = !0;
        }
      }
    }, this.set = async (i, s) => {
      this.isInitialized();
      const o = Er(s);
      let u = this.messages.get(i);
      return typeof u > "u" && (u = {}), typeof u[o] < "u" || (u[o] = s, this.messages.set(i, u), await this.persist()), o;
    }, this.get = (i) => {
      this.isInitialized();
      let s = this.messages.get(i);
      return typeof s > "u" && (s = {}), s;
    }, this.has = (i, s) => {
      this.isInitialized();
      const o = this.get(i), u = Er(s);
      return typeof o[u] < "u";
    }, this.del = async (i) => {
      this.isInitialized(), this.messages.delete(i), await this.persist();
    }, this.logger = _e.generateChildLogger(e, this.name), this.core = r;
  }
  get context() {
    return _e.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, Ea(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Da(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = G("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class D0 extends ih {
  constructor(e, r) {
    super(e, r), this.relayer = e, this.logger = r, this.events = new zt(), this.name = r0, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = Q.toMiliseconds(Q.TEN_SECONDS), this.queueTimeout = Q.toMiliseconds(Q.FIVE_SECONDS), this.needsTransportRestart = !1, this.publish = async (i, s, o) => {
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i, message: s, opts: o } });
      try {
        const u = (o == null ? void 0 : o.ttl) || t0, c = ys(o), h = (o == null ? void 0 : o.prompt) || !1, d = (o == null ? void 0 : o.tag) || 0, p = (o == null ? void 0 : o.id) || Ms().toString(), E = { topic: i, message: s, opts: { ttl: u, relay: c, prompt: h, tag: d, id: p } }, x = setTimeout(() => this.queue.set(p, E), this.queueTimeout);
        try {
          await await wi(this.rpcPublish(i, s, u, c, h, d, p), this.publishTimeout), clearTimeout(x), this.relayer.events.emit(Ue.publish, E);
        } catch {
          this.logger.debug("Publishing Payload stalled"), this.needsTransportRestart = !0;
          return;
        }
        this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i, message: s, opts: o } });
      } catch (u) {
        throw this.logger.debug("Failed to Publish Payload"), this.logger.error(u), u;
      }
    }, this.on = (i, s) => {
      this.events.on(i, s);
    }, this.once = (i, s) => {
      this.events.once(i, s);
    }, this.off = (i, s) => {
      this.events.off(i, s);
    }, this.removeListener = (i, s) => {
      this.events.removeListener(i, s);
    }, this.relayer = e, this.logger = _e.generateChildLogger(r, this.name), this.registerEventListeners();
  }
  get context() {
    return _e.getLoggerContext(this.logger);
  }
  rpcPublish(e, r, i, s, o, u, c) {
    var h, d, p, E;
    const x = { method: fi(s.protocol).publish, params: { topic: e, message: r, ttl: i, prompt: o, tag: u }, id: c };
    return ft((h = x.params) == null ? void 0 : h.prompt) && ((d = x.params) == null || delete d.prompt), ft((p = x.params) == null ? void 0 : p.tag) && ((E = x.params) == null || delete E.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: x }), this.relayer.request(x);
  }
  onPublish(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: r, message: i, opts: s } = e;
      await this.publish(r, i, s);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(Sr.HEARTBEAT_EVENTS.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = !1, this.relayer.events.emit(Ue.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(Ue.message_ack, (e) => {
      this.onPublish(e.id.toString());
    });
  }
}
class S0 {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, r) => {
      const i = this.get(e);
      this.exists(e, r) || this.map.set(e, [...i, r]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, r) => this.get(e).includes(r), this.delete = (e, r) => {
      if (typeof r > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e))
        return;
      const i = this.get(e);
      if (!this.exists(e, r))
        return;
      const s = i.filter((o) => o !== r);
      if (!s.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, s);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
}
var I0 = Object.defineProperty, x0 = Object.defineProperties, O0 = Object.getOwnPropertyDescriptors, Do = Object.getOwnPropertySymbols, A0 = Object.prototype.hasOwnProperty, C0 = Object.prototype.propertyIsEnumerable, So = (t, e, r) => e in t ? I0(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, qr = (t, e) => {
  for (var r in e || (e = {}))
    A0.call(e, r) && So(t, r, e[r]);
  if (Do)
    for (var r of Do(e))
      C0.call(e, r) && So(t, r, e[r]);
  return t;
}, Yi = (t, e) => x0(t, O0(e));
class T0 extends oh {
  constructor(e, r) {
    super(e, r), this.relayer = e, this.logger = r, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new S0(), this.events = new zt(), this.name = l0, this.version = f0, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = Jt, this.subscribeTimeout = 1e4, this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restart(), this.registerEventListeners(), this.onEnable(), this.clientId = await this.relayer.core.crypto.getClientId());
    }, this.subscribe = async (i, s) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i, opts: s } });
      try {
        const o = ys(s), u = { topic: i, relay: o };
        this.pending.set(i, u);
        const c = await this.rpcSubscribe(i, o);
        return this.onSubscribe(c, u), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i, opts: s } }), c;
      } catch (o) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(o), o;
      }
    }, this.unsubscribe = async (i, s) => {
      await this.restartToComplete(), this.isInitialized(), typeof (s == null ? void 0 : s.id) < "u" ? await this.unsubscribeById(i, s.id, s) : await this.unsubscribeByTopic(i, s);
    }, this.isSubscribed = async (i) => this.topics.includes(i) ? !0 : await new Promise((s, o) => {
      const u = new Q.Watch();
      u.start(this.pendingSubscriptionWatchLabel);
      const c = setInterval(() => {
        !this.pending.has(i) && this.topics.includes(i) && (clearInterval(c), u.stop(this.pendingSubscriptionWatchLabel), s(!0)), u.elapsed(this.pendingSubscriptionWatchLabel) >= d0 && (clearInterval(c), u.stop(this.pendingSubscriptionWatchLabel), o(new Error("Subscription resolution timeout")));
      }, this.pollingInterval);
    }).catch(() => !1), this.on = (i, s) => {
      this.events.on(i, s);
    }, this.once = (i, s) => {
      this.events.once(i, s);
    }, this.off = (i, s) => {
      this.events.off(i, s);
    }, this.removeListener = (i, s) => {
      this.events.removeListener(i, s);
    }, this.restart = async () => {
      this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1;
    }, this.relayer = e, this.logger = _e.generateChildLogger(r, this.name), this.clientId = "";
  }
  get context() {
    return _e.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, r) {
    let i = !1;
    try {
      i = this.getSubscription(e).topic === r;
    } catch {
    }
    return i;
  }
  onEnable() {
    this.cached = [], this.initialized = !0;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, r) {
    const i = this.topicMap.get(e);
    await Promise.all(i.map(async (s) => await this.unsubscribeById(e, s, r)));
  }
  async unsubscribeById(e, r, i) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: r, opts: i } });
    try {
      const s = ys(i);
      await this.rpcUnsubscribe(e, r, s);
      const o = Ze("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, r, o), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: r, opts: i } });
    } catch (s) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s), s;
    }
  }
  async rpcSubscribe(e, r) {
    const i = { method: fi(r.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i });
    try {
      await await wi(this.relayer.request(i), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(Ue.connection_stalled);
    }
    return Er(e + this.clientId);
  }
  async rpcBatchSubscribe(e) {
    if (!e.length)
      return;
    const r = e[0].relay, i = { method: fi(r.protocol).batchSubscribe, params: { topics: e.map((s) => s.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i });
    try {
      return await await wi(this.relayer.request(i), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(Ue.connection_stalled);
    }
  }
  rpcUnsubscribe(e, r, i) {
    const s = { method: fi(i.protocol).unsubscribe, params: { topic: e, id: r } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s }), this.relayer.request(s);
  }
  onSubscribe(e, r) {
    this.setSubscription(e, Yi(qr({}, r), { id: e })), this.pending.delete(r.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((r) => {
      this.setSubscription(r.id, qr({}, r)), this.pending.delete(r.topic);
    });
  }
  async onUnsubscribe(e, r, i) {
    this.events.removeAllListeners(r), this.hasSubscription(r, e) && this.deleteSubscription(r, i), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, r) {
    this.subscriptions.has(e) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: r }), this.addSubscription(e, r));
  }
  addSubscription(e, r) {
    this.subscriptions.set(e, qr({}, r)), this.topicMap.set(r.topic, e), this.events.emit(Ft.created, r);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const r = this.subscriptions.get(e);
    if (!r) {
      const { message: i } = G("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i);
    }
    return r;
  }
  deleteSubscription(e, r) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: r });
    const i = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(i.topic, e), this.events.emit(Ft.deleted, Yi(qr({}, i), { reason: r }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(Ft.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let r = 0; r < e; r++) {
        const i = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(i);
      }
    }
    this.events.emit(Ft.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length)
        return;
      if (this.subscriptions.size) {
        const { message: r } = G("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length)
      return;
    const r = await this.rpcBatchSubscribe(e);
    Zr(r) && this.onBatchSubscribe(r.map((i, s) => Yi(qr({}, e[s]), { id: i })));
  }
  async onConnect() {
    this.restartInProgress || (await this.restart(), this.onEnable());
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (this.relayer.transportExplicitlyClosed)
      return;
    const e = [];
    this.pending.forEach((r) => {
      e.push(r);
    }), await this.batchSubscribe(e);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(Sr.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }), this.relayer.on(Ue.connect, async () => {
      await this.onConnect();
    }), this.relayer.on(Ue.disconnect, () => {
      this.onDisconnect();
    }), this.events.on(Ft.created, async (e) => {
      const r = Ft.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), await this.persist();
    }), this.events.on(Ft.deleted, async (e) => {
      const r = Ft.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = G("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise((e) => {
      const r = setInterval(() => {
        this.restartInProgress || (clearInterval(r), e());
      }, this.pollingInterval);
    });
  }
}
var N0 = Object.defineProperty, Io = Object.getOwnPropertySymbols, R0 = Object.prototype.hasOwnProperty, P0 = Object.prototype.propertyIsEnumerable, xo = (t, e, r) => e in t ? N0(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, U0 = (t, e) => {
  for (var r in e || (e = {}))
    R0.call(e, r) && xo(t, r, e[r]);
  if (Io)
    for (var r of Io(e))
      P0.call(e, r) && xo(t, r, e[r]);
  return t;
};
class L0 extends sh {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new zt(), this.name = s0, this.transportExplicitlyClosed = !1, this.initialized = !1, this.reconnecting = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.request = async (r) => {
      this.logger.debug("Publishing Request Payload");
      try {
        return await this.toEstablishConnection(), await this.provider.request(r);
      } catch (i) {
        throw this.logger.debug("Failed to Publish Request"), this.logger.error(i), i;
      }
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? _e.generateChildLogger(e.logger, this.name) : _e.pino(_e.getDefaultLoggerOptions({ level: e.logger || i0 })), this.messages = new E0(this.logger, e.core), this.subscriber = new T0(this, this.logger), this.publisher = new D0(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || Wa, this.projectId = e.projectId, this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
    try {
      await this.transportOpen();
    } catch {
      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${vo}...`), await this.restartTransport(vo);
    }
    this.registerEventListeners(), this.initialized = !0, setTimeout(async () => {
      this.subscriber.topics.length === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = !1);
    }, c0);
  }
  get context() {
    return _e.getLoggerContext(this.logger);
  }
  get connected() {
    return this.provider.connection.connected;
  }
  get connecting() {
    return this.provider.connection.connecting;
  }
  async publish(e, r, i) {
    this.isInitialized(), await this.publisher.publish(e, r, i), await this.recordMessageEvent({ topic: e, message: r, publishedAt: Date.now() });
  }
  async subscribe(e, r) {
    var i;
    this.isInitialized();
    let s = ((i = this.subscriber.topicMap.get(e)) == null ? void 0 : i[0]) || "";
    return s || (await Promise.all([new Promise((o) => {
      this.subscriber.once(Ft.created, (u) => {
        u.topic === e && o();
      });
    }), new Promise(async (o) => {
      s = await this.subscriber.subscribe(e, r), o();
    })]), s);
  }
  async unsubscribe(e, r) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, r);
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async transportClose() {
    this.transportExplicitlyClosed = !0, this.connected && (await this.provider.disconnect(), this.events.emit(Ue.transport_closed));
  }
  async transportOpen(e) {
    if (this.transportExplicitlyClosed = !1, !this.reconnecting) {
      this.relayUrl = e || this.relayUrl, this.reconnecting = !0;
      try {
        await Promise.all([new Promise((r) => {
          this.initialized || r(), this.subscriber.once(Ft.resubscribed, () => {
            r();
          });
        }), await Promise.race([new Promise(async (r, i) => {
          await wi(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((s) => i(s)).then(() => r()).finally(() => this.removeListener(Ue.transport_closed, this.rejectTransportOpen));
        }), new Promise((r) => this.once(Ue.transport_closed, this.rejectTransportOpen))])]);
      } catch (r) {
        this.logger.error(r);
        const i = r;
        if (!this.isConnectionStalled(i.message))
          throw r;
        this.events.emit(Ue.transport_closed);
      } finally {
        this.reconnecting = !1;
      }
    }
  }
  async restartTransport(e) {
    this.transportExplicitlyClosed || this.reconnecting || (this.relayUrl = e || this.relayUrl, this.connected && await Promise.all([new Promise((r) => {
      this.provider.once(jr.disconnect, () => {
        r();
      });
    }), this.transportClose()]), await this.createProvider(), await this.transportOpen());
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((r) => e.includes(r));
  }
  rejectTransportOpen() {
    throw new Error("Attempt to connect to relay via `transportOpen` has stalled. Retrying...");
  }
  async createProvider() {
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new pp(new _p(ad({ sdkVersion: a0, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: !0 }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: r, message: i } = e;
    await this.messages.set(r, i);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: r, message: i } = e;
    if (!i || i.length === 0)
      return this.logger.debug(`Ignoring invalid/empty message: ${i}`), !0;
    if (!await this.subscriber.isSubscribed(r))
      return this.logger.debug(`Ignoring message for non-subscribed topic ${r}`), !0;
    const s = this.messages.has(r, i);
    return s && this.logger.debug(`Ignoring duplicate message: ${i}`), s;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), Bs(e)) {
      if (!e.method.endsWith(n0))
        return;
      const r = e.params, { topic: i, message: s, publishedAt: o } = r.data, u = { topic: i, message: s, publishedAt: o };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(U0({ type: "event", event: r.id }, u)), this.events.emit(r.id, u), await this.acknowledgePayload(e), await this.onMessageEvent(u);
    } else
      Ti(e) && this.events.emit(Ue.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(Ue.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const r = $s(e.id, !0);
    await this.provider.connection.send(r);
  }
  registerProviderListeners() {
    this.provider.on(jr.payload, (e) => this.onProviderPayload(e)), this.provider.on(jr.connect, () => {
      this.events.emit(Ue.connect);
    }), this.provider.on(jr.disconnect, () => {
      this.onProviderDisconnect();
    }), this.provider.on(jr.error, (e) => {
      this.logger.error(e), this.events.emit(Ue.error, e);
    });
  }
  registerEventListeners() {
    this.events.on(Ue.connection_stalled, async () => {
      await this.restartTransport();
    });
  }
  onProviderDisconnect() {
    this.events.emit(Ue.disconnect), this.attemptToReconnect();
  }
  attemptToReconnect() {
    this.transportExplicitlyClosed || setTimeout(async () => {
      await this.restartTransport();
    }, Q.toMiliseconds(o0));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = G("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (!this.connected) {
      if (this.connecting)
        return await new Promise((e) => {
          const r = setInterval(() => {
            this.connected && (clearInterval(r), e());
          }, this.connectionStatusPollingInterval);
        });
      await this.restartTransport();
    }
  }
}
var F0 = Object.defineProperty, Oo = Object.getOwnPropertySymbols, M0 = Object.prototype.hasOwnProperty, $0 = Object.prototype.propertyIsEnumerable, Ao = (t, e, r) => e in t ? F0(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Co = (t, e) => {
  for (var r in e || (e = {}))
    M0.call(e, r) && Ao(t, r, e[r]);
  if (Oo)
    for (var r of Oo(e))
      $0.call(e, r) && Ao(t, r, e[r]);
  return t;
};
class Ri extends nh {
  constructor(e, r, i, s = Jt, o = void 0) {
    super(e, r, i, s), this.core = e, this.logger = r, this.name = i, this.map = /* @__PURE__ */ new Map(), this.version = u0, this.cached = [], this.initialized = !1, this.storagePrefix = Jt, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((u) => {
        this.getKey && u !== null && !ft(u) ? this.map.set(this.getKey(u), u) : Td(u) ? this.map.set(u.id, u) : Nd(u) && this.map.set(u.topic, u);
      }), this.cached = [], this.initialized = !0);
    }, this.set = async (u, c) => {
      this.isInitialized(), this.map.has(u) ? await this.update(u, c) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: u, value: c }), this.map.set(u, c), await this.persist());
    }, this.get = (u) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: u }), this.getData(u)), this.getAll = (u) => (this.isInitialized(), u ? this.values.filter((c) => Object.keys(u).every((h) => vp(c[h], u[h]))) : this.values), this.update = async (u, c) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: u, update: c });
      const h = Co(Co({}, this.getData(u)), c);
      this.map.set(u, h), await this.persist();
    }, this.delete = async (u, c) => {
      this.isInitialized(), this.map.has(u) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: u, reason: c }), this.map.delete(u), await this.persist());
    }, this.logger = _e.generateChildLogger(r, this.name), this.storagePrefix = s, this.getKey = o;
  }
  get context() {
    return _e.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const r = this.map.get(e);
    if (!r) {
      const { message: i } = G("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i), new Error(i);
    }
    return r;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length)
        return;
      if (this.map.size) {
        const { message: r } = G("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = G("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class j0 {
  constructor(e, r) {
    this.core = e, this.logger = r, this.name = p0, this.version = g0, this.events = new vs(), this.initialized = !1, this.storagePrefix = Jt, this.ignoredPayloadTypes = [gr], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"));
    }, this.register = ({ methods: i }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i])];
    }, this.create = async () => {
      this.isInitialized();
      const i = gs(), s = await this.core.crypto.setSymKey(i), o = At(Q.FIVE_MINUTES), u = { protocol: Ha }, c = { topic: s, expiry: o, relay: u, active: !1 }, h = md({ protocol: this.core.protocol, version: this.core.version, topic: s, symKey: i, relay: u });
      return await this.pairings.set(s, c), await this.core.relayer.subscribe(s), this.core.expirer.set(s, o), { topic: s, uri: h };
    }, this.pair = async (i) => {
      this.isInitialized(), this.isValidPair(i);
      const { topic: s, symKey: o, relay: u } = bd(i.uri);
      if (this.pairings.keys.includes(s))
        throw new Error(`Pairing already exists: ${s}`);
      if (this.core.crypto.hasKeys(s))
        throw new Error(`Keychain already exists: ${s}`);
      const c = At(Q.FIVE_MINUTES), h = { topic: s, relay: u, expiry: c, active: !1 };
      return await this.pairings.set(s, h), await this.core.crypto.setSymKey(o, s), await this.core.relayer.subscribe(s, { relay: u }), this.core.expirer.set(s, c), i.activatePairing && await this.activate({ topic: s }), h;
    }, this.activate = async ({ topic: i }) => {
      this.isInitialized();
      const s = At(Q.THIRTY_DAYS);
      await this.pairings.update(i, { active: !0, expiry: s }), this.core.expirer.set(i, s);
    }, this.ping = async (i) => {
      this.isInitialized(), await this.isValidPing(i);
      const { topic: s } = i;
      if (this.pairings.keys.includes(s)) {
        const o = await this.sendRequest(s, "wc_pairingPing", {}), { done: u, resolve: c, reject: h } = mr();
        this.events.once(qe("pairing_ping", o), ({ error: d }) => {
          d ? h(d) : c();
        }), await u();
      }
    }, this.updateExpiry = async ({ topic: i, expiry: s }) => {
      this.isInitialized(), await this.pairings.update(i, { expiry: s });
    }, this.updateMetadata = async ({ topic: i, metadata: s }) => {
      this.isInitialized(), await this.pairings.update(i, { peerMetadata: s });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (i) => {
      this.isInitialized(), await this.isValidDisconnect(i);
      const { topic: s } = i;
      this.pairings.keys.includes(s) && (await this.sendRequest(s, "wc_pairingDelete", Ze("USER_DISCONNECTED")), await this.deletePairing(s));
    }, this.sendRequest = async (i, s, o) => {
      const u = Ci(s, o), c = await this.core.crypto.encode(i, u), h = Br[s].req;
      return this.core.history.set(i, u), this.core.relayer.publish(i, c, h), u.id;
    }, this.sendResult = async (i, s, o) => {
      const u = $s(i, o), c = await this.core.crypto.encode(s, u), h = await this.core.history.get(s, i), d = Br[h.request.method].res;
      await this.core.relayer.publish(s, c, d), await this.core.history.resolve(u);
    }, this.sendError = async (i, s, o) => {
      const u = js(i, o), c = await this.core.crypto.encode(s, u), h = await this.core.history.get(s, i), d = Br[h.request.method] ? Br[h.request.method].res : Br.unregistered_method.res;
      await this.core.relayer.publish(s, c, d), await this.core.history.resolve(u);
    }, this.deletePairing = async (i, s) => {
      await this.core.relayer.unsubscribe(i), await Promise.all([this.pairings.delete(i, Ze("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i), s ? Promise.resolve() : this.core.expirer.del(i)]);
    }, this.cleanup = async () => {
      const i = this.pairings.getAll().filter((s) => Gt(s.expiry));
      await Promise.all(i.map((s) => this.deletePairing(s.topic)));
    }, this.onRelayEventRequest = (i) => {
      const { topic: s, payload: o } = i;
      switch (o.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(s, o);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(s, o);
        default:
          return this.onUnknownRpcMethodRequest(s, o);
      }
    }, this.onRelayEventResponse = async (i) => {
      const { topic: s, payload: o } = i, u = (await this.core.history.get(s, o.id)).request.method;
      switch (u) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s, o);
        default:
          return this.onUnknownRpcMethodResponse(u);
      }
    }, this.onPairingPingRequest = async (i, s) => {
      const { id: o } = s;
      try {
        this.isValidPing({ topic: i }), await this.sendResult(o, i, !0), this.events.emit("pairing_ping", { id: o, topic: i });
      } catch (u) {
        await this.sendError(o, i, u), this.logger.error(u);
      }
    }, this.onPairingPingResponse = (i, s) => {
      const { id: o } = s;
      setTimeout(() => {
        qt(s) ? this.events.emit(qe("pairing_ping", o), {}) : Ct(s) && this.events.emit(qe("pairing_ping", o), { error: s.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (i, s) => {
      const { id: o } = s;
      try {
        this.isValidDisconnect({ topic: i }), await this.deletePairing(i), this.events.emit("pairing_delete", { id: o, topic: i });
      } catch (u) {
        await this.sendError(o, i, u), this.logger.error(u);
      }
    }, this.onUnknownRpcMethodRequest = async (i, s) => {
      const { id: o, method: u } = s;
      try {
        if (this.registeredMethods.includes(u))
          return;
        const c = Ze("WC_METHOD_UNSUPPORTED", u);
        await this.sendError(o, i, c), this.logger.error(c);
      } catch (c) {
        await this.sendError(o, i, c), this.logger.error(c);
      }
    }, this.onUnknownRpcMethodResponse = (i) => {
      this.registeredMethods.includes(i) || this.logger.error(Ze("WC_METHOD_UNSUPPORTED", i));
    }, this.isValidPair = (i) => {
      if (!gt(i)) {
        const { message: s } = G("MISSING_OR_INVALID", `pair() params: ${i}`);
        throw new Error(s);
      }
      if (!Cd(i.uri)) {
        const { message: s } = G("MISSING_OR_INVALID", `pair() uri: ${i.uri}`);
        throw new Error(s);
      }
    }, this.isValidPing = async (i) => {
      if (!gt(i)) {
        const { message: o } = G("MISSING_OR_INVALID", `ping() params: ${i}`);
        throw new Error(o);
      }
      const { topic: s } = i;
      await this.isValidPairingTopic(s);
    }, this.isValidDisconnect = async (i) => {
      if (!gt(i)) {
        const { message: o } = G("MISSING_OR_INVALID", `disconnect() params: ${i}`);
        throw new Error(o);
      }
      const { topic: s } = i;
      await this.isValidPairingTopic(s);
    }, this.isValidPairingTopic = async (i) => {
      if (!et(i, !1)) {
        const { message: s } = G("MISSING_OR_INVALID", `pairing topic should be a string: ${i}`);
        throw new Error(s);
      }
      if (!this.pairings.keys.includes(i)) {
        const { message: s } = G("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i}`);
        throw new Error(s);
      }
      if (Gt(this.pairings.get(i).expiry)) {
        await this.deletePairing(i);
        const { message: s } = G("EXPIRED", `pairing topic: ${i}`);
        throw new Error(s);
      }
    }, this.core = e, this.logger = _e.generateChildLogger(r, this.name), this.pairings = new Ri(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return _e.getLoggerContext(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = G("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(Ue.message, async (e) => {
      const { topic: r, message: i } = e;
      if (!this.pairings.keys.includes(r) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i)))
        return;
      const s = await this.core.crypto.decode(r, i);
      Bs(s) ? (this.core.history.set(r, s), this.onRelayEventRequest({ topic: r, payload: s })) : Ti(s) && (await this.core.history.resolve(s), await this.onRelayEventResponse({ topic: r, payload: s }), this.core.history.delete(r, s.id));
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(St.expired, async (e) => {
      const { topic: r } = Ia(e.target);
      r && this.pairings.keys.includes(r) && (await this.deletePairing(r, !0), this.events.emit("pairing_expire", { topic: r }));
    });
  }
}
class B0 extends th {
  constructor(e, r) {
    super(e, r), this.core = e, this.logger = r, this.records = /* @__PURE__ */ new Map(), this.events = new zt(), this.name = y0, this.version = b0, this.cached = [], this.initialized = !1, this.storagePrefix = Jt, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i) => this.records.set(i.id, i)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.set = (i, s, o) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i, request: s, chainId: o }), this.records.has(s.id))
        return;
      const u = { id: s.id, topic: i, request: { method: s.method, params: s.params || null }, chainId: o, expiry: At(Q.THIRTY_DAYS) };
      this.records.set(u.id, u), this.events.emit(Lt.created, u);
    }, this.resolve = async (i) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i }), !this.records.has(i.id))
        return;
      const s = await this.getRecord(i.id);
      typeof s.response > "u" && (s.response = Ct(i) ? { error: i.error } : { result: i.result }, this.records.set(s.id, s), this.events.emit(Lt.updated, s));
    }, this.get = async (i, s) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i, id: s }), await this.getRecord(s)), this.delete = (i, s) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s }), this.values.forEach((o) => {
        if (o.topic === i) {
          if (typeof s < "u" && o.id !== s)
            return;
          this.records.delete(o.id), this.events.emit(Lt.deleted, o);
        }
      });
    }, this.exists = async (i, s) => (this.isInitialized(), this.records.has(s) ? (await this.getRecord(s)).topic === i : !1), this.on = (i, s) => {
      this.events.on(i, s);
    }, this.once = (i, s) => {
      this.events.once(i, s);
    }, this.off = (i, s) => {
      this.events.off(i, s);
    }, this.removeListener = (i, s) => {
      this.events.removeListener(i, s);
    }, this.logger = _e.generateChildLogger(r, this.name);
  }
  get context() {
    return _e.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((r) => {
      if (typeof r.response < "u")
        return;
      const i = { topic: r.topic, request: Ci(r.request.method, r.request.params, r.id), chainId: r.chainId };
      return e.push(i);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const r = this.records.get(e);
    if (!r) {
      const { message: i } = G("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i);
    }
    return r;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(Lt.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length)
        return;
      if (this.records.size) {
        const { message: r } = G("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(Lt.created, (e) => {
      const r = Lt.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e }), this.persist();
    }), this.events.on(Lt.updated, (e) => {
      const r = Lt.updated;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e }), this.persist();
    }), this.events.on(Lt.deleted, (e) => {
      const r = Lt.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e }), this.persist();
    }), this.core.heartbeat.on(Sr.HEARTBEAT_EVENTS.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.records.forEach((e) => {
        Q.toMiliseconds(e.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e.id}`), this.delete(e.topic, e.id));
      });
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = G("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class q0 extends ah {
  constructor(e, r) {
    super(e, r), this.core = e, this.logger = r, this.expirations = /* @__PURE__ */ new Map(), this.events = new zt(), this.name = w0, this.version = _0, this.cached = [], this.initialized = !1, this.storagePrefix = Jt, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i) => this.expirations.set(i.target, i)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.has = (i) => {
      try {
        const s = this.formatTarget(i);
        return typeof this.getExpiration(s) < "u";
      } catch {
        return !1;
      }
    }, this.set = (i, s) => {
      this.isInitialized();
      const o = this.formatTarget(i), u = { target: o, expiry: s };
      this.expirations.set(o, u), this.checkExpiry(o, u), this.events.emit(St.created, { target: o, expiration: u });
    }, this.get = (i) => {
      this.isInitialized();
      const s = this.formatTarget(i);
      return this.getExpiration(s);
    }, this.del = (i) => {
      if (this.isInitialized(), this.has(i)) {
        const s = this.formatTarget(i), o = this.getExpiration(s);
        this.expirations.delete(s), this.events.emit(St.deleted, { target: s, expiration: o });
      }
    }, this.on = (i, s) => {
      this.events.on(i, s);
    }, this.once = (i, s) => {
      this.events.once(i, s);
    }, this.off = (i, s) => {
      this.events.off(i, s);
    }, this.removeListener = (i, s) => {
      this.events.removeListener(i, s);
    }, this.logger = _e.generateChildLogger(r, this.name);
  }
  get context() {
    return _e.getLoggerContext(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string")
      return cd(e);
    if (typeof e == "number")
      return ud(e);
    const { message: r } = G("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(r);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(St.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length)
        return;
      if (this.expirations.size) {
        const { message: r } = G("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const r = this.expirations.get(e);
    if (!r) {
      const { message: i } = G("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i), new Error(i);
    }
    return r;
  }
  checkExpiry(e, r) {
    const { expiry: i } = r;
    Q.toMiliseconds(i) - Date.now() <= 0 && this.expire(e, r);
  }
  expire(e, r) {
    this.expirations.delete(e), this.events.emit(St.expired, { target: e, expiration: r });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, r) => this.checkExpiry(r, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(Sr.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(St.created, (e) => {
      const r = St.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    }), this.events.on(St.expired, (e) => {
      const r = St.expired;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    }), this.events.on(St.deleted, (e) => {
      const r = St.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = G("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class z0 extends ch {
  constructor(e, r) {
    super(e, r), this.projectId = e, this.logger = r, this.name = Gi, this.initialized = !1, this.init = async (i) => {
      va() || !Ps() || (this.verifyUrl = (i == null ? void 0 : i.verifyUrl) || Eo, await this.createIframe());
    }, this.register = async (i) => {
      var s;
      if (this.initialized || await this.init(), !!this.iframe)
        try {
          (s = this.iframe.contentWindow) == null || s.postMessage(i.attestationId, this.verifyUrl), this.logger.info(`postMessage sent: ${i.attestationId} ${this.verifyUrl}`);
        } catch {
        }
    }, this.resolve = async (i) => {
      var s;
      if (this.isDevEnv)
        return "";
      this.logger.info(`resolving attestation: ${i.attestationId}`);
      const o = this.startAbortTimer(Q.FIVE_SECONDS), u = await fetch(`${this.verifyUrl}/attestation/${i.attestationId}`, { signal: this.abortController.signal });
      return clearTimeout(o), u.status === 200 ? (s = await u.json()) == null ? void 0 : s.origin : "";
    }, this.createIframe = async () => {
      try {
        await Promise.race([new Promise((i, s) => {
          if (document.getElementById(Gi))
            return i();
          const o = document.createElement("iframe");
          o.setAttribute("id", Gi), o.setAttribute("src", `${this.verifyUrl}/${this.projectId}`), o.style.display = "none", o.addEventListener("load", () => {
            this.initialized = !0, i();
          }), o.addEventListener("error", (u) => {
            s(u);
          }), document.body.append(o), this.iframe = o;
        }), new Promise((i) => {
          setTimeout(() => i("iframe load timeout"), Q.toMiliseconds(Q.ONE_SECOND / 2));
        })]);
      } catch (i) {
        this.logger.error(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.error(i);
      }
    }, this.logger = _e.generateChildLogger(r, this.name), this.verifyUrl = Eo, this.abortController = new AbortController(), this.isDevEnv = Rs() && process.env.IS_VITEST;
  }
  get context() {
    return _e.getLoggerContext(this.logger);
  }
  startAbortTimer(e) {
    return setTimeout(() => this.abortController.abort(), Q.toMiliseconds(e));
  }
}
var K0 = Object.defineProperty, To = Object.getOwnPropertySymbols, V0 = Object.prototype.hasOwnProperty, H0 = Object.prototype.propertyIsEnumerable, No = (t, e, r) => e in t ? K0(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Ro = (t, e) => {
  for (var r in e || (e = {}))
    V0.call(e, r) && No(t, r, e[r]);
  if (To)
    for (var r of To(e))
      H0.call(e, r) && No(t, r, e[r]);
  return t;
};
class zs extends eh {
  constructor(e) {
    super(e), this.protocol = Va, this.version = Wg, this.name = qs, this.events = new zt(), this.initialized = !1, this.on = (i, s) => this.events.on(i, s), this.once = (i, s) => this.events.once(i, s), this.off = (i, s) => this.events.off(i, s), this.removeListener = (i, s) => this.events.removeListener(i, s), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || Wa;
    const r = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : _e.pino(_e.getDefaultLoggerOptions({ level: (e == null ? void 0 : e.logger) || kg.logger }));
    this.logger = _e.generateChildLogger(r, this.name), this.heartbeat = new Sr.HeartBeat(), this.crypto = new v0(this, this.logger, e == null ? void 0 : e.keychain), this.history = new B0(this, this.logger), this.expirer = new q0(this, this.logger), this.storage = e != null && e.storage ? e.storage : new Mu(Ro(Ro({}, Gg), e == null ? void 0 : e.storageOptions)), this.relayer = new L0({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new j0(this, this.logger), this.verify = new z0(this.projectId || "", this.logger);
  }
  static async init(e) {
    const r = new zs(e);
    await r.initialize();
    const i = await r.crypto.getClientId();
    return await r.storage.setItem(h0, i), r;
  }
  get context() {
    return _e.getLoggerContext(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = !0, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
}
const W0 = zs, ka = "wc", Ga = 2, Ya = "client", Ks = `${ka}@${Ga}:${Ya}:`, Ji = { name: Ya, logger: "error", controller: !1, relayUrl: "wss://relay.walletconnect.com" }, k0 = "WALLETCONNECT_DEEPLINK_CHOICE", G0 = "proposal", Y0 = "Proposal expired", J0 = "session", li = Q.SEVEN_DAYS, X0 = "engine", zr = { wc_sessionPropose: { req: { ttl: Q.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: Q.FIVE_MINUTES, prompt: !1, tag: 1101 } }, wc_sessionSettle: { req: { ttl: Q.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: Q.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: Q.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: Q.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: Q.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: Q.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: Q.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: Q.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: Q.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: Q.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: Q.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: Q.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: Q.THIRTY_SECONDS, prompt: !1, tag: 1114 }, res: { ttl: Q.THIRTY_SECONDS, prompt: !1, tag: 1115 } } }, Xi = { min: Q.FIVE_MINUTES, max: Q.SEVEN_DAYS }, Kr = { idle: "idle", active: "active" }, Q0 = "request", Z0 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var ey = Object.defineProperty, ty = Object.defineProperties, ry = Object.getOwnPropertyDescriptors, Po = Object.getOwnPropertySymbols, iy = Object.prototype.hasOwnProperty, sy = Object.prototype.propertyIsEnumerable, Uo = (t, e, r) => e in t ? ey(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Dt = (t, e) => {
  for (var r in e || (e = {}))
    iy.call(e, r) && Uo(t, r, e[r]);
  if (Po)
    for (var r of Po(e))
      sy.call(e, r) && Uo(t, r, e[r]);
  return t;
}, Qi = (t, e) => ty(t, ry(e));
class ny extends hh {
  constructor(e) {
    super(e), this.name = X0, this.events = new vs(), this.initialized = !1, this.ignoredPayloadTypes = [gr], this.requestQueue = { state: Kr.idle, requests: [] }, this.requestQueueDelay = Q.ONE_SECOND, this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.client.core.pairing.register({ methods: Object.keys(zr) }), this.initialized = !0, setTimeout(() => {
        this.requestQueue.requests = this.getPendingSessionRequests(), this.processRequestQueue();
      }, Q.toMiliseconds(this.requestQueueDelay)));
    }, this.connect = async (r) => {
      this.isInitialized();
      const i = Qi(Dt({}, r), { requiredNamespaces: r.requiredNamespaces || {}, optionalNamespaces: r.optionalNamespaces || {} });
      await this.isValidConnect(i);
      const { pairingTopic: s, requiredNamespaces: o, optionalNamespaces: u, sessionProperties: c, relays: h } = i;
      let d = s, p, E = !1;
      if (d && (E = this.client.core.pairing.pairings.get(d).active), !d || !E) {
        const { topic: O, uri: y } = await this.client.core.pairing.create();
        d = O, p = y;
      }
      const x = await this.client.core.crypto.generateKeyPair(), v = Dt({ requiredNamespaces: o, optionalNamespaces: u, relays: h ?? [{ protocol: Ha }], proposer: { publicKey: x, metadata: this.client.metadata } }, c && { sessionProperties: c }), { reject: I, resolve: N, done: R } = mr(Q.FIVE_MINUTES, Y0);
      if (this.events.once(qe("session_connect"), async ({ error: O, session: y }) => {
        if (O)
          I(O);
        else if (y) {
          y.self.publicKey = x;
          const _ = Qi(Dt({}, y), { requiredNamespaces: y.requiredNamespaces, optionalNamespaces: y.optionalNamespaces });
          await this.client.session.set(y.topic, _), await this.setExpiry(y.topic, y.expiry), d && await this.client.core.pairing.updateMetadata({ topic: d, metadata: y.peer.metadata }), N(_);
        }
      }), !d) {
        const { message: O } = G("NO_MATCHING_KEY", `connect() pairing topic: ${d}`);
        throw new Error(O);
      }
      const K = await this.sendRequest(d, "wc_sessionPropose", v), m = At(Q.FIVE_MINUTES);
      return await this.setProposal(K, Dt({ id: K, expiry: m }, v)), { uri: p, approval: R };
    }, this.pair = async (r) => (this.isInitialized(), await this.client.core.pairing.pair(r)), this.approve = async (r) => {
      this.isInitialized(), await this.isValidApprove(r);
      const { id: i, relayProtocol: s, namespaces: o, sessionProperties: u } = r, c = this.client.proposal.get(i);
      let { pairingTopic: h, proposer: d, requiredNamespaces: p, optionalNamespaces: E } = c;
      h = h || "", Hr(p) || (p = Sd(o, "approve()"));
      const x = await this.client.core.crypto.generateKeyPair(), v = d.publicKey, I = await this.client.core.crypto.generateSharedKey(x, v);
      h && i && (await this.client.core.pairing.updateMetadata({ topic: h, metadata: d.metadata }), await this.sendResult(i, h, { relay: { protocol: s ?? "irn" }, responderPublicKey: x }), await this.client.proposal.delete(i, Ze("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: h }));
      const N = Dt({ relay: { protocol: s ?? "irn" }, namespaces: o, requiredNamespaces: p, optionalNamespaces: E, pairingTopic: h, controller: { publicKey: x, metadata: this.client.metadata }, expiry: At(li) }, u && { sessionProperties: u });
      await this.client.core.relayer.subscribe(I), await this.sendRequest(I, "wc_sessionSettle", N);
      const R = Qi(Dt({}, N), { topic: I, pairingTopic: h, acknowledged: !1, self: N.controller, peer: { publicKey: d.publicKey, metadata: d.metadata }, controller: x });
      return await this.client.session.set(I, R), await this.setExpiry(I, At(li)), { topic: I, acknowledged: () => new Promise((K) => setTimeout(() => K(this.client.session.get(I)), 500)) };
    }, this.reject = async (r) => {
      this.isInitialized(), await this.isValidReject(r);
      const { id: i, reason: s } = r, { pairingTopic: o } = this.client.proposal.get(i);
      o && (await this.sendError(i, o, s), await this.client.proposal.delete(i, Ze("USER_DISCONNECTED")));
    }, this.update = async (r) => {
      this.isInitialized(), await this.isValidUpdate(r);
      const { topic: i, namespaces: s } = r, o = await this.sendRequest(i, "wc_sessionUpdate", { namespaces: s }), { done: u, resolve: c, reject: h } = mr();
      return this.events.once(qe("session_update", o), ({ error: d }) => {
        d ? h(d) : c();
      }), await this.client.session.update(i, { namespaces: s }), { acknowledged: u };
    }, this.extend = async (r) => {
      this.isInitialized(), await this.isValidExtend(r);
      const { topic: i } = r, s = await this.sendRequest(i, "wc_sessionExtend", {}), { done: o, resolve: u, reject: c } = mr();
      return this.events.once(qe("session_extend", s), ({ error: h }) => {
        h ? c(h) : u();
      }), await this.setExpiry(i, At(li)), { acknowledged: o };
    }, this.request = async (r) => {
      this.isInitialized(), await this.isValidRequest(r);
      const { chainId: i, request: s, topic: o, expiry: u } = r, c = await this.sendRequest(o, "wc_sessionRequest", { request: s, chainId: i }, u), { done: h, resolve: d, reject: p } = mr(u);
      this.events.once(qe("session_request", c), ({ error: x, result: v }) => {
        x ? p(x) : d(v);
      }), this.client.events.emit("session_request_sent", { topic: o, request: s, chainId: i, id: c });
      const E = await this.client.core.storage.getItem(k0);
      return hd({ id: c, topic: o, wcDeepLink: E }), await h();
    }, this.respond = async (r) => {
      this.isInitialized(), await this.isValidRespond(r);
      const { topic: i, response: s } = r, { id: o } = s;
      qt(s) ? await this.sendResult(o, i, s.result) : Ct(s) && await this.sendError(o, i, s.error), this.cleanupAfterResponse(r);
    }, this.ping = async (r) => {
      this.isInitialized(), await this.isValidPing(r);
      const { topic: i } = r;
      if (this.client.session.keys.includes(i)) {
        const s = await this.sendRequest(i, "wc_sessionPing", {}), { done: o, resolve: u, reject: c } = mr();
        this.events.once(qe("session_ping", s), ({ error: h }) => {
          h ? c(h) : u();
        }), await o();
      } else
        this.client.core.pairing.pairings.keys.includes(i) && await this.client.core.pairing.ping({ topic: i });
    }, this.emit = async (r) => {
      this.isInitialized(), await this.isValidEmit(r);
      const { topic: i, event: s, chainId: o } = r;
      await this.sendRequest(i, "wc_sessionEvent", { event: s, chainId: o });
    }, this.disconnect = async (r) => {
      this.isInitialized(), await this.isValidDisconnect(r);
      const { topic: i } = r;
      if (this.client.session.keys.includes(i)) {
        const s = Ms().toString();
        let o;
        const u = (c) => {
          (c == null ? void 0 : c.id.toString()) === s && (this.client.core.relayer.events.removeListener(Ue.message_ack, u), o());
        };
        await Promise.all([new Promise((c) => {
          o = c, this.client.core.relayer.on(Ue.message_ack, u);
        }), this.sendRequest(i, "wc_sessionDelete", Ze("USER_DISCONNECTED"), void 0, s)]), await this.deleteSession(i);
      } else
        await this.client.core.pairing.disconnect({ topic: i });
    }, this.find = (r) => (this.isInitialized(), this.client.session.getAll().filter((i) => Od(i, r))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async (r) => {
      if (r.pairingTopic)
        try {
          const i = this.client.core.pairing.pairings.get(r.pairingTopic), s = this.client.core.pairing.pairings.getAll().filter((o) => {
            var u, c;
            return ((u = o.peerMetadata) == null ? void 0 : u.url) && ((c = o.peerMetadata) == null ? void 0 : c.url) === r.peer.metadata.url && o.topic && o.topic !== i.topic;
          });
          if (s.length === 0)
            return;
          this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`), await Promise.all(s.map((o) => this.client.core.pairing.disconnect({ topic: o.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
        } catch (i) {
          this.client.logger.error(i);
        }
    }, this.deleteSession = async (r, i) => {
      const { self: s } = this.client.session.get(r);
      await this.client.core.relayer.unsubscribe(r), this.client.session.delete(r, Ze("USER_DISCONNECTED")), this.client.core.crypto.keychain.has(s.publicKey) && await this.client.core.crypto.deleteKeyPair(s.publicKey), this.client.core.crypto.keychain.has(r) && await this.client.core.crypto.deleteSymKey(r), i || this.client.core.expirer.del(r);
    }, this.deleteProposal = async (r, i) => {
      await Promise.all([this.client.proposal.delete(r, Ze("USER_DISCONNECTED")), i ? Promise.resolve() : this.client.core.expirer.del(r)]);
    }, this.deletePendingSessionRequest = async (r, i, s = !1) => {
      await Promise.all([this.client.pendingRequest.delete(r, i), s ? Promise.resolve() : this.client.core.expirer.del(r)]), this.requestQueue.requests = this.requestQueue.requests.filter((o) => o.id !== r), s && (this.requestQueue.state = Kr.idle);
    }, this.setExpiry = async (r, i) => {
      this.client.session.keys.includes(r) && await this.client.session.update(r, { expiry: i }), this.client.core.expirer.set(r, i);
    }, this.setProposal = async (r, i) => {
      await this.client.proposal.set(r, i), this.client.core.expirer.set(r, i.expiry);
    }, this.setPendingSessionRequest = async (r) => {
      const i = zr.wc_sessionRequest.req.ttl, { id: s, topic: o, params: u } = r;
      await this.client.pendingRequest.set(s, { id: s, topic: o, params: u }), i && this.client.core.expirer.set(s, At(i));
    }, this.sendRequest = async (r, i, s, o, u) => {
      const c = Ci(i, s);
      if (Ps() && Z0.includes(i)) {
        const p = Er(JSON.stringify(c));
        await this.client.core.verify.register({ attestationId: p });
      }
      const h = await this.client.core.crypto.encode(r, c), d = zr[i].req;
      return o && (d.ttl = o), u && (d.id = u), this.client.core.history.set(r, c), this.client.core.relayer.publish(r, h, d), c.id;
    }, this.sendResult = async (r, i, s) => {
      const o = $s(r, s), u = await this.client.core.crypto.encode(i, o), c = await this.client.core.history.get(i, r), h = zr[c.request.method].res;
      this.client.core.relayer.publish(i, u, h), await this.client.core.history.resolve(o);
    }, this.sendError = async (r, i, s) => {
      const o = js(r, s), u = await this.client.core.crypto.encode(i, o), c = await this.client.core.history.get(i, r), h = zr[c.request.method].res;
      this.client.core.relayer.publish(i, u, h), await this.client.core.history.resolve(o);
    }, this.cleanup = async () => {
      const r = [], i = [];
      this.client.session.getAll().forEach((s) => {
        Gt(s.expiry) && r.push(s.topic);
      }), this.client.proposal.getAll().forEach((s) => {
        Gt(s.expiry) && i.push(s.id);
      }), await Promise.all([...r.map((s) => this.deleteSession(s)), ...i.map((s) => this.deleteProposal(s))]);
    }, this.onRelayEventRequest = (r) => {
      const { topic: i, payload: s } = r, o = s.method;
      switch (o) {
        case "wc_sessionPropose":
          return this.onSessionProposeRequest(i, s);
        case "wc_sessionSettle":
          return this.onSessionSettleRequest(i, s);
        case "wc_sessionUpdate":
          return this.onSessionUpdateRequest(i, s);
        case "wc_sessionExtend":
          return this.onSessionExtendRequest(i, s);
        case "wc_sessionPing":
          return this.onSessionPingRequest(i, s);
        case "wc_sessionDelete":
          return this.onSessionDeleteRequest(i, s);
        case "wc_sessionRequest":
          return this.onSessionRequest(i, s);
        case "wc_sessionEvent":
          return this.onSessionEventRequest(i, s);
        default:
          return this.client.logger.info(`Unsupported request method ${o}`);
      }
    }, this.onRelayEventResponse = async (r) => {
      const { topic: i, payload: s } = r, o = (await this.client.core.history.get(i, s.id)).request.method;
      switch (o) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(i, s);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(i, s);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(i, s);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(i, s);
        case "wc_sessionPing":
          return this.onSessionPingResponse(i, s);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(i, s);
        default:
          return this.client.logger.info(`Unsupported response method ${o}`);
      }
    }, this.onRelayEventUnknownPayload = (r) => {
      const { topic: i } = r, { message: s } = G("MISSING_OR_INVALID", `Decoded payload on topic ${i} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s);
    }, this.onSessionProposeRequest = async (r, i) => {
      const { params: s, id: o } = i;
      try {
        this.isValidConnect(Dt({}, i.params));
        const u = At(Q.FIVE_MINUTES), c = Dt({ id: o, pairingTopic: r, expiry: u }, s);
        await this.setProposal(o, c);
        const h = Er(JSON.stringify(i)), d = await this.getVerifyContext(h, c.proposer.metadata);
        this.client.events.emit("session_proposal", { id: o, params: c, verifyContext: d });
      } catch (u) {
        await this.sendError(o, r, u), this.client.logger.error(u);
      }
    }, this.onSessionProposeResponse = async (r, i) => {
      const { id: s } = i;
      if (qt(i)) {
        const { result: o } = i;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: o });
        const u = this.client.proposal.get(s);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: u });
        const c = u.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: c });
        const h = o.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: h });
        const d = await this.client.core.crypto.generateSharedKey(c, h);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: d });
        const p = await this.client.core.relayer.subscribe(d);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: p }), await this.client.core.pairing.activate({ topic: r });
      } else
        Ct(i) && (await this.client.proposal.delete(s, Ze("USER_DISCONNECTED")), this.events.emit(qe("session_connect"), { error: i.error }));
    }, this.onSessionSettleRequest = async (r, i) => {
      const { id: s, params: o } = i;
      try {
        this.isValidSessionSettleRequest(o);
        const { relay: u, controller: c, expiry: h, namespaces: d, requiredNamespaces: p, optionalNamespaces: E, sessionProperties: x, pairingTopic: v } = i.params, I = Dt({ topic: r, relay: u, expiry: h, namespaces: d, acknowledged: !0, pairingTopic: v, requiredNamespaces: p, optionalNamespaces: E, controller: c.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: c.publicKey, metadata: c.metadata } }, x && { sessionProperties: x });
        await this.sendResult(i.id, r, !0), this.events.emit(qe("session_connect"), { session: I }), this.cleanupDuplicatePairings(I);
      } catch (u) {
        await this.sendError(s, r, u), this.client.logger.error(u);
      }
    }, this.onSessionSettleResponse = async (r, i) => {
      const { id: s } = i;
      qt(i) ? (await this.client.session.update(r, { acknowledged: !0 }), this.events.emit(qe("session_approve", s), {})) : Ct(i) && (await this.client.session.delete(r, Ze("USER_DISCONNECTED")), this.events.emit(qe("session_approve", s), { error: i.error }));
    }, this.onSessionUpdateRequest = async (r, i) => {
      const { params: s, id: o } = i;
      try {
        this.isValidUpdate(Dt({ topic: r }, s)), await this.client.session.update(r, { namespaces: s.namespaces }), await this.sendResult(o, r, !0), this.client.events.emit("session_update", { id: o, topic: r, params: s });
      } catch (u) {
        await this.sendError(o, r, u), this.client.logger.error(u);
      }
    }, this.onSessionUpdateResponse = (r, i) => {
      const { id: s } = i;
      qt(i) ? this.events.emit(qe("session_update", s), {}) : Ct(i) && this.events.emit(qe("session_update", s), { error: i.error });
    }, this.onSessionExtendRequest = async (r, i) => {
      const { id: s } = i;
      try {
        this.isValidExtend({ topic: r }), await this.setExpiry(r, At(li)), await this.sendResult(s, r, !0), this.client.events.emit("session_extend", { id: s, topic: r });
      } catch (o) {
        await this.sendError(s, r, o), this.client.logger.error(o);
      }
    }, this.onSessionExtendResponse = (r, i) => {
      const { id: s } = i;
      qt(i) ? this.events.emit(qe("session_extend", s), {}) : Ct(i) && this.events.emit(qe("session_extend", s), { error: i.error });
    }, this.onSessionPingRequest = async (r, i) => {
      const { id: s } = i;
      try {
        this.isValidPing({ topic: r }), await this.sendResult(s, r, !0), this.client.events.emit("session_ping", { id: s, topic: r });
      } catch (o) {
        await this.sendError(s, r, o), this.client.logger.error(o);
      }
    }, this.onSessionPingResponse = (r, i) => {
      const { id: s } = i;
      setTimeout(() => {
        qt(i) ? this.events.emit(qe("session_ping", s), {}) : Ct(i) && this.events.emit(qe("session_ping", s), { error: i.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (r, i) => {
      const { id: s } = i;
      try {
        this.isValidDisconnect({ topic: r, reason: i.params }), await Promise.all([new Promise((o) => {
          this.client.core.relayer.once(Ue.publish, async () => {
            o(await this.deleteSession(r));
          });
        }), this.sendResult(s, r, !0)]), this.client.events.emit("session_delete", { id: s, topic: r });
      } catch (o) {
        this.client.logger.error(o);
      }
    }, this.onSessionRequest = async (r, i) => {
      const { id: s, params: o } = i;
      try {
        this.isValidRequest(Dt({ topic: r }, o)), await this.setPendingSessionRequest({ id: s, topic: r, params: o }), this.addRequestToQueue({ id: s, topic: r, params: o }), await this.processRequestQueue();
      } catch (u) {
        await this.sendError(s, r, u), this.client.logger.error(u);
      }
    }, this.onSessionRequestResponse = (r, i) => {
      const { id: s } = i;
      qt(i) ? this.events.emit(qe("session_request", s), { result: i.result }) : Ct(i) && this.events.emit(qe("session_request", s), { error: i.error });
    }, this.onSessionEventRequest = async (r, i) => {
      const { id: s, params: o } = i;
      try {
        this.isValidEmit(Dt({ topic: r }, o)), this.client.events.emit("session_event", { id: s, topic: r, params: o });
      } catch (u) {
        await this.sendError(s, r, u), this.client.logger.error(u);
      }
    }, this.addRequestToQueue = (r) => {
      this.requestQueue.requests.push(r);
    }, this.cleanupAfterResponse = (r) => {
      this.deletePendingSessionRequest(r.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.requestQueue.state = Kr.idle, this.processRequestQueue();
      }, Q.toMiliseconds(this.requestQueueDelay));
    }, this.processRequestQueue = async () => {
      if (this.requestQueue.state === Kr.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const r = this.requestQueue.requests[0];
      if (!r) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        const { id: i, topic: s, params: o } = r, u = Er(JSON.stringify({ id: i, params: o })), c = this.client.session.get(s), h = await this.getVerifyContext(u, c.peer.metadata);
        this.requestQueue.state = Kr.active, this.client.events.emit("session_request", { id: i, topic: s, params: o, verifyContext: h });
      } catch (i) {
        this.client.logger.error(i);
      }
    }, this.isValidConnect = async (r) => {
      if (!gt(r)) {
        const { message: h } = G("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(r)}`);
        throw new Error(h);
      }
      const { pairingTopic: i, requiredNamespaces: s, optionalNamespaces: o, sessionProperties: u, relays: c } = r;
      if (ft(i) || await this.isValidPairingTopic(i), !jd(c, !0)) {
        const { message: h } = G("MISSING_OR_INVALID", `connect() relays: ${c}`);
        throw new Error(h);
      }
      !ft(s) && Hr(s) !== 0 && this.validateNamespaces(s, "requiredNamespaces"), !ft(o) && Hr(o) !== 0 && this.validateNamespaces(o, "optionalNamespaces"), ft(u) || this.validateSessionProps(u, "sessionProperties");
    }, this.validateNamespaces = (r, i) => {
      const s = $d(r, "connect()", i);
      if (s)
        throw new Error(s.message);
    }, this.isValidApprove = async (r) => {
      if (!gt(r))
        throw new Error(G("MISSING_OR_INVALID", `approve() params: ${r}`).message);
      const { id: i, namespaces: s, relayProtocol: o, sessionProperties: u } = r;
      await this.isValidProposalId(i);
      const c = this.client.proposal.get(i), h = di(s, "approve()");
      if (h)
        throw new Error(h.message);
      const d = so(c.requiredNamespaces, s, "approve()");
      if (d)
        throw new Error(d.message);
      if (!et(o, !0)) {
        const { message: p } = G("MISSING_OR_INVALID", `approve() relayProtocol: ${o}`);
        throw new Error(p);
      }
      ft(u) || this.validateSessionProps(u, "sessionProperties");
    }, this.isValidReject = async (r) => {
      if (!gt(r)) {
        const { message: o } = G("MISSING_OR_INVALID", `reject() params: ${r}`);
        throw new Error(o);
      }
      const { id: i, reason: s } = r;
      if (await this.isValidProposalId(i), !qd(s)) {
        const { message: o } = G("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s)}`);
        throw new Error(o);
      }
    }, this.isValidSessionSettleRequest = (r) => {
      if (!gt(r)) {
        const { message: d } = G("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${r}`);
        throw new Error(d);
      }
      const { relay: i, controller: s, namespaces: o, expiry: u } = r;
      if (!Oa(i)) {
        const { message: d } = G("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(d);
      }
      const c = Rd(s, "onSessionSettleRequest()");
      if (c)
        throw new Error(c.message);
      const h = di(o, "onSessionSettleRequest()");
      if (h)
        throw new Error(h.message);
      if (Gt(u)) {
        const { message: d } = G("EXPIRED", "onSessionSettleRequest()");
        throw new Error(d);
      }
    }, this.isValidUpdate = async (r) => {
      if (!gt(r)) {
        const { message: h } = G("MISSING_OR_INVALID", `update() params: ${r}`);
        throw new Error(h);
      }
      const { topic: i, namespaces: s } = r;
      await this.isValidSessionTopic(i);
      const o = this.client.session.get(i), u = di(s, "update()");
      if (u)
        throw new Error(u.message);
      const c = so(o.requiredNamespaces, s, "update()");
      if (c)
        throw new Error(c.message);
    }, this.isValidExtend = async (r) => {
      if (!gt(r)) {
        const { message: s } = G("MISSING_OR_INVALID", `extend() params: ${r}`);
        throw new Error(s);
      }
      const { topic: i } = r;
      await this.isValidSessionTopic(i);
    }, this.isValidRequest = async (r) => {
      if (!gt(r)) {
        const { message: h } = G("MISSING_OR_INVALID", `request() params: ${r}`);
        throw new Error(h);
      }
      const { topic: i, request: s, chainId: o, expiry: u } = r;
      await this.isValidSessionTopic(i);
      const { namespaces: c } = this.client.session.get(i);
      if (!io(c, o)) {
        const { message: h } = G("MISSING_OR_INVALID", `request() chainId: ${o}`);
        throw new Error(h);
      }
      if (!zd(s)) {
        const { message: h } = G("MISSING_OR_INVALID", `request() ${JSON.stringify(s)}`);
        throw new Error(h);
      }
      if (!Hd(c, o, s.method)) {
        const { message: h } = G("MISSING_OR_INVALID", `request() method: ${s.method}`);
        throw new Error(h);
      }
      if (u && !Yd(u, Xi)) {
        const { message: h } = G("MISSING_OR_INVALID", `request() expiry: ${u}. Expiry must be a number (in seconds) between ${Xi.min} and ${Xi.max}`);
        throw new Error(h);
      }
    }, this.isValidRespond = async (r) => {
      if (!gt(r)) {
        const { message: o } = G("MISSING_OR_INVALID", `respond() params: ${r}`);
        throw new Error(o);
      }
      const { topic: i, response: s } = r;
      if (await this.isValidSessionTopic(i), !Kd(s)) {
        const { message: o } = G("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(s)}`);
        throw new Error(o);
      }
    }, this.isValidPing = async (r) => {
      if (!gt(r)) {
        const { message: s } = G("MISSING_OR_INVALID", `ping() params: ${r}`);
        throw new Error(s);
      }
      const { topic: i } = r;
      await this.isValidSessionOrPairingTopic(i);
    }, this.isValidEmit = async (r) => {
      if (!gt(r)) {
        const { message: c } = G("MISSING_OR_INVALID", `emit() params: ${r}`);
        throw new Error(c);
      }
      const { topic: i, event: s, chainId: o } = r;
      await this.isValidSessionTopic(i);
      const { namespaces: u } = this.client.session.get(i);
      if (!io(u, o)) {
        const { message: c } = G("MISSING_OR_INVALID", `emit() chainId: ${o}`);
        throw new Error(c);
      }
      if (!Vd(s)) {
        const { message: c } = G("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
        throw new Error(c);
      }
      if (!Wd(u, o, s.name)) {
        const { message: c } = G("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
        throw new Error(c);
      }
    }, this.isValidDisconnect = async (r) => {
      if (!gt(r)) {
        const { message: s } = G("MISSING_OR_INVALID", `disconnect() params: ${r}`);
        throw new Error(s);
      }
      const { topic: i } = r;
      await this.isValidSessionOrPairingTopic(i);
    }, this.getVerifyContext = async (r, i) => {
      const s = { verified: { verifyUrl: i.verifyUrl || "", validation: "UNKNOWN", origin: i.url || "" } };
      try {
        const o = await this.client.core.verify.resolve({ attestationId: r, verifyUrl: i.verifyUrl });
        o && (s.verified.origin = o, s.verified.validation = o === i.url ? "VALID" : "INVALID");
      } catch (o) {
        this.client.logger.error(o);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(s)}`), s;
    }, this.validateSessionProps = (r, i) => {
      Object.values(r).forEach((s) => {
        if (!et(s, !1)) {
          const { message: o } = G("MISSING_OR_INVALID", `${i} must be in Record<string, string> format. Received: ${JSON.stringify(s)}`);
          throw new Error(o);
        }
      });
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = G("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(Ue.message, async (e) => {
      const { topic: r, message: i } = e;
      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(i)))
        return;
      const s = await this.client.core.crypto.decode(r, i);
      Bs(s) ? (this.client.core.history.set(r, s), this.onRelayEventRequest({ topic: r, payload: s })) : Ti(s) ? (await this.client.core.history.resolve(s), await this.onRelayEventResponse({ topic: r, payload: s }), this.client.core.history.delete(r, s.id)) : this.onRelayEventUnknownPayload({ topic: r, payload: s });
    });
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(St.expired, async (e) => {
      const { topic: r, id: i } = Ia(e.target);
      if (i && this.client.pendingRequest.keys.includes(i))
        return await this.deletePendingSessionRequest(i, G("EXPIRED"), !0);
      r ? this.client.session.keys.includes(r) && (await this.deleteSession(r, !0), this.client.events.emit("session_expire", { topic: r })) : i && (await this.deleteProposal(i, !0), this.client.events.emit("proposal_expire", { id: i }));
    });
  }
  isValidPairingTopic(e) {
    if (!et(e, !1)) {
      const { message: r } = G("MISSING_OR_INVALID", `pairing topic should be a string: ${e}`);
      throw new Error(r);
    }
    if (!this.client.core.pairing.pairings.keys.includes(e)) {
      const { message: r } = G("NO_MATCHING_KEY", `pairing topic doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (Gt(this.client.core.pairing.pairings.get(e).expiry)) {
      const { message: r } = G("EXPIRED", `pairing topic: ${e}`);
      throw new Error(r);
    }
  }
  async isValidSessionTopic(e) {
    if (!et(e, !1)) {
      const { message: r } = G("MISSING_OR_INVALID", `session topic should be a string: ${e}`);
      throw new Error(r);
    }
    if (!this.client.session.keys.includes(e)) {
      const { message: r } = G("NO_MATCHING_KEY", `session topic doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (Gt(this.client.session.get(e).expiry)) {
      await this.deleteSession(e);
      const { message: r } = G("EXPIRED", `session topic: ${e}`);
      throw new Error(r);
    }
  }
  async isValidSessionOrPairingTopic(e) {
    if (this.client.session.keys.includes(e))
      await this.isValidSessionTopic(e);
    else if (this.client.core.pairing.pairings.keys.includes(e))
      this.isValidPairingTopic(e);
    else if (et(e, !1)) {
      const { message: r } = G("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${e}`);
      throw new Error(r);
    } else {
      const { message: r } = G("MISSING_OR_INVALID", `session or pairing topic should be a string: ${e}`);
      throw new Error(r);
    }
  }
  async isValidProposalId(e) {
    if (!Bd(e)) {
      const { message: r } = G("MISSING_OR_INVALID", `proposal id should be a number: ${e}`);
      throw new Error(r);
    }
    if (!this.client.proposal.keys.includes(e)) {
      const { message: r } = G("NO_MATCHING_KEY", `proposal id doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (Gt(this.client.proposal.get(e).expiry)) {
      await this.deleteProposal(e);
      const { message: r } = G("EXPIRED", `proposal id: ${e}`);
      throw new Error(r);
    }
  }
}
class oy extends Ri {
  constructor(e, r) {
    super(e, r, G0, Ks), this.core = e, this.logger = r;
  }
}
class ay extends Ri {
  constructor(e, r) {
    super(e, r, J0, Ks), this.core = e, this.logger = r;
  }
}
class cy extends Ri {
  constructor(e, r) {
    super(e, r, Q0, Ks, (i) => i.id), this.core = e, this.logger = r;
  }
}
let uy = class Ja extends uh {
  constructor(e) {
    super(e), this.protocol = ka, this.version = Ga, this.name = Ji.name, this.events = new zt(), this.on = (i, s) => this.events.on(i, s), this.once = (i, s) => this.events.once(i, s), this.off = (i, s) => this.events.off(i, s), this.removeListener = (i, s) => this.events.removeListener(i, s), this.removeAllListeners = (i) => this.events.removeAllListeners(i), this.connect = async (i) => {
      try {
        return await this.engine.connect(i);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.pair = async (i) => {
      try {
        return await this.engine.pair(i);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.approve = async (i) => {
      try {
        return await this.engine.approve(i);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.reject = async (i) => {
      try {
        return await this.engine.reject(i);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.update = async (i) => {
      try {
        return await this.engine.update(i);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.extend = async (i) => {
      try {
        return await this.engine.extend(i);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.request = async (i) => {
      try {
        return await this.engine.request(i);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.respond = async (i) => {
      try {
        return await this.engine.respond(i);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.ping = async (i) => {
      try {
        return await this.engine.ping(i);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.emit = async (i) => {
      try {
        return await this.engine.emit(i);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.disconnect = async (i) => {
      try {
        return await this.engine.disconnect(i);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.find = (i) => {
      try {
        return this.engine.find(i);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.name = (e == null ? void 0 : e.name) || Ji.name, this.metadata = (e == null ? void 0 : e.metadata) || id();
    const r = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : _e.pino(_e.getDefaultLoggerOptions({ level: (e == null ? void 0 : e.logger) || Ji.logger }));
    this.core = (e == null ? void 0 : e.core) || new W0(e), this.logger = _e.generateChildLogger(r, this.name), this.session = new ay(this.core, this.logger), this.proposal = new oy(this.core, this.logger), this.pendingRequest = new cy(this.core, this.logger), this.engine = new ny(this);
  }
  static async init(e) {
    const r = new Ja(e);
    return await r.initialize(), r;
  }
  get context() {
    return _e.getLoggerContext(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info("SignClient Initialization Success");
    } catch (e) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(e.message), e;
    }
  }
};
var hy = Object.defineProperty, ly = Object.defineProperties, fy = Object.getOwnPropertyDescriptors, Lo = Object.getOwnPropertySymbols, dy = Object.prototype.hasOwnProperty, py = Object.prototype.propertyIsEnumerable, Fo = (t, e, r) => e in t ? hy(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, gy = (t, e) => {
  for (var r in e || (e = {}))
    dy.call(e, r) && Fo(t, r, e[r]);
  if (Lo)
    for (var r of Lo(e))
      py.call(e, r) && Fo(t, r, e[r]);
  return t;
}, yy = (t, e) => ly(t, fy(e)), Vs = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
}, Ae = (t, e, r) => (Vs(t, e, "read from private field"), r ? r.call(t) : e.get(t)), ur = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, vi = (t, e, r, i) => (Vs(t, e, "write to private field"), i ? i.call(t, r) : e.set(t, r), r), at = (t, e, r) => (Vs(t, e, "access private method"), r), hr, vr, Vr, Qe, _s, Xa, ct, lt, ms, Mo;
class by {
  constructor(e) {
    ur(this, _s), ur(this, ct), ur(this, ms), ur(this, hr, void 0), ur(this, vr, void 0), ur(this, Vr, void 0), ur(this, Qe, void 0), vi(this, hr, e), vi(this, vr, at(this, _s, Xa).call(this)), at(this, ct, lt).call(this);
  }
  async connect(e) {
    const { requiredNamespaces: r, optionalNamespaces: i } = e;
    return new Promise(async (s, o) => {
      await at(this, ct, lt).call(this);
      const u = Ae(this, vr).subscribeModal((d) => {
        d.open || (u(), o(new Error("Modal closed")));
      }), { uri: c, approval: h } = await Ae(this, Qe).connect(e);
      if (c) {
        const d = /* @__PURE__ */ new Set();
        r && Object.values(r).forEach(({ chains: p }) => {
          p && p.forEach((E) => d.add(E));
        }), i && Object.values(i).forEach(({ chains: p }) => {
          p && p.forEach((E) => d.add(E));
        }), await Ae(this, vr).openModal({ uri: c, chains: Array.from(d) });
      }
      try {
        const d = await h();
        s(d);
      } catch (d) {
        o(d);
      } finally {
        u(), Ae(this, vr).closeModal();
      }
    });
  }
  async disconnect(e) {
    await at(this, ct, lt).call(this), await Ae(this, Qe).disconnect(e);
  }
  async request(e) {
    return await at(this, ct, lt).call(this), await Ae(this, Qe).request(e);
  }
  async getSessions() {
    return await at(this, ct, lt).call(this), Ae(this, Qe).session.getAll();
  }
  async getSession() {
    return await at(this, ct, lt).call(this), Ae(this, Qe).session.getAll().at(-1);
  }
  async onSessionEvent(e) {
    await at(this, ct, lt).call(this), Ae(this, Qe).on("session_event", e);
  }
  async offSessionEvent(e) {
    await at(this, ct, lt).call(this), Ae(this, Qe).off("session_event", e);
  }
  async onSessionUpdate(e) {
    await at(this, ct, lt).call(this), Ae(this, Qe).on("session_update", e);
  }
  async offSessionUpdate(e) {
    await at(this, ct, lt).call(this), Ae(this, Qe).off("session_update", e);
  }
  async onSessionDelete(e) {
    await at(this, ct, lt).call(this), Ae(this, Qe).on("session_delete", e);
  }
  async offSessionDelete(e) {
    await at(this, ct, lt).call(this), Ae(this, Qe).off("session_delete", e);
  }
  async onSessionExpire(e) {
    await at(this, ct, lt).call(this), Ae(this, Qe).on("session_expire", e);
  }
  async offSessionExpire(e) {
    await at(this, ct, lt).call(this), Ae(this, Qe).off("session_expire", e);
  }
}
hr = /* @__PURE__ */ new WeakMap(), vr = /* @__PURE__ */ new WeakMap(), Vr = /* @__PURE__ */ new WeakMap(), Qe = /* @__PURE__ */ new WeakMap(), _s = /* @__PURE__ */ new WeakSet(), Xa = function() {
  const { modalOptions: t, projectId: e } = Ae(this, hr);
  return new cu(yy(gy({}, t), { projectId: e }));
}, ct = /* @__PURE__ */ new WeakSet(), lt = async function() {
  return Ae(this, Qe) ? !0 : (!Ae(this, Vr) && typeof window < "u" && vi(this, Vr, at(this, ms, Mo).call(this)), Ae(this, Vr));
}, ms = /* @__PURE__ */ new WeakSet(), Mo = async function() {
  vi(this, Qe, await uy.init({ metadata: Ae(this, hr).metadata, projectId: Ae(this, hr).projectId, relayUrl: Ae(this, hr).relayUrl }));
  const t = await Ae(this, Qe).core.crypto.getClientId();
  try {
    localStorage.setItem("WCM_WALLETCONNECT_CLIENT_ID", t);
  } catch {
    console.info("Unable to set client id");
  }
};
const Uy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  WalletConnectModalSign: by
}, Symbol.toStringTag, { value: "Module" }));
export {
  Gc as R,
  jo as T,
  ut as a,
  Uy as i,
  ln as n,
  Ey as o,
  Tt as p,
  Li as s,
  vy as t,
  Dr as y
};
