var o = /* @__PURE__ */ ((t) => (t.INVALID_INPUT_PARAMETERS = "1000", t.UNKNOWN_PROVIDERS = "1001", t.CANNOT_FIND_INBOUND_ADDRESS = "1002", t.NO_INBOUND_ADDRESSES = "1003", t.CHAIN_HALTED_OR_UNSUPPORTED = "1004", t.MISSING_INPUT_PARAMETER = "1005", t.INVALID_TYPE_GENERIC = "1100", t.INVALID_NUMBER_STRING = "1101", t.INVALID_NUMBER = "1102", t.INVALID_BOOLEAN = "1103", t.INVALID_OBJECT = "1104", t.INVALID_ARRAY = "1105", t.SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2000", t.SELL_BUY_ASSETS_ARE_THE_SAME = "2001", t.MISSING_SOURCE_ADDRESS_FOR_SYNTH = "2002", t.AFF_ADDRESS_AND_BPS_OR_NEITHER = "2003", t.AFF_ADDRESS_TOO_LONG = "2004", t.AFF_BPS_INTEGER_0_100 = "2005", t.SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN = "2006", t.DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN = "2007", t.PREFERRED_PROFVIDER_NOT_SUPPORTED = "2008", t.DESTINATION_ADDRESS_SMART_CONTRACT = "2009", t.BUY_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2010", t.SOURCE_ADDRESS_SMART_CONTRACT = "2011", t.INVALID_PROVIDER = "2100", t.MISSING_CROSS_CHAIN_PROVIDER = "2101", t.MISSING_AVAX_PROVIDER = "2102", t.MISSING_BSC_PROVIDER = "2103", t.MISSING_ETH_PROVIDER = "2104", t.INVALID_PROVIDER_FOR_SWAP_OUT = "2105", t.MISSING_ARB_PROVIDER = "2106", t.INVALID_CHAIN = "2200", t.INVALID_ASSET = "2201", t.INVALID_ASSET_IDENTIFIER = "2202", t.UNSUPPORTED_CHAIN = "2204", t.UNSUPPORTED_ASSET = "2203", t.UNSUPPORTED_ASSET_FOR_SWAPOUT = "2205", t.INVALID_SOURCE_ADDRESS = "2300", t.INVALID_DESTINATION_ADDRESS = "2301", t.THORNODE_QUOTE_GENERIC_ERROR = "3000", t.NOT_ENOUGH_SYNTH_BALANCE = "3001", t.SYNTH_MINTING_CAP_REACHED = "3002", t.INVALID_QUOTE_MODE = "4000", t.NO_QUOTES = "4001", t.SERVICE_UNAVAILABLE_GENERIC = "5000", t.MISSING_GAS_DATA_GENERIC = "5100", t.MISSING_TOKEN_INFO_GENERIC = "5200", t.CANT_FIND_TOKEN_LIST = "5201", t.NO_PRICE = "5202", t.PRICE_IS_STALE = "5203", t.ADDRESS_NOT_WHITELISTED = "6000", t.ADDRESS_ALREADY_CLAIMED = "6001", t.TEMPORARY_ERROR = "9999", t))(o || {});
o.INVALID_INPUT_PARAMETERS + "", o.UNKNOWN_PROVIDERS + "", o.CANNOT_FIND_INBOUND_ADDRESS + "", o.NO_INBOUND_ADDRESSES + "", o.CHAIN_HALTED_OR_UNSUPPORTED + "", o.MISSING_INPUT_PARAMETER + "", o.INVALID_TYPE_GENERIC + "", o.INVALID_NUMBER_STRING + "", o.INVALID_NUMBER + "", o.INVALID_BOOLEAN + "", o.INVALID_OBJECT + "", o.INVALID_ARRAY + "", o.SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER + "", o.SELL_BUY_ASSETS_ARE_THE_SAME + "", o.MISSING_SOURCE_ADDRESS_FOR_SYNTH + "", o.AFF_ADDRESS_AND_BPS_OR_NEITHER + "", o.AFF_ADDRESS_TOO_LONG + "", o.AFF_BPS_INTEGER_0_100 + "", o.SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN + "", o.DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN + "", o.PREFERRED_PROFVIDER_NOT_SUPPORTED + "", o.DESTINATION_ADDRESS_SMART_CONTRACT + "", o.BUY_AMOUNT_MUST_BE_POSITIVE_INTEGER + "", o.INVALID_PROVIDER + "", o.MISSING_CROSS_CHAIN_PROVIDER + "", o.MISSING_AVAX_PROVIDER + "", o.MISSING_BSC_PROVIDER + "", o.MISSING_ETH_PROVIDER + "", o.MISSING_ARB_PROVIDER + "", o.INVALID_PROVIDER_FOR_SWAP_OUT + "", o.INVALID_CHAIN + "", o.INVALID_ASSET + "", o.UNSUPPORTED_CHAIN + "", o.UNSUPPORTED_ASSET + "", o.UNSUPPORTED_ASSET_FOR_SWAPOUT + "", o.THORNODE_QUOTE_GENERIC_ERROR + "", o.INVALID_SOURCE_ADDRESS + "", o.INVALID_DESTINATION_ADDRESS + "", o.NOT_ENOUGH_SYNTH_BALANCE + "", o.SYNTH_MINTING_CAP_REACHED + "", o.INVALID_QUOTE_MODE + "", o.NO_QUOTES + "", o.SERVICE_UNAVAILABLE_GENERIC + "", o.MISSING_GAS_DATA_GENERIC + "", o.MISSING_TOKEN_INFO_GENERIC + "", o.CANT_FIND_TOKEN_LIST + "", o.NO_PRICE + "", o.PRICE_IS_STALE + "", o.ADDRESS_NOT_WHITELISTED + "", o.ADDRESS_ALREADY_CLAIMED + "";
var i = /* @__PURE__ */ ((t) => (t.Arbitrum = "ARB", t.Avalanche = "AVAX", t.Base = "BASE", t.Binance = "BNB", t.BinanceSmartChain = "BSC", t.Bitcoin = "BTC", t.BitcoinCash = "BCH", t.Cosmos = "GAIA", t.Dash = "DASH", t.Digibyte = "DGB", t.Dogecoin = "DOGE", t.EOS = "EOS", t.Ethereum = "ETH", t.Kujira = "KUJI", t.Litecoin = "LTC", t.Maya = "MAYA", t.Optimism = "OP", t.Osmosis = "OSMO", t.Polygon = "MATIC", t.Ripple = "XRP", t.THORChain = "THOR", t.Zcash = "ZEC", t))(i || {});
const H = {
  ARB: "eip155:42161",
  AVAX: "eip155:43114",
  BSC: "eip155:56",
  BNB: "binance:bnb-beacon-chain",
  BCH: "bip122:000000000000000000651ef99cb9fcbe",
  BTC: "bip122:000000000019d6689c085ae165831e93",
  BASE: "eip155:8453",
  GAIA: "cosmos:cosmoshub-4",
  DASH: "bip122:dash-hash",
  DGB: "bip122:digibytes-hash",
  DOGE: "bip122:00000000001a91e3dace36e2be3bf030",
  KUJI: "cosmos:kaiyo-1",
  EOS: "eos:cf057bbfb72640471fd910bcb67639c2",
  ETH: "eip155:1",
  LTC: "bip122:12a765e31ffd4059bada1e25190f6e98",
  MAYA: "cosmos:maya-mainnet-v1",
  OP: "eip155:10",
  OSMO: "cosmos:osmosis-1",
  MATIC: "eip155:137",
  XRP: "ripple:unknown",
  THOR: "cosmos:thorchain-mainnet-v1",
  ZEC: "bip122:0000000000196a45"
};
for (const t in i)
  H[i[t]], i[t];
const N = [
  "ETH",
  "AVAX",
  "BSC",
  "ARB",
  // Chain.Base,
  "OP",
  "MATIC"
  /* Polygon */
];
var f = /* @__PURE__ */ ((t) => (t.Arbitrum = "42161", t.ArbitrumHex = "0xa4b1", t.Avalanche = "43114", t.AvalancheHex = "0xa86a", t.Base = "8453", t.Binance = "Binance-Chain-Tigris", t.BinanceSmartChain = "56", t.BinanceSmartChainHex = "0x38", t.Bitcoin = "bitcoin", t.BitcoinCash = "bitcoincash", t.Cosmos = "cosmoshub-4", t.Dash = "dash", t.Dogecoin = "dogecoin", t.Kujira = "kaiyo-1", t.Ethereum = "1", t.EthereumHex = "0x1", t.Litecoin = "litecoin", t.Maya = "mayachain-mainnet-v1", t.MayaStagenet = "mayachain-stagenet-v1", t.Optimism = "10", t.OptimismHex = "0xa", t.Osmosis = "osmosis-1", t.Polygon = "137", t.PolygonHex = "0x89", t.THORChain = "thorchain-mainnet-v1", t.THORChainStagenet = "thorchain-stagenet-v2", t))(f || {}), y = /* @__PURE__ */ ((t) => (t.Arbitrum = "https://arb1.arbitrum.io/rpc", t.Avalanche = "https://node-router.thorswap.net/avalanche-c", t.Binance = "https://base.llamarpc.com", t.BinanceSmartChain = "https://bsc-dataseed.binance.org", t.Bitcoin = "https://node-router.thorswap.net/bitcoin", t.BitcoinCash = "https://node-router.thorswap.net/bitcoin-cash", t.Cosmos = "https://node-router.thorswap.net/cosmos/rpc", t.Kujira = "https://rpc-kujira.synergynodes.com/", t.Dash = "https://dash.nownodes.io", t.Dogecoin = "https://node-router.thorswap.net/dogecoin", t.Ethereum = "https://node-router.thorswap.net/ethereum", t.Litecoin = "https://node-router.thorswap.net/litecoin", t.Maya = "https://tendermint.mayachain.info", t.MayaStagenet = "https://stagenet.tendermint.mayachain.info", t.Optimism = "https://mainnet.optimism.io", t.Osmosis = "https://rpc-osmosis.keplr.app", t.Polygon = "https://polygon-rpc.com", t.THORChain = "https://rpc.thorswap.net", t.THORChainStagenet = "https://stagenet-rpc.ninerealms.com", t))(y || {}), c = /* @__PURE__ */ ((t) => (t.Cosmos = "https://node-router.thorswap.net/cosmos/rest", t.Kujira = "https://lcd-kujira.synergynodes.com/", t.MayanodeMainnet = "https://mayanode.mayachain.info", t.MayanodeStagenet = "https://stagenet.mayanode.mayachain.info", t.ThornodeMainnet = "https://thornode.thorswap.net", t.ThornodeStagenet = "https://stagenet-thornode.ninerealms.com", t.ThorswapApi = "https://api.thorswap.net", t.ThorswapStatic = "https://static.thorswap.net", t))(c || {});
const p = Object.values(i), v = Object.keys(i), m = p.reduce(
  (t, e) => {
    const r = v.find((s) => i[s] === e);
    return r && (t[e] = r), t;
  },
  {}
);
p.reduce(
  (t, e) => (t[e] = f[m[e]], t),
  {}
);
p.reduce(
  (t, e) => (t[e] = y[m[e]], t),
  {}
);
p.reduce(
  (t, e) => {
    const r = `${m[e]}Hex`;
    return t[e] = f[r], t;
  },
  {}
);
const T = [
  i.Arbitrum,
  i.Avalanche,
  i.Binance,
  i.BinanceSmartChain,
  i.Bitcoin,
  i.BitcoinCash,
  i.Cosmos,
  i.Dogecoin,
  i.Ethereum,
  i.Litecoin,
  i.Optimism,
  i.Polygon,
  i.THORChain
];
i.Cosmos, i.Bitcoin, i.BitcoinCash, i.Litecoin, i.Dogecoin, i.Ethereum, i.Arbitrum, i.Avalanche, i.BinanceSmartChain, i.Bitcoin, i.BitcoinCash, i.Cosmos, i.Dogecoin, i.Ethereum, i.Litecoin, i.Optimism, i.Polygon, i.THORChain, i.Ethereum, i.Binance, i.BinanceSmartChain, i.Avalanche, i.THORChain, i.Ethereum, i.Avalanche, i.BinanceSmartChain, i.Bitcoin, i.Cosmos;
class P extends Error {
  constructor(e, r, s) {
    const n = e.status || e.status === 0 ? e.status : "", a = e.statusText || "", _ = `${n} ${a}`.trim(), A = _ ? `status code ${_}` : "an unknown error";
    super(`Request failed with ${A}`), Object.defineProperty(this, "response", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "request", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "options", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "HTTPError", this.response = e, this.request = r, this.options = s;
  }
}
class L extends Error {
  constructor(e) {
    super("Request timed out"), Object.defineProperty(this, "request", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "TimeoutError", this.request = e;
  }
}
const l = (t) => t !== null && typeof t == "object", d = (...t) => {
  for (const e of t)
    if ((!l(e) || Array.isArray(e)) && e !== void 0)
      throw new TypeError("The `options` argument must be an object");
  return D({}, ...t);
}, B = (t = {}, e = {}) => {
  const r = new globalThis.Headers(t), s = e instanceof globalThis.Headers, n = new globalThis.Headers(e);
  for (const [a, _] of n.entries())
    s && _ === "undefined" || _ === void 0 ? r.delete(a) : r.set(a, _);
  return r;
}, D = (...t) => {
  let e = {}, r = {};
  for (const s of t)
    if (Array.isArray(s))
      Array.isArray(e) || (e = []), e = [...e, ...s];
    else if (l(s)) {
      for (let [n, a] of Object.entries(s))
        l(a) && n in e && (a = D(e[n], a)), e = { ...e, [n]: a };
      l(s.headers) && (r = B(r, s.headers), e.headers = r);
    }
  return e;
}, M = (() => {
  let t = !1, e = !1;
  const r = typeof globalThis.ReadableStream == "function", s = typeof globalThis.Request == "function";
  return r && s && (e = new globalThis.Request("https://empty.invalid", {
    body: new globalThis.ReadableStream(),
    method: "POST",
    // @ts-expect-error - Types are outdated.
    get duplex() {
      return t = !0, "half";
    }
  }).headers.has("Content-Type")), t && !e;
})(), G = typeof globalThis.AbortController == "function", W = typeof globalThis.ReadableStream == "function", F = typeof globalThis.FormData == "function", U = ["get", "post", "put", "patch", "head", "delete"], k = {
  json: "application/json",
  text: "text/*",
  formData: "multipart/form-data",
  arrayBuffer: "*/*",
  blob: "*/*"
}, C = 2147483647, w = Symbol("stop"), q = {
  json: !0,
  parseJson: !0,
  searchParams: !0,
  prefixUrl: !0,
  retry: !0,
  timeout: !0,
  hooks: !0,
  throwHttpErrors: !0,
  onDownloadProgress: !0,
  fetch: !0
}, x = {
  method: !0,
  headers: !0,
  body: !0,
  mode: !0,
  credentials: !0,
  cache: !0,
  redirect: !0,
  referrer: !0,
  referrerPolicy: !0,
  integrity: !0,
  keepalive: !0,
  signal: !0,
  window: !0,
  dispatcher: !0,
  duplex: !0
}, j = (t) => U.includes(t) ? t.toUpperCase() : t, X = ["get", "put", "head", "delete", "options", "trace"], Y = [408, 413, 429, 500, 502, 503, 504], V = [413, 429, 503], b = {
  limit: 2,
  methods: X,
  statusCodes: Y,
  afterStatusCodes: V,
  maxRetryAfter: Number.POSITIVE_INFINITY,
  backoffLimit: Number.POSITIVE_INFINITY,
  delay: (t) => 0.3 * 2 ** (t - 1) * 1e3
}, $ = (t = {}) => {
  if (typeof t == "number")
    return {
      ...b,
      limit: t
    };
  if (t.methods && !Array.isArray(t.methods))
    throw new Error("retry.methods must be an array");
  if (t.statusCodes && !Array.isArray(t.statusCodes))
    throw new Error("retry.statusCodes must be an array");
  return {
    ...b,
    ...t,
    afterStatusCodes: V
  };
};
async function K(t, e, r, s) {
  return new Promise((n, a) => {
    const _ = setTimeout(() => {
      r && r.abort(), a(new L(t));
    }, s.timeout);
    s.fetch(t, e).then(n).catch(a).then(() => {
      clearTimeout(_);
    });
  });
}
async function J(t, { signal: e }) {
  return new Promise((r, s) => {
    e && (e.throwIfAborted(), e.addEventListener("abort", n, { once: !0 }));
    function n() {
      clearTimeout(a), s(e.reason);
    }
    const a = setTimeout(() => {
      e == null || e.removeEventListener("abort", n), r();
    }, t);
  });
}
const Q = (t, e) => {
  const r = {};
  for (const s in e)
    !(s in x) && !(s in q) && !(s in t) && (r[s] = e[s]);
  return r;
};
class I {
  static create(e, r) {
    const s = new I(e, r), n = async () => {
      if (typeof s._options.timeout == "number" && s._options.timeout > C)
        throw new RangeError(`The \`timeout\` option cannot be greater than ${C}`);
      await Promise.resolve();
      let A = await s._fetch();
      for (const h of s._options.hooks.afterResponse) {
        const u = await h(s.request, s._options, s._decorateResponse(A.clone()));
        u instanceof globalThis.Response && (A = u);
      }
      if (s._decorateResponse(A), !A.ok && s._options.throwHttpErrors) {
        let h = new P(A, s.request, s._options);
        for (const u of s._options.hooks.beforeError)
          h = await u(h);
        throw h;
      }
      if (s._options.onDownloadProgress) {
        if (typeof s._options.onDownloadProgress != "function")
          throw new TypeError("The `onDownloadProgress` option must be a function");
        if (!W)
          throw new Error("Streams are not supported in your environment. `ReadableStream` is missing.");
        return s._stream(A.clone(), s._options.onDownloadProgress);
      }
      return A;
    }, _ = s._options.retry.methods.includes(s.request.method.toLowerCase()) ? s._retry(n) : n();
    for (const [A, h] of Object.entries(k))
      _[A] = async () => {
        s.request.headers.set("accept", s.request.headers.get("accept") || h);
        const R = (await _).clone();
        if (A === "json") {
          if (R.status === 204 || (await R.clone().arrayBuffer()).byteLength === 0)
            return "";
          if (r.parseJson)
            return r.parseJson(await R.text());
        }
        return R[A]();
      };
    return _;
  }
  // eslint-disable-next-line complexity
  constructor(e, r = {}) {
    if (Object.defineProperty(this, "request", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "abortController", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_retryCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_input", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_options", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._input = e, this._options = {
      // TODO: credentials can be removed when the spec change is implemented in all browsers. Context: https://www.chromestatus.com/feature/4539473312350208
      credentials: this._input.credentials || "same-origin",
      ...r,
      headers: B(this._input.headers, r.headers),
      hooks: D({
        beforeRequest: [],
        beforeRetry: [],
        beforeError: [],
        afterResponse: []
      }, r.hooks),
      method: j(r.method ?? this._input.method),
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      prefixUrl: String(r.prefixUrl || ""),
      retry: $(r.retry),
      throwHttpErrors: r.throwHttpErrors !== !1,
      timeout: r.timeout ?? 1e4,
      fetch: r.fetch ?? globalThis.fetch.bind(globalThis)
    }, typeof this._input != "string" && !(this._input instanceof URL || this._input instanceof globalThis.Request))
      throw new TypeError("`input` must be a string, URL, or Request");
    if (this._options.prefixUrl && typeof this._input == "string") {
      if (this._input.startsWith("/"))
        throw new Error("`input` must not begin with a slash when using `prefixUrl`");
      this._options.prefixUrl.endsWith("/") || (this._options.prefixUrl += "/"), this._input = this._options.prefixUrl + this._input;
    }
    if (G) {
      if (this.abortController = new globalThis.AbortController(), this._options.signal) {
        const s = this._options.signal;
        this._options.signal.addEventListener("abort", () => {
          this.abortController.abort(s.reason);
        });
      }
      this._options.signal = this.abortController.signal;
    }
    if (M && (this._options.duplex = "half"), this.request = new globalThis.Request(this._input, this._options), this._options.searchParams) {
      const n = "?" + (typeof this._options.searchParams == "string" ? this._options.searchParams.replace(/^\?/, "") : new URLSearchParams(this._options.searchParams).toString()), a = this.request.url.replace(/(?:\?.*?)?(?=#|$)/, n);
      (F && this._options.body instanceof globalThis.FormData || this._options.body instanceof URLSearchParams) && !(this._options.headers && this._options.headers["content-type"]) && this.request.headers.delete("content-type"), this.request = new globalThis.Request(new globalThis.Request(a, { ...this.request }), this._options);
    }
    this._options.json !== void 0 && (this._options.body = JSON.stringify(this._options.json), this.request.headers.set("content-type", this._options.headers.get("content-type") ?? "application/json"), this.request = new globalThis.Request(this.request, { body: this._options.body }));
  }
  _calculateRetryDelay(e) {
    if (this._retryCount++, this._retryCount < this._options.retry.limit && !(e instanceof L)) {
      if (e instanceof P) {
        if (!this._options.retry.statusCodes.includes(e.response.status))
          return 0;
        const s = e.response.headers.get("Retry-After");
        if (s && this._options.retry.afterStatusCodes.includes(e.response.status)) {
          let n = Number(s);
          return Number.isNaN(n) ? n = Date.parse(s) - Date.now() : n *= 1e3, this._options.retry.maxRetryAfter !== void 0 && n > this._options.retry.maxRetryAfter ? 0 : n;
        }
        if (e.response.status === 413)
          return 0;
      }
      const r = this._options.retry.delay(this._retryCount);
      return Math.min(this._options.retry.backoffLimit, r);
    }
    return 0;
  }
  _decorateResponse(e) {
    return this._options.parseJson && (e.json = async () => this._options.parseJson(await e.text())), e;
  }
  async _retry(e) {
    try {
      return await e();
    } catch (r) {
      const s = Math.min(this._calculateRetryDelay(r), C);
      if (s !== 0 && this._retryCount > 0) {
        await J(s, { signal: this._options.signal });
        for (const n of this._options.hooks.beforeRetry)
          if (await n({
            request: this.request,
            options: this._options,
            error: r,
            retryCount: this._retryCount
          }) === w)
            return;
        return this._retry(e);
      }
      throw r;
    }
  }
  async _fetch() {
    for (const r of this._options.hooks.beforeRequest) {
      const s = await r(this.request, this._options);
      if (s instanceof Request) {
        this.request = s;
        break;
      }
      if (s instanceof Response)
        return s;
    }
    const e = Q(this.request, this._options);
    return this._options.timeout === !1 ? this._options.fetch(this.request.clone(), e) : K(this.request.clone(), e, this.abortController, this._options);
  }
  /* istanbul ignore next */
  _stream(e, r) {
    const s = Number(e.headers.get("content-length")) || 0;
    let n = 0;
    return e.status === 204 ? (r && r({ percent: 1, totalBytes: s, transferredBytes: n }, new Uint8Array()), new globalThis.Response(null, {
      status: e.status,
      statusText: e.statusText,
      headers: e.headers
    })) : new globalThis.Response(new globalThis.ReadableStream({
      async start(a) {
        const _ = e.body.getReader();
        r && r({ percent: 0, transferredBytes: 0, totalBytes: s }, new Uint8Array());
        async function A() {
          const { done: h, value: u } = await _.read();
          if (h) {
            a.close();
            return;
          }
          if (r) {
            n += u.byteLength;
            const R = s === 0 ? 0 : n / s;
            r({ percent: R, transferredBytes: n, totalBytes: s }, u);
          }
          a.enqueue(u), await A();
        }
        await A();
      }
    }), {
      status: e.status,
      statusText: e.statusText,
      headers: e.headers
    });
  }
}
/*! MIT License © Sindre Sorhus */
const O = (t) => {
  const e = (r, s) => I.create(r, d(t, s));
  for (const r of U)
    e[r] = (s, n) => I.create(s, d(t, n, { method: r }));
  return e.create = (r) => O(d(r)), e.extend = (r) => O(d(t, r)), e.stop = w, e;
}, z = O(), Z = z, E = {
  CachedPrices: `${c.ThorswapApi}/tokenlist/cached-price`,
  GasRates: `${c.ThorswapApi}/resource-worker/gasPrice/getAll`,
  Quote: `${c.ThorswapApi}/aggregator/tokens/quote`,
  Txn: `${c.ThorswapApi}/apiusage/v2/txn`,
  TokenlistProviders: `${c.ThorswapApi}/tokenlist/providers`,
  TokenList: `${c.ThorswapStatic}/token-list`,
  Thorname: `${c.ThorswapApi}/thorname`
}, tt = typeof window < "u" ? {} : { referrer: "https://sk.thorswap.net", referer: "https://sk.thorswap.net" }, g = Z.create({ headers: tt }), S = {
  get: (t, e) => g.get(t, e).json(),
  post: (t, e) => g.post(t, e).json()
}, et = ({ tokens: t, ...e }) => {
  const r = new URLSearchParams();
  return t.filter((s, n, a) => a.findIndex((_) => _ === s) === n).forEach((s) => r.append("tokens", JSON.stringify(s))), e.metadata && r.append("metadata", "true"), e.lookup && r.append("lookup", "true"), e.sparkline && r.append("sparkline", "true"), S.post(E.CachedPrices, {
    body: r.toString(),
    headers: { "Content-Type": "application/x-www-form-urlencoded" }
  });
}, at = {
  getCachedPrices: et,
  getQuote: (t) => S.get(E.Quote, { searchParams: t }),
  getGasRates: () => S.get(E.GasRates),
  getTxnDetails: (t) => S.get(E.Txn, { searchParams: t }),
  getTokenlistProviders: () => S.get(E.TokenlistProviders),
  getTokenList: (t) => S.get(`${E.TokenList}/${t}.json`),
  getThornameAddresses: (t) => S.get(`${E.Thorname}/${t}`),
  getThornameRegisteredChains: (t) => S.get(`${E.Thorname}/chains/${t}`),
  getThornameRlookup: (t, e) => S.get(`${E.Thorname}/rlookup`, { searchParams: { address: t, chain: e } })
};
var st = /* @__PURE__ */ ((t) => (t.SWAP_TC_TO_TC = "SWAP:TC-TC", t.SWAP_ETH_TO_TC = "SWAP:ERC20-TC", t.SWAP_TC_TO_ETH = "SWAP:TC-ERC20", t.SWAP_ETH_TO_ETH = "SWAP:ERC20-ERC20", t.SWAP_AVAX_TO_TC = "SWAP:AVAX-TC", t.SWAP_TC_TO_AVAX = "SWAP:TC-AVAX", t.SWAP_AVAX_TO_AVAX = "SWAP:AVAX-AVAX", t.SWAP_ETH_TO_AVAX = "SWAP:ETH-AVAX", t.SWAP_AVAX_TO_ETH = "SWAP:AVAX-ETH", t.SWAP_TC_TO_GAIA = "SWAP:TC-GAIA", t.SWAP_GAIA_TO_TC = "SWAP:GAIA-TC", t.SWAP_TC_TO_BNB = "SWAP:TC-BNB", t.SWAP_BNB_TO_TC = "SWAP:BNB-TC", t.SWAP_TC_TO_BTC = "SWAP:TC-BTC", t.SWAP_BTC_TO_TC = "SWAP:BTC-TC", t.SWAP_TC_TO_BCH = "SWAP:TC-BCH", t.SWAP_BCH_TO_TC = "SWAP:BCH-TC", t.SWAP_TC_TO_LTC = "SWAP:TC-LTC", t.SWAP_LTC_TO_TC = "SWAP:LTC-TC", t.SWAP_TC_TO_DOGE = "SWAP:TC-DOGE", t.SWAP_DOGE_TO_TC = "SWAP:DOGE-TC", t.TC_STATUS = "TC:STATUS", t.TC_TRANSFER = "TC:TRANSFER", t.TC_DEPOSIT = "TC:DEPOSIT", t.TC_SEND = "TC:SEND", t.TC_SWITCH = "TC:SWITCH", t.TC_LP_ADD = "TC:ADDLIQUIDITY", t.TC_LP_WITHDRAW = "TC:WITHDRAW", t.TC_TNS_CREATE = "TC:TNS-CREATE", t.TC_TNS_EXTEND = "TC:TNS-EXTEND", t.TC_TNS_UPDATE = "TC:TNS-UPDATE", t.TC_SAVINGS_ADD = "TC:ADDSAVINGS", t.TC_SAVINGS_WITHDRAW = "TC:WITHDRAWSAVINGS", t.TC_LENDING_OPEN = "TC:LENDINGOPEN", t.TC_LENDING_CLOSE = "TC:LENDINGCLOSE", t.ETH_APPROVAL = "ETH:APPROVAL", t.ETH_STATUS = "ETH:STATUS", t.ETH_TRANSFER_TO_TC = "ETH:TRANSFER:IN", t.ETH_TRANSFER_FROM_TC = "ETH:TRANSFER:OUT", t.AVAX_APPROVAL = "AVAX:APPROVAL", t.AVAX_STATUS = "AVAX:STATUS", t.AVAX_TRANSFER_TO_TC = "AVAX:TRANSFER:IN", t.AVAX_TRANSFER_FROM_TC = "AVAX:TRANSFER:OUT", t.BSC_APPROVAL = "BSC:APPROVAL", t.BSC_STATUS = "BSC:STATUS", t.BSC_TRANSFER_TO_TC = "BSC:TRANSFER:IN", t.BSC_TRANSFER_FROM_TC = "BSC:TRANSFER:OUT", t.APPROVAL = "APPROVAL", t.STATUS = "STATUS", t.TRANSFER_TO_TC = "TRANSFER:IN", t.TRANSFER_FROM_TC = "TRANSFER:OUT", t.UNSUPPORTED = "UNSUPPORTED", t.TC_LENDING = "TC:LENDING", t))(st || {}), rt = /* @__PURE__ */ ((t) => (t.PENDING = "pending", t.SUCCESS = "success", t.CANCELLED = "cancelled", t.REFUNDED = "refunded", t.REPLACED = "replaced", t.ERROR = "error", t.UNKNOWN = "unknown", t.NOT_STARTED = "not_started", t.NOT_FOUND = "not_found", t.RETRIES_EXCEEDED = "retries_exceeded", t.STREAMING = "streaming", t))(rt || {}), ot = /* @__PURE__ */ ((t) => (t[t.NOT_STARTED = 0] = "NOT_STARTED", t[t.SUCCESS = 1] = "SUCCESS", t[t.REFUNDED = 2] = "REFUNDED", t))(ot || {});
export {
  ot as StreamingSwapProgressStatus,
  at as SwapKitApi,
  st as TransactionType,
  rt as TxStatus
};
