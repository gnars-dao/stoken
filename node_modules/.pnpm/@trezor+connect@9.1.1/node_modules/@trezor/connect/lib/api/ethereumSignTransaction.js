"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const AbstractMethod_1 = require("../core/AbstractMethod");
const paramsValidator_1 = require("./common/paramsValidator");
const pathUtils_1 = require("../utils/pathUtils");
const coinInfo_1 = require("../data/coinInfo");
const ethereumUtils_1 = require("../utils/ethereumUtils");
const formatUtils_1 = require("../utils/formatUtils");
const helper = tslib_1.__importStar(require("./ethereum/ethereumSignTx"));
const ethereumDefinitions_1 = require("./ethereum/ethereumDefinitions");
const strip = value => {
    if (typeof value === 'string') {
        let stripped = (0, formatUtils_1.stripHexPrefix)(value);
        if (stripped.length % 2 !== 0) {
            stripped = `0${stripped}`;
        }
        return stripped;
    }
    if (Array.isArray(value)) {
        return value.map(strip);
    }
    if (typeof value === 'object') {
        return Object.entries(value).reduce((acc, [k, v]) => ({ ...acc, [k]: strip(v) }), {});
    }
    return value;
};
class EthereumSignTransaction extends AbstractMethod_1.AbstractMethod {
    init() {
        this.requiredPermissions = ['read', 'write'];
        const { payload } = this;
        (0, paramsValidator_1.validateParams)(payload, [
            { name: 'path', required: true },
            { name: 'transaction', required: true },
        ]);
        const path = (0, pathUtils_1.validatePath)(payload.path, 3);
        const network = (0, coinInfo_1.getEthereumNetwork)(path);
        this.info = (0, ethereumUtils_1.getNetworkLabel)('Sign #NETWORK transaction', network);
        const tx = payload.transaction;
        const isEIP1559 = tx.maxFeePerGas && tx.maxPriorityFeePerGas;
        this.firmwareRange = (0, paramsValidator_1.getFirmwareRange)(isEIP1559 ? 'eip1559' : this.name, network, this.firmwareRange);
        const schema = isEIP1559
            ? [
                { name: 'to', type: 'string', required: true },
                { name: 'value', type: 'string', required: true },
                { name: 'gasLimit', type: 'string', required: true },
                { name: 'maxFeePerGas', type: 'string', required: true },
                { name: 'maxPriorityFeePerGas', type: 'string', required: true },
                { name: 'nonce', type: 'string', required: true },
                { name: 'data', type: 'string' },
                { name: 'chainId', type: 'number', required: true },
            ]
            : [
                { name: 'to', type: 'string', required: true },
                { name: 'value', type: 'string', required: true },
                { name: 'gasLimit', type: 'string', required: true },
                { name: 'gasPrice', type: 'string', required: true },
                { name: 'nonce', type: 'string', required: true },
                { name: 'data', type: 'string' },
                { name: 'chainId', type: 'number' },
                { name: 'txType', type: 'number' },
            ];
        (0, paramsValidator_1.validateParams)(tx, schema);
        if (typeof tx.chainId !== 'number') {
            console.warn('TrezorConnect.ethereumSignTransaction: Missing chainId parameter!');
        }
        this.params = {
            path,
            tx: {
                type: isEIP1559 ? 'eip1559' : 'legacy',
                ...strip(tx),
            },
        };
    }
    async run() {
        const { tx } = this.params;
        const slip44 = (0, pathUtils_1.getSlip44ByPath)(this.params.path);
        const definitions = await (0, ethereumDefinitions_1.getEthereumDefinitions)({
            chainId: tx.chainId,
            slip44,
            contractAddress: tx.data ? tx.to : undefined,
        });
        return tx.type === 'eip1559'
            ? helper.ethereumSignTxEIP1559(this.device.getCommands().typedCall.bind(this.device.getCommands()), this.params.path, tx.to, tx.value, tx.gasLimit, tx.maxFeePerGas, tx.maxPriorityFeePerGas, tx.nonce, tx.chainId, tx.data, tx.accessList, definitions)
            : helper.ethereumSignTx(this.device.getCommands().typedCall.bind(this.device.getCommands()), this.params.path, tx.to, tx.value, tx.gasLimit, tx.gasPrice, tx.nonce, tx.chainId, tx.data, tx.txType, definitions);
    }
}
exports.default = EthereumSignTransaction;
//# sourceMappingURL=ethereumSignTransaction.js.map