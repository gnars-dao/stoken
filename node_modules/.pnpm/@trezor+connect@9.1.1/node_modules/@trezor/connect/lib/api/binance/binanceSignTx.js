"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signTx = exports.validate = void 0;
const constants_1 = require("../../constants");
const paramsValidator_1 = require("../common/paramsValidator");
const processTxRequest = async (typedCall, messages, index) => {
    const { type, ...params } = messages[index];
    const lastOp = index + 1 >= messages.length;
    if (lastOp) {
        const response = await typedCall(type, 'BinanceSignedTx', params);
        return response.message;
    }
    await typedCall(type, 'BinanceTxRequest', params);
    index++;
    return processTxRequest(typedCall, messages, index);
};
const validate = (tx) => {
    (0, paramsValidator_1.validateParams)(tx, [
        { name: 'chain_id', type: 'string', required: true },
        { name: 'account_number', type: 'number' },
        { name: 'memo', type: 'string' },
        { name: 'sequence', type: 'number' },
        { name: 'source', type: 'number' },
        { name: 'message', type: 'object' },
    ]);
    const preparedTx = {
        chain_id: tx.chain_id,
        account_number: tx.account_number || 0,
        memo: tx.memo,
        sequence: tx.sequence || 0,
        source: tx.source || 0,
        messages: [],
    };
    const { transfer, placeOrder, cancelOrder } = tx;
    if (transfer) {
        (0, paramsValidator_1.validateParams)(transfer, [
            { name: 'inputs', type: 'array', required: true },
            { name: 'outputs', type: 'array', required: true },
        ]);
        preparedTx.messages.push({
            ...transfer,
            type: 'BinanceTransferMsg',
        });
    }
    if (placeOrder) {
        (0, paramsValidator_1.validateParams)(placeOrder, [
            { name: 'id', type: 'string' },
            { name: 'ordertype', type: 'number' },
            { name: 'price', type: 'number' },
            { name: 'quantity', type: 'number' },
            { name: 'sender', type: 'string' },
            { name: 'side', type: 'number' },
        ]);
        preparedTx.messages.push({
            ...placeOrder,
            type: 'BinanceOrderMsg',
        });
    }
    if (cancelOrder) {
        (0, paramsValidator_1.validateParams)(cancelOrder, [
            { name: 'refid', type: 'string', required: true },
            { name: 'sender', type: 'string', required: true },
            { name: 'symbol', type: 'string', required: true },
        ]);
        preparedTx.messages.push({
            ...cancelOrder,
            type: 'BinanceCancelMsg',
        });
    }
    if (preparedTx.messages.length < 1) {
        throw constants_1.ERRORS.TypedError('Method_InvalidParameter', 'Transaction does not have any message');
    }
    return preparedTx;
};
exports.validate = validate;
const signTx = async (typedCall, address_n, tx) => {
    const { account_number, chain_id, memo, sequence, source, messages } = tx;
    const msg_count = messages.length;
    await typedCall('BinanceSignTx', 'BinanceTxRequest', {
        address_n,
        msg_count,
        account_number,
        chain_id,
        memo,
        sequence,
        source,
    });
    return processTxRequest(typedCall, messages, 0);
};
exports.signTx = signTx;
//# sourceMappingURL=binanceSignTx.js.map