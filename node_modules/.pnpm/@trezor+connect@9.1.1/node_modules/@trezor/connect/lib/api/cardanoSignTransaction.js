"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AbstractMethod_1 = require("../core/AbstractMethod");
const paramsValidator_1 = require("./common/paramsValidator");
const coinInfo_1 = require("../data/coinInfo");
const pathUtils_1 = require("../utils/pathUtils");
const cardanoAuxiliaryData_1 = require("./cardano/cardanoAuxiliaryData");
const cardanoCertificate_1 = require("./cardano/cardanoCertificate");
const cardanoInputs_1 = require("./cardano/cardanoInputs");
const cardanoOutputs_1 = require("./cardano/cardanoOutputs");
const constants_1 = require("../constants");
const cardanoWitnesses_1 = require("./cardano/cardanoWitnesses");
const cardanoTokenBundle_1 = require("./cardano/cardanoTokenBundle");
const CardanoSignTransactionFeatures = Object.freeze({
    TransactionStreaming: ['0', '2.4.2'],
    TokenMinting: ['0', '2.4.3'],
    Multisig: ['0', '2.4.3'],
    NetworkIdInTxBody: ['0', '2.4.4'],
    OutputDatumHash: ['0', '2.4.4'],
    ScriptDataHash: ['0', '2.4.4'],
    Plutus: ['0', '2.4.4'],
    KeyHashStakeCredential: ['0', '2.4.4'],
    Babbage: ['0', '2.5.2'],
    CIP36Registration: ['0', '2.5.3'],
    CIP36RegistrationExternalPaymentAddress: ['0', '2.5.4'],
});
class CardanoSignTransaction extends AbstractMethod_1.AbstractMethod {
    init() {
        this.requiredPermissions = ['read', 'write'];
        this.firmwareRange = (0, paramsValidator_1.getFirmwareRange)(this.name, (0, coinInfo_1.getMiscNetwork)('Cardano'), this.firmwareRange);
        this.info = 'Sign Cardano transaction';
        const { payload } = this;
        if (payload.metadata) {
            throw constants_1.ERRORS.TypedError('Method_InvalidParameter', 'Metadata field has been replaced by auxiliaryData.');
        }
        if (payload.auxiliaryData && payload.auxiliaryData.blob) {
            throw constants_1.ERRORS.TypedError('Method_InvalidParameter', 'Auxiliary data can now only be sent as a hash.');
        }
        if (payload.auxiliaryData && payload.auxiliaryData.catalystRegistrationParameters) {
            console.warn('Please use cVoteRegistrationParameters instead of catalystRegistrationParameters.');
            payload.auxiliaryData.cVoteRegistrationParameters =
                payload.auxiliaryData.catalystRegistrationParameters;
        }
        if (payload.auxiliaryData && payload.auxiliaryData.governanceRegistrationParameters) {
            console.warn('Please use cVoteRegistrationParameters instead of governanceRegistrationParameters.');
            payload.auxiliaryData.cVoteRegistrationParameters =
                payload.auxiliaryData.governanceRegistrationParameters;
        }
        (0, paramsValidator_1.validateParams)(payload, [
            { name: 'signingMode', type: 'number', required: true },
            { name: 'inputs', type: 'array', required: true },
            { name: 'outputs', type: 'array', required: true, allowEmpty: true },
            { name: 'fee', type: 'uint', required: true },
            { name: 'ttl', type: 'uint' },
            { name: 'certificates', type: 'array', allowEmpty: true },
            { name: 'withdrawals', type: 'array', allowEmpty: true },
            { name: 'mint', type: 'array', allowEmpty: true },
            { name: 'validityIntervalStart', type: 'uint' },
            { name: 'scriptDataHash', type: 'string' },
            { name: 'collateralInputs', type: 'array', allowEmpty: true },
            { name: 'requiredSigners', type: 'array', allowEmpty: true },
            { name: 'totalCollateral', type: 'uint' },
            { name: 'referenceInputs', type: 'array', allowEmpty: true },
            { name: 'protocolMagic', type: 'number', required: true },
            { name: 'networkId', type: 'number', required: true },
            { name: 'additionalWitnessRequests', type: 'array', allowEmpty: true },
            { name: 'derivationType', type: 'number' },
            { name: 'includeNetworkId', type: 'boolean' },
        ]);
        const inputsWithPath = payload.inputs.map(cardanoInputs_1.transformInput);
        const outputsWithData = payload.outputs.map(cardanoOutputs_1.transformOutput);
        let certificatesWithPoolOwnersAndRelays = [];
        if (payload.certificates) {
            certificatesWithPoolOwnersAndRelays = payload.certificates.map(cardanoCertificate_1.transformCertificate);
        }
        let withdrawals = [];
        if (payload.withdrawals) {
            withdrawals = payload.withdrawals.map(withdrawal => {
                (0, paramsValidator_1.validateParams)(withdrawal, [
                    { name: 'amount', type: 'uint', required: true },
                    { name: 'scriptHash', type: 'string' },
                    { name: 'keyHash', type: 'string' },
                ]);
                return {
                    path: withdrawal.path ? (0, pathUtils_1.validatePath)(withdrawal.path, 5) : undefined,
                    amount: withdrawal.amount,
                    script_hash: withdrawal.scriptHash,
                    key_hash: withdrawal.keyHash,
                };
            });
        }
        let mint = [];
        if (payload.mint) {
            mint = (0, cardanoTokenBundle_1.tokenBundleToProto)(payload.mint);
        }
        let auxiliaryData;
        if (payload.auxiliaryData) {
            auxiliaryData = (0, cardanoAuxiliaryData_1.transformAuxiliaryData)(payload.auxiliaryData);
        }
        let additionalWitnessRequests = [];
        if (payload.additionalWitnessRequests) {
            additionalWitnessRequests = payload.additionalWitnessRequests.map(witnessRequest => (0, pathUtils_1.validatePath)(witnessRequest, 3));
        }
        let collateralInputsWithPath = [];
        if (payload.collateralInputs) {
            collateralInputsWithPath = payload.collateralInputs.map(cardanoInputs_1.transformCollateralInput);
        }
        let requiredSigners = [];
        if (payload.requiredSigners) {
            requiredSigners = payload.requiredSigners.map(requiredSigner => {
                (0, paramsValidator_1.validateParams)(requiredSigner, [{ name: 'keyHash', type: 'string' }]);
                return {
                    key_path: requiredSigner.keyPath
                        ? (0, pathUtils_1.validatePath)(requiredSigner.keyPath, 3)
                        : undefined,
                    key_hash: requiredSigner.keyHash,
                };
            });
        }
        const collateralReturnWithData = payload.collateralReturn
            ? (0, cardanoOutputs_1.transformOutput)(payload.collateralReturn)
            : undefined;
        let referenceInputs = [];
        if (payload.referenceInputs) {
            referenceInputs = payload.referenceInputs.map(cardanoInputs_1.transformReferenceInput);
        }
        this.params = {
            signingMode: payload.signingMode,
            inputsWithPath,
            outputsWithData,
            fee: payload.fee,
            ttl: payload.ttl,
            certificatesWithPoolOwnersAndRelays,
            withdrawals,
            mint,
            auxiliaryData,
            validityIntervalStart: payload.validityIntervalStart,
            scriptDataHash: payload.scriptDataHash,
            collateralInputsWithPath,
            requiredSigners,
            collateralReturnWithData,
            totalCollateral: payload.totalCollateral,
            referenceInputs,
            protocolMagic: payload.protocolMagic,
            networkId: payload.networkId,
            witnessPaths: (0, cardanoWitnesses_1.gatherWitnessPaths)(inputsWithPath, certificatesWithPoolOwnersAndRelays, withdrawals, collateralInputsWithPath, requiredSigners, additionalWitnessRequests, payload.signingMode),
            additionalWitnessRequests,
            derivationType: typeof payload.derivationType !== 'undefined'
                ? payload.derivationType
                : constants_1.PROTO.CardanoDerivationType.ICARUS_TREZOR,
            includeNetworkId: payload.includeNetworkId,
        };
    }
    _isFeatureSupported(feature) {
        return this.device.atLeast(CardanoSignTransactionFeatures[feature]);
    }
    _ensureFeatureIsSupported(feature) {
        if (!this._isFeatureSupported(feature)) {
            throw constants_1.ERRORS.TypedError('Method_InvalidParameter', `Feature ${feature} not supported by device firmware`);
        }
    }
    _ensureFirmwareSupportsParams() {
        var _a;
        const { params } = this;
        this._ensureFeatureIsSupported('TransactionStreaming');
        params.certificatesWithPoolOwnersAndRelays.forEach(({ certificate }) => {
            if (certificate.key_hash) {
                this._ensureFeatureIsSupported('KeyHashStakeCredential');
            }
        });
        params.outputsWithData.forEach(({ output }) => {
            if (output.datum_hash) {
                this._ensureFeatureIsSupported('OutputDatumHash');
            }
        });
        params.withdrawals.forEach(withdrawal => {
            if (withdrawal.key_hash) {
                this._ensureFeatureIsSupported('KeyHashStakeCredential');
            }
        });
        if (params.mint.length > 0) {
            this._ensureFeatureIsSupported('TokenMinting');
        }
        if (params.additionalWitnessRequests.length > 0 ||
            params.signingMode === constants_1.PROTO.CardanoTxSigningMode.MULTISIG_TRANSACTION) {
            this._ensureFeatureIsSupported('Multisig');
        }
        if (params.includeNetworkId) {
            this._ensureFeatureIsSupported('NetworkIdInTxBody');
        }
        if (params.scriptDataHash) {
            this._ensureFeatureIsSupported('ScriptDataHash');
        }
        if (params.signingMode === constants_1.PROTO.CardanoTxSigningMode.PLUTUS_TRANSACTION) {
            this._ensureFeatureIsSupported('Plutus');
        }
        params.outputsWithData.forEach(({ output, inlineDatum, referenceScript }) => {
            if (output.format === constants_1.PROTO.CardanoTxOutputSerializationFormat.MAP_BABBAGE ||
                inlineDatum ||
                referenceScript) {
                this._ensureFeatureIsSupported('Babbage');
            }
        });
        if (params.collateralReturnWithData ||
            params.totalCollateral != null ||
            params.referenceInputs.length > 0) {
            this._ensureFeatureIsSupported('Babbage');
        }
        if (params.requiredSigners.length > 0 &&
            params.signingMode !== constants_1.PROTO.CardanoTxSigningMode.PLUTUS_TRANSACTION) {
            this._ensureFeatureIsSupported('Babbage');
        }
        if ((_a = params.auxiliaryData) === null || _a === void 0 ? void 0 : _a.cvote_registration_parameters) {
            const { format, delegations, voting_purpose, payment_address } = params.auxiliaryData.cvote_registration_parameters;
            if (format === constants_1.PROTO.CardanoCVoteRegistrationFormat.CIP36 ||
                (delegations === null || delegations === void 0 ? void 0 : delegations.length) ||
                voting_purpose != null) {
                this._ensureFeatureIsSupported('CIP36Registration');
            }
            if (payment_address) {
                this._ensureFeatureIsSupported('CIP36RegistrationExternalPaymentAddress');
            }
        }
    }
    async _sign_tx() {
        const typedCall = this.device.getCommands().typedCall.bind(this.device.getCommands());
        const hasAuxiliaryData = !!this.params.auxiliaryData;
        const signTxInitMessage = {
            signing_mode: this.params.signingMode,
            protocol_magic: this.params.protocolMagic,
            network_id: this.params.networkId,
            inputs_count: this.params.inputsWithPath.length,
            outputs_count: this.params.outputsWithData.length,
            fee: this.params.fee,
            ttl: this.params.ttl,
            certificates_count: this.params.certificatesWithPoolOwnersAndRelays.length,
            withdrawals_count: this.params.withdrawals.length,
            has_auxiliary_data: hasAuxiliaryData,
            validity_interval_start: this.params.validityIntervalStart,
            witness_requests_count: this.params.witnessPaths.length,
            minting_asset_groups_count: this.params.mint.length,
            script_data_hash: this.params.scriptDataHash,
            collateral_inputs_count: this.params.collateralInputsWithPath.length,
            required_signers_count: this.params.requiredSigners.length,
            has_collateral_return: this.params.collateralReturnWithData != null,
            total_collateral: this.params.totalCollateral,
            reference_inputs_count: this.params.referenceInputs.length,
            derivation_type: this.params.derivationType,
            include_network_id: this.params.includeNetworkId,
        };
        await typedCall('CardanoSignTxInit', 'CardanoTxItemAck', signTxInitMessage);
        for (const { input } of this.params.inputsWithPath) {
            await typedCall('CardanoTxInput', 'CardanoTxItemAck', input);
        }
        for (const outputWithData of this.params.outputsWithData) {
            await (0, cardanoOutputs_1.sendOutput)(typedCall, outputWithData);
        }
        for (const { certificate, poolOwners, poolRelays } of this.params
            .certificatesWithPoolOwnersAndRelays) {
            await typedCall('CardanoTxCertificate', 'CardanoTxItemAck', certificate);
            for (const poolOwner of poolOwners) {
                await typedCall('CardanoPoolOwner', 'CardanoTxItemAck', poolOwner);
            }
            for (const poolRelay of poolRelays) {
                await typedCall('CardanoPoolRelayParameters', 'CardanoTxItemAck', poolRelay);
            }
        }
        for (const withdrawal of this.params.withdrawals) {
            await typedCall('CardanoTxWithdrawal', 'CardanoTxItemAck', withdrawal);
        }
        let auxiliaryDataSupplement;
        if (this.params.auxiliaryData) {
            const { cvote_registration_parameters } = this.params.auxiliaryData;
            if (cvote_registration_parameters) {
                this.params.auxiliaryData = (0, cardanoAuxiliaryData_1.modifyAuxiliaryDataForBackwardsCompatibility)(this.device, this.params.auxiliaryData);
            }
            const { message } = await typedCall('CardanoTxAuxiliaryData', 'CardanoTxAuxiliaryDataSupplement', this.params.auxiliaryData);
            const auxiliaryDataType = constants_1.PROTO.CardanoTxAuxiliaryDataSupplementType[message.type];
            if (auxiliaryDataType !== constants_1.PROTO.CardanoTxAuxiliaryDataSupplementType.NONE) {
                auxiliaryDataSupplement = {
                    type: auxiliaryDataType,
                    auxiliaryDataHash: message.auxiliary_data_hash,
                    cVoteRegistrationSignature: message.cvote_registration_signature,
                    catalystSignature: message.cvote_registration_signature,
                    governanceSignature: message.cvote_registration_signature,
                };
            }
            await typedCall('CardanoTxHostAck', 'CardanoTxItemAck');
        }
        if (this.params.mint.length > 0) {
            await typedCall('CardanoTxMint', 'CardanoTxItemAck', {
                asset_groups_count: this.params.mint.length,
            });
            for (const assetGroup of this.params.mint) {
                await typedCall('CardanoAssetGroup', 'CardanoTxItemAck', {
                    policy_id: assetGroup.policyId,
                    tokens_count: assetGroup.tokens.length,
                });
                for (const token of assetGroup.tokens) {
                    await typedCall('CardanoToken', 'CardanoTxItemAck', token);
                }
            }
        }
        for (const { collateralInput } of this.params.collateralInputsWithPath) {
            await typedCall('CardanoTxCollateralInput', 'CardanoTxItemAck', collateralInput);
        }
        for (const requiredSigner of this.params.requiredSigners) {
            await typedCall('CardanoTxRequiredSigner', 'CardanoTxItemAck', requiredSigner);
        }
        if (this.params.collateralReturnWithData) {
            await (0, cardanoOutputs_1.sendOutput)(typedCall, this.params.collateralReturnWithData);
        }
        for (const referenceInput of this.params.referenceInputs) {
            await typedCall('CardanoTxReferenceInput', 'CardanoTxItemAck', referenceInput);
        }
        const witnesses = [];
        for (const path of this.params.witnessPaths) {
            const { message } = await typedCall('CardanoTxWitnessRequest', 'CardanoTxWitnessResponse', { path });
            witnesses.push({
                type: constants_1.PROTO.CardanoTxWitnessType[message.type],
                pubKey: message.pub_key,
                signature: message.signature,
                chainCode: message.chain_code,
            });
        }
        const { message: txBodyHashMessage } = await typedCall('CardanoTxHostAck', 'CardanoTxBodyHash');
        await typedCall('CardanoTxHostAck', 'CardanoSignTxFinished');
        return { hash: txBodyHashMessage.tx_hash, witnesses, auxiliaryDataSupplement };
    }
    run() {
        this._ensureFirmwareSupportsParams();
        return this._sign_tx();
    }
}
exports.default = CardanoSignTransaction;
//# sourceMappingURL=cardanoSignTransaction.js.map