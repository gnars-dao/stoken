"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addressParametersFromProto = exports.addressParametersToProto = exports.modifyAddressParametersForBackwardsCompatibility = exports.validateAddressParameters = void 0;
const paramsValidator_1 = require("../common/paramsValidator");
const pathUtils_1 = require("../../utils/pathUtils");
const constants_1 = require("../../constants");
const validateAddressParameters = (addressParameters) => {
    (0, paramsValidator_1.validateParams)(addressParameters, [
        { name: 'addressType', type: 'number', required: true },
        { name: 'stakingKeyHash', type: 'string' },
        { name: 'paymentScriptHash', type: 'string' },
        { name: 'stakingScriptHash', type: 'string' },
    ]);
    if (addressParameters.path) {
        (0, pathUtils_1.validatePath)(addressParameters.path);
    }
    if (addressParameters.stakingPath) {
        (0, pathUtils_1.validatePath)(addressParameters.stakingPath);
    }
    if (addressParameters.certificatePointer) {
        (0, paramsValidator_1.validateParams)(addressParameters.certificatePointer, [
            { name: 'blockIndex', type: 'number', required: true },
            { name: 'txIndex', type: 'number', required: true },
            { name: 'certificateIndex', type: 'number', required: true },
        ]);
    }
};
exports.validateAddressParameters = validateAddressParameters;
const modifyAddressParametersForBackwardsCompatibility = (device, address_parameters) => {
    if (address_parameters.address_type === constants_1.PROTO.CardanoAddressType.REWARD) {
        let { address_n, address_n_staking } = address_parameters;
        if (address_n.length > 0 && address_n_staking.length > 0) {
            throw constants_1.ERRORS.TypedError('Method_InvalidParameter', `Only stakingPath is allowed for CardanoAddressType.REWARD`);
        }
        if (device.atLeast(['0', '2.4.3'])) {
            if (address_n.length > 0) {
                address_n_staking = address_n;
                address_n = [];
            }
        }
        else if (address_n_staking.length > 0) {
            address_n = address_n_staking;
            address_n_staking = [];
        }
        return {
            ...address_parameters,
            address_n,
            address_n_staking,
        };
    }
    return address_parameters;
};
exports.modifyAddressParametersForBackwardsCompatibility = modifyAddressParametersForBackwardsCompatibility;
const addressParametersToProto = (addressParameters) => {
    let path = [];
    if (addressParameters.path) {
        path = (0, pathUtils_1.validatePath)(addressParameters.path, 3);
    }
    let stakingPath = [];
    if (addressParameters.stakingPath) {
        stakingPath = (0, pathUtils_1.validatePath)(addressParameters.stakingPath, 3);
    }
    let certificatePointer;
    if (addressParameters.certificatePointer) {
        certificatePointer = {
            block_index: addressParameters.certificatePointer.blockIndex,
            tx_index: addressParameters.certificatePointer.txIndex,
            certificate_index: addressParameters.certificatePointer.certificateIndex,
        };
    }
    return {
        address_type: addressParameters.addressType,
        address_n: path,
        address_n_staking: stakingPath,
        staking_key_hash: addressParameters.stakingKeyHash,
        certificate_pointer: certificatePointer,
        script_payment_hash: addressParameters.paymentScriptHash,
        script_staking_hash: addressParameters.stakingScriptHash,
    };
};
exports.addressParametersToProto = addressParametersToProto;
const addressParametersFromProto = (addressParameters) => {
    let certificatePointer;
    if (addressParameters.certificate_pointer) {
        certificatePointer = {
            blockIndex: addressParameters.certificate_pointer.block_index,
            txIndex: addressParameters.certificate_pointer.tx_index,
            certificateIndex: addressParameters.certificate_pointer.certificate_index,
        };
    }
    return {
        addressType: addressParameters.address_type,
        path: addressParameters.address_n,
        stakingPath: addressParameters.address_n_staking,
        stakingKeyHash: addressParameters.staking_key_hash,
        certificatePointer,
    };
};
exports.addressParametersFromProto = addressParametersFromProto;
//# sourceMappingURL=cardanoAddressParameters.js.map