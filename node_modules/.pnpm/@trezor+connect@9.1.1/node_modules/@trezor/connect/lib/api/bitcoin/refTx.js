"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateReferencedTransactions = exports.transformReferencedTransactions = exports.transformOrigTransactions = exports.getOrigTransactions = exports.getReferencedTransactions = exports.requireReferencedTransactions = void 0;
const utxo_lib_1 = require("@trezor/utxo-lib");
const utils_1 = require("@trezor/utils");
const pathUtils_1 = require("../../utils/pathUtils");
const paramsValidator_1 = require("../common/paramsValidator");
const errors_1 = require("../../constants/errors");
const requireReferencedTransactions = (inputs, options = {}, coinInfo) => {
    if ((coinInfo === null || coinInfo === void 0 ? void 0 : coinInfo.shortcut) === 'ZEC' || (coinInfo === null || coinInfo === void 0 ? void 0 : coinInfo.shortcut) === 'TAZ') {
        return !(options.version && options.version >= 5);
    }
    const inputTypes = ['SPENDTAPROOT', 'EXTERNAL'];
    return !!inputs.find(input => !inputTypes.find(t => t === input.script_type));
};
exports.requireReferencedTransactions = requireReferencedTransactions;
const getReferencedTransactions = (inputs) => {
    const result = [];
    inputs.forEach(input => {
        if (input.prev_hash && !result.includes(input.prev_hash)) {
            result.push(input.prev_hash);
        }
    });
    return result;
};
exports.getReferencedTransactions = getReferencedTransactions;
const getOrigTransactions = (inputs, outputs) => {
    const result = [];
    inputs.forEach(input => {
        if (input.orig_hash && !result.includes(input.orig_hash)) {
            result.push(input.orig_hash);
        }
    });
    outputs.forEach(output => {
        if (output.orig_hash && !result.includes(output.orig_hash)) {
            result.push(output.orig_hash);
        }
    });
    return result;
};
exports.getOrigTransactions = getOrigTransactions;
const enhanceTransaction = (refTx, srcTx) => {
    const extraData = srcTx.getExtraData();
    if (extraData) {
        refTx.extra_data = extraData.toString('hex');
    }
    const specific = srcTx.getSpecificData();
    if (specific) {
        if (specific.type === 'zcash' && specific.versionGroupId && refTx.version >= 3) {
            refTx.version_group_id = specific.versionGroupId;
        }
        if (specific.type === 'dash' && srcTx.type && srcTx.version >= 3) {
            refTx.version |= srcTx.type << 16;
        }
    }
    return refTx;
};
const transformOrigTransactions = (txs, coinInfo, addresses) => txs.flatMap(raw => {
    if (coinInfo.type !== 'bitcoin' || raw.type !== 'blockbook' || !addresses)
        return [];
    const { hex, vin, vout } = raw.tx;
    const tx = utxo_lib_1.Transaction.fromHex(hex, { network: coinInfo.network });
    const inputAddresses = addresses.used.concat(addresses.change).concat(addresses.unused);
    const inputsMap = (input, i) => {
        var _a;
        const rawInput = vin[i];
        if (!(rawInput === null || rawInput === void 0 ? void 0 : rawInput.value) || !(rawInput === null || rawInput === void 0 ? void 0 : rawInput.addresses) || rawInput.addresses.length !== 1) {
            throw (0, errors_1.TypedError)('Method_InvalidParameter', `transformOrigTransactions: invalid input at ${raw.tx.txid} [${i}]`);
        }
        const [address] = rawInput.addresses;
        const inputAddress = inputAddresses.find(addr => addr.address === address);
        const address_n = (0, pathUtils_1.getHDPath)((inputAddress === null || inputAddress === void 0 ? void 0 : inputAddress.path) || '');
        return {
            address_n,
            prev_hash: utils_1.bufferUtils.reverseBuffer(input.hash).toString('hex'),
            prev_index: input.index,
            script_sig: input.script.toString('hex'),
            sequence: input.sequence,
            script_type: (0, pathUtils_1.getScriptType)(address_n),
            multisig: undefined,
            amount: rawInput.value,
            decred_tree: undefined,
            witness: (_a = tx.getWitness(i)) === null || _a === void 0 ? void 0 : _a.toString('hex'),
            ownership_proof: undefined,
            commitment_data: undefined,
        };
    };
    const outputsMap = (output, i) => {
        var _a;
        const rawOutput = vout[i];
        if (!rawOutput.isAddress) {
            const { data } = utxo_lib_1.payments.embed({ output: output.script });
            const op_return_data = (_a = data === null || data === void 0 ? void 0 : data.shift()) === null || _a === void 0 ? void 0 : _a.toString('hex');
            if (typeof op_return_data !== 'string') {
                throw (0, errors_1.TypedError)('Method_InvalidParameter', `transformOrigTransactions: invalid op_return_data at ${raw.tx.txid} [${i}]`);
            }
            return {
                script_type: 'PAYTOOPRETURN',
                amount: '0',
                op_return_data,
            };
        }
        if (!rawOutput.addresses || rawOutput.addresses.length !== 1) {
            throw (0, errors_1.TypedError)('Method_InvalidParameter', `transformOrigTransactions: invalid output at ${raw.tx.txid} [${i}]`);
        }
        const [address] = rawOutput.addresses;
        const changeAddress = addresses.change.find(addr => addr.address === address);
        const address_n = changeAddress && (0, pathUtils_1.getHDPath)(changeAddress.path);
        const amount = output.value.toString();
        return address_n
            ? {
                address_n,
                amount,
                script_type: (0, pathUtils_1.getOutputScriptType)(address_n),
            }
            : {
                address,
                amount,
                script_type: 'PAYTOADDRESS',
            };
    };
    const refTx = {
        version: tx.version,
        hash: tx.getId(),
        inputs: tx.ins.map(inputsMap),
        outputs: tx.outs.map(outputsMap),
        lock_time: tx.locktime,
        timestamp: tx.timestamp,
        expiry: tx.expiry,
    };
    return enhanceTransaction(refTx, tx);
});
exports.transformOrigTransactions = transformOrigTransactions;
const transformReferencedTransactions = (txs, coinInfo) => txs.flatMap(raw => {
    if (coinInfo.type !== 'bitcoin' || raw.type !== 'blockbook')
        return [];
    const { hex } = raw.tx;
    const tx = utxo_lib_1.Transaction.fromHex(hex, { network: coinInfo.network });
    const inputsMap = (input) => ({
        prev_index: input.index,
        sequence: input.sequence,
        prev_hash: utils_1.bufferUtils.reverseBuffer(input.hash).toString('hex'),
        script_sig: input.script.toString('hex'),
    });
    const binOutputsMap = (output) => ({
        amount: output.value.toString(),
        script_pubkey: output.script.toString('hex'),
    });
    const refTx = {
        version: tx.version,
        hash: tx.getId(),
        inputs: tx.ins.map(inputsMap),
        bin_outputs: tx.outs.map(binOutputsMap),
        lock_time: tx.locktime,
        timestamp: tx.timestamp,
        expiry: tx.expiry,
    };
    return enhanceTransaction(refTx, tx);
});
exports.transformReferencedTransactions = transformReferencedTransactions;
const validateReferencedTransactions = (txs, inputs, outputs) => {
    if (!Array.isArray(txs) || txs.length === 0)
        return;
    const refTxs = (0, exports.requireReferencedTransactions)(inputs) ? (0, exports.getReferencedTransactions)(inputs) : [];
    const origTxs = (0, exports.getOrigTransactions)(inputs, outputs);
    const transformedTxs = txs.map(tx => {
        (0, paramsValidator_1.validateParams)(tx, [
            { name: 'hash', type: 'string', required: true },
            { name: 'inputs', type: 'array', required: true },
            { name: 'version', type: 'number', required: true },
            { name: 'lock_time', type: 'number', required: true },
            { name: 'extra_data', type: 'string' },
            { name: 'timestamp', type: 'number' },
            { name: 'version_group_id', type: 'number' },
        ]);
        if (origTxs.includes(tx.hash)) {
            (0, paramsValidator_1.validateParams)(tx, [{ name: 'outputs', type: 'array', required: true }]);
            return tx;
        }
        (0, paramsValidator_1.validateParams)(tx, [{ name: 'bin_outputs', type: 'array', required: true }]);
        tx.inputs.forEach(input => {
            (0, paramsValidator_1.validateParams)(input, [
                { name: 'prev_hash', type: 'string', required: true },
                { name: 'prev_index', type: 'number', required: true },
                { name: 'script_sig', type: 'string', required: true },
                { name: 'sequence', type: 'number', required: true },
                { name: 'decred_tree', type: 'number' },
            ]);
        });
        return {
            hash: tx.hash,
            version: tx.version,
            extra_data: tx.extra_data,
            lock_time: tx.lock_time,
            timestamp: tx.timestamp,
            version_group_id: tx.version_group_id,
            expiry: tx.expiry,
            inputs: tx.inputs.map(input => ({
                prev_hash: input.prev_hash,
                prev_index: input.prev_index,
                script_sig: input.script_sig,
                sequence: input.sequence,
                decred_tree: input.decred_tree,
            })),
            bin_outputs: tx.bin_outputs.map(output => ({
                amount: output.amount,
                script_pubkey: output.script_pubkey,
                decred_script_version: output.decred_script_version,
            })),
        };
    });
    refTxs.concat(origTxs).forEach(hash => {
        if (!transformedTxs.find(tx => tx.hash === hash)) {
            throw (0, errors_1.TypedError)('Method_InvalidParameter', `refTx: ${hash} not provided`);
        }
    });
    return transformedTxs;
};
exports.validateReferencedTransactions = validateReferencedTransactions;
//# sourceMappingURL=refTx.js.map