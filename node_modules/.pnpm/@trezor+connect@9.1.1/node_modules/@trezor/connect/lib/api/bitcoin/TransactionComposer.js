"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionComposer = void 0;
const tslib_1 = require("tslib");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const utxo_lib_1 = require("@trezor/utxo-lib");
const Fees_1 = require("./Fees");
const pathUtils_1 = require("../../utils/pathUtils");
class TransactionComposer {
    constructor(options) {
        this.blockHeight = 0;
        this.composed = {};
        this.account = options.account;
        this.outputs = options.outputs;
        this.coinInfo = options.coinInfo;
        this.blockHeight = 0;
        this.baseFee = options.baseFee || 0;
        this.skipPermutation = options.skipPermutation || false;
        this.feeLevels = new Fees_1.FeeLevels(options.coinInfo);
        const { addresses } = options.account;
        const allAddresses = !addresses
            ? []
            : addresses.used
                .concat(addresses.unused)
                .concat(addresses.change)
                .map(a => a.address);
        this.utxos = options.utxo.flatMap(u => {
            if (!u.required && new bignumber_js_1.default(u.amount).lte(this.coinInfo.dustLimit))
                return [];
            const addressPath = (0, pathUtils_1.getHDPath)(u.path);
            const [chain, index] = addressPath.slice(addressPath.length - 2);
            return {
                index: u.vout,
                transactionHash: u.txid,
                value: u.amount,
                addressPath: [chain, index],
                height: u.blockHeight,
                tsize: 0,
                vsize: 0,
                coinbase: typeof u.coinbase === 'boolean' ? u.coinbase : false,
                own: allAddresses.indexOf(u.address) >= 0,
                required: u.required,
            };
        });
    }
    async init(blockchain) {
        const { blockHeight } = await blockchain.getNetworkInfo();
        this.blockHeight = blockHeight;
        await this.feeLevels.load(blockchain);
    }
    composeAllFeeLevels() {
        const { levels } = this.feeLevels;
        if (this.utxos.length < 1)
            return false;
        this.composed = {};
        let atLeastOneValid = false;
        levels.forEach(level => {
            if (level.feePerUnit !== '0') {
                const tx = this.compose(level.feePerUnit);
                if (tx.type === 'final') {
                    atLeastOneValid = true;
                }
                this.composed[level.label] = tx;
            }
        });
        if (!atLeastOneValid) {
            const lastLevel = levels[levels.length - 1];
            let lastFee = new bignumber_js_1.default(lastLevel.feePerUnit);
            while (lastFee.gt(this.coinInfo.minFee) && this.composed.custom === undefined) {
                lastFee = lastFee.minus(1);
                const tx = this.compose(lastFee.toString());
                if (tx.type === 'final') {
                    this.feeLevels.updateCustomFee(lastFee.toString());
                    this.composed.custom = tx;
                    return true;
                }
            }
            return false;
        }
        return true;
    }
    composeCustomFee(fee) {
        const tx = this.compose(fee);
        this.composed.custom = tx;
        if (tx.type === 'final') {
            this.feeLevels.updateCustomFee(tx.feePerByte);
        }
        else {
            this.feeLevels.updateCustomFee(fee);
        }
    }
    getFeeLevelList() {
        const list = [];
        const { levels } = this.feeLevels;
        levels.forEach(level => {
            const tx = this.composed[level.label];
            if (tx && tx.type === 'final') {
                list.push({
                    name: level.label,
                    fee: tx.fee,
                    feePerByte: level.feePerUnit,
                    minutes: level.blocks * this.coinInfo.blocktime,
                    total: tx.totalSpent,
                });
            }
            else {
                list.push({
                    name: level.label,
                    fee: '0',
                    disabled: true,
                });
            }
        });
        return list;
    }
    compose(feeRate) {
        const { account, coinInfo, baseFee } = this;
        const { addresses } = account;
        if (!addresses)
            return { type: 'error', error: 'ADDRESSES-NOT-SET' };
        const changeAddress = addresses.change.find(a => !a.transfers) ||
            addresses.change[addresses.change.length - 1];
        const changeId = (0, pathUtils_1.getHDPath)(changeAddress.path).slice(-1)[0];
        const enhancement = {
            baseFee,
            floorBaseFee: false,
            dustOutputFee: 0,
        };
        if (coinInfo.shortcut === 'DOGE') {
            enhancement.dustOutputFee = 1000000;
        }
        return (0, utxo_lib_1.composeTx)({
            txType: account.type,
            utxos: this.utxos,
            outputs: this.outputs,
            height: this.blockHeight,
            feeRate,
            skipPermutation: this.skipPermutation,
            basePath: account.address_n,
            network: coinInfo.network,
            changeId,
            changeAddress: changeAddress.address,
            dustThreshold: coinInfo.dustLimit,
            ...enhancement,
        });
    }
    dispose() {
    }
}
exports.TransactionComposer = TransactionComposer;
//# sourceMappingURL=TransactionComposer.js.map