"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const randombytes_1 = tslib_1.__importDefault(require("randombytes"));
const AbstractMethod_1 = require("../core/AbstractMethod");
const firmware_1 = require("./firmware");
const firmwareInfo_1 = require("../data/firmwareInfo");
const constants_1 = require("../constants");
const assets_1 = require("../utils/assets");
class CheckFirmwareAuthenticity extends AbstractMethod_1.AbstractMethod {
    init() {
        this.useEmptyPassphrase = true;
        this.requiredPermissions = ['management'];
        this.useDeviceState = false;
    }
    async run() {
        const { device } = this;
        const deviceVersion = `${device.features.major_version}.${device.features.minor_version}.${device.features.patch_version}`;
        const releases = (0, firmwareInfo_1.getReleases)(device.features.major_version);
        const release = releases.find(release => release.version.join('.') === deviceVersion);
        if (!release) {
            throw constants_1.ERRORS.TypedError('Runtime', 'checkFirmwareAuthenticity: No release found for device firmware');
        }
        const baseUrl = `https://data.trezor.io/firmware/${device.features.major_version}`;
        const fwUrl = `${baseUrl}/trezor-${deviceVersion}${device.firmwareType === 'bitcoin-only' ? '-bitcoinonly.bin' : '.bin'}`;
        const fw = await (0, assets_1.httpRequest)(fwUrl, 'binary');
        if (!fw) {
            throw constants_1.ERRORS.TypedError('Runtime', 'checkFirmwareAuthenticity: firmware binary not found');
        }
        const { hash: expectedFirmwareHash, challenge } = (0, firmware_1.calculateFirmwareHash)(device.features.major_version, (0, firmware_1.stripFwHeaders)(fw), (0, randombytes_1.default)(32));
        const result = await this.device
            .getCommands()
            .typedCall('GetFirmwareHash', 'FirmwareHash', {
            challenge,
        });
        const { message } = result;
        const { hash: actualFirmwareHash } = message;
        return {
            expectedFirmwareHash,
            actualFirmwareHash,
            valid: actualFirmwareHash === expectedFirmwareHash,
        };
    }
}
exports.default = CheckFirmwareAuthenticity;
//# sourceMappingURL=checkFirmwareAuthenticity.js.map