"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFirmwareRange = exports.validateCoinPath = exports.validateParams = void 0;
const constants_1 = require("../../constants");
const pathUtils_1 = require("../../utils/pathUtils");
const versionUtils_1 = require("../../utils/versionUtils");
const config_1 = require("../../data/config");
const invalidParameter = (message) => constants_1.ERRORS.TypedError('Method_InvalidParameter', message);
function validateParams(params, schema) {
    schema.forEach(field => {
        const value = params[field.name];
        if (field.required && value == null) {
            throw invalidParameter(`Parameter "${field.name}" is missing.`);
        }
        if (!field.type || value == null)
            return;
        const { name, type } = field;
        if (Array.isArray(type)) {
            const p = {};
            p[name] = value;
            const success = type.reduce((count, t) => {
                try {
                    validateParams(p, [{ name: field.name, type: t }]);
                    return count + 1;
                }
                catch (e) {
                    return count;
                }
            }, 0);
            if (!success) {
                throw invalidParameter(`Parameter "${name}" has invalid type. Union of "${type.join('|')}" expected.`);
            }
            return;
        }
        if (type === 'array') {
            if (!Array.isArray(value)) {
                throw invalidParameter(`Parameter "${name}" has invalid type. "${type}" expected.`);
            }
            if (!field.allowEmpty && value.length < 1) {
                throw invalidParameter(`Parameter "${name}" is empty.`);
            }
        }
        else if (type === 'uint') {
            if (typeof value !== 'string' && typeof value !== 'number') {
                throw invalidParameter(`Parameter "${name}" has invalid type. "string|number" expected.`);
            }
            if ((typeof value === 'number' && !Number.isSafeInteger(value)) ||
                !/^(?:[1-9]\d*|\d)$/.test(value.toString().replace(/^-/, field.allowNegative ? '' : '-'))) {
                throw invalidParameter(`Parameter "${name}" has invalid value "${value}". Integer representation expected.`);
            }
        }
        else if (type === 'array-buffer') {
            if (!(value instanceof ArrayBuffer)) {
                throw invalidParameter(`Parameter "${name}" has invalid type. "ArrayBuffer" expected.`);
            }
        }
        else if (typeof value !== type) {
            throw invalidParameter(`Parameter "${name}" has invalid type. "${type}" expected.`);
        }
    });
    return params;
}
exports.validateParams = validateParams;
const validateCoinPath = (path, coinInfo) => {
    if (coinInfo && coinInfo.slip44 !== (0, pathUtils_1.fromHardened)(path[1])) {
        throw invalidParameter('Parameters "path" and "coin" do not match.');
    }
};
exports.validateCoinPath = validateCoinPath;
const getFirmwareRange = (method, coinInfo, currentRange) => {
    const current = JSON.parse(JSON.stringify(currentRange));
    if (coinInfo) {
        if (!coinInfo.support || typeof coinInfo.support.trezor1 !== 'string') {
            current['1'].min = '0';
        }
        else if ((0, versionUtils_1.versionCompare)(coinInfo.support.trezor1, current['1'].min) > 0) {
            current['1'].min = coinInfo.support.trezor1;
        }
        if (!coinInfo.support || typeof coinInfo.support.trezor2 !== 'string') {
            current['2'].min = '0';
        }
        else if ((0, versionUtils_1.versionCompare)(coinInfo.support.trezor2, current['2'].min) > 0) {
            current['2'].min = coinInfo.support.trezor2;
        }
    }
    const coinType = coinInfo ? coinInfo.type : null;
    const shortcut = coinInfo ? coinInfo.shortcut.toLowerCase() : null;
    const { supportedFirmware } = config_1.config;
    const ranges = supportedFirmware
        .filter(rule => {
        if (rule.methods) {
            return rule.methods.includes(method);
        }
        if (rule.capabilities) {
            return rule.capabilities.includes(method);
        }
        return true;
    })
        .filter(c => {
        if (c.coinType) {
            return c.coinType === coinType;
        }
        if (c.coin) {
            return (typeof c.coin === 'string' ? [c.coin] : c.coin).includes(shortcut);
        }
        return c.methods || c.capabilities;
    });
    ranges.forEach(range => {
        const { min, max } = range;
        if (min) {
            const [t1, t2] = min;
            if (t1 === '0' ||
                current['1'].min === '0' ||
                (0, versionUtils_1.versionCompare)(current['1'].min, t1) < 0) {
                current['1'].min = t1;
            }
            if (t2 === '0' ||
                current['2'].min === '0' ||
                (0, versionUtils_1.versionCompare)(current['2'].min, t2) < 0) {
                current['2'].min = t2;
            }
        }
        if (max) {
            const [t1, t2] = max;
            if (t1 === '0' ||
                current['1'].max === '0' ||
                (0, versionUtils_1.versionCompare)(current['1'].max, t1) < 0) {
                current['1'].max = t1;
            }
            if (t2 === '0' ||
                current['2'].max === '0' ||
                (0, versionUtils_1.versionCompare)(current['2'].max, t2) < 0) {
                current['2'].max = t2;
            }
        }
    });
    return current;
};
exports.getFirmwareRange = getFirmwareRange;
//# sourceMappingURL=paramsValidator.js.map