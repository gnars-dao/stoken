"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Blockchain = void 0;
const tslib_1 = require("tslib");
const blockchain_link_1 = tslib_1.__importDefault(require("@trezor/blockchain-link"));
const events_1 = require("../events");
const constants_1 = require("../constants");
const workers_1 = require("../workers/workers");
const getWorker = (type) => {
    switch (type) {
        case 'blockbook':
            return workers_1.BlockbookWorker;
        case 'ripple':
            return workers_1.RippleWorker;
        case 'blockfrost':
            return workers_1.BlockfrostWorker;
        case 'electrum':
            return workers_1.ElectrumWorker;
        default:
            return null;
    }
};
class Blockchain {
    constructor(options) {
        this.feeForBlock = [];
        this.feeTimestamp = 0;
        this.coinInfo = options.coinInfo;
        this.postMessage = options.postMessage;
        this.onConnected = options.onConnected;
        this.onDisconnected = options.onDisconnected;
        const { blockchainLink } = options.coinInfo;
        if (!blockchainLink) {
            throw constants_1.ERRORS.TypedError('Backend_NotSupported');
        }
        const worker = getWorker(blockchainLink.type);
        if (!worker) {
            throw constants_1.ERRORS.TypedError('Backend_WorkerMissing', `BlockchainLink worker not found ${blockchainLink.type}`);
        }
        const server = blockchainLink.url;
        this.link = new blockchain_link_1.default({
            name: this.coinInfo.shortcut,
            worker,
            server,
            debug: options.debug,
            proxy: options.proxy,
        });
    }
    onError(error) {
        var _a;
        this.link.dispose();
        this.postMessage((0, events_1.createBlockchainMessage)(events_1.BLOCKCHAIN.ERROR, {
            coin: this.coinInfo,
            error: error.message,
            code: error.code,
        }));
        (_a = this.onDisconnected) === null || _a === void 0 ? void 0 : _a.call(this);
    }
    async init() {
        this.link.on('connected', async () => {
            var _a;
            const info = await this.link.getInfo();
            this.serverInfo = info;
            const shortcut = this.coinInfo.shortcut === 'tXRP' ? 'XRP' : this.coinInfo.shortcut;
            if (info.shortcut.toLowerCase() !== shortcut.toLowerCase()) {
                this.onError(constants_1.ERRORS.TypedError('Backend_Invalid'));
                return;
            }
            (_a = this.onConnected) === null || _a === void 0 ? void 0 : _a.call(this, info.url);
            this.postMessage((0, events_1.createBlockchainMessage)(events_1.BLOCKCHAIN.CONNECT, {
                coin: this.coinInfo,
                ...info,
            }));
        });
        this.link.on('disconnected', () => {
            this.onError(constants_1.ERRORS.TypedError('Backend_Disconnected'));
        });
        this.link.on('error', error => {
            this.onError(constants_1.ERRORS.TypedError('Backend_Error', error.message));
        });
        try {
            await this.link.connect();
        }
        catch (error) {
            this.onError(constants_1.ERRORS.TypedError('Backend_Error', error.message));
            throw error;
        }
    }
    getTransactions(txs) {
        return Promise.all(txs.map(id => this.link.getTransaction(id)));
    }
    getCurrentFiatRates(params) {
        return this.link.getCurrentFiatRates(params);
    }
    getFiatRatesForTimestamps(params) {
        return this.link.getFiatRatesForTimestamps(params);
    }
    getAccountBalanceHistory(params) {
        return this.link.getAccountBalanceHistory(params);
    }
    getNetworkInfo() {
        return this.link.getInfo();
    }
    getAccountInfo(request) {
        return this.link.getAccountInfo(request);
    }
    getAccountUtxo(descriptor) {
        return this.link.getAccountUtxo(descriptor);
    }
    async estimateFee(request) {
        const { blocks } = request;
        if (blocks) {
            const now = Date.now();
            const outdated = now - this.feeTimestamp > 20 * 60 * 1000;
            const unknownBlocks = blocks.filter(() => typeof this.feeForBlock !== 'string');
            if (!outdated && unknownBlocks.length < 1) {
            }
            const fees = await this.link.estimateFee(request);
            blocks.forEach((block, index) => {
                this.feeForBlock[block] = fees[index];
            });
            this.feeTimestamp = now;
            return fees;
        }
        return this.link.estimateFee(request);
    }
    async subscribe(accounts) {
        if (this.link.listenerCount('block') === 0) {
            this.link.on('block', block => {
                this.postMessage((0, events_1.createBlockchainMessage)(events_1.BLOCKCHAIN.BLOCK, {
                    coin: this.coinInfo,
                    ...block,
                }));
            });
        }
        if (this.link.listenerCount('notification') === 0) {
            this.link.on('notification', notification => {
                this.postMessage((0, events_1.createBlockchainMessage)(events_1.BLOCKCHAIN.NOTIFICATION, {
                    coin: this.coinInfo,
                    notification,
                }));
            });
        }
        const blockSubscription = await this.link.subscribe({ type: 'block' });
        if (!accounts) {
            return blockSubscription;
        }
        return this.link.subscribe({
            type: 'accounts',
            accounts,
        });
    }
    subscribeFiatRates(_currency) {
        if (this.link.listenerCount('fiatRates') === 0) {
            this.link.on('fiatRates', ({ rates }) => {
                this.postMessage((0, events_1.createBlockchainMessage)(events_1.BLOCKCHAIN.FIAT_RATES_UPDATE, {
                    coin: this.coinInfo,
                    rates,
                }));
            });
        }
        return this.link.subscribe({
            type: 'fiatRates',
        });
    }
    async unsubscribe(accounts) {
        if (!accounts) {
            this.link.removeAllListeners('block');
            this.link.removeAllListeners('fiatRates');
            this.link.removeAllListeners('notification');
            await this.link.unsubscribe({ type: 'fiatRates' });
            return this.link.unsubscribe({ type: 'block' });
        }
        return this.link.unsubscribe({ type: 'accounts', accounts });
    }
    unsubscribeFiatRates() {
        this.link.removeAllListeners('fiatRates');
        return this.link.unsubscribe({ type: 'fiatRates' });
    }
    pushTransaction(tx) {
        return this.link.pushTransaction(tx);
    }
    disconnect() {
        this.link.removeAllListeners();
        this.link.disconnect();
        this.onError(constants_1.ERRORS.TypedError('Backend_Disconnected'));
    }
}
exports.Blockchain = Blockchain;
//# sourceMappingURL=Blockchain.js.map