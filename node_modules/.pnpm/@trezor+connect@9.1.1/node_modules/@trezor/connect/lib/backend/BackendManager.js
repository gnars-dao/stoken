"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BackendManager = void 0;
const DataManager_1 = require("../data/DataManager");
const constants_1 = require("../constants");
const Blockchain_1 = require("./Blockchain");
class BackendManager {
    constructor() {
        this.instances = {};
        this.custom = {};
        this.preferred = {};
    }
    get(shortcut) {
        var _a;
        return (_a = this.instances[shortcut]) !== null && _a !== void 0 ? _a : null;
    }
    remove(shortcut) {
        delete this.instances[shortcut];
    }
    async getOrConnect(coinInfo, postMessage) {
        let backend = this.get(coinInfo.shortcut);
        if (!backend) {
            backend = new Blockchain_1.Blockchain({
                coinInfo: this.patchCoinInfo(coinInfo),
                postMessage,
                debug: DataManager_1.DataManager.getSettings('debug'),
                proxy: DataManager_1.DataManager.getSettings('proxy'),
                onConnected: url => this.setPreferred(coinInfo.shortcut, url),
                onDisconnected: () => this.remove(coinInfo.shortcut),
            });
            this.instances[coinInfo.shortcut] = backend;
            try {
                await backend.init();
            }
            catch (error) {
                this.remove(coinInfo.shortcut);
                this.removePreferred(coinInfo.shortcut);
                throw error;
            }
        }
        return backend;
    }
    dispose() {
        Object.values(this.instances).forEach(i => i.disconnect());
    }
    reconnectAll() {
        const params = Object.values(this.instances).map(i => [i.coinInfo, i.postMessage]);
        Object.values(this.instances).forEach(i => i.disconnect());
        return Promise.all(params.map(p => this.getOrConnect(...p)));
    }
    isSupported(coinInfo) {
        const info = this.custom[coinInfo.shortcut] || coinInfo.blockchainLink;
        if (!info) {
            throw constants_1.ERRORS.TypedError('Backend_NotSupported');
        }
    }
    setCustom(shortcut, blockchainLink) {
        this.removePreferred(shortcut);
        this.custom[shortcut] = blockchainLink;
    }
    removeCustom(shortcut) {
        this.removePreferred(shortcut);
        delete this.custom[shortcut];
    }
    setPreferred(shortcut, url) {
        this.preferred[shortcut] = url;
    }
    removePreferred(shortcut) {
        delete this.preferred[shortcut];
    }
    patchCoinInfo(coinInfo) {
        var _a, _b;
        const custom = this.custom[coinInfo.shortcut];
        const preferred = this.preferred[coinInfo.shortcut];
        const url = preferred ? [preferred] : (_a = custom === null || custom === void 0 ? void 0 : custom.url) !== null && _a !== void 0 ? _a : (_b = coinInfo.blockchainLink) === null || _b === void 0 ? void 0 : _b.url;
        return {
            ...coinInfo,
            blockchainLink: {
                ...coinInfo.blockchainLink,
                ...custom,
                url,
            },
        };
    }
}
exports.BackendManager = BackendManager;
//# sourceMappingURL=BackendManager.js.map