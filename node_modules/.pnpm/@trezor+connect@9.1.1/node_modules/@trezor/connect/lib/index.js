"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.messagePromises = exports.eventEmitter = void 0;
const tslib_1 = require("tslib");
const events_1 = tslib_1.__importDefault(require("events"));
const utils_1 = require("@trezor/utils");
const core_1 = require("./core");
const factory_1 = require("./factory");
const connectSettings_1 = require("./data/connectSettings");
const debug_1 = require("./utils/debug");
const events_2 = require("./events");
const constants_1 = require("./constants");
exports.eventEmitter = new events_1.default();
const _log = (0, debug_1.initLog)('@trezor/connect');
let _settings = (0, connectSettings_1.parseConnectSettings)();
let _core = null;
let _messageID = 0;
exports.messagePromises = {};
const manifest = (data) => {
    _settings = (0, connectSettings_1.parseConnectSettings)({
        ..._settings,
        manifest: data,
    });
};
const dispose = async () => {
    exports.eventEmitter.removeAllListeners();
    _settings = (0, connectSettings_1.parseConnectSettings)();
    if (_core) {
        await _core.dispose();
        _core = null;
    }
};
const handleMessage = (message) => {
    const { event, type, payload } = message;
    const id = message.id || 0;
    if (!_core)
        return;
    if (type === events_2.UI.REQUEST_UI_WINDOW) {
        _core.handleMessage({ event: events_2.UI_EVENT, type: events_2.POPUP.HANDSHAKE });
        return;
    }
    if (type === events_2.POPUP.CANCEL_POPUP_REQUEST)
        return;
    _log.debug('handleMessage', message);
    switch (event) {
        case events_2.RESPONSE_EVENT:
            if (exports.messagePromises[id]) {
                exports.messagePromises[id].resolve({
                    id,
                    success: message.success,
                    payload,
                });
                delete exports.messagePromises[id];
            }
            else {
                _log.warn(`Unknown message id ${id}`);
            }
            break;
        case events_2.DEVICE_EVENT:
            exports.eventEmitter.emit(event, message);
            exports.eventEmitter.emit(type, payload);
            break;
        case events_2.TRANSPORT_EVENT:
            exports.eventEmitter.emit(event, message);
            exports.eventEmitter.emit(type, payload);
            break;
        case events_2.BLOCKCHAIN_EVENT:
            exports.eventEmitter.emit(event, message);
            exports.eventEmitter.emit(type, payload);
            break;
        case events_2.UI_EVENT:
            exports.eventEmitter.emit(event, message);
            exports.eventEmitter.emit(type, payload);
            break;
        default:
            _log.warn('Undefined message', event, message);
    }
};
function postMessage(message, usePromise = true) {
    if (!_core) {
        throw constants_1.ERRORS.TypedError('Runtime', 'postMessage: _core not found');
    }
    if (usePromise) {
        _messageID++;
        exports.messagePromises[_messageID] = (0, utils_1.createDeferred)();
        const { promise } = exports.messagePromises[_messageID];
        _core.handleMessage({ ...message, id: _messageID });
        return promise;
    }
    _core.handleMessage(message);
}
const init = async (settings = {}) => {
    var _a;
    if (_core) {
        throw constants_1.ERRORS.TypedError('Init_AlreadyInitialized');
    }
    _settings = (0, connectSettings_1.parseConnectSettings)({ ..._settings, ...settings, popup: false });
    if (!_settings.manifest) {
        throw constants_1.ERRORS.TypedError('Init_ManifestMissing');
    }
    if (!((_a = _settings.transports) === null || _a === void 0 ? void 0 : _a.length)) {
        _settings.transports = ['BridgeTransport'];
    }
    if (_settings.lazyLoad) {
        _settings.lazyLoad = false;
        return;
    }
    _core = await (0, core_1.initCore)(_settings);
    _core.on(events_2.CORE_EVENT, handleMessage);
    await (0, core_1.initTransport)(_settings);
};
const call = async (params) => {
    if (!_core) {
        try {
            await init(_settings);
        }
        catch (error) {
            return (0, events_2.createErrorMessage)(error);
        }
    }
    try {
        const response = await postMessage({
            type: events_2.IFRAME.CALL,
            payload: params,
        });
        if (response) {
            return response;
        }
        return (0, events_2.createErrorMessage)(constants_1.ERRORS.TypedError('Method_NoResponse'));
    }
    catch (error) {
        _log.error('call', error);
        return (0, events_2.createErrorMessage)(error);
    }
};
const uiResponse = (response) => {
    if (!_core) {
        throw constants_1.ERRORS.TypedError('Init_NotInitialized');
    }
    const { type, payload } = response;
    _core.handleMessage({ event: events_2.UI_EVENT, type, payload });
};
const requestLogin = async (params) => {
    if (typeof params.callback === 'function') {
        const { callback } = params;
        const loginChallengeListener = async (event) => {
            const { data } = event;
            if (data && data.type === events_2.UI.LOGIN_CHALLENGE_REQUEST) {
                try {
                    const payload = await callback();
                    _core === null || _core === void 0 ? void 0 : _core.handleMessage({
                        event: events_2.UI_EVENT,
                        type: events_2.UI.LOGIN_CHALLENGE_RESPONSE,
                        payload,
                    });
                }
                catch (error) {
                    _core === null || _core === void 0 ? void 0 : _core.handleMessage({
                        event: events_2.UI_EVENT,
                        type: events_2.UI.LOGIN_CHALLENGE_RESPONSE,
                        payload: error.message,
                    });
                }
            }
        };
        _core === null || _core === void 0 ? void 0 : _core.on(events_2.CORE_EVENT, loginChallengeListener);
        const response = await call({
            method: 'requestLogin',
            ...params,
            asyncChallenge: true,
            callback: null,
        });
        _core === null || _core === void 0 ? void 0 : _core.removeListener(events_2.CORE_EVENT, loginChallengeListener);
        return response;
    }
    return call({ method: 'requestLogin', ...params });
};
const cancel = (error) => {
    postMessage({
        type: events_2.POPUP.CLOSED,
        payload: error ? { error } : null,
    }, false);
};
const renderWebUSBButton = (_className) => {
    throw constants_1.ERRORS.TypedError('Method_InvalidPackage');
};
const disableWebUSB = () => {
    throw constants_1.ERRORS.TypedError('Method_InvalidPackage');
};
const requestWebUSBDevice = () => {
    throw constants_1.ERRORS.TypedError('Method_InvalidPackage');
};
const TrezorConnect = (0, factory_1.factory)({
    eventEmitter: exports.eventEmitter,
    manifest,
    init,
    call,
    requestLogin,
    uiResponse,
    renderWebUSBButton,
    disableWebUSB,
    requestWebUSBDevice,
    cancel,
    dispose,
});
exports.default = TrezorConnect;
tslib_1.__exportStar(require("./exports"), exports);
//# sourceMappingURL=index.js.map