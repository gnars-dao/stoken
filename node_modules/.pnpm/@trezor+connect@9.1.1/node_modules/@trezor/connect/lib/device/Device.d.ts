import { TypedEmitter } from '@trezor/utils/lib/typedEventEmitter';
import { DeviceCommands } from './DeviceCommands';
import { PROTO, NETWORK } from '../constants';
import { DEVICE, DeviceButtonRequestPayload } from '../events';
import { Deferred } from '../utils/deferred';
import type { Transport, Descriptor } from '@trezor/transport';
import type { Device as DeviceTyped, DeviceFirmwareStatus, Features, ReleaseInfo, UnavailableCapabilities } from '../types';
export type RunOptions = {
    skipFinalReload?: boolean;
    waiting?: boolean;
    onlyOneActivity?: boolean;
    cancelPopupRequest?: () => any;
    keepSession?: boolean;
    useEmptyPassphrase?: boolean;
    useCardanoDerivation?: boolean;
};
export interface DeviceEvents {
    [DEVICE.PIN]: (device: Device, b: PROTO.PinMatrixRequestType | undefined, callback: (err: any, pin: string) => void) => void;
    [DEVICE.WORD]: (device: Device, b: PROTO.WordRequestType, callback: (err: any, word: string) => void) => void;
    [DEVICE.PASSPHRASE]: (device: Device, callback: (response: any) => void) => void;
    [DEVICE.PASSPHRASE_ON_DEVICE]: () => void;
    [DEVICE.BUTTON]: (device: Device, payload: DeviceButtonRequestPayload) => void;
    [DEVICE.ACQUIRED]: () => void;
}
export declare class Device extends TypedEmitter<DeviceEvents> {
    transport: Transport;
    originalDescriptor: Descriptor;
    unreadableError?: string;
    firmwareStatus: DeviceFirmwareStatus;
    firmwareRelease?: ReleaseInfo | null;
    features: Features;
    featuresNeedsReload: boolean;
    acquirePromise?: ReturnType<Transport['acquire']>;
    releasePromise?: ReturnType<Transport['release']>;
    runPromise?: Deferred<void> | null;
    loaded: boolean;
    inconsistent: boolean;
    firstRunPromise: Deferred<boolean>;
    activitySessionID?: string | null;
    commands?: DeviceCommands;
    keepSession: boolean;
    instance: number;
    internalState: string[];
    externalState: string[];
    unavailableCapabilities: UnavailableCapabilities;
    networkTypeState: NETWORK.NetworkType[];
    firmwareType: 'regular' | 'bitcoin-only';
    constructor(transport: Transport, descriptor: Descriptor);
    static fromDescriptor(transport: Transport, originalDescriptor: Descriptor): Device;
    static createUnacquired(transport: Transport, descriptor: Descriptor, unreadableError?: string): Device;
    acquire(): Promise<void>;
    release(): Promise<void>;
    cleanup(): Promise<void>;
    run(fn?: () => Promise<void>, options?: RunOptions): Promise<void>;
    override(error: Error): Promise<void>;
    interruptionFromUser(error: Error): Promise<void>;
    interruptionFromOutside(): void;
    _runInner<X>(fn: (() => Promise<X>) | undefined, options: RunOptions): Promise<void>;
    getCommands(): DeviceCommands;
    setInstance(instance?: number): void;
    getInstance(): number;
    setInternalState(state?: string): void;
    getInternalState(): string;
    setExternalState(state?: string): void;
    getExternalState(): string;
    validateState(networkType?: NETWORK.NetworkType, preauthorized?: boolean): Promise<string | undefined>;
    useLegacyPassphrase(): boolean;
    initialize(useEmptyPassphrase: boolean, useCardanoDerivation: boolean): Promise<void>;
    getFeatures(): Promise<void>;
    _updateFeatures(feat: Features): void;
    isUnacquired(): boolean;
    disconnect(): void;
    isBootloader(): boolean;
    isInitialized(): boolean;
    isSeedless(): boolean;
    isInconsistent(): boolean;
    getVersion(): number[];
    atLeast(versions: string[] | string): boolean;
    isUsed(): boolean;
    isUsedHere(): boolean;
    isUsedElsewhere(): boolean;
    isRunning(): boolean;
    isLoaded(): boolean;
    waitForFirstRun(): Promise<boolean>;
    getDevicePath(): string;
    isT1(): boolean;
    hasUnexpectedMode(allow: string[], require: string[]): "ui-device_bootloader_mode" | "ui-device_not_in_bootloader_mode" | "ui-device_not_initialized" | "ui-device_seedless" | null;
    dispose(): import("packages/transport/lib/types").AbortableCall<void, "Network request failed" | "Wrong result type." | "device disconnected during action" | "unexpected error" | "Aborted by timeout" | "Aborted by signal" | "This transport can not be used in this environment" | "device not found" | "Unable to open device" | "wrong previous session" | "session not found"> | undefined;
    getMode(): "normal" | "bootloader" | "initialize" | "seedless";
    toMessageObject(): DeviceTyped;
    _getNetworkTypeState(): "bitcoin" | "ethereum" | "nem" | "eos" | "stellar" | "cardano" | "ripple" | "tezos" | "binance";
    _setNetworkTypeState(networkType?: NETWORK.NetworkType): void;
    _altModeChange(networkType?: NETWORK.NetworkType): boolean;
    _isAltModeNetworkType(networkType?: keyof typeof NETWORK.TYPES): boolean;
    legacyForceRelease(): Promise<void>;
}
//# sourceMappingURL=Device.d.ts.map