"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeviceList = void 0;
const typedEventEmitter_1 = require("@trezor/utils/lib/typedEventEmitter");
const transport_1 = require("@trezor/transport");
const constants_1 = require("../constants");
const events_1 = require("../events");
const Device_1 = require("./Device");
const DataManager_1 = require("../data/DataManager");
const transportInfo_1 = require("../data/transportInfo");
const debug_1 = require("../utils/debug");
const promiseUtils_1 = require("../utils/promiseUtils");
const _log = (0, debug_1.initLog)('DeviceList');
let autoResolveTransportEventTimeout;
class DeviceList extends typedEventEmitter_1.TypedEmitter {
    constructor() {
        super();
        this.transports = [];
        this.devices = {};
        this.creatingDevicesDescriptors = {};
        this.transportStartPending = 0;
        this.penalizedDevices = {};
        let { transports } = DataManager_1.DataManager.getSettings();
        const { debug } = DataManager_1.DataManager.getSettings();
        this.messages = DataManager_1.DataManager.getProtobufMessages();
        if (!(transports === null || transports === void 0 ? void 0 : transports.length)) {
            transports = ['BridgeTransport'];
        }
        const transportLogger = (0, debug_1.initLog)('@trezor/transport', debug);
        transports.forEach(transportType => {
            if (typeof transportType === 'string') {
                switch (transportType) {
                    case 'WebUsbTransport':
                        this.transports.push(new transport_1.WebUsbTransport({
                            messages: this.messages,
                            logger: transportLogger,
                        }));
                        break;
                    case 'NodeUsbTransport':
                        this.transports.push(new transport_1.NodeUsbTransport({
                            messages: this.messages,
                            logger: transportLogger,
                        }));
                        break;
                    case 'BridgeTransport':
                        this.transports.push(new transport_1.BridgeTransport({
                            latestVersion: (0, transportInfo_1.getBridgeInfo)().version.join('.'),
                            messages: this.messages,
                            logger: transportLogger,
                        }));
                        break;
                    default:
                        throw constants_1.ERRORS.TypedError('Runtime', `DeviceList.init: transports[] of unexpected type: ${transportType}`);
                }
            }
            else if (transportType instanceof transport_1.Transport) {
                this.transports.unshift(transportType);
            }
            else {
                throw constants_1.ERRORS.TypedError('Runtime', 'DeviceList.init: transports[] of unexpected type');
            }
        });
    }
    async init() {
        try {
            _log.debug('Initializing transports');
            let lastError;
            for (const transport of this.transports) {
                this.transport = transport;
                const result = await this.transport.init().promise;
                if (result.success) {
                    lastError = undefined;
                    break;
                }
                else {
                    lastError = result.error;
                }
            }
            if (lastError) {
                this.emit(transport_1.TRANSPORT.ERROR, lastError);
                return;
            }
            this.transport.on(transport_1.TRANSPORT.UPDATE, diff => {
                diff.connected.forEach(async (descriptor) => {
                    const path = descriptor.path.toString();
                    const priority = DataManager_1.DataManager.getSettings('priority');
                    const penalty = this.getAuthPenalty();
                    if (priority || penalty) {
                        await (0, promiseUtils_1.resolveAfter)(501 + penalty + 100 * priority, null).promise;
                    }
                    if (descriptor.session == null) {
                        await this._createAndSaveDevice(descriptor);
                    }
                    else {
                        const device = this._createUnacquiredDevice(descriptor);
                        this.devices[path] = device;
                        this.emit(events_1.DEVICE.CONNECT_UNACQUIRED, device.toMessageObject());
                    }
                });
                diff.acquiredElsewhere.forEach((descriptor) => {
                    const path = descriptor.path.toString();
                    const device = this.devices[path];
                    if (device) {
                        device.featuresNeedsReload = true;
                        device.interruptionFromOutside();
                    }
                });
                diff.released.forEach(descriptor => {
                    var _a;
                    const path = descriptor.path.toString();
                    const device = this.devices[path];
                    const methodStillRunning = !((_a = device === null || device === void 0 ? void 0 : device.commands) === null || _a === void 0 ? void 0 : _a.disposed);
                    if (device && methodStillRunning) {
                        device.keepSession = false;
                    }
                });
                diff.releasedElsewhere.forEach(async (descriptor) => {
                    const path = descriptor.path.toString();
                    const device = this.devices[path];
                    await (0, promiseUtils_1.resolveAfter)(1000, null).promise;
                    if (device) {
                        if (!device.isUsed() && device.isUnacquired() && !device.isInconsistent()) {
                            _log.debug('Create device from unacquired', device);
                            await this._createAndSaveDevice(descriptor);
                        }
                    }
                });
                const events = [
                    {
                        d: diff.changedSessions,
                        e: events_1.DEVICE.CHANGED,
                    },
                    {
                        d: diff.acquired,
                        e: events_1.DEVICE.ACQUIRED,
                    },
                    {
                        d: diff.released,
                        e: events_1.DEVICE.RELEASED,
                    },
                ];
                events.forEach(({ d, e }) => {
                    d.forEach(descriptor => {
                        const path = descriptor.path.toString();
                        const device = this.devices[path];
                        _log.debug('Event', e, device);
                        if (device) {
                            this.emit(e, device.toMessageObject());
                        }
                    });
                });
                diff.disconnected.forEach(descriptor => {
                    const path = descriptor.path.toString();
                    const device = this.devices[path];
                    if (device) {
                        device.disconnect();
                        delete this.devices[path];
                        this.emit(events_1.DEVICE.DISCONNECT, device.toMessageObject());
                    }
                });
                diff.descriptors.forEach(d => {
                    if (this.devices[d.path]) {
                        this.devices[d.path].originalDescriptor = {
                            session: d.session,
                            path: d.path,
                        };
                    }
                });
            });
            this.transport.on(transport_1.TRANSPORT.ERROR, error => {
                this.emit(transport_1.TRANSPORT.ERROR, error);
            });
            const enumerateResult = await this.transport.enumerate().promise;
            if (!enumerateResult.success) {
                this.emit(transport_1.TRANSPORT.ERROR, enumerateResult.error);
                return;
            }
            const descriptors = enumerateResult.payload;
            if (descriptors.length > 0 && DataManager_1.DataManager.getSettings('pendingTransportEvent')) {
                this.transportStartPending = descriptors.length;
                this.on(events_1.DEVICE.CONNECT, this.resolveTransportEvent.bind(this));
                this.on(events_1.DEVICE.CONNECT_UNACQUIRED, this.resolveTransportEvent.bind(this));
                autoResolveTransportEventTimeout = setTimeout(() => {
                    this.emit(transport_1.TRANSPORT.START, this.getTransportInfo());
                }, 10000);
            }
            else {
                this.emit(transport_1.TRANSPORT.START, this.getTransportInfo());
            }
            this.transport.handleDescriptorsChange(descriptors);
            this.transport.listen();
        }
        catch (error) {
            console.error('DeviceList init error', error);
        }
    }
    resolveTransportEvent() {
        this.transportStartPending--;
        if (autoResolveTransportEventTimeout) {
            clearTimeout(autoResolveTransportEventTimeout);
        }
        if (this.transportStartPending === 0) {
            this.emit(transport_1.TRANSPORT.START, this.getTransportInfo());
        }
    }
    async waitForTransportFirstEvent() {
        await new Promise(resolve => {
            const handler = () => {
                this.removeListener(transport_1.TRANSPORT.START, handler);
                this.removeListener(transport_1.TRANSPORT.ERROR, handler);
                resolve();
            };
            this.on(transport_1.TRANSPORT.START, handler);
            this.on(transport_1.TRANSPORT.ERROR, handler);
        });
    }
    async _createAndSaveDevice(descriptor) {
        _log.debug('Creating Device', descriptor);
        await this.handle(descriptor);
    }
    _createUnacquiredDevice(descriptor) {
        _log.debug('Creating Unacquired Device', descriptor);
        const device = Device_1.Device.createUnacquired(this.transport, descriptor);
        device.once(events_1.DEVICE.ACQUIRED, () => {
            this.emit(events_1.DEVICE.CONNECT, device.toMessageObject());
        });
        return device;
    }
    _createUnreadableDevice(descriptor, unreadableError) {
        _log.debug('Creating Unreadable Device', descriptor, unreadableError);
        return Device_1.Device.createUnacquired(this.transport, descriptor, unreadableError);
    }
    getDevice(path) {
        return this.devices[path];
    }
    getFirstDevicePath() {
        return this.asArray()[0].path;
    }
    asArray() {
        return this.allDevices().map(device => device.toMessageObject());
    }
    allDevices() {
        return Object.keys(this.devices).map(key => this.devices[key]);
    }
    length() {
        return this.asArray().length;
    }
    transportType() {
        return this.transport.name;
    }
    getTransportInfo() {
        return {
            type: this.transportType(),
            version: this.transport.version,
            outdated: this.transport.isOutdated,
        };
    }
    async dispose() {
        this.removeAllListeners();
        if (autoResolveTransportEventTimeout) {
            clearTimeout(autoResolveTransportEventTimeout);
        }
        await Promise.all(this.allDevices().map(device => device.dispose()));
        this.transport.stop();
    }
    disconnectDevices() {
        this.allDevices().forEach(device => {
            this.emit(events_1.DEVICE.DISCONNECT, device.toMessageObject());
        });
    }
    async enumerate() {
        const res = await this.transport.enumerate().promise;
        if (!res.success) {
            return;
        }
        res.payload.forEach(d => {
            if (this.devices[d.path]) {
                this.devices[d.path].originalDescriptor = {
                    session: d.session,
                    path: d.path,
                };
                this.devices[d.path].activitySessionID = d.session;
            }
        });
    }
    addAuthPenalty(device) {
        if (!device.isInitialized() || device.isBootloader() || !device.features.device_id)
            return;
        const deviceID = device.features.device_id;
        const penalty = this.penalizedDevices[deviceID]
            ? this.penalizedDevices[deviceID] + 500
            : 2000;
        this.penalizedDevices[deviceID] = Math.min(penalty, 5000);
    }
    getAuthPenalty() {
        const { penalizedDevices } = this;
        return Object.keys(penalizedDevices).reduce((penalty, key) => Math.max(penalty, penalizedDevices[key]), 0);
    }
    removeAuthPenalty(device) {
        if (!device.isInitialized() || device.isBootloader() || !device.features.device_id)
            return;
        const deviceID = device.features.device_id;
        delete this.penalizedDevices[deviceID];
    }
    async handle(descriptor) {
        var _a;
        const path = descriptor.path.toString();
        this.creatingDevicesDescriptors[path] = descriptor;
        try {
            await this._takeAndCreateDevice(descriptor);
        }
        catch (error) {
            _log.debug('Cannot create device', error);
            if (error.code === 'Device_NotFound' ||
                error.message === transport_1.TRANSPORT_ERROR.DEVICE_NOT_FOUND ||
                error.message === transport_1.TRANSPORT_ERROR.DEVICE_DISCONNECTED_DURING_ACTION ||
                error.message === transport_1.TRANSPORT_ERROR.UNEXPECTED_ERROR ||
                error.message === transport_1.TRANSPORT_ERROR.INTERFACE_UNABLE_TO_OPEN_DEVICE) {
                delete this.devices[path];
            }
            else if (error.message === transport_1.TRANSPORT_ERROR.SESSION_WRONG_PREVIOUS) {
                this.enumerate();
                this._handleUsedElsewhere(descriptor);
            }
            else if (((_a = error.message) === null || _a === void 0 ? void 0 : _a.indexOf(constants_1.ERRORS.LIBUSB_ERROR_MESSAGE)) >= 0) {
                const device = this._createUnreadableDevice(this.creatingDevicesDescriptors[path], error.message);
                this.devices[path] = device;
                this.emit(events_1.DEVICE.CONNECT_UNACQUIRED, device.toMessageObject());
            }
            else if (error.code === 'Device_InitializeFailed') {
                this._handleUsedElsewhere(descriptor);
            }
            else if (error.code === 'Device_UsedElsewhere') {
                this._handleUsedElsewhere(descriptor);
            }
            else {
                await (0, promiseUtils_1.resolveAfter)(501, null).promise;
                await this.handle(descriptor);
            }
        }
        delete this.creatingDevicesDescriptors[path];
    }
    async _takeAndCreateDevice(descriptor) {
        const device = Device_1.Device.fromDescriptor(this.transport, descriptor);
        const path = descriptor.path.toString();
        this.devices[path] = device;
        const promise = device.run();
        await promise;
        this.emit(events_1.DEVICE.CONNECT, device.toMessageObject());
    }
    _handleUsedElsewhere(descriptor) {
        const path = descriptor.path.toString();
        const device = this._createUnacquiredDevice(this.creatingDevicesDescriptors[path]);
        this.devices[path] = device;
        this.emit(events_1.DEVICE.CONNECT_UNACQUIRED, device.toMessageObject());
    }
}
exports.DeviceList = DeviceList;
//# sourceMappingURL=DeviceList.js.map