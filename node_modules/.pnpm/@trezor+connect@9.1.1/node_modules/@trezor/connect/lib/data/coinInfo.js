"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllNetworks = exports.getUniqueNetworks = exports.parseCoinsJson = exports.getCoinName = exports.getCoinInfo = exports.getCoinInfoByHash = exports.fixCoinInfoNetwork = exports.getBech32Network = exports.getSegwitNetwork = exports.getMiscNetwork = exports.getEthereumNetwork = exports.getBitcoinNetwork = void 0;
const constants_1 = require("../constants");
const pathUtils_1 = require("../utils/pathUtils");
const utils_1 = require("@trezor/utils");
const bitcoinNetworks = [];
const ethereumNetworks = [];
const miscNetworks = [];
const getBitcoinNetwork = (pathOrName) => {
    const networks = (0, utils_1.cloneObject)(bitcoinNetworks);
    if (typeof pathOrName === 'string') {
        const name = pathOrName.toLowerCase();
        return networks.find(n => n.name.toLowerCase() === name ||
            n.shortcut.toLowerCase() === name ||
            n.label.toLowerCase() === name);
    }
    const slip44 = (0, pathUtils_1.fromHardened)(pathOrName[1]);
    return networks.find(n => n.slip44 === slip44);
};
exports.getBitcoinNetwork = getBitcoinNetwork;
const getEthereumNetwork = (pathOrName) => {
    const networks = (0, utils_1.cloneObject)(ethereumNetworks);
    if (typeof pathOrName === 'string') {
        const name = pathOrName.toLowerCase();
        return networks.find(n => n.name.toLowerCase() === name || n.shortcut.toLowerCase() === name);
    }
    const slip44 = (0, pathUtils_1.fromHardened)(pathOrName[1]);
    return networks.find(n => n.slip44 === slip44);
};
exports.getEthereumNetwork = getEthereumNetwork;
const getMiscNetwork = (pathOrName) => {
    const networks = (0, utils_1.cloneObject)(miscNetworks);
    if (typeof pathOrName === 'string') {
        const name = pathOrName.toLowerCase();
        return networks.find(n => n.name.toLowerCase() === name || n.shortcut.toLowerCase() === name);
    }
    const slip44 = (0, pathUtils_1.fromHardened)(pathOrName[1]);
    return networks.find(n => n.slip44 === slip44);
};
exports.getMiscNetwork = getMiscNetwork;
const getSegwitNetwork = (coin) => {
    if (coin.segwit && typeof coin.xPubMagicSegwit === 'number') {
        return {
            ...coin.network,
            bip32: {
                ...coin.network.bip32,
                public: coin.xPubMagicSegwit,
            },
        };
    }
    return null;
};
exports.getSegwitNetwork = getSegwitNetwork;
const getBech32Network = (coin) => {
    if (coin.segwit && typeof coin.xPubMagicSegwitNative === 'number') {
        return {
            ...coin.network,
            bip32: {
                ...coin.network.bip32,
                public: coin.xPubMagicSegwitNative,
            },
        };
    }
    return null;
};
exports.getBech32Network = getBech32Network;
const fixCoinInfoNetwork = (ci, path) => {
    const coinInfo = (0, utils_1.cloneObject)(ci);
    if (path[0] === (0, pathUtils_1.toHardened)(84)) {
        const bech32Network = (0, exports.getBech32Network)(coinInfo);
        if (bech32Network) {
            coinInfo.network = bech32Network;
        }
    }
    else if (path[0] === (0, pathUtils_1.toHardened)(49)) {
        const segwitNetwork = (0, exports.getSegwitNetwork)(coinInfo);
        if (segwitNetwork) {
            coinInfo.network = segwitNetwork;
        }
    }
    else {
        coinInfo.segwit = false;
    }
    return coinInfo;
};
exports.fixCoinInfoNetwork = fixCoinInfoNetwork;
const detectBtcVersion = (data) => {
    if (data.subversion == null) {
        return 'btc';
    }
    if (data.subversion.startsWith('/Bitcoin ABC')) {
        return 'bch';
    }
    if (data.subversion.startsWith('/Bitcoin Cash')) {
        return 'bch';
    }
    if (data.subversion.startsWith('/Bitcoin Gold')) {
        return 'btg';
    }
    return 'btc';
};
const getCoinInfoByHash = (hash, networkInfo) => {
    const networks = (0, utils_1.cloneObject)(bitcoinNetworks);
    const result = networks.find(info => hash.toLowerCase() === info.hashGenesisBlock.toLowerCase());
    if (!result) {
        throw constants_1.ERRORS.TypedError('Method_UnknownCoin', `Coin info not found for hash: ${hash} ${networkInfo.hashGenesisBlock}`);
    }
    if (result.isBitcoin) {
        const btcVersion = detectBtcVersion(networkInfo);
        let fork;
        if (btcVersion === 'bch') {
            fork = networks.find(info => info.name === 'Bcash');
        }
        else if (btcVersion === 'btg') {
            fork = networks.find(info => info.name === 'Bgold');
        }
        if (fork) {
            return fork;
        }
        throw constants_1.ERRORS.TypedError('Method_UnknownCoin', `Coin info not found for hash: ${hash} ${networkInfo.hashGenesisBlock} BTC version:${btcVersion}`);
    }
    return result;
};
exports.getCoinInfoByHash = getCoinInfoByHash;
const getCoinInfo = (currency) => (0, exports.getBitcoinNetwork)(currency) || (0, exports.getEthereumNetwork)(currency) || (0, exports.getMiscNetwork)(currency);
exports.getCoinInfo = getCoinInfo;
const getCoinName = (path) => {
    const slip44 = (0, pathUtils_1.fromHardened)(path[1]);
    const network = ethereumNetworks.find(n => n.slip44 === slip44);
    return network ? network.name : 'Unknown coin';
};
exports.getCoinName = getCoinName;
const parseBitcoinNetworksJson = (json) => {
    Object.keys(json).forEach(key => {
        const coin = json[key];
        const shortcut = coin.coin_shortcut;
        const isBitcoin = shortcut === 'BTC' || shortcut === 'TEST';
        const network = {
            messagePrefix: coin.signed_message_header,
            bech32: coin.bech32_prefix,
            bip32: {
                public: coin.xpub_magic,
                private: coin.xprv_magic,
            },
            pubKeyHash: coin.address_type,
            scriptHash: coin.address_type_p2sh,
            forkId: coin.fork_id,
            wif: 0,
        };
        bitcoinNetworks.push({
            type: 'bitcoin',
            blockchainLink: coin.blockchain_link,
            blocktime: Math.round(coin.blocktime_seconds / 60),
            cashAddrPrefix: coin.cashaddr_prefix,
            label: coin.coin_label,
            name: coin.coin_name,
            shortcut,
            curveName: coin.curve_name,
            defaultFees: coin.default_fee_b,
            dustLimit: coin.dust_limit,
            forceBip143: coin.force_bip143,
            hashGenesisBlock: coin.hash_genesis_block,
            maxAddressLength: coin.max_address_length,
            maxFeeSatoshiKb: coin.maxfee_kb,
            minAddressLength: coin.min_address_length,
            minFeeSatoshiKb: coin.minfee_kb,
            segwit: coin.segwit,
            slip44: coin.slip44,
            support: coin.support,
            xPubMagic: coin.xpub_magic,
            xPubMagicSegwitNative: coin.xpub_magic_segwit_native,
            xPubMagicSegwit: coin.xpub_magic_segwit_p2sh,
            taproot: coin.taproot,
            network,
            isBitcoin,
            maxFee: Math.round(coin.maxfee_kb / 1000),
            minFee: Math.round(coin.minfee_kb / 1000),
            blocks: Math.round(coin.blocktime_seconds / 60),
            decimals: coin.decimals,
        });
    });
};
const parseEthereumNetworksJson = (json) => {
    Object.keys(json).forEach(key => {
        const network = json[key];
        ethereumNetworks.push({
            type: 'ethereum',
            blockchainLink: network.blockchain_link,
            blocktime: -1,
            chain: network.chain,
            chainId: network.chain_id,
            defaultFees: [
                {
                    label: 'normal',
                    feePerUnit: '5000000000',
                    feeLimit: '21000',
                },
            ],
            minFee: 1,
            maxFee: 10000,
            label: network.name,
            name: network.name,
            shortcut: network.shortcut,
            rskip60: network.rskip60,
            slip44: network.slip44,
            support: network.support,
            network: undefined,
            decimals: 16,
        });
    });
};
const parseMiscNetworksJSON = (json, type) => {
    Object.keys(json).forEach(key => {
        const network = json[key];
        let minFee = -1;
        let maxFee = -1;
        let defaultFees = { Normal: -1 };
        const shortcut = network.shortcut.toLowerCase();
        if (shortcut === 'xrp' || shortcut === 'txrp') {
            minFee = 10;
            maxFee = 10000;
            defaultFees = { Normal: 12 };
        }
        if (shortcut === 'ada' || shortcut === 'tada') {
            minFee = 44;
            maxFee = 16384 * 44 + 155381;
            defaultFees = { Normal: 44 };
        }
        miscNetworks.push({
            type: type || 'misc',
            blockchainLink: network.blockchain_link,
            blocktime: -1,
            curve: network.curve,
            defaultFees,
            minFee,
            maxFee,
            label: network.name,
            name: network.name,
            shortcut: network.shortcut,
            slip44: network.slip44,
            support: network.support,
            network: undefined,
            decimals: network.decimals,
        });
    });
};
const parseCoinsJson = (json) => {
    Object.keys(json).forEach(key => {
        switch (key) {
            case 'bitcoin':
                return parseBitcoinNetworksJson(json[key]);
            case 'eth':
                return parseEthereumNetworksJson(json[key]);
            case 'misc':
                return parseMiscNetworksJSON(json[key]);
            case 'nem':
                return parseMiscNetworksJSON(json[key], 'nem');
        }
    });
};
exports.parseCoinsJson = parseCoinsJson;
const getUniqueNetworks = (networks) => networks.reduce((result, info) => {
    if (!info || result.find(i => i.shortcut === info.shortcut))
        return result;
    return result.concat(info);
}, []);
exports.getUniqueNetworks = getUniqueNetworks;
const getAllNetworks = () => [...bitcoinNetworks, ...ethereumNetworks, ...miscNetworks];
exports.getAllNetworks = getAllNetworks;
//# sourceMappingURL=coinInfo.js.map