"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getReleases = exports.getRelease = exports.getFirmwareStatus = exports.getInfo = exports.parseFirmware = void 0;
const utils_1 = require("@trezor/utils");
const firmwareUtils_1 = require("../utils/firmwareUtils");
const versionUtils_1 = require("../utils/versionUtils");
const releases = {};
releases[1] = [];
releases[2] = [];
const parseFirmware = (json, model) => {
    Object.keys(json).forEach(key => {
        const release = json[key];
        releases[model].push({
            ...release,
        });
    });
};
exports.parseFirmware = parseFirmware;
const getChangelog = (releases, features) => {
    if (features.bootloader_mode) {
        if (features.firmware_present && features.major_version === 1) {
            return null;
        }
        if (features.firmware_present && features.major_version === 2) {
            return releases.filter(r => utils_1.versionUtils.isNewer(r.version, [
                features.fw_major,
                features.fw_minor,
                features.fw_patch,
            ]));
        }
        return releases;
    }
    return releases.filter(r => utils_1.versionUtils.isNewer(r.version, [
        features.major_version,
        features.minor_version,
        features.patch_version,
    ]));
};
const isNewer = (release, features) => {
    if (features.major_version === 1 && features.bootloader_mode) {
        return null;
    }
    return utils_1.versionUtils.isNewer(release.version, [
        features.major_version,
        features.minor_version,
        features.patch_version,
    ]);
};
const isRequired = (changelog) => {
    if (!changelog || !changelog.length)
        return null;
    return changelog.some(item => item.required);
};
const isEqual = (release, latest) => utils_1.versionUtils.isEqual(release.version, latest.version);
const getT1BootloaderVersion = (releases, features) => {
    const { bootloader_mode, major_version, minor_version, patch_version } = features;
    const versionArray = [major_version, minor_version, patch_version];
    if (bootloader_mode) {
        return versionArray;
    }
    const release = releases.find(({ version }) => utils_1.versionUtils.isEqual(version, versionArray));
    return (release === null || release === void 0 ? void 0 : release.bootloader_version) || [1, 0, 0];
};
const getIntermediaryVersion = (releases, features, offerLatest) => {
    if (features.major_version !== 1 || offerLatest) {
        return;
    }
    const bootloaderVersion = getT1BootloaderVersion(releases, features);
    if (utils_1.versionUtils.isNewerOrEqual(bootloaderVersion, [1, 12, 0])) {
        return 3;
    }
    if (utils_1.versionUtils.isNewerOrEqual(bootloaderVersion, [1, 8, 0])) {
        return 2;
    }
    return 1;
};
const getSafeReleases = ({ features, releases }) => {
    const { bootloader_mode, major_version, minor_version, patch_version, fw_major, fw_minor, fw_patch, } = features;
    const firmwareVersion = [major_version, minor_version, patch_version];
    if (!(0, versionUtils_1.isVersionArray)(firmwareVersion)) {
        return [];
    }
    if (major_version === 2 && bootloader_mode) {
        const fwVersion = [fw_major, fw_minor, fw_patch];
        if ((0, versionUtils_1.isVersionArray)(fwVersion)) {
            return (0, firmwareUtils_1.filterSafeListByFirmware)(releases, fwVersion);
        }
        return (0, firmwareUtils_1.filterSafeListByBootloader)(releases, firmwareVersion);
    }
    if (major_version === 1 && bootloader_mode) {
        return (0, firmwareUtils_1.filterSafeListByBootloader)(releases, firmwareVersion);
    }
    return (0, firmwareUtils_1.filterSafeListByFirmware)(releases, firmwareVersion);
};
const getInfo = ({ features, releases }) => {
    if (!(0, firmwareUtils_1.isStrictFeatures)(features)) {
        throw new Error('Features of unexpected shape provided.');
    }
    if (!(0, firmwareUtils_1.isValidReleases)(releases)) {
        throw new Error(`Release object in unexpected shape.`);
    }
    const latest = releases[0];
    const releasesSafe = getSafeReleases({ features, releases });
    if (!releasesSafe.length) {
        return null;
    }
    const releasesParsed = features.major_version === 1 ? releases : releasesSafe;
    const changelog = getChangelog(releasesParsed, features);
    const release = releasesParsed[0];
    const intermediaryVersion = getIntermediaryVersion(releases, features, isEqual(releasesSafe[0], latest));
    return {
        changelog,
        release,
        isRequired: isRequired(changelog),
        isNewer: isNewer(latest, features),
        intermediaryVersion,
    };
};
exports.getInfo = getInfo;
const getFirmwareStatus = (features) => {
    if (features.firmware_present === false) {
        return 'none';
    }
    if (features.major_version === 1 && features.bootloader_mode) {
        return 'unknown';
    }
    const info = (0, exports.getInfo)({ features, releases: releases[features.major_version] });
    if (!info)
        return 'unknown';
    if (info.isRequired)
        return 'required';
    if (info.isNewer)
        return 'outdated';
    return 'valid';
};
exports.getFirmwareStatus = getFirmwareStatus;
const getRelease = (features) => (0, exports.getInfo)({ features, releases: releases[features.major_version] });
exports.getRelease = getRelease;
const getReleases = (model) => releases[model];
exports.getReleases = getReleases;
//# sourceMappingURL=firmwareInfo.js.map