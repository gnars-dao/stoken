var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("@chakra-ui/react"), require("react-dom"), require("react"), require("@emotion/react")) : typeof define === "function" && define.amd ? define(["exports", "@chakra-ui/react", "react-dom", "react", "@emotion/react"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.PioneerLib = {}, global2.Chakra, global2.ReactDOM, global2.React, global2.emotion));
})(this, function(exports2, react, require$$0$4, React$1, react$1) {
  var _a2;
  "use strict";
  function _interopNamespaceDefault(e) {
    const n2 = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
    if (e) {
      for (const k2 in e) {
        if (k2 !== "default") {
          const d = Object.getOwnPropertyDescriptor(e, k2);
          Object.defineProperty(n2, k2, d.get ? d : {
            enumerable: true,
            get: () => e[k2]
          });
        }
      }
    }
    n2.default = e;
    return Object.freeze(n2);
  }
  const React__namespace = /* @__PURE__ */ _interopNamespaceDefault(React$1);
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  function getAugmentedNamespace(n2) {
    if (n2.__esModule)
      return n2;
    var f2 = n2.default;
    if (typeof f2 == "function") {
      var a = function a2() {
        if (this instanceof a2) {
          return Reflect.construct(f2, arguments, this.constructor);
        }
        return f2.apply(this, arguments);
      };
      a.prototype = f2.prototype;
    } else
      a = {};
    Object.defineProperty(a, "__esModule", { value: true });
    Object.keys(n2).forEach(function(k2) {
      var d = Object.getOwnPropertyDescriptor(n2, k2);
      Object.defineProperty(a, k2, d.get ? d : {
        enumerable: true,
        get: function() {
          return n2[k2];
        }
      });
    });
    return a;
  }
  var jsxRuntime = { exports: {} };
  var reactJsxRuntime_production_min = {};
  /**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var f = React$1, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m$1 = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
  function q(c, a, g) {
    var b, d = {}, e = null, h = null;
    void 0 !== g && (e = "" + g);
    void 0 !== a.key && (e = "" + a.key);
    void 0 !== a.ref && (h = a.ref);
    for (b in a)
      m$1.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
    if (c && c.defaultProps)
      for (b in a = c.defaultProps, a)
        void 0 === d[b] && (d[b] = a[b]);
    return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
  }
  reactJsxRuntime_production_min.Fragment = l;
  reactJsxRuntime_production_min.jsx = q;
  reactJsxRuntime_production_min.jsxs = q;
  {
    jsxRuntime.exports = reactJsxRuntime_production_min;
  }
  var jsxRuntimeExports = jsxRuntime.exports;
  var client = {};
  var m = require$$0$4;
  {
    client.createRoot = m.createRoot;
    client.hydrateRoot = m.hydrateRoot;
  }
  const latin = "";
  var domain;
  function EventHandlers() {
  }
  EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
  function EventEmitter() {
    EventEmitter.init.call(this);
  }
  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.usingDomains = false;
  EventEmitter.prototype.domain = void 0;
  EventEmitter.prototype._events = void 0;
  EventEmitter.prototype._maxListeners = void 0;
  EventEmitter.defaultMaxListeners = 10;
  EventEmitter.init = function() {
    this.domain = null;
    if (EventEmitter.usingDomains) {
      if (domain.active)
        ;
    }
    if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || void 0;
  };
  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n2) {
    if (typeof n2 !== "number" || n2 < 0 || isNaN(n2))
      throw new TypeError('"n" argument must be a positive number');
    this._maxListeners = n2;
    return this;
  };
  function $getMaxListeners(that) {
    if (that._maxListeners === void 0)
      return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }
  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return $getMaxListeners(this);
  };
  function emitNone(handler, isFn, self2) {
    if (isFn)
      handler.call(self2);
    else {
      var len2 = handler.length;
      var listeners = arrayClone(handler, len2);
      for (var i2 = 0; i2 < len2; ++i2)
        listeners[i2].call(self2);
    }
  }
  function emitOne(handler, isFn, self2, arg1) {
    if (isFn)
      handler.call(self2, arg1);
    else {
      var len2 = handler.length;
      var listeners = arrayClone(handler, len2);
      for (var i2 = 0; i2 < len2; ++i2)
        listeners[i2].call(self2, arg1);
    }
  }
  function emitTwo(handler, isFn, self2, arg1, arg2) {
    if (isFn)
      handler.call(self2, arg1, arg2);
    else {
      var len2 = handler.length;
      var listeners = arrayClone(handler, len2);
      for (var i2 = 0; i2 < len2; ++i2)
        listeners[i2].call(self2, arg1, arg2);
    }
  }
  function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
    if (isFn)
      handler.call(self2, arg1, arg2, arg3);
    else {
      var len2 = handler.length;
      var listeners = arrayClone(handler, len2);
      for (var i2 = 0; i2 < len2; ++i2)
        listeners[i2].call(self2, arg1, arg2, arg3);
    }
  }
  function emitMany(handler, isFn, self2, args) {
    if (isFn)
      handler.apply(self2, args);
    else {
      var len2 = handler.length;
      var listeners = arrayClone(handler, len2);
      for (var i2 = 0; i2 < len2; ++i2)
        listeners[i2].apply(self2, args);
    }
  }
  EventEmitter.prototype.emit = function emit(type2) {
    var er, handler, len2, args, i2, events2, domain2;
    var doError = type2 === "error";
    events2 = this._events;
    if (events2)
      doError = doError && events2.error == null;
    else if (!doError)
      return false;
    domain2 = this.domain;
    if (doError) {
      er = arguments[1];
      if (domain2) {
        if (!er)
          er = new Error('Uncaught, unspecified "error" event');
        er.domainEmitter = this;
        er.domain = domain2;
        er.domainThrown = false;
        domain2.emit("error", er);
      } else if (er instanceof Error) {
        throw er;
      } else {
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
        err.context = er;
        throw err;
      }
      return false;
    }
    handler = events2[type2];
    if (!handler)
      return false;
    var isFn = typeof handler === "function";
    len2 = arguments.length;
    switch (len2) {
      case 1:
        emitNone(handler, isFn, this);
        break;
      case 2:
        emitOne(handler, isFn, this, arguments[1]);
        break;
      case 3:
        emitTwo(handler, isFn, this, arguments[1], arguments[2]);
        break;
      case 4:
        emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
        break;
      default:
        args = new Array(len2 - 1);
        for (i2 = 1; i2 < len2; i2++)
          args[i2 - 1] = arguments[i2];
        emitMany(handler, isFn, this, args);
    }
    return true;
  };
  function _addListener(target, type2, listener, prepend) {
    var m2;
    var events2;
    var existing;
    if (typeof listener !== "function")
      throw new TypeError('"listener" argument must be a function');
    events2 = target._events;
    if (!events2) {
      events2 = target._events = new EventHandlers();
      target._eventsCount = 0;
    } else {
      if (events2.newListener) {
        target.emit(
          "newListener",
          type2,
          listener.listener ? listener.listener : listener
        );
        events2 = target._events;
      }
      existing = events2[type2];
    }
    if (!existing) {
      existing = events2[type2] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === "function") {
        existing = events2[type2] = prepend ? [listener, existing] : [existing, listener];
      } else {
        if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
      }
      if (!existing.warned) {
        m2 = $getMaxListeners(target);
        if (m2 && m2 > 0 && existing.length > m2) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type2 + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type2;
          w.count = existing.length;
          emitWarning(w);
        }
      }
    }
    return target;
  }
  function emitWarning(e) {
    typeof console.warn === "function" ? console.warn(e) : console.log(e);
  }
  EventEmitter.prototype.addListener = function addListener(type2, listener) {
    return _addListener(this, type2, listener, false);
  };
  EventEmitter.prototype.on = EventEmitter.prototype.addListener;
  EventEmitter.prototype.prependListener = function prependListener(type2, listener) {
    return _addListener(this, type2, listener, true);
  };
  function _onceWrap(target, type2, listener) {
    var fired = false;
    function g() {
      target.removeListener(type2, g);
      if (!fired) {
        fired = true;
        listener.apply(target, arguments);
      }
    }
    g.listener = listener;
    return g;
  }
  EventEmitter.prototype.once = function once(type2, listener) {
    if (typeof listener !== "function")
      throw new TypeError('"listener" argument must be a function');
    this.on(type2, _onceWrap(this, type2, listener));
    return this;
  };
  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
    if (typeof listener !== "function")
      throw new TypeError('"listener" argument must be a function');
    this.prependListener(type2, _onceWrap(this, type2, listener));
    return this;
  };
  EventEmitter.prototype.removeListener = function removeListener(type2, listener) {
    var list2, events2, position2, i2, originalListener;
    if (typeof listener !== "function")
      throw new TypeError('"listener" argument must be a function');
    events2 = this._events;
    if (!events2)
      return this;
    list2 = events2[type2];
    if (!list2)
      return this;
    if (list2 === listener || list2.listener && list2.listener === listener) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers();
      else {
        delete events2[type2];
        if (events2.removeListener)
          this.emit("removeListener", type2, list2.listener || listener);
      }
    } else if (typeof list2 !== "function") {
      position2 = -1;
      for (i2 = list2.length; i2-- > 0; ) {
        if (list2[i2] === listener || list2[i2].listener && list2[i2].listener === listener) {
          originalListener = list2[i2].listener;
          position2 = i2;
          break;
        }
      }
      if (position2 < 0)
        return this;
      if (list2.length === 1) {
        list2[0] = void 0;
        if (--this._eventsCount === 0) {
          this._events = new EventHandlers();
          return this;
        } else {
          delete events2[type2];
        }
      } else {
        spliceOne(list2, position2);
      }
      if (events2.removeListener)
        this.emit("removeListener", type2, originalListener || listener);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(type2) {
    var listeners, events2;
    events2 = this._events;
    if (!events2)
      return this;
    if (!events2.removeListener) {
      if (arguments.length === 0) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      } else if (events2[type2]) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else
          delete events2[type2];
      }
      return this;
    }
    if (arguments.length === 0) {
      var keys2 = Object.keys(events2);
      for (var i2 = 0, key; i2 < keys2.length; ++i2) {
        key = keys2[i2];
        if (key === "removeListener")
          continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners("removeListener");
      this._events = new EventHandlers();
      this._eventsCount = 0;
      return this;
    }
    listeners = events2[type2];
    if (typeof listeners === "function") {
      this.removeListener(type2, listeners);
    } else if (listeners) {
      do {
        this.removeListener(type2, listeners[listeners.length - 1]);
      } while (listeners[0]);
    }
    return this;
  };
  EventEmitter.prototype.listeners = function listeners(type2) {
    var evlistener;
    var ret;
    var events2 = this._events;
    if (!events2)
      ret = [];
    else {
      evlistener = events2[type2];
      if (!evlistener)
        ret = [];
      else if (typeof evlistener === "function")
        ret = [evlistener.listener || evlistener];
      else
        ret = unwrapListeners(evlistener);
    }
    return ret;
  };
  EventEmitter.listenerCount = function(emitter, type2) {
    if (typeof emitter.listenerCount === "function") {
      return emitter.listenerCount(type2);
    } else {
      return listenerCount.call(emitter, type2);
    }
  };
  EventEmitter.prototype.listenerCount = listenerCount;
  function listenerCount(type2) {
    var events2 = this._events;
    if (events2) {
      var evlistener = events2[type2];
      if (typeof evlistener === "function") {
        return 1;
      } else if (evlistener) {
        return evlistener.length;
      }
    }
    return 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  };
  function spliceOne(list2, index2) {
    for (var i2 = index2, k2 = i2 + 1, n2 = list2.length; k2 < n2; i2 += 1, k2 += 1)
      list2[i2] = list2[k2];
    list2.pop();
  }
  function arrayClone(arr, i2) {
    var copy2 = new Array(i2);
    while (i2--)
      copy2[i2] = arr[i2];
    return copy2;
  }
  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i2 = 0; i2 < ret.length; ++i2) {
      ret[i2] = arr[i2].listener || arr[i2];
    }
    return ret;
  }
  const events = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    EventEmitter,
    default: EventEmitter
  }, Symbol.toStringTag, { value: "Module" }));
  let getRandomValues;
  const rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }
  const byteToHex = [];
  for (let i2 = 0; i2 < 256; ++i2) {
    byteToHex.push((i2 + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
  }
  const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
  const native = {
    randomUUID
  };
  function v4(options, buf, offset) {
    if (native.randomUUID && !buf && !options) {
      return native.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i2 = 0; i2 < 16; ++i2) {
        buf[offset + i2] = rnds[i2];
      }
      return buf;
    }
    return unsafeStringify(rnds);
  }
  var lib$9 = {};
  var browser$1 = { exports: {} };
  var process$1 = browser$1.exports = {};
  var cachedSetTimeout;
  var cachedClearTimeout;
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      if (typeof setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      } else {
        cachedSetTimeout = defaultSetTimout;
      }
    } catch (e) {
      cachedSetTimeout = defaultSetTimout;
    }
    try {
      if (typeof clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      } else {
        cachedClearTimeout = defaultClearTimeout;
      }
    } catch (e) {
      cachedClearTimeout = defaultClearTimeout;
    }
  })();
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e2) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e2) {
        return cachedClearTimeout.call(this, marker);
      }
    }
  }
  var queue$1 = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue$1 = currentQueue.concat(queue$1);
    } else {
      queueIndex = -1;
    }
    if (queue$1.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout2 = runTimeout(cleanUpNextTick);
    draining = true;
    var len2 = queue$1.length;
    while (len2) {
      currentQueue = queue$1;
      queue$1 = [];
      while (++queueIndex < len2) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len2 = queue$1.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout2);
  }
  process$1.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        args[i2 - 1] = arguments[i2];
      }
    }
    queue$1.push(new Item(fun, args));
    if (queue$1.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process$1.title = "browser";
  process$1.browser = true;
  process$1.env = {};
  process$1.argv = [];
  process$1.version = "";
  process$1.versions = {};
  function noop$5() {
  }
  process$1.on = noop$5;
  process$1.addListener = noop$5;
  process$1.once = noop$5;
  process$1.off = noop$5;
  process$1.removeListener = noop$5;
  process$1.removeAllListeners = noop$5;
  process$1.emit = noop$5;
  process$1.prependListener = noop$5;
  process$1.prependOnceListener = noop$5;
  process$1.listeners = function(name) {
    return [];
  };
  process$1.binding = function(name) {
    throw new Error("process.binding is not supported");
  };
  process$1.cwd = function() {
    return "/";
  };
  process$1.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
  };
  process$1.umask = function() {
    return 0;
  };
  var browserExports$1 = browser$1.exports;
  const process$2 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports$1);
  var lib$8 = { exports: {} };
  (function(module2, exports3) {
    var __spreadArray = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
          if (ar || !(i2 in from2)) {
            if (!ar)
              ar = Array.prototype.slice.call(from2, 0, i2);
            ar[i2] = from2[i2];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from2));
    };
    var LOG_LEVELS = {
      TEST: { val: 0, label: "TEST", color: "color: cyan" },
      EMERG: { val: 0, label: "EMERG", color: "color: magenta" },
      ALERT: { val: 1, label: "ALERT", color: "color: magenta" },
      CRIT: { val: 2, label: "CRIT", color: "color: red" },
      ERROR: { val: 3, label: "ERROR", color: "color: red" },
      WARN: { val: 4, label: "WARN", color: "color: orange" },
      NOTICE: { val: 5, label: "NOTICE", color: "color: yellow" },
      VERBOSE: { val: 6, label: "VERBOSE", color: "color: cyan" },
      INFO: { val: 6, label: "INFO", color: "color: cyan" },
      DEBUG: { val: 7, label: "DEBUG", color: "color: green" },
      DEBUGV: { val: 8, label: "DEBUG", color: "color: green" },
      DEBUGVV: { val: 9, label: "DEBUG", color: "color: green" }
    };
    var DEFAULT_LOG_LEVEL = typeof process$2 !== "undefined" ? process$2.env["DEFAULT_LOG_LEVEL"] || "INFO" : "INFO";
    function _extractContext(stack, depth) {
      try {
        var arr = stack.split("\n");
        var chunks = arr[depth].split("/");
        var business = chunks[chunks.length - 1];
        var matches = business.match(/^([^:]+):(\d+):(\d+)/i) || "";
        var filename = matches[1];
        var line = matches[2];
        var pos = matches[3];
        return { filename, line, pos };
      } catch (ex) {
        return { filename: "unknown" };
      }
    }
    function _getContextString() {
      var stack = new Error().stack || "";
      var _a3 = _extractContext(stack, 3), filename = _a3.filename, line = _a3.line, pos = _a3.pos;
      return "[".concat(filename, ":").concat(line, ":").concat(pos, "]");
    }
    var Logger2 = (
      /** @class */
      function() {
        function Logger3() {
          var stack = new Error().stack || "";
          var ctx = _extractContext(stack, 3);
          this._tag = ctx.filename || "";
          for (var lvl in LOG_LEVELS) {
            this[lvl.toLowerCase()] = this._log.bind(this, lvl);
          }
          this._setLogLevel();
        }
        Logger3.prototype._setLogLevel = function() {
          var tag = this._tag.split(".")[0];
          tag = tag.toUpperCase().replace("-", "_");
          var level = typeof process$2 !== "undefined" ? process$2.env["LOG_LEVEL_" + tag] || null : null;
          if (level && LOG_LEVELS[level] !== void 0) {
            this._level = LOG_LEVELS[level].val;
          } else {
            this._level = LOG_LEVELS[DEFAULT_LOG_LEVEL].val;
          }
        };
        Logger3.prototype._log = function(level) {
          var args = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
          }
          if (this._level >= LOG_LEVELS[level].val) {
            var dt = (/* @__PURE__ */ new Date()).toISOString().replace("T", " ");
            var ctx = _getContextString();
            var label = LOG_LEVELS[level].label;
            var color2 = LOG_LEVELS[level].color;
            var message = void 0;
            if (typeof process$2 !== "undefined" && process$2.env["STRUCTURED_LOGGING"]) {
              message = {};
              var tag = args[0];
              var param = args[1];
              var value2 = args[2];
              if (typeof args === "object") {
                message.loggerdog = true;
                message.label = label;
                message.param = param;
                message.value = value2;
                message.ctx = ctx;
                message.dt = dt;
                message.tag = tag.toString();
                message.raw = args.toString();
              } else {
                message.raw = args;
              }
              console.log("%c " + dt, color2, label, ctx, message);
            } else {
              console.log.apply(console, __spreadArray(["%c " + dt, color2, label, ctx], args, false));
            }
          }
        };
        return Logger3;
      }()
    );
    var getLogger = function() {
      return new Logger2();
    };
    exports3.default = getLogger;
    module2.exports = getLogger;
  })(lib$8, lib$8.exports);
  var libExports = lib$8.exports;
  var lib$7 = {};
  var paths$2 = {};
  Object.defineProperty(paths$2, "__esModule", { value: true });
  paths$2.getPaths = paths$2.blockchains = void 0;
  libExports();
  paths$2.blockchains = ["bitcoin", "ethereum", "thorchain", "bitcoincash", "litecoin", "binance", "cosmos", "dogecoin", "osmosis"];
  function getPaths$1(blockchains2, isTestnet) {
    var output2 = [];
    if (!blockchains2)
      blockchains2 = [];
    if (blockchains2.indexOf("bitcoin") >= 0) {
      if (isTestnet) {
        output2.push({
          note: "Bitcoin testnet account 0",
          blockchain: "bitcoin",
          testnet: true,
          symbol: "BTC",
          network: "BTC",
          script_type: "p2wpkh",
          available_scripts_types: ["p2pkh", "p2sh", "p2wpkh", "p2sh-p2wpkh"],
          type: "zpub",
          addressNList: [2147483648 + 84, 2147483648 + 1, 2147483648 + 0],
          addressNListMaster: [2147483648 + 84, 2147483648 + 1, 2147483648 + 0, 0, 0],
          curve: "secp256k1",
          showDisplay: false
          // Not supported by TrezorConnect or Ledger, but KeepKey should do it
        });
      } else {
        output2.push({
          note: "Bitcoin account 0",
          blockchain: "bitcoin",
          symbol: "BTC",
          network: "BTC",
          script_type: "p2pkh",
          available_scripts_types: ["p2pkh", "p2sh", "p2wpkh", "p2sh-p2wpkh"],
          type: "xpub",
          addressNList: [2147483648 + 44, 2147483648 + 0, 2147483648 + 0],
          addressNListMaster: [2147483648 + 44, 2147483648 + 0, 2147483648 + 0, 0, 0],
          curve: "secp256k1",
          showDisplay: false
          // Not supported by TrezorConnect or Ledger, but KeepKey should do it
        });
        output2.push({
          note: "Bitcoin account Native Segwit (Bech32)",
          blockchain: "bitcoin",
          symbol: "BTC",
          network: "BTC",
          script_type: "p2wpkh",
          available_scripts_types: ["p2pkh", "p2sh", "p2wpkh", "p2sh-p2wpkh"],
          type: "zpub",
          addressNList: [2147483648 + 84, 2147483648 + 0, 2147483648 + 0],
          addressNListMaster: [2147483648 + 84, 2147483648 + 0, 2147483648 + 0, 0, 0],
          curve: "secp256k1",
          showDisplay: false
          // Not supported by TrezorConnect or Ledger, but KeepKey should do it
        });
      }
    }
    if (blockchains2.indexOf("ethereum") >= 0) {
      var entry = {
        note: " ETH primary (default)",
        symbol: "ETH",
        network: "ETH",
        script_type: "ethereum",
        available_scripts_types: ["ethereum"],
        type: "address",
        addressNList: [2147483648 + 44, 2147483648 + 60, 2147483648 + 0],
        addressNListMaster: [2147483648 + 44, 2147483648 + 60, 2147483648 + 0, 0, 0],
        curve: "secp256k1",
        showDisplay: false,
        blockchain: "ethereum"
      };
      if (isTestnet)
        entry.testnet = true;
      output2.push(entry);
    }
    if (blockchains2.indexOf("avalanche") >= 0) {
      var entry = {
        note: " AVAX primary (default)",
        symbol: "AVAX",
        network: "AVAX",
        script_type: "avalanche",
        available_scripts_types: ["avalanche"],
        type: "address",
        addressNList: [2147483648 + 44, 2147483648 + 60, 2147483648 + 0],
        addressNListMaster: [2147483648 + 44, 2147483648 + 60, 2147483648 + 0, 0, 0],
        curve: "secp256k1",
        showDisplay: false,
        blockchain: "avalanche"
      };
      if (isTestnet)
        entry.testnet = true;
      output2.push(entry);
    }
    if (blockchains2.indexOf("thorchain") >= 0) {
      var entry = {
        note: " Default RUNE path ",
        type: "address",
        addressNList: [2147483648 + 44, 2147483648 + 931, 2147483648 + 0, 0, 0],
        addressNListMaster: [2147483648 + 44, 2147483648 + 931, 2147483648 + 0, 0, 0],
        curve: "secp256k1",
        script_type: "thorchain",
        showDisplay: false,
        blockchain: "thorchain",
        symbol: "RUNE",
        network: "RUNE"
      };
      if (isTestnet) {
        entry.testnet = true;
      }
      output2.push(entry);
    }
    if (blockchains2.indexOf("secret") >= 0) {
      var entry = {
        note: " Default Secret path ",
        type: "address",
        addressNList: [2147483648 + 44, 2147483648 + 931, 2147483648 + 0, 0, 0],
        addressNListMaster: [2147483648 + 44, 2147483648 + 931, 2147483648 + 0, 0, 0],
        curve: "secp256k1",
        script_type: "thorchain",
        showDisplay: false,
        blockchain: "thorchain",
        symbol: "RUNE",
        network: "RUNE"
      };
      if (isTestnet) {
        entry.testnet = true;
      }
      output2.push(entry);
    }
    if (blockchains2.indexOf("cosmos") >= 0) {
      var entry = {
        note: " Default ATOM path ",
        type: "address",
        script_type: "cosmos",
        available_scripts_types: ["cosmos"],
        addressNList: [2147483648 + 44, 2147483648 + 118, 2147483648 + 0, 0, 0],
        addressNListMaster: [2147483648 + 44, 2147483648 + 118, 2147483648 + 0, 0, 0],
        curve: "secp256k1",
        showDisplay: false,
        blockchain: "cosmos",
        symbol: "ATOM",
        network: "ATOM"
      };
      if (isTestnet) {
        entry.testnet = true;
      }
      output2.push(entry);
    }
    if (blockchains2.indexOf("osmosis") >= 0) {
      var entry = {
        note: " Default OSMO path ",
        type: "address",
        script_type: "bech32",
        available_scripts_types: ["bech32"],
        addressNList: [2147483648 + 44, 2147483648 + 118, 2147483648 + 0, 0, 0],
        addressNListMaster: [2147483648 + 44, 2147483648 + 118, 2147483648 + 0, 0, 0],
        curve: "secp256k1",
        showDisplay: false,
        blockchain: "osmosis",
        symbol: "OSMO",
        network: "OSMO"
      };
      if (isTestnet) {
        entry.testnet = true;
      }
      output2.push(entry);
    }
    if (blockchains2.indexOf("binance") >= 0) {
      var entry = {
        note: "Binance default path",
        type: "address",
        script_type: "binance",
        available_scripts_types: ["binance"],
        addressNList: [2147483648 + 44, 2147483648 + 714, 2147483648 + 0, 0, 0],
        addressNListMaster: [2147483648 + 44, 2147483648 + 714, 2147483648 + 0, 0, 0],
        curve: "secp256k1",
        showDisplay: false,
        blockchain: "binance",
        symbol: "BNB",
        network: "BNB"
      };
      if (isTestnet) {
        entry.testnet = true;
      }
      output2.push(entry);
    }
    if (blockchains2.indexOf("bitcoincash") >= 0) {
      var entry = {
        note: "Bitcoin Cash Default path",
        type: "xpub",
        script_type: "p2pkh",
        available_scripts_types: ["p2pkh"],
        addressNList: [2147483648 + 44, 2147483648 + 145, 2147483648 + 0],
        addressNListMaster: [2147483648 + 44, 2147483648 + 145, 2147483648 + 0, 0, 0],
        curve: "secp256k1",
        showDisplay: false,
        blockchain: "bitcoincash",
        symbol: "BCH",
        network: "BCH"
      };
      if (isTestnet) {
        entry.testnet = true;
      }
      output2.push(entry);
    }
    if (blockchains2.indexOf("litecoin") >= 0) {
      var entry = {
        note: "Litecoin Default path",
        type: "xpub",
        script_type: "p2pkh",
        available_scripts_types: ["p2pkh"],
        addressNList: [2147483648 + 44, 2147483648 + 2, 2147483648 + 0],
        addressNListMaster: [2147483648 + 44, 2147483648 + 2, 2147483648 + 0, 0, 0],
        curve: "secp256k1",
        showDisplay: false,
        blockchain: "litecoin",
        symbol: "LTC",
        network: "LTC"
      };
      if (isTestnet) {
        entry.testnet = true;
      }
      output2.push(entry);
      output2.push({
        note: "Litecoin account Native Segwit (Bech32)",
        blockchain: "litecoin",
        symbol: "LTC",
        network: "LTC",
        script_type: "p2wpkh",
        available_scripts_types: ["p2pkh", "p2sh", "p2wpkh", "p2sh-p2wpkh"],
        type: "zpub",
        addressNList: [2147483648 + 84, 2147483648 + 2, 2147483648 + 0],
        addressNListMaster: [2147483648 + 84, 2147483648 + 2, 2147483648 + 0, 0, 0],
        curve: "secp256k1",
        showDisplay: false
        // Not supported by TrezorConnect or Ledger, but KeepKey should do it
      });
      output2.push(entry);
    }
    if (blockchains2.indexOf("dogecoin") >= 0) {
      var entry = {
        note: "Dogecoin Default path",
        type: "xpub",
        script_type: "p2pkh",
        available_scripts_types: ["p2pkh"],
        addressNList: [2147483648 + 44, 2147483648 + 3, 2147483648 + 0],
        addressNListMaster: [2147483648 + 44, 2147483648 + 3, 2147483648 + 0, 0, 0],
        curve: "secp256k1",
        showDisplay: false,
        blockchain: "dogecoin",
        symbol: "DOGE",
        network: "DOGE"
      };
      if (isTestnet) {
        entry.testnet = true;
      }
      output2.push(entry);
    }
    if (blockchains2.indexOf("dash") >= 0) {
      var entry = {
        note: "Default dash path",
        type: "xpub",
        coin: "Dash",
        symbol: "DASH",
        network: "DASH",
        blockchain: "dash",
        script_type: "p2pkh",
        available_scripts_types: ["p2pkh"],
        addressNList: [2147483648 + 44, 2147483648 + 5, 2147483648 + 0],
        addressNListMaster: [2147483648 + 44, 2147483648 + 5, 2147483648 + 0, 0, 0],
        curve: "secp256k1",
        showDisplay: false
        // Not supported by TrezorConnect or Ledger, but KeepKey should do it
      };
      output2.push(entry);
    }
    return output2;
  }
  paths$2.getPaths = getPaths$1;
  var buffer$1 = {};
  var base64Js = {};
  base64Js.byteLength = byteLength$1;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;
  var lookup$1 = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i$2 = 0, len = code.length; i$2 < len; ++i$2) {
    lookup$1[i$2] = code[i$2];
    revLookup[code.charCodeAt(i$2)] = i$2;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength$1(b64) {
    var lens2 = getLens(b64);
    var validLen = lens2[0];
    var placeHoldersLen = lens2[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens2 = getLens(b64);
    var validLen = lens2[0];
    var placeHoldersLen = lens2[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i2;
    for (i2 = 0; i2 < len2; i2 += 4) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup$1[num >> 18 & 63] + lookup$1[num >> 12 & 63] + lookup$1[num >> 6 & 63] + lookup$1[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output2 = [];
    for (var i2 = start; i2 < end; i2 += 3) {
      tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
      output2.push(tripletToBase64(tmp));
    }
    return output2.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts2 = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
      parts2.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts2.push(
        lookup$1[tmp >> 2] + lookup$1[tmp << 4 & 63] + "=="
      );
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts2.push(
        lookup$1[tmp >> 10] + lookup$1[tmp >> 4 & 63] + lookup$1[tmp << 2 & 63] + "="
      );
    }
    return parts2.join("");
  }
  var ieee754 = {};
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e, m2;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i2 = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer2[offset + i2];
    i2 += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
    }
    m2 = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i2], i2 += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m2 ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m2 = m2 + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m2 * Math.pow(2, e - mLen);
  };
  ieee754.write = function(buffer2, value2, offset, isLE, mLen, nBytes) {
    var e, m2, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i2 = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
    value2 = Math.abs(value2);
    if (isNaN(value2) || value2 === Infinity) {
      m2 = isNaN(value2) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value2) / Math.LN2);
      if (value2 * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value2 += rt / c;
      } else {
        value2 += rt * Math.pow(2, 1 - eBias);
      }
      if (value2 * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m2 = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m2 = (value2 * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i2] = m2 & 255, i2 += d, m2 /= 256, mLen -= 8) {
    }
    e = e << mLen | m2;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
    }
    buffer2[offset + i2 - d] |= s * 128;
  };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  (function(exports3) {
    var base64 = base64Js;
    var ieee754$1 = ieee754;
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports3.Buffer = Buffer2;
    exports3.SlowBuffer = SlowBuffer;
    exports3.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports3.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length2) {
      if (length2 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length2);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length2) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from2(arg, encodingOrOffset, length2);
    }
    Buffer2.poolSize = 8192;
    function from2(value2, encodingOrOffset, length2) {
      if (typeof value2 === "string") {
        return fromString(value2, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value2)) {
        return fromArrayView(value2);
      }
      if (value2 == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
        );
      }
      if (isInstance(value2, ArrayBuffer) || value2 && isInstance(value2.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value2, encodingOrOffset, length2);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value2, SharedArrayBuffer) || value2 && isInstance(value2.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value2, encodingOrOffset, length2);
      }
      if (typeof value2 === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value2.valueOf && value2.valueOf();
      if (valueOf != null && valueOf !== value2) {
        return Buffer2.from(valueOf, encodingOrOffset, length2);
      }
      var b = fromObject(value2);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value2[Symbol.toPrimitive] === "function") {
        return Buffer2.from(
          value2[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length2
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
      );
    }
    Buffer2.from = function(value2, encodingOrOffset, length2) {
      return from2(value2, encodingOrOffset, length2);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length2 = byteLength2(string, encoding) | 0;
      var buf = createBuffer(length2);
      var actual = buf.write(string, encoding);
      if (actual !== length2) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length2 = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length2);
      for (var i2 = 0; i2 < length2; i2 += 1) {
        buf[i2] = array[i2] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy2 = new Uint8Array(arrayView);
        return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length2) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length2 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length2 === void 0) {
        buf = new Uint8Array(array);
      } else if (length2 === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length2);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        var len2 = checked(obj.length) | 0;
        var buf = createBuffer(len2);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len2);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length2) {
      if (length2 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length2 | 0;
    }
    function SlowBuffer(length2) {
      if (+length2 != length2) {
        length2 = 0;
      }
      return Buffer2.alloc(+length2);
    }
    Buffer2.isBuffer = function isBuffer2(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare2(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      var x2 = a.length;
      var y = b.length;
      for (var i2 = 0, len2 = Math.min(x2, y); i2 < len2; ++i2) {
        if (a[i2] !== b[i2]) {
          x2 = a[i2];
          y = b[i2];
          break;
        }
      }
      if (x2 < y)
        return -1;
      if (y < x2)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat2(list2, length2) {
      if (!Array.isArray(list2)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list2.length === 0) {
        return Buffer2.alloc(0);
      }
      var i2;
      if (length2 === void 0) {
        length2 = 0;
        for (i2 = 0; i2 < list2.length; ++i2) {
          length2 += list2[i2].length;
        }
      }
      var buffer2 = Buffer2.allocUnsafe(length2);
      var pos = 0;
      for (i2 = 0; i2 < list2.length; ++i2) {
        var buf = list2[i2];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            Buffer2.from(buf).copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength2(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      var len2 = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len2 === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len2;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len2 * 2;
          case "hex":
            return len2 >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength2;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n2, m2) {
      var i2 = b[n2];
      b[n2] = b[m2];
      b[m2] = i2;
    }
    Buffer2.prototype.swap16 = function swap16() {
      var len2 = this.length;
      if (len2 % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i2 = 0; i2 < len2; i2 += 2) {
        swap(this, i2, i2 + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len2 = this.length;
      if (len2 % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i2 = 0; i2 < len2; i2 += 4) {
        swap(this, i2, i2 + 3);
        swap(this, i2 + 1, i2 + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len2 = this.length;
      if (len2 % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i2 = 0; i2 < len2; i2 += 8) {
        swap(this, i2, i2 + 7);
        swap(this, i2 + 1, i2 + 6);
        swap(this, i2 + 2, i2 + 5);
        swap(this, i2 + 3, i2 + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString2() {
      var length2 = this.length;
      if (length2 === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length2);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals2(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect2() {
      var str2 = "";
      var max2 = exports3.INSPECT_MAX_BYTES;
      str2 = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max2)
        str2 += " ... ";
      return "<Buffer " + str2 + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x2 = thisEnd - thisStart;
      var y = end - start;
      var len2 = Math.min(x2, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i2 = 0; i2 < len2; ++i2) {
        if (thisCopy[i2] !== targetCopy[i2]) {
          x2 = thisCopy[i2];
          y = targetCopy[i2];
          break;
        }
      }
      if (x2 < y)
        return -1;
      if (y < x2)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i3) {
        if (indexSize === 1) {
          return buf[i3];
        } else {
          return buf.readUInt16BE(i3 * indexSize);
        }
      }
      var i2;
      if (dir) {
        var foundIndex = -1;
        for (i2 = byteOffset; i2 < arrLength; i2++) {
          if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i2;
            if (i2 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i2 -= i2 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i2 = byteOffset; i2 >= 0; i2--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i2 + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i2;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes2(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length2) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length2) {
        length2 = remaining;
      } else {
        length2 = Number(length2);
        if (length2 > remaining) {
          length2 = remaining;
        }
      }
      var strLen = string.length;
      if (length2 > strLen / 2) {
        length2 = strLen / 2;
      }
      for (var i2 = 0; i2 < length2; ++i2) {
        var parsed = parseInt(string.substr(i2 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i2;
        buf[offset + i2] = parsed;
      }
      return i2;
    }
    function utf8Write(buf, string, offset, length2) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length2);
    }
    function asciiWrite(buf, string, offset, length2) {
      return blitBuffer(asciiToBytes(string), buf, offset, length2);
    }
    function base64Write(buf, string, offset, length2) {
      return blitBuffer(base64ToBytes(string), buf, offset, length2);
    }
    function ucs2Write(buf, string, offset, length2) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length2);
    }
    Buffer2.prototype.write = function write(string, offset, length2, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length2 = this.length;
        offset = 0;
      } else if (length2 === void 0 && typeof offset === "string") {
        encoding = offset;
        length2 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length2)) {
          length2 = length2 >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length2;
          length2 = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length2 === void 0 || length2 > remaining)
        length2 = remaining;
      if (string.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length2);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length2);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length2);
          case "base64":
            return base64Write(this, string, offset, length2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length2);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i2 = start;
      while (i2 < end) {
        var firstByte = buf[i2];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i2 + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i2 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              fourthByte = buf[i2 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i2 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len2 = codePoints.length;
      if (len2 <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i2 = 0;
      while (i2 < len2) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len2 = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len2)
        end = len2;
      var out = "";
      for (var i2 = start; i2 < end; ++i2) {
        out += hexSliceLookupTable[buf[i2]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes2 = buf.slice(start, end);
      var res = "";
      for (var i2 = 0; i2 < bytes2.length - 1; i2 += 2) {
        res += String.fromCharCode(bytes2[i2] + bytes2[i2 + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice2(start, end) {
      var len2 = this.length;
      start = ~~start;
      end = end === void 0 ? len2 : ~~end;
      if (start < 0) {
        start += len2;
        if (start < 0)
          start = 0;
      } else if (start > len2) {
        start = len2;
      }
      if (end < 0) {
        end += len2;
        if (end < 0)
          end = 0;
      } else if (end > len2) {
        end = len2;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length2) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length2)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var val = this[offset];
      var mul = 1;
      var i2 = 0;
      while (++i2 < byteLength3 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength3, this.length);
      }
      var val = this[offset + --byteLength3];
      var mul = 1;
      while (byteLength3 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength3] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var val = this[offset];
      var mul = 1;
      var i2 = 0;
      while (++i2 < byteLength3 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength3, this.length);
      var i2 = byteLength3;
      var mul = 1;
      var val = this[offset + --i2];
      while (i2 > 0 && (mul *= 256)) {
        val += this[offset + --i2] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength3);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value2, offset, ext, max2, min2) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value2 > max2 || value2 < min2)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value2, offset, byteLength3, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value2, offset, byteLength3, maxBytes, 0);
      }
      var mul = 1;
      var i2 = 0;
      this[offset] = value2 & 255;
      while (++i2 < byteLength3 && (mul *= 256)) {
        this[offset + i2] = value2 / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value2, offset, byteLength3, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      byteLength3 = byteLength3 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
        checkInt(this, value2, offset, byteLength3, maxBytes, 0);
      }
      var i2 = byteLength3 - 1;
      var mul = 1;
      this[offset + i2] = value2 & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        this[offset + i2] = value2 / mul & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 1, 255, 0);
      this[offset] = value2 & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 65535, 0);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 65535, 0);
      this[offset] = value2 >>> 8;
      this[offset + 1] = value2 & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 4294967295, 0);
      this[offset + 3] = value2 >>> 24;
      this[offset + 2] = value2 >>> 16;
      this[offset + 1] = value2 >>> 8;
      this[offset] = value2 & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 4294967295, 0);
      this[offset] = value2 >>> 24;
      this[offset + 1] = value2 >>> 16;
      this[offset + 2] = value2 >>> 8;
      this[offset + 3] = value2 & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value2, offset, byteLength3, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value2, offset, byteLength3, limit - 1, -limit);
      }
      var i2 = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value2 & 255;
      while (++i2 < byteLength3 && (mul *= 256)) {
        if (value2 < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value2 / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value2, offset, byteLength3, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength3 - 1);
        checkInt(this, value2, offset, byteLength3, limit - 1, -limit);
      }
      var i2 = byteLength3 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i2] = value2 & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        if (value2 < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value2 / mul >> 0) - sub & 255;
      }
      return offset + byteLength3;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 1, 127, -128);
      if (value2 < 0)
        value2 = 255 + value2 + 1;
      this[offset] = value2 & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 32767, -32768);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 2, 32767, -32768);
      this[offset] = value2 >>> 8;
      this[offset + 1] = value2 & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 2147483647, -2147483648);
      this[offset] = value2 & 255;
      this[offset + 1] = value2 >>> 8;
      this[offset + 2] = value2 >>> 16;
      this[offset + 3] = value2 >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value2, offset, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset, 4, 2147483647, -2147483648);
      if (value2 < 0)
        value2 = 4294967295 + value2 + 1;
      this[offset] = value2 >>> 24;
      this[offset + 1] = value2 >>> 16;
      this[offset + 2] = value2 >>> 8;
      this[offset + 3] = value2 & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value2, offset, ext, max2, min2) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value2, offset, littleEndian, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value2, offset, 4);
      }
      ieee754$1.write(buf, value2, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value2, offset, noAssert) {
      return writeFloat(this, value2, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value2, offset, noAssert) {
      return writeFloat(this, value2, offset, false, noAssert);
    };
    function writeDouble(buf, value2, offset, littleEndian, noAssert) {
      value2 = +value2;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value2, offset, 8);
      }
      ieee754$1.write(buf, value2, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value2, offset, noAssert) {
      return writeDouble(this, value2, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value2, offset, noAssert) {
      return writeDouble(this, value2, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy2(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len2 = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len2;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code2 = val.charCodeAt(0);
          if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
            val = code2;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i2;
      if (typeof val === "number") {
        for (i2 = start; i2 < end; ++i2) {
          this[i2] = val;
        }
      } else {
        var bytes2 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        var len2 = bytes2.length;
        if (len2 === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i2 = 0; i2 < end - start; ++i2) {
          this[i2 + start] = bytes2[i2 % len2];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str2) {
      str2 = str2.split("=")[0];
      str2 = str2.trim().replace(INVALID_BASE64_RE, "");
      if (str2.length < 2)
        return "";
      while (str2.length % 4 !== 0) {
        str2 = str2 + "=";
      }
      return str2;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length2 = string.length;
      var leadSurrogate = null;
      var bytes2 = [];
      for (var i2 = 0; i2 < length2; ++i2) {
        codePoint = string.charCodeAt(i2);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes2.push(239, 191, 189);
              continue;
            } else if (i2 + 1 === length2) {
              if ((units -= 3) > -1)
                bytes2.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes2.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes2.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes2.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes2.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes2;
    }
    function asciiToBytes(str2) {
      var byteArray = [];
      for (var i2 = 0; i2 < str2.length; ++i2) {
        byteArray.push(str2.charCodeAt(i2) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str2, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i2 = 0; i2 < str2.length; ++i2) {
        if ((units -= 2) < 0)
          break;
        c = str2.charCodeAt(i2);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str2) {
      return base64.toByteArray(base64clean(str2));
    }
    function blitBuffer(src2, dst, offset, length2) {
      for (var i2 = 0; i2 < length2; ++i2) {
        if (i2 + offset >= dst.length || i2 >= src2.length)
          break;
        dst[i2 + offset] = src2[i2];
      }
      return i2;
    }
    function isInstance(obj, type2) {
      return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet2 = "0123456789abcdef";
      var table = new Array(256);
      for (var i2 = 0; i2 < 16; ++i2) {
        var i16 = i2 * 16;
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet2[i2] + alphabet2[j];
        }
      }
      return table;
    }();
  })(buffer$1);
  var coins = {};
  var ripemd160 = { exports: {} };
  function commonjsRequire(path2) {
    throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }
  var core$3 = { exports: {} };
  const __viteBrowserExternal = {};
  const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: __viteBrowserExternal
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$0$3 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
  var hasRequiredCore;
  function requireCore() {
    if (hasRequiredCore)
      return core$3.exports;
    hasRequiredCore = 1;
    (function(module2, exports3) {
      (function(root2, factory2) {
        {
          module2.exports = factory2();
        }
      })(commonjsGlobal, function() {
        var CryptoJS = CryptoJS || function(Math2, undefined$12) {
          var crypto2;
          if (typeof window !== "undefined" && window.crypto) {
            crypto2 = window.crypto;
          }
          if (typeof self !== "undefined" && self.crypto) {
            crypto2 = self.crypto;
          }
          if (typeof globalThis !== "undefined" && globalThis.crypto) {
            crypto2 = globalThis.crypto;
          }
          if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
            crypto2 = window.msCrypto;
          }
          if (!crypto2 && typeof commonjsGlobal !== "undefined" && commonjsGlobal.crypto) {
            crypto2 = commonjsGlobal.crypto;
          }
          if (!crypto2 && typeof commonjsRequire === "function") {
            try {
              crypto2 = require$$0$3;
            } catch (err) {
            }
          }
          var cryptoSecureRandomInt = function() {
            if (crypto2) {
              if (typeof crypto2.getRandomValues === "function") {
                try {
                  return crypto2.getRandomValues(new Uint32Array(1))[0];
                } catch (err) {
                }
              }
              if (typeof crypto2.randomBytes === "function") {
                try {
                  return crypto2.randomBytes(4).readInt32LE();
                } catch (err) {
                }
              }
            }
            throw new Error("Native crypto module could not be used to get secure random number.");
          };
          var create2 = Object.create || function() {
            function F2() {
            }
            return function(obj) {
              var subtype;
              F2.prototype = obj;
              subtype = new F2();
              F2.prototype = null;
              return subtype;
            };
          }();
          var C = {};
          var C_lib = C.lib = {};
          var Base = C_lib.Base = function() {
            return {
              /**
               * Creates a new object that inherits from this object.
               *
               * @param {Object} overrides Properties to copy into the new object.
               *
               * @return {Object} The new object.
               *
               * @static
               *
               * @example
               *
               *     var MyType = CryptoJS.lib.Base.extend({
               *         field: 'value',
               *
               *         method: function () {
               *         }
               *     });
               */
              extend: function(overrides) {
                var subtype = create2(this);
                if (overrides) {
                  subtype.mixIn(overrides);
                }
                if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                  subtype.init = function() {
                    subtype.$super.init.apply(this, arguments);
                  };
                }
                subtype.init.prototype = subtype;
                subtype.$super = this;
                return subtype;
              },
              /**
               * Extends this object and runs the init method.
               * Arguments to create() will be passed to init().
               *
               * @return {Object} The new object.
               *
               * @static
               *
               * @example
               *
               *     var instance = MyType.create();
               */
              create: function() {
                var instance = this.extend();
                instance.init.apply(instance, arguments);
                return instance;
              },
              /**
               * Initializes a newly created object.
               * Override this method to add some logic when your objects are created.
               *
               * @example
               *
               *     var MyType = CryptoJS.lib.Base.extend({
               *         init: function () {
               *             // ...
               *         }
               *     });
               */
              init: function() {
              },
              /**
               * Copies properties into this object.
               *
               * @param {Object} properties The properties to mix in.
               *
               * @example
               *
               *     MyType.mixIn({
               *         field: 'value'
               *     });
               */
              mixIn: function(properties2) {
                for (var propertyName in properties2) {
                  if (properties2.hasOwnProperty(propertyName)) {
                    this[propertyName] = properties2[propertyName];
                  }
                }
                if (properties2.hasOwnProperty("toString")) {
                  this.toString = properties2.toString;
                }
              },
              /**
               * Creates a copy of this object.
               *
               * @return {Object} The clone.
               *
               * @example
               *
               *     var clone = instance.clone();
               */
              clone: function() {
                return this.init.prototype.extend(this);
              }
            };
          }();
          var WordArray = C_lib.WordArray = Base.extend({
            /**
             * Initializes a newly created word array.
             *
             * @param {Array} words (Optional) An array of 32-bit words.
             * @param {number} sigBytes (Optional) The number of significant bytes in the words.
             *
             * @example
             *
             *     var wordArray = CryptoJS.lib.WordArray.create();
             *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
             *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
             */
            init: function(words, sigBytes) {
              words = this.words = words || [];
              if (sigBytes != undefined$12) {
                this.sigBytes = sigBytes;
              } else {
                this.sigBytes = words.length * 4;
              }
            },
            /**
             * Converts this word array to a string.
             *
             * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
             *
             * @return {string} The stringified word array.
             *
             * @example
             *
             *     var string = wordArray + '';
             *     var string = wordArray.toString();
             *     var string = wordArray.toString(CryptoJS.enc.Utf8);
             */
            toString: function(encoder) {
              return (encoder || Hex).stringify(this);
            },
            /**
             * Concatenates a word array to this word array.
             *
             * @param {WordArray} wordArray The word array to append.
             *
             * @return {WordArray} This word array.
             *
             * @example
             *
             *     wordArray1.concat(wordArray2);
             */
            concat: function(wordArray) {
              var thisWords = this.words;
              var thatWords = wordArray.words;
              var thisSigBytes = this.sigBytes;
              var thatSigBytes = wordArray.sigBytes;
              this.clamp();
              if (thisSigBytes % 4) {
                for (var i2 = 0; i2 < thatSigBytes; i2++) {
                  var thatByte = thatWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                  thisWords[thisSigBytes + i2 >>> 2] |= thatByte << 24 - (thisSigBytes + i2) % 4 * 8;
                }
              } else {
                for (var j = 0; j < thatSigBytes; j += 4) {
                  thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
                }
              }
              this.sigBytes += thatSigBytes;
              return this;
            },
            /**
             * Removes insignificant bits.
             *
             * @example
             *
             *     wordArray.clamp();
             */
            clamp: function() {
              var words = this.words;
              var sigBytes = this.sigBytes;
              words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
              words.length = Math2.ceil(sigBytes / 4);
            },
            /**
             * Creates a copy of this word array.
             *
             * @return {WordArray} The clone.
             *
             * @example
             *
             *     var clone = wordArray.clone();
             */
            clone: function() {
              var clone = Base.clone.call(this);
              clone.words = this.words.slice(0);
              return clone;
            },
            /**
             * Creates a word array filled with random bytes.
             *
             * @param {number} nBytes The number of random bytes to generate.
             *
             * @return {WordArray} The random word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.lib.WordArray.random(16);
             */
            random: function(nBytes) {
              var words = [];
              for (var i2 = 0; i2 < nBytes; i2 += 4) {
                words.push(cryptoSecureRandomInt());
              }
              return new WordArray.init(words, nBytes);
            }
          });
          var C_enc = C.enc = {};
          var Hex = C_enc.Hex = {
            /**
             * Converts a word array to a hex string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The hex string.
             *
             * @static
             *
             * @example
             *
             *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var hexChars = [];
              for (var i2 = 0; i2 < sigBytes; i2++) {
                var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                hexChars.push((bite >>> 4).toString(16));
                hexChars.push((bite & 15).toString(16));
              }
              return hexChars.join("");
            },
            /**
             * Converts a hex string to a word array.
             *
             * @param {string} hexStr The hex string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
             */
            parse: function(hexStr) {
              var hexStrLength = hexStr.length;
              var words = [];
              for (var i2 = 0; i2 < hexStrLength; i2 += 2) {
                words[i2 >>> 3] |= parseInt(hexStr.substr(i2, 2), 16) << 24 - i2 % 8 * 4;
              }
              return new WordArray.init(words, hexStrLength / 2);
            }
          };
          var Latin1 = C_enc.Latin1 = {
            /**
             * Converts a word array to a Latin1 string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The Latin1 string.
             *
             * @static
             *
             * @example
             *
             *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var latin1Chars = [];
              for (var i2 = 0; i2 < sigBytes; i2++) {
                var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                latin1Chars.push(String.fromCharCode(bite));
              }
              return latin1Chars.join("");
            },
            /**
             * Converts a Latin1 string to a word array.
             *
             * @param {string} latin1Str The Latin1 string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
             */
            parse: function(latin1Str) {
              var latin1StrLength = latin1Str.length;
              var words = [];
              for (var i2 = 0; i2 < latin1StrLength; i2++) {
                words[i2 >>> 2] |= (latin1Str.charCodeAt(i2) & 255) << 24 - i2 % 4 * 8;
              }
              return new WordArray.init(words, latin1StrLength);
            }
          };
          var Utf8 = C_enc.Utf8 = {
            /**
             * Converts a word array to a UTF-8 string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The UTF-8 string.
             *
             * @static
             *
             * @example
             *
             *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
             */
            stringify: function(wordArray) {
              try {
                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
              } catch (e) {
                throw new Error("Malformed UTF-8 data");
              }
            },
            /**
             * Converts a UTF-8 string to a word array.
             *
             * @param {string} utf8Str The UTF-8 string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
             */
            parse: function(utf8Str) {
              return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
            }
          };
          var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
            /**
             * Resets this block algorithm's data buffer to its initial state.
             *
             * @example
             *
             *     bufferedBlockAlgorithm.reset();
             */
            reset: function() {
              this._data = new WordArray.init();
              this._nDataBytes = 0;
            },
            /**
             * Adds new data to this block algorithm's buffer.
             *
             * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
             *
             * @example
             *
             *     bufferedBlockAlgorithm._append('data');
             *     bufferedBlockAlgorithm._append(wordArray);
             */
            _append: function(data2) {
              if (typeof data2 == "string") {
                data2 = Utf8.parse(data2);
              }
              this._data.concat(data2);
              this._nDataBytes += data2.sigBytes;
            },
            /**
             * Processes available data blocks.
             *
             * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
             *
             * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
             *
             * @return {WordArray} The processed data.
             *
             * @example
             *
             *     var processedData = bufferedBlockAlgorithm._process();
             *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
             */
            _process: function(doFlush) {
              var processedWords;
              var data2 = this._data;
              var dataWords = data2.words;
              var dataSigBytes = data2.sigBytes;
              var blockSize = this.blockSize;
              var blockSizeBytes = blockSize * 4;
              var nBlocksReady = dataSigBytes / blockSizeBytes;
              if (doFlush) {
                nBlocksReady = Math2.ceil(nBlocksReady);
              } else {
                nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
              }
              var nWordsReady = nBlocksReady * blockSize;
              var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
              if (nWordsReady) {
                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                  this._doProcessBlock(dataWords, offset);
                }
                processedWords = dataWords.splice(0, nWordsReady);
                data2.sigBytes -= nBytesReady;
              }
              return new WordArray.init(processedWords, nBytesReady);
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = bufferedBlockAlgorithm.clone();
             */
            clone: function() {
              var clone = Base.clone.call(this);
              clone._data = this._data.clone();
              return clone;
            },
            _minBufferSize: 0
          });
          C_lib.Hasher = BufferedBlockAlgorithm.extend({
            /**
             * Configuration options.
             */
            cfg: Base.extend(),
            /**
             * Initializes a newly created hasher.
             *
             * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
             *
             * @example
             *
             *     var hasher = CryptoJS.algo.SHA256.create();
             */
            init: function(cfg) {
              this.cfg = this.cfg.extend(cfg);
              this.reset();
            },
            /**
             * Resets this hasher to its initial state.
             *
             * @example
             *
             *     hasher.reset();
             */
            reset: function() {
              BufferedBlockAlgorithm.reset.call(this);
              this._doReset();
            },
            /**
             * Updates this hasher with a message.
             *
             * @param {WordArray|string} messageUpdate The message to append.
             *
             * @return {Hasher} This hasher.
             *
             * @example
             *
             *     hasher.update('message');
             *     hasher.update(wordArray);
             */
            update: function(messageUpdate) {
              this._append(messageUpdate);
              this._process();
              return this;
            },
            /**
             * Finalizes the hash computation.
             * Note that the finalize operation is effectively a destructive, read-once operation.
             *
             * @param {WordArray|string} messageUpdate (Optional) A final message update.
             *
             * @return {WordArray} The hash.
             *
             * @example
             *
             *     var hash = hasher.finalize();
             *     var hash = hasher.finalize('message');
             *     var hash = hasher.finalize(wordArray);
             */
            finalize: function(messageUpdate) {
              if (messageUpdate) {
                this._append(messageUpdate);
              }
              var hash2 = this._doFinalize();
              return hash2;
            },
            blockSize: 512 / 32,
            /**
             * Creates a shortcut function to a hasher's object interface.
             *
             * @param {Hasher} hasher The hasher to create a helper for.
             *
             * @return {Function} The shortcut function.
             *
             * @static
             *
             * @example
             *
             *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
             */
            _createHelper: function(hasher) {
              return function(message, cfg) {
                return new hasher.init(cfg).finalize(message);
              };
            },
            /**
             * Creates a shortcut function to the HMAC's object interface.
             *
             * @param {Hasher} hasher The hasher to use in this HMAC helper.
             *
             * @return {Function} The shortcut function.
             *
             * @static
             *
             * @example
             *
             *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
             */
            _createHmacHelper: function(hasher) {
              return function(message, key) {
                return new C_algo.HMAC.init(hasher, key).finalize(message);
              };
            }
          });
          var C_algo = C.algo = {};
          return C;
        }(Math);
        return CryptoJS;
      });
    })(core$3);
    return core$3.exports;
  }
  (function(module2, exports3) {
    (function(root2, factory2) {
      {
        module2.exports = factory2(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      /** @preserve
      			(c) 2012 by Cdric Mesnil. All rights reserved.
      
      			Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
      
      			    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
      			    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
      
      			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      			*/
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i2 = 0; i2 < 16; i2++) {
              var offset_i = offset + i2;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var hl = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl = _sl.words;
            var sr = _sr.words;
            var al, bl, cl, dl, el;
            var ar, br, cr, dr, er;
            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er = el = H[4];
            var t2;
            for (var i2 = 0; i2 < 80; i2 += 1) {
              t2 = al + M[offset + zl[i2]] | 0;
              if (i2 < 16) {
                t2 += f1(bl, cl, dl) + hl[0];
              } else if (i2 < 32) {
                t2 += f2(bl, cl, dl) + hl[1];
              } else if (i2 < 48) {
                t2 += f3(bl, cl, dl) + hl[2];
              } else if (i2 < 64) {
                t2 += f4(bl, cl, dl) + hl[3];
              } else {
                t2 += f5(bl, cl, dl) + hl[4];
              }
              t2 = t2 | 0;
              t2 = rotl(t2, sl[i2]);
              t2 = t2 + el | 0;
              al = el;
              el = dl;
              dl = rotl(cl, 10);
              cl = bl;
              bl = t2;
              t2 = ar + M[offset + zr[i2]] | 0;
              if (i2 < 16) {
                t2 += f5(br, cr, dr) + hr[0];
              } else if (i2 < 32) {
                t2 += f4(br, cr, dr) + hr[1];
              } else if (i2 < 48) {
                t2 += f3(br, cr, dr) + hr[2];
              } else if (i2 < 64) {
                t2 += f2(br, cr, dr) + hr[3];
              } else {
                t2 += f1(br, cr, dr) + hr[4];
              }
              t2 = t2 | 0;
              t2 = rotl(t2, sr[i2]);
              t2 = t2 + er | 0;
              ar = er;
              er = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t2;
            }
            t2 = H[1] + cl + dr | 0;
            H[1] = H[2] + dl + er | 0;
            H[2] = H[3] + el + ar | 0;
            H[3] = H[4] + al + br | 0;
            H[4] = H[0] + bl + cr | 0;
            H[0] = t2;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data2.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash2 = this._hash;
            var H = hash2.words;
            for (var i2 = 0; i2 < 5; i2++) {
              var H_i = H[i2];
              H[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash2;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function f1(x2, y, z2) {
          return x2 ^ y ^ z2;
        }
        function f2(x2, y, z2) {
          return x2 & y | ~x2 & z2;
        }
        function f3(x2, y, z2) {
          return (x2 | ~y) ^ z2;
        }
        function f4(x2, y, z2) {
          return x2 & z2 | y & ~z2;
        }
        function f5(x2, y, z2) {
          return x2 ^ (y | ~z2);
        }
        function rotl(x2, n2) {
          return x2 << n2 | x2 >>> 32 - n2;
        }
        C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })();
      return CryptoJS.RIPEMD160;
    });
  })(ripemd160);
  var ripemd160Exports = ripemd160.exports;
  var cryptoJs = { exports: {} };
  var x64Core = { exports: {} };
  var hasRequiredX64Core;
  function requireX64Core() {
    if (hasRequiredX64Core)
      return x64Core.exports;
    hasRequiredX64Core = 1;
    (function(module2, exports3) {
      (function(root2, factory2) {
        {
          module2.exports = factory2(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        (function(undefined$12) {
          var C = CryptoJS;
          var C_lib = C.lib;
          var Base = C_lib.Base;
          var X32WordArray = C_lib.WordArray;
          var C_x64 = C.x64 = {};
          C_x64.Word = Base.extend({
            /**
             * Initializes a newly created 64-bit word.
             *
             * @param {number} high The high 32 bits.
             * @param {number} low The low 32 bits.
             *
             * @example
             *
             *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
             */
            init: function(high, low) {
              this.high = high;
              this.low = low;
            }
            /**
             * Bitwise NOTs this word.
             *
             * @return {X64Word} A new x64-Word object after negating.
             *
             * @example
             *
             *     var negated = x64Word.not();
             */
            // not: function () {
            // var high = ~this.high;
            // var low = ~this.low;
            // return X64Word.create(high, low);
            // },
            /**
             * Bitwise ANDs this word with the passed word.
             *
             * @param {X64Word} word The x64-Word to AND with this word.
             *
             * @return {X64Word} A new x64-Word object after ANDing.
             *
             * @example
             *
             *     var anded = x64Word.and(anotherX64Word);
             */
            // and: function (word) {
            // var high = this.high & word.high;
            // var low = this.low & word.low;
            // return X64Word.create(high, low);
            // },
            /**
             * Bitwise ORs this word with the passed word.
             *
             * @param {X64Word} word The x64-Word to OR with this word.
             *
             * @return {X64Word} A new x64-Word object after ORing.
             *
             * @example
             *
             *     var ored = x64Word.or(anotherX64Word);
             */
            // or: function (word) {
            // var high = this.high | word.high;
            // var low = this.low | word.low;
            // return X64Word.create(high, low);
            // },
            /**
             * Bitwise XORs this word with the passed word.
             *
             * @param {X64Word} word The x64-Word to XOR with this word.
             *
             * @return {X64Word} A new x64-Word object after XORing.
             *
             * @example
             *
             *     var xored = x64Word.xor(anotherX64Word);
             */
            // xor: function (word) {
            // var high = this.high ^ word.high;
            // var low = this.low ^ word.low;
            // return X64Word.create(high, low);
            // },
            /**
             * Shifts this word n bits to the left.
             *
             * @param {number} n The number of bits to shift.
             *
             * @return {X64Word} A new x64-Word object after shifting.
             *
             * @example
             *
             *     var shifted = x64Word.shiftL(25);
             */
            // shiftL: function (n) {
            // if (n < 32) {
            // var high = (this.high << n) | (this.low >>> (32 - n));
            // var low = this.low << n;
            // } else {
            // var high = this.low << (n - 32);
            // var low = 0;
            // }
            // return X64Word.create(high, low);
            // },
            /**
             * Shifts this word n bits to the right.
             *
             * @param {number} n The number of bits to shift.
             *
             * @return {X64Word} A new x64-Word object after shifting.
             *
             * @example
             *
             *     var shifted = x64Word.shiftR(7);
             */
            // shiftR: function (n) {
            // if (n < 32) {
            // var low = (this.low >>> n) | (this.high << (32 - n));
            // var high = this.high >>> n;
            // } else {
            // var low = this.high >>> (n - 32);
            // var high = 0;
            // }
            // return X64Word.create(high, low);
            // },
            /**
             * Rotates this word n bits to the left.
             *
             * @param {number} n The number of bits to rotate.
             *
             * @return {X64Word} A new x64-Word object after rotating.
             *
             * @example
             *
             *     var rotated = x64Word.rotL(25);
             */
            // rotL: function (n) {
            // return this.shiftL(n).or(this.shiftR(64 - n));
            // },
            /**
             * Rotates this word n bits to the right.
             *
             * @param {number} n The number of bits to rotate.
             *
             * @return {X64Word} A new x64-Word object after rotating.
             *
             * @example
             *
             *     var rotated = x64Word.rotR(7);
             */
            // rotR: function (n) {
            // return this.shiftR(n).or(this.shiftL(64 - n));
            // },
            /**
             * Adds this word with the passed word.
             *
             * @param {X64Word} word The x64-Word to add with this word.
             *
             * @return {X64Word} A new x64-Word object after adding.
             *
             * @example
             *
             *     var added = x64Word.add(anotherX64Word);
             */
            // add: function (word) {
            // var low = (this.low + word.low) | 0;
            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
            // var high = (this.high + word.high + carry) | 0;
            // return X64Word.create(high, low);
            // }
          });
          C_x64.WordArray = Base.extend({
            /**
             * Initializes a newly created word array.
             *
             * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
             * @param {number} sigBytes (Optional) The number of significant bytes in the words.
             *
             * @example
             *
             *     var wordArray = CryptoJS.x64.WordArray.create();
             *
             *     var wordArray = CryptoJS.x64.WordArray.create([
             *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
             *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
             *     ]);
             *
             *     var wordArray = CryptoJS.x64.WordArray.create([
             *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
             *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
             *     ], 10);
             */
            init: function(words, sigBytes) {
              words = this.words = words || [];
              if (sigBytes != undefined$12) {
                this.sigBytes = sigBytes;
              } else {
                this.sigBytes = words.length * 8;
              }
            },
            /**
             * Converts this 64-bit word array to a 32-bit word array.
             *
             * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
             *
             * @example
             *
             *     var x32WordArray = x64WordArray.toX32();
             */
            toX32: function() {
              var x64Words = this.words;
              var x64WordsLength = x64Words.length;
              var x32Words = [];
              for (var i2 = 0; i2 < x64WordsLength; i2++) {
                var x64Word = x64Words[i2];
                x32Words.push(x64Word.high);
                x32Words.push(x64Word.low);
              }
              return X32WordArray.create(x32Words, this.sigBytes);
            },
            /**
             * Creates a copy of this word array.
             *
             * @return {X64WordArray} The clone.
             *
             * @example
             *
             *     var clone = x64WordArray.clone();
             */
            clone: function() {
              var clone = Base.clone.call(this);
              var words = clone.words = this.words.slice(0);
              var wordsLength = words.length;
              for (var i2 = 0; i2 < wordsLength; i2++) {
                words[i2] = words[i2].clone();
              }
              return clone;
            }
          });
        })();
        return CryptoJS;
      });
    })(x64Core);
    return x64Core.exports;
  }
  var libTypedarrays = { exports: {} };
  var hasRequiredLibTypedarrays;
  function requireLibTypedarrays() {
    if (hasRequiredLibTypedarrays)
      return libTypedarrays.exports;
    hasRequiredLibTypedarrays = 1;
    (function(module2, exports3) {
      (function(root2, factory2) {
        {
          module2.exports = factory2(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        (function() {
          if (typeof ArrayBuffer != "function") {
            return;
          }
          var C = CryptoJS;
          var C_lib = C.lib;
          var WordArray = C_lib.WordArray;
          var superInit = WordArray.init;
          var subInit = WordArray.init = function(typedArray) {
            if (typedArray instanceof ArrayBuffer) {
              typedArray = new Uint8Array(typedArray);
            }
            if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
              typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
            }
            if (typedArray instanceof Uint8Array) {
              var typedArrayByteLength = typedArray.byteLength;
              var words = [];
              for (var i2 = 0; i2 < typedArrayByteLength; i2++) {
                words[i2 >>> 2] |= typedArray[i2] << 24 - i2 % 4 * 8;
              }
              superInit.call(this, words, typedArrayByteLength);
            } else {
              superInit.apply(this, arguments);
            }
          };
          subInit.prototype = WordArray;
        })();
        return CryptoJS.lib.WordArray;
      });
    })(libTypedarrays);
    return libTypedarrays.exports;
  }
  var encUtf16 = { exports: {} };
  var hasRequiredEncUtf16;
  function requireEncUtf16() {
    if (hasRequiredEncUtf16)
      return encUtf16.exports;
    hasRequiredEncUtf16 = 1;
    (function(module2, exports3) {
      (function(root2, factory2) {
        {
          module2.exports = factory2(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var WordArray = C_lib.WordArray;
          var C_enc = C.enc;
          C_enc.Utf16 = C_enc.Utf16BE = {
            /**
             * Converts a word array to a UTF-16 BE string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The UTF-16 BE string.
             *
             * @static
             *
             * @example
             *
             *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var utf16Chars = [];
              for (var i2 = 0; i2 < sigBytes; i2 += 2) {
                var codePoint = words[i2 >>> 2] >>> 16 - i2 % 4 * 8 & 65535;
                utf16Chars.push(String.fromCharCode(codePoint));
              }
              return utf16Chars.join("");
            },
            /**
             * Converts a UTF-16 BE string to a word array.
             *
             * @param {string} utf16Str The UTF-16 BE string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
             */
            parse: function(utf16Str) {
              var utf16StrLength = utf16Str.length;
              var words = [];
              for (var i2 = 0; i2 < utf16StrLength; i2++) {
                words[i2 >>> 1] |= utf16Str.charCodeAt(i2) << 16 - i2 % 2 * 16;
              }
              return WordArray.create(words, utf16StrLength * 2);
            }
          };
          C_enc.Utf16LE = {
            /**
             * Converts a word array to a UTF-16 LE string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The UTF-16 LE string.
             *
             * @static
             *
             * @example
             *
             *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var utf16Chars = [];
              for (var i2 = 0; i2 < sigBytes; i2 += 2) {
                var codePoint = swapEndian(words[i2 >>> 2] >>> 16 - i2 % 4 * 8 & 65535);
                utf16Chars.push(String.fromCharCode(codePoint));
              }
              return utf16Chars.join("");
            },
            /**
             * Converts a UTF-16 LE string to a word array.
             *
             * @param {string} utf16Str The UTF-16 LE string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
             */
            parse: function(utf16Str) {
              var utf16StrLength = utf16Str.length;
              var words = [];
              for (var i2 = 0; i2 < utf16StrLength; i2++) {
                words[i2 >>> 1] |= swapEndian(utf16Str.charCodeAt(i2) << 16 - i2 % 2 * 16);
              }
              return WordArray.create(words, utf16StrLength * 2);
            }
          };
          function swapEndian(word) {
            return word << 8 & 4278255360 | word >>> 8 & 16711935;
          }
        })();
        return CryptoJS.enc.Utf16;
      });
    })(encUtf16);
    return encUtf16.exports;
  }
  var encBase64 = { exports: {} };
  var hasRequiredEncBase64;
  function requireEncBase64() {
    if (hasRequiredEncBase64)
      return encBase64.exports;
    hasRequiredEncBase64 = 1;
    (function(module2, exports3) {
      (function(root2, factory2) {
        {
          module2.exports = factory2(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var WordArray = C_lib.WordArray;
          var C_enc = C.enc;
          C_enc.Base64 = {
            /**
             * Converts a word array to a Base64 string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The Base64 string.
             *
             * @static
             *
             * @example
             *
             *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var map2 = this._map;
              wordArray.clamp();
              var base64Chars = [];
              for (var i2 = 0; i2 < sigBytes; i2 += 3) {
                var byte1 = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                var byte2 = words[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
                var byte3 = words[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
                var triplet = byte1 << 16 | byte2 << 8 | byte3;
                for (var j = 0; j < 4 && i2 + j * 0.75 < sigBytes; j++) {
                  base64Chars.push(map2.charAt(triplet >>> 6 * (3 - j) & 63));
                }
              }
              var paddingChar = map2.charAt(64);
              if (paddingChar) {
                while (base64Chars.length % 4) {
                  base64Chars.push(paddingChar);
                }
              }
              return base64Chars.join("");
            },
            /**
             * Converts a Base64 string to a word array.
             *
             * @param {string} base64Str The Base64 string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
             */
            parse: function(base64Str) {
              var base64StrLength = base64Str.length;
              var map2 = this._map;
              var reverseMap = this._reverseMap;
              if (!reverseMap) {
                reverseMap = this._reverseMap = [];
                for (var j = 0; j < map2.length; j++) {
                  reverseMap[map2.charCodeAt(j)] = j;
                }
              }
              var paddingChar = map2.charAt(64);
              if (paddingChar) {
                var paddingIndex = base64Str.indexOf(paddingChar);
                if (paddingIndex !== -1) {
                  base64StrLength = paddingIndex;
                }
              }
              return parseLoop(base64Str, base64StrLength, reverseMap);
            },
            _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
          };
          function parseLoop(base64Str, base64StrLength, reverseMap) {
            var words = [];
            var nBytes = 0;
            for (var i2 = 0; i2 < base64StrLength; i2++) {
              if (i2 % 4) {
                var bits1 = reverseMap[base64Str.charCodeAt(i2 - 1)] << i2 % 4 * 2;
                var bits2 = reverseMap[base64Str.charCodeAt(i2)] >>> 6 - i2 % 4 * 2;
                var bitsCombined = bits1 | bits2;
                words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
                nBytes++;
              }
            }
            return WordArray.create(words, nBytes);
          }
        })();
        return CryptoJS.enc.Base64;
      });
    })(encBase64);
    return encBase64.exports;
  }
  var encBase64url = { exports: {} };
  var hasRequiredEncBase64url;
  function requireEncBase64url() {
    if (hasRequiredEncBase64url)
      return encBase64url.exports;
    hasRequiredEncBase64url = 1;
    (function(module2, exports3) {
      (function(root2, factory2) {
        {
          module2.exports = factory2(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var WordArray = C_lib.WordArray;
          var C_enc = C.enc;
          C_enc.Base64url = {
            /**
             * Converts a word array to a Base64url string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @param {boolean} urlSafe Whether to use url safe
             *
             * @return {string} The Base64url string.
             *
             * @static
             *
             * @example
             *
             *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
             */
            stringify: function(wordArray, urlSafe) {
              if (urlSafe === void 0) {
                urlSafe = true;
              }
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var map2 = urlSafe ? this._safe_map : this._map;
              wordArray.clamp();
              var base64Chars = [];
              for (var i2 = 0; i2 < sigBytes; i2 += 3) {
                var byte1 = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                var byte2 = words[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
                var byte3 = words[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
                var triplet = byte1 << 16 | byte2 << 8 | byte3;
                for (var j = 0; j < 4 && i2 + j * 0.75 < sigBytes; j++) {
                  base64Chars.push(map2.charAt(triplet >>> 6 * (3 - j) & 63));
                }
              }
              var paddingChar = map2.charAt(64);
              if (paddingChar) {
                while (base64Chars.length % 4) {
                  base64Chars.push(paddingChar);
                }
              }
              return base64Chars.join("");
            },
            /**
             * Converts a Base64url string to a word array.
             *
             * @param {string} base64Str The Base64url string.
             *
             * @param {boolean} urlSafe Whether to use url safe
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
             */
            parse: function(base64Str, urlSafe) {
              if (urlSafe === void 0) {
                urlSafe = true;
              }
              var base64StrLength = base64Str.length;
              var map2 = urlSafe ? this._safe_map : this._map;
              var reverseMap = this._reverseMap;
              if (!reverseMap) {
                reverseMap = this._reverseMap = [];
                for (var j = 0; j < map2.length; j++) {
                  reverseMap[map2.charCodeAt(j)] = j;
                }
              }
              var paddingChar = map2.charAt(64);
              if (paddingChar) {
                var paddingIndex = base64Str.indexOf(paddingChar);
                if (paddingIndex !== -1) {
                  base64StrLength = paddingIndex;
                }
              }
              return parseLoop(base64Str, base64StrLength, reverseMap);
            },
            _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
            _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
          };
          function parseLoop(base64Str, base64StrLength, reverseMap) {
            var words = [];
            var nBytes = 0;
            for (var i2 = 0; i2 < base64StrLength; i2++) {
              if (i2 % 4) {
                var bits1 = reverseMap[base64Str.charCodeAt(i2 - 1)] << i2 % 4 * 2;
                var bits2 = reverseMap[base64Str.charCodeAt(i2)] >>> 6 - i2 % 4 * 2;
                var bitsCombined = bits1 | bits2;
                words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
                nBytes++;
              }
            }
            return WordArray.create(words, nBytes);
          }
        })();
        return CryptoJS.enc.Base64url;
      });
    })(encBase64url);
    return encBase64url.exports;
  }
  var md5 = { exports: {} };
  var hasRequiredMd5;
  function requireMd5() {
    if (hasRequiredMd5)
      return md5.exports;
    hasRequiredMd5 = 1;
    (function(module2, exports3) {
      (function(root2, factory2) {
        {
          module2.exports = factory2(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        (function(Math2) {
          var C = CryptoJS;
          var C_lib = C.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_algo = C.algo;
          var T2 = [];
          (function() {
            for (var i2 = 0; i2 < 64; i2++) {
              T2[i2] = Math2.abs(Math2.sin(i2 + 1)) * 4294967296 | 0;
            }
          })();
          var MD5 = C_algo.MD5 = Hasher.extend({
            _doReset: function() {
              this._hash = new WordArray.init([
                1732584193,
                4023233417,
                2562383102,
                271733878
              ]);
            },
            _doProcessBlock: function(M, offset) {
              for (var i2 = 0; i2 < 16; i2++) {
                var offset_i = offset + i2;
                var M_offset_i = M[offset_i];
                M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
              }
              var H = this._hash.words;
              var M_offset_0 = M[offset + 0];
              var M_offset_1 = M[offset + 1];
              var M_offset_2 = M[offset + 2];
              var M_offset_3 = M[offset + 3];
              var M_offset_4 = M[offset + 4];
              var M_offset_5 = M[offset + 5];
              var M_offset_6 = M[offset + 6];
              var M_offset_7 = M[offset + 7];
              var M_offset_8 = M[offset + 8];
              var M_offset_9 = M[offset + 9];
              var M_offset_10 = M[offset + 10];
              var M_offset_11 = M[offset + 11];
              var M_offset_12 = M[offset + 12];
              var M_offset_13 = M[offset + 13];
              var M_offset_14 = M[offset + 14];
              var M_offset_15 = M[offset + 15];
              var a = H[0];
              var b = H[1];
              var c = H[2];
              var d = H[3];
              a = FF(a, b, c, d, M_offset_0, 7, T2[0]);
              d = FF(d, a, b, c, M_offset_1, 12, T2[1]);
              c = FF(c, d, a, b, M_offset_2, 17, T2[2]);
              b = FF(b, c, d, a, M_offset_3, 22, T2[3]);
              a = FF(a, b, c, d, M_offset_4, 7, T2[4]);
              d = FF(d, a, b, c, M_offset_5, 12, T2[5]);
              c = FF(c, d, a, b, M_offset_6, 17, T2[6]);
              b = FF(b, c, d, a, M_offset_7, 22, T2[7]);
              a = FF(a, b, c, d, M_offset_8, 7, T2[8]);
              d = FF(d, a, b, c, M_offset_9, 12, T2[9]);
              c = FF(c, d, a, b, M_offset_10, 17, T2[10]);
              b = FF(b, c, d, a, M_offset_11, 22, T2[11]);
              a = FF(a, b, c, d, M_offset_12, 7, T2[12]);
              d = FF(d, a, b, c, M_offset_13, 12, T2[13]);
              c = FF(c, d, a, b, M_offset_14, 17, T2[14]);
              b = FF(b, c, d, a, M_offset_15, 22, T2[15]);
              a = GG(a, b, c, d, M_offset_1, 5, T2[16]);
              d = GG(d, a, b, c, M_offset_6, 9, T2[17]);
              c = GG(c, d, a, b, M_offset_11, 14, T2[18]);
              b = GG(b, c, d, a, M_offset_0, 20, T2[19]);
              a = GG(a, b, c, d, M_offset_5, 5, T2[20]);
              d = GG(d, a, b, c, M_offset_10, 9, T2[21]);
              c = GG(c, d, a, b, M_offset_15, 14, T2[22]);
              b = GG(b, c, d, a, M_offset_4, 20, T2[23]);
              a = GG(a, b, c, d, M_offset_9, 5, T2[24]);
              d = GG(d, a, b, c, M_offset_14, 9, T2[25]);
              c = GG(c, d, a, b, M_offset_3, 14, T2[26]);
              b = GG(b, c, d, a, M_offset_8, 20, T2[27]);
              a = GG(a, b, c, d, M_offset_13, 5, T2[28]);
              d = GG(d, a, b, c, M_offset_2, 9, T2[29]);
              c = GG(c, d, a, b, M_offset_7, 14, T2[30]);
              b = GG(b, c, d, a, M_offset_12, 20, T2[31]);
              a = HH(a, b, c, d, M_offset_5, 4, T2[32]);
              d = HH(d, a, b, c, M_offset_8, 11, T2[33]);
              c = HH(c, d, a, b, M_offset_11, 16, T2[34]);
              b = HH(b, c, d, a, M_offset_14, 23, T2[35]);
              a = HH(a, b, c, d, M_offset_1, 4, T2[36]);
              d = HH(d, a, b, c, M_offset_4, 11, T2[37]);
              c = HH(c, d, a, b, M_offset_7, 16, T2[38]);
              b = HH(b, c, d, a, M_offset_10, 23, T2[39]);
              a = HH(a, b, c, d, M_offset_13, 4, T2[40]);
              d = HH(d, a, b, c, M_offset_0, 11, T2[41]);
              c = HH(c, d, a, b, M_offset_3, 16, T2[42]);
              b = HH(b, c, d, a, M_offset_6, 23, T2[43]);
              a = HH(a, b, c, d, M_offset_9, 4, T2[44]);
              d = HH(d, a, b, c, M_offset_12, 11, T2[45]);
              c = HH(c, d, a, b, M_offset_15, 16, T2[46]);
              b = HH(b, c, d, a, M_offset_2, 23, T2[47]);
              a = II(a, b, c, d, M_offset_0, 6, T2[48]);
              d = II(d, a, b, c, M_offset_7, 10, T2[49]);
              c = II(c, d, a, b, M_offset_14, 15, T2[50]);
              b = II(b, c, d, a, M_offset_5, 21, T2[51]);
              a = II(a, b, c, d, M_offset_12, 6, T2[52]);
              d = II(d, a, b, c, M_offset_3, 10, T2[53]);
              c = II(c, d, a, b, M_offset_10, 15, T2[54]);
              b = II(b, c, d, a, M_offset_1, 21, T2[55]);
              a = II(a, b, c, d, M_offset_8, 6, T2[56]);
              d = II(d, a, b, c, M_offset_15, 10, T2[57]);
              c = II(c, d, a, b, M_offset_6, 15, T2[58]);
              b = II(b, c, d, a, M_offset_13, 21, T2[59]);
              a = II(a, b, c, d, M_offset_4, 6, T2[60]);
              d = II(d, a, b, c, M_offset_11, 10, T2[61]);
              c = II(c, d, a, b, M_offset_2, 15, T2[62]);
              b = II(b, c, d, a, M_offset_9, 21, T2[63]);
              H[0] = H[0] + a | 0;
              H[1] = H[1] + b | 0;
              H[2] = H[2] + c | 0;
              H[3] = H[3] + d | 0;
            },
            _doFinalize: function() {
              var data2 = this._data;
              var dataWords = data2.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data2.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
              var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
              var nBitsTotalL = nBitsTotal;
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
              data2.sigBytes = (dataWords.length + 1) * 4;
              this._process();
              var hash2 = this._hash;
              var H = hash2.words;
              for (var i2 = 0; i2 < 4; i2++) {
                var H_i = H[i2];
                H[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
              }
              return hash2;
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
            }
          });
          function FF(a, b, c, d, x2, s, t2) {
            var n2 = a + (b & c | ~b & d) + x2 + t2;
            return (n2 << s | n2 >>> 32 - s) + b;
          }
          function GG(a, b, c, d, x2, s, t2) {
            var n2 = a + (b & d | c & ~d) + x2 + t2;
            return (n2 << s | n2 >>> 32 - s) + b;
          }
          function HH(a, b, c, d, x2, s, t2) {
            var n2 = a + (b ^ c ^ d) + x2 + t2;
            return (n2 << s | n2 >>> 32 - s) + b;
          }
          function II(a, b, c, d, x2, s, t2) {
            var n2 = a + (c ^ (b | ~d)) + x2 + t2;
            return (n2 << s | n2 >>> 32 - s) + b;
          }
          C.MD5 = Hasher._createHelper(MD5);
          C.HmacMD5 = Hasher._createHmacHelper(MD5);
        })(Math);
        return CryptoJS.MD5;
      });
    })(md5);
    return md5.exports;
  }
  var sha1 = { exports: {} };
  var hasRequiredSha1;
  function requireSha1() {
    if (hasRequiredSha1)
      return sha1.exports;
    hasRequiredSha1 = 1;
    (function(module2, exports3) {
      (function(root2, factory2) {
        {
          module2.exports = factory2(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_algo = C.algo;
          var W = [];
          var SHA1 = C_algo.SHA1 = Hasher.extend({
            _doReset: function() {
              this._hash = new WordArray.init([
                1732584193,
                4023233417,
                2562383102,
                271733878,
                3285377520
              ]);
            },
            _doProcessBlock: function(M, offset) {
              var H = this._hash.words;
              var a = H[0];
              var b = H[1];
              var c = H[2];
              var d = H[3];
              var e = H[4];
              for (var i2 = 0; i2 < 80; i2++) {
                if (i2 < 16) {
                  W[i2] = M[offset + i2] | 0;
                } else {
                  var n2 = W[i2 - 3] ^ W[i2 - 8] ^ W[i2 - 14] ^ W[i2 - 16];
                  W[i2] = n2 << 1 | n2 >>> 31;
                }
                var t2 = (a << 5 | a >>> 27) + e + W[i2];
                if (i2 < 20) {
                  t2 += (b & c | ~b & d) + 1518500249;
                } else if (i2 < 40) {
                  t2 += (b ^ c ^ d) + 1859775393;
                } else if (i2 < 60) {
                  t2 += (b & c | b & d | c & d) - 1894007588;
                } else {
                  t2 += (b ^ c ^ d) - 899497514;
                }
                e = d;
                d = c;
                c = b << 30 | b >>> 2;
                b = a;
                a = t2;
              }
              H[0] = H[0] + a | 0;
              H[1] = H[1] + b | 0;
              H[2] = H[2] + c | 0;
              H[3] = H[3] + d | 0;
              H[4] = H[4] + e | 0;
            },
            _doFinalize: function() {
              var data2 = this._data;
              var dataWords = data2.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data2.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
              data2.sigBytes = dataWords.length * 4;
              this._process();
              return this._hash;
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
            }
          });
          C.SHA1 = Hasher._createHelper(SHA1);
          C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
        })();
        return CryptoJS.SHA1;
      });
    })(sha1);
    return sha1.exports;
  }
  var sha256$2 = { exports: {} };
  (function(module2, exports3) {
    (function(root2, factory2) {
      {
        module2.exports = factory2(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n3) {
            var sqrtN = Math2.sqrt(n3);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n3 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n3) {
            return (n3 - (n3 | 0)) * 4294967296 | 0;
          }
          var n2 = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n2)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 3));
              nPrime++;
            }
            n2++;
          }
        })();
        var W = [];
        var SHA2562 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M, offset) {
            var H2 = this._hash.words;
            var a = H2[0];
            var b = H2[1];
            var c = H2[2];
            var d = H2[3];
            var e = H2[4];
            var f2 = H2[5];
            var g = H2[6];
            var h = H2[7];
            for (var i2 = 0; i2 < 64; i2++) {
              if (i2 < 16) {
                W[i2] = M[offset + i2] | 0;
              } else {
                var gamma0x = W[i2 - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i2 - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i2] = gamma0 + W[i2 - 7] + gamma1 + W[i2 - 16];
              }
              var ch = e & f2 ^ ~e & g;
              var maj = a & b ^ a & c ^ b & c;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h + sigma1 + ch + K[i2] + W[i2];
              var t2 = sigma0 + maj;
              h = g;
              g = f2;
              f2 = e;
              e = d + t1 | 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            }
            H2[0] = H2[0] + a | 0;
            H2[1] = H2[1] + b | 0;
            H2[2] = H2[2] + c | 0;
            H2[3] = H2[3] + d | 0;
            H2[4] = H2[4] + e | 0;
            H2[5] = H2[5] + f2 | 0;
            H2[6] = H2[6] + g | 0;
            H2[7] = H2[7] + h | 0;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA2562);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA2562);
      })(Math);
      return CryptoJS.SHA256;
    });
  })(sha256$2);
  var sha256Exports = sha256$2.exports;
  var sha224 = { exports: {} };
  var hasRequiredSha224;
  function requireSha224() {
    if (hasRequiredSha224)
      return sha224.exports;
    hasRequiredSha224 = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), sha256Exports);
        }
      })(commonjsGlobal, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var WordArray = C_lib.WordArray;
          var C_algo = C.algo;
          var SHA2562 = C_algo.SHA256;
          var SHA2242 = C_algo.SHA224 = SHA2562.extend({
            _doReset: function() {
              this._hash = new WordArray.init([
                3238371032,
                914150663,
                812702999,
                4144912697,
                4290775857,
                1750603025,
                1694076839,
                3204075428
              ]);
            },
            _doFinalize: function() {
              var hash2 = SHA2562._doFinalize.call(this);
              hash2.sigBytes -= 4;
              return hash2;
            }
          });
          C.SHA224 = SHA2562._createHelper(SHA2242);
          C.HmacSHA224 = SHA2562._createHmacHelper(SHA2242);
        })();
        return CryptoJS.SHA224;
      });
    })(sha224);
    return sha224.exports;
  }
  var sha512 = { exports: {} };
  var hasRequiredSha512;
  function requireSha512() {
    if (hasRequiredSha512)
      return sha512.exports;
    hasRequiredSha512 = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), requireX64Core());
        }
      })(commonjsGlobal, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var Hasher = C_lib.Hasher;
          var C_x64 = C.x64;
          var X64Word = C_x64.Word;
          var X64WordArray = C_x64.WordArray;
          var C_algo = C.algo;
          function X64Word_create() {
            return X64Word.create.apply(X64Word, arguments);
          }
          var K = [
            X64Word_create(1116352408, 3609767458),
            X64Word_create(1899447441, 602891725),
            X64Word_create(3049323471, 3964484399),
            X64Word_create(3921009573, 2173295548),
            X64Word_create(961987163, 4081628472),
            X64Word_create(1508970993, 3053834265),
            X64Word_create(2453635748, 2937671579),
            X64Word_create(2870763221, 3664609560),
            X64Word_create(3624381080, 2734883394),
            X64Word_create(310598401, 1164996542),
            X64Word_create(607225278, 1323610764),
            X64Word_create(1426881987, 3590304994),
            X64Word_create(1925078388, 4068182383),
            X64Word_create(2162078206, 991336113),
            X64Word_create(2614888103, 633803317),
            X64Word_create(3248222580, 3479774868),
            X64Word_create(3835390401, 2666613458),
            X64Word_create(4022224774, 944711139),
            X64Word_create(264347078, 2341262773),
            X64Word_create(604807628, 2007800933),
            X64Word_create(770255983, 1495990901),
            X64Word_create(1249150122, 1856431235),
            X64Word_create(1555081692, 3175218132),
            X64Word_create(1996064986, 2198950837),
            X64Word_create(2554220882, 3999719339),
            X64Word_create(2821834349, 766784016),
            X64Word_create(2952996808, 2566594879),
            X64Word_create(3210313671, 3203337956),
            X64Word_create(3336571891, 1034457026),
            X64Word_create(3584528711, 2466948901),
            X64Word_create(113926993, 3758326383),
            X64Word_create(338241895, 168717936),
            X64Word_create(666307205, 1188179964),
            X64Word_create(773529912, 1546045734),
            X64Word_create(1294757372, 1522805485),
            X64Word_create(1396182291, 2643833823),
            X64Word_create(1695183700, 2343527390),
            X64Word_create(1986661051, 1014477480),
            X64Word_create(2177026350, 1206759142),
            X64Word_create(2456956037, 344077627),
            X64Word_create(2730485921, 1290863460),
            X64Word_create(2820302411, 3158454273),
            X64Word_create(3259730800, 3505952657),
            X64Word_create(3345764771, 106217008),
            X64Word_create(3516065817, 3606008344),
            X64Word_create(3600352804, 1432725776),
            X64Word_create(4094571909, 1467031594),
            X64Word_create(275423344, 851169720),
            X64Word_create(430227734, 3100823752),
            X64Word_create(506948616, 1363258195),
            X64Word_create(659060556, 3750685593),
            X64Word_create(883997877, 3785050280),
            X64Word_create(958139571, 3318307427),
            X64Word_create(1322822218, 3812723403),
            X64Word_create(1537002063, 2003034995),
            X64Word_create(1747873779, 3602036899),
            X64Word_create(1955562222, 1575990012),
            X64Word_create(2024104815, 1125592928),
            X64Word_create(2227730452, 2716904306),
            X64Word_create(2361852424, 442776044),
            X64Word_create(2428436474, 593698344),
            X64Word_create(2756734187, 3733110249),
            X64Word_create(3204031479, 2999351573),
            X64Word_create(3329325298, 3815920427),
            X64Word_create(3391569614, 3928383900),
            X64Word_create(3515267271, 566280711),
            X64Word_create(3940187606, 3454069534),
            X64Word_create(4118630271, 4000239992),
            X64Word_create(116418474, 1914138554),
            X64Word_create(174292421, 2731055270),
            X64Word_create(289380356, 3203993006),
            X64Word_create(460393269, 320620315),
            X64Word_create(685471733, 587496836),
            X64Word_create(852142971, 1086792851),
            X64Word_create(1017036298, 365543100),
            X64Word_create(1126000580, 2618297676),
            X64Word_create(1288033470, 3409855158),
            X64Word_create(1501505948, 4234509866),
            X64Word_create(1607167915, 987167468),
            X64Word_create(1816402316, 1246189591)
          ];
          var W = [];
          (function() {
            for (var i2 = 0; i2 < 80; i2++) {
              W[i2] = X64Word_create();
            }
          })();
          var SHA512 = C_algo.SHA512 = Hasher.extend({
            _doReset: function() {
              this._hash = new X64WordArray.init([
                new X64Word.init(1779033703, 4089235720),
                new X64Word.init(3144134277, 2227873595),
                new X64Word.init(1013904242, 4271175723),
                new X64Word.init(2773480762, 1595750129),
                new X64Word.init(1359893119, 2917565137),
                new X64Word.init(2600822924, 725511199),
                new X64Word.init(528734635, 4215389547),
                new X64Word.init(1541459225, 327033209)
              ]);
            },
            _doProcessBlock: function(M, offset) {
              var H = this._hash.words;
              var H0 = H[0];
              var H1 = H[1];
              var H2 = H[2];
              var H3 = H[3];
              var H4 = H[4];
              var H5 = H[5];
              var H6 = H[6];
              var H7 = H[7];
              var H0h = H0.high;
              var H0l = H0.low;
              var H1h = H1.high;
              var H1l = H1.low;
              var H2h = H2.high;
              var H2l = H2.low;
              var H3h = H3.high;
              var H3l = H3.low;
              var H4h = H4.high;
              var H4l = H4.low;
              var H5h = H5.high;
              var H5l = H5.low;
              var H6h = H6.high;
              var H6l = H6.low;
              var H7h = H7.high;
              var H7l = H7.low;
              var ah = H0h;
              var al = H0l;
              var bh = H1h;
              var bl = H1l;
              var ch = H2h;
              var cl = H2l;
              var dh = H3h;
              var dl = H3l;
              var eh = H4h;
              var el = H4l;
              var fh = H5h;
              var fl = H5l;
              var gh = H6h;
              var gl = H6l;
              var hh = H7h;
              var hl = H7l;
              for (var i2 = 0; i2 < 80; i2++) {
                var Wil;
                var Wih;
                var Wi = W[i2];
                if (i2 < 16) {
                  Wih = Wi.high = M[offset + i2 * 2] | 0;
                  Wil = Wi.low = M[offset + i2 * 2 + 1] | 0;
                } else {
                  var gamma0x = W[i2 - 15];
                  var gamma0xh = gamma0x.high;
                  var gamma0xl = gamma0x.low;
                  var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                  var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                  var gamma1x = W[i2 - 2];
                  var gamma1xh = gamma1x.high;
                  var gamma1xl = gamma1x.low;
                  var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                  var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                  var Wi7 = W[i2 - 7];
                  var Wi7h = Wi7.high;
                  var Wi7l = Wi7.low;
                  var Wi16 = W[i2 - 16];
                  var Wi16h = Wi16.high;
                  var Wi16l = Wi16.low;
                  Wil = gamma0l + Wi7l;
                  Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                  Wil = Wil + gamma1l;
                  Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                  Wil = Wil + Wi16l;
                  Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                  Wi.high = Wih;
                  Wi.low = Wil;
                }
                var chh = eh & fh ^ ~eh & gh;
                var chl = el & fl ^ ~el & gl;
                var majh = ah & bh ^ ah & ch ^ bh & ch;
                var majl = al & bl ^ al & cl ^ bl & cl;
                var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
                var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
                var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
                var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
                var Ki = K[i2];
                var Kih = Ki.high;
                var Kil = Ki.low;
                var t1l = hl + sigma1l;
                var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
                var t1l = t1l + chl;
                var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
                var t1l = t1l + Kil;
                var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
                var t1l = t1l + Wil;
                var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
                var t2l = sigma0l + majl;
                var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
                hh = gh;
                hl = gl;
                gh = fh;
                gl = fl;
                fh = eh;
                fl = el;
                el = dl + t1l | 0;
                eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
                dh = ch;
                dl = cl;
                ch = bh;
                cl = bl;
                bh = ah;
                bl = al;
                al = t1l + t2l | 0;
                ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
              }
              H0l = H0.low = H0l + al;
              H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
              H1l = H1.low = H1l + bl;
              H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
              H2l = H2.low = H2l + cl;
              H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
              H3l = H3.low = H3l + dl;
              H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
              H4l = H4.low = H4l + el;
              H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
              H5l = H5.low = H5l + fl;
              H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
              H6l = H6.low = H6l + gl;
              H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
              H7l = H7.low = H7l + hl;
              H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
            },
            _doFinalize: function() {
              var data2 = this._data;
              var dataWords = data2.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data2.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
              dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
              dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
              data2.sigBytes = dataWords.length * 4;
              this._process();
              var hash2 = this._hash.toX32();
              return hash2;
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
            },
            blockSize: 1024 / 32
          });
          C.SHA512 = Hasher._createHelper(SHA512);
          C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
        })();
        return CryptoJS.SHA512;
      });
    })(sha512);
    return sha512.exports;
  }
  var sha384 = { exports: {} };
  var hasRequiredSha384;
  function requireSha384() {
    if (hasRequiredSha384)
      return sha384.exports;
    hasRequiredSha384 = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), requireX64Core(), requireSha512());
        }
      })(commonjsGlobal, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_x64 = C.x64;
          var X64Word = C_x64.Word;
          var X64WordArray = C_x64.WordArray;
          var C_algo = C.algo;
          var SHA512 = C_algo.SHA512;
          var SHA384 = C_algo.SHA384 = SHA512.extend({
            _doReset: function() {
              this._hash = new X64WordArray.init([
                new X64Word.init(3418070365, 3238371032),
                new X64Word.init(1654270250, 914150663),
                new X64Word.init(2438529370, 812702999),
                new X64Word.init(355462360, 4144912697),
                new X64Word.init(1731405415, 4290775857),
                new X64Word.init(2394180231, 1750603025),
                new X64Word.init(3675008525, 1694076839),
                new X64Word.init(1203062813, 3204075428)
              ]);
            },
            _doFinalize: function() {
              var hash2 = SHA512._doFinalize.call(this);
              hash2.sigBytes -= 16;
              return hash2;
            }
          });
          C.SHA384 = SHA512._createHelper(SHA384);
          C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
        })();
        return CryptoJS.SHA384;
      });
    })(sha384);
    return sha384.exports;
  }
  var sha3 = { exports: {} };
  var hasRequiredSha3;
  function requireSha3() {
    if (hasRequiredSha3)
      return sha3.exports;
    hasRequiredSha3 = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), requireX64Core());
        }
      })(commonjsGlobal, function(CryptoJS) {
        (function(Math2) {
          var C = CryptoJS;
          var C_lib = C.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_x64 = C.x64;
          var X64Word = C_x64.Word;
          var C_algo = C.algo;
          var RHO_OFFSETS = [];
          var PI_INDEXES = [];
          var ROUND_CONSTANTS = [];
          (function() {
            var x2 = 1, y = 0;
            for (var t2 = 0; t2 < 24; t2++) {
              RHO_OFFSETS[x2 + 5 * y] = (t2 + 1) * (t2 + 2) / 2 % 64;
              var newX = y % 5;
              var newY = (2 * x2 + 3 * y) % 5;
              x2 = newX;
              y = newY;
            }
            for (var x2 = 0; x2 < 5; x2++) {
              for (var y = 0; y < 5; y++) {
                PI_INDEXES[x2 + 5 * y] = y + (2 * x2 + 3 * y) % 5 * 5;
              }
            }
            var LFSR = 1;
            for (var i2 = 0; i2 < 24; i2++) {
              var roundConstantMsw = 0;
              var roundConstantLsw = 0;
              for (var j = 0; j < 7; j++) {
                if (LFSR & 1) {
                  var bitPosition = (1 << j) - 1;
                  if (bitPosition < 32) {
                    roundConstantLsw ^= 1 << bitPosition;
                  } else {
                    roundConstantMsw ^= 1 << bitPosition - 32;
                  }
                }
                if (LFSR & 128) {
                  LFSR = LFSR << 1 ^ 113;
                } else {
                  LFSR <<= 1;
                }
              }
              ROUND_CONSTANTS[i2] = X64Word.create(roundConstantMsw, roundConstantLsw);
            }
          })();
          var T2 = [];
          (function() {
            for (var i2 = 0; i2 < 25; i2++) {
              T2[i2] = X64Word.create();
            }
          })();
          var SHA3 = C_algo.SHA3 = Hasher.extend({
            /**
             * Configuration options.
             *
             * @property {number} outputLength
             *   The desired number of bits in the output hash.
             *   Only values permitted are: 224, 256, 384, 512.
             *   Default: 512
             */
            cfg: Hasher.cfg.extend({
              outputLength: 512
            }),
            _doReset: function() {
              var state2 = this._state = [];
              for (var i2 = 0; i2 < 25; i2++) {
                state2[i2] = new X64Word.init();
              }
              this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
            },
            _doProcessBlock: function(M, offset) {
              var state2 = this._state;
              var nBlockSizeLanes = this.blockSize / 2;
              for (var i2 = 0; i2 < nBlockSizeLanes; i2++) {
                var M2i = M[offset + 2 * i2];
                var M2i1 = M[offset + 2 * i2 + 1];
                M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
                M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
                var lane = state2[i2];
                lane.high ^= M2i1;
                lane.low ^= M2i;
              }
              for (var round = 0; round < 24; round++) {
                for (var x2 = 0; x2 < 5; x2++) {
                  var tMsw = 0, tLsw = 0;
                  for (var y = 0; y < 5; y++) {
                    var lane = state2[x2 + 5 * y];
                    tMsw ^= lane.high;
                    tLsw ^= lane.low;
                  }
                  var Tx = T2[x2];
                  Tx.high = tMsw;
                  Tx.low = tLsw;
                }
                for (var x2 = 0; x2 < 5; x2++) {
                  var Tx4 = T2[(x2 + 4) % 5];
                  var Tx1 = T2[(x2 + 1) % 5];
                  var Tx1Msw = Tx1.high;
                  var Tx1Lsw = Tx1.low;
                  var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                  var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                  for (var y = 0; y < 5; y++) {
                    var lane = state2[x2 + 5 * y];
                    lane.high ^= tMsw;
                    lane.low ^= tLsw;
                  }
                }
                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                  var tMsw;
                  var tLsw;
                  var lane = state2[laneIndex];
                  var laneMsw = lane.high;
                  var laneLsw = lane.low;
                  var rhoOffset = RHO_OFFSETS[laneIndex];
                  if (rhoOffset < 32) {
                    tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                    tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                  } else {
                    tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                    tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                  }
                  var TPiLane = T2[PI_INDEXES[laneIndex]];
                  TPiLane.high = tMsw;
                  TPiLane.low = tLsw;
                }
                var T0 = T2[0];
                var state0 = state2[0];
                T0.high = state0.high;
                T0.low = state0.low;
                for (var x2 = 0; x2 < 5; x2++) {
                  for (var y = 0; y < 5; y++) {
                    var laneIndex = x2 + 5 * y;
                    var lane = state2[laneIndex];
                    var TLane = T2[laneIndex];
                    var Tx1Lane = T2[(x2 + 1) % 5 + 5 * y];
                    var Tx2Lane = T2[(x2 + 2) % 5 + 5 * y];
                    lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                    lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                  }
                }
                var lane = state2[0];
                var roundConstant = ROUND_CONSTANTS[round];
                lane.high ^= roundConstant.high;
                lane.low ^= roundConstant.low;
              }
            },
            _doFinalize: function() {
              var data2 = this._data;
              var dataWords = data2.words;
              this._nDataBytes * 8;
              var nBitsLeft = data2.sigBytes * 8;
              var blockSizeBits = this.blockSize * 32;
              dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
              dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
              data2.sigBytes = dataWords.length * 4;
              this._process();
              var state2 = this._state;
              var outputLengthBytes = this.cfg.outputLength / 8;
              var outputLengthLanes = outputLengthBytes / 8;
              var hashWords = [];
              for (var i2 = 0; i2 < outputLengthLanes; i2++) {
                var lane = state2[i2];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
                laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
                hashWords.push(laneLsw);
                hashWords.push(laneMsw);
              }
              return new WordArray.init(hashWords, outputLengthBytes);
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              var state2 = clone._state = this._state.slice(0);
              for (var i2 = 0; i2 < 25; i2++) {
                state2[i2] = state2[i2].clone();
              }
              return clone;
            }
          });
          C.SHA3 = Hasher._createHelper(SHA3);
          C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
        })(Math);
        return CryptoJS.SHA3;
      });
    })(sha3);
    return sha3.exports;
  }
  var hmac = { exports: {} };
  var hasRequiredHmac;
  function requireHmac() {
    if (hasRequiredHmac)
      return hmac.exports;
    hasRequiredHmac = 1;
    (function(module2, exports3) {
      (function(root2, factory2) {
        {
          module2.exports = factory2(requireCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var Base = C_lib.Base;
          var C_enc = C.enc;
          var Utf8 = C_enc.Utf8;
          var C_algo = C.algo;
          C_algo.HMAC = Base.extend({
            /**
             * Initializes a newly created HMAC.
             *
             * @param {Hasher} hasher The hash algorithm to use.
             * @param {WordArray|string} key The secret key.
             *
             * @example
             *
             *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
             */
            init: function(hasher, key) {
              hasher = this._hasher = new hasher.init();
              if (typeof key == "string") {
                key = Utf8.parse(key);
              }
              var hasherBlockSize = hasher.blockSize;
              var hasherBlockSizeBytes = hasherBlockSize * 4;
              if (key.sigBytes > hasherBlockSizeBytes) {
                key = hasher.finalize(key);
              }
              key.clamp();
              var oKey = this._oKey = key.clone();
              var iKey = this._iKey = key.clone();
              var oKeyWords = oKey.words;
              var iKeyWords = iKey.words;
              for (var i2 = 0; i2 < hasherBlockSize; i2++) {
                oKeyWords[i2] ^= 1549556828;
                iKeyWords[i2] ^= 909522486;
              }
              oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
              this.reset();
            },
            /**
             * Resets this HMAC to its initial state.
             *
             * @example
             *
             *     hmacHasher.reset();
             */
            reset: function() {
              var hasher = this._hasher;
              hasher.reset();
              hasher.update(this._iKey);
            },
            /**
             * Updates this HMAC with a message.
             *
             * @param {WordArray|string} messageUpdate The message to append.
             *
             * @return {HMAC} This HMAC instance.
             *
             * @example
             *
             *     hmacHasher.update('message');
             *     hmacHasher.update(wordArray);
             */
            update: function(messageUpdate) {
              this._hasher.update(messageUpdate);
              return this;
            },
            /**
             * Finalizes the HMAC computation.
             * Note that the finalize operation is effectively a destructive, read-once operation.
             *
             * @param {WordArray|string} messageUpdate (Optional) A final message update.
             *
             * @return {WordArray} The HMAC.
             *
             * @example
             *
             *     var hmac = hmacHasher.finalize();
             *     var hmac = hmacHasher.finalize('message');
             *     var hmac = hmacHasher.finalize(wordArray);
             */
            finalize: function(messageUpdate) {
              var hasher = this._hasher;
              var innerHash = hasher.finalize(messageUpdate);
              hasher.reset();
              var hmac2 = hasher.finalize(this._oKey.clone().concat(innerHash));
              return hmac2;
            }
          });
        })();
      });
    })(hmac);
    return hmac.exports;
  }
  var pbkdf2 = { exports: {} };
  var hasRequiredPbkdf2;
  function requirePbkdf2() {
    if (hasRequiredPbkdf2)
      return pbkdf2.exports;
    hasRequiredPbkdf2 = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), sha256Exports, requireHmac());
        }
      })(commonjsGlobal, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var Base = C_lib.Base;
          var WordArray = C_lib.WordArray;
          var C_algo = C.algo;
          var SHA2562 = C_algo.SHA256;
          var HMAC = C_algo.HMAC;
          var PBKDF2 = C_algo.PBKDF2 = Base.extend({
            /**
             * Configuration options.
             *
             * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
             * @property {Hasher} hasher The hasher to use. Default: SHA256
             * @property {number} iterations The number of iterations to perform. Default: 250000
             */
            cfg: Base.extend({
              keySize: 128 / 32,
              hasher: SHA2562,
              iterations: 25e4
            }),
            /**
             * Initializes a newly created key derivation function.
             *
             * @param {Object} cfg (Optional) The configuration options to use for the derivation.
             *
             * @example
             *
             *     var kdf = CryptoJS.algo.PBKDF2.create();
             *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
             *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
             */
            init: function(cfg) {
              this.cfg = this.cfg.extend(cfg);
            },
            /**
             * Computes the Password-Based Key Derivation Function 2.
             *
             * @param {WordArray|string} password The password.
             * @param {WordArray|string} salt A salt.
             *
             * @return {WordArray} The derived key.
             *
             * @example
             *
             *     var key = kdf.compute(password, salt);
             */
            compute: function(password, salt) {
              var cfg = this.cfg;
              var hmac2 = HMAC.create(cfg.hasher, password);
              var derivedKey = WordArray.create();
              var blockIndex = WordArray.create([1]);
              var derivedKeyWords = derivedKey.words;
              var blockIndexWords = blockIndex.words;
              var keySize = cfg.keySize;
              var iterations = cfg.iterations;
              while (derivedKeyWords.length < keySize) {
                var block = hmac2.update(salt).finalize(blockIndex);
                hmac2.reset();
                var blockWords = block.words;
                var blockWordsLength = blockWords.length;
                var intermediate = block;
                for (var i2 = 1; i2 < iterations; i2++) {
                  intermediate = hmac2.finalize(intermediate);
                  hmac2.reset();
                  var intermediateWords = intermediate.words;
                  for (var j = 0; j < blockWordsLength; j++) {
                    blockWords[j] ^= intermediateWords[j];
                  }
                }
                derivedKey.concat(block);
                blockIndexWords[0]++;
              }
              derivedKey.sigBytes = keySize * 4;
              return derivedKey;
            }
          });
          C.PBKDF2 = function(password, salt, cfg) {
            return PBKDF2.create(cfg).compute(password, salt);
          };
        })();
        return CryptoJS.PBKDF2;
      });
    })(pbkdf2);
    return pbkdf2.exports;
  }
  var evpkdf = { exports: {} };
  var hasRequiredEvpkdf;
  function requireEvpkdf() {
    if (hasRequiredEvpkdf)
      return evpkdf.exports;
    hasRequiredEvpkdf = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), requireSha1(), requireHmac());
        }
      })(commonjsGlobal, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var Base = C_lib.Base;
          var WordArray = C_lib.WordArray;
          var C_algo = C.algo;
          var MD5 = C_algo.MD5;
          var EvpKDF = C_algo.EvpKDF = Base.extend({
            /**
             * Configuration options.
             *
             * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
             * @property {Hasher} hasher The hash algorithm to use. Default: MD5
             * @property {number} iterations The number of iterations to perform. Default: 1
             */
            cfg: Base.extend({
              keySize: 128 / 32,
              hasher: MD5,
              iterations: 1
            }),
            /**
             * Initializes a newly created key derivation function.
             *
             * @param {Object} cfg (Optional) The configuration options to use for the derivation.
             *
             * @example
             *
             *     var kdf = CryptoJS.algo.EvpKDF.create();
             *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
             *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
             */
            init: function(cfg) {
              this.cfg = this.cfg.extend(cfg);
            },
            /**
             * Derives a key from a password.
             *
             * @param {WordArray|string} password The password.
             * @param {WordArray|string} salt A salt.
             *
             * @return {WordArray} The derived key.
             *
             * @example
             *
             *     var key = kdf.compute(password, salt);
             */
            compute: function(password, salt) {
              var block;
              var cfg = this.cfg;
              var hasher = cfg.hasher.create();
              var derivedKey = WordArray.create();
              var derivedKeyWords = derivedKey.words;
              var keySize = cfg.keySize;
              var iterations = cfg.iterations;
              while (derivedKeyWords.length < keySize) {
                if (block) {
                  hasher.update(block);
                }
                block = hasher.update(password).finalize(salt);
                hasher.reset();
                for (var i2 = 1; i2 < iterations; i2++) {
                  block = hasher.finalize(block);
                  hasher.reset();
                }
                derivedKey.concat(block);
              }
              derivedKey.sigBytes = keySize * 4;
              return derivedKey;
            }
          });
          C.EvpKDF = function(password, salt, cfg) {
            return EvpKDF.create(cfg).compute(password, salt);
          };
        })();
        return CryptoJS.EvpKDF;
      });
    })(evpkdf);
    return evpkdf.exports;
  }
  var cipherCore = { exports: {} };
  var hasRequiredCipherCore;
  function requireCipherCore() {
    if (hasRequiredCipherCore)
      return cipherCore.exports;
    hasRequiredCipherCore = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), requireEvpkdf());
        }
      })(commonjsGlobal, function(CryptoJS) {
        CryptoJS.lib.Cipher || function(undefined$12) {
          var C = CryptoJS;
          var C_lib = C.lib;
          var Base = C_lib.Base;
          var WordArray = C_lib.WordArray;
          var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
          var C_enc = C.enc;
          C_enc.Utf8;
          var Base64 = C_enc.Base64;
          var C_algo = C.algo;
          var EvpKDF = C_algo.EvpKDF;
          var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
            /**
             * Configuration options.
             *
             * @property {WordArray} iv The IV to use for this operation.
             */
            cfg: Base.extend(),
            /**
             * Creates this cipher in encryption mode.
             *
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {Cipher} A cipher instance.
             *
             * @static
             *
             * @example
             *
             *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
             */
            createEncryptor: function(key, cfg) {
              return this.create(this._ENC_XFORM_MODE, key, cfg);
            },
            /**
             * Creates this cipher in decryption mode.
             *
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {Cipher} A cipher instance.
             *
             * @static
             *
             * @example
             *
             *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
             */
            createDecryptor: function(key, cfg) {
              return this.create(this._DEC_XFORM_MODE, key, cfg);
            },
            /**
             * Initializes a newly created cipher.
             *
             * @param {number} xformMode Either the encryption or decryption transormation mode constant.
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @example
             *
             *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
             */
            init: function(xformMode, key, cfg) {
              this.cfg = this.cfg.extend(cfg);
              this._xformMode = xformMode;
              this._key = key;
              this.reset();
            },
            /**
             * Resets this cipher to its initial state.
             *
             * @example
             *
             *     cipher.reset();
             */
            reset: function() {
              BufferedBlockAlgorithm.reset.call(this);
              this._doReset();
            },
            /**
             * Adds data to be encrypted or decrypted.
             *
             * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
             *
             * @return {WordArray} The data after processing.
             *
             * @example
             *
             *     var encrypted = cipher.process('data');
             *     var encrypted = cipher.process(wordArray);
             */
            process: function(dataUpdate) {
              this._append(dataUpdate);
              return this._process();
            },
            /**
             * Finalizes the encryption or decryption process.
             * Note that the finalize operation is effectively a destructive, read-once operation.
             *
             * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
             *
             * @return {WordArray} The data after final processing.
             *
             * @example
             *
             *     var encrypted = cipher.finalize();
             *     var encrypted = cipher.finalize('data');
             *     var encrypted = cipher.finalize(wordArray);
             */
            finalize: function(dataUpdate) {
              if (dataUpdate) {
                this._append(dataUpdate);
              }
              var finalProcessedData = this._doFinalize();
              return finalProcessedData;
            },
            keySize: 128 / 32,
            ivSize: 128 / 32,
            _ENC_XFORM_MODE: 1,
            _DEC_XFORM_MODE: 2,
            /**
             * Creates shortcut functions to a cipher's object interface.
             *
             * @param {Cipher} cipher The cipher to create a helper for.
             *
             * @return {Object} An object with encrypt and decrypt shortcut functions.
             *
             * @static
             *
             * @example
             *
             *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
             */
            _createHelper: function() {
              function selectCipherStrategy(key) {
                if (typeof key == "string") {
                  return PasswordBasedCipher;
                } else {
                  return SerializableCipher;
                }
              }
              return function(cipher) {
                return {
                  encrypt: function(message, key, cfg) {
                    return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                  },
                  decrypt: function(ciphertext, key, cfg) {
                    return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                  }
                };
              };
            }()
          });
          C_lib.StreamCipher = Cipher.extend({
            _doFinalize: function() {
              var finalProcessedBlocks = this._process(true);
              return finalProcessedBlocks;
            },
            blockSize: 1
          });
          var C_mode = C.mode = {};
          var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
            /**
             * Creates this mode for encryption.
             *
             * @param {Cipher} cipher A block cipher instance.
             * @param {Array} iv The IV words.
             *
             * @static
             *
             * @example
             *
             *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
             */
            createEncryptor: function(cipher, iv) {
              return this.Encryptor.create(cipher, iv);
            },
            /**
             * Creates this mode for decryption.
             *
             * @param {Cipher} cipher A block cipher instance.
             * @param {Array} iv The IV words.
             *
             * @static
             *
             * @example
             *
             *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
             */
            createDecryptor: function(cipher, iv) {
              return this.Decryptor.create(cipher, iv);
            },
            /**
             * Initializes a newly created mode.
             *
             * @param {Cipher} cipher A block cipher instance.
             * @param {Array} iv The IV words.
             *
             * @example
             *
             *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
             */
            init: function(cipher, iv) {
              this._cipher = cipher;
              this._iv = iv;
            }
          });
          var CBC = C_mode.CBC = function() {
            var CBC2 = BlockCipherMode.extend();
            CBC2.Encryptor = CBC2.extend({
              /**
               * Processes the data block at offset.
               *
               * @param {Array} words The data words to operate on.
               * @param {number} offset The offset where the block starts.
               *
               * @example
               *
               *     mode.processBlock(data.words, offset);
               */
              processBlock: function(words, offset) {
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;
                xorBlock.call(this, words, offset, blockSize);
                cipher.encryptBlock(words, offset);
                this._prevBlock = words.slice(offset, offset + blockSize);
              }
            });
            CBC2.Decryptor = CBC2.extend({
              /**
               * Processes the data block at offset.
               *
               * @param {Array} words The data words to operate on.
               * @param {number} offset The offset where the block starts.
               *
               * @example
               *
               *     mode.processBlock(data.words, offset);
               */
              processBlock: function(words, offset) {
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;
                var thisBlock = words.slice(offset, offset + blockSize);
                cipher.decryptBlock(words, offset);
                xorBlock.call(this, words, offset, blockSize);
                this._prevBlock = thisBlock;
              }
            });
            function xorBlock(words, offset, blockSize) {
              var block;
              var iv = this._iv;
              if (iv) {
                block = iv;
                this._iv = undefined$12;
              } else {
                block = this._prevBlock;
              }
              for (var i2 = 0; i2 < blockSize; i2++) {
                words[offset + i2] ^= block[i2];
              }
            }
            return CBC2;
          }();
          var C_pad = C.pad = {};
          var Pkcs7 = C_pad.Pkcs7 = {
            /**
             * Pads data using the algorithm defined in PKCS #5/7.
             *
             * @param {WordArray} data The data to pad.
             * @param {number} blockSize The multiple that the data should be padded to.
             *
             * @static
             *
             * @example
             *
             *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
             */
            pad: function(data2, blockSize) {
              var blockSizeBytes = blockSize * 4;
              var nPaddingBytes = blockSizeBytes - data2.sigBytes % blockSizeBytes;
              var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
              var paddingWords = [];
              for (var i2 = 0; i2 < nPaddingBytes; i2 += 4) {
                paddingWords.push(paddingWord);
              }
              var padding = WordArray.create(paddingWords, nPaddingBytes);
              data2.concat(padding);
            },
            /**
             * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
             *
             * @param {WordArray} data The data to unpad.
             *
             * @static
             *
             * @example
             *
             *     CryptoJS.pad.Pkcs7.unpad(wordArray);
             */
            unpad: function(data2) {
              var nPaddingBytes = data2.words[data2.sigBytes - 1 >>> 2] & 255;
              data2.sigBytes -= nPaddingBytes;
            }
          };
          C_lib.BlockCipher = Cipher.extend({
            /**
             * Configuration options.
             *
             * @property {Mode} mode The block mode to use. Default: CBC
             * @property {Padding} padding The padding strategy to use. Default: Pkcs7
             */
            cfg: Cipher.cfg.extend({
              mode: CBC,
              padding: Pkcs7
            }),
            reset: function() {
              var modeCreator;
              Cipher.reset.call(this);
              var cfg = this.cfg;
              var iv = cfg.iv;
              var mode = cfg.mode;
              if (this._xformMode == this._ENC_XFORM_MODE) {
                modeCreator = mode.createEncryptor;
              } else {
                modeCreator = mode.createDecryptor;
                this._minBufferSize = 1;
              }
              if (this._mode && this._mode.__creator == modeCreator) {
                this._mode.init(this, iv && iv.words);
              } else {
                this._mode = modeCreator.call(mode, this, iv && iv.words);
                this._mode.__creator = modeCreator;
              }
            },
            _doProcessBlock: function(words, offset) {
              this._mode.processBlock(words, offset);
            },
            _doFinalize: function() {
              var finalProcessedBlocks;
              var padding = this.cfg.padding;
              if (this._xformMode == this._ENC_XFORM_MODE) {
                padding.pad(this._data, this.blockSize);
                finalProcessedBlocks = this._process(true);
              } else {
                finalProcessedBlocks = this._process(true);
                padding.unpad(finalProcessedBlocks);
              }
              return finalProcessedBlocks;
            },
            blockSize: 128 / 32
          });
          var CipherParams = C_lib.CipherParams = Base.extend({
            /**
             * Initializes a newly created cipher params object.
             *
             * @param {Object} cipherParams An object with any of the possible cipher parameters.
             *
             * @example
             *
             *     var cipherParams = CryptoJS.lib.CipherParams.create({
             *         ciphertext: ciphertextWordArray,
             *         key: keyWordArray,
             *         iv: ivWordArray,
             *         salt: saltWordArray,
             *         algorithm: CryptoJS.algo.AES,
             *         mode: CryptoJS.mode.CBC,
             *         padding: CryptoJS.pad.PKCS7,
             *         blockSize: 4,
             *         formatter: CryptoJS.format.OpenSSL
             *     });
             */
            init: function(cipherParams) {
              this.mixIn(cipherParams);
            },
            /**
             * Converts this cipher params object to a string.
             *
             * @param {Format} formatter (Optional) The formatting strategy to use.
             *
             * @return {string} The stringified cipher params.
             *
             * @throws Error If neither the formatter nor the default formatter is set.
             *
             * @example
             *
             *     var string = cipherParams + '';
             *     var string = cipherParams.toString();
             *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
             */
            toString: function(formatter) {
              return (formatter || this.formatter).stringify(this);
            }
          });
          var C_format = C.format = {};
          var OpenSSLFormatter = C_format.OpenSSL = {
            /**
             * Converts a cipher params object to an OpenSSL-compatible string.
             *
             * @param {CipherParams} cipherParams The cipher params object.
             *
             * @return {string} The OpenSSL-compatible string.
             *
             * @static
             *
             * @example
             *
             *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
             */
            stringify: function(cipherParams) {
              var wordArray;
              var ciphertext = cipherParams.ciphertext;
              var salt = cipherParams.salt;
              if (salt) {
                wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
              } else {
                wordArray = ciphertext;
              }
              return wordArray.toString(Base64);
            },
            /**
             * Converts an OpenSSL-compatible string to a cipher params object.
             *
             * @param {string} openSSLStr The OpenSSL-compatible string.
             *
             * @return {CipherParams} The cipher params object.
             *
             * @static
             *
             * @example
             *
             *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
             */
            parse: function(openSSLStr) {
              var salt;
              var ciphertext = Base64.parse(openSSLStr);
              var ciphertextWords = ciphertext.words;
              if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
                salt = WordArray.create(ciphertextWords.slice(2, 4));
                ciphertextWords.splice(0, 4);
                ciphertext.sigBytes -= 16;
              }
              return CipherParams.create({ ciphertext, salt });
            }
          };
          var SerializableCipher = C_lib.SerializableCipher = Base.extend({
            /**
             * Configuration options.
             *
             * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
             */
            cfg: Base.extend({
              format: OpenSSLFormatter
            }),
            /**
             * Encrypts a message.
             *
             * @param {Cipher} cipher The cipher algorithm to use.
             * @param {WordArray|string} message The message to encrypt.
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {CipherParams} A cipher params object.
             *
             * @static
             *
             * @example
             *
             *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
             *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
             *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
             */
            encrypt: function(cipher, message, key, cfg) {
              cfg = this.cfg.extend(cfg);
              var encryptor = cipher.createEncryptor(key, cfg);
              var ciphertext = encryptor.finalize(message);
              var cipherCfg = encryptor.cfg;
              return CipherParams.create({
                ciphertext,
                key,
                iv: cipherCfg.iv,
                algorithm: cipher,
                mode: cipherCfg.mode,
                padding: cipherCfg.padding,
                blockSize: cipher.blockSize,
                formatter: cfg.format
              });
            },
            /**
             * Decrypts serialized ciphertext.
             *
             * @param {Cipher} cipher The cipher algorithm to use.
             * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {WordArray} The plaintext.
             *
             * @static
             *
             * @example
             *
             *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
             *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
             */
            decrypt: function(cipher, ciphertext, key, cfg) {
              cfg = this.cfg.extend(cfg);
              ciphertext = this._parse(ciphertext, cfg.format);
              var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
              return plaintext;
            },
            /**
             * Converts serialized ciphertext to CipherParams,
             * else assumed CipherParams already and returns ciphertext unchanged.
             *
             * @param {CipherParams|string} ciphertext The ciphertext.
             * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
             *
             * @return {CipherParams} The unserialized ciphertext.
             *
             * @static
             *
             * @example
             *
             *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
             */
            _parse: function(ciphertext, format) {
              if (typeof ciphertext == "string") {
                return format.parse(ciphertext, this);
              } else {
                return ciphertext;
              }
            }
          });
          var C_kdf = C.kdf = {};
          var OpenSSLKdf = C_kdf.OpenSSL = {
            /**
             * Derives a key and IV from a password.
             *
             * @param {string} password The password to derive from.
             * @param {number} keySize The size in words of the key to generate.
             * @param {number} ivSize The size in words of the IV to generate.
             * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
             *
             * @return {CipherParams} A cipher params object with the key, IV, and salt.
             *
             * @static
             *
             * @example
             *
             *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
             *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
             */
            execute: function(password, keySize, ivSize, salt, hasher) {
              if (!salt) {
                salt = WordArray.random(64 / 8);
              }
              if (!hasher) {
                var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
              } else {
                var key = EvpKDF.create({ keySize: keySize + ivSize, hasher }).compute(password, salt);
              }
              var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
              key.sigBytes = keySize * 4;
              return CipherParams.create({ key, iv, salt });
            }
          };
          var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
            /**
             * Configuration options.
             *
             * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
             */
            cfg: SerializableCipher.cfg.extend({
              kdf: OpenSSLKdf
            }),
            /**
             * Encrypts a message using a password.
             *
             * @param {Cipher} cipher The cipher algorithm to use.
             * @param {WordArray|string} message The message to encrypt.
             * @param {string} password The password.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {CipherParams} A cipher params object.
             *
             * @static
             *
             * @example
             *
             *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
             *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
             */
            encrypt: function(cipher, message, password, cfg) {
              cfg = this.cfg.extend(cfg);
              var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
              cfg.iv = derivedParams.iv;
              var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
              ciphertext.mixIn(derivedParams);
              return ciphertext;
            },
            /**
             * Decrypts serialized ciphertext using a password.
             *
             * @param {Cipher} cipher The cipher algorithm to use.
             * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
             * @param {string} password The password.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {WordArray} The plaintext.
             *
             * @static
             *
             * @example
             *
             *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
             *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
             */
            decrypt: function(cipher, ciphertext, password, cfg) {
              cfg = this.cfg.extend(cfg);
              ciphertext = this._parse(ciphertext, cfg.format);
              var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
              cfg.iv = derivedParams.iv;
              var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
              return plaintext;
            }
          });
        }();
      });
    })(cipherCore);
    return cipherCore.exports;
  }
  var modeCfb = { exports: {} };
  var hasRequiredModeCfb;
  function requireModeCfb() {
    if (hasRequiredModeCfb)
      return modeCfb.exports;
    hasRequiredModeCfb = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        CryptoJS.mode.CFB = function() {
          var CFB = CryptoJS.lib.BlockCipherMode.extend();
          CFB.Encryptor = CFB.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CFB.Decryptor = CFB.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
              this._prevBlock = thisBlock;
            }
          });
          function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
            var keystream;
            var iv = this._iv;
            if (iv) {
              keystream = iv.slice(0);
              this._iv = void 0;
            } else {
              keystream = this._prevBlock;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i2 = 0; i2 < blockSize; i2++) {
              words[offset + i2] ^= keystream[i2];
            }
          }
          return CFB;
        }();
        return CryptoJS.mode.CFB;
      });
    })(modeCfb);
    return modeCfb.exports;
  }
  var modeCtr = { exports: {} };
  var hasRequiredModeCtr;
  function requireModeCtr() {
    if (hasRequiredModeCtr)
      return modeCtr.exports;
    hasRequiredModeCtr = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        CryptoJS.mode.CTR = function() {
          var CTR = CryptoJS.lib.BlockCipherMode.extend();
          var Encryptor = CTR.Encryptor = CTR.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var iv = this._iv;
              var counter = this._counter;
              if (iv) {
                counter = this._counter = iv.slice(0);
                this._iv = void 0;
              }
              var keystream = counter.slice(0);
              cipher.encryptBlock(keystream, 0);
              counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
              for (var i2 = 0; i2 < blockSize; i2++) {
                words[offset + i2] ^= keystream[i2];
              }
            }
          });
          CTR.Decryptor = Encryptor;
          return CTR;
        }();
        return CryptoJS.mode.CTR;
      });
    })(modeCtr);
    return modeCtr.exports;
  }
  var modeCtrGladman = { exports: {} };
  var hasRequiredModeCtrGladman;
  function requireModeCtrGladman() {
    if (hasRequiredModeCtrGladman)
      return modeCtrGladman.exports;
    hasRequiredModeCtrGladman = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        /** @preserve
         * Counter block mode compatible with  Dr Brian Gladman fileenc.c
         * derived from CryptoJS.mode.CTR
         * Jan Hruby jhruby.web@gmail.com
         */
        CryptoJS.mode.CTRGladman = function() {
          var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
          function incWord(word) {
            if ((word >> 24 & 255) === 255) {
              var b1 = word >> 16 & 255;
              var b2 = word >> 8 & 255;
              var b3 = word & 255;
              if (b1 === 255) {
                b1 = 0;
                if (b2 === 255) {
                  b2 = 0;
                  if (b3 === 255) {
                    b3 = 0;
                  } else {
                    ++b3;
                  }
                } else {
                  ++b2;
                }
              } else {
                ++b1;
              }
              word = 0;
              word += b1 << 16;
              word += b2 << 8;
              word += b3;
            } else {
              word += 1 << 24;
            }
            return word;
          }
          function incCounter(counter) {
            if ((counter[0] = incWord(counter[0])) === 0) {
              counter[1] = incWord(counter[1]);
            }
            return counter;
          }
          var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var iv = this._iv;
              var counter = this._counter;
              if (iv) {
                counter = this._counter = iv.slice(0);
                this._iv = void 0;
              }
              incCounter(counter);
              var keystream = counter.slice(0);
              cipher.encryptBlock(keystream, 0);
              for (var i2 = 0; i2 < blockSize; i2++) {
                words[offset + i2] ^= keystream[i2];
              }
            }
          });
          CTRGladman.Decryptor = Encryptor;
          return CTRGladman;
        }();
        return CryptoJS.mode.CTRGladman;
      });
    })(modeCtrGladman);
    return modeCtrGladman.exports;
  }
  var modeOfb = { exports: {} };
  var hasRequiredModeOfb;
  function requireModeOfb() {
    if (hasRequiredModeOfb)
      return modeOfb.exports;
    hasRequiredModeOfb = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        CryptoJS.mode.OFB = function() {
          var OFB = CryptoJS.lib.BlockCipherMode.extend();
          var Encryptor = OFB.Encryptor = OFB.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var iv = this._iv;
              var keystream = this._keystream;
              if (iv) {
                keystream = this._keystream = iv.slice(0);
                this._iv = void 0;
              }
              cipher.encryptBlock(keystream, 0);
              for (var i2 = 0; i2 < blockSize; i2++) {
                words[offset + i2] ^= keystream[i2];
              }
            }
          });
          OFB.Decryptor = Encryptor;
          return OFB;
        }();
        return CryptoJS.mode.OFB;
      });
    })(modeOfb);
    return modeOfb.exports;
  }
  var modeEcb = { exports: {} };
  var hasRequiredModeEcb;
  function requireModeEcb() {
    if (hasRequiredModeEcb)
      return modeEcb.exports;
    hasRequiredModeEcb = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        CryptoJS.mode.ECB = function() {
          var ECB = CryptoJS.lib.BlockCipherMode.extend();
          ECB.Encryptor = ECB.extend({
            processBlock: function(words, offset) {
              this._cipher.encryptBlock(words, offset);
            }
          });
          ECB.Decryptor = ECB.extend({
            processBlock: function(words, offset) {
              this._cipher.decryptBlock(words, offset);
            }
          });
          return ECB;
        }();
        return CryptoJS.mode.ECB;
      });
    })(modeEcb);
    return modeEcb.exports;
  }
  var padAnsix923 = { exports: {} };
  var hasRequiredPadAnsix923;
  function requirePadAnsix923() {
    if (hasRequiredPadAnsix923)
      return padAnsix923.exports;
    hasRequiredPadAnsix923 = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        CryptoJS.pad.AnsiX923 = {
          pad: function(data2, blockSize) {
            var dataSigBytes = data2.sigBytes;
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
            var lastBytePos = dataSigBytes + nPaddingBytes - 1;
            data2.clamp();
            data2.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
            data2.sigBytes += nPaddingBytes;
          },
          unpad: function(data2) {
            var nPaddingBytes = data2.words[data2.sigBytes - 1 >>> 2] & 255;
            data2.sigBytes -= nPaddingBytes;
          }
        };
        return CryptoJS.pad.Ansix923;
      });
    })(padAnsix923);
    return padAnsix923.exports;
  }
  var padIso10126 = { exports: {} };
  var hasRequiredPadIso10126;
  function requirePadIso10126() {
    if (hasRequiredPadIso10126)
      return padIso10126.exports;
    hasRequiredPadIso10126 = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        CryptoJS.pad.Iso10126 = {
          pad: function(data2, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data2.sigBytes % blockSizeBytes;
            data2.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
          },
          unpad: function(data2) {
            var nPaddingBytes = data2.words[data2.sigBytes - 1 >>> 2] & 255;
            data2.sigBytes -= nPaddingBytes;
          }
        };
        return CryptoJS.pad.Iso10126;
      });
    })(padIso10126);
    return padIso10126.exports;
  }
  var padIso97971 = { exports: {} };
  var hasRequiredPadIso97971;
  function requirePadIso97971() {
    if (hasRequiredPadIso97971)
      return padIso97971.exports;
    hasRequiredPadIso97971 = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        CryptoJS.pad.Iso97971 = {
          pad: function(data2, blockSize) {
            data2.concat(CryptoJS.lib.WordArray.create([2147483648], 1));
            CryptoJS.pad.ZeroPadding.pad(data2, blockSize);
          },
          unpad: function(data2) {
            CryptoJS.pad.ZeroPadding.unpad(data2);
            data2.sigBytes--;
          }
        };
        return CryptoJS.pad.Iso97971;
      });
    })(padIso97971);
    return padIso97971.exports;
  }
  var padZeropadding = { exports: {} };
  var hasRequiredPadZeropadding;
  function requirePadZeropadding() {
    if (hasRequiredPadZeropadding)
      return padZeropadding.exports;
    hasRequiredPadZeropadding = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        CryptoJS.pad.ZeroPadding = {
          pad: function(data2, blockSize) {
            var blockSizeBytes = blockSize * 4;
            data2.clamp();
            data2.sigBytes += blockSizeBytes - (data2.sigBytes % blockSizeBytes || blockSizeBytes);
          },
          unpad: function(data2) {
            var dataWords = data2.words;
            var i2 = data2.sigBytes - 1;
            for (var i2 = data2.sigBytes - 1; i2 >= 0; i2--) {
              if (dataWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255) {
                data2.sigBytes = i2 + 1;
                break;
              }
            }
          }
        };
        return CryptoJS.pad.ZeroPadding;
      });
    })(padZeropadding);
    return padZeropadding.exports;
  }
  var padNopadding = { exports: {} };
  var hasRequiredPadNopadding;
  function requirePadNopadding() {
    if (hasRequiredPadNopadding)
      return padNopadding.exports;
    hasRequiredPadNopadding = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        CryptoJS.pad.NoPadding = {
          pad: function() {
          },
          unpad: function() {
          }
        };
        return CryptoJS.pad.NoPadding;
      });
    })(padNopadding);
    return padNopadding.exports;
  }
  var formatHex = { exports: {} };
  var hasRequiredFormatHex;
  function requireFormatHex() {
    if (hasRequiredFormatHex)
      return formatHex.exports;
    hasRequiredFormatHex = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        (function(undefined$12) {
          var C = CryptoJS;
          var C_lib = C.lib;
          var CipherParams = C_lib.CipherParams;
          var C_enc = C.enc;
          var Hex = C_enc.Hex;
          var C_format = C.format;
          C_format.Hex = {
            /**
             * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
             *
             * @param {CipherParams} cipherParams The cipher params object.
             *
             * @return {string} The hexadecimally encoded string.
             *
             * @static
             *
             * @example
             *
             *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
             */
            stringify: function(cipherParams) {
              return cipherParams.ciphertext.toString(Hex);
            },
            /**
             * Converts a hexadecimally encoded ciphertext string to a cipher params object.
             *
             * @param {string} input The hexadecimally encoded string.
             *
             * @return {CipherParams} The cipher params object.
             *
             * @static
             *
             * @example
             *
             *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
             */
            parse: function(input) {
              var ciphertext = Hex.parse(input);
              return CipherParams.create({ ciphertext });
            }
          };
        })();
        return CryptoJS.format.Hex;
      });
    })(formatHex);
    return formatHex.exports;
  }
  var aes = { exports: {} };
  var hasRequiredAes;
  function requireAes() {
    if (hasRequiredAes)
      return aes.exports;
    hasRequiredAes = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var BlockCipher = C_lib.BlockCipher;
          var C_algo = C.algo;
          var SBOX = [];
          var INV_SBOX = [];
          var SUB_MIX_0 = [];
          var SUB_MIX_1 = [];
          var SUB_MIX_2 = [];
          var SUB_MIX_3 = [];
          var INV_SUB_MIX_0 = [];
          var INV_SUB_MIX_1 = [];
          var INV_SUB_MIX_2 = [];
          var INV_SUB_MIX_3 = [];
          (function() {
            var d = [];
            for (var i2 = 0; i2 < 256; i2++) {
              if (i2 < 128) {
                d[i2] = i2 << 1;
              } else {
                d[i2] = i2 << 1 ^ 283;
              }
            }
            var x2 = 0;
            var xi = 0;
            for (var i2 = 0; i2 < 256; i2++) {
              var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
              sx = sx >>> 8 ^ sx & 255 ^ 99;
              SBOX[x2] = sx;
              INV_SBOX[sx] = x2;
              var x22 = d[x2];
              var x4 = d[x22];
              var x8 = d[x4];
              var t2 = d[sx] * 257 ^ sx * 16843008;
              SUB_MIX_0[x2] = t2 << 24 | t2 >>> 8;
              SUB_MIX_1[x2] = t2 << 16 | t2 >>> 16;
              SUB_MIX_2[x2] = t2 << 8 | t2 >>> 24;
              SUB_MIX_3[x2] = t2;
              var t2 = x8 * 16843009 ^ x4 * 65537 ^ x22 * 257 ^ x2 * 16843008;
              INV_SUB_MIX_0[sx] = t2 << 24 | t2 >>> 8;
              INV_SUB_MIX_1[sx] = t2 << 16 | t2 >>> 16;
              INV_SUB_MIX_2[sx] = t2 << 8 | t2 >>> 24;
              INV_SUB_MIX_3[sx] = t2;
              if (!x2) {
                x2 = xi = 1;
              } else {
                x2 = x22 ^ d[d[d[x8 ^ x22]]];
                xi ^= d[d[xi]];
              }
            }
          })();
          var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
          var AES = C_algo.AES = BlockCipher.extend({
            _doReset: function() {
              var t2;
              if (this._nRounds && this._keyPriorReset === this._key) {
                return;
              }
              var key = this._keyPriorReset = this._key;
              var keyWords = key.words;
              var keySize = key.sigBytes / 4;
              var nRounds = this._nRounds = keySize + 6;
              var ksRows = (nRounds + 1) * 4;
              var keySchedule = this._keySchedule = [];
              for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                if (ksRow < keySize) {
                  keySchedule[ksRow] = keyWords[ksRow];
                } else {
                  t2 = keySchedule[ksRow - 1];
                  if (!(ksRow % keySize)) {
                    t2 = t2 << 8 | t2 >>> 24;
                    t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                    t2 ^= RCON[ksRow / keySize | 0] << 24;
                  } else if (keySize > 6 && ksRow % keySize == 4) {
                    t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                  }
                  keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t2;
                }
              }
              var invKeySchedule = this._invKeySchedule = [];
              for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                var ksRow = ksRows - invKsRow;
                if (invKsRow % 4) {
                  var t2 = keySchedule[ksRow];
                } else {
                  var t2 = keySchedule[ksRow - 4];
                }
                if (invKsRow < 4 || ksRow <= 4) {
                  invKeySchedule[invKsRow] = t2;
                } else {
                  invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t2 >>> 24]] ^ INV_SUB_MIX_1[SBOX[t2 >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t2 >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t2 & 255]];
                }
              }
            },
            encryptBlock: function(M, offset) {
              this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
            },
            decryptBlock: function(M, offset) {
              var t2 = M[offset + 1];
              M[offset + 1] = M[offset + 3];
              M[offset + 3] = t2;
              this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
              var t2 = M[offset + 1];
              M[offset + 1] = M[offset + 3];
              M[offset + 3] = t2;
            },
            _doCryptBlock: function(M, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
              var nRounds = this._nRounds;
              var s0 = M[offset] ^ keySchedule[0];
              var s1 = M[offset + 1] ^ keySchedule[1];
              var s2 = M[offset + 2] ^ keySchedule[2];
              var s3 = M[offset + 3] ^ keySchedule[3];
              var ksRow = 4;
              for (var round = 1; round < nRounds; round++) {
                var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
                var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
                var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
                var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
                s0 = t0;
                s1 = t1;
                s2 = t2;
                s3 = t3;
              }
              var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
              var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
              var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
              var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
              M[offset] = t0;
              M[offset + 1] = t1;
              M[offset + 2] = t2;
              M[offset + 3] = t3;
            },
            keySize: 256 / 32
          });
          C.AES = BlockCipher._createHelper(AES);
        })();
        return CryptoJS.AES;
      });
    })(aes);
    return aes.exports;
  }
  var tripledes = { exports: {} };
  var hasRequiredTripledes;
  function requireTripledes() {
    if (hasRequiredTripledes)
      return tripledes.exports;
    hasRequiredTripledes = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var WordArray = C_lib.WordArray;
          var BlockCipher = C_lib.BlockCipher;
          var C_algo = C.algo;
          var PC1 = [
            57,
            49,
            41,
            33,
            25,
            17,
            9,
            1,
            58,
            50,
            42,
            34,
            26,
            18,
            10,
            2,
            59,
            51,
            43,
            35,
            27,
            19,
            11,
            3,
            60,
            52,
            44,
            36,
            63,
            55,
            47,
            39,
            31,
            23,
            15,
            7,
            62,
            54,
            46,
            38,
            30,
            22,
            14,
            6,
            61,
            53,
            45,
            37,
            29,
            21,
            13,
            5,
            28,
            20,
            12,
            4
          ];
          var PC2 = [
            14,
            17,
            11,
            24,
            1,
            5,
            3,
            28,
            15,
            6,
            21,
            10,
            23,
            19,
            12,
            4,
            26,
            8,
            16,
            7,
            27,
            20,
            13,
            2,
            41,
            52,
            31,
            37,
            47,
            55,
            30,
            40,
            51,
            45,
            33,
            48,
            44,
            49,
            39,
            56,
            34,
            53,
            46,
            42,
            50,
            36,
            29,
            32
          ];
          var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
          var SBOX_P = [
            {
              0: 8421888,
              268435456: 32768,
              536870912: 8421378,
              805306368: 2,
              1073741824: 512,
              1342177280: 8421890,
              1610612736: 8389122,
              1879048192: 8388608,
              2147483648: 514,
              2415919104: 8389120,
              2684354560: 33280,
              2952790016: 8421376,
              3221225472: 32770,
              3489660928: 8388610,
              3758096384: 0,
              4026531840: 33282,
              134217728: 0,
              402653184: 8421890,
              671088640: 33282,
              939524096: 32768,
              1207959552: 8421888,
              1476395008: 512,
              1744830464: 8421378,
              2013265920: 2,
              2281701376: 8389120,
              2550136832: 33280,
              2818572288: 8421376,
              3087007744: 8389122,
              3355443200: 8388610,
              3623878656: 32770,
              3892314112: 514,
              4160749568: 8388608,
              1: 32768,
              268435457: 2,
              536870913: 8421888,
              805306369: 8388608,
              1073741825: 8421378,
              1342177281: 33280,
              1610612737: 512,
              1879048193: 8389122,
              2147483649: 8421890,
              2415919105: 8421376,
              2684354561: 8388610,
              2952790017: 33282,
              3221225473: 514,
              3489660929: 8389120,
              3758096385: 32770,
              4026531841: 0,
              134217729: 8421890,
              402653185: 8421376,
              671088641: 8388608,
              939524097: 512,
              1207959553: 32768,
              1476395009: 8388610,
              1744830465: 2,
              2013265921: 33282,
              2281701377: 32770,
              2550136833: 8389122,
              2818572289: 514,
              3087007745: 8421888,
              3355443201: 8389120,
              3623878657: 0,
              3892314113: 33280,
              4160749569: 8421378
            },
            {
              0: 1074282512,
              16777216: 16384,
              33554432: 524288,
              50331648: 1074266128,
              67108864: 1073741840,
              83886080: 1074282496,
              100663296: 1073758208,
              117440512: 16,
              134217728: 540672,
              150994944: 1073758224,
              167772160: 1073741824,
              184549376: 540688,
              201326592: 524304,
              218103808: 0,
              234881024: 16400,
              251658240: 1074266112,
              8388608: 1073758208,
              25165824: 540688,
              41943040: 16,
              58720256: 1073758224,
              75497472: 1074282512,
              92274688: 1073741824,
              109051904: 524288,
              125829120: 1074266128,
              142606336: 524304,
              159383552: 0,
              176160768: 16384,
              192937984: 1074266112,
              209715200: 1073741840,
              226492416: 540672,
              243269632: 1074282496,
              260046848: 16400,
              268435456: 0,
              285212672: 1074266128,
              301989888: 1073758224,
              318767104: 1074282496,
              335544320: 1074266112,
              352321536: 16,
              369098752: 540688,
              385875968: 16384,
              402653184: 16400,
              419430400: 524288,
              436207616: 524304,
              452984832: 1073741840,
              469762048: 540672,
              486539264: 1073758208,
              503316480: 1073741824,
              520093696: 1074282512,
              276824064: 540688,
              293601280: 524288,
              310378496: 1074266112,
              327155712: 16384,
              343932928: 1073758208,
              360710144: 1074282512,
              377487360: 16,
              394264576: 1073741824,
              411041792: 1074282496,
              427819008: 1073741840,
              444596224: 1073758224,
              461373440: 524304,
              478150656: 0,
              494927872: 16400,
              511705088: 1074266128,
              528482304: 540672
            },
            {
              0: 260,
              1048576: 0,
              2097152: 67109120,
              3145728: 65796,
              4194304: 65540,
              5242880: 67108868,
              6291456: 67174660,
              7340032: 67174400,
              8388608: 67108864,
              9437184: 67174656,
              10485760: 65792,
              11534336: 67174404,
              12582912: 67109124,
              13631488: 65536,
              14680064: 4,
              15728640: 256,
              524288: 67174656,
              1572864: 67174404,
              2621440: 0,
              3670016: 67109120,
              4718592: 67108868,
              5767168: 65536,
              6815744: 65540,
              7864320: 260,
              8912896: 4,
              9961472: 256,
              11010048: 67174400,
              12058624: 65796,
              13107200: 65792,
              14155776: 67109124,
              15204352: 67174660,
              16252928: 67108864,
              16777216: 67174656,
              17825792: 65540,
              18874368: 65536,
              19922944: 67109120,
              20971520: 256,
              22020096: 67174660,
              23068672: 67108868,
              24117248: 0,
              25165824: 67109124,
              26214400: 67108864,
              27262976: 4,
              28311552: 65792,
              29360128: 67174400,
              30408704: 260,
              31457280: 65796,
              32505856: 67174404,
              17301504: 67108864,
              18350080: 260,
              19398656: 67174656,
              20447232: 0,
              21495808: 65540,
              22544384: 67109120,
              23592960: 256,
              24641536: 67174404,
              25690112: 65536,
              26738688: 67174660,
              27787264: 65796,
              28835840: 67108868,
              29884416: 67109124,
              30932992: 67174400,
              31981568: 4,
              33030144: 65792
            },
            {
              0: 2151682048,
              65536: 2147487808,
              131072: 4198464,
              196608: 2151677952,
              262144: 0,
              327680: 4198400,
              393216: 2147483712,
              458752: 4194368,
              524288: 2147483648,
              589824: 4194304,
              655360: 64,
              720896: 2147487744,
              786432: 2151678016,
              851968: 4160,
              917504: 4096,
              983040: 2151682112,
              32768: 2147487808,
              98304: 64,
              163840: 2151678016,
              229376: 2147487744,
              294912: 4198400,
              360448: 2151682112,
              425984: 0,
              491520: 2151677952,
              557056: 4096,
              622592: 2151682048,
              688128: 4194304,
              753664: 4160,
              819200: 2147483648,
              884736: 4194368,
              950272: 4198464,
              1015808: 2147483712,
              1048576: 4194368,
              1114112: 4198400,
              1179648: 2147483712,
              1245184: 0,
              1310720: 4160,
              1376256: 2151678016,
              1441792: 2151682048,
              1507328: 2147487808,
              1572864: 2151682112,
              1638400: 2147483648,
              1703936: 2151677952,
              1769472: 4198464,
              1835008: 2147487744,
              1900544: 4194304,
              1966080: 64,
              2031616: 4096,
              1081344: 2151677952,
              1146880: 2151682112,
              1212416: 0,
              1277952: 4198400,
              1343488: 4194368,
              1409024: 2147483648,
              1474560: 2147487808,
              1540096: 64,
              1605632: 2147483712,
              1671168: 4096,
              1736704: 2147487744,
              1802240: 2151678016,
              1867776: 4160,
              1933312: 2151682048,
              1998848: 4194304,
              2064384: 4198464
            },
            {
              0: 128,
              4096: 17039360,
              8192: 262144,
              12288: 536870912,
              16384: 537133184,
              20480: 16777344,
              24576: 553648256,
              28672: 262272,
              32768: 16777216,
              36864: 537133056,
              40960: 536871040,
              45056: 553910400,
              49152: 553910272,
              53248: 0,
              57344: 17039488,
              61440: 553648128,
              2048: 17039488,
              6144: 553648256,
              10240: 128,
              14336: 17039360,
              18432: 262144,
              22528: 537133184,
              26624: 553910272,
              30720: 536870912,
              34816: 537133056,
              38912: 0,
              43008: 553910400,
              47104: 16777344,
              51200: 536871040,
              55296: 553648128,
              59392: 16777216,
              63488: 262272,
              65536: 262144,
              69632: 128,
              73728: 536870912,
              77824: 553648256,
              81920: 16777344,
              86016: 553910272,
              90112: 537133184,
              94208: 16777216,
              98304: 553910400,
              102400: 553648128,
              106496: 17039360,
              110592: 537133056,
              114688: 262272,
              118784: 536871040,
              122880: 0,
              126976: 17039488,
              67584: 553648256,
              71680: 16777216,
              75776: 17039360,
              79872: 537133184,
              83968: 536870912,
              88064: 17039488,
              92160: 128,
              96256: 553910272,
              100352: 262272,
              104448: 553910400,
              108544: 0,
              112640: 553648128,
              116736: 16777344,
              120832: 262144,
              124928: 537133056,
              129024: 536871040
            },
            {
              0: 268435464,
              256: 8192,
              512: 270532608,
              768: 270540808,
              1024: 268443648,
              1280: 2097152,
              1536: 2097160,
              1792: 268435456,
              2048: 0,
              2304: 268443656,
              2560: 2105344,
              2816: 8,
              3072: 270532616,
              3328: 2105352,
              3584: 8200,
              3840: 270540800,
              128: 270532608,
              384: 270540808,
              640: 8,
              896: 2097152,
              1152: 2105352,
              1408: 268435464,
              1664: 268443648,
              1920: 8200,
              2176: 2097160,
              2432: 8192,
              2688: 268443656,
              2944: 270532616,
              3200: 0,
              3456: 270540800,
              3712: 2105344,
              3968: 268435456,
              4096: 268443648,
              4352: 270532616,
              4608: 270540808,
              4864: 8200,
              5120: 2097152,
              5376: 268435456,
              5632: 268435464,
              5888: 2105344,
              6144: 2105352,
              6400: 0,
              6656: 8,
              6912: 270532608,
              7168: 8192,
              7424: 268443656,
              7680: 270540800,
              7936: 2097160,
              4224: 8,
              4480: 2105344,
              4736: 2097152,
              4992: 268435464,
              5248: 268443648,
              5504: 8200,
              5760: 270540808,
              6016: 270532608,
              6272: 270540800,
              6528: 270532616,
              6784: 8192,
              7040: 2105352,
              7296: 2097160,
              7552: 0,
              7808: 268435456,
              8064: 268443656
            },
            {
              0: 1048576,
              16: 33555457,
              32: 1024,
              48: 1049601,
              64: 34604033,
              80: 0,
              96: 1,
              112: 34603009,
              128: 33555456,
              144: 1048577,
              160: 33554433,
              176: 34604032,
              192: 34603008,
              208: 1025,
              224: 1049600,
              240: 33554432,
              8: 34603009,
              24: 0,
              40: 33555457,
              56: 34604032,
              72: 1048576,
              88: 33554433,
              104: 33554432,
              120: 1025,
              136: 1049601,
              152: 33555456,
              168: 34603008,
              184: 1048577,
              200: 1024,
              216: 34604033,
              232: 1,
              248: 1049600,
              256: 33554432,
              272: 1048576,
              288: 33555457,
              304: 34603009,
              320: 1048577,
              336: 33555456,
              352: 34604032,
              368: 1049601,
              384: 1025,
              400: 34604033,
              416: 1049600,
              432: 1,
              448: 0,
              464: 34603008,
              480: 33554433,
              496: 1024,
              264: 1049600,
              280: 33555457,
              296: 34603009,
              312: 1,
              328: 33554432,
              344: 1048576,
              360: 1025,
              376: 34604032,
              392: 33554433,
              408: 34603008,
              424: 0,
              440: 34604033,
              456: 1049601,
              472: 1024,
              488: 33555456,
              504: 1048577
            },
            {
              0: 134219808,
              1: 131072,
              2: 134217728,
              3: 32,
              4: 131104,
              5: 134350880,
              6: 134350848,
              7: 2048,
              8: 134348800,
              9: 134219776,
              10: 133120,
              11: 134348832,
              12: 2080,
              13: 0,
              14: 134217760,
              15: 133152,
              2147483648: 2048,
              2147483649: 134350880,
              2147483650: 134219808,
              2147483651: 134217728,
              2147483652: 134348800,
              2147483653: 133120,
              2147483654: 133152,
              2147483655: 32,
              2147483656: 134217760,
              2147483657: 2080,
              2147483658: 131104,
              2147483659: 134350848,
              2147483660: 0,
              2147483661: 134348832,
              2147483662: 134219776,
              2147483663: 131072,
              16: 133152,
              17: 134350848,
              18: 32,
              19: 2048,
              20: 134219776,
              21: 134217760,
              22: 134348832,
              23: 131072,
              24: 0,
              25: 131104,
              26: 134348800,
              27: 134219808,
              28: 134350880,
              29: 133120,
              30: 2080,
              31: 134217728,
              2147483664: 131072,
              2147483665: 2048,
              2147483666: 134348832,
              2147483667: 133152,
              2147483668: 32,
              2147483669: 134348800,
              2147483670: 134217728,
              2147483671: 134219808,
              2147483672: 134350880,
              2147483673: 134217760,
              2147483674: 134219776,
              2147483675: 0,
              2147483676: 133120,
              2147483677: 2080,
              2147483678: 131104,
              2147483679: 134350848
            }
          ];
          var SBOX_MASK = [
            4160749569,
            528482304,
            33030144,
            2064384,
            129024,
            8064,
            504,
            2147483679
          ];
          var DES = C_algo.DES = BlockCipher.extend({
            _doReset: function() {
              var key = this._key;
              var keyWords = key.words;
              var keyBits = [];
              for (var i2 = 0; i2 < 56; i2++) {
                var keyBitPos = PC1[i2] - 1;
                keyBits[i2] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
              }
              var subKeys = this._subKeys = [];
              for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
                var subKey = subKeys[nSubKey] = [];
                var bitShift = BIT_SHIFTS[nSubKey];
                for (var i2 = 0; i2 < 24; i2++) {
                  subKey[i2 / 6 | 0] |= keyBits[(PC2[i2] - 1 + bitShift) % 28] << 31 - i2 % 6;
                  subKey[4 + (i2 / 6 | 0)] |= keyBits[28 + (PC2[i2 + 24] - 1 + bitShift) % 28] << 31 - i2 % 6;
                }
                subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
                for (var i2 = 1; i2 < 7; i2++) {
                  subKey[i2] = subKey[i2] >>> (i2 - 1) * 4 + 3;
                }
                subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
              }
              var invSubKeys = this._invSubKeys = [];
              for (var i2 = 0; i2 < 16; i2++) {
                invSubKeys[i2] = subKeys[15 - i2];
              }
            },
            encryptBlock: function(M, offset) {
              this._doCryptBlock(M, offset, this._subKeys);
            },
            decryptBlock: function(M, offset) {
              this._doCryptBlock(M, offset, this._invSubKeys);
            },
            _doCryptBlock: function(M, offset, subKeys) {
              this._lBlock = M[offset];
              this._rBlock = M[offset + 1];
              exchangeLR.call(this, 4, 252645135);
              exchangeLR.call(this, 16, 65535);
              exchangeRL.call(this, 2, 858993459);
              exchangeRL.call(this, 8, 16711935);
              exchangeLR.call(this, 1, 1431655765);
              for (var round = 0; round < 16; round++) {
                var subKey = subKeys[round];
                var lBlock = this._lBlock;
                var rBlock = this._rBlock;
                var f2 = 0;
                for (var i2 = 0; i2 < 8; i2++) {
                  f2 |= SBOX_P[i2][((rBlock ^ subKey[i2]) & SBOX_MASK[i2]) >>> 0];
                }
                this._lBlock = rBlock;
                this._rBlock = lBlock ^ f2;
              }
              var t2 = this._lBlock;
              this._lBlock = this._rBlock;
              this._rBlock = t2;
              exchangeLR.call(this, 1, 1431655765);
              exchangeRL.call(this, 8, 16711935);
              exchangeRL.call(this, 2, 858993459);
              exchangeLR.call(this, 16, 65535);
              exchangeLR.call(this, 4, 252645135);
              M[offset] = this._lBlock;
              M[offset + 1] = this._rBlock;
            },
            keySize: 64 / 32,
            ivSize: 64 / 32,
            blockSize: 64 / 32
          });
          function exchangeLR(offset, mask) {
            var t2 = (this._lBlock >>> offset ^ this._rBlock) & mask;
            this._rBlock ^= t2;
            this._lBlock ^= t2 << offset;
          }
          function exchangeRL(offset, mask) {
            var t2 = (this._rBlock >>> offset ^ this._lBlock) & mask;
            this._lBlock ^= t2;
            this._rBlock ^= t2 << offset;
          }
          C.DES = BlockCipher._createHelper(DES);
          var TripleDES = C_algo.TripleDES = BlockCipher.extend({
            _doReset: function() {
              var key = this._key;
              var keyWords = key.words;
              if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
                throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
              }
              var key1 = keyWords.slice(0, 2);
              var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
              var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
              this._des1 = DES.createEncryptor(WordArray.create(key1));
              this._des2 = DES.createEncryptor(WordArray.create(key2));
              this._des3 = DES.createEncryptor(WordArray.create(key3));
            },
            encryptBlock: function(M, offset) {
              this._des1.encryptBlock(M, offset);
              this._des2.decryptBlock(M, offset);
              this._des3.encryptBlock(M, offset);
            },
            decryptBlock: function(M, offset) {
              this._des3.decryptBlock(M, offset);
              this._des2.encryptBlock(M, offset);
              this._des1.decryptBlock(M, offset);
            },
            keySize: 192 / 32,
            ivSize: 64 / 32,
            blockSize: 64 / 32
          });
          C.TripleDES = BlockCipher._createHelper(TripleDES);
        })();
        return CryptoJS.TripleDES;
      });
    })(tripledes);
    return tripledes.exports;
  }
  var rc4 = { exports: {} };
  var hasRequiredRc4;
  function requireRc4() {
    if (hasRequiredRc4)
      return rc4.exports;
    hasRequiredRc4 = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var StreamCipher = C_lib.StreamCipher;
          var C_algo = C.algo;
          var RC4 = C_algo.RC4 = StreamCipher.extend({
            _doReset: function() {
              var key = this._key;
              var keyWords = key.words;
              var keySigBytes = key.sigBytes;
              var S = this._S = [];
              for (var i2 = 0; i2 < 256; i2++) {
                S[i2] = i2;
              }
              for (var i2 = 0, j = 0; i2 < 256; i2++) {
                var keyByteIndex = i2 % keySigBytes;
                var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
                j = (j + S[i2] + keyByte) % 256;
                var t2 = S[i2];
                S[i2] = S[j];
                S[j] = t2;
              }
              this._i = this._j = 0;
            },
            _doProcessBlock: function(M, offset) {
              M[offset] ^= generateKeystreamWord.call(this);
            },
            keySize: 256 / 32,
            ivSize: 0
          });
          function generateKeystreamWord() {
            var S = this._S;
            var i2 = this._i;
            var j = this._j;
            var keystreamWord = 0;
            for (var n2 = 0; n2 < 4; n2++) {
              i2 = (i2 + 1) % 256;
              j = (j + S[i2]) % 256;
              var t2 = S[i2];
              S[i2] = S[j];
              S[j] = t2;
              keystreamWord |= S[(S[i2] + S[j]) % 256] << 24 - n2 * 8;
            }
            this._i = i2;
            this._j = j;
            return keystreamWord;
          }
          C.RC4 = StreamCipher._createHelper(RC4);
          var RC4Drop = C_algo.RC4Drop = RC4.extend({
            /**
             * Configuration options.
             *
             * @property {number} drop The number of keystream words to drop. Default 192
             */
            cfg: RC4.cfg.extend({
              drop: 192
            }),
            _doReset: function() {
              RC4._doReset.call(this);
              for (var i2 = this.cfg.drop; i2 > 0; i2--) {
                generateKeystreamWord.call(this);
              }
            }
          });
          C.RC4Drop = StreamCipher._createHelper(RC4Drop);
        })();
        return CryptoJS.RC4;
      });
    })(rc4);
    return rc4.exports;
  }
  var rabbit = { exports: {} };
  var hasRequiredRabbit;
  function requireRabbit() {
    if (hasRequiredRabbit)
      return rabbit.exports;
    hasRequiredRabbit = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var StreamCipher = C_lib.StreamCipher;
          var C_algo = C.algo;
          var S = [];
          var C_ = [];
          var G = [];
          var Rabbit = C_algo.Rabbit = StreamCipher.extend({
            _doReset: function() {
              var K = this._key.words;
              var iv = this.cfg.iv;
              for (var i2 = 0; i2 < 4; i2++) {
                K[i2] = (K[i2] << 8 | K[i2] >>> 24) & 16711935 | (K[i2] << 24 | K[i2] >>> 8) & 4278255360;
              }
              var X = this._X = [
                K[0],
                K[3] << 16 | K[2] >>> 16,
                K[1],
                K[0] << 16 | K[3] >>> 16,
                K[2],
                K[1] << 16 | K[0] >>> 16,
                K[3],
                K[2] << 16 | K[1] >>> 16
              ];
              var C2 = this._C = [
                K[2] << 16 | K[2] >>> 16,
                K[0] & 4294901760 | K[1] & 65535,
                K[3] << 16 | K[3] >>> 16,
                K[1] & 4294901760 | K[2] & 65535,
                K[0] << 16 | K[0] >>> 16,
                K[2] & 4294901760 | K[3] & 65535,
                K[1] << 16 | K[1] >>> 16,
                K[3] & 4294901760 | K[0] & 65535
              ];
              this._b = 0;
              for (var i2 = 0; i2 < 4; i2++) {
                nextState.call(this);
              }
              for (var i2 = 0; i2 < 8; i2++) {
                C2[i2] ^= X[i2 + 4 & 7];
              }
              if (iv) {
                var IV2 = iv.words;
                var IV_0 = IV2[0];
                var IV_1 = IV2[1];
                var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
                var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
                var i1 = i0 >>> 16 | i22 & 4294901760;
                var i3 = i22 << 16 | i0 & 65535;
                C2[0] ^= i0;
                C2[1] ^= i1;
                C2[2] ^= i22;
                C2[3] ^= i3;
                C2[4] ^= i0;
                C2[5] ^= i1;
                C2[6] ^= i22;
                C2[7] ^= i3;
                for (var i2 = 0; i2 < 4; i2++) {
                  nextState.call(this);
                }
              }
            },
            _doProcessBlock: function(M, offset) {
              var X = this._X;
              nextState.call(this);
              S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
              S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
              S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
              S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
              for (var i2 = 0; i2 < 4; i2++) {
                S[i2] = (S[i2] << 8 | S[i2] >>> 24) & 16711935 | (S[i2] << 24 | S[i2] >>> 8) & 4278255360;
                M[offset + i2] ^= S[i2];
              }
            },
            blockSize: 128 / 32,
            ivSize: 64 / 32
          });
          function nextState() {
            var X = this._X;
            var C2 = this._C;
            for (var i2 = 0; i2 < 8; i2++) {
              C_[i2] = C2[i2];
            }
            C2[0] = C2[0] + 1295307597 + this._b | 0;
            C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
            C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
            C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
            C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
            C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
            C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
            C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
            this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
            for (var i2 = 0; i2 < 8; i2++) {
              var gx = X[i2] + C2[i2];
              var ga = gx & 65535;
              var gb = gx >>> 16;
              var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
              var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
              G[i2] = gh ^ gl;
            }
            X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
            X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
            X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
            X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
            X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
            X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
            X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
            X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
          }
          C.Rabbit = StreamCipher._createHelper(Rabbit);
        })();
        return CryptoJS.Rabbit;
      });
    })(rabbit);
    return rabbit.exports;
  }
  var rabbitLegacy = { exports: {} };
  var hasRequiredRabbitLegacy;
  function requireRabbitLegacy() {
    if (hasRequiredRabbitLegacy)
      return rabbitLegacy.exports;
    hasRequiredRabbitLegacy = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var StreamCipher = C_lib.StreamCipher;
          var C_algo = C.algo;
          var S = [];
          var C_ = [];
          var G = [];
          var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
            _doReset: function() {
              var K = this._key.words;
              var iv = this.cfg.iv;
              var X = this._X = [
                K[0],
                K[3] << 16 | K[2] >>> 16,
                K[1],
                K[0] << 16 | K[3] >>> 16,
                K[2],
                K[1] << 16 | K[0] >>> 16,
                K[3],
                K[2] << 16 | K[1] >>> 16
              ];
              var C2 = this._C = [
                K[2] << 16 | K[2] >>> 16,
                K[0] & 4294901760 | K[1] & 65535,
                K[3] << 16 | K[3] >>> 16,
                K[1] & 4294901760 | K[2] & 65535,
                K[0] << 16 | K[0] >>> 16,
                K[2] & 4294901760 | K[3] & 65535,
                K[1] << 16 | K[1] >>> 16,
                K[3] & 4294901760 | K[0] & 65535
              ];
              this._b = 0;
              for (var i2 = 0; i2 < 4; i2++) {
                nextState.call(this);
              }
              for (var i2 = 0; i2 < 8; i2++) {
                C2[i2] ^= X[i2 + 4 & 7];
              }
              if (iv) {
                var IV2 = iv.words;
                var IV_0 = IV2[0];
                var IV_1 = IV2[1];
                var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
                var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
                var i1 = i0 >>> 16 | i22 & 4294901760;
                var i3 = i22 << 16 | i0 & 65535;
                C2[0] ^= i0;
                C2[1] ^= i1;
                C2[2] ^= i22;
                C2[3] ^= i3;
                C2[4] ^= i0;
                C2[5] ^= i1;
                C2[6] ^= i22;
                C2[7] ^= i3;
                for (var i2 = 0; i2 < 4; i2++) {
                  nextState.call(this);
                }
              }
            },
            _doProcessBlock: function(M, offset) {
              var X = this._X;
              nextState.call(this);
              S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
              S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
              S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
              S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
              for (var i2 = 0; i2 < 4; i2++) {
                S[i2] = (S[i2] << 8 | S[i2] >>> 24) & 16711935 | (S[i2] << 24 | S[i2] >>> 8) & 4278255360;
                M[offset + i2] ^= S[i2];
              }
            },
            blockSize: 128 / 32,
            ivSize: 64 / 32
          });
          function nextState() {
            var X = this._X;
            var C2 = this._C;
            for (var i2 = 0; i2 < 8; i2++) {
              C_[i2] = C2[i2];
            }
            C2[0] = C2[0] + 1295307597 + this._b | 0;
            C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
            C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
            C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
            C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
            C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
            C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
            C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
            this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
            for (var i2 = 0; i2 < 8; i2++) {
              var gx = X[i2] + C2[i2];
              var ga = gx & 65535;
              var gb = gx >>> 16;
              var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
              var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
              G[i2] = gh ^ gl;
            }
            X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
            X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
            X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
            X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
            X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
            X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
            X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
            X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
          }
          C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
        })();
        return CryptoJS.RabbitLegacy;
      });
    })(rabbitLegacy);
    return rabbitLegacy.exports;
  }
  var blowfish = { exports: {} };
  var hasRequiredBlowfish;
  function requireBlowfish() {
    if (hasRequiredBlowfish)
      return blowfish.exports;
    hasRequiredBlowfish = 1;
    (function(module2, exports3) {
      (function(root2, factory2, undef) {
        {
          module2.exports = factory2(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
        }
      })(commonjsGlobal, function(CryptoJS) {
        (function() {
          var C = CryptoJS;
          var C_lib = C.lib;
          var BlockCipher = C_lib.BlockCipher;
          var C_algo = C.algo;
          const N = 16;
          const ORIG_P = [
            608135816,
            2242054355,
            320440878,
            57701188,
            2752067618,
            698298832,
            137296536,
            3964562569,
            1160258022,
            953160567,
            3193202383,
            887688300,
            3232508343,
            3380367581,
            1065670069,
            3041331479,
            2450970073,
            2306472731
          ];
          const ORIG_S = [
            [
              3509652390,
              2564797868,
              805139163,
              3491422135,
              3101798381,
              1780907670,
              3128725573,
              4046225305,
              614570311,
              3012652279,
              134345442,
              2240740374,
              1667834072,
              1901547113,
              2757295779,
              4103290238,
              227898511,
              1921955416,
              1904987480,
              2182433518,
              2069144605,
              3260701109,
              2620446009,
              720527379,
              3318853667,
              677414384,
              3393288472,
              3101374703,
              2390351024,
              1614419982,
              1822297739,
              2954791486,
              3608508353,
              3174124327,
              2024746970,
              1432378464,
              3864339955,
              2857741204,
              1464375394,
              1676153920,
              1439316330,
              715854006,
              3033291828,
              289532110,
              2706671279,
              2087905683,
              3018724369,
              1668267050,
              732546397,
              1947742710,
              3462151702,
              2609353502,
              2950085171,
              1814351708,
              2050118529,
              680887927,
              999245976,
              1800124847,
              3300911131,
              1713906067,
              1641548236,
              4213287313,
              1216130144,
              1575780402,
              4018429277,
              3917837745,
              3693486850,
              3949271944,
              596196993,
              3549867205,
              258830323,
              2213823033,
              772490370,
              2760122372,
              1774776394,
              2652871518,
              566650946,
              4142492826,
              1728879713,
              2882767088,
              1783734482,
              3629395816,
              2517608232,
              2874225571,
              1861159788,
              326777828,
              3124490320,
              2130389656,
              2716951837,
              967770486,
              1724537150,
              2185432712,
              2364442137,
              1164943284,
              2105845187,
              998989502,
              3765401048,
              2244026483,
              1075463327,
              1455516326,
              1322494562,
              910128902,
              469688178,
              1117454909,
              936433444,
              3490320968,
              3675253459,
              1240580251,
              122909385,
              2157517691,
              634681816,
              4142456567,
              3825094682,
              3061402683,
              2540495037,
              79693498,
              3249098678,
              1084186820,
              1583128258,
              426386531,
              1761308591,
              1047286709,
              322548459,
              995290223,
              1845252383,
              2603652396,
              3431023940,
              2942221577,
              3202600964,
              3727903485,
              1712269319,
              422464435,
              3234572375,
              1170764815,
              3523960633,
              3117677531,
              1434042557,
              442511882,
              3600875718,
              1076654713,
              1738483198,
              4213154764,
              2393238008,
              3677496056,
              1014306527,
              4251020053,
              793779912,
              2902807211,
              842905082,
              4246964064,
              1395751752,
              1040244610,
              2656851899,
              3396308128,
              445077038,
              3742853595,
              3577915638,
              679411651,
              2892444358,
              2354009459,
              1767581616,
              3150600392,
              3791627101,
              3102740896,
              284835224,
              4246832056,
              1258075500,
              768725851,
              2589189241,
              3069724005,
              3532540348,
              1274779536,
              3789419226,
              2764799539,
              1660621633,
              3471099624,
              4011903706,
              913787905,
              3497959166,
              737222580,
              2514213453,
              2928710040,
              3937242737,
              1804850592,
              3499020752,
              2949064160,
              2386320175,
              2390070455,
              2415321851,
              4061277028,
              2290661394,
              2416832540,
              1336762016,
              1754252060,
              3520065937,
              3014181293,
              791618072,
              3188594551,
              3933548030,
              2332172193,
              3852520463,
              3043980520,
              413987798,
              3465142937,
              3030929376,
              4245938359,
              2093235073,
              3534596313,
              375366246,
              2157278981,
              2479649556,
              555357303,
              3870105701,
              2008414854,
              3344188149,
              4221384143,
              3956125452,
              2067696032,
              3594591187,
              2921233993,
              2428461,
              544322398,
              577241275,
              1471733935,
              610547355,
              4027169054,
              1432588573,
              1507829418,
              2025931657,
              3646575487,
              545086370,
              48609733,
              2200306550,
              1653985193,
              298326376,
              1316178497,
              3007786442,
              2064951626,
              458293330,
              2589141269,
              3591329599,
              3164325604,
              727753846,
              2179363840,
              146436021,
              1461446943,
              4069977195,
              705550613,
              3059967265,
              3887724982,
              4281599278,
              3313849956,
              1404054877,
              2845806497,
              146425753,
              1854211946
            ],
            [
              1266315497,
              3048417604,
              3681880366,
              3289982499,
              290971e4,
              1235738493,
              2632868024,
              2414719590,
              3970600049,
              1771706367,
              1449415276,
              3266420449,
              422970021,
              1963543593,
              2690192192,
              3826793022,
              1062508698,
              1531092325,
              1804592342,
              2583117782,
              2714934279,
              4024971509,
              1294809318,
              4028980673,
              1289560198,
              2221992742,
              1669523910,
              35572830,
              157838143,
              1052438473,
              1016535060,
              1802137761,
              1753167236,
              1386275462,
              3080475397,
              2857371447,
              1040679964,
              2145300060,
              2390574316,
              1461121720,
              2956646967,
              4031777805,
              4028374788,
              33600511,
              2920084762,
              1018524850,
              629373528,
              3691585981,
              3515945977,
              2091462646,
              2486323059,
              586499841,
              988145025,
              935516892,
              3367335476,
              2599673255,
              2839830854,
              265290510,
              3972581182,
              2759138881,
              3795373465,
              1005194799,
              847297441,
              406762289,
              1314163512,
              1332590856,
              1866599683,
              4127851711,
              750260880,
              613907577,
              1450815602,
              3165620655,
              3734664991,
              3650291728,
              3012275730,
              3704569646,
              1427272223,
              778793252,
              1343938022,
              2676280711,
              2052605720,
              1946737175,
              3164576444,
              3914038668,
              3967478842,
              3682934266,
              1661551462,
              3294938066,
              4011595847,
              840292616,
              3712170807,
              616741398,
              312560963,
              711312465,
              1351876610,
              322626781,
              1910503582,
              271666773,
              2175563734,
              1594956187,
              70604529,
              3617834859,
              1007753275,
              1495573769,
              4069517037,
              2549218298,
              2663038764,
              504708206,
              2263041392,
              3941167025,
              2249088522,
              1514023603,
              1998579484,
              1312622330,
              694541497,
              2582060303,
              2151582166,
              1382467621,
              776784248,
              2618340202,
              3323268794,
              2497899128,
              2784771155,
              503983604,
              4076293799,
              907881277,
              423175695,
              432175456,
              1378068232,
              4145222326,
              3954048622,
              3938656102,
              3820766613,
              2793130115,
              2977904593,
              26017576,
              3274890735,
              3194772133,
              1700274565,
              1756076034,
              4006520079,
              3677328699,
              720338349,
              1533947780,
              354530856,
              688349552,
              3973924725,
              1637815568,
              332179504,
              3949051286,
              53804574,
              2852348879,
              3044236432,
              1282449977,
              3583942155,
              3416972820,
              4006381244,
              1617046695,
              2628476075,
              3002303598,
              1686838959,
              431878346,
              2686675385,
              1700445008,
              1080580658,
              1009431731,
              832498133,
              3223435511,
              2605976345,
              2271191193,
              2516031870,
              1648197032,
              4164389018,
              2548247927,
              300782431,
              375919233,
              238389289,
              3353747414,
              2531188641,
              2019080857,
              1475708069,
              455242339,
              2609103871,
              448939670,
              3451063019,
              1395535956,
              2413381860,
              1841049896,
              1491858159,
              885456874,
              4264095073,
              4001119347,
              1565136089,
              3898914787,
              1108368660,
              540939232,
              1173283510,
              2745871338,
              3681308437,
              4207628240,
              3343053890,
              4016749493,
              1699691293,
              1103962373,
              3625875870,
              2256883143,
              3830138730,
              1031889488,
              3479347698,
              1535977030,
              4236805024,
              3251091107,
              2132092099,
              1774941330,
              1199868427,
              1452454533,
              157007616,
              2904115357,
              342012276,
              595725824,
              1480756522,
              206960106,
              497939518,
              591360097,
              863170706,
              2375253569,
              3596610801,
              1814182875,
              2094937945,
              3421402208,
              1082520231,
              3463918190,
              2785509508,
              435703966,
              3908032597,
              1641649973,
              2842273706,
              3305899714,
              1510255612,
              2148256476,
              2655287854,
              3276092548,
              4258621189,
              236887753,
              3681803219,
              274041037,
              1734335097,
              3815195456,
              3317970021,
              1899903192,
              1026095262,
              4050517792,
              356393447,
              2410691914,
              3873677099,
              3682840055
            ],
            [
              3913112168,
              2491498743,
              4132185628,
              2489919796,
              1091903735,
              1979897079,
              3170134830,
              3567386728,
              3557303409,
              857797738,
              1136121015,
              1342202287,
              507115054,
              2535736646,
              337727348,
              3213592640,
              1301675037,
              2528481711,
              1895095763,
              1721773893,
              3216771564,
              62756741,
              2142006736,
              835421444,
              2531993523,
              1442658625,
              3659876326,
              2882144922,
              676362277,
              1392781812,
              170690266,
              3921047035,
              1759253602,
              3611846912,
              1745797284,
              664899054,
              1329594018,
              3901205900,
              3045908486,
              2062866102,
              2865634940,
              3543621612,
              3464012697,
              1080764994,
              553557557,
              3656615353,
              3996768171,
              991055499,
              499776247,
              1265440854,
              648242737,
              3940784050,
              980351604,
              3713745714,
              1749149687,
              3396870395,
              4211799374,
              3640570775,
              1161844396,
              3125318951,
              1431517754,
              545492359,
              4268468663,
              3499529547,
              1437099964,
              2702547544,
              3433638243,
              2581715763,
              2787789398,
              1060185593,
              1593081372,
              2418618748,
              4260947970,
              69676912,
              2159744348,
              86519011,
              2512459080,
              3838209314,
              1220612927,
              3339683548,
              133810670,
              1090789135,
              1078426020,
              1569222167,
              845107691,
              3583754449,
              4072456591,
              1091646820,
              628848692,
              1613405280,
              3757631651,
              526609435,
              236106946,
              48312990,
              2942717905,
              3402727701,
              1797494240,
              859738849,
              992217954,
              4005476642,
              2243076622,
              3870952857,
              3732016268,
              765654824,
              3490871365,
              2511836413,
              1685915746,
              3888969200,
              1414112111,
              2273134842,
              3281911079,
              4080962846,
              172450625,
              2569994100,
              980381355,
              4109958455,
              2819808352,
              2716589560,
              2568741196,
              3681446669,
              3329971472,
              1835478071,
              660984891,
              3704678404,
              4045999559,
              3422617507,
              3040415634,
              1762651403,
              1719377915,
              3470491036,
              2693910283,
              3642056355,
              3138596744,
              1364962596,
              2073328063,
              1983633131,
              926494387,
              3423689081,
              2150032023,
              4096667949,
              1749200295,
              3328846651,
              309677260,
              2016342300,
              1779581495,
              3079819751,
              111262694,
              1274766160,
              443224088,
              298511866,
              1025883608,
              3806446537,
              1145181785,
              168956806,
              3641502830,
              3584813610,
              1689216846,
              3666258015,
              3200248200,
              1692713982,
              2646376535,
              4042768518,
              1618508792,
              1610833997,
              3523052358,
              4130873264,
              2001055236,
              3610705100,
              2202168115,
              4028541809,
              2961195399,
              1006657119,
              2006996926,
              3186142756,
              1430667929,
              3210227297,
              1314452623,
              4074634658,
              4101304120,
              2273951170,
              1399257539,
              3367210612,
              3027628629,
              1190975929,
              2062231137,
              2333990788,
              2221543033,
              2438960610,
              1181637006,
              548689776,
              2362791313,
              3372408396,
              3104550113,
              3145860560,
              296247880,
              1970579870,
              3078560182,
              3769228297,
              1714227617,
              3291629107,
              3898220290,
              166772364,
              1251581989,
              493813264,
              448347421,
              195405023,
              2709975567,
              677966185,
              3703036547,
              1463355134,
              2715995803,
              1338867538,
              1343315457,
              2802222074,
              2684532164,
              233230375,
              2599980071,
              2000651841,
              3277868038,
              1638401717,
              4028070440,
              3237316320,
              6314154,
              819756386,
              300326615,
              590932579,
              1405279636,
              3267499572,
              3150704214,
              2428286686,
              3959192993,
              3461946742,
              1862657033,
              1266418056,
              963775037,
              2089974820,
              2263052895,
              1917689273,
              448879540,
              3550394620,
              3981727096,
              150775221,
              3627908307,
              1303187396,
              508620638,
              2975983352,
              2726630617,
              1817252668,
              1876281319,
              1457606340,
              908771278,
              3720792119,
              3617206836,
              2455994898,
              1729034894,
              1080033504
            ],
            [
              976866871,
              3556439503,
              2881648439,
              1522871579,
              1555064734,
              1336096578,
              3548522304,
              2579274686,
              3574697629,
              3205460757,
              3593280638,
              3338716283,
              3079412587,
              564236357,
              2993598910,
              1781952180,
              1464380207,
              3163844217,
              3332601554,
              1699332808,
              1393555694,
              1183702653,
              3581086237,
              1288719814,
              691649499,
              2847557200,
              2895455976,
              3193889540,
              2717570544,
              1781354906,
              1676643554,
              2592534050,
              3230253752,
              1126444790,
              2770207658,
              2633158820,
              2210423226,
              2615765581,
              2414155088,
              3127139286,
              673620729,
              2805611233,
              1269405062,
              4015350505,
              3341807571,
              4149409754,
              1057255273,
              2012875353,
              2162469141,
              2276492801,
              2601117357,
              993977747,
              3918593370,
              2654263191,
              753973209,
              36408145,
              2530585658,
              25011837,
              3520020182,
              2088578344,
              530523599,
              2918365339,
              1524020338,
              1518925132,
              3760827505,
              3759777254,
              1202760957,
              3985898139,
              3906192525,
              674977740,
              4174734889,
              2031300136,
              2019492241,
              3983892565,
              4153806404,
              3822280332,
              352677332,
              2297720250,
              60907813,
              90501309,
              3286998549,
              1016092578,
              2535922412,
              2839152426,
              457141659,
              509813237,
              4120667899,
              652014361,
              1966332200,
              2975202805,
              55981186,
              2327461051,
              676427537,
              3255491064,
              2882294119,
              3433927263,
              1307055953,
              942726286,
              933058658,
              2468411793,
              3933900994,
              4215176142,
              1361170020,
              2001714738,
              2830558078,
              3274259782,
              1222529897,
              1679025792,
              2729314320,
              3714953764,
              1770335741,
              151462246,
              3013232138,
              1682292957,
              1483529935,
              471910574,
              1539241949,
              458788160,
              3436315007,
              1807016891,
              3718408830,
              978976581,
              1043663428,
              3165965781,
              1927990952,
              4200891579,
              2372276910,
              3208408903,
              3533431907,
              1412390302,
              2931980059,
              4132332400,
              1947078029,
              3881505623,
              4168226417,
              2941484381,
              1077988104,
              1320477388,
              886195818,
              18198404,
              3786409e3,
              2509781533,
              112762804,
              3463356488,
              1866414978,
              891333506,
              18488651,
              661792760,
              1628790961,
              3885187036,
              3141171499,
              876946877,
              2693282273,
              1372485963,
              791857591,
              2686433993,
              3759982718,
              3167212022,
              3472953795,
              2716379847,
              445679433,
              3561995674,
              3504004811,
              3574258232,
              54117162,
              3331405415,
              2381918588,
              3769707343,
              4154350007,
              1140177722,
              4074052095,
              668550556,
              3214352940,
              367459370,
              261225585,
              2610173221,
              4209349473,
              3468074219,
              3265815641,
              314222801,
              3066103646,
              3808782860,
              282218597,
              3406013506,
              3773591054,
              379116347,
              1285071038,
              846784868,
              2669647154,
              3771962079,
              3550491691,
              2305946142,
              453669953,
              1268987020,
              3317592352,
              3279303384,
              3744833421,
              2610507566,
              3859509063,
              266596637,
              3847019092,
              517658769,
              3462560207,
              3443424879,
              370717030,
              4247526661,
              2224018117,
              4143653529,
              4112773975,
              2788324899,
              2477274417,
              1456262402,
              2901442914,
              1517677493,
              1846949527,
              2295493580,
              3734397586,
              2176403920,
              1280348187,
              1908823572,
              3871786941,
              846861322,
              1172426758,
              3287448474,
              3383383037,
              1655181056,
              3139813346,
              901632758,
              1897031941,
              2986607138,
              3066810236,
              3447102507,
              1393639104,
              373351379,
              950779232,
              625454576,
              3124240540,
              4148612726,
              2007998917,
              544563296,
              2244738638,
              2330496472,
              2058025392,
              1291430526,
              424198748,
              50039436,
              29584100,
              3605783033,
              2429876329,
              2791104160,
              1057563949,
              3255363231,
              3075367218,
              3463963227,
              1469046755,
              985887462
            ]
          ];
          var BLOWFISH_CTX = {
            pbox: [],
            sbox: []
          };
          function F2(ctx, x2) {
            let a = x2 >> 24 & 255;
            let b = x2 >> 16 & 255;
            let c = x2 >> 8 & 255;
            let d = x2 & 255;
            let y = ctx.sbox[0][a] + ctx.sbox[1][b];
            y = y ^ ctx.sbox[2][c];
            y = y + ctx.sbox[3][d];
            return y;
          }
          function BlowFish_Encrypt(ctx, left, right) {
            let Xl = left;
            let Xr = right;
            let temp;
            for (let i2 = 0; i2 < N; ++i2) {
              Xl = Xl ^ ctx.pbox[i2];
              Xr = F2(ctx, Xl) ^ Xr;
              temp = Xl;
              Xl = Xr;
              Xr = temp;
            }
            temp = Xl;
            Xl = Xr;
            Xr = temp;
            Xr = Xr ^ ctx.pbox[N];
            Xl = Xl ^ ctx.pbox[N + 1];
            return { left: Xl, right: Xr };
          }
          function BlowFish_Decrypt(ctx, left, right) {
            let Xl = left;
            let Xr = right;
            let temp;
            for (let i2 = N + 1; i2 > 1; --i2) {
              Xl = Xl ^ ctx.pbox[i2];
              Xr = F2(ctx, Xl) ^ Xr;
              temp = Xl;
              Xl = Xr;
              Xr = temp;
            }
            temp = Xl;
            Xl = Xr;
            Xr = temp;
            Xr = Xr ^ ctx.pbox[1];
            Xl = Xl ^ ctx.pbox[0];
            return { left: Xl, right: Xr };
          }
          function BlowFishInit(ctx, key, keysize) {
            for (let Row = 0; Row < 4; Row++) {
              ctx.sbox[Row] = [];
              for (let Col = 0; Col < 256; Col++) {
                ctx.sbox[Row][Col] = ORIG_S[Row][Col];
              }
            }
            let keyIndex = 0;
            for (let index2 = 0; index2 < N + 2; index2++) {
              ctx.pbox[index2] = ORIG_P[index2] ^ key[keyIndex];
              keyIndex++;
              if (keyIndex >= keysize) {
                keyIndex = 0;
              }
            }
            let Data1 = 0;
            let Data2 = 0;
            let res = 0;
            for (let i2 = 0; i2 < N + 2; i2 += 2) {
              res = BlowFish_Encrypt(ctx, Data1, Data2);
              Data1 = res.left;
              Data2 = res.right;
              ctx.pbox[i2] = Data1;
              ctx.pbox[i2 + 1] = Data2;
            }
            for (let i2 = 0; i2 < 4; i2++) {
              for (let j = 0; j < 256; j += 2) {
                res = BlowFish_Encrypt(ctx, Data1, Data2);
                Data1 = res.left;
                Data2 = res.right;
                ctx.sbox[i2][j] = Data1;
                ctx.sbox[i2][j + 1] = Data2;
              }
            }
            return true;
          }
          var Blowfish = C_algo.Blowfish = BlockCipher.extend({
            _doReset: function() {
              if (this._keyPriorReset === this._key) {
                return;
              }
              var key = this._keyPriorReset = this._key;
              var keyWords = key.words;
              var keySize = key.sigBytes / 4;
              BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
            },
            encryptBlock: function(M, offset) {
              var res = BlowFish_Encrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
              M[offset] = res.left;
              M[offset + 1] = res.right;
            },
            decryptBlock: function(M, offset) {
              var res = BlowFish_Decrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
              M[offset] = res.left;
              M[offset + 1] = res.right;
            },
            blockSize: 64 / 32,
            keySize: 128 / 32,
            ivSize: 64 / 32
          });
          C.Blowfish = BlockCipher._createHelper(Blowfish);
        })();
        return CryptoJS.Blowfish;
      });
    })(blowfish);
    return blowfish.exports;
  }
  (function(module2, exports3) {
    (function(root2, factory2, undef) {
      {
        module2.exports = factory2(requireCore(), requireX64Core(), requireLibTypedarrays(), requireEncUtf16(), requireEncBase64(), requireEncBase64url(), requireMd5(), requireSha1(), sha256Exports, requireSha224(), requireSha512(), requireSha384(), requireSha3(), ripemd160Exports, requireHmac(), requirePbkdf2(), requireEvpkdf(), requireCipherCore(), requireModeCfb(), requireModeCtr(), requireModeCtrGladman(), requireModeOfb(), requireModeEcb(), requirePadAnsix923(), requirePadIso10126(), requirePadIso97971(), requirePadZeropadding(), requirePadNopadding(), requireFormatHex(), requireAes(), requireTripledes(), requireRc4(), requireRabbit(), requireRabbitLegacy(), requireBlowfish());
      }
    })(commonjsGlobal, function(CryptoJS) {
      return CryptoJS;
    });
  })(cryptoJs);
  var ALPHABET$2 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
  var ALPHABET_MAP = {};
  for (var z = 0; z < ALPHABET$2.length; z++) {
    var x = ALPHABET$2.charAt(z);
    if (ALPHABET_MAP[x] !== void 0)
      throw new TypeError(x + " is ambiguous");
    ALPHABET_MAP[x] = z;
  }
  var sha256$1 = {};
  var _sha2 = {};
  var _assert = {};
  Object.defineProperty(_assert, "__esModule", { value: true });
  _assert.output = _assert.exists = _assert.hash = _assert.bytes = _assert.bool = _assert.number = void 0;
  function number(n2) {
    if (!Number.isSafeInteger(n2) || n2 < 0)
      throw new Error(`Wrong positive integer: ${n2}`);
  }
  _assert.number = number;
  function bool$1(b) {
    if (typeof b !== "boolean")
      throw new Error(`Expected boolean, not ${b}`);
  }
  _assert.bool = bool$1;
  function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
  }
  _assert.bytes = bytes;
  function hash(hash2) {
    if (typeof hash2 !== "function" || typeof hash2.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(hash2.outputLen);
    number(hash2.blockLen);
  }
  _assert.hash = hash;
  function exists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  _assert.exists = exists;
  function output(out, instance) {
    bytes(out);
    const min2 = instance.outputLen;
    if (out.length < min2) {
      throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
    }
  }
  _assert.output = output;
  const assert$1 = { number, bool: bool$1, bytes, hash, exists, output };
  _assert.default = assert$1;
  var utils$a = {};
  var crypto$1 = {};
  Object.defineProperty(crypto$1, "__esModule", { value: true });
  crypto$1.crypto = void 0;
  crypto$1.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  (function(exports3) {
    /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.randomBytes = exports3.wrapXOFConstructorWithOpts = exports3.wrapConstructorWithOpts = exports3.wrapConstructor = exports3.checkOpts = exports3.Hash = exports3.concatBytes = exports3.toBytes = exports3.utf8ToBytes = exports3.asyncLoop = exports3.nextTick = exports3.hexToBytes = exports3.bytesToHex = exports3.isLE = exports3.rotr = exports3.createView = exports3.u32 = exports3.u8 = void 0;
    const crypto_1 = crypto$1;
    const u8a = (a) => a instanceof Uint8Array;
    const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports3.u8 = u8;
    const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports3.u32 = u32;
    const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports3.createView = createView;
    const rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports3.rotr = rotr;
    exports3.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports3.isLE)
      throw new Error("Non little-endian hardware is not supported");
    const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
    function bytesToHex(bytes2) {
      if (!u8a(bytes2))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i2 = 0; i2 < bytes2.length; i2++) {
        hex += hexes[bytes2[i2]];
      }
      return hex;
    }
    exports3.bytesToHex = bytesToHex;
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const len2 = hex.length;
      if (len2 % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + len2);
      const array = new Uint8Array(len2 / 2);
      for (let i2 = 0; i2 < array.length; i2++) {
        const j = i2 * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i2] = byte;
      }
      return array;
    }
    exports3.hexToBytes = hexToBytes;
    const nextTick = async () => {
    };
    exports3.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i2 = 0; i2 < iters; i2++) {
        cb(i2);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports3.nextTick)();
        ts += diff;
      }
    }
    exports3.asyncLoop = asyncLoop;
    function utf8ToBytes(str2) {
      if (typeof str2 !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str2}`);
      return new Uint8Array(new TextEncoder().encode(str2));
    }
    exports3.utf8ToBytes = utf8ToBytes;
    function toBytes(data2) {
      if (typeof data2 === "string")
        data2 = utf8ToBytes(data2);
      if (!u8a(data2))
        throw new Error(`expected Uint8Array, got ${typeof data2}`);
      return data2;
    }
    exports3.toBytes = toBytes;
    function concatBytes(...arrays) {
      const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
      let pad2 = 0;
      arrays.forEach((a) => {
        if (!u8a(a))
          throw new Error("Uint8Array expected");
        r.set(a, pad2);
        pad2 += a.length;
      });
      return r;
    }
    exports3.concatBytes = concatBytes;
    class Hash2 {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    }
    exports3.Hash = Hash2;
    const toStr2 = {}.toString;
    function checkOpts(defaults2, opts) {
      if (opts !== void 0 && toStr2.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults2, opts);
      return merged;
    }
    exports3.checkOpts = checkOpts;
    function wrapConstructor2(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports3.wrapConstructor = wrapConstructor2;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports3.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports3.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports3.randomBytes = randomBytes;
  })(utils$a);
  Object.defineProperty(_sha2, "__esModule", { value: true });
  _sha2.SHA2 = void 0;
  const _assert_js_1 = _assert;
  const utils_js_1$1 = utils$a;
  function setBigUint64(view, byteOffset, value2, isLE) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value2, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value2 >> _32n & _u32_max);
    const wl = Number(value2 & _u32_max);
    const h = isLE ? 4 : 0;
    const l2 = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l2, wl, isLE);
  }
  class SHA2 extends utils_js_1$1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = (0, utils_js_1$1.createView)(this.buffer);
    }
    update(data2) {
      (0, _assert_js_1.exists)(this);
      const { view, buffer: buffer2, blockLen } = this;
      data2 = (0, utils_js_1$1.toBytes)(data2);
      const len2 = data2.length;
      for (let pos = 0; pos < len2; ) {
        const take2 = Math.min(blockLen - this.pos, len2 - pos);
        if (take2 === blockLen) {
          const dataView = (0, utils_js_1$1.createView)(data2);
          for (; blockLen <= len2 - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer2.set(data2.subarray(pos, pos + take2), this.pos);
        this.pos += take2;
        pos += take2;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data2.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      (0, _assert_js_1.exists)(this);
      (0, _assert_js_1.output)(out, this);
      this.finished = true;
      const { buffer: buffer2, view, blockLen, isLE } = this;
      let { pos } = this;
      buffer2[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i2 = pos; i2 < blockLen; i2++)
        buffer2[i2] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
      this.process(view, 0);
      const oview = (0, utils_js_1$1.createView)(out);
      const len2 = this.outputLen;
      if (len2 % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len2 / 4;
      const state2 = this.get();
      if (outLen > state2.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i2 = 0; i2 < outLen; i2++)
        oview.setUint32(4 * i2, state2[i2], isLE);
    }
    digest() {
      const { buffer: buffer2, outputLen } = this;
      this.digestInto(buffer2);
      const res = buffer2.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer: buffer2, length: length2, finished, destroyed, pos } = this;
      to.length = length2;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length2 % blockLen)
        to.buffer.set(buffer2);
      return to;
    }
  }
  _sha2.SHA2 = SHA2;
  Object.defineProperty(sha256$1, "__esModule", { value: true });
  sha256$1.sha224 = sha256$1.sha256 = void 0;
  const _sha2_js_1 = _sha2;
  const utils_js_1 = utils$a;
  const Chi = (a, b, c) => a & b ^ ~a & c;
  const Maj = (a, b, c) => a & b ^ a & c ^ b & c;
  const SHA256_K = /* @__PURE__ */ new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  const IV = /* @__PURE__ */ new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  class SHA256 extends _sha2_js_1.SHA2 {
    constructor() {
      super(64, 32, 8, false);
      this.A = IV[0] | 0;
      this.B = IV[1] | 0;
      this.C = IV[2] | 0;
      this.D = IV[3] | 0;
      this.E = IV[4] | 0;
      this.F = IV[5] | 0;
      this.G = IV[6] | 0;
      this.H = IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F: F2, G, H } = this;
      return [A, B, C, D, E, F2, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F2, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F2 | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i2 = 0; i2 < 16; i2++, offset += 4)
        SHA256_W[i2] = view.getUint32(offset, false);
      for (let i2 = 16; i2 < 64; i2++) {
        const W15 = SHA256_W[i2 - 15];
        const W2 = SHA256_W[i2 - 2];
        const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
        const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
        SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
      }
      let { A, B, C, D, E, F: F2, G, H } = this;
      for (let i2 = 0; i2 < 64; i2++) {
        const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
        const T1 = H + sigma1 + Chi(E, F2, G) + SHA256_K[i2] + SHA256_W[i2] | 0;
        const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F2;
        F2 = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F2 = F2 + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F2, G, H);
    }
    roundClean() {
      SHA256_W.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  }
  class SHA224 extends SHA256 {
    constructor() {
      super();
      this.A = 3238371032 | 0;
      this.B = 914150663 | 0;
      this.C = 812702999 | 0;
      this.D = 4144912697 | 0;
      this.E = 4290775857 | 0;
      this.F = 1750603025 | 0;
      this.G = 1694076839 | 0;
      this.H = 3204075428 | 0;
      this.outputLen = 28;
    }
  }
  sha256$1.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
  sha256$1.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  function base$1(ALPHABET2) {
    if (ALPHABET2.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i2 = 0; i2 < ALPHABET2.length; i2++) {
      var x2 = ALPHABET2.charAt(i2);
      var xc = x2.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x2 + " is ambiguous");
      }
      BASE_MAP[xc] = i2;
    }
    var BASE = ALPHABET2.length;
    var LEADER = ALPHABET2.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode2(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length2 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i3 = 0;
        for (var it1 = size - 1; (carry !== 0 || i3 < length2) && it1 !== -1; it1--, i3++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i3;
        pbegin++;
      }
      var it2 = size - length2;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str2 = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str2 += ALPHABET2.charAt(b58[it2]);
      }
      return str2;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      var zeroes = 0;
      var length2 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i3 = 0;
        for (var it3 = size - 1; (carry !== 0 || i3 < length2) && it3 !== -1; it3--, i3++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i3;
        psz++;
      }
      var it4 = size - length2;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode2(string) {
      var buffer2 = decodeUnsafe(string);
      if (buffer2) {
        return buffer2;
      }
      throw new Error("Non-base" + BASE + " character");
    }
    return {
      encode: encode2,
      decodeUnsafe,
      decode: decode2
    };
  }
  var src$1 = base$1;
  const basex = src$1;
  const ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  var bs58 = basex(ALPHABET$1);
  var base58 = bs58;
  var base = function(checksumFn) {
    function encode2(payload) {
      var payloadU8 = Uint8Array.from(payload);
      var checksum = checksumFn(payloadU8);
      var length2 = payloadU8.length + 4;
      var both2 = new Uint8Array(length2);
      both2.set(payloadU8, 0);
      both2.set(checksum.subarray(0, 4), payloadU8.length);
      return base58.encode(both2, length2);
    }
    function decodeRaw(buffer2) {
      var payload = buffer2.slice(0, -4);
      var checksum = buffer2.slice(-4);
      var newChecksum = checksumFn(payload);
      if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3])
        return;
      return payload;
    }
    function decodeUnsafe(string) {
      var buffer2 = base58.decodeUnsafe(string);
      if (!buffer2)
        return;
      return decodeRaw(buffer2);
    }
    function decode2(string) {
      var buffer2 = base58.decode(string);
      var payload = decodeRaw(buffer2);
      if (!payload)
        throw new Error("Invalid checksum");
      return payload;
    }
    return {
      encode: encode2,
      decode: decode2,
      decodeUnsafe
    };
  };
  var { sha256 } = sha256$1;
  var bs58checkBase = base;
  function sha256x2(buffer2) {
    return sha256(sha256(buffer2));
  }
  var bs58check = bs58checkBase(sha256x2);
  (function(exports3) {
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.xpubConvert = exports3.getExplorerTxUrl = exports3.needsMemoByNetwork = exports3.getExplorerAddressUrl = exports3.getExplorerUrl = exports3.segwitCoins = exports3.stakingCoins = exports3.baseAmountToNative = exports3.nativeToBaseAmount = exports3.getPrecision = exports3.CURRENCY_DECIMALS = exports3.PoSchains = exports3.COIN_ICONS_BY_SYMBOL = exports3.supportedAssets = exports3.supportedBlockchains = exports3.getNativeAssetForBlockchain = exports3.addressNListToBIP32 = exports3.bip32ToAddressNList = exports3.bip32Like = exports3.GET_NETWORK_NAME = exports3.SLIP_44_BY_LONG = exports3.COIN_MAP_KEEPKEY_LONG = exports3.COIN_MAP_LONG_XCHAIN = exports3.COIN_MAP_LONG = exports3.COIN_MAP = exports3.UTXO_COINS = exports3.THORCHAIN_NETWORKS = exports3.HDWALLETS = exports3.parseThorchainAssetString = exports3.getSwapProtocals = exports3.getThorswapBlockchainName = exports3.getRangoBlockchainName = void 0;
    var log2 = libExports();
    var b58 = bs58check;
    paths$2.getPaths;
    var getRangoBlockchainName2 = function(blockchain) {
      try {
        var rangoName = void 0;
        switch (blockchain) {
          case "bitcoin":
            rangoName = "BTC";
            break;
          case "bitcoincash":
            rangoName = "BCH";
            break;
          case "avalanche":
            rangoName = "AVAX_CCHAIN";
            break;
          case "ethereum":
            rangoName = "ETH";
            break;
          case "cosmos":
            rangoName = "COSMOS";
            break;
          case "thorchain":
            rangoName = "THOR";
            break;
          case "osmosis":
            rangoName = "OSMOSIS";
            break;
          default:
            throw Error("Unknown rango name for blockchain" + blockchain);
        }
        return rangoName;
      } catch (e) {
        log2.error(e);
      }
    };
    exports3.getRangoBlockchainName = getRangoBlockchainName2;
    var getThorswapBlockchainName = function(blockchain) {
      try {
        var rangoName = void 0;
        switch (blockchain) {
          case "bitcoin":
            rangoName = "BTC";
            break;
          case "bitcoincash":
            rangoName = "BCH";
            break;
          case "avalanche":
            rangoName = "AVAX_CCHAIN";
            break;
          case "ethereum":
            rangoName = "ETH";
            break;
          case "cosmos":
            rangoName = "COSMOS";
            break;
          case "thorchain":
            rangoName = "THOR";
            break;
          case "osmosis":
            rangoName = "OSMOSIS";
            break;
          default:
            throw Error("Unknown rango name for blockchain" + blockchain);
        }
        return rangoName;
      } catch (e) {
        log2.error(e);
      }
    };
    exports3.getThorswapBlockchainName = getThorswapBlockchainName;
    var getSwapProtocals2 = function(asset, network) {
      try {
        var output2 = [];
        if (network === "ETH") {
          output2.push("0x");
        }
        var thorchainAssets = ["BCH", "BNB", "BTC", "ETH", "LTC"];
        if (thorchainAssets.indexOf(asset) >= 0) {
          output2.push("thorchain");
        }
        var osmoAssets = ["OSMO", "ATOM"];
        if (osmoAssets.indexOf(asset) >= 0) {
          output2.push("osmosis");
        }
        return output2;
      } catch (e) {
        log2.error(e);
      }
    };
    exports3.getSwapProtocals = getSwapProtocals2;
    var parseThorchainAssetString = function(input) {
      try {
        var parts2 = input.split(".");
        var network = parts2[0];
        var asset = void 0;
        var symbol = void 0;
        var contract = void 0;
        if (parts2[1].indexOf("-") >= 0) {
          var parts22 = parts2[1].split("-");
          contract = parts22[1];
          asset = parts22[0];
          symbol = parts22[0];
        } else {
          asset = parts2[0];
          symbol = parts2[0];
        }
        return {
          asset,
          symbol,
          network,
          contract
        };
      } catch (e) {
        log2.error(e);
      }
    };
    exports3.parseThorchainAssetString = parseThorchainAssetString;
    var HDWALLETS;
    (function(HDWALLETS2) {
      HDWALLETS2[HDWALLETS2["pioneer"] = 0] = "pioneer";
      HDWALLETS2[HDWALLETS2["trezor"] = 1] = "trezor";
      HDWALLETS2[HDWALLETS2["keepkey"] = 2] = "keepkey";
      HDWALLETS2[HDWALLETS2["ledger"] = 3] = "ledger";
    })(HDWALLETS || (exports3.HDWALLETS = HDWALLETS = {}));
    exports3.THORCHAIN_NETWORKS = [
      {
        "symbol": "ARB",
        "image": "https://pioneers.dev/coins/arbitrum.png"
      },
      {
        "symbol": "AVAX",
        "image": "https://pioneers.dev/coins/avalanche.png"
      },
      {
        "symbol": "BNB",
        "image": "https://pioneers.dev/coins/binance.png"
      },
      {
        "symbol": "BSC",
        "image": "https://pioneers.dev/coins/binance.png"
      },
      {
        "symbol": "BTC",
        "image": "https://pioneers.dev/coins/bitcoin.png"
      },
      {
        "symbol": "BCH",
        "image": "https://pioneers.dev/coins/bitcoincash.png"
      },
      {
        "symbol": "GAIA",
        "image": "https://pioneers.dev/coins/cosmos.png"
      },
      {
        "symbol": "DOGE",
        "image": "https://pioneers.dev/coins/dogecoin.png"
      },
      {
        "symbol": "ETH",
        "image": "https://pioneers.dev/coins/ethereum.png"
      },
      {
        "symbol": "LTC",
        "image": "https://pioneers.dev/coins/litecoin.png"
      },
      {
        "symbol": "OP",
        "image": "https://pioneers.dev/coins/optimism.png"
      },
      {
        "symbol": "MATIC",
        "image": "https://pioneers.dev/coins/polygon.png"
      },
      {
        "symbol": "THOR",
        "image": "https://pioneers.dev/coins/undefined.png"
      }
    ];
    exports3.UTXO_COINS = [
      "BTC",
      "BCH",
      "DASH",
      "DGB",
      "DOGE",
      "LTC",
      "TEST"
    ];
    exports3.COIN_MAP = {
      bitcoin: "BTC",
      cosmos: "ATOM",
      osmosis: "OSMO",
      testnet: "TEST",
      bitcoincash: "BCH",
      litecoin: "LTC",
      dash: "DASH",
      digibyte: "DGB",
      dogecoin: "DOGE",
      ethereum: "ETH",
      avalanche: "AVAX",
      poly: "MATIC",
      cardano: "ADA",
      binance: "BNB",
      thorchain: "RUNE",
      eos: "EOS",
      fio: "FIO"
    };
    exports3.COIN_MAP_LONG = {
      BTC: "bitcoin",
      ATOM: "cosmos",
      ARB: "arbitrum",
      OSMO: "osmosis",
      BTCT: "testnet",
      BCH: "bitcoincash",
      LTC: "litecoin",
      DASH: "dash",
      OP: "optimism",
      THOR: "thorchain",
      DGB: "digiByte",
      DOGE: "dogecoin",
      RUNE: "thorchain",
      ETH: "ethereum",
      AVAX: "avalanche",
      ADA: "cardano",
      MATIC: "polygon",
      BNB: "binance",
      EOS: "eos",
      FIO: "fio"
    };
    exports3.COIN_MAP_LONG_XCHAIN = {
      BTC: "bitcoin",
      ATOM: "cosmos",
      OSMO: "osmosis",
      BTCT: "testnet",
      BCH: "bitcoinCash",
      LTC: "litecoin",
      DASH: "dash",
      DGB: "digiByte",
      DOGE: "dogecoin",
      RUNE: "thorchain",
      ETH: "ethereum",
      ADA: "cardano",
      MATIC: "polygon",
      BNB: "binance",
      EOS: "eos",
      FIO: "fio"
    };
    exports3.COIN_MAP_KEEPKEY_LONG = {
      BTC: "Bitcoin",
      ATOM: "Cosmos",
      GAIA: "Cosmos",
      OSMO: "osmosis",
      BTCT: "testnet",
      BCH: "BitcoinCash",
      LTC: "Litecoin",
      DASH: "Dash",
      DGB: "DigiByte",
      DOGE: "Dogecoin",
      RUNE: "Thorchain",
      THOR: "Thorchain",
      ETH: "Ethereum",
      ADA: "Cardano",
      BNB: "Binance",
      AVAX: "Avalanche",
      EOS: "Eos",
      FIO: "Fio"
    };
    exports3.SLIP_44_BY_LONG = {
      bitcoin: 0,
      testnet: 1,
      bitcoincash: 145,
      bitcoingold: 156,
      litecoin: 2,
      dash: 5,
      digibyte: 20,
      dogecoin: 3,
      bitcoinsv: 236,
      ethereum: 60,
      avalanche: 60,
      cosmos: 118,
      osmosis: 118,
      binance: 714,
      ripple: 144,
      eos: 194,
      fio: 235,
      thorchain: 931,
      cardano: 1815,
      secret: 529,
      terra: 931,
      kava: 459
    };
    var GET_NETWORK_NAME = function(network) {
      var networkName;
      switch (network) {
        case "1":
          networkName = "Main";
          break;
        case "2":
          networkName = "Morden";
          break;
        case "3":
          networkName = "Ropsten";
          break;
        case "4":
          networkName = "Rinkeby";
          break;
        case "42":
          networkName = "Kovan";
          break;
        default:
          networkName = "Unknown";
      }
      return networkName;
    };
    exports3.GET_NETWORK_NAME = GET_NETWORK_NAME;
    var HARDENED2 = 2147483648;
    function bip32Like2(path2) {
      if (path2 == "m/")
        return true;
      return /^m(((\/[0-9]+h)+|(\/[0-9]+H)+|(\/[0-9]+')*)((\/[0-9]+)*))$/.test(path2);
    }
    exports3.bip32Like = bip32Like2;
    function bip32ToAddressNList2(path2) {
      if (!bip32Like2(path2)) {
        throw new Error("Not a bip32 path: '".concat(path2, "'"));
      }
      if (/^m\//i.test(path2)) {
        path2 = path2.slice(2);
      }
      var segments = path2.split("/");
      if (segments.length === 1 && segments[0] === "")
        return [];
      var ret = new Array(segments.length);
      for (var i2 = 0; i2 < segments.length; i2++) {
        var tmp = /(\d+)([hH\']?)/.exec(segments[i2]);
        if (tmp === null) {
          throw new Error("Invalid input");
        }
        ret[i2] = parseInt(tmp[1], 10);
        if (ret[i2] >= HARDENED2) {
          throw new Error("Invalid child index");
        }
        if (tmp[2] === "h" || tmp[2] === "H" || tmp[2] === "'") {
          ret[i2] += HARDENED2;
        } else if (tmp[2].length !== 0) {
          throw new Error("Invalid modifier");
        }
      }
      return ret;
    }
    exports3.bip32ToAddressNList = bip32ToAddressNList2;
    function addressNListToBIP322(address2) {
      return "m/".concat(address2.map(function(num) {
        return num >= HARDENED2 ? "".concat(num - HARDENED2, "'") : num;
      }).join("/"));
    }
    exports3.addressNListToBIP32 = addressNListToBIP322;
    function getNativeAssetForBlockchain2(blockchain) {
      if (exports3.COIN_MAP[blockchain.toLowerCase()]) {
        return exports3.COIN_MAP[blockchain.toLowerCase()];
      } else {
        throw Error(" Unknown blockchain! " + blockchain);
      }
    }
    exports3.getNativeAssetForBlockchain = getNativeAssetForBlockchain2;
    exports3.supportedBlockchains = [];
    exports3.supportedAssets = [];
    exports3.supportedBlockchains.push("Bitcoin", "Ethereum", "Thorchain", "Secret", "Kava", "Terra", "BinanceSmartChain", "Cardano", "Eos", "Fio", "Cosmos", "Osmosis", "Binance", "BitcoinCash", "Litecoin", "Avalanche");
    exports3.supportedAssets.push("BTC", "ETH", "RUNE", "SCRT", "KAVA", "LUNA", "BNB", "ADA", "EOS", "FIO", "ATOM", "OSMO", "BNB", "BCH", "LTC", "AVAX");
    exports3.COIN_ICONS_BY_SYMBOL = {
      BTC: "https://assets.coingecko.com/coins/images/1/small/bitcoin.png?1547033579",
      ETH: "https://assets.coingecko.com/coins/images/279/large/ethereum.png?1595348880",
      LTC: "https://assets.coingecko.com/coins/images/16724/thumb/ltc.png",
      BNB: "https://assets.coingecko.com/coins/images/825/thumb/binance-coin-logo.png?1547034615",
      BCH: "https://assets.coingecko.com/coins/images/780/thumb/bitcoin-cash-circle.png?1594689492",
      OSMO: "https://assets.coingecko.com/coins/images/16724/thumb/osmo.png",
      ATOM: "https://assets.coingecko.com/coins/images/16724/thumb/atom.png",
      FIO: "https://assets.coingecko.com/coins/images/16724/thumb/fio.png",
      EOS: "https://assets.coingecko.com/coins/images/16724/thumb/eos.png",
      RUNE: "https://assets.coingecko.com/coins/images/6595/thumb/RUNE.png",
      ADA: "https://assets.coingecko.com/coins/images/16724/thumb/ada.png",
      LUNA: "https://assets.coingecko.com/coins/images/8284/thumb/luna1557227471663.png?1567147072",
      KAVA: "https://assets.coingecko.com/coins/images/16724/thumb/kava.png",
      SCRT: "https://assets.coingecko.com/coins/images/16724/thumb/scrt.png"
    };
    var PoSchains;
    (function(PoSchains2) {
      PoSchains2[PoSchains2["eos"] = 0] = "eos";
      PoSchains2[PoSchains2["cosmos"] = 1] = "cosmos";
      PoSchains2[PoSchains2["osmosis"] = 2] = "osmosis";
      PoSchains2[PoSchains2["binance"] = 3] = "binance";
      PoSchains2[PoSchains2["fio"] = 4] = "fio";
      PoSchains2[PoSchains2["terra"] = 5] = "terra";
      PoSchains2[PoSchains2["kava"] = 6] = "kava";
      PoSchains2[PoSchains2["secret"] = 7] = "secret";
    })(PoSchains || (exports3.PoSchains = PoSchains = {}));
    exports3.CURRENCY_DECIMALS = {
      "btc": 8,
      "rune": 8,
      "dash": 8,
      "atom": 6,
      "osmo": 6,
      "ltc": 8,
      "bch": 8,
      "doge": 8,
      "eth": 18,
      "gnt": 18,
      "usdt": 6,
      "trx": 6,
      "bnb": 8,
      "poly": 18,
      "gno": 18,
      "sngls": 0,
      "icn": 18,
      "dgd": 9,
      "mln": 18,
      "rep": 18,
      "swt": 18,
      "wings": 18,
      "trst": 6,
      "rlc": 9,
      "gup": 3,
      "ant": 18,
      "bat": 18,
      "bnt": 18,
      "snt": 18,
      "nmr": 18,
      "edg": 0,
      "eos": 18,
      "cvc": 8,
      "link": 18,
      "knc": 18,
      "mtl": 8,
      "pay": 18,
      "fun": 8,
      "dnt": 18,
      "zrx": 18,
      "1st": 18,
      "omg": 18,
      "salt": 8,
      "rcn": 18,
      "storj": 8,
      "zil": 12,
      "mana": 18,
      "tusd": 18,
      "ae": 18,
      "dai": 18,
      "mkr": 18
    };
    function getPrecision2(asset) {
      if (exports3.CURRENCY_DECIMALS[asset.toLowerCase()]) {
        return exports3.CURRENCY_DECIMALS[asset.toLowerCase()];
      } else {
        throw Error(" Unknown asset! " + asset);
      }
    }
    exports3.getPrecision = getPrecision2;
    function nativeToBaseAmount2(asset, amount) {
      if (!exports3.CURRENCY_DECIMALS[asset.toLowerCase()])
        throw Error("Unknown asset!");
      var output2 = amount / Math.pow(10, exports3.CURRENCY_DECIMALS[asset.toLowerCase()]);
      return output2;
    }
    exports3.nativeToBaseAmount = nativeToBaseAmount2;
    function baseAmountToNative2(asset, amount) {
      if (!exports3.CURRENCY_DECIMALS[asset.toLowerCase()])
        throw Error("Unknown asset!");
      var output2 = amount * Math.pow(10, exports3.CURRENCY_DECIMALS[asset.toLowerCase()]);
      output2 = parseInt(output2);
      return output2;
    }
    exports3.baseAmountToNative = baseAmountToNative2;
    exports3.stakingCoins = ["EOS", "ATOM"];
    exports3.segwitCoins = ["Bitcoin", "Testnet", "BitcoinGold", "Litecoin"];
    function getExplorerUrl2(network, token, testnet) {
      if (testnet) {
        var href = void 0;
        switch (network) {
          case "bitcoin":
            href = "https://blockstream.info/testnet";
            break;
          case "ethereum":
            href = "https://ropsten.etherscan.io/";
            break;
        }
        return href;
      } else {
        var href = void 0;
        switch (network) {
          case "bitcoin":
            href = "https://blockstream.info";
            break;
          case "ethereum":
            href = "https://etherscan.io";
            break;
          case "bitcoinCash":
            href = "https://blockchair.com/bitcoin-cash";
            break;
          case "binance":
            href = "https://explorer.binance.org";
            break;
          case "thorchain":
            href = "https://thorchain.net";
            break;
          case "cosmos":
            href = "https://www.mintscan.io";
            break;
          case "osmosis":
            href = "https://www.mintscan.io";
            break;
          case "dash":
            return "https://chainz.cryptoid.info/dash";
          case "doge":
            return "https://dogechain.info";
        }
        return href;
      }
    }
    exports3.getExplorerUrl = getExplorerUrl2;
    function getExplorerAddressUrl2(address2, network, token, testnet) {
      if (testnet) {
        var href = void 0;
        switch (network) {
          case "bitcoin":
            href = "https://blockstream.info/testnet/address/" + address2;
            break;
          case "ethereum":
            href = "https://ropsten.etherscan.io/address/" + address2;
            break;
        }
        return href;
      } else {
        var href = void 0;
        switch (network) {
          case "bitcoin":
            href = "https://www.blockchain.com/";
            break;
          case "ethereum":
            href = "https://etherscan.io";
            break;
          case "bitcoinCash":
            href = "https://blockchair.com/bitcoin-cash";
            break;
          case "binance":
            href = "https://explorer.binance.org";
            break;
          case "cosmos":
            href = "https://www.mintscan.io";
            break;
          case "dash":
            return "https://chainz.cryptoid.info/dash";
          case "doge":
            return "https://dogechain.info";
        }
        return href;
      }
    }
    exports3.getExplorerAddressUrl = getExplorerAddressUrl2;
    function needsMemoByNetwork(network) {
      var needsMemo = false;
      switch (network) {
        case "thorchain":
          needsMemo = true;
          break;
        case "osmosis":
          needsMemo = true;
          break;
        case "cosmos":
          needsMemo = true;
          break;
      }
      return needsMemo;
    }
    exports3.needsMemoByNetwork = needsMemoByNetwork;
    function getExplorerTxUrl2(network, txid, testnet) {
      if (testnet) {
        var href = void 0;
        switch (network) {
          case "bitcoin":
            href = "https://blockstream.info/testnet/tx/" + txid;
            break;
          case "ethereum":
            href = "https://ropsten.etherscan.io/tx/" + txid;
            break;
        }
        return href;
      } else {
        var href = void 0;
        switch (network) {
          case "bitcoin":
            href = "https://blockstream.info/tx/" + txid;
            break;
          case "ethereum":
            href = "https://etherscan.io/tx/" + txid;
            break;
          case "bitcoinCash":
            href = "https://blockchair.com/bitcoin-cash/tx/" + txid;
            break;
          case "binance":
            href = "https://explorer.binance.org/tx/" + txid;
            break;
          case "thorchain":
            href = "https://thorchain.net/tx/" + txid;
            break;
          case "osmosis":
            href = "https://www.mintscan.io/osmosis/txs/" + txid;
            break;
          case "cosmos":
            href = "https://www.mintscan.io/cosmos/txs/" + txid;
            break;
          case "dash":
            return "https://chainz.cryptoid.info/dash" + txid;
          case "doge":
            return "https://dogechain.info/tx/" + txid;
        }
        return href;
      }
    }
    exports3.getExplorerTxUrl = getExplorerTxUrl2;
    var prefixes = /* @__PURE__ */ new Map([
      ["xpub", "0488b21e"],
      ["ypub", "049d7cb2"],
      ["Ypub", "0295b43f"],
      ["zpub", "04b24746"],
      ["Zpub", "02aa7ed3"],
      ["tpub", "043587cf"],
      ["upub", "044a5262"],
      ["Upub", "024289ef"],
      ["vpub", "045f1cf6"],
      ["Vpub", "02575483"],
      ["Ltub", "02575483"]
    ]);
    var AddressTypes;
    (function(AddressTypes2) {
      AddressTypes2[AddressTypes2["bech32"] = 0] = "bech32";
      AddressTypes2[AddressTypes2["legacy"] = 1] = "legacy";
    })(AddressTypes || (AddressTypes = {}));
    function xpubConvert2(xpub, target) {
      if (!prefixes.has(target)) {
        return "Invalid target version";
      }
      xpub = xpub.trim();
      var data2 = b58.decode(xpub);
      data2 = data2.slice(4);
      data2 = buffer$1.Buffer.concat([buffer$1.Buffer.from(prefixes.get(target), "hex"), data2]);
      return b58.encode(data2);
    }
    exports3.xpubConvert = xpubConvert2;
  })(coins);
  var pubkey = {};
  var bitcoinRegex$1 = (opts) => {
    opts = Object.assign({}, opts);
    const regex = "(?:[13][a-km-zA-HJ-NP-Z1-9]{25,34})";
    return opts.exact ? new RegExp("(?:^" + regex + "$)") : new RegExp(regex, "g");
  };
  const re$7 = "0x[a-fA-F0-9]{40}";
  var ethereumRegex$1 = (options) => {
    options = options || {};
    return options.exact ? new RegExp(`(?:^${re$7}$)`) : new RegExp(re$7, "g");
  };
  const re$6 = "[LM3][a-km-zA-HJ-NP-Z1-9]{26,33}";
  var litecoinRegex$1 = (options) => {
    options = options || {};
    return options.exact ? new RegExp("(?:^" + re$6 + "$)") : new RegExp(re$6, "g");
  };
  const re$5 = "D{1}[5-9A-HJ-NP-U]{1}[1-9A-HJ-NP-Za-km-z]{32}";
  var dogecoinRegex$1 = (options) => {
    options = options || {};
    return options.exact ? new RegExp("(?:^" + re$5 + "$)") : new RegExp(re$5, "g");
  };
  const bchRegExps = {
    legacy: "[13][a-km-zA-HJ-NP-Z1-9]{33}",
    cashaddr: "((bitcoincash|bchreg|bchtest):)?(q|p)[a-z0-9]{41}"
  };
  const buildRegExp = (body, options) => {
    return options.exact ? new RegExp("(?:^" + body + "$)") : new RegExp(body, "g");
  };
  const bchRegex = (options) => {
    options = options || {};
    const body = Object.keys(bchRegExps).map((format) => "(?:" + bchRegExps[format] + ")").join("|");
    return buildRegExp(body, options);
  };
  bchRegex.format = (format, options) => {
    options = options || {};
    if (!bchRegExps[format]) {
      throw new Error("Invalid BCH format");
    }
    const body = bchRegExps[format];
    return buildRegExp(body, options);
  };
  var bitcoincashRegex$1 = bchRegex;
  const re$4 = "X[1-9A-HJ-NP-Za-km-z]{33}";
  var dashRegex$1 = (options) => {
    options = options || {};
    return options.exact ? new RegExp("(?:^" + re$4 + "$)") : new RegExp(re$4, "g");
  };
  const re$3 = "4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}";
  var moneroRegex$1 = (options) => {
    options = options || {};
    return options.exact ? new RegExp("(?:^" + re$3 + "$)") : new RegExp(re$3, "g");
  };
  const re$2 = "r[0-9a-zA-Z]{24,34}";
  var rippleRegex$1 = (opts) => {
    opts = opts || {};
    return opts.exact ? new RegExp("(?:^" + re$2 + "$)") : new RegExp(re$2, "g");
  };
  const re$1 = "A[0-9a-zA-Z]{33}";
  var neoRegex$1 = (options) => {
    options = options || {};
    return options.exact ? new RegExp("(?:^" + re$1 + "$)") : new RegExp(re$1, "g");
  };
  Object.defineProperty(pubkey, "__esModule", { value: true });
  pubkey.classifyPubkey = void 0;
  var bitcoinRegex = bitcoinRegex$1;
  var ethereumRegex = ethereumRegex$1;
  var litecoinRegex = litecoinRegex$1;
  var dogecoinRegex = dogecoinRegex$1;
  var bitcoincashRegex = bitcoincashRegex$1;
  var dashRegex = dashRegex$1;
  var moneroRegex = moneroRegex$1;
  var rippleRegex = rippleRegex$1;
  var neoRegex = neoRegex$1;
  function classifyPubkey(address2) {
    if (bitcoinRegex({ exact: true }).test(address2))
      return "BTC";
    else if (ethereumRegex({ exact: true }).test(address2))
      return "ETH";
    else if (litecoinRegex({ exact: true }).test(address2))
      return "LTC";
    else if (dogecoinRegex({ exact: true }).test(address2))
      return "DOGE";
    else if (dashRegex({ exact: true }).test(address2))
      return "DASH";
    else if (moneroRegex({ exact: true }).test(address2))
      return "XMR";
    else if (rippleRegex({ exact: true }).test(address2))
      return "XRP";
    else if (bitcoincashRegex.format("cashaddr", { exact: true }).test(address2))
      return "BCH";
    else if (neoRegex({ exact: true }).test(address2))
      return "NEO";
    switch (address2[0]) {
      case "S":
        return "DASH";
      case "A":
        return "DOGE";
      case "9":
        return "DOGE";
    }
    return "Cryptocurrency could not be detected";
  }
  pubkey.classifyPubkey = classifyPubkey;
  var address = {};
  Object.defineProperty(address, "__esModule", { value: true });
  address.addressInfoForCoin = void 0;
  libExports();
  var paths_1 = paths$2;
  var coins_1 = coins;
  var addressInfoForCoin = function(symbol, isTestnet, scriptType, showDisplay, path2) {
    var paths2 = (0, paths_1.getPaths)(paths_1.blockchains);
    if (symbol === "THOR")
      symbol = "RUNE";
    if (symbol === "GAIA")
      symbol = "ATOM";
    symbol = symbol.toUpperCase();
    var blockchainEntries = paths2.filter(function(entry2) {
      return entry2.symbol === symbol.toUpperCase();
    });
    if (!blockchainEntries) {
      throw new Error("Blockchain symbol '".concat(symbol, "' not found."));
    }
    var entry;
    if (scriptType && blockchainEntries.length > 1) {
      entry = blockchainEntries.find(function(entry2) {
        return entry2.script_type === scriptType;
      });
    } else {
      entry = blockchainEntries[0];
    }
    var addressInfo = {
      address_n: entry.addressNListMaster,
      path: (0, coins_1.addressNListToBIP32)(entry.addressNListMaster),
      coin: coins_1.COIN_MAP_KEEPKEY_LONG[symbol.toUpperCase()],
      script_type: scriptType || entry.script_type,
      showDisplay: entry.showDisplay
    };
    return addressInfo;
  };
  address.addressInfoForCoin = addressInfoForCoin;
  (function(exports3) {
    var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m2[k2];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports4) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports4, p2))
          __createBinding2(exports4, m2, p2);
    };
    Object.defineProperty(exports3, "__esModule", { value: true });
    __exportStar(paths$2, exports3);
    __exportStar(coins, exports3);
    __exportStar(pubkey, exports3);
    __exportStar(address, exports3);
  })(lib$7);
  var uuidRandom = { exports: {} };
  (function(module2) {
    (function() {
      var buf, bufIdx = 0, hexBytes = [], i2;
      for (i2 = 0; i2 < 256; i2++) {
        hexBytes[i2] = (i2 + 256).toString(16).substr(1);
      }
      uuid2.BUFFER_SIZE = 4096;
      uuid2.bin = uuidBin;
      uuid2.clearBuffer = function() {
        buf = null;
        bufIdx = 0;
      };
      uuid2.test = function(uuid3) {
        if (typeof uuid3 === "string") {
          return /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(uuid3);
        }
        return false;
      };
      var crypt0;
      if (typeof crypto !== "undefined") {
        crypt0 = crypto;
      } else if (typeof window !== "undefined" && typeof window.msCrypto !== "undefined") {
        crypt0 = window.msCrypto;
      }
      if (typeof commonjsRequire === "function") {
        crypt0 = crypt0 || require$$0$3;
        module2.exports = uuid2;
      } else if (typeof window !== "undefined") {
        window.uuid = uuid2;
      }
      uuid2.randomBytes = function() {
        if (crypt0) {
          if (crypt0.randomBytes) {
            return crypt0.randomBytes;
          }
          if (crypt0.getRandomValues) {
            if (typeof Uint8Array.prototype.slice !== "function") {
              return function(n2) {
                var bytes2 = new Uint8Array(n2);
                crypt0.getRandomValues(bytes2);
                return Array.from(bytes2);
              };
            }
            return function(n2) {
              var bytes2 = new Uint8Array(n2);
              crypt0.getRandomValues(bytes2);
              return bytes2;
            };
          }
        }
        return function(n2) {
          var i3, r = [];
          for (i3 = 0; i3 < n2; i3++) {
            r.push(Math.floor(Math.random() * 256));
          }
          return r;
        };
      }();
      function randomBytesBuffered(n2) {
        if (!buf || bufIdx + n2 > uuid2.BUFFER_SIZE) {
          bufIdx = 0;
          buf = uuid2.randomBytes(uuid2.BUFFER_SIZE);
        }
        return buf.slice(bufIdx, bufIdx += n2);
      }
      function uuidBin() {
        var b = randomBytesBuffered(16);
        b[6] = b[6] & 15 | 64;
        b[8] = b[8] & 63 | 128;
        return b;
      }
      function uuid2() {
        var b = uuidBin();
        return hexBytes[b[0]] + hexBytes[b[1]] + hexBytes[b[2]] + hexBytes[b[3]] + "-" + hexBytes[b[4]] + hexBytes[b[5]] + "-" + hexBytes[b[6]] + hexBytes[b[7]] + "-" + hexBytes[b[8]] + hexBytes[b[9]] + "-" + hexBytes[b[10]] + hexBytes[b[11]] + hexBytes[b[12]] + hexBytes[b[13]] + hexBytes[b[14]] + hexBytes[b[15]];
      }
    })();
  })(uuidRandom);
  var uuidRandomExports = uuidRandom.exports;
  const uuid = /* @__PURE__ */ getDefaultExportFromCjs(uuidRandomExports);
  const global$e = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
  function bind$6(fn, thisArg) {
    return function wrap2() {
      return fn.apply(thisArg, arguments);
    };
  }
  const { toString: toString$b } = Object.prototype;
  const { getPrototypeOf: getPrototypeOf$3 } = Object;
  const kindOf = ((cache) => (thing) => {
    const str2 = toString$b.call(thing);
    return cache[str2] || (cache[str2] = str2.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null));
  const kindOfTest = (type2) => {
    type2 = type2.toLowerCase();
    return (thing) => kindOf(thing) === type2;
  };
  const typeOfTest = (type2) => (thing) => typeof thing === type2;
  const { isArray: isArray$d } = Array;
  const isUndefined$2 = typeOfTest("undefined");
  function isBuffer$4(val) {
    return val !== null && !isUndefined$2(val) && val.constructor !== null && !isUndefined$2(val.constructor) && isFunction$9(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  const isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  const isString$6 = typeOfTest("string");
  const isFunction$9 = typeOfTest("function");
  const isNumber$6 = typeOfTest("number");
  const isObject$k = (thing) => thing !== null && typeof thing === "object";
  const isBoolean$5 = (thing) => thing === true || thing === false;
  const isPlainObject$2 = (val) => {
    if (kindOf(val) !== "object") {
      return false;
    }
    const prototype2 = getPrototypeOf$3(val);
    return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
  };
  const isDate$4 = kindOfTest("Date");
  const isFile$1 = kindOfTest("File");
  const isBlob = kindOfTest("Blob");
  const isFileList = kindOfTest("FileList");
  const isStream = (val) => isObject$k(val) && isFunction$9(val.pipe);
  const isFormData = (thing) => {
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$9(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction$9(thing.toString) && thing.toString() === "[object FormData]"));
  };
  const isURLSearchParams = kindOfTest("URLSearchParams");
  const trim = (str2) => str2.trim ? str2.trim() : str2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function forEach$2(obj, fn, { allOwnKeys = false } = {}) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    let i2;
    let l2;
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray$d(obj)) {
      for (i2 = 0, l2 = obj.length; i2 < l2; i2++) {
        fn.call(null, obj[i2], i2, obj);
      }
    } else {
      const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len2 = keys2.length;
      let key;
      for (i2 = 0; i2 < len2; i2++) {
        key = keys2[i2];
        fn.call(null, obj[key], key, obj);
      }
    }
  }
  function findKey(obj, key) {
    key = key.toLowerCase();
    const keys2 = Object.keys(obj);
    let i2 = keys2.length;
    let _key;
    while (i2-- > 0) {
      _key = keys2[i2];
      if (key === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  const _global = (() => {
    if (typeof globalThis !== "undefined")
      return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global$e;
  })();
  const isContextDefined = (context2) => !isUndefined$2(context2) && context2 !== _global;
  function merge$7() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key) => {
      const targetKey = caseless && findKey(result, key) || key;
      if (isPlainObject$2(result[targetKey]) && isPlainObject$2(val)) {
        result[targetKey] = merge$7(result[targetKey], val);
      } else if (isPlainObject$2(val)) {
        result[targetKey] = merge$7({}, val);
      } else if (isArray$d(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };
    for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
      arguments[i2] && forEach$2(arguments[i2], assignValue);
    }
    return result;
  }
  const extend$1 = (a, b, thisArg, { allOwnKeys } = {}) => {
    forEach$2(b, (val, key) => {
      if (thisArg && isFunction$9(val)) {
        a[key] = bind$6(val, thisArg);
      } else {
        a[key] = val;
      }
    }, { allOwnKeys });
    return a;
  };
  const stripBOM = (content) => {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  };
  const inherits$1 = (constructor, superConstructor, props, descriptors2) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };
  const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
    let props;
    let i2;
    let prop2;
    const merged = {};
    destObj = destObj || {};
    if (sourceObj == null)
      return destObj;
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i2 = props.length;
      while (i2-- > 0) {
        prop2 = props[i2];
        if ((!propFilter || propFilter(prop2, sourceObj, destObj)) && !merged[prop2]) {
          destObj[prop2] = sourceObj[prop2];
          merged[prop2] = true;
        }
      }
      sourceObj = filter2 !== false && getPrototypeOf$3(sourceObj);
    } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  };
  const endsWith = (str2, searchString, position2) => {
    str2 = String(str2);
    if (position2 === void 0 || position2 > str2.length) {
      position2 = str2.length;
    }
    position2 -= searchString.length;
    const lastIndex = str2.indexOf(searchString, position2);
    return lastIndex !== -1 && lastIndex === position2;
  };
  const toArray$3 = (thing) => {
    if (!thing)
      return null;
    if (isArray$d(thing))
      return thing;
    let i2 = thing.length;
    if (!isNumber$6(i2))
      return null;
    const arr = new Array(i2);
    while (i2-- > 0) {
      arr[i2] = thing[i2];
    }
    return arr;
  };
  const isTypedArray$3 = ((TypedArray2) => {
    return (thing) => {
      return TypedArray2 && thing instanceof TypedArray2;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf$3(Uint8Array));
  const forEachEntry = (obj, fn) => {
    const generator = obj && obj[Symbol.iterator];
    const iterator2 = generator.call(obj);
    let result;
    while ((result = iterator2.next()) && !result.done) {
      const pair = result.value;
      fn.call(obj, pair[0], pair[1]);
    }
  };
  const matchAll = (regExp, str2) => {
    let matches;
    const arr = [];
    while ((matches = regExp.exec(str2)) !== null) {
      arr.push(matches);
    }
    return arr;
  };
  const isHTMLForm = kindOfTest("HTMLFormElement");
  const toCamelCase = (str2) => {
    return str2.toLowerCase().replace(
      /[-_\s]([a-z\d])(\w*)/g,
      function replacer(m2, p1, p2) {
        return p1.toUpperCase() + p2;
      }
    );
  };
  const hasOwnProperty$e = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop2) => hasOwnProperty2.call(obj, prop2))(Object.prototype);
  const isRegExp$5 = kindOfTest("RegExp");
  const reduceDescriptors = (obj, reducer2) => {
    const descriptors2 = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach$2(descriptors2, (descriptor, name) => {
      let ret;
      if ((ret = reducer2(descriptor, name, obj)) !== false) {
        reducedDescriptors[name] = ret || descriptor;
      }
    });
    Object.defineProperties(obj, reducedDescriptors);
  };
  const freezeMethods = (obj) => {
    reduceDescriptors(obj, (descriptor, name) => {
      if (isFunction$9(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
        return false;
      }
      const value2 = obj[name];
      if (!isFunction$9(value2))
        return;
      descriptor.enumerable = false;
      if ("writable" in descriptor) {
        descriptor.writable = false;
        return;
      }
      if (!descriptor.set) {
        descriptor.set = () => {
          throw Error("Can not rewrite read-only method '" + name + "'");
        };
      }
    });
  };
  const toObjectSet = (arrayOrString, delimiter) => {
    const obj = {};
    const define2 = (arr) => {
      arr.forEach((value2) => {
        obj[value2] = true;
      });
    };
    isArray$d(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
    return obj;
  };
  const noop$4 = () => {
  };
  const toFiniteNumber = (value2, defaultValue) => {
    value2 = +value2;
    return Number.isFinite(value2) ? value2 : defaultValue;
  };
  const ALPHA = "abcdefghijklmnopqrstuvwxyz";
  const DIGIT = "0123456789";
  const ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
  };
  const generateString = (size = 16, alphabet2 = ALPHABET.ALPHA_DIGIT) => {
    let str2 = "";
    const { length: length2 } = alphabet2;
    while (size--) {
      str2 += alphabet2[Math.random() * length2 | 0];
    }
    return str2;
  };
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction$9(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
  }
  const toJSONObject = (obj) => {
    const stack = new Array(10);
    const visit2 = (source, i2) => {
      if (isObject$k(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }
        if (!("toJSON" in source)) {
          stack[i2] = source;
          const target = isArray$d(source) ? [] : {};
          forEach$2(source, (value2, key) => {
            const reducedValue = visit2(value2, i2 + 1);
            !isUndefined$2(reducedValue) && (target[key] = reducedValue);
          });
          stack[i2] = void 0;
          return target;
        }
      }
      return source;
    };
    return visit2(obj, 0);
  };
  const isAsyncFn = kindOfTest("AsyncFunction");
  const isThenable = (thing) => thing && (isObject$k(thing) || isFunction$9(thing)) && isFunction$9(thing.then) && isFunction$9(thing.catch);
  const utils$9 = {
    isArray: isArray$d,
    isArrayBuffer,
    isBuffer: isBuffer$4,
    isFormData,
    isArrayBufferView,
    isString: isString$6,
    isNumber: isNumber$6,
    isBoolean: isBoolean$5,
    isObject: isObject$k,
    isPlainObject: isPlainObject$2,
    isUndefined: isUndefined$2,
    isDate: isDate$4,
    isFile: isFile$1,
    isBlob,
    isRegExp: isRegExp$5,
    isFunction: isFunction$9,
    isStream,
    isURLSearchParams,
    isTypedArray: isTypedArray$3,
    isFileList,
    forEach: forEach$2,
    merge: merge$7,
    extend: extend$1,
    trim,
    stripBOM,
    inherits: inherits$1,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray: toArray$3,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty: hasOwnProperty$e,
    hasOwnProp: hasOwnProperty$e,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop: noop$4,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable
  };
  function AxiosError(message, code2, config2, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message;
    this.name = "AxiosError";
    code2 && (this.code = code2);
    config2 && (this.config = config2);
    request && (this.request = request);
    response && (this.response = response);
  }
  utils$9.inherits(AxiosError, Error, {
    toJSON: function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils$9.toJSONObject(this.config),
        code: this.code,
        status: this.response && this.response.status ? this.response.status : null
      };
    }
  });
  const prototype$1 = AxiosError.prototype;
  const descriptors$1 = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((code2) => {
    descriptors$1[code2] = { value: code2 };
  });
  Object.defineProperties(AxiosError, descriptors$1);
  Object.defineProperty(prototype$1, "isAxiosError", { value: true });
  AxiosError.from = (error, code2, config2, request, response, customProps) => {
    const axiosError = Object.create(prototype$1);
    utils$9.toFlatObject(error, axiosError, function filter2(obj) {
      return obj !== Error.prototype;
    }, (prop2) => {
      return prop2 !== "isAxiosError";
    });
    AxiosError.call(axiosError, error.message, code2, config2, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  const httpAdapter = null;
  function isVisitable(thing) {
    return utils$9.isPlainObject(thing) || utils$9.isArray(thing);
  }
  function removeBrackets(key) {
    return utils$9.endsWith(key, "[]") ? key.slice(0, -2) : key;
  }
  function renderKey(path2, key, dots) {
    if (!path2)
      return key;
    return path2.concat(key).map(function each(token, i2) {
      token = removeBrackets(token);
      return !dots && i2 ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
  }
  function isFlatArray(arr) {
    return utils$9.isArray(arr) && !arr.some(isVisitable);
  }
  const predicates = utils$9.toFlatObject(utils$9, {}, null, function filter2(prop2) {
    return /^is[A-Z]/.test(prop2);
  });
  function toFormData(obj, formData, options) {
    if (!utils$9.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new FormData();
    options = utils$9.toFlatObject(options, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils$9.isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    const visitor2 = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils$9.isSpecCompliantForm(formData);
    if (!utils$9.isFunction(visitor2)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value2) {
      if (value2 === null)
        return "";
      if (utils$9.isDate(value2)) {
        return value2.toISOString();
      }
      if (!useBlob && utils$9.isBlob(value2)) {
        throw new AxiosError("Blob is not supported. Use a Buffer instead.");
      }
      if (utils$9.isArrayBuffer(value2) || utils$9.isTypedArray(value2)) {
        return useBlob && typeof Blob === "function" ? new Blob([value2]) : buffer$1.Buffer.from(value2);
      }
      return value2;
    }
    function defaultVisitor(value2, key, path2) {
      let arr = value2;
      if (value2 && !path2 && typeof value2 === "object") {
        if (utils$9.endsWith(key, "{}")) {
          key = metaTokens ? key : key.slice(0, -2);
          value2 = JSON.stringify(value2);
        } else if (utils$9.isArray(value2) && isFlatArray(value2) || (utils$9.isFileList(value2) || utils$9.endsWith(key, "[]")) && (arr = utils$9.toArray(value2))) {
          key = removeBrackets(key);
          arr.forEach(function each(el, index2) {
            !(utils$9.isUndefined(el) || el === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
              convertValue(el)
            );
          });
          return false;
        }
      }
      if (isVisitable(value2)) {
        return true;
      }
      formData.append(renderKey(path2, key, dots), convertValue(value2));
      return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });
    function build(value2, path2) {
      if (utils$9.isUndefined(value2))
        return;
      if (stack.indexOf(value2) !== -1) {
        throw Error("Circular reference detected in " + path2.join("."));
      }
      stack.push(value2);
      utils$9.forEach(value2, function each(el, key) {
        const result = !(utils$9.isUndefined(el) || el === null) && visitor2.call(
          formData,
          el,
          utils$9.isString(key) ? key.trim() : key,
          path2,
          exposedHelpers
        );
        if (result === true) {
          build(el, path2 ? path2.concat(key) : [key]);
        }
      });
      stack.pop();
    }
    if (!utils$9.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build(obj);
    return formData;
  }
  function encode$6(str2) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(str2).replace(/[!'()~]|%20|%00/g, function replacer(match2) {
      return charMap[match2];
    });
  }
  function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && toFormData(params, this, options);
  }
  const prototype = AxiosURLSearchParams.prototype;
  prototype.append = function append(name, value2) {
    this._pairs.push([name, value2]);
  };
  prototype.toString = function toString2(encoder) {
    const _encode = encoder ? function(value2) {
      return encoder.call(this, value2, encode$6);
    } : encode$6;
    return this._pairs.map(function each(pair) {
      return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
  };
  function encode$5(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function buildURL(url2, params, options) {
    if (!params) {
      return url2;
    }
    const _encode = options && options.encode || encode$5;
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, options);
    } else {
      serializedParams = utils$9.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
    }
    if (serializedParams) {
      const hashmarkIndex = url2.indexOf("#");
      if (hashmarkIndex !== -1) {
        url2 = url2.slice(0, hashmarkIndex);
      }
      url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url2;
  }
  class InterceptorManager {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
     */
    eject(id2) {
      if (this.handlers[id2]) {
        this.handlers[id2] = null;
      }
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn) {
      utils$9.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    }
  }
  const InterceptorManager$1 = InterceptorManager;
  const transitionalDefaults = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
  const FormData$2 = typeof FormData !== "undefined" ? FormData : null;
  const Blob$2 = typeof Blob !== "undefined" ? Blob : null;
  const isStandardBrowserEnv = (() => {
    let product;
    if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
      return false;
    }
    return typeof window !== "undefined" && typeof document !== "undefined";
  })();
  const isStandardBrowserWebWorkerEnv = (() => {
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
  })();
  const platform = {
    isBrowser: true,
    classes: {
      URLSearchParams: URLSearchParams$1,
      FormData: FormData$2,
      Blob: Blob$2
    },
    isStandardBrowserEnv,
    isStandardBrowserWebWorkerEnv,
    protocols: ["http", "https", "file", "blob", "url", "data"]
  };
  function toURLEncodedForm(data2, options) {
    return toFormData(data2, new platform.classes.URLSearchParams(), Object.assign({
      visitor: function(value2, key, path2, helpers2) {
        if (platform.isNode && utils$9.isBuffer(value2)) {
          this.append(key, value2.toString("base64"));
          return false;
        }
        return helpers2.defaultVisitor.apply(this, arguments);
      }
    }, options));
  }
  function parsePropPath(name) {
    return utils$9.matchAll(/\w+|\[(\w*)]/g, name).map((match2) => {
      return match2[0] === "[]" ? "" : match2[1] || match2[0];
    });
  }
  function arrayToObject$1(arr) {
    const obj = {};
    const keys2 = Object.keys(arr);
    let i2;
    const len2 = keys2.length;
    let key;
    for (i2 = 0; i2 < len2; i2++) {
      key = keys2[i2];
      obj[key] = arr[key];
    }
    return obj;
  }
  function formDataToJSON(formData) {
    function buildPath(path2, value2, target, index2) {
      let name = path2[index2++];
      const isNumericKey = Number.isFinite(+name);
      const isLast = index2 >= path2.length;
      name = !name && utils$9.isArray(target) ? target.length : name;
      if (isLast) {
        if (utils$9.hasOwnProp(target, name)) {
          target[name] = [target[name], value2];
        } else {
          target[name] = value2;
        }
        return !isNumericKey;
      }
      if (!target[name] || !utils$9.isObject(target[name])) {
        target[name] = [];
      }
      const result = buildPath(path2, value2, target[name], index2);
      if (result && utils$9.isArray(target[name])) {
        target[name] = arrayToObject$1(target[name]);
      }
      return !isNumericKey;
    }
    if (utils$9.isFormData(formData) && utils$9.isFunction(formData.entries)) {
      const obj = {};
      utils$9.forEachEntry(formData, (name, value2) => {
        buildPath(parsePropPath(name), value2, obj, 0);
      });
      return obj;
    }
    return null;
  }
  function stringifySafely(rawValue, parser2, encoder) {
    if (utils$9.isString(rawValue)) {
      try {
        (parser2 || JSON.parse)(rawValue);
        return utils$9.trim(rawValue);
      } catch (e) {
        if (e.name !== "SyntaxError") {
          throw e;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  const defaults$2 = {
    transitional: transitionalDefaults,
    adapter: ["xhr", "http"],
    transformRequest: [function transformRequest(data2, headers) {
      const contentType = headers.getContentType() || "";
      const hasJSONContentType = contentType.indexOf("application/json") > -1;
      const isObjectPayload = utils$9.isObject(data2);
      if (isObjectPayload && utils$9.isHTMLForm(data2)) {
        data2 = new FormData(data2);
      }
      const isFormData2 = utils$9.isFormData(data2);
      if (isFormData2) {
        if (!hasJSONContentType) {
          return data2;
        }
        return hasJSONContentType ? JSON.stringify(formDataToJSON(data2)) : data2;
      }
      if (utils$9.isArrayBuffer(data2) || utils$9.isBuffer(data2) || utils$9.isStream(data2) || utils$9.isFile(data2) || utils$9.isBlob(data2)) {
        return data2;
      }
      if (utils$9.isArrayBufferView(data2)) {
        return data2.buffer;
      }
      if (utils$9.isURLSearchParams(data2)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
        return data2.toString();
      }
      let isFileList2;
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm(data2, this.formSerializer).toString();
        }
        if ((isFileList2 = utils$9.isFileList(data2)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData;
          return toFormData(
            isFileList2 ? { "files[]": data2 } : data2,
            _FormData && new _FormData(),
            this.formSerializer
          );
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false);
        return stringifySafely(data2);
      }
      return data2;
    }],
    transformResponse: [function transformResponse(data2) {
      const transitional = this.transitional || defaults$2.transitional;
      const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
      const JSONRequested = this.responseType === "json";
      if (data2 && utils$9.isString(data2) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        const silentJSONParsing = transitional && transitional.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data2);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === "SyntaxError") {
              throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e;
          }
        }
      }
      return data2;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: platform.classes.FormData,
      Blob: platform.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  utils$9.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
    defaults$2.headers[method] = {};
  });
  const defaults$3 = defaults$2;
  const ignoreDuplicateOf = utils$9.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
  const parseHeaders = (rawHeaders) => {
    const parsed = {};
    let key;
    let val;
    let i2;
    rawHeaders && rawHeaders.split("\n").forEach(function parser2(line) {
      i2 = line.indexOf(":");
      key = line.substring(0, i2).trim().toLowerCase();
      val = line.substring(i2 + 1).trim();
      if (!key || parsed[key] && ignoreDuplicateOf[key]) {
        return;
      }
      if (key === "set-cookie") {
        if (parsed[key]) {
          parsed[key].push(val);
        } else {
          parsed[key] = [val];
        }
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    });
    return parsed;
  };
  const $internals = Symbol("internals");
  function normalizeHeader(header2) {
    return header2 && String(header2).trim().toLowerCase();
  }
  function normalizeValue(value2) {
    if (value2 === false || value2 == null) {
      return value2;
    }
    return utils$9.isArray(value2) ? value2.map(normalizeValue) : String(value2);
  }
  function parseTokens(str2) {
    const tokens = /* @__PURE__ */ Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match2;
    while (match2 = tokensRE.exec(str2)) {
      tokens[match2[1]] = match2[2];
    }
    return tokens;
  }
  const isValidHeaderName = (str2) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str2.trim());
  function matchHeaderValue(context2, value2, header2, filter2, isHeaderNameFilter) {
    if (utils$9.isFunction(filter2)) {
      return filter2.call(this, value2, header2);
    }
    if (isHeaderNameFilter) {
      value2 = header2;
    }
    if (!utils$9.isString(value2))
      return;
    if (utils$9.isString(filter2)) {
      return value2.indexOf(filter2) !== -1;
    }
    if (utils$9.isRegExp(filter2)) {
      return filter2.test(value2);
    }
  }
  function formatHeader(header2) {
    return header2.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str2) => {
      return char.toUpperCase() + str2;
    });
  }
  function buildAccessors(obj, header2) {
    const accessorName = utils$9.toCamelCase(" " + header2);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header2, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  class AxiosHeaders {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header2, valueOrRewrite, rewrite) {
      const self2 = this;
      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }
        const key = utils$9.findKey(self2, lHeader);
        if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
          self2[key || _header] = normalizeValue(_value);
        }
      }
      const setHeaders = (headers, _rewrite) => utils$9.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils$9.isPlainObject(header2) || header2 instanceof this.constructor) {
        setHeaders(header2, valueOrRewrite);
      } else if (utils$9.isString(header2) && (header2 = header2.trim()) && !isValidHeaderName(header2)) {
        setHeaders(parseHeaders(header2), valueOrRewrite);
      } else {
        header2 != null && setHeader(valueOrRewrite, header2, rewrite);
      }
      return this;
    }
    get(header2, parser2) {
      header2 = normalizeHeader(header2);
      if (header2) {
        const key = utils$9.findKey(this, header2);
        if (key) {
          const value2 = this[key];
          if (!parser2) {
            return value2;
          }
          if (parser2 === true) {
            return parseTokens(value2);
          }
          if (utils$9.isFunction(parser2)) {
            return parser2.call(this, value2, key);
          }
          if (utils$9.isRegExp(parser2)) {
            return parser2.exec(value2);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header2, matcher) {
      header2 = normalizeHeader(header2);
      if (header2) {
        const key = utils$9.findKey(this, header2);
        return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
      }
      return false;
    }
    delete(header2, matcher) {
      const self2 = this;
      let deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader(_header);
        if (_header) {
          const key = utils$9.findKey(self2, _header);
          if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
            delete self2[key];
            deleted = true;
          }
        }
      }
      if (utils$9.isArray(header2)) {
        header2.forEach(deleteHeader);
      } else {
        deleteHeader(header2);
      }
      return deleted;
    }
    clear(matcher) {
      const keys2 = Object.keys(this);
      let i2 = keys2.length;
      let deleted = false;
      while (i2--) {
        const key = keys2[i2];
        if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
          delete this[key];
          deleted = true;
        }
      }
      return deleted;
    }
    normalize(format) {
      const self2 = this;
      const headers = {};
      utils$9.forEach(this, (value2, header2) => {
        const key = utils$9.findKey(headers, header2);
        if (key) {
          self2[key] = normalizeValue(value2);
          delete self2[header2];
          return;
        }
        const normalized = format ? formatHeader(header2) : String(header2).trim();
        if (normalized !== header2) {
          delete self2[header2];
        }
        self2[normalized] = normalizeValue(value2);
        headers[normalized] = true;
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj = /* @__PURE__ */ Object.create(null);
      utils$9.forEach(this, (value2, header2) => {
        value2 != null && value2 !== false && (obj[header2] = asStrings && utils$9.isArray(value2) ? value2.join(", ") : value2);
      });
      return obj;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header2, value2]) => header2 + ": " + value2).join("\n");
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first2, ...targets) {
      const computed = new this(first2);
      targets.forEach((target) => computed.set(target));
      return computed;
    }
    static accessor(header2) {
      const internals = this[$internals] = this[$internals] = {
        accessors: {}
      };
      const accessors = internals.accessors;
      const prototype2 = this.prototype;
      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);
        if (!accessors[lHeader]) {
          buildAccessors(prototype2, _header);
          accessors[lHeader] = true;
        }
      }
      utils$9.isArray(header2) ? header2.forEach(defineAccessor) : defineAccessor(header2);
      return this;
    }
  }
  AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  utils$9.reduceDescriptors(AxiosHeaders.prototype, ({ value: value2 }, key) => {
    let mapped = key[0].toUpperCase() + key.slice(1);
    return {
      get: () => value2,
      set(headerValue) {
        this[mapped] = headerValue;
      }
    };
  });
  utils$9.freezeMethods(AxiosHeaders);
  const AxiosHeaders$1 = AxiosHeaders;
  function transformData(fns, response) {
    const config2 = this || defaults$3;
    const context2 = response || config2;
    const headers = AxiosHeaders$1.from(context2.headers);
    let data2 = context2.data;
    utils$9.forEach(fns, function transform2(fn) {
      data2 = fn.call(config2, data2, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data2;
  }
  function isCancel(value2) {
    return !!(value2 && value2.__CANCEL__);
  }
  function CanceledError(message, config2, request) {
    AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config2, request);
    this.name = "CanceledError";
  }
  utils$9.inherits(CanceledError, AxiosError, {
    __CANCEL__: true
  });
  function settle(resolve2, reject2, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve2(response);
    } else {
      reject2(new AxiosError(
        "Request failed with status code " + response.status,
        [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }
  const cookies = platform.isStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    function standardBrowserEnv() {
      return {
        write: function write(name, value2, expires, path2, domain2, secure) {
          const cookie2 = [];
          cookie2.push(name + "=" + encodeURIComponent(value2));
          if (utils$9.isNumber(expires)) {
            cookie2.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils$9.isString(path2)) {
            cookie2.push("path=" + path2);
          }
          if (utils$9.isString(domain2)) {
            cookie2.push("domain=" + domain2);
          }
          if (secure === true) {
            cookie2.push("secure");
          }
          document.cookie = cookie2.join("; ");
        },
        read: function read(name) {
          const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match2 ? decodeURIComponent(match2[3]) : null;
        },
        remove: function remove2(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }()
  ) : (
    // Non standard browser env (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove2() {
        }
      };
    }()
  );
  function isAbsoluteURL(url2) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
  }
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }
  function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }
  const isURLSameOrigin = platform.isStandardBrowserEnv ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function standardBrowserEnv() {
      const msie = /(msie|trident)/i.test(navigator.userAgent);
      const urlParsingNode = document.createElement("a");
      let originURL;
      function resolveURL(url2) {
        let href = url2;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin2(requestURL) {
        const parsed = utils$9.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv() {
      return function isURLSameOrigin2() {
        return true;
      };
    }()
  );
  function parseProtocol(url2) {
    const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
    return match2 && match2[1] || "";
  }
  function speedometer(samplesCount, min2) {
    samplesCount = samplesCount || 10;
    const bytes2 = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head2 = 0;
    let tail2 = 0;
    let firstSampleTS;
    min2 = min2 !== void 0 ? min2 : 1e3;
    return function push2(chunkLength) {
      const now = Date.now();
      const startedAt = timestamps[tail2];
      if (!firstSampleTS) {
        firstSampleTS = now;
      }
      bytes2[head2] = chunkLength;
      timestamps[head2] = now;
      let i2 = tail2;
      let bytesCount = 0;
      while (i2 !== head2) {
        bytesCount += bytes2[i2++];
        i2 = i2 % samplesCount;
      }
      head2 = (head2 + 1) % samplesCount;
      if (head2 === tail2) {
        tail2 = (tail2 + 1) % samplesCount;
      }
      if (now - firstSampleTS < min2) {
        return;
      }
      const passed = startedAt && now - startedAt;
      return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
  }
  function progressEventReducer(listener, isDownloadStream) {
    let bytesNotified = 0;
    const _speedometer = speedometer(50, 250);
    return (e) => {
      const loaded = e.loaded;
      const total = e.lengthComputable ? e.total : void 0;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;
      bytesNotified = loaded;
      const data2 = {
        loaded,
        total,
        progress: total ? loaded / total : void 0,
        bytes: progressBytes,
        rate: rate ? rate : void 0,
        estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
        event: e
      };
      data2[isDownloadStream ? "download" : "upload"] = true;
      listener(data2);
    };
  }
  const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
  const xhrAdapter = isXHRAdapterSupported && function(config2) {
    return new Promise(function dispatchXhrRequest(resolve2, reject2) {
      let requestData = config2.data;
      const requestHeaders = AxiosHeaders$1.from(config2.headers).normalize();
      const responseType = config2.responseType;
      let onCanceled;
      function done() {
        if (config2.cancelToken) {
          config2.cancelToken.unsubscribe(onCanceled);
        }
        if (config2.signal) {
          config2.signal.removeEventListener("abort", onCanceled);
        }
      }
      let contentType;
      if (utils$9.isFormData(requestData)) {
        if (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv) {
          requestHeaders.setContentType(false);
        } else if (!requestHeaders.getContentType(/^\s*multipart\/form-data/)) {
          requestHeaders.setContentType("multipart/form-data");
        } else if (utils$9.isString(contentType = requestHeaders.getContentType())) {
          requestHeaders.setContentType(contentType.replace(/^\s*(multipart\/form-data);+/, "$1"));
        }
      }
      let request = new XMLHttpRequest();
      if (config2.auth) {
        const username = config2.auth.username || "";
        const password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
        requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
      }
      const fullPath = buildFullPath(config2.baseURL, config2.url);
      request.open(config2.method.toUpperCase(), buildURL(fullPath, config2.params, config2.paramsSerializer), true);
      request.timeout = config2.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        const responseHeaders = AxiosHeaders$1.from(
          "getAllResponseHeaders" in request && request.getAllResponseHeaders()
        );
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config: config2,
          request
        };
        settle(function _resolve(value2) {
          resolve2(value2);
          done();
        }, function _reject(err) {
          reject2(err);
          done();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject2(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config2, request));
        request = null;
      };
      request.onerror = function handleError() {
        reject2(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
        const transitional = config2.transitional || transitionalDefaults;
        if (config2.timeoutErrorMessage) {
          timeoutErrorMessage = config2.timeoutErrorMessage;
        }
        reject2(new AxiosError(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
          config2,
          request
        ));
        request = null;
      };
      if (platform.isStandardBrowserEnv) {
        const xsrfValue = (config2.withCredentials || isURLSameOrigin(fullPath)) && config2.xsrfCookieName && cookies.read(config2.xsrfCookieName);
        if (xsrfValue) {
          requestHeaders.set(config2.xsrfHeaderName, xsrfValue);
        }
      }
      requestData === void 0 && requestHeaders.setContentType(null);
      if ("setRequestHeader" in request) {
        utils$9.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
          request.setRequestHeader(key, val);
        });
      }
      if (!utils$9.isUndefined(config2.withCredentials)) {
        request.withCredentials = !!config2.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = config2.responseType;
      }
      if (typeof config2.onDownloadProgress === "function") {
        request.addEventListener("progress", progressEventReducer(config2.onDownloadProgress, true));
      }
      if (typeof config2.onUploadProgress === "function" && request.upload) {
        request.upload.addEventListener("progress", progressEventReducer(config2.onUploadProgress));
      }
      if (config2.cancelToken || config2.signal) {
        onCanceled = (cancel) => {
          if (!request) {
            return;
          }
          reject2(!cancel || cancel.type ? new CanceledError(null, config2, request) : cancel);
          request.abort();
          request = null;
        };
        config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
        if (config2.signal) {
          config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
        }
      }
      const protocol = parseProtocol(fullPath);
      if (protocol && platform.protocols.indexOf(protocol) === -1) {
        reject2(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config2));
        return;
      }
      request.send(requestData || null);
    });
  };
  const knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter
  };
  utils$9.forEach(knownAdapters, (fn, value2) => {
    if (fn) {
      try {
        Object.defineProperty(fn, "name", { value: value2 });
      } catch (e) {
      }
      Object.defineProperty(fn, "adapterName", { value: value2 });
    }
  });
  const renderReason = (reason) => `- ${reason}`;
  const isResolvedHandle = (adapter) => utils$9.isFunction(adapter) || adapter === null || adapter === false;
  const adapters = {
    getAdapter: (adapters2) => {
      adapters2 = utils$9.isArray(adapters2) ? adapters2 : [adapters2];
      const { length: length2 } = adapters2;
      let nameOrAdapter;
      let adapter;
      const rejectedReasons = {};
      for (let i2 = 0; i2 < length2; i2++) {
        nameOrAdapter = adapters2[i2];
        let id2;
        adapter = nameOrAdapter;
        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
          if (adapter === void 0) {
            throw new AxiosError(`Unknown adapter '${id2}'`);
          }
        }
        if (adapter) {
          break;
        }
        rejectedReasons[id2 || "#" + i2] = adapter;
      }
      if (!adapter) {
        const reasons = Object.entries(rejectedReasons).map(
          ([id2, state2]) => `adapter ${id2} ` + (state2 === false ? "is not supported by the environment" : "is not available in the build")
        );
        let s = length2 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
        throw new AxiosError(
          `There is no suitable adapter to dispatch the request ` + s,
          "ERR_NOT_SUPPORT"
        );
      }
      return adapter;
    },
    adapters: knownAdapters
  };
  function throwIfCancellationRequested(config2) {
    if (config2.cancelToken) {
      config2.cancelToken.throwIfRequested();
    }
    if (config2.signal && config2.signal.aborted) {
      throw new CanceledError(null, config2);
    }
  }
  function dispatchRequest(config2) {
    throwIfCancellationRequested(config2);
    config2.headers = AxiosHeaders$1.from(config2.headers);
    config2.data = transformData.call(
      config2,
      config2.transformRequest
    );
    if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
      config2.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters.getAdapter(config2.adapter || defaults$3.adapter);
    return adapter(config2).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config2);
      response.data = transformData.call(
        config2,
        config2.transformResponse,
        response
      );
      response.headers = AxiosHeaders$1.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config2);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config2,
            config2.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }
  const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
  function mergeConfig(config1, config2) {
    config2 = config2 || {};
    const config3 = {};
    function getMergedValue(target, source, caseless) {
      if (utils$9.isPlainObject(target) && utils$9.isPlainObject(source)) {
        return utils$9.merge.call({ caseless }, target, source);
      } else if (utils$9.isPlainObject(source)) {
        return utils$9.merge({}, source);
      } else if (utils$9.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a, b, caseless) {
      if (!utils$9.isUndefined(b)) {
        return getMergedValue(a, b, caseless);
      } else if (!utils$9.isUndefined(a)) {
        return getMergedValue(void 0, a, caseless);
      }
    }
    function valueFromConfig2(a, b) {
      if (!utils$9.isUndefined(b)) {
        return getMergedValue(void 0, b);
      }
    }
    function defaultToConfig2(a, b) {
      if (!utils$9.isUndefined(b)) {
        return getMergedValue(void 0, b);
      } else if (!utils$9.isUndefined(a)) {
        return getMergedValue(void 0, a);
      }
    }
    function mergeDirectKeys(a, b, prop2) {
      if (prop2 in config2) {
        return getMergedValue(a, b);
      } else if (prop2 in config1) {
        return getMergedValue(void 0, a);
      }
    }
    const mergeMap2 = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
    };
    utils$9.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop2) {
      const merge2 = mergeMap2[prop2] || mergeDeepProperties;
      const configValue = merge2(config1[prop2], config2[prop2], prop2);
      utils$9.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop2] = configValue);
    });
    return config3;
  }
  const VERSION = "1.5.1";
  const validators$1 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i2) => {
    validators$1[type2] = function validator2(thing) {
      return typeof thing === type2 || "a" + (i2 < 1 ? "n " : " ") + type2;
    };
  });
  const deprecatedWarnings = {};
  validators$1.transitional = function transitional(validator2, version2, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return (value2, opt, opts) => {
      if (validator2 === false) {
        throw new AxiosError(
          formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
          AxiosError.ERR_DEPRECATED
        );
      }
      if (version2 && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version2 + " and will be removed in the near future"
          )
        );
      }
      return validator2 ? validator2(value2, opt, opts) : true;
    };
  };
  function assertOptions(options, schema2, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
    }
    const keys2 = Object.keys(options);
    let i2 = keys2.length;
    while (i2-- > 0) {
      const opt = keys2[i2];
      const validator2 = schema2[opt];
      if (validator2) {
        const value2 = options[opt];
        const result = value2 === void 0 || validator2(value2, opt, options);
        if (result !== true) {
          throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
      }
    }
  }
  const validator$1 = {
    assertOptions,
    validators: validators$1
  };
  const validators = validator$1.validators;
  class Axios {
    constructor(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager$1(),
        response: new InterceptorManager$1()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    request(configOrUrl, config2) {
      if (typeof configOrUrl === "string") {
        config2 = config2 || {};
        config2.url = configOrUrl;
      } else {
        config2 = configOrUrl || {};
      }
      config2 = mergeConfig(this.defaults, config2);
      const { transitional, paramsSerializer, headers } = config2;
      if (transitional !== void 0) {
        validator$1.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      if (paramsSerializer != null) {
        if (utils$9.isFunction(paramsSerializer)) {
          config2.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          validator$1.assertOptions(paramsSerializer, {
            encode: validators.function,
            serialize: validators.function
          }, true);
        }
      }
      config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
      let contextHeaders = headers && utils$9.merge(
        headers.common,
        headers[config2.method]
      );
      headers && utils$9.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (method) => {
          delete headers[method];
        }
      );
      config2.headers = AxiosHeaders$1.concat(contextHeaders, headers);
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      let promise;
      let i2 = 0;
      let len2;
      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), void 0];
        chain.unshift.apply(chain, requestInterceptorChain);
        chain.push.apply(chain, responseInterceptorChain);
        len2 = chain.length;
        promise = Promise.resolve(config2);
        while (i2 < len2) {
          promise = promise.then(chain[i2++], chain[i2++]);
        }
        return promise;
      }
      len2 = requestInterceptorChain.length;
      let newConfig = config2;
      i2 = 0;
      while (i2 < len2) {
        const onFulfilled = requestInterceptorChain[i2++];
        const onRejected = requestInterceptorChain[i2++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected.call(this, error);
          break;
        }
      }
      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      i2 = 0;
      len2 = responseInterceptorChain.length;
      while (i2 < len2) {
        promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
      }
      return promise;
    }
    getUri(config2) {
      config2 = mergeConfig(this.defaults, config2);
      const fullPath = buildFullPath(config2.baseURL, config2.url);
      return buildURL(fullPath, config2.params, config2.paramsSerializer);
    }
  }
  utils$9.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios.prototype[method] = function(url2, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        url: url2,
        data: (config2 || {}).data
      }));
    };
  });
  utils$9.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url2, data2, config2) {
        return this.request(mergeConfig(config2 || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url: url2,
          data: data2
        }));
      };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  const Axios$1 = Axios;
  class CancelToken {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      let resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve2) {
        resolvePromise = resolve2;
      });
      const token = this;
      this.promise.then((cancel) => {
        if (!token._listeners)
          return;
        let i2 = token._listeners.length;
        while (i2-- > 0) {
          token._listeners[i2](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = (onfulfilled) => {
        let _resolve;
        const promise = new Promise((resolve2) => {
          token.subscribe(resolve2);
          _resolve = resolve2;
        }).then(onfulfilled);
        promise.cancel = function reject2() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message, config2, request) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError(message, config2, request);
        resolvePromise(token.reason);
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index2 = this._listeners.indexOf(listener);
      if (index2 !== -1) {
        this._listeners.splice(index2, 1);
      }
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    }
  }
  const CancelToken$1 = CancelToken;
  function spread(callback) {
    return function wrap2(arr) {
      return callback.apply(null, arr);
    };
  }
  function isAxiosError(payload) {
    return utils$9.isObject(payload) && payload.isAxiosError === true;
  }
  const HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(HttpStatusCode).forEach(([key, value2]) => {
    HttpStatusCode[value2] = key;
  });
  const HttpStatusCode$1 = HttpStatusCode;
  function createInstance(defaultConfig) {
    const context2 = new Axios$1(defaultConfig);
    const instance = bind$6(Axios$1.prototype.request, context2);
    utils$9.extend(instance, Axios$1.prototype, context2, { allOwnKeys: true });
    utils$9.extend(instance, context2, null, { allOwnKeys: true });
    instance.create = function create2(instanceConfig) {
      return createInstance(mergeConfig(defaultConfig, instanceConfig));
    };
    return instance;
  }
  const axios = createInstance(defaults$3);
  axios.Axios = Axios$1;
  axios.CanceledError = CanceledError;
  axios.CancelToken = CancelToken$1;
  axios.isCancel = isCancel;
  axios.VERSION = VERSION;
  axios.toFormData = toFormData;
  axios.AxiosError = AxiosError;
  axios.Cancel = axios.CanceledError;
  axios.all = function all2(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread;
  axios.isAxiosError = isAxiosError;
  axios.mergeConfig = mergeConfig;
  axios.AxiosHeaders = AxiosHeaders$1;
  axios.formToJSON = (thing) => formDataToJSON(utils$9.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios.getAdapter = adapters.getAdapter;
  axios.HttpStatusCode = HttpStatusCode$1;
  axios.default = axios;
  const axios$1 = axios;
  function _regeneratorRuntime() {
    _regeneratorRuntime = function() {
      return exports3;
    };
    var exports3 = {}, Op = Object.prototype, hasOwn2 = Op.hasOwnProperty, defineProperty2 = Object.defineProperty || function(obj, key, desc) {
      obj[key] = desc.value;
    }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define2(obj, key, value2) {
      return Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      }), obj[key];
    }
    try {
      define2({}, "");
    } catch (err) {
      define2 = function(obj, key, value2) {
        return obj[key] = value2;
      };
    }
    function wrap2(innerFn, outerFn, self2, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context2 = new Context2(tryLocsList || []);
      return defineProperty2(generator, "_invoke", {
        value: makeInvokeMethod(innerFn, self2, context2)
      }), generator;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    exports3.wrap = wrap2;
    var ContinueSentinel = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var IteratorPrototype2 = {};
    define2(IteratorPrototype2, iteratorSymbol, function() {
      return this;
    });
    var getProto2 = Object.getPrototypeOf, NativeIteratorPrototype = getProto2 && getProto2(getProto2(values2([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn2.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype2 = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype2);
    function defineIteratorMethods(prototype2) {
      ["next", "throw", "return"].forEach(function(method) {
        define2(prototype2, method, function(arg) {
          return this._invoke(method, arg);
        });
      });
    }
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve2, reject2) {
        var record = tryCatch(generator[method], generator, arg);
        if ("throw" !== record.type) {
          var result = record.arg, value2 = result.value;
          return value2 && "object" == typeof value2 && hasOwn2.call(value2, "__await") ? PromiseImpl.resolve(value2.__await).then(function(value3) {
            invoke("next", value3, resolve2, reject2);
          }, function(err) {
            invoke("throw", err, resolve2, reject2);
          }) : PromiseImpl.resolve(value2).then(function(unwrapped) {
            result.value = unwrapped, resolve2(result);
          }, function(error) {
            return invoke("throw", error, resolve2, reject2);
          });
        }
        reject2(record.arg);
      }
      var previousPromise;
      defineProperty2(this, "_invoke", {
        value: function(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve2, reject2) {
              invoke(method, arg, resolve2, reject2);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(innerFn, self2, context2) {
      var state2 = "suspendedStart";
      return function(method, arg) {
        if ("executing" === state2)
          throw new Error("Generator is already running");
        if ("completed" === state2) {
          if ("throw" === method)
            throw arg;
          return {
            value: void 0,
            done: true
          };
        }
        for (context2.method = method, context2.arg = arg; ; ) {
          var delegate = context2.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context2);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel)
                continue;
              return delegateResult;
            }
          }
          if ("next" === context2.method)
            context2.sent = context2._sent = context2.arg;
          else if ("throw" === context2.method) {
            if ("suspendedStart" === state2)
              throw state2 = "completed", context2.arg;
            context2.dispatchException(context2.arg);
          } else
            "return" === context2.method && context2.abrupt("return", context2.arg);
          state2 = "executing";
          var record = tryCatch(innerFn, self2, context2);
          if ("normal" === record.type) {
            if (state2 = context2.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
              continue;
            return {
              value: record.arg,
              done: context2.done
            };
          }
          "throw" === record.type && (state2 = "completed", context2.method = "throw", context2.arg = record.arg);
        }
      };
    }
    function maybeInvokeDelegate(delegate, context2) {
      var methodName = context2.method, method = delegate.iterator[methodName];
      if (void 0 === method)
        return context2.delegate = null, "throw" === methodName && delegate.iterator.return && (context2.method = "return", context2.arg = void 0, maybeInvokeDelegate(delegate, context2), "throw" === context2.method) || "return" !== methodName && (context2.method = "throw", context2.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
      var record = tryCatch(method, delegate.iterator, context2.arg);
      if ("throw" === record.type)
        return context2.method = "throw", context2.arg = record.arg, context2.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context2[delegate.resultName] = info.value, context2.next = delegate.nextLoc, "return" !== context2.method && (context2.method = "next", context2.arg = void 0), context2.delegate = null, ContinueSentinel) : info : (context2.method = "throw", context2.arg = new TypeError("iterator result is not an object"), context2.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context2(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
    }
    function values2(iterable) {
      if (iterable || "" === iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod)
          return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next)
          return iterable;
        if (!isNaN(iterable.length)) {
          var i2 = -1, next = function next2() {
            for (; ++i2 < iterable.length; )
              if (hasOwn2.call(iterable, i2))
                return next2.value = iterable[i2], next2.done = false, next2;
            return next2.value = void 0, next2.done = true, next2;
          };
          return next.next = next;
        }
      }
      throw new TypeError(typeof iterable + " is not iterable");
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty2(Gp, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: true
    }), defineProperty2(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: true
    }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports3.isGeneratorFunction = function(genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports3.mark = function(genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports3.awrap = function(arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
      return this;
    }), exports3.AsyncIterator = AsyncIterator, exports3.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap2(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
      return exports3.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
      return this;
    }), define2(Gp, "toString", function() {
      return "[object Generator]";
    }), exports3.keys = function(val) {
      var object = Object(val), keys2 = [];
      for (var key in object)
        keys2.push(key);
      return keys2.reverse(), function next() {
        for (; keys2.length; ) {
          var key2 = keys2.pop();
          if (key2 in object)
            return next.value = key2, next.done = false, next;
        }
        return next.done = true, next;
      };
    }, exports3.values = values2, Context2.prototype = {
      constructor: Context2,
      reset: function(skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
          for (var name in this)
            "t" === name.charAt(0) && hasOwn2.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
      },
      stop: function() {
        this.done = true;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type)
          throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function(exception2) {
        if (this.done)
          throw exception2;
        var context2 = this;
        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception2, context2.next = loc, caught && (context2.method = "next", context2.arg = void 0), !!caught;
        }
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2], record = entry.completion;
          if ("root" === entry.tryLoc)
            return handle("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn2.call(entry, "catchLoc"), hasFinally = hasOwn2.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc)
                return handle(entry.catchLoc, true);
              if (this.prev < entry.finallyLoc)
                return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc)
                return handle(entry.catchLoc, true);
            } else {
              if (!hasFinally)
                throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc)
                return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function(type2, arg) {
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2];
          if (entry.tryLoc <= this.prev && hasOwn2.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && ("break" === type2 || "continue" === type2) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type2, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function(record, afterLoc) {
        if ("throw" === record.type)
          throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function(finallyLoc) {
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2];
          if (entry.finallyLoc === finallyLoc)
            return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      catch: function(tryLoc) {
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function(iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values2(iterable),
          resultName,
          nextLoc
        }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
      }
    }, exports3;
  }
  function asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value2 = info.value;
    } catch (error) {
      reject2(error);
      return;
    }
    if (info.done) {
      resolve2(value2);
    } else {
      Promise.resolve(value2).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve2, reject2) {
        var gen = fn.apply(self2, args);
        function _next(value2) {
          asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, "next", value2);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  function _extends$4() {
    _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$4.apply(this, arguments);
  }
  var RangoClient = /* @__PURE__ */ function() {
    function RangoClient2(apiKey, apiUrl) {
      this.apiUrl = apiUrl || "https://api.rango.exchange";
      this.apiKey = apiKey;
      try {
        if (typeof window !== "undefined") {
          var deviceId = localStorage.getItem("deviceId");
          if (deviceId) {
            this.deviceId = deviceId;
          } else {
            var generatedId = uuid();
            localStorage.setItem("deviceId", generatedId);
            this.deviceId = generatedId;
          }
        } else {
          this.deviceId = uuid();
        }
      } catch (e) {
        this.deviceId = uuid();
      }
      this.httpService = axios$1.create({
        baseURL: this.apiUrl
      });
    }
    var _proto = RangoClient2.prototype;
    _proto.getAllMetadata = /* @__PURE__ */ function() {
      var _getAllMetadata = /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(metaRequest, options) {
        var _metaRequest$blockcha, _metaRequest$swappers, _metaRequest$swappers2, _metaRequest$transact;
        var params, axiosResponse, reformatTokens, tokens, popularTokens;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                params = _extends$4({}, metaRequest, {
                  blockchains: metaRequest == null || (_metaRequest$blockcha = metaRequest.blockchains) == null ? void 0 : _metaRequest$blockcha.join(),
                  swappers: metaRequest == null || (_metaRequest$swappers = metaRequest.swappers) == null ? void 0 : _metaRequest$swappers.join(),
                  swappersGroups: metaRequest == null || (_metaRequest$swappers2 = metaRequest.swappersGroups) == null ? void 0 : _metaRequest$swappers2.join(),
                  transactionTypes: metaRequest == null || (_metaRequest$transact = metaRequest.transactionTypes) == null ? void 0 : _metaRequest$transact.join()
                });
                _context.next = 3;
                return this.httpService.get("/meta/compact?apiKey=" + this.apiKey, _extends$4({
                  params
                }, options));
              case 3:
                axiosResponse = _context.sent;
                reformatTokens = function reformatTokens2(tokens2) {
                  return tokens2.map(function(tm) {
                    return {
                      blockchain: tm.b,
                      symbol: tm.s,
                      image: tm.i,
                      address: tm.a || null,
                      usdPrice: tm.p || null,
                      isSecondaryCoin: tm.is || false,
                      coinSource: tm.c || null,
                      coinSourceUrl: tm.cu || null,
                      name: tm.n || null,
                      decimals: tm.d,
                      isPopular: tm.ip || false,
                      supportedSwappers: tm.ss || []
                    };
                  });
                };
                tokens = reformatTokens(axiosResponse.data.tokens);
                popularTokens = reformatTokens(axiosResponse.data.popularTokens);
                return _context.abrupt("return", _extends$4({}, axiosResponse.data, {
                  tokens,
                  popularTokens
                }));
              case 8:
              case "end":
                return _context.stop();
            }
        }, _callee, this);
      }));
      function getAllMetadata(_x, _x2) {
        return _getAllMetadata.apply(this, arguments);
      }
      return getAllMetadata;
    }();
    _proto.getBlockchains = /* @__PURE__ */ function() {
      var _getBlockchains = /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(options) {
        var axiosResponse;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.httpService.get("/meta/blockchains?apiKey=" + this.apiKey, _extends$4({}, options));
              case 2:
                axiosResponse = _context2.sent;
                return _context2.abrupt("return", axiosResponse.data);
              case 4:
              case "end":
                return _context2.stop();
            }
        }, _callee2, this);
      }));
      function getBlockchains(_x3) {
        return _getBlockchains.apply(this, arguments);
      }
      return getBlockchains;
    }();
    _proto.getSwappers = /* @__PURE__ */ function() {
      var _getSwappers = /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3(options) {
        var axiosResponse;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1)
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.httpService.get("/meta/swappers?apiKey=" + this.apiKey, _extends$4({}, options));
              case 2:
                axiosResponse = _context3.sent;
                return _context3.abrupt("return", axiosResponse.data);
              case 4:
              case "end":
                return _context3.stop();
            }
        }, _callee3, this);
      }));
      function getSwappers(_x4) {
        return _getSwappers.apply(this, arguments);
      }
      return getSwappers;
    }();
    _proto.getBestRoute = /* @__PURE__ */ function() {
      var _getBestRoute = /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4(requestBody, options) {
        var axiosResponse;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1)
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.httpService.post("/routing/best?apiKey=" + this.apiKey, requestBody, _extends$4({
                  headers: {
                    "X-Rango-Id": this.deviceId
                  }
                }, options));
              case 2:
                axiosResponse = _context4.sent;
                return _context4.abrupt("return", axiosResponse.data);
              case 4:
              case "end":
                return _context4.stop();
            }
        }, _callee4, this);
      }));
      function getBestRoute(_x5, _x6) {
        return _getBestRoute.apply(this, arguments);
      }
      return getBestRoute;
    }();
    _proto.checkApproval = /* @__PURE__ */ function() {
      var _checkApproval = /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee5(requestId, txId, options) {
        var axiosResponse;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1)
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.httpService.get("/tx/" + requestId + "/check-approval?apiKey=" + this.apiKey, _extends$4({
                  params: {
                    txId
                  }
                }, options));
              case 2:
                axiosResponse = _context5.sent;
                return _context5.abrupt("return", axiosResponse.data);
              case 4:
              case "end":
                return _context5.stop();
            }
        }, _callee5, this);
      }));
      function checkApproval(_x7, _x8, _x9) {
        return _checkApproval.apply(this, arguments);
      }
      return checkApproval;
    }();
    _proto.checkStatus = /* @__PURE__ */ function() {
      var _checkStatus = /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee6(requestBody, options) {
        var axiosResponse;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1)
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.httpService.post("/tx/check-status?apiKey=" + this.apiKey, requestBody, _extends$4({}, options));
              case 2:
                axiosResponse = _context6.sent;
                return _context6.abrupt("return", axiosResponse.data);
              case 4:
              case "end":
                return _context6.stop();
            }
        }, _callee6, this);
      }));
      function checkStatus(_x10, _x11) {
        return _checkStatus.apply(this, arguments);
      }
      return checkStatus;
    }();
    _proto.createTransaction = /* @__PURE__ */ function() {
      var _createTransaction = /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee7(requestBody, options) {
        var axiosResponse;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1)
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.httpService.post("/tx/create?apiKey=" + this.apiKey, requestBody, _extends$4({}, options));
              case 2:
                axiosResponse = _context7.sent;
                return _context7.abrupt("return", axiosResponse.data);
              case 4:
              case "end":
                return _context7.stop();
            }
        }, _callee7, this);
      }));
      function createTransaction(_x12, _x13) {
        return _createTransaction.apply(this, arguments);
      }
      return createTransaction;
    }();
    _proto.reportFailure = /* @__PURE__ */ function() {
      var _reportFailure = /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee8(requestBody, options) {
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1)
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.httpService.post("/tx/report-tx?apiKey=" + this.apiKey, requestBody, _extends$4({}, options));
              case 2:
              case "end":
                return _context8.stop();
            }
        }, _callee8, this);
      }));
      function reportFailure(_x14, _x15) {
        return _reportFailure.apply(this, arguments);
      }
      return reportFailure;
    }();
    _proto.getWalletsDetails = /* @__PURE__ */ function() {
      var _getWalletsDetails = /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee9(walletAddresses, options) {
        var walletAddressesQueryParams, i2, walletAddress, axiosResponse;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1)
            switch (_context9.prev = _context9.next) {
              case 0:
                walletAddressesQueryParams = "";
                for (i2 = 0; i2 < walletAddresses.length; i2++) {
                  walletAddress = walletAddresses[i2];
                  walletAddressesQueryParams += "&address=" + walletAddress.blockchain + "." + walletAddress.address;
                }
                _context9.next = 4;
                return this.httpService.get("/wallets/details?apiKey=" + this.apiKey + walletAddressesQueryParams, _extends$4({}, options));
              case 4:
                axiosResponse = _context9.sent;
                return _context9.abrupt("return", axiosResponse.data);
              case 6:
              case "end":
                return _context9.stop();
            }
        }, _callee9, this);
      }));
      function getWalletsDetails(_x16, _x17) {
        return _getWalletsDetails.apply(this, arguments);
      }
      return getWalletsDetails;
    }();
    return RangoClient2;
  }();
  var isEvmBlockchain = function isEvmBlockchain2(blockchainMeta) {
    return blockchainMeta.type === "EVM";
  };
  var isCosmosBlockchain = function isCosmosBlockchain2(blockchainMeta) {
    return blockchainMeta.type === "COSMOS";
  };
  var isSolanaBlockchain = function isSolanaBlockchain2(blockchainMeta) {
    return blockchainMeta.type === "SOLANA";
  };
  var isTronBlockchain = function isTronBlockchain2(blockchainMeta) {
    return blockchainMeta.type === "TRON";
  };
  var isTransferBlockchain = function isTransferBlockchain2(blockchainMeta) {
    return blockchainMeta.type === "TRANSFER";
  };
  var isStarknetBlockchain = function isStarknetBlockchain2(blockchainMeta) {
    return blockchainMeta.type === "STARKNET";
  };
  var isTonBlockchain = function isTonBlockchain2(blockchainMeta) {
    return blockchainMeta.type === "TON";
  };
  var evmBlockchains = function evmBlockchains2(blockchains2) {
    return blockchains2.filter(isEvmBlockchain);
  };
  var solanaBlockchain = function solanaBlockchain2(blockchains2) {
    return blockchains2.filter(isSolanaBlockchain);
  };
  var starknetBlockchain = function starknetBlockchain2(blockchains2) {
    return blockchains2.filter(isStarknetBlockchain);
  };
  var tronBlockchain = function tronBlockchain2(blockchains2) {
    return blockchains2.filter(isTronBlockchain);
  };
  var cosmosBlockchains = function cosmosBlockchains2(blockchains2) {
    return blockchains2.filter(isCosmosBlockchain);
  };
  var transferBlockchains = function transferBlockchains2(blockchains2) {
    return blockchains2.filter(isTransferBlockchain);
  };
  var tonBlockchain = function tonBlockchain2(blockchains2) {
    return blockchains2.filter(isTonBlockchain);
  };
  var RoutingResultType;
  (function(RoutingResultType2) {
    RoutingResultType2["OK"] = "OK";
    RoutingResultType2["HIGH_IMPACT"] = "HIGH_IMPACT";
    RoutingResultType2["NO_ROUTE"] = "NO_ROUTE";
    RoutingResultType2["INPUT_LIMIT_ISSUE"] = "INPUT_LIMIT_ISSUE";
  })(RoutingResultType || (RoutingResultType = {}));
  var TransactionType;
  (function(TransactionType2) {
    TransactionType2["EVM"] = "EVM";
    TransactionType2["TRANSFER"] = "TRANSFER";
    TransactionType2["COSMOS"] = "COSMOS";
    TransactionType2["SOLANA"] = "SOLANA";
    TransactionType2["TRON"] = "TRON";
    TransactionType2["STARKNET"] = "STARKNET";
    TransactionType2["TON"] = "TON";
  })(TransactionType || (TransactionType = {}));
  var GenericTransactionType;
  (function(GenericTransactionType2) {
    GenericTransactionType2["EVM"] = "EVM";
    GenericTransactionType2["TRANSFER"] = "TRANSFER";
    GenericTransactionType2["COSMOS"] = "COSMOS";
    GenericTransactionType2["SOLANA"] = "SOLANA";
  })(GenericTransactionType || (GenericTransactionType = {}));
  var TransactionStatus;
  (function(TransactionStatus2) {
    TransactionStatus2["FAILED"] = "failed";
    TransactionStatus2["RUNNING"] = "running";
    TransactionStatus2["SUCCESS"] = "success";
  })(TransactionStatus || (TransactionStatus = {}));
  var isCosmosTransaction = function isCosmosTransaction2(transaction) {
    return transaction.type === TransactionType.COSMOS;
  };
  var isSolanaTransaction = function isSolanaTransaction2(transaction) {
    return transaction.type === TransactionType.SOLANA;
  };
  var isTransferTransaction = function isTransferTransaction2(transaction) {
    return transaction.type === TransactionType.TRANSFER;
  };
  var isStarknetTransaction = function isStarknetTransaction2(transaction) {
    return transaction.type === TransactionType.STARKNET;
  };
  var isTronTransaction = function isTronTransaction2(transaction) {
    return transaction.type === TransactionType.TRON;
  };
  var TonChainID;
  (function(TonChainID2) {
    TonChainID2["MAINNET"] = "-239";
    TonChainID2["TESTNET"] = "-3";
  })(TonChainID || (TonChainID = {}));
  var isTonTransaction = function isTonTransaction2(transaction) {
    return transaction.type === TransactionType.TON;
  };
  var isEvmTransaction = function isEvmTransaction2(transaction) {
    return transaction.type === TransactionType.EVM;
  };
  const rangoSdk_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    get GenericTransactionType() {
      return GenericTransactionType;
    },
    RangoClient,
    get RoutingResultType() {
      return RoutingResultType;
    },
    get TonChainID() {
      return TonChainID;
    },
    get TransactionStatus() {
      return TransactionStatus;
    },
    get TransactionType() {
      return TransactionType;
    },
    cosmosBlockchains,
    evmBlockchains,
    isCosmosBlockchain,
    isCosmosTransaction,
    isEvmBlockchain,
    isEvmTransaction,
    isSolanaBlockchain,
    isSolanaTransaction,
    isStarknetBlockchain,
    isStarknetTransaction,
    isTonBlockchain,
    isTonTransaction,
    isTransferBlockchain,
    isTransferTransaction,
    isTronBlockchain,
    isTronTransaction,
    solanaBlockchain,
    starknetBlockchain,
    tonBlockchain,
    transferBlockchains,
    tronBlockchain
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$2 = /* @__PURE__ */ getAugmentedNamespace(rangoSdk_esm);
  var lib$6 = {};
  var shams = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (sym in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = shams;
  var hasSymbols$1 = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  var test$3 = {
    foo: {}
  };
  var $Object$5 = Object;
  var hasProto$1 = function hasProto2() {
    return { __proto__: test$3 }.foo === test$3.foo && !({ __proto__: null } instanceof $Object$5);
  };
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr$1 = Object.prototype.toString;
  var max$4 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b) {
    var arr = [];
    for (var i2 = 0; i2 < a.length; i2 += 1) {
      arr[i2] = a[i2];
    }
    for (var j = 0; j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i2 = offset || 0, j = 0; i2 < arrLike.length; i2 += 1, j += 1) {
      arr[j] = arrLike[i2];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str2 = "";
    for (var i2 = 0; i2 < arr.length; i2 += 1) {
      str2 += arr[i2];
      if (i2 + 1 < arr.length) {
        str2 += joiner;
      }
    }
    return str2;
  };
  var implementation$1 = function bind2(that) {
    var target = this;
    if (typeof target !== "function" || toStr$1.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max$4(0, target.length - args.length);
    var boundArgs = [];
    for (var i2 = 0; i2 < boundLength; i2++) {
      boundArgs[i2] = "$" + i2;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  var implementation = implementation$1;
  var functionBind = Function.prototype.bind || implementation;
  var hasOwnProperty$d = {}.hasOwnProperty;
  var call$a = Function.prototype.call;
  var src = call$a.bind ? call$a.bind(hasOwnProperty$d) : function(O, P) {
    return call$a.call(hasOwnProperty$d, O, P);
  };
  var undefined$1;
  var $SyntaxError = SyntaxError;
  var $Function = Function;
  var $TypeError$a = TypeError;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = Object.getOwnPropertyDescriptor;
  if ($gOPD) {
    try {
      $gOPD({}, "");
    } catch (e) {
      $gOPD = null;
    }
  }
  var throwTypeError = function() {
    throw new $TypeError$a();
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols = hasSymbols$1();
  var hasProto = hasProto$1();
  var getProto = Object.getPrototypeOf || (hasProto ? function(x2) {
    return x2.__proto__;
  } : null);
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
  var INTRINSICS = {
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError$a,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
  };
  if (getProto) {
    try {
      null.error;
    } catch (e) {
      var errorProto = getProto(getProto(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value2;
    if (name === "%AsyncFunction%") {
      value2 = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value2 = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value2 = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value2 = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto) {
        value2 = getProto(gen.prototype);
      }
    }
    INTRINSICS[name] = value2;
    return value2;
  };
  var LEGACY_ALIASES = {
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind$5 = functionBind;
  var hasOwn$a = src;
  var $concat$1 = bind$5.call(Function.call, Array.prototype.concat);
  var $spliceApply = bind$5.call(Function.apply, Array.prototype.splice);
  var $replace$1 = bind$5.call(Function.call, String.prototype.replace);
  var $strSlice = bind$5.call(Function.call, String.prototype.slice);
  var $exec = bind$5.call(Function.call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string) {
    var first2 = $strSlice(string, 0, 1);
    var last2 = $strSlice(string, -1);
    if (first2 === "%" && last2 !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last2 === "%" && first2 !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace$1(string, rePropName, function(match2, number2, quote2, subString) {
      result[result.length] = quote2 ? $replace$1(subString, reEscapeChar, "$1") : number2 || match2;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn$a(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn$a(INTRINSICS, intrinsicName)) {
      var value2 = INTRINSICS[intrinsicName];
      if (value2 === needsEval) {
        value2 = doEval(intrinsicName);
      }
      if (typeof value2 === "undefined" && !allowMissing) {
        throw new $TypeError$a("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value: value2
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  var getIntrinsic = function GetIntrinsic2(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError$a("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError$a('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts2 = stringToPath(name);
    var intrinsicBaseName = parts2.length > 0 ? parts2[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value2 = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts2, $concat$1([0, 1], alias));
    }
    for (var i2 = 1, isOwn = true; i2 < parts2.length; i2 += 1) {
      var part = parts2[i2];
      var first2 = $strSlice(part, 0, 1);
      var last2 = $strSlice(part, -1);
      if ((first2 === '"' || first2 === "'" || first2 === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first2 !== last2) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn$a(INTRINSICS, intrinsicRealName)) {
        value2 = INTRINSICS[intrinsicRealName];
      } else if (value2 != null) {
        if (!(part in value2)) {
          if (!allowMissing) {
            throw new $TypeError$a("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void 0;
        }
        if ($gOPD && i2 + 1 >= parts2.length) {
          var desc = $gOPD(value2, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value2 = desc.get;
          } else {
            value2 = value2[part];
          }
        } else {
          isOwn = hasOwn$a(value2, part);
          value2 = value2[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value2;
        }
      }
    }
    return value2;
  };
  var callBind$1 = { exports: {} };
  (function(module2) {
    var bind2 = functionBind;
    var GetIntrinsic2 = getIntrinsic;
    var $apply = GetIntrinsic2("%Function.prototype.apply%");
    var $call = GetIntrinsic2("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic2("%Reflect.apply%", true) || bind2.call($call, $apply);
    var $gOPD2 = GetIntrinsic2("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty2 = GetIntrinsic2("%Object.defineProperty%", true);
    var $max = GetIntrinsic2("%Math.max%");
    if ($defineProperty2) {
      try {
        $defineProperty2({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty2 = null;
      }
    }
    module2.exports = function callBind2(originalFunction) {
      var func = $reflectApply(bind2, $call, arguments);
      if ($gOPD2 && $defineProperty2) {
        var desc = $gOPD2(func, "length");
        if (desc.configurable) {
          $defineProperty2(
            func,
            "length",
            { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind2, $apply, arguments);
    };
    if ($defineProperty2) {
      $defineProperty2(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  })(callBind$1);
  var callBindExports = callBind$1.exports;
  var GetIntrinsic$1 = getIntrinsic;
  var callBind = callBindExports;
  var $indexOf = callBind(GetIntrinsic$1("String.prototype.indexOf"));
  var callBound$1 = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic$1(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBind(intrinsic);
    }
    return intrinsic;
  };
  var hasMap$1 = typeof Map === "function" && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap$1 ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
  var mapSize = hasMap$1 && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap$1 && Map.prototype.forEach;
  var hasSet$1 = typeof Set === "function" && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet$1 ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
  var setSize = hasSet$1 && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
  var setForEach = hasSet$1 && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
  var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString$3 = Object.prototype.toString;
  var functionToString = Function.prototype.toString;
  var $match = String.prototype.match;
  var $slice = String.prototype.slice;
  var $replace = String.prototype.replace;
  var $toUpperCase = String.prototype.toUpperCase;
  var $toLowerCase = String.prototype.toLowerCase;
  var $test = RegExp.prototype.test;
  var $concat = Array.prototype.concat;
  var $join = Array.prototype.join;
  var $arrSlice = Array.prototype.slice;
  var $floor = Math.floor;
  var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
  var gOPS = Object.getOwnPropertySymbols;
  var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
  var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
  var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
    return O.__proto__;
  } : null);
  function addNumericSeparator(num, str2) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str2)) {
      return str2;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === "number") {
      var int2 = num < 0 ? -$floor(-num) : $floor(num);
      if (int2 !== num) {
        var intStr = String(int2);
        var dec = $slice.call(str2, intStr.length + 1);
        return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return $replace.call(str2, sepRegex, "$&_");
  }
  var utilInspect = require$$0$3;
  var inspectCustom = utilInspect.custom;
  var inspectSymbol = isSymbol$3(inspectCustom) ? inspectCustom : null;
  var objectInspect = function inspect_(obj, options, depth, seen) {
    var opts = options || {};
    if (has$6(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has$6(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has$6(opts, "customInspect") ? opts.customInspect : true;
    if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    }
    if (has$6(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has$6(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === "undefined") {
      return "undefined";
    }
    if (obj === null) {
      return "null";
    }
    if (typeof obj === "boolean") {
      return obj ? "true" : "false";
    }
    if (typeof obj === "string") {
      return inspectString(obj, opts);
    }
    if (typeof obj === "number") {
      if (obj === 0) {
        return Infinity / obj > 0 ? "0" : "-0";
      }
      var str2 = String(obj);
      return numericSeparator ? addNumericSeparator(obj, str2) : str2;
    }
    if (typeof obj === "bigint") {
      var bigIntStr = String(obj) + "n";
      return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
    if (typeof depth === "undefined") {
      depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
      return isArray$c(obj) ? "[Array]" : "[Object]";
    }
    var indent = getIndent(opts, depth);
    if (typeof seen === "undefined") {
      seen = [];
    } else if (indexOf$1(seen, obj) >= 0) {
      return "[Circular]";
    }
    function inspect2(value2, from2, noIndent) {
      if (from2) {
        seen = $arrSlice.call(seen);
        seen.push(from2);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has$6(opts, "quoteStyle")) {
          newOpts.quoteStyle = opts.quoteStyle;
        }
        return inspect_(value2, newOpts, depth + 1, seen);
      }
      return inspect_(value2, opts, depth + 1, seen);
    }
    if (typeof obj === "function" && !isRegExp$4(obj)) {
      var name = nameOf(obj);
      var keys2 = arrObjKeys(obj, inspect2);
      return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
    }
    if (isSymbol$3(obj)) {
      var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
      return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement$1(obj)) {
      var s = "<" + $toLowerCase.call(String(obj.nodeName));
      var attrs = obj.attributes || [];
      for (var i2 = 0; i2 < attrs.length; i2++) {
        s += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
      }
      s += ">";
      if (obj.childNodes && obj.childNodes.length) {
        s += "...";
      }
      s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
      return s;
    }
    if (isArray$c(obj)) {
      if (obj.length === 0) {
        return "[]";
      }
      var xs = arrObjKeys(obj, inspect2);
      if (indent && !singleLineValues(xs)) {
        return "[" + indentedJoin(xs, indent) + "]";
      }
      return "[ " + $join.call(xs, ", ") + " ]";
    }
    if (isError$2(obj)) {
      var parts2 = arrObjKeys(obj, inspect2);
      if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
        return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect2(obj.cause), parts2), ", ") + " }";
      }
      if (parts2.length === 0) {
        return "[" + String(obj) + "]";
      }
      return "{ [" + String(obj) + "] " + $join.call(parts2, ", ") + " }";
    }
    if (typeof obj === "object" && customInspect) {
      if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
        return utilInspect(obj, { depth: maxDepth - depth });
      } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
        return obj.inspect();
      }
    }
    if (isMap(obj)) {
      var mapParts = [];
      if (mapForEach) {
        mapForEach.call(obj, function(value2, key) {
          mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value2, obj));
        });
      }
      return collectionOf("Map", mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
      var setParts = [];
      if (setForEach) {
        setForEach.call(obj, function(value2) {
          setParts.push(inspect2(value2, obj));
        });
      }
      return collectionOf("Set", setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
      return weakCollectionOf("WeakMap");
    }
    if (isWeakSet(obj)) {
      return weakCollectionOf("WeakSet");
    }
    if (isWeakRef(obj)) {
      return weakCollectionOf("WeakRef");
    }
    if (isNumber$5(obj)) {
      return markBoxed(inspect2(Number(obj)));
    }
    if (isBigInt(obj)) {
      return markBoxed(inspect2(bigIntValueOf.call(obj)));
    }
    if (isBoolean$4(obj)) {
      return markBoxed(booleanValueOf.call(obj));
    }
    if (isString$5(obj)) {
      return markBoxed(inspect2(String(obj)));
    }
    if (!isDate$3(obj) && !isRegExp$4(obj)) {
      var ys = arrObjKeys(obj, inspect2);
      var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
      var protoTag = obj instanceof Object ? "" : "null prototype";
      var stringTag2 = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
      var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
      var tag = constructorTag + (stringTag2 || protoTag ? "[" + $join.call($concat.call([], stringTag2 || [], protoTag || []), ": ") + "] " : "");
      if (ys.length === 0) {
        return tag + "{}";
      }
      if (indent) {
        return tag + "{" + indentedJoin(ys, indent) + "}";
      }
      return tag + "{ " + $join.call(ys, ", ") + " }";
    }
    return String(obj);
  };
  function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
    return quoteChar + s + quoteChar;
  }
  function quote(s) {
    return $replace.call(String(s), /"/g, "&quot;");
  }
  function isArray$c(obj) {
    return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isDate$3(obj) {
    return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isRegExp$4(obj) {
    return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isError$2(obj) {
    return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isString$5(obj) {
    return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isNumber$5(obj) {
    return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isBoolean$4(obj) {
    return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isSymbol$3(obj) {
    if (hasShammedSymbols) {
      return obj && typeof obj === "object" && obj instanceof Symbol;
    }
    if (typeof obj === "symbol") {
      return true;
    }
    if (!obj || typeof obj !== "object" || !symToString) {
      return false;
    }
    try {
      symToString.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isBigInt(obj) {
    if (!obj || typeof obj !== "object" || !bigIntValueOf) {
      return false;
    }
    try {
      bigIntValueOf.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  var hasOwn$9 = Object.prototype.hasOwnProperty || function(key) {
    return key in this;
  };
  function has$6(obj, key) {
    return hasOwn$9.call(obj, key);
  }
  function toStr(obj) {
    return objectToString$3.call(obj);
  }
  function nameOf(f2) {
    if (f2.name) {
      return f2.name;
    }
    var m2 = $match.call(functionToString.call(f2), /^function\s*([\w$]+)/);
    if (m2) {
      return m2[1];
    }
    return null;
  }
  function indexOf$1(xs, x2) {
    if (xs.indexOf) {
      return xs.indexOf(x2);
    }
    for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
      if (xs[i2] === x2) {
        return i2;
      }
    }
    return -1;
  }
  function isMap(x2) {
    if (!mapSize || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      mapSize.call(x2);
      try {
        setSize.call(x2);
      } catch (s) {
        return true;
      }
      return x2 instanceof Map;
    } catch (e) {
    }
    return false;
  }
  function isWeakMap(x2) {
    if (!weakMapHas || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      weakMapHas.call(x2, weakMapHas);
      try {
        weakSetHas.call(x2, weakSetHas);
      } catch (s) {
        return true;
      }
      return x2 instanceof WeakMap;
    } catch (e) {
    }
    return false;
  }
  function isWeakRef(x2) {
    if (!weakRefDeref || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      weakRefDeref.call(x2);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isSet(x2) {
    if (!setSize || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      setSize.call(x2);
      try {
        mapSize.call(x2);
      } catch (m2) {
        return true;
      }
      return x2 instanceof Set;
    } catch (e) {
    }
    return false;
  }
  function isWeakSet(x2) {
    if (!weakSetHas || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      weakSetHas.call(x2, weakSetHas);
      try {
        weakMapHas.call(x2, weakMapHas);
      } catch (s) {
        return true;
      }
      return x2 instanceof WeakSet;
    } catch (e) {
    }
    return false;
  }
  function isElement$1(x2) {
    if (!x2 || typeof x2 !== "object") {
      return false;
    }
    if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
      return true;
    }
    return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
  }
  function inspectString(str2, opts) {
    if (str2.length > opts.maxStringLength) {
      var remaining = str2.length - opts.maxStringLength;
      var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
      return inspectString($slice.call(str2, 0, opts.maxStringLength), opts) + trailer;
    }
    var s = $replace.call($replace.call(str2, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, "single", opts);
  }
  function lowbyte(c) {
    var n2 = c.charCodeAt(0);
    var x2 = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[n2];
    if (x2) {
      return "\\" + x2;
    }
    return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
  }
  function markBoxed(str2) {
    return "Object(" + str2 + ")";
  }
  function weakCollectionOf(type2) {
    return type2 + " { ? }";
  }
  function collectionOf(type2, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
    return type2 + " (" + size + ") {" + joinedEntries + "}";
  }
  function singleLineValues(xs) {
    for (var i2 = 0; i2 < xs.length; i2++) {
      if (indexOf$1(xs[i2], "\n") >= 0) {
        return false;
      }
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === "	") {
      baseIndent = "	";
    } else if (typeof opts.indent === "number" && opts.indent > 0) {
      baseIndent = $join.call(Array(opts.indent + 1), " ");
    } else {
      return null;
    }
    return {
      base: baseIndent,
      prev: $join.call(Array(depth + 1), baseIndent)
    };
  }
  function indentedJoin(xs, indent) {
    if (xs.length === 0) {
      return "";
    }
    var lineJoiner = "\n" + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
  }
  function arrObjKeys(obj, inspect2) {
    var isArr = isArray$c(obj);
    var xs = [];
    if (isArr) {
      xs.length = obj.length;
      for (var i2 = 0; i2 < obj.length; i2++) {
        xs[i2] = has$6(obj, i2) ? inspect2(obj[i2], obj) : "";
      }
    }
    var syms = typeof gOPS === "function" ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
      symMap = {};
      for (var k2 = 0; k2 < syms.length; k2++) {
        symMap["$" + syms[k2]] = syms[k2];
      }
    }
    for (var key in obj) {
      if (!has$6(obj, key)) {
        continue;
      }
      if (isArr && String(Number(key)) === key && key < obj.length) {
        continue;
      }
      if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
        continue;
      } else if ($test.call(/[^\w$]/, key)) {
        xs.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
      } else {
        xs.push(key + ": " + inspect2(obj[key], obj));
      }
    }
    if (typeof gOPS === "function") {
      for (var j = 0; j < syms.length; j++) {
        if (isEnumerable.call(obj, syms[j])) {
          xs.push("[" + inspect2(syms[j]) + "]: " + inspect2(obj[syms[j]], obj));
        }
      }
    }
    return xs;
  }
  var GetIntrinsic = getIntrinsic;
  var callBound = callBound$1;
  var inspect = objectInspect;
  var $TypeError$9 = GetIntrinsic("%TypeError%");
  var $WeakMap = GetIntrinsic("%WeakMap%", true);
  var $Map = GetIntrinsic("%Map%", true);
  var $weakMapGet = callBound("WeakMap.prototype.get", true);
  var $weakMapSet = callBound("WeakMap.prototype.set", true);
  var $weakMapHas = callBound("WeakMap.prototype.has", true);
  var $mapGet = callBound("Map.prototype.get", true);
  var $mapSet = callBound("Map.prototype.set", true);
  var $mapHas = callBound("Map.prototype.has", true);
  var listGetNode = function(list2, key) {
    for (var prev2 = list2, curr; (curr = prev2.next) !== null; prev2 = curr) {
      if (curr.key === key) {
        prev2.next = curr.next;
        curr.next = list2.next;
        list2.next = curr;
        return curr;
      }
    }
  };
  var listGet = function(objects, key) {
    var node = listGetNode(objects, key);
    return node && node.value;
  };
  var listSet = function(objects, key, value2) {
    var node = listGetNode(objects, key);
    if (node) {
      node.value = value2;
    } else {
      objects.next = {
        // eslint-disable-line no-param-reassign
        key,
        next: objects.next,
        value: value2
      };
    }
  };
  var listHas = function(objects, key) {
    return !!listGetNode(objects, key);
  };
  var sideChannel = function getSideChannel2() {
    var $wm;
    var $m;
    var $o;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError$9("Side channel does not contain " + inspect(key));
        }
      },
      get: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapGet($wm, key);
          }
        } else if ($Map) {
          if ($m) {
            return $mapGet($m, key);
          }
        } else {
          if ($o) {
            return listGet($o, key);
          }
        }
      },
      has: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapHas($wm, key);
          }
        } else if ($Map) {
          if ($m) {
            return $mapHas($m, key);
          }
        } else {
          if ($o) {
            return listHas($o, key);
          }
        }
        return false;
      },
      set: function(key, value2) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if (!$wm) {
            $wm = new $WeakMap();
          }
          $weakMapSet($wm, key, value2);
        } else if ($Map) {
          if (!$m) {
            $m = new $Map();
          }
          $mapSet($m, key, value2);
        } else {
          if (!$o) {
            $o = { key: {}, next: null };
          }
          listSet($o, key, value2);
        }
      }
    };
    return channel;
  };
  var replace$4 = String.prototype.replace;
  var percentTwenties = /%20/g;
  var Format = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
  var formats$3 = {
    "default": Format.RFC3986,
    formatters: {
      RFC1738: function(value2) {
        return replace$4.call(value2, percentTwenties, "+");
      },
      RFC3986: function(value2) {
        return String(value2);
      }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
  };
  var formats$2 = formats$3;
  var has$5 = Object.prototype.hasOwnProperty;
  var isArray$b = Array.isArray;
  var hexTable = function() {
    var array = [];
    for (var i2 = 0; i2 < 256; ++i2) {
      array.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
    }
    return array;
  }();
  var compactQueue = function compactQueue2(queue2) {
    while (queue2.length > 1) {
      var item = queue2.pop();
      var obj = item.obj[item.prop];
      if (isArray$b(obj)) {
        var compacted = [];
        for (var j = 0; j < obj.length; ++j) {
          if (typeof obj[j] !== "undefined") {
            compacted.push(obj[j]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
  };
  var arrayToObject = function arrayToObject2(source, options) {
    var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    for (var i2 = 0; i2 < source.length; ++i2) {
      if (typeof source[i2] !== "undefined") {
        obj[i2] = source[i2];
      }
    }
    return obj;
  };
  var merge$6 = function merge2(target, source, options) {
    if (!source) {
      return target;
    }
    if (typeof source !== "object") {
      if (isArray$b(target)) {
        target.push(source);
      } else if (target && typeof target === "object") {
        if (options && (options.plainObjects || options.allowPrototypes) || !has$5.call(Object.prototype, source)) {
          target[source] = true;
        }
      } else {
        return [target, source];
      }
      return target;
    }
    if (!target || typeof target !== "object") {
      return [target].concat(source);
    }
    var mergeTarget = target;
    if (isArray$b(target) && !isArray$b(source)) {
      mergeTarget = arrayToObject(target, options);
    }
    if (isArray$b(target) && isArray$b(source)) {
      source.forEach(function(item, i2) {
        if (has$5.call(target, i2)) {
          var targetItem = target[i2];
          if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
            target[i2] = merge2(targetItem, item, options);
          } else {
            target.push(item);
          }
        } else {
          target[i2] = item;
        }
      });
      return target;
    }
    return Object.keys(source).reduce(function(acc, key) {
      var value2 = source[key];
      if (has$5.call(acc, key)) {
        acc[key] = merge2(acc[key], value2, options);
      } else {
        acc[key] = value2;
      }
      return acc;
    }, mergeTarget);
  };
  var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
      acc[key] = source[key];
      return acc;
    }, target);
  };
  var decode$4 = function(str2, decoder, charset) {
    var strWithoutPlus = str2.replace(/\+/g, " ");
    if (charset === "iso-8859-1") {
      return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    try {
      return decodeURIComponent(strWithoutPlus);
    } catch (e) {
      return strWithoutPlus;
    }
  };
  var encode$4 = function encode2(str2, defaultEncoder, charset, kind, format) {
    if (str2.length === 0) {
      return str2;
    }
    var string = str2;
    if (typeof str2 === "symbol") {
      string = Symbol.prototype.toString.call(str2);
    } else if (typeof str2 !== "string") {
      string = String(str2);
    }
    if (charset === "iso-8859-1") {
      return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
        return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
      });
    }
    var out = "";
    for (var i2 = 0; i2 < string.length; ++i2) {
      var c = string.charCodeAt(i2);
      if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats$2.RFC1738 && (c === 40 || c === 41)) {
        out += string.charAt(i2);
        continue;
      }
      if (c < 128) {
        out = out + hexTable[c];
        continue;
      }
      if (c < 2048) {
        out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
        continue;
      }
      if (c < 55296 || c >= 57344) {
        out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
        continue;
      }
      i2 += 1;
      c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i2) & 1023);
      out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
    }
    return out;
  };
  var compact = function compact2(value2) {
    var queue2 = [{ obj: { o: value2 }, prop: "o" }];
    var refs = [];
    for (var i2 = 0; i2 < queue2.length; ++i2) {
      var item = queue2[i2];
      var obj = item.obj[item.prop];
      var keys2 = Object.keys(obj);
      for (var j = 0; j < keys2.length; ++j) {
        var key = keys2[j];
        var val = obj[key];
        if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
          queue2.push({ obj, prop: key });
          refs.push(val);
        }
      }
    }
    compactQueue(queue2);
    return value2;
  };
  var isRegExp$3 = function isRegExp2(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  };
  var isBuffer$3 = function isBuffer2(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };
  var combine = function combine2(a, b) {
    return [].concat(a, b);
  };
  var maybeMap = function maybeMap2(val, fn) {
    if (isArray$b(val)) {
      var mapped = [];
      for (var i2 = 0; i2 < val.length; i2 += 1) {
        mapped.push(fn(val[i2]));
      }
      return mapped;
    }
    return fn(val);
  };
  var utils$8 = {
    arrayToObject,
    assign,
    combine,
    compact,
    decode: decode$4,
    encode: encode$4,
    isBuffer: isBuffer$3,
    isRegExp: isRegExp$3,
    maybeMap,
    merge: merge$6
  };
  var getSideChannel = sideChannel;
  var utils$7 = utils$8;
  var formats$1 = formats$3;
  var has$4 = Object.prototype.hasOwnProperty;
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + "[]";
    },
    comma: "comma",
    indices: function indices(prefix, key) {
      return prefix + "[" + key + "]";
    },
    repeat: function repeat2(prefix) {
      return prefix;
    }
  };
  var isArray$a = Array.isArray;
  var push$2 = Array.prototype.push;
  var pushToArray = function(arr, valueOrArray) {
    push$2.apply(arr, isArray$a(valueOrArray) ? valueOrArray : [valueOrArray]);
  };
  var toISO = Date.prototype.toISOString;
  var defaultFormat = formats$1["default"];
  var defaults$1 = {
    addQueryPrefix: false,
    allowDots: false,
    charset: "utf-8",
    charsetSentinel: false,
    delimiter: "&",
    encode: true,
    encoder: utils$7.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats$1.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
      return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
    return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
  };
  var sentinel = {};
  var stringify$1 = function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter2, sort2, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel2) {
    var obj = object;
    var tmpSc = sideChannel2;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
      var pos = tmpSc.get(object);
      step += 1;
      if (typeof pos !== "undefined") {
        if (pos === step) {
          throw new RangeError("Cyclic object value");
        } else {
          findFlag = true;
        }
      }
      if (typeof tmpSc.get(sentinel) === "undefined") {
        step = 0;
      }
    }
    if (typeof filter2 === "function") {
      obj = filter2(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate(obj);
    } else if (generateArrayPrefix === "comma" && isArray$a(obj)) {
      obj = utils$7.maybeMap(obj, function(value3) {
        if (value3 instanceof Date) {
          return serializeDate(value3);
        }
        return value3;
      });
    }
    if (obj === null) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly ? encoder(prefix, defaults$1.encoder, charset, "key", format) : prefix;
      }
      obj = "";
    }
    if (isNonNullishPrimitive(obj) || utils$7.isBuffer(obj)) {
      if (encoder) {
        var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$1.encoder, charset, "key", format);
        return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults$1.encoder, charset, "value", format))];
      }
      return [formatter(prefix) + "=" + formatter(String(obj))];
    }
    var values2 = [];
    if (typeof obj === "undefined") {
      return values2;
    }
    var objKeys;
    if (generateArrayPrefix === "comma" && isArray$a(obj)) {
      if (encodeValuesOnly && encoder) {
        obj = utils$7.maybeMap(obj, encoder);
      }
      objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
    } else if (isArray$a(filter2)) {
      objKeys = filter2;
    } else {
      var keys2 = Object.keys(obj);
      objKeys = sort2 ? keys2.sort(sort2) : keys2;
    }
    var adjustedPrefix = commaRoundTrip && isArray$a(obj) && obj.length === 1 ? prefix + "[]" : prefix;
    for (var j = 0; j < objKeys.length; ++j) {
      var key = objKeys[j];
      var value2 = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
      if (skipNulls && value2 === null) {
        continue;
      }
      var keyPrefix = isArray$a(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
      sideChannel2.set(object, step);
      var valueSideChannel = getSideChannel();
      valueSideChannel.set(sentinel, sideChannel2);
      pushToArray(values2, stringify2(
        value2,
        keyPrefix,
        generateArrayPrefix,
        commaRoundTrip,
        strictNullHandling,
        skipNulls,
        generateArrayPrefix === "comma" && encodeValuesOnly && isArray$a(obj) ? null : encoder,
        filter2,
        sort2,
        allowDots,
        serializeDate,
        format,
        formatter,
        encodeValuesOnly,
        charset,
        valueSideChannel
      ));
    }
    return values2;
  };
  var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
    if (!opts) {
      return defaults$1;
    }
    if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
      throw new TypeError("Encoder has to be a function.");
    }
    var charset = opts.charset || defaults$1.charset;
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var format = formats$1["default"];
    if (typeof opts.format !== "undefined") {
      if (!has$4.call(formats$1.formatters, opts.format)) {
        throw new TypeError("Unknown format option provided.");
      }
      format = opts.format;
    }
    var formatter = formats$1.formatters[format];
    var filter2 = defaults$1.filter;
    if (typeof opts.filter === "function" || isArray$a(opts.filter)) {
      filter2 = opts.filter;
    }
    return {
      addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
      allowDots: typeof opts.allowDots === "undefined" ? defaults$1.allowDots : !!opts.allowDots,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
      delimiter: typeof opts.delimiter === "undefined" ? defaults$1.delimiter : opts.delimiter,
      encode: typeof opts.encode === "boolean" ? opts.encode : defaults$1.encode,
      encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$1.encoder,
      encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
      filter: filter2,
      format,
      formatter,
      serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$1.serializeDate,
      skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$1.skipNulls,
      sort: typeof opts.sort === "function" ? opts.sort : null,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
    };
  };
  var stringify_1 = function(object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter2;
    if (typeof options.filter === "function") {
      filter2 = options.filter;
      obj = filter2("", obj);
    } else if (isArray$a(options.filter)) {
      filter2 = options.filter;
      objKeys = filter2;
    }
    var keys2 = [];
    if (typeof obj !== "object" || obj === null) {
      return "";
    }
    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = opts.arrayFormat;
    } else if (opts && "indices" in opts) {
      arrayFormat = opts.indices ? "indices" : "repeat";
    } else {
      arrayFormat = "indices";
    }
    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
    if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    }
    var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (options.sort) {
      objKeys.sort(options.sort);
    }
    var sideChannel2 = getSideChannel();
    for (var i2 = 0; i2 < objKeys.length; ++i2) {
      var key = objKeys[i2];
      if (options.skipNulls && obj[key] === null) {
        continue;
      }
      pushToArray(keys2, stringify$1(
        obj[key],
        key,
        generateArrayPrefix,
        commaRoundTrip,
        options.strictNullHandling,
        options.skipNulls,
        options.encode ? options.encoder : null,
        options.filter,
        options.sort,
        options.allowDots,
        options.serializeDate,
        options.format,
        options.formatter,
        options.encodeValuesOnly,
        options.charset,
        sideChannel2
      ));
    }
    var joined = keys2.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? "?" : "";
    if (options.charsetSentinel) {
      if (options.charset === "iso-8859-1") {
        prefix += "utf8=%26%2310003%3B&";
      } else {
        prefix += "utf8=%E2%9C%93&";
      }
    }
    return joined.length > 0 ? prefix + joined : "";
  };
  var utils$6 = utils$8;
  var has$3 = Object.prototype.hasOwnProperty;
  var isArray$9 = Array.isArray;
  var defaults = {
    allowDots: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: false,
    comma: false,
    decoder: utils$6.decode,
    delimiter: "&",
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1e3,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
  };
  var interpretNumericEntities = function(str2) {
    return str2.replace(/&#(\d+);/g, function($0, numberStr) {
      return String.fromCharCode(parseInt(numberStr, 10));
    });
  };
  var parseArrayValue = function(val, options) {
    if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
      return val.split(",");
    }
    return val;
  };
  var isoSentinel = "utf8=%26%2310003%3B";
  var charsetSentinel = "utf8=%E2%9C%93";
  var parseValues = function parseQueryStringValues(str2, options) {
    var obj = { __proto__: null };
    var cleanStr = options.ignoreQueryPrefix ? str2.replace(/^\?/, "") : str2;
    var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
    var parts2 = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1;
    var i2;
    var charset = options.charset;
    if (options.charsetSentinel) {
      for (i2 = 0; i2 < parts2.length; ++i2) {
        if (parts2[i2].indexOf("utf8=") === 0) {
          if (parts2[i2] === charsetSentinel) {
            charset = "utf-8";
          } else if (parts2[i2] === isoSentinel) {
            charset = "iso-8859-1";
          }
          skipIndex = i2;
          i2 = parts2.length;
        }
      }
    }
    for (i2 = 0; i2 < parts2.length; ++i2) {
      if (i2 === skipIndex) {
        continue;
      }
      var part = parts2[i2];
      var bracketEqualsPos = part.indexOf("]=");
      var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
      var key, val;
      if (pos === -1) {
        key = options.decoder(part, defaults.decoder, charset, "key");
        val = options.strictNullHandling ? null : "";
      } else {
        key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
        val = utils$6.maybeMap(
          parseArrayValue(part.slice(pos + 1), options),
          function(encodedVal) {
            return options.decoder(encodedVal, defaults.decoder, charset, "value");
          }
        );
      }
      if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
        val = interpretNumericEntities(val);
      }
      if (part.indexOf("[]=") > -1) {
        val = isArray$9(val) ? [val] : val;
      }
      if (has$3.call(obj, key)) {
        obj[key] = utils$6.combine(obj[key], val);
      } else {
        obj[key] = val;
      }
    }
    return obj;
  };
  var parseObject = function(chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);
    for (var i2 = chain.length - 1; i2 >= 0; --i2) {
      var obj;
      var root2 = chain[i2];
      if (root2 === "[]" && options.parseArrays) {
        obj = [].concat(leaf);
      } else {
        obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
        var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
        var index2 = parseInt(cleanRoot, 10);
        if (!options.parseArrays && cleanRoot === "") {
          obj = { 0: leaf };
        } else if (!isNaN(index2) && root2 !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
          obj = [];
          obj[index2] = leaf;
        } else if (cleanRoot !== "__proto__") {
          obj[cleanRoot] = leaf;
        }
      }
      leaf = obj;
    }
    return leaf;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
      return;
    }
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = options.depth > 0 && brackets.exec(key);
    var parent2 = segment ? key.slice(0, segment.index) : key;
    var keys2 = [];
    if (parent2) {
      if (!options.plainObjects && has$3.call(Object.prototype, parent2)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys2.push(parent2);
    }
    var i2 = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i2 < options.depth) {
      i2 += 1;
      if (!options.plainObjects && has$3.call(Object.prototype, segment[1].slice(1, -1))) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys2.push(segment[1]);
    }
    if (segment) {
      keys2.push("[" + key.slice(segment.index) + "]");
    }
    return parseObject(keys2, val, options, valuesParsed);
  };
  var normalizeParseOptions = function normalizeParseOptions2(opts) {
    if (!opts) {
      return defaults;
    }
    if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
      throw new TypeError("Decoder has to be a function.");
    }
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
    return {
      allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
      allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
      allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
      arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
      comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
      decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
      delimiter: typeof opts.delimiter === "string" || utils$6.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
      // eslint-disable-next-line no-implicit-coercion, no-extra-parens
      depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
      ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
      parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
      parseArrays: opts.parseArrays !== false,
      plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
    };
  };
  var parse$7 = function(str2, opts) {
    var options = normalizeParseOptions(opts);
    if (str2 === "" || str2 === null || typeof str2 === "undefined") {
      return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    }
    var tempObj = typeof str2 === "string" ? parseValues(str2, options) : str2;
    var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    var keys2 = Object.keys(tempObj);
    for (var i2 = 0; i2 < keys2.length; ++i2) {
      var key = keys2[i2];
      var newObj = parseKeys(key, tempObj[key], options, typeof str2 === "string");
      obj = utils$6.merge(obj, newObj, options);
    }
    if (options.allowSparse === true) {
      return obj;
    }
    return utils$6.compact(obj);
  };
  var stringify = stringify_1;
  var parse$6 = parse$7;
  var formats = formats$3;
  var lib$5 = {
    formats,
    parse: parse$6,
    stringify
  };
  const qs = /* @__PURE__ */ getDefaultExportFromCjs(lib$5);
  /*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
  function isNothing(subject) {
    return typeof subject === "undefined" || subject === null;
  }
  function isObject$j(subject) {
    return typeof subject === "object" && subject !== null;
  }
  function toArray$2(sequence) {
    if (Array.isArray(sequence))
      return sequence;
    else if (isNothing(sequence))
      return [];
    return [sequence];
  }
  function extend(target, source) {
    var index2, length2, key, sourceKeys;
    if (source) {
      sourceKeys = Object.keys(source);
      for (index2 = 0, length2 = sourceKeys.length; index2 < length2; index2 += 1) {
        key = sourceKeys[index2];
        target[key] = source[key];
      }
    }
    return target;
  }
  function repeat$1(string, count2) {
    var result = "", cycle;
    for (cycle = 0; cycle < count2; cycle += 1) {
      result += string;
    }
    return result;
  }
  function isNegativeZero(number2) {
    return number2 === 0 && Number.NEGATIVE_INFINITY === 1 / number2;
  }
  var isNothing_1 = isNothing;
  var isObject_1$2 = isObject$j;
  var toArray_1 = toArray$2;
  var repeat_1 = repeat$1;
  var isNegativeZero_1 = isNegativeZero;
  var extend_1 = extend;
  var common$1 = {
    isNothing: isNothing_1,
    isObject: isObject_1$2,
    toArray: toArray_1,
    repeat: repeat_1,
    isNegativeZero: isNegativeZero_1,
    extend: extend_1
  };
  function formatError(exception2, compact2) {
    var where = "", message = exception2.reason || "(unknown reason)";
    if (!exception2.mark)
      return message;
    if (exception2.mark.name) {
      where += 'in "' + exception2.mark.name + '" ';
    }
    where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
    if (!compact2 && exception2.mark.snippet) {
      where += "\n\n" + exception2.mark.snippet;
    }
    return message + " " + where;
  }
  function YAMLException$1(reason, mark) {
    Error.call(this);
    this.name = "YAMLException";
    this.reason = reason;
    this.mark = mark;
    this.message = formatError(this, false);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack || "";
    }
  }
  YAMLException$1.prototype = Object.create(Error.prototype);
  YAMLException$1.prototype.constructor = YAMLException$1;
  YAMLException$1.prototype.toString = function toString2(compact2) {
    return this.name + ": " + formatError(this, compact2);
  };
  var exception = YAMLException$1;
  function getLine(buffer2, lineStart, lineEnd, position2, maxLineLength) {
    var head2 = "";
    var tail2 = "";
    var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
    if (position2 - lineStart > maxHalfLength) {
      head2 = " ... ";
      lineStart = position2 - maxHalfLength + head2.length;
    }
    if (lineEnd - position2 > maxHalfLength) {
      tail2 = " ...";
      lineEnd = position2 + maxHalfLength - tail2.length;
    }
    return {
      str: head2 + buffer2.slice(lineStart, lineEnd).replace(/\t/g, "") + tail2,
      pos: position2 - lineStart + head2.length
      // relative position
    };
  }
  function padStart(string, max2) {
    return common$1.repeat(" ", max2 - string.length) + string;
  }
  function makeSnippet(mark, options) {
    options = Object.create(options || null);
    if (!mark.buffer)
      return null;
    if (!options.maxLength)
      options.maxLength = 79;
    if (typeof options.indent !== "number")
      options.indent = 1;
    if (typeof options.linesBefore !== "number")
      options.linesBefore = 3;
    if (typeof options.linesAfter !== "number")
      options.linesAfter = 2;
    var re2 = /\r?\n|\r|\0/g;
    var lineStarts = [0];
    var lineEnds = [];
    var match2;
    var foundLineNo = -1;
    while (match2 = re2.exec(mark.buffer)) {
      lineEnds.push(match2.index);
      lineStarts.push(match2.index + match2[0].length);
      if (mark.position <= match2.index && foundLineNo < 0) {
        foundLineNo = lineStarts.length - 2;
      }
    }
    if (foundLineNo < 0)
      foundLineNo = lineStarts.length - 1;
    var result = "", i2, line;
    var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
    var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
    for (i2 = 1; i2 <= options.linesBefore; i2++) {
      if (foundLineNo - i2 < 0)
        break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo - i2],
        lineEnds[foundLineNo - i2],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i2]),
        maxLineLength
      );
      result = common$1.repeat(" ", options.indent) + padStart((mark.line - i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
    }
    line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
    result += common$1.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
    result += common$1.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
    for (i2 = 1; i2 <= options.linesAfter; i2++) {
      if (foundLineNo + i2 >= lineEnds.length)
        break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo + i2],
        lineEnds[foundLineNo + i2],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i2]),
        maxLineLength
      );
      result += common$1.repeat(" ", options.indent) + padStart((mark.line + i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n";
    }
    return result.replace(/\n$/, "");
  }
  var snippet = makeSnippet;
  var TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases"
  ];
  var YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function compileStyleAliases(map2) {
    var result = {};
    if (map2 !== null) {
      Object.keys(map2).forEach(function(style) {
        map2[style].forEach(function(alias) {
          result[String(alias)] = style;
        });
      });
    }
    return result;
  }
  function Type$1(tag, options) {
    options = options || {};
    Object.keys(options).forEach(function(name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
        throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
      }
    });
    this.options = options;
    this.tag = tag;
    this.kind = options["kind"] || null;
    this.resolve = options["resolve"] || function() {
      return true;
    };
    this.construct = options["construct"] || function(data2) {
      return data2;
    };
    this.instanceOf = options["instanceOf"] || null;
    this.predicate = options["predicate"] || null;
    this.represent = options["represent"] || null;
    this.representName = options["representName"] || null;
    this.defaultStyle = options["defaultStyle"] || null;
    this.multi = options["multi"] || false;
    this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
  }
  var type$2 = Type$1;
  function compileList(schema2, name) {
    var result = [];
    schema2[name].forEach(function(currentType) {
      var newIndex = result.length;
      result.forEach(function(previousType, previousIndex) {
        if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
          newIndex = previousIndex;
        }
      });
      result[newIndex] = currentType;
    });
    return result;
  }
  function compileMap() {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: {
        scalar: [],
        sequence: [],
        mapping: [],
        fallback: []
      }
    }, index2, length2;
    function collectType(type2) {
      if (type2.multi) {
        result.multi[type2.kind].push(type2);
        result.multi["fallback"].push(type2);
      } else {
        result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
      }
    }
    for (index2 = 0, length2 = arguments.length; index2 < length2; index2 += 1) {
      arguments[index2].forEach(collectType);
    }
    return result;
  }
  function Schema$1$1(definition) {
    return this.extend(definition);
  }
  Schema$1$1.prototype.extend = function extend2(definition) {
    var implicit = [];
    var explicit = [];
    if (definition instanceof type$2) {
      explicit.push(definition);
    } else if (Array.isArray(definition)) {
      explicit = explicit.concat(definition);
    } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
      if (definition.implicit)
        implicit = implicit.concat(definition.implicit);
      if (definition.explicit)
        explicit = explicit.concat(definition.explicit);
    } else {
      throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
    }
    implicit.forEach(function(type$12) {
      if (!(type$12 instanceof type$2)) {
        throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
      if (type$12.loadKind && type$12.loadKind !== "scalar") {
        throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      }
      if (type$12.multi) {
        throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
      }
    });
    explicit.forEach(function(type$12) {
      if (!(type$12 instanceof type$2)) {
        throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
    });
    var result = Object.create(Schema$1$1.prototype);
    result.implicit = (this.implicit || []).concat(implicit);
    result.explicit = (this.explicit || []).concat(explicit);
    result.compiledImplicit = compileList(result, "implicit");
    result.compiledExplicit = compileList(result, "explicit");
    result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
    return result;
  };
  var schema = Schema$1$1;
  var str = new type$2("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data2) {
      return data2 !== null ? data2 : "";
    }
  });
  var seq = new type$2("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data2) {
      return data2 !== null ? data2 : [];
    }
  });
  var map$5 = new type$2("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data2) {
      return data2 !== null ? data2 : {};
    }
  });
  var failsafe = new schema({
    explicit: [
      str,
      seq,
      map$5
    ]
  });
  function resolveYamlNull(data2) {
    if (data2 === null)
      return true;
    var max2 = data2.length;
    return max2 === 1 && data2 === "~" || max2 === 4 && (data2 === "null" || data2 === "Null" || data2 === "NULL");
  }
  function constructYamlNull() {
    return null;
  }
  function isNull$4(object) {
    return object === null;
  }
  var _null = new type$2("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull$4,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      },
      empty: function() {
        return "";
      }
    },
    defaultStyle: "lowercase"
  });
  function resolveYamlBoolean(data2) {
    if (data2 === null)
      return false;
    var max2 = data2.length;
    return max2 === 4 && (data2 === "true" || data2 === "True" || data2 === "TRUE") || max2 === 5 && (data2 === "false" || data2 === "False" || data2 === "FALSE");
  }
  function constructYamlBoolean(data2) {
    return data2 === "true" || data2 === "True" || data2 === "TRUE";
  }
  function isBoolean$3(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
  }
  var bool = new type$2("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean$3,
    represent: {
      lowercase: function(object) {
        return object ? "true" : "false";
      },
      uppercase: function(object) {
        return object ? "TRUE" : "FALSE";
      },
      camelcase: function(object) {
        return object ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  });
  function isHexCode(c) {
    return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
  }
  function isOctCode(c) {
    return 48 <= c && c <= 55;
  }
  function isDecCode(c) {
    return 48 <= c && c <= 57;
  }
  function resolveYamlInteger(data2) {
    if (data2 === null)
      return false;
    var max2 = data2.length, index2 = 0, hasDigits = false, ch;
    if (!max2)
      return false;
    ch = data2[index2];
    if (ch === "-" || ch === "+") {
      ch = data2[++index2];
    }
    if (ch === "0") {
      if (index2 + 1 === max2)
        return true;
      ch = data2[++index2];
      if (ch === "b") {
        index2++;
        for (; index2 < max2; index2++) {
          ch = data2[index2];
          if (ch === "_")
            continue;
          if (ch !== "0" && ch !== "1")
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "x") {
        index2++;
        for (; index2 < max2; index2++) {
          ch = data2[index2];
          if (ch === "_")
            continue;
          if (!isHexCode(data2.charCodeAt(index2)))
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "o") {
        index2++;
        for (; index2 < max2; index2++) {
          ch = data2[index2];
          if (ch === "_")
            continue;
          if (!isOctCode(data2.charCodeAt(index2)))
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
    }
    if (ch === "_")
      return false;
    for (; index2 < max2; index2++) {
      ch = data2[index2];
      if (ch === "_")
        continue;
      if (!isDecCode(data2.charCodeAt(index2))) {
        return false;
      }
      hasDigits = true;
    }
    if (!hasDigits || ch === "_")
      return false;
    return true;
  }
  function constructYamlInteger(data2) {
    var value2 = data2, sign = 1, ch;
    if (value2.indexOf("_") !== -1) {
      value2 = value2.replace(/_/g, "");
    }
    ch = value2[0];
    if (ch === "-" || ch === "+") {
      if (ch === "-")
        sign = -1;
      value2 = value2.slice(1);
      ch = value2[0];
    }
    if (value2 === "0")
      return 0;
    if (ch === "0") {
      if (value2[1] === "b")
        return sign * parseInt(value2.slice(2), 2);
      if (value2[1] === "x")
        return sign * parseInt(value2.slice(2), 16);
      if (value2[1] === "o")
        return sign * parseInt(value2.slice(2), 8);
    }
    return sign * parseInt(value2, 10);
  }
  function isInteger$4(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common$1.isNegativeZero(object));
  }
  var int = new type$2("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger$4,
    represent: {
      binary: function(obj) {
        return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
      },
      octal: function(obj) {
        return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
      },
      decimal: function(obj) {
        return obj.toString(10);
      },
      /* eslint-disable max-len */
      hexadecimal: function(obj) {
        return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  });
  var YAML_FLOAT_PATTERN = new RegExp(
    // 2.5e4, 2.5 and integers
    "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
  function resolveYamlFloat(data2) {
    if (data2 === null)
      return false;
    if (!YAML_FLOAT_PATTERN.test(data2) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data2[data2.length - 1] === "_") {
      return false;
    }
    return true;
  }
  function constructYamlFloat(data2) {
    var value2, sign;
    value2 = data2.replace(/_/g, "").toLowerCase();
    sign = value2[0] === "-" ? -1 : 1;
    if ("+-".indexOf(value2[0]) >= 0) {
      value2 = value2.slice(1);
    }
    if (value2 === ".inf") {
      return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    } else if (value2 === ".nan") {
      return NaN;
    }
    return sign * parseFloat(value2, 10);
  }
  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
  function representYamlFloat(object, style) {
    var res;
    if (isNaN(object)) {
      switch (style) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    } else if (Number.POSITIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    } else if (Number.NEGATIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    } else if (common$1.isNegativeZero(object)) {
      return "-0.0";
    }
    res = object.toString(10);
    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
  }
  function isFloat(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common$1.isNegativeZero(object));
  }
  var float = new type$2("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
  });
  var json = failsafe.extend({
    implicit: [
      _null,
      bool,
      int,
      float
    ]
  });
  var core$2 = json;
  var YAML_DATE_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
  );
  var YAML_TIMESTAMP_REGEXP = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
  function resolveYamlTimestamp(data2) {
    if (data2 === null)
      return false;
    if (YAML_DATE_REGEXP.exec(data2) !== null)
      return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data2) !== null)
      return true;
    return false;
  }
  function constructYamlTimestamp(data2) {
    var match2, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    match2 = YAML_DATE_REGEXP.exec(data2);
    if (match2 === null)
      match2 = YAML_TIMESTAMP_REGEXP.exec(data2);
    if (match2 === null)
      throw new Error("Date resolve error");
    year = +match2[1];
    month = +match2[2] - 1;
    day = +match2[3];
    if (!match2[4]) {
      return new Date(Date.UTC(year, month, day));
    }
    hour = +match2[4];
    minute = +match2[5];
    second = +match2[6];
    if (match2[7]) {
      fraction = match2[7].slice(0, 3);
      while (fraction.length < 3) {
        fraction += "0";
      }
      fraction = +fraction;
    }
    if (match2[9]) {
      tz_hour = +match2[10];
      tz_minute = +(match2[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 6e4;
      if (match2[9] === "-")
        delta = -delta;
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta)
      date.setTime(date.getTime() - delta);
    return date;
  }
  function representYamlTimestamp(object) {
    return object.toISOString();
  }
  var timestamp$1 = new type$2("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });
  function resolveYamlMerge(data2) {
    return data2 === "<<" || data2 === null;
  }
  var merge$5 = new type$2("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
  });
  var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
  function resolveYamlBinary(data2) {
    if (data2 === null)
      return false;
    var code2, idx, bitlen = 0, max2 = data2.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max2; idx++) {
      code2 = map2.indexOf(data2.charAt(idx));
      if (code2 > 64)
        continue;
      if (code2 < 0)
        return false;
      bitlen += 6;
    }
    return bitlen % 8 === 0;
  }
  function constructYamlBinary(data2) {
    var idx, tailbits, input = data2.replace(/[\r\n=]/g, ""), max2 = input.length, map2 = BASE64_MAP, bits = 0, result = [];
    for (idx = 0; idx < max2; idx++) {
      if (idx % 4 === 0 && idx) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      }
      bits = bits << 6 | map2.indexOf(input.charAt(idx));
    }
    tailbits = max2 % 4 * 6;
    if (tailbits === 0) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    } else if (tailbits === 18) {
      result.push(bits >> 10 & 255);
      result.push(bits >> 2 & 255);
    } else if (tailbits === 12) {
      result.push(bits >> 4 & 255);
    }
    return new Uint8Array(result);
  }
  function representYamlBinary(object) {
    var result = "", bits = 0, idx, tail2, max2 = object.length, map2 = BASE64_MAP;
    for (idx = 0; idx < max2; idx++) {
      if (idx % 3 === 0 && idx) {
        result += map2[bits >> 18 & 63];
        result += map2[bits >> 12 & 63];
        result += map2[bits >> 6 & 63];
        result += map2[bits & 63];
      }
      bits = (bits << 8) + object[idx];
    }
    tail2 = max2 % 3;
    if (tail2 === 0) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    } else if (tail2 === 2) {
      result += map2[bits >> 10 & 63];
      result += map2[bits >> 4 & 63];
      result += map2[bits << 2 & 63];
      result += map2[64];
    } else if (tail2 === 1) {
      result += map2[bits >> 2 & 63];
      result += map2[bits << 4 & 63];
      result += map2[64];
      result += map2[64];
    }
    return result;
  }
  function isBinary$2(obj) {
    return Object.prototype.toString.call(obj) === "[object Uint8Array]";
  }
  var binary$1 = new type$2("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary$2,
    represent: representYamlBinary
  });
  var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
  var _toString$2 = Object.prototype.toString;
  function resolveYamlOmap(data2) {
    if (data2 === null)
      return true;
    var objectKeys2 = [], index2, length2, pair, pairKey, pairHasKey, object = data2;
    for (index2 = 0, length2 = object.length; index2 < length2; index2 += 1) {
      pair = object[index2];
      pairHasKey = false;
      if (_toString$2.call(pair) !== "[object Object]")
        return false;
      for (pairKey in pair) {
        if (_hasOwnProperty$3.call(pair, pairKey)) {
          if (!pairHasKey)
            pairHasKey = true;
          else
            return false;
        }
      }
      if (!pairHasKey)
        return false;
      if (objectKeys2.indexOf(pairKey) === -1)
        objectKeys2.push(pairKey);
      else
        return false;
    }
    return true;
  }
  function constructYamlOmap(data2) {
    return data2 !== null ? data2 : [];
  }
  var omap = new type$2("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });
  var _toString$1 = Object.prototype.toString;
  function resolveYamlPairs(data2) {
    if (data2 === null)
      return true;
    var index2, length2, pair, keys2, result, object = data2;
    result = new Array(object.length);
    for (index2 = 0, length2 = object.length; index2 < length2; index2 += 1) {
      pair = object[index2];
      if (_toString$1.call(pair) !== "[object Object]")
        return false;
      keys2 = Object.keys(pair);
      if (keys2.length !== 1)
        return false;
      result[index2] = [keys2[0], pair[keys2[0]]];
    }
    return true;
  }
  function constructYamlPairs(data2) {
    if (data2 === null)
      return [];
    var index2, length2, pair, keys2, result, object = data2;
    result = new Array(object.length);
    for (index2 = 0, length2 = object.length; index2 < length2; index2 += 1) {
      pair = object[index2];
      keys2 = Object.keys(pair);
      result[index2] = [keys2[0], pair[keys2[0]]];
    }
    return result;
  }
  var pairs$1 = new type$2("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });
  var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
  function resolveYamlSet(data2) {
    if (data2 === null)
      return true;
    var key, object = data2;
    for (key in object) {
      if (_hasOwnProperty$2.call(object, key)) {
        if (object[key] !== null)
          return false;
      }
    }
    return true;
  }
  function constructYamlSet(data2) {
    return data2 !== null ? data2 : {};
  }
  var set$1 = new type$2("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });
  var _default = core$2.extend({
    implicit: [
      timestamp$1,
      merge$5
    ],
    explicit: [
      binary$1,
      omap,
      pairs$1,
      set$1
    ]
  });
  var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  var CONTEXT_FLOW_IN = 1;
  var CONTEXT_FLOW_OUT = 2;
  var CONTEXT_BLOCK_IN = 3;
  var CONTEXT_BLOCK_OUT = 4;
  var CHOMPING_CLIP = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP = 3;
  var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function is_EOL(c) {
    return c === 10 || c === 13;
  }
  function is_WHITE_SPACE(c) {
    return c === 9 || c === 32;
  }
  function is_WS_OR_EOL(c) {
    return c === 9 || c === 32 || c === 10 || c === 13;
  }
  function is_FLOW_INDICATOR(c) {
    return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
  }
  function fromHexCode(c) {
    var lc;
    if (48 <= c && c <= 57) {
      return c - 48;
    }
    lc = c | 32;
    if (97 <= lc && lc <= 102) {
      return lc - 97 + 10;
    }
    return -1;
  }
  function escapedHexLen(c) {
    if (c === 120) {
      return 2;
    }
    if (c === 117) {
      return 4;
    }
    if (c === 85) {
      return 8;
    }
    return 0;
  }
  function fromDecimalCode(c) {
    if (48 <= c && c <= 57) {
      return c - 48;
    }
    return -1;
  }
  function simpleEscapeSequence(c) {
    return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "" : c === 95 ? "" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
  }
  function charFromCodepoint(c) {
    if (c <= 65535) {
      return String.fromCharCode(c);
    }
    return String.fromCharCode(
      (c - 65536 >> 10) + 55296,
      (c - 65536 & 1023) + 56320
    );
  }
  var simpleEscapeCheck = new Array(256);
  var simpleEscapeMap = new Array(256);
  for (var i$1 = 0; i$1 < 256; i$1++) {
    simpleEscapeCheck[i$1] = simpleEscapeSequence(i$1) ? 1 : 0;
    simpleEscapeMap[i$1] = simpleEscapeSequence(i$1);
  }
  function State$1(input, options) {
    this.input = input;
    this.filename = options["filename"] || null;
    this.schema = options["schema"] || _default;
    this.onWarning = options["onWarning"] || null;
    this.legacy = options["legacy"] || false;
    this.json = options["json"] || false;
    this.listener = options["listener"] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    this.firstTabInLine = -1;
    this.documents = [];
  }
  function generateError(state2, message) {
    var mark = {
      name: state2.filename,
      buffer: state2.input.slice(0, -1),
      // omit trailing \0
      position: state2.position,
      line: state2.line,
      column: state2.position - state2.lineStart
    };
    mark.snippet = snippet(mark);
    return new exception(message, mark);
  }
  function throwError$1(state2, message) {
    throw generateError(state2, message);
  }
  function throwWarning(state2, message) {
    if (state2.onWarning) {
      state2.onWarning.call(null, generateError(state2, message));
    }
  }
  var directiveHandlers = {
    YAML: function handleYamlDirective(state2, name, args) {
      var match2, major, minor;
      if (state2.version !== null) {
        throwError$1(state2, "duplication of %YAML directive");
      }
      if (args.length !== 1) {
        throwError$1(state2, "YAML directive accepts exactly one argument");
      }
      match2 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
      if (match2 === null) {
        throwError$1(state2, "ill-formed argument of the YAML directive");
      }
      major = parseInt(match2[1], 10);
      minor = parseInt(match2[2], 10);
      if (major !== 1) {
        throwError$1(state2, "unacceptable YAML version of the document");
      }
      state2.version = args[0];
      state2.checkLineBreaks = minor < 2;
      if (minor !== 1 && minor !== 2) {
        throwWarning(state2, "unsupported YAML version of the document");
      }
    },
    TAG: function handleTagDirective(state2, name, args) {
      var handle, prefix;
      if (args.length !== 2) {
        throwError$1(state2, "TAG directive accepts exactly two arguments");
      }
      handle = args[0];
      prefix = args[1];
      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError$1(state2, "ill-formed tag handle (first argument) of the TAG directive");
      }
      if (_hasOwnProperty$1.call(state2.tagMap, handle)) {
        throwError$1(state2, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }
      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError$1(state2, "ill-formed tag prefix (second argument) of the TAG directive");
      }
      try {
        prefix = decodeURIComponent(prefix);
      } catch (err) {
        throwError$1(state2, "tag prefix is malformed: " + prefix);
      }
      state2.tagMap[handle] = prefix;
    }
  };
  function captureSegment(state2, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
      _result = state2.input.slice(start, end);
      if (checkJson) {
        for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
            throwError$1(state2, "expected valid JSON character");
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError$1(state2, "the stream contains non-printable characters");
      }
      state2.result += _result;
    }
  }
  function mergeMappings(state2, destination, source, overridableKeys) {
    var sourceKeys, key, index2, quantity;
    if (!common$1.isObject(source)) {
      throwError$1(state2, "cannot merge mappings; the provided source object is unacceptable");
    }
    sourceKeys = Object.keys(source);
    for (index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1) {
      key = sourceKeys[index2];
      if (!_hasOwnProperty$1.call(destination, key)) {
        destination[key] = source[key];
        overridableKeys[key] = true;
      }
    }
  }
  function storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
    var index2, quantity;
    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);
      for (index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1) {
        if (Array.isArray(keyNode[index2])) {
          throwError$1(state2, "nested arrays are not supported inside keys");
        }
        if (typeof keyNode === "object" && _class(keyNode[index2]) === "[object Object]") {
          keyNode[index2] = "[object Object]";
        }
      }
    }
    if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
      keyNode = "[object Object]";
    }
    keyNode = String(keyNode);
    if (_result === null) {
      _result = {};
    }
    if (keyTag === "tag:yaml.org,2002:merge") {
      if (Array.isArray(valueNode)) {
        for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1) {
          mergeMappings(state2, _result, valueNode[index2], overridableKeys);
        }
      } else {
        mergeMappings(state2, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state2.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
        state2.line = startLine || state2.line;
        state2.lineStart = startLineStart || state2.lineStart;
        state2.position = startPos || state2.position;
        throwError$1(state2, "duplicated mapping key");
      }
      if (keyNode === "__proto__") {
        Object.defineProperty(_result, keyNode, {
          configurable: true,
          enumerable: true,
          writable: true,
          value: valueNode
        });
      } else {
        _result[keyNode] = valueNode;
      }
      delete overridableKeys[keyNode];
    }
    return _result;
  }
  function readLineBreak(state2) {
    var ch;
    ch = state2.input.charCodeAt(state2.position);
    if (ch === 10) {
      state2.position++;
    } else if (ch === 13) {
      state2.position++;
      if (state2.input.charCodeAt(state2.position) === 10) {
        state2.position++;
      }
    } else {
      throwError$1(state2, "a line break is expected");
    }
    state2.line += 1;
    state2.lineStart = state2.position;
    state2.firstTabInLine = -1;
  }
  function skipSeparationSpace(state2, allowComments, checkIndent) {
    var lineBreaks = 0, ch = state2.input.charCodeAt(state2.position);
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        if (ch === 9 && state2.firstTabInLine === -1) {
          state2.firstTabInLine = state2.position;
        }
        ch = state2.input.charCodeAt(++state2.position);
      }
      if (allowComments && ch === 35) {
        do {
          ch = state2.input.charCodeAt(++state2.position);
        } while (ch !== 10 && ch !== 13 && ch !== 0);
      }
      if (is_EOL(ch)) {
        readLineBreak(state2);
        ch = state2.input.charCodeAt(state2.position);
        lineBreaks++;
        state2.lineIndent = 0;
        while (ch === 32) {
          state2.lineIndent++;
          ch = state2.input.charCodeAt(++state2.position);
        }
      } else {
        break;
      }
    }
    if (checkIndent !== -1 && lineBreaks !== 0 && state2.lineIndent < checkIndent) {
      throwWarning(state2, "deficient indentation");
    }
    return lineBreaks;
  }
  function testDocumentSeparator(state2) {
    var _position = state2.position, ch;
    ch = state2.input.charCodeAt(_position);
    if ((ch === 45 || ch === 46) && ch === state2.input.charCodeAt(_position + 1) && ch === state2.input.charCodeAt(_position + 2)) {
      _position += 3;
      ch = state2.input.charCodeAt(_position);
      if (ch === 0 || is_WS_OR_EOL(ch)) {
        return true;
      }
    }
    return false;
  }
  function writeFoldedLines(state2, count2) {
    if (count2 === 1) {
      state2.result += " ";
    } else if (count2 > 1) {
      state2.result += common$1.repeat("\n", count2 - 1);
    }
  }
  function readPlainScalar(state2, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state2.kind, _result = state2.result, ch;
    ch = state2.input.charCodeAt(state2.position);
    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
      return false;
    }
    if (ch === 63 || ch === 45) {
      following = state2.input.charCodeAt(state2.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }
    state2.kind = "scalar";
    state2.result = "";
    captureStart = captureEnd = state2.position;
    hasPendingContent = false;
    while (ch !== 0) {
      if (ch === 58) {
        following = state2.input.charCodeAt(state2.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }
      } else if (ch === 35) {
        preceding = state2.input.charCodeAt(state2.position - 1);
        if (is_WS_OR_EOL(preceding)) {
          break;
        }
      } else if (state2.position === state2.lineStart && testDocumentSeparator(state2) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
        break;
      } else if (is_EOL(ch)) {
        _line = state2.line;
        _lineStart = state2.lineStart;
        _lineIndent = state2.lineIndent;
        skipSeparationSpace(state2, false, -1);
        if (state2.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch = state2.input.charCodeAt(state2.position);
          continue;
        } else {
          state2.position = captureEnd;
          state2.line = _line;
          state2.lineStart = _lineStart;
          state2.lineIndent = _lineIndent;
          break;
        }
      }
      if (hasPendingContent) {
        captureSegment(state2, captureStart, captureEnd, false);
        writeFoldedLines(state2, state2.line - _line);
        captureStart = captureEnd = state2.position;
        hasPendingContent = false;
      }
      if (!is_WHITE_SPACE(ch)) {
        captureEnd = state2.position + 1;
      }
      ch = state2.input.charCodeAt(++state2.position);
    }
    captureSegment(state2, captureStart, captureEnd, false);
    if (state2.result) {
      return true;
    }
    state2.kind = _kind;
    state2.result = _result;
    return false;
  }
  function readSingleQuotedScalar(state2, nodeIndent) {
    var ch, captureStart, captureEnd;
    ch = state2.input.charCodeAt(state2.position);
    if (ch !== 39) {
      return false;
    }
    state2.kind = "scalar";
    state2.result = "";
    state2.position++;
    captureStart = captureEnd = state2.position;
    while ((ch = state2.input.charCodeAt(state2.position)) !== 0) {
      if (ch === 39) {
        captureSegment(state2, captureStart, state2.position, true);
        ch = state2.input.charCodeAt(++state2.position);
        if (ch === 39) {
          captureStart = state2.position;
          state2.position++;
          captureEnd = state2.position;
        } else {
          return true;
        }
      } else if (is_EOL(ch)) {
        captureSegment(state2, captureStart, captureEnd, true);
        writeFoldedLines(state2, skipSeparationSpace(state2, false, nodeIndent));
        captureStart = captureEnd = state2.position;
      } else if (state2.position === state2.lineStart && testDocumentSeparator(state2)) {
        throwError$1(state2, "unexpected end of the document within a single quoted scalar");
      } else {
        state2.position++;
        captureEnd = state2.position;
      }
    }
    throwError$1(state2, "unexpected end of the stream within a single quoted scalar");
  }
  function readDoubleQuotedScalar(state2, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
    ch = state2.input.charCodeAt(state2.position);
    if (ch !== 34) {
      return false;
    }
    state2.kind = "scalar";
    state2.result = "";
    state2.position++;
    captureStart = captureEnd = state2.position;
    while ((ch = state2.input.charCodeAt(state2.position)) !== 0) {
      if (ch === 34) {
        captureSegment(state2, captureStart, state2.position, true);
        state2.position++;
        return true;
      } else if (ch === 92) {
        captureSegment(state2, captureStart, state2.position, true);
        ch = state2.input.charCodeAt(++state2.position);
        if (is_EOL(ch)) {
          skipSeparationSpace(state2, false, nodeIndent);
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state2.result += simpleEscapeMap[ch];
          state2.position++;
        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;
          for (; hexLength > 0; hexLength--) {
            ch = state2.input.charCodeAt(++state2.position);
            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;
            } else {
              throwError$1(state2, "expected hexadecimal character");
            }
          }
          state2.result += charFromCodepoint(hexResult);
          state2.position++;
        } else {
          throwError$1(state2, "unknown escape sequence");
        }
        captureStart = captureEnd = state2.position;
      } else if (is_EOL(ch)) {
        captureSegment(state2, captureStart, captureEnd, true);
        writeFoldedLines(state2, skipSeparationSpace(state2, false, nodeIndent));
        captureStart = captureEnd = state2.position;
      } else if (state2.position === state2.lineStart && testDocumentSeparator(state2)) {
        throwError$1(state2, "unexpected end of the document within a double quoted scalar");
      } else {
        state2.position++;
        captureEnd = state2.position;
      }
    }
    throwError$1(state2, "unexpected end of the stream within a double quoted scalar");
  }
  function readFlowCollection(state2, nodeIndent) {
    var readNext = true, _line, _lineStart, _pos, _tag = state2.tag, _result, _anchor = state2.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
    ch = state2.input.charCodeAt(state2.position);
    if (ch === 91) {
      terminator = 93;
      isMapping = false;
      _result = [];
    } else if (ch === 123) {
      terminator = 125;
      isMapping = true;
      _result = {};
    } else {
      return false;
    }
    if (state2.anchor !== null) {
      state2.anchorMap[state2.anchor] = _result;
    }
    ch = state2.input.charCodeAt(++state2.position);
    while (ch !== 0) {
      skipSeparationSpace(state2, true, nodeIndent);
      ch = state2.input.charCodeAt(state2.position);
      if (ch === terminator) {
        state2.position++;
        state2.tag = _tag;
        state2.anchor = _anchor;
        state2.kind = isMapping ? "mapping" : "sequence";
        state2.result = _result;
        return true;
      } else if (!readNext) {
        throwError$1(state2, "missed comma between flow collection entries");
      } else if (ch === 44) {
        throwError$1(state2, "expected the node content, but found ','");
      }
      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;
      if (ch === 63) {
        following = state2.input.charCodeAt(state2.position + 1);
        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state2.position++;
          skipSeparationSpace(state2, true, nodeIndent);
        }
      }
      _line = state2.line;
      _lineStart = state2.lineStart;
      _pos = state2.position;
      composeNode(state2, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state2.tag;
      keyNode = state2.result;
      skipSeparationSpace(state2, true, nodeIndent);
      ch = state2.input.charCodeAt(state2.position);
      if ((isExplicitPair || state2.line === _line) && ch === 58) {
        isPair = true;
        ch = state2.input.charCodeAt(++state2.position);
        skipSeparationSpace(state2, true, nodeIndent);
        composeNode(state2, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state2.result;
      }
      if (isMapping) {
        storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
      } else if (isPair) {
        _result.push(storeMappingPair(state2, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
      } else {
        _result.push(keyNode);
      }
      skipSeparationSpace(state2, true, nodeIndent);
      ch = state2.input.charCodeAt(state2.position);
      if (ch === 44) {
        readNext = true;
        ch = state2.input.charCodeAt(++state2.position);
      } else {
        readNext = false;
      }
    }
    throwError$1(state2, "unexpected end of the stream within a flow collection");
  }
  function readBlockScalar(state2, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
    ch = state2.input.charCodeAt(state2.position);
    if (ch === 124) {
      folding = false;
    } else if (ch === 62) {
      folding = true;
    } else {
      return false;
    }
    state2.kind = "scalar";
    state2.result = "";
    while (ch !== 0) {
      ch = state2.input.charCodeAt(++state2.position);
      if (ch === 43 || ch === 45) {
        if (CHOMPING_CLIP === chomping) {
          chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError$1(state2, "repeat of a chomping mode identifier");
        }
      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
        if (tmp === 0) {
          throwError$1(state2, "bad explicit indentation width of a block scalar; it cannot be less than one");
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError$1(state2, "repeat of an indentation width identifier");
        }
      } else {
        break;
      }
    }
    if (is_WHITE_SPACE(ch)) {
      do {
        ch = state2.input.charCodeAt(++state2.position);
      } while (is_WHITE_SPACE(ch));
      if (ch === 35) {
        do {
          ch = state2.input.charCodeAt(++state2.position);
        } while (!is_EOL(ch) && ch !== 0);
      }
    }
    while (ch !== 0) {
      readLineBreak(state2);
      state2.lineIndent = 0;
      ch = state2.input.charCodeAt(state2.position);
      while ((!detectedIndent || state2.lineIndent < textIndent) && ch === 32) {
        state2.lineIndent++;
        ch = state2.input.charCodeAt(++state2.position);
      }
      if (!detectedIndent && state2.lineIndent > textIndent) {
        textIndent = state2.lineIndent;
      }
      if (is_EOL(ch)) {
        emptyLines++;
        continue;
      }
      if (state2.lineIndent < textIndent) {
        if (chomping === CHOMPING_KEEP) {
          state2.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) {
            state2.result += "\n";
          }
        }
        break;
      }
      if (folding) {
        if (is_WHITE_SPACE(ch)) {
          atMoreIndented = true;
          state2.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state2.result += common$1.repeat("\n", emptyLines + 1);
        } else if (emptyLines === 0) {
          if (didReadContent) {
            state2.result += " ";
          }
        } else {
          state2.result += common$1.repeat("\n", emptyLines);
        }
      } else {
        state2.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      }
      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state2.position;
      while (!is_EOL(ch) && ch !== 0) {
        ch = state2.input.charCodeAt(++state2.position);
      }
      captureSegment(state2, captureStart, state2.position, false);
    }
    return true;
  }
  function readBlockSequence(state2, nodeIndent) {
    var _line, _tag = state2.tag, _anchor = state2.anchor, _result = [], following, detected = false, ch;
    if (state2.firstTabInLine !== -1)
      return false;
    if (state2.anchor !== null) {
      state2.anchorMap[state2.anchor] = _result;
    }
    ch = state2.input.charCodeAt(state2.position);
    while (ch !== 0) {
      if (state2.firstTabInLine !== -1) {
        state2.position = state2.firstTabInLine;
        throwError$1(state2, "tab characters must not be used in indentation");
      }
      if (ch !== 45) {
        break;
      }
      following = state2.input.charCodeAt(state2.position + 1);
      if (!is_WS_OR_EOL(following)) {
        break;
      }
      detected = true;
      state2.position++;
      if (skipSeparationSpace(state2, true, -1)) {
        if (state2.lineIndent <= nodeIndent) {
          _result.push(null);
          ch = state2.input.charCodeAt(state2.position);
          continue;
        }
      }
      _line = state2.line;
      composeNode(state2, nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(state2.result);
      skipSeparationSpace(state2, true, -1);
      ch = state2.input.charCodeAt(state2.position);
      if ((state2.line === _line || state2.lineIndent > nodeIndent) && ch !== 0) {
        throwError$1(state2, "bad indentation of a sequence entry");
      } else if (state2.lineIndent < nodeIndent) {
        break;
      }
    }
    if (detected) {
      state2.tag = _tag;
      state2.anchor = _anchor;
      state2.kind = "sequence";
      state2.result = _result;
      return true;
    }
    return false;
  }
  function readBlockMapping(state2, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state2.tag, _anchor = state2.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
    if (state2.firstTabInLine !== -1)
      return false;
    if (state2.anchor !== null) {
      state2.anchorMap[state2.anchor] = _result;
    }
    ch = state2.input.charCodeAt(state2.position);
    while (ch !== 0) {
      if (!atExplicitKey && state2.firstTabInLine !== -1) {
        state2.position = state2.firstTabInLine;
        throwError$1(state2, "tab characters must not be used in indentation");
      }
      following = state2.input.charCodeAt(state2.position + 1);
      _line = state2.line;
      if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
        if (ch === 63) {
          if (atExplicitKey) {
            storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = true;
          allowCompact = true;
        } else if (atExplicitKey) {
          atExplicitKey = false;
          allowCompact = true;
        } else {
          throwError$1(state2, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
        }
        state2.position += 1;
        ch = following;
      } else {
        _keyLine = state2.line;
        _keyLineStart = state2.lineStart;
        _keyPos = state2.position;
        if (!composeNode(state2, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          break;
        }
        if (state2.line === _line) {
          ch = state2.input.charCodeAt(state2.position);
          while (is_WHITE_SPACE(ch)) {
            ch = state2.input.charCodeAt(++state2.position);
          }
          if (ch === 58) {
            ch = state2.input.charCodeAt(++state2.position);
            if (!is_WS_OR_EOL(ch)) {
              throwError$1(state2, "a whitespace character is expected after the key-value separator within a block mapping");
            }
            if (atExplicitKey) {
              storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state2.tag;
            keyNode = state2.result;
          } else if (detected) {
            throwError$1(state2, "can not read an implicit mapping pair; a colon is missed");
          } else {
            state2.tag = _tag;
            state2.anchor = _anchor;
            return true;
          }
        } else if (detected) {
          throwError$1(state2, "can not read a block mapping entry; a multiline key may not be an implicit key");
        } else {
          state2.tag = _tag;
          state2.anchor = _anchor;
          return true;
        }
      }
      if (state2.line === _line || state2.lineIndent > nodeIndent) {
        if (atExplicitKey) {
          _keyLine = state2.line;
          _keyLineStart = state2.lineStart;
          _keyPos = state2.position;
        }
        if (composeNode(state2, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state2.result;
          } else {
            valueNode = state2.result;
          }
        }
        if (!atExplicitKey) {
          storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        skipSeparationSpace(state2, true, -1);
        ch = state2.input.charCodeAt(state2.position);
      }
      if ((state2.line === _line || state2.lineIndent > nodeIndent) && ch !== 0) {
        throwError$1(state2, "bad indentation of a mapping entry");
      } else if (state2.lineIndent < nodeIndent) {
        break;
      }
    }
    if (atExplicitKey) {
      storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
    }
    if (detected) {
      state2.tag = _tag;
      state2.anchor = _anchor;
      state2.kind = "mapping";
      state2.result = _result;
    }
    return detected;
  }
  function readTagProperty(state2) {
    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
    ch = state2.input.charCodeAt(state2.position);
    if (ch !== 33)
      return false;
    if (state2.tag !== null) {
      throwError$1(state2, "duplication of a tag property");
    }
    ch = state2.input.charCodeAt(++state2.position);
    if (ch === 60) {
      isVerbatim = true;
      ch = state2.input.charCodeAt(++state2.position);
    } else if (ch === 33) {
      isNamed = true;
      tagHandle = "!!";
      ch = state2.input.charCodeAt(++state2.position);
    } else {
      tagHandle = "!";
    }
    _position = state2.position;
    if (isVerbatim) {
      do {
        ch = state2.input.charCodeAt(++state2.position);
      } while (ch !== 0 && ch !== 62);
      if (state2.position < state2.length) {
        tagName = state2.input.slice(_position, state2.position);
        ch = state2.input.charCodeAt(++state2.position);
      } else {
        throwError$1(state2, "unexpected end of the stream within a verbatim tag");
      }
    } else {
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        if (ch === 33) {
          if (!isNamed) {
            tagHandle = state2.input.slice(_position - 1, state2.position + 1);
            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError$1(state2, "named tag handle cannot contain such characters");
            }
            isNamed = true;
            _position = state2.position + 1;
          } else {
            throwError$1(state2, "tag suffix cannot contain exclamation marks");
          }
        }
        ch = state2.input.charCodeAt(++state2.position);
      }
      tagName = state2.input.slice(_position, state2.position);
      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError$1(state2, "tag suffix cannot contain flow indicator characters");
      }
    }
    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError$1(state2, "tag name cannot contain such characters: " + tagName);
    }
    try {
      tagName = decodeURIComponent(tagName);
    } catch (err) {
      throwError$1(state2, "tag name is malformed: " + tagName);
    }
    if (isVerbatim) {
      state2.tag = tagName;
    } else if (_hasOwnProperty$1.call(state2.tagMap, tagHandle)) {
      state2.tag = state2.tagMap[tagHandle] + tagName;
    } else if (tagHandle === "!") {
      state2.tag = "!" + tagName;
    } else if (tagHandle === "!!") {
      state2.tag = "tag:yaml.org,2002:" + tagName;
    } else {
      throwError$1(state2, 'undeclared tag handle "' + tagHandle + '"');
    }
    return true;
  }
  function readAnchorProperty(state2) {
    var _position, ch;
    ch = state2.input.charCodeAt(state2.position);
    if (ch !== 38)
      return false;
    if (state2.anchor !== null) {
      throwError$1(state2, "duplication of an anchor property");
    }
    ch = state2.input.charCodeAt(++state2.position);
    _position = state2.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state2.input.charCodeAt(++state2.position);
    }
    if (state2.position === _position) {
      throwError$1(state2, "name of an anchor node must contain at least one character");
    }
    state2.anchor = state2.input.slice(_position, state2.position);
    return true;
  }
  function readAlias(state2) {
    var _position, alias, ch;
    ch = state2.input.charCodeAt(state2.position);
    if (ch !== 42)
      return false;
    ch = state2.input.charCodeAt(++state2.position);
    _position = state2.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state2.input.charCodeAt(++state2.position);
    }
    if (state2.position === _position) {
      throwError$1(state2, "name of an alias node must contain at least one character");
    }
    alias = state2.input.slice(_position, state2.position);
    if (!_hasOwnProperty$1.call(state2.anchorMap, alias)) {
      throwError$1(state2, 'unidentified alias "' + alias + '"');
    }
    state2.result = state2.anchorMap[alias];
    skipSeparationSpace(state2, true, -1);
    return true;
  }
  function composeNode(state2, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
    if (state2.listener !== null) {
      state2.listener("open", state2);
    }
    state2.tag = null;
    state2.anchor = null;
    state2.kind = null;
    state2.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
      if (skipSeparationSpace(state2, true, -1)) {
        atNewLine = true;
        if (state2.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state2.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state2.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }
    if (indentStatus === 1) {
      while (readTagProperty(state2) || readAnchorProperty(state2)) {
        if (skipSeparationSpace(state2, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;
          if (state2.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state2.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state2.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }
    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }
    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }
      blockIndent = state2.position - state2.lineStart;
      if (indentStatus === 1) {
        if (allowBlockCollections && (readBlockSequence(state2, blockIndent) || readBlockMapping(state2, blockIndent, flowIndent)) || readFlowCollection(state2, flowIndent)) {
          hasContent = true;
        } else {
          if (allowBlockScalars && readBlockScalar(state2, flowIndent) || readSingleQuotedScalar(state2, flowIndent) || readDoubleQuotedScalar(state2, flowIndent)) {
            hasContent = true;
          } else if (readAlias(state2)) {
            hasContent = true;
            if (state2.tag !== null || state2.anchor !== null) {
              throwError$1(state2, "alias node should not have any properties");
            }
          } else if (readPlainScalar(state2, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;
            if (state2.tag === null) {
              state2.tag = "?";
            }
          }
          if (state2.anchor !== null) {
            state2.anchorMap[state2.anchor] = state2.result;
          }
        }
      } else if (indentStatus === 0) {
        hasContent = allowBlockCollections && readBlockSequence(state2, blockIndent);
      }
    }
    if (state2.tag === null) {
      if (state2.anchor !== null) {
        state2.anchorMap[state2.anchor] = state2.result;
      }
    } else if (state2.tag === "?") {
      if (state2.result !== null && state2.kind !== "scalar") {
        throwError$1(state2, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state2.kind + '"');
      }
      for (typeIndex = 0, typeQuantity = state2.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type2 = state2.implicitTypes[typeIndex];
        if (type2.resolve(state2.result)) {
          state2.result = type2.construct(state2.result);
          state2.tag = type2.tag;
          if (state2.anchor !== null) {
            state2.anchorMap[state2.anchor] = state2.result;
          }
          break;
        }
      }
    } else if (state2.tag !== "!") {
      if (_hasOwnProperty$1.call(state2.typeMap[state2.kind || "fallback"], state2.tag)) {
        type2 = state2.typeMap[state2.kind || "fallback"][state2.tag];
      } else {
        type2 = null;
        typeList = state2.typeMap.multi[state2.kind || "fallback"];
        for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
          if (state2.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
            type2 = typeList[typeIndex];
            break;
          }
        }
      }
      if (!type2) {
        throwError$1(state2, "unknown tag !<" + state2.tag + ">");
      }
      if (state2.result !== null && type2.kind !== state2.kind) {
        throwError$1(state2, "unacceptable node kind for !<" + state2.tag + '> tag; it should be "' + type2.kind + '", not "' + state2.kind + '"');
      }
      if (!type2.resolve(state2.result, state2.tag)) {
        throwError$1(state2, "cannot resolve a node with !<" + state2.tag + "> explicit tag");
      } else {
        state2.result = type2.construct(state2.result, state2.tag);
        if (state2.anchor !== null) {
          state2.anchorMap[state2.anchor] = state2.result;
        }
      }
    }
    if (state2.listener !== null) {
      state2.listener("close", state2);
    }
    return state2.tag !== null || state2.anchor !== null || hasContent;
  }
  function readDocument(state2) {
    var documentStart = state2.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
    state2.version = null;
    state2.checkLineBreaks = state2.legacy;
    state2.tagMap = /* @__PURE__ */ Object.create(null);
    state2.anchorMap = /* @__PURE__ */ Object.create(null);
    while ((ch = state2.input.charCodeAt(state2.position)) !== 0) {
      skipSeparationSpace(state2, true, -1);
      ch = state2.input.charCodeAt(state2.position);
      if (state2.lineIndent > 0 || ch !== 37) {
        break;
      }
      hasDirectives = true;
      ch = state2.input.charCodeAt(++state2.position);
      _position = state2.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state2.input.charCodeAt(++state2.position);
      }
      directiveName = state2.input.slice(_position, state2.position);
      directiveArgs = [];
      if (directiveName.length < 1) {
        throwError$1(state2, "directive name must not be less than one character in length");
      }
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state2.input.charCodeAt(++state2.position);
        }
        if (ch === 35) {
          do {
            ch = state2.input.charCodeAt(++state2.position);
          } while (ch !== 0 && !is_EOL(ch));
          break;
        }
        if (is_EOL(ch))
          break;
        _position = state2.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state2.input.charCodeAt(++state2.position);
        }
        directiveArgs.push(state2.input.slice(_position, state2.position));
      }
      if (ch !== 0)
        readLineBreak(state2);
      if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state2, directiveName, directiveArgs);
      } else {
        throwWarning(state2, 'unknown document directive "' + directiveName + '"');
      }
    }
    skipSeparationSpace(state2, true, -1);
    if (state2.lineIndent === 0 && state2.input.charCodeAt(state2.position) === 45 && state2.input.charCodeAt(state2.position + 1) === 45 && state2.input.charCodeAt(state2.position + 2) === 45) {
      state2.position += 3;
      skipSeparationSpace(state2, true, -1);
    } else if (hasDirectives) {
      throwError$1(state2, "directives end mark is expected");
    }
    composeNode(state2, state2.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state2, true, -1);
    if (state2.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state2.input.slice(documentStart, state2.position))) {
      throwWarning(state2, "non-ASCII line breaks are interpreted as content");
    }
    state2.documents.push(state2.result);
    if (state2.position === state2.lineStart && testDocumentSeparator(state2)) {
      if (state2.input.charCodeAt(state2.position) === 46) {
        state2.position += 3;
        skipSeparationSpace(state2, true, -1);
      }
      return;
    }
    if (state2.position < state2.length - 1) {
      throwError$1(state2, "end of the stream or a document separator is expected");
    } else {
      return;
    }
  }
  function loadDocuments(input, options) {
    input = String(input);
    options = options || {};
    if (input.length !== 0) {
      if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
        input += "\n";
      }
      if (input.charCodeAt(0) === 65279) {
        input = input.slice(1);
      }
    }
    var state2 = new State$1(input, options);
    var nullpos = input.indexOf("\0");
    if (nullpos !== -1) {
      state2.position = nullpos;
      throwError$1(state2, "null byte is not allowed in input");
    }
    state2.input += "\0";
    while (state2.input.charCodeAt(state2.position) === 32) {
      state2.lineIndent += 1;
      state2.position += 1;
    }
    while (state2.position < state2.length - 1) {
      readDocument(state2);
    }
    return state2.documents;
  }
  function loadAll$1(input, iterator2, options) {
    if (iterator2 !== null && typeof iterator2 === "object" && typeof options === "undefined") {
      options = iterator2;
      iterator2 = null;
    }
    var documents = loadDocuments(input, options);
    if (typeof iterator2 !== "function") {
      return documents;
    }
    for (var index2 = 0, length2 = documents.length; index2 < length2; index2 += 1) {
      iterator2(documents[index2]);
    }
  }
  function load$1(input, options) {
    var documents = loadDocuments(input, options);
    if (documents.length === 0) {
      return void 0;
    } else if (documents.length === 1) {
      return documents[0];
    }
    throw new exception("expected a single document in the stream, but found more");
  }
  var loadAll_1 = loadAll$1;
  var load_1 = load$1;
  var loader = {
    loadAll: loadAll_1,
    load: load_1
  };
  var _toString$3 = Object.prototype.toString;
  var _hasOwnProperty$4 = Object.prototype.hasOwnProperty;
  var CHAR_BOM = 65279;
  var CHAR_TAB = 9;
  var CHAR_LINE_FEED = 10;
  var CHAR_CARRIAGE_RETURN = 13;
  var CHAR_SPACE = 32;
  var CHAR_EXCLAMATION = 33;
  var CHAR_DOUBLE_QUOTE = 34;
  var CHAR_SHARP = 35;
  var CHAR_PERCENT = 37;
  var CHAR_AMPERSAND = 38;
  var CHAR_SINGLE_QUOTE = 39;
  var CHAR_ASTERISK = 42;
  var CHAR_COMMA = 44;
  var CHAR_MINUS = 45;
  var CHAR_COLON = 58;
  var CHAR_EQUALS = 61;
  var CHAR_GREATER_THAN = 62;
  var CHAR_QUESTION = 63;
  var CHAR_COMMERCIAL_AT = 64;
  var CHAR_LEFT_SQUARE_BRACKET = 91;
  var CHAR_RIGHT_SQUARE_BRACKET = 93;
  var CHAR_GRAVE_ACCENT = 96;
  var CHAR_LEFT_CURLY_BRACKET = 123;
  var CHAR_VERTICAL_LINE = 124;
  var CHAR_RIGHT_CURLY_BRACKET = 125;
  var ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0] = "\\0";
  ESCAPE_SEQUENCES[7] = "\\a";
  ESCAPE_SEQUENCES[8] = "\\b";
  ESCAPE_SEQUENCES[9] = "\\t";
  ESCAPE_SEQUENCES[10] = "\\n";
  ESCAPE_SEQUENCES[11] = "\\v";
  ESCAPE_SEQUENCES[12] = "\\f";
  ESCAPE_SEQUENCES[13] = "\\r";
  ESCAPE_SEQUENCES[27] = "\\e";
  ESCAPE_SEQUENCES[34] = '\\"';
  ESCAPE_SEQUENCES[92] = "\\\\";
  ESCAPE_SEQUENCES[133] = "\\N";
  ESCAPE_SEQUENCES[160] = "\\_";
  ESCAPE_SEQUENCES[8232] = "\\L";
  ESCAPE_SEQUENCES[8233] = "\\P";
  var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ];
  var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
  function compileStyleMap(schema2, map2) {
    var result, keys2, index2, length2, tag, style, type2;
    if (map2 === null)
      return {};
    result = {};
    keys2 = Object.keys(map2);
    for (index2 = 0, length2 = keys2.length; index2 < length2; index2 += 1) {
      tag = keys2[index2];
      style = String(map2[tag]);
      if (tag.slice(0, 2) === "!!") {
        tag = "tag:yaml.org,2002:" + tag.slice(2);
      }
      type2 = schema2.compiledTypeMap["fallback"][tag];
      if (type2 && _hasOwnProperty$4.call(type2.styleAliases, style)) {
        style = type2.styleAliases[style];
      }
      result[tag] = style;
    }
    return result;
  }
  function encodeHex(character) {
    var string, handle, length2;
    string = character.toString(16).toUpperCase();
    if (character <= 255) {
      handle = "x";
      length2 = 2;
    } else if (character <= 65535) {
      handle = "u";
      length2 = 4;
    } else if (character <= 4294967295) {
      handle = "U";
      length2 = 8;
    } else {
      throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
    }
    return "\\" + handle + common$1.repeat("0", length2 - string.length) + string;
  }
  var QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;
  function State(options) {
    this.schema = options["schema"] || _default;
    this.indent = Math.max(1, options["indent"] || 2);
    this.noArrayIndent = options["noArrayIndent"] || false;
    this.skipInvalid = options["skipInvalid"] || false;
    this.flowLevel = common$1.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
    this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
    this.sortKeys = options["sortKeys"] || false;
    this.lineWidth = options["lineWidth"] || 80;
    this.noRefs = options["noRefs"] || false;
    this.noCompatMode = options["noCompatMode"] || false;
    this.condenseFlow = options["condenseFlow"] || false;
    this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
    this.forceQuotes = options["forceQuotes"] || false;
    this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = "";
    this.duplicates = [];
    this.usedDuplicates = null;
  }
  function indentString(string, spaces) {
    var ind = common$1.repeat(" ", spaces), position2 = 0, next = -1, result = "", line, length2 = string.length;
    while (position2 < length2) {
      next = string.indexOf("\n", position2);
      if (next === -1) {
        line = string.slice(position2);
        position2 = length2;
      } else {
        line = string.slice(position2, next + 1);
        position2 = next + 1;
      }
      if (line.length && line !== "\n")
        result += ind;
      result += line;
    }
    return result;
  }
  function generateNextLine(state2, level) {
    return "\n" + common$1.repeat(" ", state2.indent * level);
  }
  function testImplicitResolving(state2, str2) {
    var index2, length2, type2;
    for (index2 = 0, length2 = state2.implicitTypes.length; index2 < length2; index2 += 1) {
      type2 = state2.implicitTypes[index2];
      if (type2.resolve(str2)) {
        return true;
      }
    }
    return false;
  }
  function isWhitespace(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
  }
  function isPrintable(c) {
    return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
  }
  function isNsCharOrWhitespace(c) {
    return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
  }
  function isPlainSafe(c, prev2, inblock) {
    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
    var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
    return (
      // ns-plain-safe
      (inblock ? (
        // c = flow-in
        cIsNsCharOrWhitespace
      ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev2 === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev2) && !isWhitespace(prev2) && c === CHAR_SHARP || prev2 === CHAR_COLON && cIsNsChar
    );
  }
  function isPlainSafeFirst(c) {
    return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
  }
  function isPlainSafeLast(c) {
    return !isWhitespace(c) && c !== CHAR_COLON;
  }
  function codePointAt(string, pos) {
    var first2 = string.charCodeAt(pos), second;
    if (first2 >= 55296 && first2 <= 56319 && pos + 1 < string.length) {
      second = string.charCodeAt(pos + 1);
      if (second >= 56320 && second <= 57343) {
        return (first2 - 55296) * 1024 + second - 56320 + 65536;
      }
    }
    return first2;
  }
  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }
  var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
    var i2;
    var char = 0;
    var prevChar = null;
    var hasLineBreak = false;
    var hasFoldableLine = false;
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1;
    var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
    if (singleLineOnly || forceQuotes) {
      for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
        char = codePointAt(string, i2);
        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
    } else {
      for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
        char = codePointAt(string, i2);
        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true;
          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
            i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
            previousLineBreak = i2;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
      hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
    }
    if (!hasLineBreak && !hasFoldableLine) {
      if (plain && !forceQuotes && !testAmbiguousType(string)) {
        return STYLE_PLAIN;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    if (indentPerLevel > 9 && needIndentIndicator(string)) {
      return STYLE_DOUBLE;
    }
    if (!forceQuotes) {
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  function writeScalar(state2, string, level, iskey, inblock) {
    state2.dump = function() {
      if (string.length === 0) {
        return state2.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
      }
      if (!state2.noCompatMode) {
        if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
          return state2.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
        }
      }
      var indent = state2.indent * Math.max(1, level);
      var lineWidth = state2.lineWidth === -1 ? -1 : Math.max(Math.min(state2.lineWidth, 40), state2.lineWidth - indent);
      var singleLineOnly = iskey || state2.flowLevel > -1 && level >= state2.flowLevel;
      function testAmbiguity(string2) {
        return testImplicitResolving(state2, string2);
      }
      switch (chooseScalarStyle(
        string,
        singleLineOnly,
        state2.indent,
        lineWidth,
        testAmbiguity,
        state2.quotingType,
        state2.forceQuotes && !iskey,
        inblock
      )) {
        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return "|" + blockHeader(string, state2.indent) + dropEndingNewline(indentString(string, indent));
        case STYLE_FOLDED:
          return ">" + blockHeader(string, state2.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string) + '"';
        default:
          throw new exception("impossible error: invalid scalar style");
      }
    }();
  }
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
    var clip = string[string.length - 1] === "\n";
    var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
    var chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + "\n";
  }
  function dropEndingNewline(string) {
    return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
  }
  function foldString(string, width) {
    var lineRe = /(\n+)([^\n]*)/g;
    var result = function() {
      var nextLF = string.indexOf("\n");
      nextLF = nextLF !== -1 ? nextLF : string.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string.slice(0, nextLF), width);
    }();
    var prevMoreIndented = string[0] === "\n" || string[0] === " ";
    var moreIndented;
    var match2;
    while (match2 = lineRe.exec(string)) {
      var prefix = match2[1], line = match2[2];
      moreIndented = line[0] === " ";
      result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }
    return result;
  }
  function foldLine(line, width) {
    if (line === "" || line[0] === " ")
      return line;
    var breakRe = / [^ ]/g;
    var match2;
    var start = 0, end, curr = 0, next = 0;
    var result = "";
    while (match2 = breakRe.exec(line)) {
      next = match2.index;
      if (next - start > width) {
        end = curr > start ? curr : next;
        result += "\n" + line.slice(start, end);
        start = end + 1;
      }
      curr = next;
    }
    result += "\n";
    if (line.length - start > width && curr > start) {
      result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
    } else {
      result += line.slice(start);
    }
    return result.slice(1);
  }
  function escapeString(string) {
    var result = "";
    var char = 0;
    var escapeSeq;
    for (var i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
      char = codePointAt(string, i2);
      escapeSeq = ESCAPE_SEQUENCES[char];
      if (!escapeSeq && isPrintable(char)) {
        result += string[i2];
        if (char >= 65536)
          result += string[i2 + 1];
      } else {
        result += escapeSeq || encodeHex(char);
      }
    }
    return result;
  }
  function writeFlowSequence(state2, level, object) {
    var _result = "", _tag = state2.tag, index2, length2, value2;
    for (index2 = 0, length2 = object.length; index2 < length2; index2 += 1) {
      value2 = object[index2];
      if (state2.replacer) {
        value2 = state2.replacer.call(object, String(index2), value2);
      }
      if (writeNode(state2, level, value2, false, false) || typeof value2 === "undefined" && writeNode(state2, level, null, false, false)) {
        if (_result !== "")
          _result += "," + (!state2.condenseFlow ? " " : "");
        _result += state2.dump;
      }
    }
    state2.tag = _tag;
    state2.dump = "[" + _result + "]";
  }
  function writeBlockSequence(state2, level, object, compact2) {
    var _result = "", _tag = state2.tag, index2, length2, value2;
    for (index2 = 0, length2 = object.length; index2 < length2; index2 += 1) {
      value2 = object[index2];
      if (state2.replacer) {
        value2 = state2.replacer.call(object, String(index2), value2);
      }
      if (writeNode(state2, level + 1, value2, true, true, false, true) || typeof value2 === "undefined" && writeNode(state2, level + 1, null, true, true, false, true)) {
        if (!compact2 || _result !== "") {
          _result += generateNextLine(state2, level);
        }
        if (state2.dump && CHAR_LINE_FEED === state2.dump.charCodeAt(0)) {
          _result += "-";
        } else {
          _result += "- ";
        }
        _result += state2.dump;
      }
    }
    state2.tag = _tag;
    state2.dump = _result || "[]";
  }
  function writeFlowMapping(state2, level, object) {
    var _result = "", _tag = state2.tag, objectKeyList = Object.keys(object), index2, length2, objectKey, objectValue, pairBuffer;
    for (index2 = 0, length2 = objectKeyList.length; index2 < length2; index2 += 1) {
      pairBuffer = "";
      if (_result !== "")
        pairBuffer += ", ";
      if (state2.condenseFlow)
        pairBuffer += '"';
      objectKey = objectKeyList[index2];
      objectValue = object[objectKey];
      if (state2.replacer) {
        objectValue = state2.replacer.call(object, objectKey, objectValue);
      }
      if (!writeNode(state2, level, objectKey, false, false)) {
        continue;
      }
      if (state2.dump.length > 1024)
        pairBuffer += "? ";
      pairBuffer += state2.dump + (state2.condenseFlow ? '"' : "") + ":" + (state2.condenseFlow ? "" : " ");
      if (!writeNode(state2, level, objectValue, false, false)) {
        continue;
      }
      pairBuffer += state2.dump;
      _result += pairBuffer;
    }
    state2.tag = _tag;
    state2.dump = "{" + _result + "}";
  }
  function writeBlockMapping(state2, level, object, compact2) {
    var _result = "", _tag = state2.tag, objectKeyList = Object.keys(object), index2, length2, objectKey, objectValue, explicitPair, pairBuffer;
    if (state2.sortKeys === true) {
      objectKeyList.sort();
    } else if (typeof state2.sortKeys === "function") {
      objectKeyList.sort(state2.sortKeys);
    } else if (state2.sortKeys) {
      throw new exception("sortKeys must be a boolean or a function");
    }
    for (index2 = 0, length2 = objectKeyList.length; index2 < length2; index2 += 1) {
      pairBuffer = "";
      if (!compact2 || _result !== "") {
        pairBuffer += generateNextLine(state2, level);
      }
      objectKey = objectKeyList[index2];
      objectValue = object[objectKey];
      if (state2.replacer) {
        objectValue = state2.replacer.call(object, objectKey, objectValue);
      }
      if (!writeNode(state2, level + 1, objectKey, true, true, true)) {
        continue;
      }
      explicitPair = state2.tag !== null && state2.tag !== "?" || state2.dump && state2.dump.length > 1024;
      if (explicitPair) {
        if (state2.dump && CHAR_LINE_FEED === state2.dump.charCodeAt(0)) {
          pairBuffer += "?";
        } else {
          pairBuffer += "? ";
        }
      }
      pairBuffer += state2.dump;
      if (explicitPair) {
        pairBuffer += generateNextLine(state2, level);
      }
      if (!writeNode(state2, level + 1, objectValue, true, explicitPair)) {
        continue;
      }
      if (state2.dump && CHAR_LINE_FEED === state2.dump.charCodeAt(0)) {
        pairBuffer += ":";
      } else {
        pairBuffer += ": ";
      }
      pairBuffer += state2.dump;
      _result += pairBuffer;
    }
    state2.tag = _tag;
    state2.dump = _result || "{}";
  }
  function detectType(state2, object, explicit) {
    var _result, typeList, index2, length2, type2, style;
    typeList = explicit ? state2.explicitTypes : state2.implicitTypes;
    for (index2 = 0, length2 = typeList.length; index2 < length2; index2 += 1) {
      type2 = typeList[index2];
      if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
        if (explicit) {
          if (type2.multi && type2.representName) {
            state2.tag = type2.representName(object);
          } else {
            state2.tag = type2.tag;
          }
        } else {
          state2.tag = "?";
        }
        if (type2.represent) {
          style = state2.styleMap[type2.tag] || type2.defaultStyle;
          if (_toString$3.call(type2.represent) === "[object Function]") {
            _result = type2.represent(object, style);
          } else if (_hasOwnProperty$4.call(type2.represent, style)) {
            _result = type2.represent[style](object, style);
          } else {
            throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
          }
          state2.dump = _result;
        }
        return true;
      }
    }
    return false;
  }
  function writeNode(state2, level, object, block, compact2, iskey, isblockseq) {
    state2.tag = null;
    state2.dump = object;
    if (!detectType(state2, object, false)) {
      detectType(state2, object, true);
    }
    var type2 = _toString$3.call(state2.dump);
    var inblock = block;
    var tagStr;
    if (block) {
      block = state2.flowLevel < 0 || state2.flowLevel > level;
    }
    var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray) {
      duplicateIndex = state2.duplicates.indexOf(object);
      duplicate = duplicateIndex !== -1;
    }
    if (state2.tag !== null && state2.tag !== "?" || duplicate || state2.indent !== 2 && level > 0) {
      compact2 = false;
    }
    if (duplicate && state2.usedDuplicates[duplicateIndex]) {
      state2.dump = "*ref_" + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state2.usedDuplicates[duplicateIndex]) {
        state2.usedDuplicates[duplicateIndex] = true;
      }
      if (type2 === "[object Object]") {
        if (block && Object.keys(state2.dump).length !== 0) {
          writeBlockMapping(state2, level, state2.dump, compact2);
          if (duplicate) {
            state2.dump = "&ref_" + duplicateIndex + state2.dump;
          }
        } else {
          writeFlowMapping(state2, level, state2.dump);
          if (duplicate) {
            state2.dump = "&ref_" + duplicateIndex + " " + state2.dump;
          }
        }
      } else if (type2 === "[object Array]") {
        if (block && state2.dump.length !== 0) {
          if (state2.noArrayIndent && !isblockseq && level > 0) {
            writeBlockSequence(state2, level - 1, state2.dump, compact2);
          } else {
            writeBlockSequence(state2, level, state2.dump, compact2);
          }
          if (duplicate) {
            state2.dump = "&ref_" + duplicateIndex + state2.dump;
          }
        } else {
          writeFlowSequence(state2, level, state2.dump);
          if (duplicate) {
            state2.dump = "&ref_" + duplicateIndex + " " + state2.dump;
          }
        }
      } else if (type2 === "[object String]") {
        if (state2.tag !== "?") {
          writeScalar(state2, state2.dump, level, iskey, inblock);
        }
      } else if (type2 === "[object Undefined]") {
        return false;
      } else {
        if (state2.skipInvalid)
          return false;
        throw new exception("unacceptable kind of an object to dump " + type2);
      }
      if (state2.tag !== null && state2.tag !== "?") {
        tagStr = encodeURI(
          state2.tag[0] === "!" ? state2.tag.slice(1) : state2.tag
        ).replace(/!/g, "%21");
        if (state2.tag[0] === "!") {
          tagStr = "!" + tagStr;
        } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
          tagStr = "!!" + tagStr.slice(18);
        } else {
          tagStr = "!<" + tagStr + ">";
        }
        state2.dump = tagStr + " " + state2.dump;
      }
    }
    return true;
  }
  function getDuplicateReferences(object, state2) {
    var objects = [], duplicatesIndexes = [], index2, length2;
    inspectNode(object, objects, duplicatesIndexes);
    for (index2 = 0, length2 = duplicatesIndexes.length; index2 < length2; index2 += 1) {
      state2.duplicates.push(objects[duplicatesIndexes[index2]]);
    }
    state2.usedDuplicates = new Array(length2);
  }
  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index2, length2;
    if (object !== null && typeof object === "object") {
      index2 = objects.indexOf(object);
      if (index2 !== -1) {
        if (duplicatesIndexes.indexOf(index2) === -1) {
          duplicatesIndexes.push(index2);
        }
      } else {
        objects.push(object);
        if (Array.isArray(object)) {
          for (index2 = 0, length2 = object.length; index2 < length2; index2 += 1) {
            inspectNode(object[index2], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object);
          for (index2 = 0, length2 = objectKeyList.length; index2 < length2; index2 += 1) {
            inspectNode(object[objectKeyList[index2]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }
  function dump$1(input, options) {
    options = options || {};
    var state2 = new State(options);
    if (!state2.noRefs)
      getDuplicateReferences(input, state2);
    var value2 = input;
    if (state2.replacer) {
      value2 = state2.replacer.call({ "": value2 }, "", value2);
    }
    if (writeNode(state2, 0, value2, true, true))
      return state2.dump + "\n";
    return "";
  }
  var dump_1 = dump$1;
  var dumper = {
    dump: dump_1
  };
  function renamed(from2, to) {
    return function() {
      throw new Error("Function yaml." + from2 + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
    };
  }
  var Type = type$2;
  var Schema$2 = schema;
  var FAILSAFE_SCHEMA = failsafe;
  var JSON_SCHEMA = json;
  var CORE_SCHEMA = core$2;
  var DEFAULT_SCHEMA = _default;
  var load = loader.load;
  var loadAll = loader.loadAll;
  var dump = dumper.dump;
  var YAMLException = exception;
  var types = {
    binary: binary$1,
    float,
    map: map$5,
    null: _null,
    pairs: pairs$1,
    set: set$1,
    timestamp: timestamp$1,
    bool,
    int,
    merge: merge$5,
    omap,
    seq,
    str
  };
  var safeLoad = renamed("safeLoad", "load");
  var safeLoadAll = renamed("safeLoadAll", "loadAll");
  var safeDump = renamed("safeDump", "dump");
  var jsYaml = {
    Type,
    Schema: Schema$2,
    FAILSAFE_SCHEMA,
    JSON_SCHEMA,
    CORE_SCHEMA,
    DEFAULT_SCHEMA,
    load,
    loadAll,
    dump,
    YAMLException,
    types,
    safeLoad,
    safeLoadAll,
    safeDump
  };
  const {
    fetch: fetch$1,
    Response: Response$3,
    Headers: Headers$1,
    Request: Request$1,
    FormData: FormData$1,
    File: File$3,
    Blob: Blob$1
  } = globalThis;
  if (typeof globalThis.fetch === "undefined") {
    globalThis.fetch = fetch$1;
  }
  if (typeof globalThis.Headers === "undefined") {
    globalThis.Headers = Headers$1;
  }
  if (typeof globalThis.Request === "undefined") {
    globalThis.Request = Request$1;
  }
  if (typeof globalThis.Response === "undefined") {
    globalThis.Response = Response$3;
  }
  if (typeof globalThis.FormData === "undefined") {
    globalThis.FormData = FormData$1;
  }
  if (typeof globalThis.File === "undefined") {
    globalThis.File = File$3;
  }
  if (typeof globalThis.Blob === "undefined") {
    globalThis.Blob = Blob$1;
  }
  const isRfc3986Reserved = (char) => ":/?#[]@!$&'()*+,;=".indexOf(char) > -1;
  const isRrc3986Unreserved = (char) => /^[a-z0-9\-._~]+$/i.test(char);
  function encodeDisallowedCharacters(str2) {
    let {
      escape: escape2
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let parse2 = arguments.length > 2 ? arguments[2] : void 0;
    if (typeof str2 === "number") {
      str2 = str2.toString();
    }
    if (typeof str2 !== "string" || !str2.length) {
      return str2;
    }
    if (!escape2) {
      return str2;
    }
    if (parse2) {
      return JSON.parse(str2);
    }
    return [...str2].map((char) => {
      if (isRrc3986Unreserved(char)) {
        return char;
      }
      if (isRfc3986Reserved(char) && escape2 === "unsafe") {
        return char;
      }
      const encoder = new TextEncoder();
      const encoded = Array.from(encoder.encode(char)).map((byte) => `0${byte.toString(16).toUpperCase()}`.slice(-2)).map((encodedByte) => `%${encodedByte}`).join("");
      return encoded;
    }).join("");
  }
  function stylize(config2) {
    const {
      value: value2
    } = config2;
    if (Array.isArray(value2)) {
      return encodeArray(config2);
    }
    if (typeof value2 === "object") {
      return encodeObject(config2);
    }
    return encodePrimitive(config2);
  }
  function encodeArray(_ref) {
    let {
      key,
      value: value2,
      style,
      explode,
      escape: escape2
    } = _ref;
    const valueEncoder = (str2) => encodeDisallowedCharacters(str2, {
      escape: escape2
    });
    if (style === "simple") {
      return value2.map((val) => valueEncoder(val)).join(",");
    }
    if (style === "label") {
      return `.${value2.map((val) => valueEncoder(val)).join(".")}`;
    }
    if (style === "matrix") {
      return value2.map((val) => valueEncoder(val)).reduce((prev2, curr) => {
        if (!prev2 || explode) {
          return `${prev2 || ""};${key}=${curr}`;
        }
        return `${prev2},${curr}`;
      }, "");
    }
    if (style === "form") {
      const after = explode ? `&${key}=` : ",";
      return value2.map((val) => valueEncoder(val)).join(after);
    }
    if (style === "spaceDelimited") {
      const after = explode ? `${key}=` : "";
      return value2.map((val) => valueEncoder(val)).join(` ${after}`);
    }
    if (style === "pipeDelimited") {
      const after = explode ? `${key}=` : "";
      return value2.map((val) => valueEncoder(val)).join(`|${after}`);
    }
    return void 0;
  }
  function encodeObject(_ref2) {
    let {
      key,
      value: value2,
      style,
      explode,
      escape: escape2
    } = _ref2;
    const valueEncoder = (str2) => encodeDisallowedCharacters(str2, {
      escape: escape2
    });
    const valueKeys = Object.keys(value2);
    if (style === "simple") {
      return valueKeys.reduce((prev2, curr) => {
        const val = valueEncoder(value2[curr]);
        const middleChar = explode ? "=" : ",";
        const prefix = prev2 ? `${prev2},` : "";
        return `${prefix}${curr}${middleChar}${val}`;
      }, "");
    }
    if (style === "label") {
      return valueKeys.reduce((prev2, curr) => {
        const val = valueEncoder(value2[curr]);
        const middleChar = explode ? "=" : ".";
        const prefix = prev2 ? `${prev2}.` : ".";
        return `${prefix}${curr}${middleChar}${val}`;
      }, "");
    }
    if (style === "matrix" && explode) {
      return valueKeys.reduce((prev2, curr) => {
        const val = valueEncoder(value2[curr]);
        const prefix = prev2 ? `${prev2};` : ";";
        return `${prefix}${curr}=${val}`;
      }, "");
    }
    if (style === "matrix") {
      return valueKeys.reduce((prev2, curr) => {
        const val = valueEncoder(value2[curr]);
        const prefix = prev2 ? `${prev2},` : `;${key}=`;
        return `${prefix}${curr},${val}`;
      }, "");
    }
    if (style === "form") {
      return valueKeys.reduce((prev2, curr) => {
        const val = valueEncoder(value2[curr]);
        const prefix = prev2 ? `${prev2}${explode ? "&" : ","}` : "";
        const separator = explode ? "=" : ",";
        return `${prefix}${curr}${separator}${val}`;
      }, "");
    }
    return void 0;
  }
  function encodePrimitive(_ref3) {
    let {
      key,
      value: value2,
      style,
      escape: escape2
    } = _ref3;
    const valueEncoder = (str2) => encodeDisallowedCharacters(str2, {
      escape: escape2
    });
    if (style === "simple") {
      return valueEncoder(value2);
    }
    if (style === "label") {
      return `.${valueEncoder(value2)}`;
    }
    if (style === "matrix") {
      return `;${key}=${valueEncoder(value2)}`;
    }
    if (style === "form") {
      return valueEncoder(value2);
    }
    if (style === "deepObject") {
      return valueEncoder(value2);
    }
    return void 0;
  }
  const self$3 = {
    serializeRes,
    mergeInQueryOrForm
  };
  async function http(url2) {
    let request = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (typeof url2 === "object") {
      request = url2;
      url2 = request.url;
    }
    request.headers = request.headers || {};
    self$3.mergeInQueryOrForm(request);
    if (request.headers) {
      Object.keys(request.headers).forEach((headerName) => {
        const value2 = request.headers[headerName];
        if (typeof value2 === "string") {
          request.headers[headerName] = value2.replace(/\n+/g, " ");
        }
      });
    }
    if (request.requestInterceptor) {
      request = await request.requestInterceptor(request) || request;
    }
    const contentType = request.headers["content-type"] || request.headers["Content-Type"];
    if (/multipart\/form-data/i.test(contentType)) {
      delete request.headers["content-type"];
      delete request.headers["Content-Type"];
    }
    let res;
    try {
      res = await (request.userFetch || fetch)(request.url, request);
      res = await self$3.serializeRes(res, url2, request);
      if (request.responseInterceptor) {
        res = await request.responseInterceptor(res) || res;
      }
    } catch (resError) {
      if (!res) {
        throw resError;
      }
      const error = new Error(res.statusText || `response status is ${res.status}`);
      error.status = res.status;
      error.statusCode = res.status;
      error.responseError = resError;
      throw error;
    }
    if (!res.ok) {
      const error = new Error(res.statusText || `response status is ${res.status}`);
      error.status = res.status;
      error.statusCode = res.status;
      error.response = res;
      throw error;
    }
    return res;
  }
  const shouldDownloadAsText = function() {
    let contentType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return /(json|xml|yaml|text)\b/.test(contentType);
  };
  function parseBody(body, contentType) {
    if (contentType && (contentType.indexOf("application/json") === 0 || contentType.indexOf("+json") > 0)) {
      return JSON.parse(body);
    }
    return jsYaml.load(body);
  }
  function serializeRes(oriRes, url2) {
    let {
      loadSpec = false
    } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const res = {
      ok: oriRes.ok,
      url: oriRes.url || url2,
      status: oriRes.status,
      statusText: oriRes.statusText,
      headers: serializeHeaders(oriRes.headers)
    };
    const contentType = res.headers["content-type"];
    const useText = loadSpec || shouldDownloadAsText(contentType);
    const getBody = useText ? oriRes.text : oriRes.blob || oriRes.buffer;
    return getBody.call(oriRes).then((body) => {
      res.text = body;
      res.data = body;
      if (useText) {
        try {
          const obj = parseBody(body, contentType);
          res.body = obj;
          res.obj = obj;
        } catch (e) {
          res.parseError = e;
        }
      }
      return res;
    });
  }
  function serializeHeaderValue(value2) {
    const isMulti = value2.includes(", ");
    return isMulti ? value2.split(", ") : value2;
  }
  function serializeHeaders() {
    let headers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (typeof headers.entries !== "function")
      return {};
    return Array.from(headers.entries()).reduce((acc, _ref) => {
      let [header2, value2] = _ref;
      acc[header2] = serializeHeaderValue(value2);
      return acc;
    }, {});
  }
  function isFile(obj, navigatorObj) {
    if (!navigatorObj && typeof navigator !== "undefined") {
      navigatorObj = navigator;
    }
    if (navigatorObj && navigatorObj.product === "ReactNative") {
      if (obj && typeof obj === "object" && typeof obj.uri === "string") {
        return true;
      }
      return false;
    }
    if (typeof File !== "undefined" && obj instanceof File) {
      return true;
    }
    if (typeof Blob !== "undefined" && obj instanceof Blob) {
      return true;
    }
    if (ArrayBuffer.isView(obj)) {
      return true;
    }
    return obj !== null && typeof obj === "object" && typeof obj.pipe === "function";
  }
  function isArrayOfFile(obj, navigatorObj) {
    return Array.isArray(obj) && obj.some((v) => isFile(v, navigatorObj));
  }
  const STYLE_SEPARATORS = {
    form: ",",
    spaceDelimited: "%20",
    pipeDelimited: "|"
  };
  const SEPARATORS = {
    csv: ",",
    ssv: "%20",
    tsv: "%09",
    pipes: "|"
  };
  class FileWithData extends File {
    constructor(data2) {
      let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      super([data2], name, options);
      this.data = data2;
    }
    valueOf() {
      return this.data;
    }
    toString() {
      return this.valueOf();
    }
  }
  function formatKeyValue(key, input) {
    let skipEncoding = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    const {
      collectionFormat,
      allowEmptyValue,
      serializationOption,
      encoding
    } = input;
    const value2 = typeof input === "object" && !Array.isArray(input) ? input.value : input;
    const encodeFn = skipEncoding ? (k2) => k2.toString() : (k2) => encodeURIComponent(k2);
    const encodedKey = encodeFn(key);
    if (typeof value2 === "undefined" && allowEmptyValue) {
      return [[encodedKey, ""]];
    }
    if (isFile(value2) || isArrayOfFile(value2)) {
      return [[encodedKey, value2]];
    }
    if (serializationOption) {
      return formatKeyValueBySerializationOption(key, value2, skipEncoding, serializationOption);
    }
    if (encoding) {
      if ([typeof encoding.style, typeof encoding.explode, typeof encoding.allowReserved].some((type2) => type2 !== "undefined")) {
        const {
          style,
          explode,
          allowReserved
        } = encoding;
        return formatKeyValueBySerializationOption(key, value2, skipEncoding, {
          style,
          explode,
          allowReserved
        });
      }
      if (typeof encoding.contentType === "string") {
        if (encoding.contentType.startsWith("application/json")) {
          const json2 = typeof value2 === "string" ? value2 : JSON.stringify(value2);
          const encodedJson = encodeFn(json2);
          const file = new FileWithData(encodedJson, "blob", {
            type: encoding.contentType
          });
          return [[encodedKey, file]];
        }
        const encodedData = encodeFn(String(value2));
        const blob = new FileWithData(encodedData, "blob", {
          type: encoding.contentType
        });
        return [[encodedKey, blob]];
      }
      if (typeof value2 !== "object") {
        return [[encodedKey, encodeFn(value2)]];
      }
      if (Array.isArray(value2) && value2.every((v) => typeof v !== "object")) {
        return [[encodedKey, value2.map(encodeFn).join(",")]];
      }
      return [[encodedKey, encodeFn(JSON.stringify(value2))]];
    }
    if (typeof value2 !== "object") {
      return [[encodedKey, encodeFn(value2)]];
    }
    if (Array.isArray(value2)) {
      if (collectionFormat === "multi") {
        return [[encodedKey, value2.map(encodeFn)]];
      }
      return [[encodedKey, value2.map(encodeFn).join(SEPARATORS[collectionFormat || "csv"])]];
    }
    return [[encodedKey, ""]];
  }
  function formatKeyValueBySerializationOption(key, value2, skipEncoding, serializationOption) {
    const style = serializationOption.style || "form";
    const explode = typeof serializationOption.explode === "undefined" ? style === "form" : serializationOption.explode;
    const escape2 = skipEncoding ? false : serializationOption && serializationOption.allowReserved ? "unsafe" : "reserved";
    const encodeFn = (v) => encodeDisallowedCharacters(v, {
      escape: escape2
    });
    const encodeKeyFn = skipEncoding ? (k2) => k2 : (k2) => encodeDisallowedCharacters(k2, {
      escape: escape2
    });
    if (typeof value2 !== "object") {
      return [[encodeKeyFn(key), encodeFn(value2)]];
    }
    if (Array.isArray(value2)) {
      if (explode) {
        return [[encodeKeyFn(key), value2.map(encodeFn)]];
      }
      return [[encodeKeyFn(key), value2.map(encodeFn).join(STYLE_SEPARATORS[style])]];
    }
    if (style === "deepObject") {
      return Object.keys(value2).map((valueKey) => [encodeKeyFn(`${key}[${valueKey}]`), encodeFn(value2[valueKey])]);
    }
    if (explode) {
      return Object.keys(value2).map((valueKey) => [encodeKeyFn(valueKey), encodeFn(value2[valueKey])]);
    }
    return [[encodeKeyFn(key), Object.keys(value2).map((valueKey) => [`${encodeKeyFn(valueKey)},${encodeFn(value2[valueKey])}`]).join(",")]];
  }
  function buildFormData(reqForm) {
    return Object.entries(reqForm).reduce((formData, _ref2) => {
      let [name, input] = _ref2;
      for (const [key, value2] of formatKeyValue(name, input, true)) {
        if (Array.isArray(value2)) {
          for (const v of value2) {
            if (ArrayBuffer.isView(v)) {
              const blob = new Blob([v]);
              formData.append(key, blob);
            } else {
              formData.append(key, v);
            }
          }
        } else if (ArrayBuffer.isView(value2)) {
          const blob = new Blob([value2]);
          formData.append(key, blob);
        } else {
          formData.append(key, value2);
        }
      }
      return formData;
    }, new FormData());
  }
  function encodeFormOrQuery(data2) {
    const encodedQuery = Object.keys(data2).reduce((result, parameterName) => {
      for (const [key, value2] of formatKeyValue(parameterName, data2[parameterName])) {
        if (value2 instanceof FileWithData) {
          result[key] = value2.valueOf();
        } else {
          result[key] = value2;
        }
      }
      return result;
    }, {});
    return qs.stringify(encodedQuery, {
      encode: false,
      indices: false
    }) || "";
  }
  function mergeInQueryOrForm() {
    let req = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      url: url2 = "",
      query: query2,
      form
    } = req;
    const joinSearch = function() {
      for (var _len = arguments.length, strs = new Array(_len), _key = 0; _key < _len; _key++) {
        strs[_key] = arguments[_key];
      }
      const search = strs.filter((a) => a).join("&");
      return search ? `?${search}` : "";
    };
    if (form) {
      const hasFile = Object.keys(form).some((key) => {
        const {
          value: value2
        } = form[key];
        return isFile(value2) || isArrayOfFile(value2);
      });
      const contentType = req.headers["content-type"] || req.headers["Content-Type"];
      if (hasFile || /multipart\/form-data/i.test(contentType)) {
        const formdata = buildFormData(req.form);
        req.formdata = formdata;
        req.body = formdata;
      } else {
        req.body = encodeFormOrQuery(form);
      }
      delete req.form;
    }
    if (query2) {
      const [baseUrl2, oriSearch] = url2.split("?");
      let newStr = "";
      if (oriSearch) {
        const oriQuery = qs.parse(oriSearch);
        const keysToRemove = Object.keys(query2);
        keysToRemove.forEach((key) => delete oriQuery[key]);
        newStr = qs.stringify(oriQuery, {
          encode: true
        });
      }
      const finalStr = joinSearch(newStr, encodeFormOrQuery(query2));
      req.url = baseUrl2 + finalStr;
      delete req.query;
    }
    return req;
  }
  function makeHttp(httpFn, preFetch, postFetch) {
    postFetch = postFetch || ((a) => a);
    preFetch = preFetch || ((a) => a);
    return (req) => {
      if (typeof req === "string") {
        req = {
          url: req
        };
      }
      self$3.mergeInQueryOrForm(req);
      req = preFetch(req);
      return postFetch(httpFn(req));
    };
  }
  const ACCEPT_HEADER_VALUE_FOR_DOCUMENTS = "application/json, application/yaml";
  const DEFAULT_BASE_URL = "https://swagger.io";
  function makeFetchJSON(http2) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      requestInterceptor,
      responseInterceptor
    } = opts;
    const credentials = http2.withCredentials ? "include" : "same-origin";
    return (docPath) => http2({
      url: docPath,
      loadSpec: true,
      requestInterceptor,
      responseInterceptor,
      headers: {
        Accept: ACCEPT_HEADER_VALUE_FOR_DOCUMENTS
      },
      credentials
    }).then((res) => res.body);
  }
  const retrievalURI = (options) => {
    var _ref, _globalThis$document;
    const {
      baseDoc,
      url: url2
    } = options;
    const retrievalURL = (_ref = baseDoc !== null && baseDoc !== void 0 ? baseDoc : url2) !== null && _ref !== void 0 ? _ref : "";
    return typeof ((_globalThis$document = globalThis.document) === null || _globalThis$document === void 0 ? void 0 : _globalThis$document.baseURI) === "string" ? String(new URL(retrievalURL, globalThis.document.baseURI)) : retrievalURL;
  };
  const httpClient = (options) => {
    const {
      fetch: fetch2,
      http: http$1
    } = options;
    return fetch2 || http$1 || http;
  };
  /*!
   * https://github.com/Starcounter-Jack/JSON-Patch
   * (c) 2017-2022 Joachim Wester
   * MIT licensed
   */
  var __extends$1 = globalThis && globalThis.__extends || function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p2 in b2)
          if (b2.hasOwnProperty(p2))
            d2[p2] = b2[p2];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  function hasOwnProperty$c(obj, key) {
    return _hasOwnProperty.call(obj, key);
  }
  function _objectKeys(obj) {
    if (Array.isArray(obj)) {
      var keys_12 = new Array(obj.length);
      for (var k2 = 0; k2 < keys_12.length; k2++) {
        keys_12[k2] = "" + k2;
      }
      return keys_12;
    }
    if (Object.keys) {
      return Object.keys(obj);
    }
    var keys2 = [];
    for (var i2 in obj) {
      if (hasOwnProperty$c(obj, i2)) {
        keys2.push(i2);
      }
    }
    return keys2;
  }
  function _deepClone(obj) {
    switch (typeof obj) {
      case "object":
        return JSON.parse(JSON.stringify(obj));
      case "undefined":
        return null;
      default:
        return obj;
    }
  }
  function isInteger$3(str2) {
    var i2 = 0;
    var len2 = str2.length;
    var charCode;
    while (i2 < len2) {
      charCode = str2.charCodeAt(i2);
      if (charCode >= 48 && charCode <= 57) {
        i2++;
        continue;
      }
      return false;
    }
    return true;
  }
  function escapePathComponent(path2) {
    if (path2.indexOf("/") === -1 && path2.indexOf("~") === -1)
      return path2;
    return path2.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function unescapePathComponent(path2) {
    return path2.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  function hasUndefined(obj) {
    if (obj === void 0) {
      return true;
    }
    if (obj) {
      if (Array.isArray(obj)) {
        for (var i_1 = 0, len2 = obj.length; i_1 < len2; i_1++) {
          if (hasUndefined(obj[i_1])) {
            return true;
          }
        }
      } else if (typeof obj === "object") {
        var objKeys = _objectKeys(obj);
        var objKeysLength = objKeys.length;
        for (var i2 = 0; i2 < objKeysLength; i2++) {
          if (hasUndefined(obj[objKeys[i2]])) {
            return true;
          }
        }
      }
    }
    return false;
  }
  function patchErrorMessageFormatter(message, args) {
    var messageParts = [message];
    for (var key in args) {
      var value2 = typeof args[key] === "object" ? JSON.stringify(args[key], null, 2) : args[key];
      if (typeof value2 !== "undefined") {
        messageParts.push(key + ": " + value2);
      }
    }
    return messageParts.join("\n");
  }
  var PatchError = (
    /** @class */
    function(_super) {
      __extends$1(PatchError2, _super);
      function PatchError2(message, name, index2, operation, tree) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, patchErrorMessageFormatter(message, { name, index: index2, operation, tree })) || this;
        _this.name = name;
        _this.index = index2;
        _this.operation = operation;
        _this.tree = tree;
        Object.setPrototypeOf(_this, _newTarget.prototype);
        _this.message = patchErrorMessageFormatter(message, { name, index: index2, operation, tree });
        return _this;
      }
      return PatchError2;
    }(Error)
  );
  var JsonPatchError = PatchError;
  var deepClone = _deepClone;
  var objOps = {
    add: function(obj, key, document2) {
      obj[key] = this.value;
      return { newDocument: document2 };
    },
    remove: function(obj, key, document2) {
      var removed = obj[key];
      delete obj[key];
      return { newDocument: document2, removed };
    },
    replace: function(obj, key, document2) {
      var removed = obj[key];
      obj[key] = this.value;
      return { newDocument: document2, removed };
    },
    move: function(obj, key, document2) {
      var removed = getValueByPointer(document2, this.path);
      if (removed) {
        removed = _deepClone(removed);
      }
      var originalValue = applyOperation(document2, { op: "remove", path: this.from }).removed;
      applyOperation(document2, { op: "add", path: this.path, value: originalValue });
      return { newDocument: document2, removed };
    },
    copy: function(obj, key, document2) {
      var valueToCopy = getValueByPointer(document2, this.from);
      applyOperation(document2, { op: "add", path: this.path, value: _deepClone(valueToCopy) });
      return { newDocument: document2 };
    },
    test: function(obj, key, document2) {
      return { newDocument: document2, test: _areEquals(obj[key], this.value) };
    },
    _get: function(obj, key, document2) {
      this.value = obj[key];
      return { newDocument: document2 };
    }
  };
  var arrOps = {
    add: function(arr, i2, document2) {
      if (isInteger$3(i2)) {
        arr.splice(i2, 0, this.value);
      } else {
        arr[i2] = this.value;
      }
      return { newDocument: document2, index: i2 };
    },
    remove: function(arr, i2, document2) {
      var removedList = arr.splice(i2, 1);
      return { newDocument: document2, removed: removedList[0] };
    },
    replace: function(arr, i2, document2) {
      var removed = arr[i2];
      arr[i2] = this.value;
      return { newDocument: document2, removed };
    },
    move: objOps.move,
    copy: objOps.copy,
    test: objOps.test,
    _get: objOps._get
  };
  function getValueByPointer(document2, pointer) {
    if (pointer == "") {
      return document2;
    }
    var getOriginalDestination = { op: "_get", path: pointer };
    applyOperation(document2, getOriginalDestination);
    return getOriginalDestination.value;
  }
  function applyOperation(document2, operation, validateOperation, mutateDocument, banPrototypeModifications, index2) {
    if (validateOperation === void 0) {
      validateOperation = false;
    }
    if (mutateDocument === void 0) {
      mutateDocument = true;
    }
    if (banPrototypeModifications === void 0) {
      banPrototypeModifications = true;
    }
    if (index2 === void 0) {
      index2 = 0;
    }
    if (validateOperation) {
      if (typeof validateOperation == "function") {
        validateOperation(operation, 0, document2, operation.path);
      } else {
        validator(operation, 0);
      }
    }
    if (operation.path === "") {
      var returnValue = { newDocument: document2 };
      if (operation.op === "add") {
        returnValue.newDocument = operation.value;
        return returnValue;
      } else if (operation.op === "replace") {
        returnValue.newDocument = operation.value;
        returnValue.removed = document2;
        return returnValue;
      } else if (operation.op === "move" || operation.op === "copy") {
        returnValue.newDocument = getValueByPointer(document2, operation.from);
        if (operation.op === "move") {
          returnValue.removed = document2;
        }
        return returnValue;
      } else if (operation.op === "test") {
        returnValue.test = _areEquals(document2, operation.value);
        if (returnValue.test === false) {
          throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index2, operation, document2);
        }
        returnValue.newDocument = document2;
        return returnValue;
      } else if (operation.op === "remove") {
        returnValue.removed = document2;
        returnValue.newDocument = null;
        return returnValue;
      } else if (operation.op === "_get") {
        operation.value = document2;
        return returnValue;
      } else {
        if (validateOperation) {
          throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index2, operation, document2);
        } else {
          return returnValue;
        }
      }
    } else {
      if (!mutateDocument) {
        document2 = _deepClone(document2);
      }
      var path2 = operation.path || "";
      var keys2 = path2.split("/");
      var obj = document2;
      var t2 = 1;
      var len2 = keys2.length;
      var existingPathFragment = void 0;
      var key = void 0;
      var validateFunction = void 0;
      if (typeof validateOperation == "function") {
        validateFunction = validateOperation;
      } else {
        validateFunction = validator;
      }
      while (true) {
        key = keys2[t2];
        if (key && key.indexOf("~") != -1) {
          key = unescapePathComponent(key);
        }
        if (banPrototypeModifications && (key == "__proto__" || key == "prototype" && t2 > 0 && keys2[t2 - 1] == "constructor")) {
          throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
        }
        if (validateOperation) {
          if (existingPathFragment === void 0) {
            if (obj[key] === void 0) {
              existingPathFragment = keys2.slice(0, t2).join("/");
            } else if (t2 == len2 - 1) {
              existingPathFragment = operation.path;
            }
            if (existingPathFragment !== void 0) {
              validateFunction(operation, 0, document2, existingPathFragment);
            }
          }
        }
        t2++;
        if (Array.isArray(obj)) {
          if (key === "-") {
            key = obj.length;
          } else {
            if (validateOperation && !isInteger$3(key)) {
              throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index2, operation, document2);
            } else if (isInteger$3(key)) {
              key = ~~key;
            }
          }
          if (t2 >= len2) {
            if (validateOperation && operation.op === "add" && key > obj.length) {
              throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index2, operation, document2);
            }
            var returnValue = arrOps[operation.op].call(operation, obj, key, document2);
            if (returnValue.test === false) {
              throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index2, operation, document2);
            }
            return returnValue;
          }
        } else {
          if (t2 >= len2) {
            var returnValue = objOps[operation.op].call(operation, obj, key, document2);
            if (returnValue.test === false) {
              throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index2, operation, document2);
            }
            return returnValue;
          }
        }
        obj = obj[key];
        if (validateOperation && t2 < len2 && (!obj || typeof obj !== "object")) {
          throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index2, operation, document2);
        }
      }
    }
  }
  function applyPatch$1(document2, patch, validateOperation, mutateDocument, banPrototypeModifications) {
    if (mutateDocument === void 0) {
      mutateDocument = true;
    }
    if (banPrototypeModifications === void 0) {
      banPrototypeModifications = true;
    }
    if (validateOperation) {
      if (!Array.isArray(patch)) {
        throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
      }
    }
    if (!mutateDocument) {
      document2 = _deepClone(document2);
    }
    var results = new Array(patch.length);
    for (var i2 = 0, length_1 = patch.length; i2 < length_1; i2++) {
      results[i2] = applyOperation(document2, patch[i2], validateOperation, true, banPrototypeModifications, i2);
      document2 = results[i2].newDocument;
    }
    results.newDocument = document2;
    return results;
  }
  function applyReducer(document2, operation, index2) {
    var operationResult = applyOperation(document2, operation);
    if (operationResult.test === false) {
      throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index2, operation, document2);
    }
    return operationResult.newDocument;
  }
  function validator(operation, index2, document2, existingPathFragment) {
    if (typeof operation !== "object" || operation === null || Array.isArray(operation)) {
      throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index2, operation, document2);
    } else if (!objOps[operation.op]) {
      throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index2, operation, document2);
    } else if (typeof operation.path !== "string") {
      throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index2, operation, document2);
    } else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) {
      throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index2, operation, document2);
    } else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string") {
      throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index2, operation, document2);
    } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === void 0) {
      throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index2, operation, document2);
    } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && hasUndefined(operation.value)) {
      throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index2, operation, document2);
    } else if (document2) {
      if (operation.op == "add") {
        var pathLen = operation.path.split("/").length;
        var existingPathLen = existingPathFragment.split("/").length;
        if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
          throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index2, operation, document2);
        }
      } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
        if (operation.path !== existingPathFragment) {
          throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index2, operation, document2);
        }
      } else if (operation.op === "move" || operation.op === "copy") {
        var existingValue = { op: "_get", path: operation.from, value: void 0 };
        var error = validate([existingValue], document2);
        if (error && error.name === "OPERATION_PATH_UNRESOLVABLE") {
          throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index2, operation, document2);
        }
      }
    }
  }
  function validate(sequence, document2, externalValidator) {
    try {
      if (!Array.isArray(sequence)) {
        throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
      }
      if (document2) {
        applyPatch$1(_deepClone(document2), _deepClone(sequence), externalValidator || true);
      } else {
        externalValidator = externalValidator || validator;
        for (var i2 = 0; i2 < sequence.length; i2++) {
          externalValidator(sequence[i2], i2, document2, void 0);
        }
      }
    } catch (e) {
      if (e instanceof JsonPatchError) {
        return e;
      } else {
        throw e;
      }
    }
  }
  function _areEquals(a, b) {
    if (a === b)
      return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      var arrA = Array.isArray(a), arrB = Array.isArray(b), i2, length2, key;
      if (arrA && arrB) {
        length2 = a.length;
        if (length2 != b.length)
          return false;
        for (i2 = length2; i2-- !== 0; )
          if (!_areEquals(a[i2], b[i2]))
            return false;
        return true;
      }
      if (arrA != arrB)
        return false;
      var keys2 = Object.keys(a);
      length2 = keys2.length;
      if (length2 !== Object.keys(b).length)
        return false;
      for (i2 = length2; i2-- !== 0; )
        if (!b.hasOwnProperty(keys2[i2]))
          return false;
      for (i2 = length2; i2-- !== 0; ) {
        key = keys2[i2];
        if (!_areEquals(a[key], b[key]))
          return false;
      }
      return true;
    }
    return a !== a && b !== b;
  }
  const core$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    JsonPatchError,
    _areEquals,
    applyOperation,
    applyPatch: applyPatch$1,
    applyReducer,
    deepClone,
    getValueByPointer,
    validate,
    validator
  }, Symbol.toStringTag, { value: "Module" }));
  /*!
   * https://github.com/Starcounter-Jack/JSON-Patch
   * (c) 2017-2021 Joachim Wester
   * MIT license
   */
  var beforeDict = /* @__PURE__ */ new WeakMap();
  var Mirror = (
    /** @class */
    function() {
      function Mirror2(obj) {
        this.observers = /* @__PURE__ */ new Map();
        this.obj = obj;
      }
      return Mirror2;
    }()
  );
  var ObserverInfo = (
    /** @class */
    function() {
      function ObserverInfo2(callback, observer) {
        this.callback = callback;
        this.observer = observer;
      }
      return ObserverInfo2;
    }()
  );
  function getMirror(obj) {
    return beforeDict.get(obj);
  }
  function getObserverFromMirror(mirror, callback) {
    return mirror.observers.get(callback);
  }
  function removeObserverFromMirror(mirror, observer) {
    mirror.observers.delete(observer.callback);
  }
  function unobserve(root2, observer) {
    observer.unobserve();
  }
  function observe(obj, callback) {
    var patches = [];
    var observer;
    var mirror = getMirror(obj);
    if (!mirror) {
      mirror = new Mirror(obj);
      beforeDict.set(obj, mirror);
    } else {
      var observerInfo = getObserverFromMirror(mirror, callback);
      observer = observerInfo && observerInfo.observer;
    }
    if (observer) {
      return observer;
    }
    observer = {};
    mirror.value = _deepClone(obj);
    if (callback) {
      observer.callback = callback;
      observer.next = null;
      var dirtyCheck = function() {
        generate$1(observer);
      };
      var fastCheck = function() {
        clearTimeout(observer.next);
        observer.next = setTimeout(dirtyCheck);
      };
      if (typeof window !== "undefined") {
        window.addEventListener("mouseup", fastCheck);
        window.addEventListener("keyup", fastCheck);
        window.addEventListener("mousedown", fastCheck);
        window.addEventListener("keydown", fastCheck);
        window.addEventListener("change", fastCheck);
      }
    }
    observer.patches = patches;
    observer.object = obj;
    observer.unobserve = function() {
      generate$1(observer);
      clearTimeout(observer.next);
      removeObserverFromMirror(mirror, observer);
      if (typeof window !== "undefined") {
        window.removeEventListener("mouseup", fastCheck);
        window.removeEventListener("keyup", fastCheck);
        window.removeEventListener("mousedown", fastCheck);
        window.removeEventListener("keydown", fastCheck);
        window.removeEventListener("change", fastCheck);
      }
    };
    mirror.observers.set(callback, new ObserverInfo(callback, observer));
    return observer;
  }
  function generate$1(observer, invertible) {
    if (invertible === void 0) {
      invertible = false;
    }
    var mirror = beforeDict.get(observer.object);
    _generate(mirror.value, observer.object, observer.patches, "", invertible);
    if (observer.patches.length) {
      applyPatch$1(mirror.value, observer.patches);
    }
    var temp = observer.patches;
    if (temp.length > 0) {
      observer.patches = [];
      if (observer.callback) {
        observer.callback(temp);
      }
    }
    return temp;
  }
  function _generate(mirror, obj, patches, path2, invertible) {
    if (obj === mirror) {
      return;
    }
    if (typeof obj.toJSON === "function") {
      obj = obj.toJSON();
    }
    var newKeys = _objectKeys(obj);
    var oldKeys = _objectKeys(mirror);
    var deleted = false;
    for (var t2 = oldKeys.length - 1; t2 >= 0; t2--) {
      var key = oldKeys[t2];
      var oldVal = mirror[key];
      if (hasOwnProperty$c(obj, key) && !(obj[key] === void 0 && oldVal !== void 0 && Array.isArray(obj) === false)) {
        var newVal = obj[key];
        if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) {
          _generate(oldVal, newVal, patches, path2 + "/" + escapePathComponent(key), invertible);
        } else {
          if (oldVal !== newVal) {
            if (invertible) {
              patches.push({ op: "test", path: path2 + "/" + escapePathComponent(key), value: _deepClone(oldVal) });
            }
            patches.push({ op: "replace", path: path2 + "/" + escapePathComponent(key), value: _deepClone(newVal) });
          }
        }
      } else if (Array.isArray(mirror) === Array.isArray(obj)) {
        if (invertible) {
          patches.push({ op: "test", path: path2 + "/" + escapePathComponent(key), value: _deepClone(oldVal) });
        }
        patches.push({ op: "remove", path: path2 + "/" + escapePathComponent(key) });
        deleted = true;
      } else {
        if (invertible) {
          patches.push({ op: "test", path: path2, value: mirror });
        }
        patches.push({ op: "replace", path: path2, value: obj });
      }
    }
    if (!deleted && newKeys.length == oldKeys.length) {
      return;
    }
    for (var t2 = 0; t2 < newKeys.length; t2++) {
      var key = newKeys[t2];
      if (!hasOwnProperty$c(mirror, key) && obj[key] !== void 0) {
        patches.push({ op: "add", path: path2 + "/" + escapePathComponent(key), value: _deepClone(obj[key]) });
      }
    }
  }
  function compare(tree1, tree2, invertible) {
    if (invertible === void 0) {
      invertible = false;
    }
    var patches = [];
    _generate(tree1, tree2, patches, "", invertible);
    return patches;
  }
  const duplex = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    compare,
    generate: generate$1,
    observe,
    unobserve
  }, Symbol.toStringTag, { value: "Module" }));
  Object.assign({}, core$1, duplex, {
    JsonPatchError: PatchError,
    deepClone: _deepClone,
    escapePathComponent,
    unescapePathComponent
  });
  var isMergeableObject = function isMergeableObject2(value2) {
    return isNonNullObject(value2) && !isSpecial(value2);
  };
  function isNonNullObject(value2) {
    return !!value2 && typeof value2 === "object";
  }
  function isSpecial(value2) {
    var stringValue = Object.prototype.toString.call(value2);
    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value2);
  }
  var canUseSymbol = typeof Symbol === "function" && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
  function isReactElement(value2) {
    return value2.$$typeof === REACT_ELEMENT_TYPE;
  }
  function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
  }
  function cloneUnlessOtherwiseSpecified$1(value2, options) {
    return options.clone !== false && options.isMergeableObject(value2) ? deepmerge$1(emptyTarget(value2), value2, options) : value2;
  }
  function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function(element) {
      return cloneUnlessOtherwiseSpecified$1(element, options);
    });
  }
  function getMergeFunction$1(key, options) {
    if (!options.customMerge) {
      return deepmerge$1;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === "function" ? customMerge : deepmerge$1;
  }
  function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
      return Object.propertyIsEnumerable.call(target, symbol);
    }) : [];
  }
  function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
  }
  function propertyIsOnObject(object, property) {
    try {
      return property in object;
    } catch (_) {
      return false;
    }
  }
  function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
  }
  function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
      getKeys(target).forEach(function(key) {
        destination[key] = cloneUnlessOtherwiseSpecified$1(target[key], options);
      });
    }
    getKeys(source).forEach(function(key) {
      if (propertyIsUnsafe(target, key)) {
        return;
      }
      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
        destination[key] = getMergeFunction$1(key, options)(target[key], source[key], options);
      } else {
        destination[key] = cloneUnlessOtherwiseSpecified$1(source[key], options);
      }
    });
    return destination;
  }
  function deepmerge$1(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified$1;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified$1(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target, source, options);
    } else {
      return mergeObject(target, source, options);
    }
  }
  deepmerge$1.all = function deepmergeAll(array, options) {
    if (!Array.isArray(array)) {
      throw new Error("first argument should be an array");
    }
    return array.reduce(function(prev2, next) {
      return deepmerge$1(prev2, next, options);
    }, {});
  };
  var deepmerge_1 = deepmerge$1;
  var cjs$4 = deepmerge_1;
  const deepmerge$2 = /* @__PURE__ */ getDefaultExportFromCjs(cjs$4);
  const lib$4 = {
    add: add$1,
    replace: replace$3,
    remove,
    merge: merge$4,
    mergeDeep,
    context,
    getIn,
    applyPatch,
    parentPathMatch,
    flatten,
    fullyNormalizeArray,
    normalizeArray: normalizeArray$1,
    isPromise: isPromise$1,
    forEachNew,
    forEachNewPrimitive,
    isJsonPatch,
    isContextPatch,
    isPatch,
    isMutation,
    isAdditiveMutation,
    isGenerator,
    isFunction: isFunction$8,
    isObject: isObject$i,
    isError: isError$1
  };
  function applyPatch(obj, patch, opts) {
    opts = opts || {};
    patch = {
      ...patch,
      path: patch.path && normalizeJSONPath(patch.path)
    };
    if (patch.op === "merge") {
      const newValue = getInByJsonPath(obj, patch.path);
      Object.assign(newValue, patch.value);
      applyPatch$1(obj, [replace$3(patch.path, newValue)]);
    } else if (patch.op === "mergeDeep") {
      const currentValue = getInByJsonPath(obj, patch.path);
      const newValue = deepmerge$2(currentValue, patch.value);
      obj = applyPatch$1(obj, [replace$3(patch.path, newValue)]).newDocument;
    } else if (patch.op === "add" && patch.path === "" && isObject$i(patch.value)) {
      const patches = Object.keys(patch.value).reduce((arr, key) => {
        arr.push({
          op: "add",
          path: `/${normalizeJSONPath(key)}`,
          value: patch.value[key]
        });
        return arr;
      }, []);
      applyPatch$1(obj, patches);
    } else if (patch.op === "replace" && patch.path === "") {
      let {
        value: value2
      } = patch;
      if (opts.allowMetaPatches && patch.meta && isAdditiveMutation(patch) && (Array.isArray(patch.value) || isObject$i(patch.value))) {
        value2 = {
          ...value2,
          ...patch.meta
        };
      }
      obj = value2;
    } else {
      applyPatch$1(obj, [patch]);
      if (opts.allowMetaPatches && patch.meta && isAdditiveMutation(patch) && (Array.isArray(patch.value) || isObject$i(patch.value))) {
        const currentValue = getInByJsonPath(obj, patch.path);
        const newValue = {
          ...currentValue,
          ...patch.meta
        };
        applyPatch$1(obj, [replace$3(patch.path, newValue)]);
      }
    }
    return obj;
  }
  function normalizeJSONPath(path2) {
    if (Array.isArray(path2)) {
      if (path2.length < 1) {
        return "";
      }
      return `/${path2.map(
        (item) => (
          // eslint-disable-line prefer-template
          (item + "").replace(/~/g, "~0").replace(/\//g, "~1")
        )
        // eslint-disable-line prefer-template
      ).join("/")}`;
    }
    return path2;
  }
  function add$1(path2, value2) {
    return {
      op: "add",
      path: path2,
      value: value2
    };
  }
  function replace$3(path2, value2, meta) {
    return {
      op: "replace",
      path: path2,
      value: value2,
      meta
    };
  }
  function remove(path2) {
    return {
      op: "remove",
      path: path2
    };
  }
  function merge$4(path2, value2) {
    return {
      type: "mutation",
      op: "merge",
      path: path2,
      value: value2
    };
  }
  function mergeDeep(path2, value2) {
    return {
      type: "mutation",
      op: "mergeDeep",
      path: path2,
      value: value2
    };
  }
  function context(path2, value2) {
    return {
      type: "context",
      path: path2,
      value: value2
    };
  }
  function forEachNew(mutations, fn) {
    try {
      return forEachNewPatch(mutations, forEach$1, fn);
    } catch (e) {
      return e;
    }
  }
  function forEachNewPrimitive(mutations, fn) {
    try {
      return forEachNewPatch(mutations, forEachPrimitive, fn);
    } catch (e) {
      return e;
    }
  }
  function forEachNewPatch(mutations, fn, callback) {
    const res = mutations.filter(isAdditiveMutation).map((mutation) => fn(mutation.value, callback, mutation.path)) || [];
    const flat = flatten(res);
    const clean = cleanArray(flat);
    return clean;
  }
  function forEachPrimitive(obj, fn, basePath) {
    basePath = basePath || [];
    if (Array.isArray(obj)) {
      return obj.map((val, key) => forEachPrimitive(val, fn, basePath.concat(key)));
    }
    if (isObject$i(obj)) {
      return Object.keys(obj).map((key) => forEachPrimitive(obj[key], fn, basePath.concat(key)));
    }
    return fn(obj, basePath[basePath.length - 1], basePath);
  }
  function forEach$1(obj, fn, basePath) {
    basePath = basePath || [];
    let results = [];
    if (basePath.length > 0) {
      const newResults = fn(obj, basePath[basePath.length - 1], basePath);
      if (newResults) {
        results = results.concat(newResults);
      }
    }
    if (Array.isArray(obj)) {
      const arrayResults = obj.map((val, key) => forEach$1(val, fn, basePath.concat(key)));
      if (arrayResults) {
        results = results.concat(arrayResults);
      }
    } else if (isObject$i(obj)) {
      const moreResults = Object.keys(obj).map((key) => forEach$1(obj[key], fn, basePath.concat(key)));
      if (moreResults) {
        results = results.concat(moreResults);
      }
    }
    results = flatten(results);
    return results;
  }
  function parentPathMatch(path2, arr) {
    if (!Array.isArray(arr)) {
      return false;
    }
    for (let i2 = 0, len2 = arr.length; i2 < len2; i2 += 1) {
      if (arr[i2] !== path2[i2]) {
        return false;
      }
    }
    return true;
  }
  function getIn(obj, path2) {
    return path2.reduce((val, token) => {
      if (typeof token !== "undefined" && val) {
        return val[token];
      }
      return val;
    }, obj);
  }
  function fullyNormalizeArray(arr) {
    return cleanArray(flatten(normalizeArray$1(arr)));
  }
  function normalizeArray$1(arr) {
    return Array.isArray(arr) ? arr : [arr];
  }
  function flatten(arr) {
    return [].concat(...arr.map((val) => Array.isArray(val) ? flatten(val) : val));
  }
  function cleanArray(arr) {
    return arr.filter((elm) => typeof elm !== "undefined");
  }
  function isObject$i(val) {
    return val && typeof val === "object";
  }
  function isPromise$1(val) {
    return isObject$i(val) && isFunction$8(val.then);
  }
  function isFunction$8(val) {
    return val && typeof val === "function";
  }
  function isError$1(patch) {
    return patch instanceof Error;
  }
  function isJsonPatch(patch) {
    if (isPatch(patch)) {
      const {
        op
      } = patch;
      return op === "add" || op === "remove" || op === "replace";
    }
    return false;
  }
  function isGenerator(thing) {
    return Object.prototype.toString.call(thing) === "[object GeneratorFunction]";
  }
  function isMutation(patch) {
    return isJsonPatch(patch) || isPatch(patch) && patch.type === "mutation";
  }
  function isAdditiveMutation(patch) {
    return isMutation(patch) && (patch.op === "add" || patch.op === "replace" || patch.op === "merge" || patch.op === "mergeDeep");
  }
  function isContextPatch(patch) {
    return isPatch(patch) && patch.type === "context";
  }
  function isPatch(patch) {
    return patch && typeof patch === "object";
  }
  function getInByJsonPath(obj, jsonPath) {
    try {
      return getValueByPointer(obj, jsonPath);
    } catch (e) {
      console.error(e);
      return {};
    }
  }
  var stampit_min = { exports: {} };
  (function(module2) {
    !function() {
      var u, c, a, s, f2, y = "properties", l2 = "deepProperties", b = "propertyDescriptors", d = "staticProperties", O = "staticDeepProperties", h = "staticPropertyDescriptors", g = "configuration", m2 = "deepConfiguration", P = "deepProps", A = "deepStatics", j = "deepConf", v = "initializers", _ = "methods", w = "composers", D = "compose";
      function S(r2) {
        return Object.getOwnPropertyNames(r2).concat(Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(r2) : []);
      }
      function r(r2, t3) {
        return Array.prototype.slice.call(arguments, 2).reduce(r2, t3);
      }
      var x2 = r.bind(0, function r2(t3, e2) {
        if (e2)
          for (var n3 = S(e2), o2 = 0; o2 < n3.length; o2 += 1)
            Object.defineProperty(t3, n3[o2], Object.getOwnPropertyDescriptor(e2, n3[o2]));
        return t3;
      });
      function C(r2) {
        return "function" == typeof r2;
      }
      function N(r2) {
        return r2 && "object" == typeof r2 || C(r2);
      }
      function z2(r2) {
        return r2 && "object" == typeof r2 && r2.__proto__ == Object.prototype;
      }
      var E = r.bind(0, function r2(t3, e2) {
        if (e2 === u)
          return t3;
        if (Array.isArray(e2))
          return (Array.isArray(t3) ? t3 : []).concat(e2);
        if (!z2(e2))
          return e2;
        for (var n3, o2, i2 = S(e2), p2 = 0; p2 < i2.length; )
          n3 = i2[p2++], (o2 = Object.getOwnPropertyDescriptor(e2, n3)).hasOwnProperty("value") ? o2.value !== u && (t3[n3] = r2(z2(t3[n3]) || Array.isArray(e2[n3]) ? t3[n3] : {}, e2[n3])) : Object.defineProperty(t3, n3, o2);
        return t3;
      });
      function I() {
        return (c = Array.prototype.concat.apply([], arguments).filter(function(r2, t3, e2) {
          return C(r2) && e2.indexOf(r2) === t3;
        })).length ? c : u;
      }
      function t2(r2) {
        return c = function r3() {
          return function r4(t3) {
            var e2, n3, o2 = r4[D] || {}, i2 = { __proto__: o2[_] }, p2 = o2[v], c2 = Array.prototype.slice.apply(arguments), a2 = o2[l2];
            if (a2 && E(i2, a2), (a2 = o2[y]) && x2(i2, a2), (a2 = o2[b]) && Object.defineProperties(i2, a2), !p2 || !p2.length)
              return i2;
            for (t3 === u && (t3 = {}), o2 = 0; o2 < p2.length; )
              C(e2 = p2[o2++]) && (i2 = (n3 = e2.call(i2, t3, { instance: i2, stamp: r4, args: c2 })) === u ? i2 : n3);
            return i2;
          };
        }(), (a = r2[O]) && E(c, a), (a = r2[d]) && x2(c, a), (a = r2[h]) && Object.defineProperties(c, a), a = C(c[D]) ? c[D] : R, x2(c[D] = function() {
          return a.apply(this, arguments);
        }, r2), c;
      }
      function e(e2, n3) {
        function r2(r3, t4) {
          N(n3[r3]) && (N(e2[r3]) || (e2[r3] = {}), (t4 || x2)(e2[r3], n3[r3]));
        }
        function t3(r3) {
          (c = I(e2[r3], n3[r3])) && (e2[r3] = c);
        }
        return n3 && N(n3 = n3[D] || n3) && (r2(_), r2(y), r2(l2, E), r2(b), r2(d), r2(O, E), r2(h), r2(g), r2(m2, E), t3(v), t3(w)), e2;
      }
      function R() {
        return t2(Array.prototype.concat.apply([this], arguments).reduce(e, {}));
      }
      function V(r2) {
        return C(r2) && C(r2[D]);
      }
      var n2 = {};
      function o(r2, t3) {
        return function() {
          return (s = {})[r2] = t3.apply(u, Array.prototype.concat.apply([{}], arguments)), ((c = this) && c[D] || a).call(c, s);
        };
      }
      n2[_] = o(_, x2), n2[y] = n2.props = o(y, x2), n2[v] = n2.init = o(v, I), n2[w] = o(w, I), n2[l2] = n2[P] = o(l2, E), n2[d] = n2.statics = o(d, x2), n2[O] = n2[A] = o(O, E), n2[g] = n2.conf = o(g, x2), n2[m2] = n2[j] = o(m2, E), n2[b] = o(b, x2), n2[h] = o(h, x2), a = n2[D] = x2(function r2() {
        for (var t3, e2, n3 = 0, o2 = [], i2 = arguments, p2 = this; n3 < i2.length; )
          N(t3 = i2[n3++]) && o2.push(V(t3) ? t3 : ((s = {})[_] = (e2 = t3)[_] || u, a = e2.props, s[y] = N((c = e2[y]) || a) ? x2({}, a, c) : u, s[v] = I(e2.init, e2[v]), s[w] = I(e2[w]), a = e2[P], s[l2] = N((c = e2[l2]) || a) ? E({}, a, c) : u, s[b] = e2[b], a = e2.statics, s[d] = N((c = e2[d]) || a) ? x2({}, a, c) : u, a = e2[A], s[O] = N((c = e2[O]) || a) ? E({}, a, c) : u, c = e2[h], s[h] = N((a = e2.name && { name: { value: e2.name } }) || c) ? x2({}, c, a) : u, a = e2.conf, s[g] = N((c = e2[g]) || a) ? x2({}, a, c) : u, a = e2[j], s[m2] = N((c = e2[m2]) || a) ? E({}, a, c) : u, s));
        if (t3 = R.apply(p2 || f2, o2), p2 && o2.unshift(p2), Array.isArray(i2 = t3[D][w]))
          for (n3 = 0; n3 < i2.length; )
            t3 = V(p2 = i2[n3++]({ stamp: t3, composables: o2 })) ? p2 : t3;
        return t3;
      }, n2), n2.create = function() {
        return this.apply(u, arguments);
      }, (s = {})[d] = n2, f2 = R(s), a[D] = a.bind(), a.version = "4.3.2", module2.exports = a;
    }();
  })(stampit_min);
  var stampit_minExports = stampit_min.exports;
  const stampit = /* @__PURE__ */ getDefaultExportFromCjs(stampit_minExports);
  var F = function() {
    return false;
  };
  const stubFalse$1 = F;
  var T = function() {
    return true;
  };
  const stubTrue = T;
  function _isPlaceholder(a) {
    return a != null && typeof a === "object" && a["@@functional/placeholder"] === true;
  }
  function _curry1(fn) {
    return function f1(a) {
      if (arguments.length === 0 || _isPlaceholder(a)) {
        return f1;
      } else {
        return fn.apply(this, arguments);
      }
    };
  }
  function _curry2(fn) {
    return function f2(a, b) {
      switch (arguments.length) {
        case 0:
          return f2;
        case 1:
          return _isPlaceholder(a) ? f2 : _curry1(function(_b) {
            return fn(a, _b);
          });
        default:
          return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function(_a3) {
            return fn(_a3, b);
          }) : _isPlaceholder(b) ? _curry1(function(_b) {
            return fn(a, _b);
          }) : fn(a, b);
      }
    };
  }
  function _concat(set1, set2) {
    set1 = set1 || [];
    set2 = set2 || [];
    var idx;
    var len1 = set1.length;
    var len2 = set2.length;
    var result = [];
    idx = 0;
    while (idx < len1) {
      result[result.length] = set1[idx];
      idx += 1;
    }
    idx = 0;
    while (idx < len2) {
      result[result.length] = set2[idx];
      idx += 1;
    }
    return result;
  }
  function _arity(n2, fn) {
    switch (n2) {
      case 0:
        return function() {
          return fn.apply(this, arguments);
        };
      case 1:
        return function(a0) {
          return fn.apply(this, arguments);
        };
      case 2:
        return function(a0, a1) {
          return fn.apply(this, arguments);
        };
      case 3:
        return function(a0, a1, a2) {
          return fn.apply(this, arguments);
        };
      case 4:
        return function(a0, a1, a2, a3) {
          return fn.apply(this, arguments);
        };
      case 5:
        return function(a0, a1, a2, a3, a4) {
          return fn.apply(this, arguments);
        };
      case 6:
        return function(a0, a1, a2, a3, a4, a5) {
          return fn.apply(this, arguments);
        };
      case 7:
        return function(a0, a1, a2, a3, a4, a5, a6) {
          return fn.apply(this, arguments);
        };
      case 8:
        return function(a0, a1, a2, a3, a4, a5, a6, a7) {
          return fn.apply(this, arguments);
        };
      case 9:
        return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
          return fn.apply(this, arguments);
        };
      case 10:
        return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          return fn.apply(this, arguments);
        };
      default:
        throw new Error("First argument to _arity must be a non-negative integer no greater than ten");
    }
  }
  function _curryN(length2, received, fn) {
    return function() {
      var combined = [];
      var argsIdx = 0;
      var left = length2;
      var combinedIdx = 0;
      var hasPlaceholder = false;
      while (combinedIdx < received.length || argsIdx < arguments.length) {
        var result;
        if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
          result = received[combinedIdx];
        } else {
          result = arguments[argsIdx];
          argsIdx += 1;
        }
        combined[combinedIdx] = result;
        if (!_isPlaceholder(result)) {
          left -= 1;
        } else {
          hasPlaceholder = true;
        }
        combinedIdx += 1;
      }
      return !hasPlaceholder && left <= 0 ? fn.apply(this, combined) : _arity(Math.max(0, left), _curryN(length2, combined, fn));
    };
  }
  var curryN = /* @__PURE__ */ _curry2(function curryN2(length2, fn) {
    if (length2 === 1) {
      return _curry1(fn);
    }
    return _arity(length2, _curryN(length2, [], fn));
  });
  const curryN$1 = curryN;
  function _curry3(fn) {
    return function f3(a, b, c) {
      switch (arguments.length) {
        case 0:
          return f3;
        case 1:
          return _isPlaceholder(a) ? f3 : _curry2(function(_b, _c) {
            return fn(a, _b, _c);
          });
        case 2:
          return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function(_a3, _c) {
            return fn(_a3, b, _c);
          }) : _isPlaceholder(b) ? _curry2(function(_b, _c) {
            return fn(a, _b, _c);
          }) : _curry1(function(_c) {
            return fn(a, b, _c);
          });
        default:
          return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function(_a3, _b) {
            return fn(_a3, _b, c);
          }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function(_a3, _c) {
            return fn(_a3, b, _c);
          }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function(_b, _c) {
            return fn(a, _b, _c);
          }) : _isPlaceholder(a) ? _curry1(function(_a3) {
            return fn(_a3, b, c);
          }) : _isPlaceholder(b) ? _curry1(function(_b) {
            return fn(a, _b, c);
          }) : _isPlaceholder(c) ? _curry1(function(_c) {
            return fn(a, b, _c);
          }) : fn(a, b, c);
      }
    };
  }
  const _isArray = Array.isArray || function _isArray2(val) {
    return val != null && val.length >= 0 && Object.prototype.toString.call(val) === "[object Array]";
  };
  function _isTransformer(obj) {
    return obj != null && typeof obj["@@transducer/step"] === "function";
  }
  function _dispatchable(methodNames, transducerCreator, fn) {
    return function() {
      if (arguments.length === 0) {
        return fn();
      }
      var obj = arguments[arguments.length - 1];
      if (!_isArray(obj)) {
        var idx = 0;
        while (idx < methodNames.length) {
          if (typeof obj[methodNames[idx]] === "function") {
            return obj[methodNames[idx]].apply(obj, Array.prototype.slice.call(arguments, 0, -1));
          }
          idx += 1;
        }
        if (_isTransformer(obj)) {
          var transducer = transducerCreator.apply(null, Array.prototype.slice.call(arguments, 0, -1));
          return transducer(obj);
        }
      }
      return fn.apply(this, arguments);
    };
  }
  function _reduced(x2) {
    return x2 && x2["@@transducer/reduced"] ? x2 : {
      "@@transducer/value": x2,
      "@@transducer/reduced": true
    };
  }
  const _xfBase = {
    init: function() {
      return this.xf["@@transducer/init"]();
    },
    result: function(result) {
      return this.xf["@@transducer/result"](result);
    }
  };
  var XAll = /* @__PURE__ */ function() {
    function XAll2(f2, xf) {
      this.xf = xf;
      this.f = f2;
      this.all = true;
    }
    XAll2.prototype["@@transducer/init"] = _xfBase.init;
    XAll2.prototype["@@transducer/result"] = function(result) {
      if (this.all) {
        result = this.xf["@@transducer/step"](result, true);
      }
      return this.xf["@@transducer/result"](result);
    };
    XAll2.prototype["@@transducer/step"] = function(result, input) {
      if (!this.f(input)) {
        this.all = false;
        result = _reduced(this.xf["@@transducer/step"](result, false));
      }
      return result;
    };
    return XAll2;
  }();
  function _xall(f2) {
    return function(xf) {
      return new XAll(f2, xf);
    };
  }
  var all = /* @__PURE__ */ _curry2(
    /* @__PURE__ */ _dispatchable(["all"], _xall, function all2(fn, list2) {
      var idx = 0;
      while (idx < list2.length) {
        if (!fn(list2[idx])) {
          return false;
        }
        idx += 1;
      }
      return true;
    })
  );
  const all$1 = all;
  function _arrayFromIterator(iter) {
    var list2 = [];
    var next;
    while (!(next = iter.next()).done) {
      list2.push(next.value);
    }
    return list2;
  }
  function _includesWith(pred, x2, list2) {
    var idx = 0;
    var len2 = list2.length;
    while (idx < len2) {
      if (pred(x2, list2[idx])) {
        return true;
      }
      idx += 1;
    }
    return false;
  }
  function _functionName(f2) {
    var match2 = String(f2).match(/^function (\w*)/);
    return match2 == null ? "" : match2[1];
  }
  function _has(prop2, obj) {
    return Object.prototype.hasOwnProperty.call(obj, prop2);
  }
  function _objectIs(a, b) {
    if (a === b) {
      return a !== 0 || 1 / a === 1 / b;
    } else {
      return a !== a && b !== b;
    }
  }
  const _objectIs$1 = typeof Object.is === "function" ? Object.is : _objectIs;
  var toString$a = Object.prototype.toString;
  var _isArguments = /* @__PURE__ */ function() {
    return toString$a.call(arguments) === "[object Arguments]" ? function _isArguments2(x2) {
      return toString$a.call(x2) === "[object Arguments]";
    } : function _isArguments2(x2) {
      return _has("callee", x2);
    };
  }();
  const _isArguments$1 = _isArguments;
  var hasEnumBug = !/* @__PURE__ */ {
    toString: null
  }.propertyIsEnumerable("toString");
  var nonEnumerableProps = ["constructor", "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];
  var hasArgsEnumBug = /* @__PURE__ */ function() {
    return arguments.propertyIsEnumerable("length");
  }();
  var contains = function contains2(list2, item) {
    var idx = 0;
    while (idx < list2.length) {
      if (list2[idx] === item) {
        return true;
      }
      idx += 1;
    }
    return false;
  };
  var keys$3 = typeof Object.keys === "function" && !hasArgsEnumBug ? /* @__PURE__ */ _curry1(function keys2(obj) {
    return Object(obj) !== obj ? [] : Object.keys(obj);
  }) : /* @__PURE__ */ _curry1(function keys2(obj) {
    if (Object(obj) !== obj) {
      return [];
    }
    var prop2, nIdx;
    var ks = [];
    var checkArgsLength = hasArgsEnumBug && _isArguments$1(obj);
    for (prop2 in obj) {
      if (_has(prop2, obj) && (!checkArgsLength || prop2 !== "length")) {
        ks[ks.length] = prop2;
      }
    }
    if (hasEnumBug) {
      nIdx = nonEnumerableProps.length - 1;
      while (nIdx >= 0) {
        prop2 = nonEnumerableProps[nIdx];
        if (_has(prop2, obj) && !contains(ks, prop2)) {
          ks[ks.length] = prop2;
        }
        nIdx -= 1;
      }
    }
    return ks;
  });
  const keys$4 = keys$3;
  var type = /* @__PURE__ */ _curry1(function type2(val) {
    return val === null ? "Null" : val === void 0 ? "Undefined" : Object.prototype.toString.call(val).slice(8, -1);
  });
  const type$1 = type;
  function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
    var a = _arrayFromIterator(aIterator);
    var b = _arrayFromIterator(bIterator);
    function eq2(_a3, _b) {
      return _equals(_a3, _b, stackA.slice(), stackB.slice());
    }
    return !_includesWith(function(b2, aItem) {
      return !_includesWith(eq2, aItem, b2);
    }, b, a);
  }
  function _equals(a, b, stackA, stackB) {
    if (_objectIs$1(a, b)) {
      return true;
    }
    var typeA = type$1(a);
    if (typeA !== type$1(b)) {
      return false;
    }
    if (typeof a["fantasy-land/equals"] === "function" || typeof b["fantasy-land/equals"] === "function") {
      return typeof a["fantasy-land/equals"] === "function" && a["fantasy-land/equals"](b) && typeof b["fantasy-land/equals"] === "function" && b["fantasy-land/equals"](a);
    }
    if (typeof a.equals === "function" || typeof b.equals === "function") {
      return typeof a.equals === "function" && a.equals(b) && typeof b.equals === "function" && b.equals(a);
    }
    switch (typeA) {
      case "Arguments":
      case "Array":
      case "Object":
        if (typeof a.constructor === "function" && _functionName(a.constructor) === "Promise") {
          return a === b;
        }
        break;
      case "Boolean":
      case "Number":
      case "String":
        if (!(typeof a === typeof b && _objectIs$1(a.valueOf(), b.valueOf()))) {
          return false;
        }
        break;
      case "Date":
        if (!_objectIs$1(a.valueOf(), b.valueOf())) {
          return false;
        }
        break;
      case "Error":
        return a.name === b.name && a.message === b.message;
      case "RegExp":
        if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
          return false;
        }
        break;
    }
    var idx = stackA.length - 1;
    while (idx >= 0) {
      if (stackA[idx] === a) {
        return stackB[idx] === b;
      }
      idx -= 1;
    }
    switch (typeA) {
      case "Map":
        if (a.size !== b.size) {
          return false;
        }
        return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));
      case "Set":
        if (a.size !== b.size) {
          return false;
        }
        return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));
      case "Arguments":
      case "Array":
      case "Object":
      case "Boolean":
      case "Number":
      case "String":
      case "Date":
      case "Error":
      case "RegExp":
      case "Int8Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
      case "Int16Array":
      case "Uint16Array":
      case "Int32Array":
      case "Uint32Array":
      case "Float32Array":
      case "Float64Array":
      case "ArrayBuffer":
        break;
      default:
        return false;
    }
    var keysA = keys$4(a);
    if (keysA.length !== keys$4(b).length) {
      return false;
    }
    var extendedStackA = stackA.concat([a]);
    var extendedStackB = stackB.concat([b]);
    idx = keysA.length - 1;
    while (idx >= 0) {
      var key = keysA[idx];
      if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
        return false;
      }
      idx -= 1;
    }
    return true;
  }
  var equals = /* @__PURE__ */ _curry2(function equals2(a, b) {
    return _equals(a, b, [], []);
  });
  const equals$1 = equals;
  function _indexOf(list2, a, idx) {
    var inf, item;
    if (typeof list2.indexOf === "function") {
      switch (typeof a) {
        case "number":
          if (a === 0) {
            inf = 1 / a;
            while (idx < list2.length) {
              item = list2[idx];
              if (item === 0 && 1 / item === inf) {
                return idx;
              }
              idx += 1;
            }
            return -1;
          } else if (a !== a) {
            while (idx < list2.length) {
              item = list2[idx];
              if (typeof item === "number" && item !== item) {
                return idx;
              }
              idx += 1;
            }
            return -1;
          }
          return list2.indexOf(a, idx);
        case "string":
        case "boolean":
        case "function":
        case "undefined":
          return list2.indexOf(a, idx);
        case "object":
          if (a === null) {
            return list2.indexOf(a, idx);
          }
      }
    }
    while (idx < list2.length) {
      if (equals$1(list2[idx], a)) {
        return idx;
      }
      idx += 1;
    }
    return -1;
  }
  function _includes(a, list2) {
    return _indexOf(list2, a, 0) >= 0;
  }
  function _map(fn, functor) {
    var idx = 0;
    var len2 = functor.length;
    var result = Array(len2);
    while (idx < len2) {
      result[idx] = fn(functor[idx]);
      idx += 1;
    }
    return result;
  }
  function _quote(s) {
    var escaped = s.replace(/\\/g, "\\\\").replace(/[\b]/g, "\\b").replace(/\f/g, "\\f").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t").replace(/\v/g, "\\v").replace(/\0/g, "\\0");
    return '"' + escaped.replace(/"/g, '\\"') + '"';
  }
  var pad = function pad2(n2) {
    return (n2 < 10 ? "0" : "") + n2;
  };
  var _toISOString = typeof Date.prototype.toISOString === "function" ? function _toISOString2(d) {
    return d.toISOString();
  } : function _toISOString2(d) {
    return d.getUTCFullYear() + "-" + pad(d.getUTCMonth() + 1) + "-" + pad(d.getUTCDate()) + "T" + pad(d.getUTCHours()) + ":" + pad(d.getUTCMinutes()) + ":" + pad(d.getUTCSeconds()) + "." + (d.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5) + "Z";
  };
  const _toISOString$1 = _toISOString;
  function _complement(f2) {
    return function() {
      return !f2.apply(this, arguments);
    };
  }
  function _arrayReduce(reducer2, acc, list2) {
    var index2 = 0;
    var length2 = list2.length;
    while (index2 < length2) {
      acc = reducer2(acc, list2[index2]);
      index2 += 1;
    }
    return acc;
  }
  function _filter(fn, list2) {
    var idx = 0;
    var len2 = list2.length;
    var result = [];
    while (idx < len2) {
      if (fn(list2[idx])) {
        result[result.length] = list2[idx];
      }
      idx += 1;
    }
    return result;
  }
  function _isObject(x2) {
    return Object.prototype.toString.call(x2) === "[object Object]";
  }
  var XFilter = /* @__PURE__ */ function() {
    function XFilter2(f2, xf) {
      this.xf = xf;
      this.f = f2;
    }
    XFilter2.prototype["@@transducer/init"] = _xfBase.init;
    XFilter2.prototype["@@transducer/result"] = _xfBase.result;
    XFilter2.prototype["@@transducer/step"] = function(result, input) {
      return this.f(input) ? this.xf["@@transducer/step"](result, input) : result;
    };
    return XFilter2;
  }();
  function _xfilter(f2) {
    return function(xf) {
      return new XFilter(f2, xf);
    };
  }
  var filter$5 = /* @__PURE__ */ _curry2(
    /* @__PURE__ */ _dispatchable(["fantasy-land/filter", "filter"], _xfilter, function(pred, filterable) {
      return _isObject(filterable) ? _arrayReduce(function(acc, key) {
        if (pred(filterable[key])) {
          acc[key] = filterable[key];
        }
        return acc;
      }, {}, keys$4(filterable)) : (
        // else
        _filter(pred, filterable)
      );
    })
  );
  const filter$6 = filter$5;
  var reject = /* @__PURE__ */ _curry2(function reject2(pred, filterable) {
    return filter$6(_complement(pred), filterable);
  });
  const reject$1 = reject;
  function _toString(x2, seen) {
    var recur = function recur2(y) {
      var xs = seen.concat([x2]);
      return _includes(y, xs) ? "<Circular>" : _toString(y, xs);
    };
    var mapPairs = function(obj, keys2) {
      return _map(function(k2) {
        return _quote(k2) + ": " + recur(obj[k2]);
      }, keys2.slice().sort());
    };
    switch (Object.prototype.toString.call(x2)) {
      case "[object Arguments]":
        return "(function() { return arguments; }(" + _map(recur, x2).join(", ") + "))";
      case "[object Array]":
        return "[" + _map(recur, x2).concat(mapPairs(x2, reject$1(function(k2) {
          return /^\d+$/.test(k2);
        }, keys$4(x2)))).join(", ") + "]";
      case "[object Boolean]":
        return typeof x2 === "object" ? "new Boolean(" + recur(x2.valueOf()) + ")" : x2.toString();
      case "[object Date]":
        return "new Date(" + (isNaN(x2.valueOf()) ? recur(NaN) : _quote(_toISOString$1(x2))) + ")";
      case "[object Map]":
        return "new Map(" + recur(Array.from(x2)) + ")";
      case "[object Null]":
        return "null";
      case "[object Number]":
        return typeof x2 === "object" ? "new Number(" + recur(x2.valueOf()) + ")" : 1 / x2 === -Infinity ? "-0" : x2.toString(10);
      case "[object Set]":
        return "new Set(" + recur(Array.from(x2).sort()) + ")";
      case "[object String]":
        return typeof x2 === "object" ? "new String(" + recur(x2.valueOf()) + ")" : _quote(x2);
      case "[object Undefined]":
        return "undefined";
      default:
        if (typeof x2.toString === "function") {
          var repr = x2.toString();
          if (repr !== "[object Object]") {
            return repr;
          }
        }
        return "{" + mapPairs(x2, keys$4(x2)).join(", ") + "}";
    }
  }
  var toString$8 = /* @__PURE__ */ _curry1(function toString2(val) {
    return _toString(val, []);
  });
  const toString$9 = toString$8;
  var max$2 = /* @__PURE__ */ _curry2(function max2(a, b) {
    if (a === b) {
      return b;
    }
    function safeMax(x2, y) {
      if (x2 > y !== y > x2) {
        return y > x2 ? y : x2;
      }
      return void 0;
    }
    var maxByValue = safeMax(a, b);
    if (maxByValue !== void 0) {
      return maxByValue;
    }
    var maxByType = safeMax(typeof a, typeof b);
    if (maxByType !== void 0) {
      return maxByType === typeof a ? a : b;
    }
    var stringA = toString$9(a);
    var maxByStringValue = safeMax(stringA, toString$9(b));
    if (maxByStringValue !== void 0) {
      return maxByStringValue === stringA ? a : b;
    }
    return b;
  });
  const max$3 = max$2;
  var XMap = /* @__PURE__ */ function() {
    function XMap2(f2, xf) {
      this.xf = xf;
      this.f = f2;
    }
    XMap2.prototype["@@transducer/init"] = _xfBase.init;
    XMap2.prototype["@@transducer/result"] = _xfBase.result;
    XMap2.prototype["@@transducer/step"] = function(result, input) {
      return this.xf["@@transducer/step"](result, this.f(input));
    };
    return XMap2;
  }();
  var _xmap = function _xmap2(f2) {
    return function(xf) {
      return new XMap(f2, xf);
    };
  };
  const _xmap$1 = _xmap;
  var map$3 = /* @__PURE__ */ _curry2(
    /* @__PURE__ */ _dispatchable(["fantasy-land/map", "map"], _xmap$1, function map2(fn, functor) {
      switch (Object.prototype.toString.call(functor)) {
        case "[object Function]":
          return curryN$1(functor.length, function() {
            return fn.call(this, functor.apply(this, arguments));
          });
        case "[object Object]":
          return _arrayReduce(function(acc, key) {
            acc[key] = fn(functor[key]);
            return acc;
          }, {}, keys$4(functor));
        default:
          return _map(fn, functor);
      }
    })
  );
  const map$4 = map$3;
  const _isInteger = Number.isInteger || function _isInteger2(n2) {
    return n2 << 0 === n2;
  };
  function _isString(x2) {
    return Object.prototype.toString.call(x2) === "[object String]";
  }
  var nth = /* @__PURE__ */ _curry2(function nth2(offset, list2) {
    var idx = offset < 0 ? list2.length + offset : offset;
    return _isString(list2) ? list2.charAt(idx) : list2[idx];
  });
  const nth$1 = nth;
  var prop = /* @__PURE__ */ _curry2(function prop2(p2, obj) {
    if (obj == null) {
      return;
    }
    return _isInteger(p2) ? nth$1(p2, obj) : obj[p2];
  });
  const prop$1 = prop;
  var pluck$1 = /* @__PURE__ */ _curry2(function pluck2(p2, list2) {
    return map$4(prop$1(p2), list2);
  });
  const pluck$2 = pluck$1;
  var _isArrayLike = /* @__PURE__ */ _curry1(function isArrayLike2(x2) {
    if (_isArray(x2)) {
      return true;
    }
    if (!x2) {
      return false;
    }
    if (typeof x2 !== "object") {
      return false;
    }
    if (_isString(x2)) {
      return false;
    }
    if (x2.length === 0) {
      return true;
    }
    if (x2.length > 0) {
      return x2.hasOwnProperty(0) && x2.hasOwnProperty(x2.length - 1);
    }
    return false;
  });
  const _isArrayLike$1 = _isArrayLike;
  var symIterator = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
  function _createReduce(arrayReduce, methodReduce, iterableReduce) {
    return function _reduce2(xf, acc, list2) {
      if (_isArrayLike$1(list2)) {
        return arrayReduce(xf, acc, list2);
      }
      if (list2 == null) {
        return acc;
      }
      if (typeof list2["fantasy-land/reduce"] === "function") {
        return methodReduce(xf, acc, list2, "fantasy-land/reduce");
      }
      if (list2[symIterator] != null) {
        return iterableReduce(xf, acc, list2[symIterator]());
      }
      if (typeof list2.next === "function") {
        return iterableReduce(xf, acc, list2);
      }
      if (typeof list2.reduce === "function") {
        return methodReduce(xf, acc, list2, "reduce");
      }
      throw new TypeError("reduce: list must be array or iterable");
    };
  }
  function _xArrayReduce(xf, acc, list2) {
    var idx = 0;
    var len2 = list2.length;
    while (idx < len2) {
      acc = xf["@@transducer/step"](acc, list2[idx]);
      if (acc && acc["@@transducer/reduced"]) {
        acc = acc["@@transducer/value"];
        break;
      }
      idx += 1;
    }
    return xf["@@transducer/result"](acc);
  }
  var bind$3 = /* @__PURE__ */ _curry2(function bind2(fn, thisObj) {
    return _arity(fn.length, function() {
      return fn.apply(thisObj, arguments);
    });
  });
  const bind$4 = bind$3;
  function _xIterableReduce(xf, acc, iter) {
    var step = iter.next();
    while (!step.done) {
      acc = xf["@@transducer/step"](acc, step.value);
      if (acc && acc["@@transducer/reduced"]) {
        acc = acc["@@transducer/value"];
        break;
      }
      step = iter.next();
    }
    return xf["@@transducer/result"](acc);
  }
  function _xMethodReduce(xf, acc, obj, methodName) {
    return xf["@@transducer/result"](obj[methodName](bind$4(xf["@@transducer/step"], xf), acc));
  }
  var _xReduce = /* @__PURE__ */ _createReduce(_xArrayReduce, _xMethodReduce, _xIterableReduce);
  const _xReduce$1 = _xReduce;
  var XWrap = /* @__PURE__ */ function() {
    function XWrap2(fn) {
      this.f = fn;
    }
    XWrap2.prototype["@@transducer/init"] = function() {
      throw new Error("init not implemented on XWrap");
    };
    XWrap2.prototype["@@transducer/result"] = function(acc) {
      return acc;
    };
    XWrap2.prototype["@@transducer/step"] = function(acc, x2) {
      return this.f(acc, x2);
    };
    return XWrap2;
  }();
  function _xwrap(fn) {
    return new XWrap(fn);
  }
  var reduce$1 = /* @__PURE__ */ _curry3(function(xf, acc, list2) {
    return _xReduce$1(typeof xf === "function" ? _xwrap(xf) : xf, acc, list2);
  });
  const reduce$2 = reduce$1;
  var allPass = /* @__PURE__ */ _curry1(function allPass2(preds) {
    return curryN$1(reduce$2(max$3, 0, pluck$2("length", preds)), function() {
      var idx = 0;
      var len2 = preds.length;
      while (idx < len2) {
        if (!preds[idx].apply(this, arguments)) {
          return false;
        }
        idx += 1;
      }
      return true;
    });
  });
  const allPass$1 = allPass;
  var always = /* @__PURE__ */ _curry1(function always2(val) {
    return function() {
      return val;
    };
  });
  const always$1 = always;
  var and = /* @__PURE__ */ _curry2(function and2(a, b) {
    return a && b;
  });
  const and$1 = and;
  var anyPass = /* @__PURE__ */ _curry1(function anyPass2(preds) {
    return curryN$1(reduce$2(max$3, 0, pluck$2("length", preds)), function() {
      var idx = 0;
      var len2 = preds.length;
      while (idx < len2) {
        if (preds[idx].apply(this, arguments)) {
          return true;
        }
        idx += 1;
      }
      return false;
    });
  });
  const anyPass$1 = anyPass;
  function _iterableReduce(reducer2, acc, iter) {
    var step = iter.next();
    while (!step.done) {
      acc = reducer2(acc, step.value);
      step = iter.next();
    }
    return acc;
  }
  function _methodReduce(reducer2, acc, obj, methodName) {
    return obj[methodName](reducer2, acc);
  }
  var _reduce = /* @__PURE__ */ _createReduce(_arrayReduce, _methodReduce, _iterableReduce);
  const _reduce$1 = _reduce;
  var ap = /* @__PURE__ */ _curry2(function ap2(applyF, applyX) {
    return typeof applyX["fantasy-land/ap"] === "function" ? applyX["fantasy-land/ap"](applyF) : typeof applyF.ap === "function" ? applyF.ap(applyX) : typeof applyF === "function" ? function(x2) {
      return applyF(x2)(applyX(x2));
    } : _reduce$1(function(acc, f2) {
      return _concat(acc, map$4(f2, applyX));
    }, [], applyF);
  });
  const ap$1 = ap;
  var apply$4 = /* @__PURE__ */ _curry2(function apply2(fn, args) {
    return fn.apply(this, args);
  });
  const apply$5 = apply$4;
  var values = /* @__PURE__ */ _curry1(function values2(obj) {
    var props = keys$4(obj);
    var len2 = props.length;
    var vals = [];
    var idx = 0;
    while (idx < len2) {
      vals[idx] = obj[props[idx]];
      idx += 1;
    }
    return vals;
  });
  const values$1 = values;
  function _assoc(prop2, val, obj) {
    if (_isInteger(prop2) && _isArray(obj)) {
      var arr = [].concat(obj);
      arr[prop2] = val;
      return arr;
    }
    var result = {};
    for (var p2 in obj) {
      result[p2] = obj[p2];
    }
    result[prop2] = val;
    return result;
  }
  var isNil = /* @__PURE__ */ _curry1(function isNil2(x2) {
    return x2 == null;
  });
  const isNil$1 = isNil;
  var assocPath = /* @__PURE__ */ _curry3(function assocPath2(path2, val, obj) {
    if (path2.length === 0) {
      return val;
    }
    var idx = path2[0];
    if (path2.length > 1) {
      var nextObj = !isNil$1(obj) && _has(idx, obj) && typeof obj[idx] === "object" ? obj[idx] : _isInteger(path2[1]) ? [] : {};
      val = assocPath2(Array.prototype.slice.call(path2, 1), val, nextObj);
    }
    return _assoc(idx, val, obj);
  });
  const assocPath$1 = assocPath;
  function _isFunction(x2) {
    var type2 = Object.prototype.toString.call(x2);
    return type2 === "[object Function]" || type2 === "[object AsyncFunction]" || type2 === "[object GeneratorFunction]" || type2 === "[object AsyncGeneratorFunction]";
  }
  var liftN = /* @__PURE__ */ _curry2(function liftN2(arity, fn) {
    var lifted = curryN$1(arity, fn);
    return curryN$1(arity, function() {
      return _arrayReduce(ap$1, map$4(lifted, arguments[0]), Array.prototype.slice.call(arguments, 1));
    });
  });
  const liftN$1 = liftN;
  var lift = /* @__PURE__ */ _curry1(function lift2(fn) {
    return liftN$1(fn.length, fn);
  });
  const lift$1 = lift;
  var both = /* @__PURE__ */ _curry2(function both2(f2, g) {
    return _isFunction(f2) ? function _both() {
      return f2.apply(this, arguments) && g.apply(this, arguments);
    } : lift$1(and$1)(f2, g);
  });
  const both$1 = both;
  function _cloneRegExp(pattern) {
    return new RegExp(pattern.source, pattern.flags ? pattern.flags : (pattern.global ? "g" : "") + (pattern.ignoreCase ? "i" : "") + (pattern.multiline ? "m" : "") + (pattern.sticky ? "y" : "") + (pattern.unicode ? "u" : "") + (pattern.dotAll ? "s" : ""));
  }
  function _clone(value2, deep, map2) {
    map2 || (map2 = new _ObjectMap());
    if (_isPrimitive(value2)) {
      return value2;
    }
    var copy2 = function copy3(copiedValue) {
      var cachedCopy = map2.get(value2);
      if (cachedCopy) {
        return cachedCopy;
      }
      map2.set(value2, copiedValue);
      for (var key in value2) {
        if (Object.prototype.hasOwnProperty.call(value2, key)) {
          copiedValue[key] = deep ? _clone(value2[key], true, map2) : value2[key];
        }
      }
      return copiedValue;
    };
    switch (type$1(value2)) {
      case "Object":
        return copy2(Object.create(Object.getPrototypeOf(value2)));
      case "Array":
        return copy2([]);
      case "Date":
        return new Date(value2.valueOf());
      case "RegExp":
        return _cloneRegExp(value2);
      case "Int8Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
      case "Int16Array":
      case "Uint16Array":
      case "Int32Array":
      case "Uint32Array":
      case "Float32Array":
      case "Float64Array":
      case "BigInt64Array":
      case "BigUint64Array":
        return value2.slice();
      default:
        return value2;
    }
  }
  function _isPrimitive(param) {
    var type2 = typeof param;
    return param == null || type2 != "object" && type2 != "function";
  }
  var _ObjectMap = /* @__PURE__ */ function() {
    function _ObjectMap2() {
      this.map = {};
      this.length = 0;
    }
    _ObjectMap2.prototype.set = function(key, value2) {
      const hashedKey = this.hash(key);
      let bucket = this.map[hashedKey];
      if (!bucket) {
        this.map[hashedKey] = bucket = [];
      }
      bucket.push([key, value2]);
      this.length += 1;
    };
    _ObjectMap2.prototype.hash = function(key) {
      let hashedKey = [];
      for (var value2 in key) {
        hashedKey.push(Object.prototype.toString.call(key[value2]));
      }
      return hashedKey.join();
    };
    _ObjectMap2.prototype.get = function(key) {
      if (this.length <= 180) {
        for (const p2 in this.map) {
          const bucket2 = this.map[p2];
          for (let i2 = 0; i2 < bucket2.length; i2 += 1) {
            const element = bucket2[i2];
            if (element[0] === key) {
              return element[1];
            }
          }
        }
        return;
      }
      const hashedKey = this.hash(key);
      const bucket = this.map[hashedKey];
      if (!bucket) {
        return;
      }
      for (let i2 = 0; i2 < bucket.length; i2 += 1) {
        const element = bucket[i2];
        if (element[0] === key) {
          return element[1];
        }
      }
    };
    return _ObjectMap2;
  }();
  var comparator = /* @__PURE__ */ _curry1(function comparator2(pred) {
    return function(a, b) {
      return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
    };
  });
  const comparator$1 = comparator;
  var not$1 = /* @__PURE__ */ _curry1(function not2(a) {
    return !a;
  });
  const not$2 = not$1;
  var complement = /* @__PURE__ */ lift$1(not$2);
  const complement$1 = complement;
  function _pipe(f2, g) {
    return function() {
      return g.call(this, f2.apply(this, arguments));
    };
  }
  function _checkForMethod(methodname, fn) {
    return function() {
      var length2 = arguments.length;
      if (length2 === 0) {
        return fn();
      }
      var obj = arguments[length2 - 1];
      return _isArray(obj) || typeof obj[methodname] !== "function" ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length2 - 1));
    };
  }
  var slice = /* @__PURE__ */ _curry3(
    /* @__PURE__ */ _checkForMethod("slice", function slice2(fromIndex, toIndex, list2) {
      return Array.prototype.slice.call(list2, fromIndex, toIndex);
    })
  );
  const slice$1 = slice;
  var tail = /* @__PURE__ */ _curry1(
    /* @__PURE__ */ _checkForMethod(
      "tail",
      /* @__PURE__ */ slice$1(1, Infinity)
    )
  );
  const tail$1 = tail;
  function pipe$2() {
    if (arguments.length === 0) {
      throw new Error("pipe requires at least one argument");
    }
    return _arity(arguments[0].length, reduce$2(_pipe, arguments[0], tail$1(arguments)));
  }
  var head = /* @__PURE__ */ nth$1(0);
  const head$1 = head;
  function _identity(x2) {
    return x2;
  }
  var identity$1 = /* @__PURE__ */ _curry1(_identity);
  const identity$2 = identity$1;
  var curry = /* @__PURE__ */ _curry1(function curry2(fn) {
    return curryN$1(fn.length, fn);
  });
  const curry$1 = curry;
  var converge = /* @__PURE__ */ _curry2(function converge2(after, fns) {
    return curryN$1(reduce$2(max$3, 0, pluck$2("length", fns)), function() {
      var args = arguments;
      var context2 = this;
      return after.apply(context2, _map(function(fn) {
        return fn.apply(context2, args);
      }, fns));
    });
  });
  const converge$1 = converge;
  var XReduceBy = /* @__PURE__ */ function() {
    function XReduceBy2(valueFn, valueAcc, keyFn, xf) {
      this.valueFn = valueFn;
      this.valueAcc = valueAcc;
      this.keyFn = keyFn;
      this.xf = xf;
      this.inputs = {};
    }
    XReduceBy2.prototype["@@transducer/init"] = _xfBase.init;
    XReduceBy2.prototype["@@transducer/result"] = function(result) {
      var key;
      for (key in this.inputs) {
        if (_has(key, this.inputs)) {
          result = this.xf["@@transducer/step"](result, this.inputs[key]);
          if (result["@@transducer/reduced"]) {
            result = result["@@transducer/value"];
            break;
          }
        }
      }
      this.inputs = null;
      return this.xf["@@transducer/result"](result);
    };
    XReduceBy2.prototype["@@transducer/step"] = function(result, input) {
      var key = this.keyFn(input);
      this.inputs[key] = this.inputs[key] || [key, _clone(this.valueAcc, false)];
      this.inputs[key][1] = this.valueFn(this.inputs[key][1], input);
      return result;
    };
    return XReduceBy2;
  }();
  function _xreduceBy(valueFn, valueAcc, keyFn) {
    return function(xf) {
      return new XReduceBy(valueFn, valueAcc, keyFn, xf);
    };
  }
  var reduceBy = /* @__PURE__ */ _curryN(
    4,
    [],
    /* @__PURE__ */ _dispatchable([], _xreduceBy, function reduceBy2(valueFn, valueAcc, keyFn, list2) {
      var xf = _xwrap(function(acc, elt) {
        var key = keyFn(elt);
        var value2 = valueFn(_has(key, acc) ? acc[key] : _clone(valueAcc, false), elt);
        if (value2 && value2["@@transducer/reduced"]) {
          return _reduced(acc);
        }
        acc[key] = value2;
        return acc;
      });
      return _xReduce$1(xf, {}, list2);
    })
  );
  const reduceBy$1 = reduceBy;
  var defaultTo = /* @__PURE__ */ _curry2(function defaultTo2(d, v) {
    return v == null || v !== v ? d : v;
  });
  const defaultTo$1 = defaultTo;
  var _Set$1 = /* @__PURE__ */ function() {
    function _Set2() {
      this._nativeSet = typeof Set === "function" ? /* @__PURE__ */ new Set() : null;
      this._items = {};
    }
    _Set2.prototype.add = function(item) {
      return !hasOrAdd(item, true, this);
    };
    _Set2.prototype.has = function(item) {
      return hasOrAdd(item, false, this);
    };
    return _Set2;
  }();
  function hasOrAdd(item, shouldAdd, set2) {
    var type2 = typeof item;
    var prevSize, newSize;
    switch (type2) {
      case "string":
      case "number":
        if (item === 0 && 1 / item === -Infinity) {
          if (set2._items["-0"]) {
            return true;
          } else {
            if (shouldAdd) {
              set2._items["-0"] = true;
            }
            return false;
          }
        }
        if (set2._nativeSet !== null) {
          if (shouldAdd) {
            prevSize = set2._nativeSet.size;
            set2._nativeSet.add(item);
            newSize = set2._nativeSet.size;
            return newSize === prevSize;
          } else {
            return set2._nativeSet.has(item);
          }
        } else {
          if (!(type2 in set2._items)) {
            if (shouldAdd) {
              set2._items[type2] = {};
              set2._items[type2][item] = true;
            }
            return false;
          } else if (item in set2._items[type2]) {
            return true;
          } else {
            if (shouldAdd) {
              set2._items[type2][item] = true;
            }
            return false;
          }
        }
      case "boolean":
        if (type2 in set2._items) {
          var bIdx = item ? 1 : 0;
          if (set2._items[type2][bIdx]) {
            return true;
          } else {
            if (shouldAdd) {
              set2._items[type2][bIdx] = true;
            }
            return false;
          }
        } else {
          if (shouldAdd) {
            set2._items[type2] = item ? [false, true] : [true, false];
          }
          return false;
        }
      case "function":
        if (set2._nativeSet !== null) {
          if (shouldAdd) {
            prevSize = set2._nativeSet.size;
            set2._nativeSet.add(item);
            newSize = set2._nativeSet.size;
            return newSize === prevSize;
          } else {
            return set2._nativeSet.has(item);
          }
        } else {
          if (!(type2 in set2._items)) {
            if (shouldAdd) {
              set2._items[type2] = [item];
            }
            return false;
          }
          if (!_includes(item, set2._items[type2])) {
            if (shouldAdd) {
              set2._items[type2].push(item);
            }
            return false;
          }
          return true;
        }
      case "undefined":
        if (set2._items[type2]) {
          return true;
        } else {
          if (shouldAdd) {
            set2._items[type2] = true;
          }
          return false;
        }
      case "object":
        if (item === null) {
          if (!set2._items["null"]) {
            if (shouldAdd) {
              set2._items["null"] = true;
            }
            return false;
          }
          return true;
        }
      default:
        type2 = Object.prototype.toString.call(item);
        if (!(type2 in set2._items)) {
          if (shouldAdd) {
            set2._items[type2] = [item];
          }
          return false;
        }
        if (!_includes(item, set2._items[type2])) {
          if (shouldAdd) {
            set2._items[type2].push(item);
          }
          return false;
        }
        return true;
    }
  }
  const _Set$2 = _Set$1;
  var difference = /* @__PURE__ */ _curry2(function difference2(first2, second) {
    var out = [];
    var idx = 0;
    var firstLen = first2.length;
    var secondLen = second.length;
    var toFilterOut = new _Set$2();
    for (var i2 = 0; i2 < secondLen; i2 += 1) {
      toFilterOut.add(second[i2]);
    }
    while (idx < firstLen) {
      if (toFilterOut.add(first2[idx])) {
        out[out.length] = first2[idx];
      }
      idx += 1;
    }
    return out;
  });
  const difference$1 = difference;
  var XTake = /* @__PURE__ */ function() {
    function XTake2(n2, xf) {
      this.xf = xf;
      this.n = n2;
      this.i = 0;
    }
    XTake2.prototype["@@transducer/init"] = _xfBase.init;
    XTake2.prototype["@@transducer/result"] = _xfBase.result;
    XTake2.prototype["@@transducer/step"] = function(result, input) {
      this.i += 1;
      var ret = this.n === 0 ? result : this.xf["@@transducer/step"](result, input);
      return this.n >= 0 && this.i >= this.n ? _reduced(ret) : ret;
    };
    return XTake2;
  }();
  function _xtake(n2) {
    return function(xf) {
      return new XTake(n2, xf);
    };
  }
  var take$1 = /* @__PURE__ */ _curry2(
    /* @__PURE__ */ _dispatchable(["take"], _xtake, function take2(n2, xs) {
      return slice$1(0, n2 < 0 ? Infinity : n2, xs);
    })
  );
  const take$2 = take$1;
  function dropLastWhile$2(pred, xs) {
    var idx = xs.length - 1;
    while (idx >= 0 && pred(xs[idx])) {
      idx -= 1;
    }
    return slice$1(0, idx + 1, xs);
  }
  var XDropLastWhile = /* @__PURE__ */ function() {
    function XDropLastWhile2(fn, xf) {
      this.f = fn;
      this.retained = [];
      this.xf = xf;
    }
    XDropLastWhile2.prototype["@@transducer/init"] = _xfBase.init;
    XDropLastWhile2.prototype["@@transducer/result"] = function(result) {
      this.retained = null;
      return this.xf["@@transducer/result"](result);
    };
    XDropLastWhile2.prototype["@@transducer/step"] = function(result, input) {
      return this.f(input) ? this.retain(result, input) : this.flush(result, input);
    };
    XDropLastWhile2.prototype.flush = function(result, input) {
      result = _xReduce$1(this.xf, result, this.retained);
      this.retained = [];
      return this.xf["@@transducer/step"](result, input);
    };
    XDropLastWhile2.prototype.retain = function(result, input) {
      this.retained.push(input);
      return result;
    };
    return XDropLastWhile2;
  }();
  function _xdropLastWhile(fn) {
    return function(xf) {
      return new XDropLastWhile(fn, xf);
    };
  }
  var dropLastWhile = /* @__PURE__ */ _curry2(
    /* @__PURE__ */ _dispatchable([], _xdropLastWhile, dropLastWhile$2)
  );
  const dropLastWhile$1 = dropLastWhile;
  var last$1 = /* @__PURE__ */ nth$1(-1);
  const last$2 = last$1;
  var XDropWhile = /* @__PURE__ */ function() {
    function XDropWhile2(f2, xf) {
      this.xf = xf;
      this.f = f2;
    }
    XDropWhile2.prototype["@@transducer/init"] = _xfBase.init;
    XDropWhile2.prototype["@@transducer/result"] = _xfBase.result;
    XDropWhile2.prototype["@@transducer/step"] = function(result, input) {
      if (this.f) {
        if (this.f(input)) {
          return result;
        }
        this.f = null;
      }
      return this.xf["@@transducer/step"](result, input);
    };
    return XDropWhile2;
  }();
  function _xdropWhile(f2) {
    return function(xf) {
      return new XDropWhile(f2, xf);
    };
  }
  var dropWhile = /* @__PURE__ */ _curry2(
    /* @__PURE__ */ _dispatchable(["dropWhile"], _xdropWhile, function dropWhile2(pred, xs) {
      var idx = 0;
      var len2 = xs.length;
      while (idx < len2 && pred(xs[idx])) {
        idx += 1;
      }
      return slice$1(idx, Infinity, xs);
    })
  );
  const dropWhile$1 = dropWhile;
  var or = /* @__PURE__ */ _curry2(function or2(a, b) {
    return a || b;
  });
  const or$1 = or;
  var either = /* @__PURE__ */ _curry2(function either2(f2, g) {
    return _isFunction(f2) ? function _either() {
      return f2.apply(this, arguments) || g.apply(this, arguments);
    } : lift$1(or$1)(f2, g);
  });
  const either$1 = either;
  function _isTypedArray(val) {
    var type2 = Object.prototype.toString.call(val);
    return type2 === "[object Uint8ClampedArray]" || type2 === "[object Int8Array]" || type2 === "[object Uint8Array]" || type2 === "[object Int16Array]" || type2 === "[object Uint16Array]" || type2 === "[object Int32Array]" || type2 === "[object Uint32Array]" || type2 === "[object Float32Array]" || type2 === "[object Float64Array]" || type2 === "[object BigInt64Array]" || type2 === "[object BigUint64Array]";
  }
  var empty$3 = /* @__PURE__ */ _curry1(function empty2(x2) {
    return x2 != null && typeof x2["fantasy-land/empty"] === "function" ? x2["fantasy-land/empty"]() : x2 != null && x2.constructor != null && typeof x2.constructor["fantasy-land/empty"] === "function" ? x2.constructor["fantasy-land/empty"]() : x2 != null && typeof x2.empty === "function" ? x2.empty() : x2 != null && x2.constructor != null && typeof x2.constructor.empty === "function" ? x2.constructor.empty() : _isArray(x2) ? [] : _isString(x2) ? "" : _isObject(x2) ? {} : _isArguments$1(x2) ? function() {
      return arguments;
    }() : _isTypedArray(x2) ? x2.constructor.from("") : void 0;
  });
  const emptyR = empty$3;
  var flip = /* @__PURE__ */ _curry1(function flip2(fn) {
    return curryN$1(fn.length, function(a, b) {
      var args = Array.prototype.slice.call(arguments, 0);
      args[0] = b;
      args[1] = a;
      return fn.apply(this, args);
    });
  });
  const flip$1 = flip;
  var groupBy$1 = /* @__PURE__ */ _curry2(
    /* @__PURE__ */ _checkForMethod(
      "groupBy",
      /* @__PURE__ */ reduceBy$1(function(acc, item) {
        acc.push(item);
        return acc;
      }, [])
    )
  );
  const groupBy$2 = groupBy$1;
  var hasPath = /* @__PURE__ */ _curry2(function hasPath2(_path, obj) {
    if (_path.length === 0 || isNil$1(obj)) {
      return false;
    }
    var val = obj;
    var idx = 0;
    while (idx < _path.length) {
      if (!isNil$1(val) && _has(_path[idx], val)) {
        val = val[_path[idx]];
        idx += 1;
      } else {
        return false;
      }
    }
    return true;
  });
  const hasPath$1 = hasPath;
  var has$1 = /* @__PURE__ */ _curry2(function has2(prop2, obj) {
    return hasPath$1([prop2], obj);
  });
  const has$2 = has$1;
  var hasIn = /* @__PURE__ */ _curry2(function hasIn2(prop2, obj) {
    if (isNil$1(obj)) {
      return false;
    }
    return prop2 in obj;
  });
  const hasIn$1 = hasIn;
  var identical = function(a, b) {
    switch (arguments.length) {
      case 0:
        return identical;
      case 1:
        return function() {
          return function unaryIdentical(_b) {
            switch (arguments.length) {
              case 0:
                return unaryIdentical;
              default:
                return _objectIs$1(a, _b);
            }
          };
        }();
      default:
        return _objectIs$1(a, b);
    }
  };
  const identical$1 = identical;
  var ifElse = /* @__PURE__ */ _curry3(function ifElse2(condition, onTrue, onFalse) {
    return curryN$1(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
      return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
    });
  });
  const ifElse$1 = ifElse;
  var includes = /* @__PURE__ */ _curry2(_includes);
  const includes$1 = includes;
  var init = /* @__PURE__ */ slice$1(0, -1);
  const init$1 = init;
  var invoker = /* @__PURE__ */ _curry2(function invoker2(arity, method) {
    return curryN$1(arity + 1, function() {
      var target = arguments[arity];
      if (target != null && _isFunction(target[method])) {
        return target[method].apply(target, Array.prototype.slice.call(arguments, 0, arity));
      }
      throw new TypeError(toString$9(target) + ' does not have a method named "' + method + '"');
    });
  });
  const invoker$1 = invoker;
  var isEmpty$1 = /* @__PURE__ */ _curry1(function isEmpty2(x2) {
    return x2 != null && equals$1(x2, emptyR(x2));
  });
  const isEmpty$2 = isEmpty$1;
  var join = /* @__PURE__ */ invoker$1(1, "join");
  const join$1 = join;
  function _isNumber(x2) {
    return Object.prototype.toString.call(x2) === "[object Number]";
  }
  var lens = /* @__PURE__ */ _curry2(function lens2(getter, setter) {
    return function(toFunctorFn) {
      return function(target) {
        return map$4(function(focus) {
          return setter(focus, target);
        }, toFunctorFn(getter(target)));
      };
    };
  });
  const lens$1 = lens;
  var paths = /* @__PURE__ */ _curry2(function paths2(pathsArray, obj) {
    return pathsArray.map(function(paths3) {
      var val = obj;
      var idx = 0;
      var p2;
      while (idx < paths3.length) {
        if (val == null) {
          return;
        }
        p2 = paths3[idx];
        val = _isInteger(p2) ? nth$1(p2, val) : val[p2];
        idx += 1;
      }
      return val;
    });
  });
  const paths$1 = paths;
  var path$5 = /* @__PURE__ */ _curry2(function path2(pathAr, obj) {
    return paths$1([pathAr], obj)[0];
  });
  const path$6 = path$5;
  var mapObjIndexed = /* @__PURE__ */ _curry2(function mapObjIndexed2(fn, obj) {
    return _arrayReduce(function(acc, key) {
      acc[key] = fn(obj[key], key, obj);
      return acc;
    }, {}, keys$4(obj));
  });
  const mapObjIndexed$1 = mapObjIndexed;
  var mergeWithKey = /* @__PURE__ */ _curry3(function mergeWithKey2(fn, l2, r) {
    var result = {};
    var k2;
    l2 = l2 || {};
    r = r || {};
    for (k2 in l2) {
      if (_has(k2, l2)) {
        result[k2] = _has(k2, r) ? fn(k2, l2[k2], r[k2]) : l2[k2];
      }
    }
    for (k2 in r) {
      if (_has(k2, r) && !_has(k2, result)) {
        result[k2] = r[k2];
      }
    }
    return result;
  });
  const mergeWithKey$1 = mergeWithKey;
  var mergeDeepWithKey = /* @__PURE__ */ _curry3(function mergeDeepWithKey2(fn, lObj, rObj) {
    return mergeWithKey$1(function(k2, lVal, rVal) {
      if (_isObject(lVal) && _isObject(rVal)) {
        return mergeDeepWithKey2(fn, lVal, rVal);
      } else {
        return fn(k2, lVal, rVal);
      }
    }, lObj, rObj);
  });
  const mergeDeepWithKey$1 = mergeDeepWithKey;
  var mergeDeepRight = /* @__PURE__ */ _curry2(function mergeDeepRight2(lObj, rObj) {
    return mergeDeepWithKey$1(function(k2, lVal, rVal) {
      return rVal;
    }, lObj, rObj);
  });
  const mergeDeepRight$1 = mergeDeepRight;
  var none = /* @__PURE__ */ _curry2(function none2(fn, input) {
    return all$1(_complement(fn), input);
  });
  const none$1 = none;
  var omit$1 = /* @__PURE__ */ _curry2(function omit2(names, obj) {
    var result = {};
    var index2 = {};
    var idx = 0;
    var len2 = names.length;
    while (idx < len2) {
      index2[names[idx]] = 1;
      idx += 1;
    }
    for (var prop2 in obj) {
      if (!index2.hasOwnProperty(prop2)) {
        result[prop2] = obj[prop2];
      }
    }
    return result;
  });
  const omit$2 = omit$1;
  var Identity = function(x2) {
    return {
      value: x2,
      map: function(f2) {
        return Identity(f2(x2));
      }
    };
  };
  var over = /* @__PURE__ */ _curry3(function over2(lens2, f2, x2) {
    return lens2(function(y) {
      return Identity(f2(y));
    })(x2).value;
  });
  const over$1 = over;
  var pathOr = /* @__PURE__ */ _curry3(function pathOr2(d, p2, obj) {
    return defaultTo$1(d, path$6(p2, obj));
  });
  const pathOr$1 = pathOr;
  var pathSatisfies = /* @__PURE__ */ _curry3(function pathSatisfies2(pred, propPath, obj) {
    return pred(path$6(propPath, obj));
  });
  const pathSatisfies$1 = pathSatisfies;
  var pick$1 = /* @__PURE__ */ _curry2(function pick2(names, obj) {
    var result = {};
    var idx = 0;
    while (idx < names.length) {
      if (names[idx] in obj) {
        result[names[idx]] = obj[names[idx]];
      }
      idx += 1;
    }
    return result;
  });
  const pick$2 = pick$1;
  var propEq = /* @__PURE__ */ _curry3(function propEq2(val, name, obj) {
    return equals$1(val, prop$1(name, obj));
  });
  const propEq$1 = propEq;
  var propOr = /* @__PURE__ */ _curry3(function propOr2(val, p2, obj) {
    return defaultTo$1(val, prop$1(p2, obj));
  });
  const propOr$1 = propOr;
  var propSatisfies = /* @__PURE__ */ _curry3(function propSatisfies2(pred, name, obj) {
    return pred(prop$1(name, obj));
  });
  const propSatisfies$1 = propSatisfies;
  var range$1 = /* @__PURE__ */ _curry2(function range2(from2, to) {
    if (!(_isNumber(from2) && _isNumber(to))) {
      throw new TypeError("Both arguments to range must be numbers");
    }
    var result = [];
    var n2 = from2;
    while (n2 < to) {
      result.push(n2);
      n2 += 1;
    }
    return result;
  });
  const range$2 = range$1;
  var reduced = /* @__PURE__ */ _curry1(_reduced);
  const reduced$1 = reduced;
  var replace$1 = /* @__PURE__ */ _curry3(function replace2(regex, replacement2, str2) {
    return str2.replace(regex, replacement2);
  });
  const replace$2 = replace$1;
  var sort = /* @__PURE__ */ _curry2(function sort2(comparator2, list2) {
    return Array.prototype.slice.call(list2, 0).sort(comparator2);
  });
  const sort$1 = sort;
  var split$3 = /* @__PURE__ */ invoker$1(1, "split");
  const split$4 = split$3;
  var startsWith = /* @__PURE__ */ _curry2(function(prefix, list2) {
    return equals$1(take$2(prefix.length, list2), prefix);
  });
  const startsWith$1 = startsWith;
  function _isRegExp(x2) {
    return Object.prototype.toString.call(x2) === "[object RegExp]";
  }
  var test$1 = /* @__PURE__ */ _curry2(function test2(pattern, str2) {
    if (!_isRegExp(pattern)) {
      throw new TypeError("test requires a value of type RegExp as its first argument; received " + toString$9(pattern));
    }
    return _cloneRegExp(pattern).test(str2);
  });
  const test$2 = test$1;
  var XUniqWith = /* @__PURE__ */ function() {
    function XUniqWith2(pred, xf) {
      this.xf = xf;
      this.pred = pred;
      this.items = [];
    }
    XUniqWith2.prototype["@@transducer/init"] = _xfBase.init;
    XUniqWith2.prototype["@@transducer/result"] = _xfBase.result;
    XUniqWith2.prototype["@@transducer/step"] = function(result, input) {
      if (_includesWith(this.pred, input, this.items)) {
        return result;
      } else {
        this.items.push(input);
        return this.xf["@@transducer/step"](result, input);
      }
    };
    return XUniqWith2;
  }();
  function _xuniqWith(pred) {
    return function(xf) {
      return new XUniqWith(pred, xf);
    };
  }
  var uniqWith = /* @__PURE__ */ _curry2(
    /* @__PURE__ */ _dispatchable([], _xuniqWith, function(pred, list2) {
      var idx = 0;
      var len2 = list2.length;
      var result = [];
      var item;
      while (idx < len2) {
        item = list2[idx];
        if (!_includesWith(pred, item, result)) {
          result[result.length] = item;
        }
        idx += 1;
      }
      return result;
    })
  );
  const uniqWith$1 = uniqWith;
  var when = /* @__PURE__ */ _curry3(function when2(pred, whenTrueFn, x2) {
    return pred(x2) ? whenTrueFn(x2) : x2;
  });
  const when$1 = when;
  var stubUndefined = always$1(void 0);
  const stubUndefined$1 = stubUndefined;
  var isUndefined = equals$1(stubUndefined$1());
  const isUndefined$1 = isUndefined;
  var isNotUndefined = complement$1(isUndefined$1);
  const isNotUndefined$1 = isNotUndefined;
  var isNull$2 = equals$1(null);
  const isNull$3 = isNull$2;
  var isNotNull = complement$1(isNull$3);
  const isNotNull$1 = isNotNull;
  var isNotNil = complement$1(isNil$1);
  const isNotNil$1 = isNotNil;
  var isGeneratorFunction = curryN$1(1, pipe$2(type$1, identical$1("GeneratorFunction")));
  const isGeneratorFunction$1 = isGeneratorFunction;
  var isAsyncFunction = curryN$1(1, pipe$2(type$1, identical$1("AsyncFunction")));
  const isAsyncFunction$1 = isAsyncFunction;
  var isFunction$6 = anyPass$1([pipe$2(type$1, identical$1("Function")), isGeneratorFunction$1, isAsyncFunction$1]);
  const isFunction$7 = isFunction$6;
  var isArray$7 = curryN$1(1, isFunction$7(Array.isArray) ? Array.isArray : pipe$2(type$1, identical$1("Array")));
  const isArray$8 = isArray$7;
  var isEmptyArray = both$1(isArray$8, isEmpty$2);
  const isEmptyArray$1 = isEmptyArray;
  var isNotEmpty = complement$1(isEmpty$2);
  const isNotEmpty$1 = isNotEmpty;
  var isNonEmptyArray = both$1(isArray$8, isNotEmpty$1);
  const isNonEmptyArray$1 = isNonEmptyArray;
  var isString$3 = curryN$1(1, pipe$2(type$1, identical$1("String")));
  const isString$4 = isString$3;
  var isEmptyString = equals$1("");
  const isEmptyString$1 = isEmptyString;
  function _typeof$1(obj) {
    "@babel/helpers - typeof";
    return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof$1(obj);
  }
  var isOfTypeObject = function isOfTypeObject2(val) {
    return _typeof$1(val) === "object";
  };
  const isOfTypeObject$1 = isOfTypeObject;
  var isObj$1 = curryN$1(1, both$1(isNotNull$1, either$1(isOfTypeObject$1, isFunction$7)));
  const isObj$2 = isObj$1;
  var isNotObj = complement$1(isObj$2);
  const isNotObj$1 = isNotObj;
  var isNonEmptyString = allPass$1([isString$4, isNotObj$1, isNotEmpty$1]);
  const isNonEmptyString$1 = isNonEmptyString;
  var isNotFunction = complement$1(isFunction$7);
  const isNotFunction$1 = isNotFunction;
  var isObjLike = curryN$1(1, both$1(isNotNull$1, isOfTypeObject$1));
  const isObjLike$1 = isObjLike;
  var isObject$h = pipe$2(type$1, identical$1("Object"));
  var isObjectConstructor = pipe$2(toString$9, equals$1(toString$9(Object)));
  var hasObjectConstructor = pathSatisfies$1(both$1(isFunction$7, isObjectConstructor), ["constructor"]);
  var isPlainObj = curryN$1(1, function(val) {
    if (!isObjLike$1(val) || !isObject$h(val)) {
      return false;
    }
    var proto = Object.getPrototypeOf(val);
    if (isNull$3(proto)) {
      return true;
    }
    return hasObjectConstructor(proto);
  });
  const isPlainObject$1 = isPlainObj;
  var isNumber$3 = curryN$1(1, pipe$2(type$1, identical$1("Number")));
  const isNumber$4 = isNumber$3;
  var isFinitePonyfill$1 = both$1(isNumber$4, isFinite);
  const ponyfill$2 = isFinitePonyfill$1;
  var isFinitePonyfill = curryN$1(1, ponyfill$2);
  var _isFinite = isFunction$7(Number.isFinite) ? curryN$1(1, bind$4(Number.isFinite, Number)) : isFinitePonyfill;
  const isFinite$1 = _isFinite;
  var isIntegerPonyfill$1 = both$1(isFinite$1, converge$1(equals$1, [Math.floor, identity$2]));
  const ponyfill$1 = isIntegerPonyfill$1;
  var isIntegerPonyfill = curryN$1(1, ponyfill$1);
  var isInteger$1 = isFunction$7(Number.isInteger) ? curryN$1(1, bind$4(Number.isInteger, Number)) : isIntegerPonyfill;
  const isInteger$2 = isInteger$1;
  var isRegExp$1 = curryN$1(1, pipe$2(type$1, identical$1("RegExp")));
  const isRegExp$2 = isRegExp$1;
  var noop$2 = always$1(stubUndefined$1());
  const noop$3 = noop$2;
  var allP = curryN$1(1, bind$4(Promise.all, Promise));
  const allP$1 = allP;
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o, minLen);
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
      return Array.from(iter);
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray(arr);
  }
  function _arrayLikeToArray(arr, len2) {
    if (len2 == null || len2 > arr.length)
      len2 = arr.length;
    for (var i2 = 0, arr2 = new Array(len2); i2 < len2; i2++)
      arr2[i2] = arr[i2];
    return arr2;
  }
  var byArity = comparator$1(function(a, b) {
    return a.length > b.length;
  });
  var getMaxArity = pipe$2(sort$1(byArity), head$1, prop$1("length"));
  var iteratorFn = curry$1(function(args, accumulator, fn) {
    var result = fn.apply(void 0, _toConsumableArray(args));
    return isNotNil$1(result) ? reduced$1(result) : accumulator;
  });
  var dispatchImpl = function dispatchImpl2(functions) {
    var arity = getMaxArity(functions);
    return curryN$1(arity, function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return reduce$2(iteratorFn(args), void 0, functions);
    });
  };
  var dispatch$8 = ifElse$1(isNonEmptyArray$1, dispatchImpl, stubUndefined$1);
  const dispatch$9 = dispatch$8;
  var included = flip$1(includes$1);
  const included$1 = included;
  var invokeArgs = curryN$1(3, function(mpath, args, obj) {
    var method = path$6(mpath, obj);
    var context2 = path$6(init$1(mpath), obj);
    if (isNotFunction$1(method))
      return void 0;
    if (isEmptyArray$1(mpath))
      return void 0;
    var boundMethod = bind$4(method, context2);
    return apply$5(boundMethod, args);
  });
  const invokeArgs$1 = invokeArgs;
  var escapeRegExp = when$1(isString$4, replace$2(/[.*+?^${}()|[\]\\-]/g, "\\$&"));
  const escapeRegExp$1 = escapeRegExp;
  var checkArguments = function checkArguments2(searchValue, replaceValue, str2) {
    if (str2 == null || searchValue == null || replaceValue == null) {
      throw TypeError("Input values must not be `null` or `undefined`");
    }
  };
  var checkValue = function checkValue2(value2, valueName) {
    if (typeof value2 !== "string") {
      if (!(value2 instanceof String)) {
        throw TypeError("`".concat(valueName, "` must be a string"));
      }
    }
  };
  var checkSearchValue = function checkSearchValue2(searchValue) {
    if (typeof searchValue !== "string" && !(searchValue instanceof String) && !(searchValue instanceof RegExp)) {
      throw TypeError("`searchValue` must be a string or an regexp");
    }
  };
  var replaceAll$2 = function replaceAll2(searchValue, replaceValue, str2) {
    checkArguments(searchValue, replaceValue, str2);
    checkValue(str2, "str");
    checkValue(replaceValue, "replaceValue");
    checkSearchValue(searchValue);
    var regexp = new RegExp(isRegExp$2(searchValue) ? searchValue : escapeRegExp$1(searchValue), "g");
    return replace$2(regexp, replaceValue, str2);
  };
  const ponyfill = replaceAll$2;
  var replaceAllPonyfill = curryN$1(3, ponyfill);
  var replaceAllInvoker = invoker$1(2, "replaceAll");
  var replaceAll = isFunction$7(String.prototype.replaceAll) ? replaceAllInvoker : replaceAllPonyfill;
  const replaceAll$1 = replaceAll;
  var trimCharsEnd = curry$1(function(chars2, value2) {
    return pipe$2(split$4(""), dropLastWhile$1(included$1(chars2)), join$1(""))(value2);
  });
  const trimCharsEnd$1 = trimCharsEnd;
  var trimCharsStart = curry$1(function(chars2, value2) {
    return pipe$2(split$4(""), dropWhile$1(included$1(chars2)), join$1(""))(value2);
  });
  const trimCharsStart$1 = trimCharsStart;
  const isWindows = () => pathSatisfies$1(test$2(/^win/), ["platform"], process$2);
  const getProtocol = (url2) => {
    try {
      const parsedUrl = new URL(url2);
      return trimCharsEnd$1(":", parsedUrl.protocol);
    } catch {
      return void 0;
    }
  };
  pipe$2(getProtocol, isNotUndefined$1);
  const getExtension = (url2) => {
    const lastDotPosition = url2.lastIndexOf(".");
    if (lastDotPosition >= 0) {
      return url2.substr(lastDotPosition).toLowerCase();
    }
    return "";
  };
  const isFileSystemPath = (uri) => {
    if (process$2.browser) {
      return false;
    }
    const protocol = getProtocol(uri);
    return isUndefined$1(protocol) || protocol === "file" || /^[a-zA-Z]$/.test(protocol);
  };
  const isHttpUrl = (url2) => {
    const protocol = getProtocol(url2);
    return protocol === "http" || protocol === "https";
  };
  const toFileSystemPath = (uri, options) => {
    const urlDecodePatterns = [/%23/g, "#", /%24/g, "$", /%26/g, "&", /%2C/g, ",", /%40/g, "@"];
    const keepFileProtocol = propOr$1(false, "keepFileProtocol", options);
    const isWindowsPredicate = propOr$1(isWindows, "isWindows", options);
    let path2 = decodeURI(uri);
    for (let i2 = 0; i2 < urlDecodePatterns.length; i2 += 2) {
      path2 = path2.replace(urlDecodePatterns[i2], urlDecodePatterns[i2 + 1]);
    }
    let isFileUrl = path2.substr(0, 7).toLowerCase() === "file://";
    if (isFileUrl) {
      path2 = path2[7] === "/" ? path2.substr(8) : path2.substr(7);
      if (isWindowsPredicate() && path2[1] === "/") {
        path2 = `${path2[0]}:${path2.substr(1)}`;
      }
      if (keepFileProtocol) {
        path2 = `file:///${path2}`;
      } else {
        isFileUrl = false;
        path2 = isWindowsPredicate() ? path2 : `/${path2}`;
      }
    }
    if (isWindowsPredicate() && !isFileUrl) {
      path2 = replaceAll$1("/", "\\", path2);
      if (path2.substr(1, 2) === ":\\") {
        path2 = path2[0].toUpperCase() + path2.substr(1);
      }
    }
    return path2;
  };
  const fromFileSystemPath = (uri) => {
    const urlEncodePatterns = [/\?/g, "%3F", /#/g, "%23"];
    let path2 = uri;
    if (isWindows()) {
      path2 = path2.replace(/\\/g, "/");
    }
    path2 = encodeURI(path2);
    for (let i2 = 0; i2 < urlEncodePatterns.length; i2 += 2) {
      path2 = path2.replace(urlEncodePatterns[i2], urlEncodePatterns[i2 + 1]);
    }
    return path2;
  };
  const getHash$1 = (uri) => {
    const hashIndex = uri.indexOf("#");
    if (hashIndex !== -1) {
      return uri.substr(hashIndex);
    }
    return "#";
  };
  const stripHash = (uri) => {
    const hashIndex = uri.indexOf("#");
    let hashStrippedUri = uri;
    if (hashIndex >= 0) {
      hashStrippedUri = uri.substr(0, hashIndex);
    }
    return hashStrippedUri;
  };
  const cwd = () => {
    if (process$2.browser) {
      return stripHash(globalThis.location.href);
    }
    const path2 = process$2.cwd();
    const lastChar = last$2(path2);
    if (["/", "\\"].includes(lastChar)) {
      return path2;
    }
    return path2 + (isWindows() ? "\\" : "/");
  };
  const resolve$2 = (from2, to) => {
    const resolvedUrl = new URL(to, new URL(from2, "resolve://"));
    if (resolvedUrl.protocol === "resolve:") {
      const {
        pathname,
        search,
        hash: hash2
      } = resolvedUrl;
      return pathname + search + hash2;
    }
    return resolvedUrl.toString();
  };
  const sanitize = (uri) => {
    if (isFileSystemPath(uri)) {
      return fromFileSystemPath(toFileSystemPath(uri));
    }
    return encodeURI(decodeURI(uri)).replace(/%5B/g, "[").replace(/%5D/g, "]");
  };
  const unsanitize = (uri) => {
    if (isFileSystemPath(uri)) {
      return toFileSystemPath(uri);
    }
    return decodeURI(uri);
  };
  const File$1 = stampit({
    props: {
      uri: null,
      mediaType: "text/plain",
      data: null,
      parseResult: null
    },
    init({
      uri = this.uri,
      mediaType = this.mediaType,
      data: data2 = this.data,
      parseResult = this.parseResult
    } = {}) {
      this.uri = uri;
      this.mediaType = mediaType;
      this.data = data2;
      this.parseResult = parseResult;
    },
    methods: {
      get extension() {
        if (isString$4(this.uri)) {
          return getExtension(this.uri);
        }
        return "";
      },
      toString() {
        if (typeof this.data === "string") {
          return this.data;
        }
        if (this.data instanceof ArrayBuffer || ["ArrayBuffer"].includes(type$1(this.data)) || ArrayBuffer.isView(this.data)) {
          const textDecoder = new TextDecoder("utf-8");
          return textDecoder.decode(this.data);
        }
        return String(this.data);
      }
    }
  });
  const File$2 = File$1;
  const defaultOptions = {
    parse: {
      /**
       * This is media type that
       */
      mediaType: "text/plain",
      /**
       * Determines how different types of files will be parsed.
       *
       * You can add additional parsers of your own, replace an existing one with
       * your own implementation, or remove any resolver by removing it from the list.
       * It's recommended to keep the order of parser from most specific ones to most generic ones.
       */
      parsers: [],
      /**
       * These options are merged with parser plugin instance before the plugin is run.
       */
      parserOpts: {}
    },
    resolve: {
      /**
       * baseURI serves as a base for all relative URL found in ApiDOM references.
       */
      baseURI: "",
      /**
       * Determines how References will be resolved.
       *
       * You can add additional resolvers of your own, replace an existing one with
       * your own implementation, or remove any resolver by removing it from the list.
       */
      resolvers: [],
      /**
       * These options are merged with resolver plugin instance before the plugin is run.
       */
      resolverOpts: {},
      /**
       * Determines strategies how References are identified and processed by resolvers.
       * Strategy is determined by media type.
       *
       * You can add additional resolver strategies of your own, replace an existing one with
       * your own implementation, or remove any resolve strategy by removing it from the list.
       */
      strategies: [],
      /**
       * Determines whether external references will be resolved.
       * If this option is disabled, then none of above resolvers will be called.
       * Instead, external references will simply be ignored.
       */
      external: true,
      /**
       * Determines the maximum depth of resolve algorithms.
       * By default, there is no limit.
       *
       * This option tracks the depth of the file tree not the depth of the dereference path.
       *
       * It can be set to any positive integer number or zero (0).
       *
       * The resolver should throw MaximumResolverDepthError if resolution depth
       * is exceeded by this option.
       */
      maxDepth: Infinity
    },
    dereference: {
      /**
       * Determines strategies how ApiDOM is dereferenced.
       * Strategy is determined by media type or by inspecting ApiDOM to be dereferenced.
       *
       * You can add additional dereference strategies of your own, replace an existing one with
       * your own implementation, or remove any dereference strategy by removing it from the list.
       */
      strategies: [],
      /**
       * This option accepts an instance of pre-computed ReferenceSet.
       * If provided it will speed up the dereferencing significantly as the external
       * resolution doesn't need to happen anymore.
       */
      refSet: null,
      /**
       * Determines the maximum depth of dereferencing.
       * By default, there is no limit.
       *
       * The maxDepth represents a number of references that needed to be followed
       * before the eventual value was reached.
       *
       * It can be set to any positive integer number or zero (0).
       *
       * The dereferencing should throw MaximumDereferenceDepthError if dereferencing depth
       * is exceeded by this option.
       */
      maxDepth: Infinity
    }
  };
  const defaultOptions$1 = defaultOptions;
  const baseURILens = lens$1(path$6(["resolve", "baseURI"]), assocPath$1(["resolve", "baseURI"]));
  const baseURIDefault = (baseURI) => isEmptyString$1(baseURI) ? cwd() : baseURI;
  const merge$3 = (lObj, rObj) => {
    const withoutDefaults = mergeDeepRight$1(lObj, rObj);
    return over$1(baseURILens, baseURIDefault, withoutDefaults);
  };
  var check = function(it) {
    return it && it.Math === Math && it;
  };
  var global$d = (
    // eslint-disable-next-line es/no-global-this -- safe
    check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
    check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || // eslint-disable-next-line no-new-func -- fallback
    function() {
      return this;
    }() || commonjsGlobal || Function("return this")()
  );
  var fails$b = function(exec) {
    try {
      return !!exec();
    } catch (error) {
      return true;
    }
  };
  var fails$a = fails$b;
  var functionBindNative = !fails$a(function() {
    var test2 = (function() {
    }).bind();
    return typeof test2 != "function" || test2.hasOwnProperty("prototype");
  });
  var NATIVE_BIND$3 = functionBindNative;
  var FunctionPrototype$2 = Function.prototype;
  var apply$3 = FunctionPrototype$2.apply;
  var call$9 = FunctionPrototype$2.call;
  var functionApply = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND$3 ? call$9.bind(apply$3) : function() {
    return call$9.apply(apply$3, arguments);
  });
  var NATIVE_BIND$2 = functionBindNative;
  var FunctionPrototype$1 = Function.prototype;
  var call$8 = FunctionPrototype$1.call;
  var uncurryThisWithBind = NATIVE_BIND$2 && FunctionPrototype$1.bind.bind(call$8, call$8);
  var functionUncurryThis = NATIVE_BIND$2 ? uncurryThisWithBind : function(fn) {
    return function() {
      return call$8.apply(fn, arguments);
    };
  };
  var uncurryThis$c = functionUncurryThis;
  var toString$7 = uncurryThis$c({}.toString);
  var stringSlice$1 = uncurryThis$c("".slice);
  var classofRaw$2 = function(it) {
    return stringSlice$1(toString$7(it), 8, -1);
  };
  var classofRaw$1 = classofRaw$2;
  var uncurryThis$b = functionUncurryThis;
  var functionUncurryThisClause = function(fn) {
    if (classofRaw$1(fn) === "Function")
      return uncurryThis$b(fn);
  };
  var documentAll$2 = typeof document == "object" && document.all;
  var IS_HTMLDDA = typeof documentAll$2 == "undefined" && documentAll$2 !== void 0;
  var documentAll_1 = {
    all: documentAll$2,
    IS_HTMLDDA
  };
  var $documentAll$1 = documentAll_1;
  var documentAll$1 = $documentAll$1.all;
  var isCallable$d = $documentAll$1.IS_HTMLDDA ? function(argument) {
    return typeof argument == "function" || argument === documentAll$1;
  } : function(argument) {
    return typeof argument == "function";
  };
  var objectGetOwnPropertyDescriptor = {};
  var fails$9 = fails$b;
  var descriptors = !fails$9(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] !== 7;
  });
  var NATIVE_BIND$1 = functionBindNative;
  var call$7 = Function.prototype.call;
  var functionCall = NATIVE_BIND$1 ? call$7.bind(call$7) : function() {
    return call$7.apply(call$7, arguments);
  };
  var objectPropertyIsEnumerable = {};
  var $propertyIsEnumerable = {}.propertyIsEnumerable;
  var getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
  var NASHORN_BUG = getOwnPropertyDescriptor$1 && !$propertyIsEnumerable.call({ 1: 2 }, 1);
  objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable2(V) {
    var descriptor = getOwnPropertyDescriptor$1(this, V);
    return !!descriptor && descriptor.enumerable;
  } : $propertyIsEnumerable;
  var createPropertyDescriptor$5 = function(bitmap, value2) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value2
    };
  };
  var uncurryThis$a = functionUncurryThis;
  var fails$8 = fails$b;
  var classof$5 = classofRaw$2;
  var $Object$4 = Object;
  var split$2 = uncurryThis$a("".split);
  var indexedObject = fails$8(function() {
    return !$Object$4("z").propertyIsEnumerable(0);
  }) ? function(it) {
    return classof$5(it) === "String" ? split$2(it, "") : $Object$4(it);
  } : $Object$4;
  var isNullOrUndefined$3 = function(it) {
    return it === null || it === void 0;
  };
  var isNullOrUndefined$2 = isNullOrUndefined$3;
  var $TypeError$8 = TypeError;
  var requireObjectCoercible$3 = function(it) {
    if (isNullOrUndefined$2(it))
      throw new $TypeError$8("Can't call method on " + it);
    return it;
  };
  var IndexedObject = indexedObject;
  var requireObjectCoercible$2 = requireObjectCoercible$3;
  var toIndexedObject$5 = function(it) {
    return IndexedObject(requireObjectCoercible$2(it));
  };
  var isCallable$c = isCallable$d;
  var $documentAll = documentAll_1;
  var documentAll = $documentAll.all;
  var isObject$g = $documentAll.IS_HTMLDDA ? function(it) {
    return typeof it == "object" ? it !== null : isCallable$c(it) || it === documentAll;
  } : function(it) {
    return typeof it == "object" ? it !== null : isCallable$c(it);
  };
  var path$4 = {};
  var path$3 = path$4;
  var global$c = global$d;
  var isCallable$b = isCallable$d;
  var aFunction = function(variable) {
    return isCallable$b(variable) ? variable : void 0;
  };
  var getBuiltIn$5 = function(namespace2, method) {
    return arguments.length < 2 ? aFunction(path$3[namespace2]) || aFunction(global$c[namespace2]) : path$3[namespace2] && path$3[namespace2][method] || global$c[namespace2] && global$c[namespace2][method];
  };
  var uncurryThis$9 = functionUncurryThis;
  var objectIsPrototypeOf = uncurryThis$9({}.isPrototypeOf);
  var engineUserAgent = typeof navigator != "undefined" && String(navigator.userAgent) || "";
  var global$b = global$d;
  var userAgent = engineUserAgent;
  var process = global$b.process;
  var Deno = global$b.Deno;
  var versions = process && process.versions || Deno && Deno.version;
  var v8 = versions && versions.v8;
  var match, version$3;
  if (v8) {
    match = v8.split(".");
    version$3 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
  }
  if (!version$3 && userAgent) {
    match = userAgent.match(/Edge\/(\d+)/);
    if (!match || match[1] >= 74) {
      match = userAgent.match(/Chrome\/(\d+)/);
      if (match)
        version$3 = +match[1];
    }
  }
  var engineV8Version = version$3;
  var V8_VERSION = engineV8Version;
  var fails$7 = fails$b;
  var global$a = global$d;
  var $String$4 = global$a.String;
  var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$7(function() {
    var symbol = Symbol("symbol detection");
    return !$String$4(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
  });
  var NATIVE_SYMBOL$1 = symbolConstructorDetection;
  var useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && typeof Symbol.iterator == "symbol";
  var getBuiltIn$4 = getBuiltIn$5;
  var isCallable$a = isCallable$d;
  var isPrototypeOf$3 = objectIsPrototypeOf;
  var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
  var $Object$3 = Object;
  var isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function(it) {
    return typeof it == "symbol";
  } : function(it) {
    var $Symbol = getBuiltIn$4("Symbol");
    return isCallable$a($Symbol) && isPrototypeOf$3($Symbol.prototype, $Object$3(it));
  };
  var $String$3 = String;
  var tryToString$3 = function(argument) {
    try {
      return $String$3(argument);
    } catch (error) {
      return "Object";
    }
  };
  var isCallable$9 = isCallable$d;
  var tryToString$2 = tryToString$3;
  var $TypeError$7 = TypeError;
  var aCallable$4 = function(argument) {
    if (isCallable$9(argument))
      return argument;
    throw new $TypeError$7(tryToString$2(argument) + " is not a function");
  };
  var aCallable$3 = aCallable$4;
  var isNullOrUndefined$1 = isNullOrUndefined$3;
  var getMethod$3 = function(V, P) {
    var func = V[P];
    return isNullOrUndefined$1(func) ? void 0 : aCallable$3(func);
  };
  var call$6 = functionCall;
  var isCallable$8 = isCallable$d;
  var isObject$f = isObject$g;
  var $TypeError$6 = TypeError;
  var ordinaryToPrimitive$1 = function(input, pref) {
    var fn, val;
    if (pref === "string" && isCallable$8(fn = input.toString) && !isObject$f(val = call$6(fn, input)))
      return val;
    if (isCallable$8(fn = input.valueOf) && !isObject$f(val = call$6(fn, input)))
      return val;
    if (pref !== "string" && isCallable$8(fn = input.toString) && !isObject$f(val = call$6(fn, input)))
      return val;
    throw new $TypeError$6("Can't convert object to primitive value");
  };
  var shared$3 = { exports: {} };
  var global$9 = global$d;
  var defineProperty$2 = Object.defineProperty;
  var defineGlobalProperty$1 = function(key, value2) {
    try {
      defineProperty$2(global$9, key, { value: value2, configurable: true, writable: true });
    } catch (error) {
      global$9[key] = value2;
    }
    return value2;
  };
  var global$8 = global$d;
  var defineGlobalProperty = defineGlobalProperty$1;
  var SHARED = "__core-js_shared__";
  var store$2 = global$8[SHARED] || defineGlobalProperty(SHARED, {});
  var sharedStore = store$2;
  var store$1 = sharedStore;
  (shared$3.exports = function(key, value2) {
    return store$1[key] || (store$1[key] = value2 !== void 0 ? value2 : {});
  })("versions", []).push({
    version: "3.33.0",
    mode: "pure",
    copyright: " 2014-2023 Denis Pushkarev (zloirock.ru)",
    license: "https://github.com/zloirock/core-js/blob/v3.33.0/LICENSE",
    source: "https://github.com/zloirock/core-js"
  });
  var sharedExports = shared$3.exports;
  var requireObjectCoercible$1 = requireObjectCoercible$3;
  var $Object$2 = Object;
  var toObject$3 = function(argument) {
    return $Object$2(requireObjectCoercible$1(argument));
  };
  var uncurryThis$8 = functionUncurryThis;
  var toObject$2 = toObject$3;
  var hasOwnProperty$b = uncurryThis$8({}.hasOwnProperty);
  var hasOwnProperty_1 = Object.hasOwn || function hasOwn2(it, key) {
    return hasOwnProperty$b(toObject$2(it), key);
  };
  var uncurryThis$7 = functionUncurryThis;
  var id = 0;
  var postfix = Math.random();
  var toString$6 = uncurryThis$7(1 .toString);
  var uid$2 = function(key) {
    return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString$6(++id + postfix, 36);
  };
  var global$7 = global$d;
  var shared$2 = sharedExports;
  var hasOwn$8 = hasOwnProperty_1;
  var uid$1 = uid$2;
  var NATIVE_SYMBOL = symbolConstructorDetection;
  var USE_SYMBOL_AS_UID = useSymbolAsUid;
  var Symbol$5 = global$7.Symbol;
  var WellKnownSymbolsStore = shared$2("wks");
  var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$5["for"] || Symbol$5 : Symbol$5 && Symbol$5.withoutSetter || uid$1;
  var wellKnownSymbol$a = function(name) {
    if (!hasOwn$8(WellKnownSymbolsStore, name)) {
      WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn$8(Symbol$5, name) ? Symbol$5[name] : createWellKnownSymbol("Symbol." + name);
    }
    return WellKnownSymbolsStore[name];
  };
  var call$5 = functionCall;
  var isObject$e = isObject$g;
  var isSymbol$1 = isSymbol$2;
  var getMethod$2 = getMethod$3;
  var ordinaryToPrimitive = ordinaryToPrimitive$1;
  var wellKnownSymbol$9 = wellKnownSymbol$a;
  var $TypeError$5 = TypeError;
  var TO_PRIMITIVE = wellKnownSymbol$9("toPrimitive");
  var toPrimitive$1 = function(input, pref) {
    if (!isObject$e(input) || isSymbol$1(input))
      return input;
    var exoticToPrim = getMethod$2(input, TO_PRIMITIVE);
    var result;
    if (exoticToPrim) {
      if (pref === void 0)
        pref = "default";
      result = call$5(exoticToPrim, input, pref);
      if (!isObject$e(result) || isSymbol$1(result))
        return result;
      throw new $TypeError$5("Can't convert object to primitive value");
    }
    if (pref === void 0)
      pref = "number";
    return ordinaryToPrimitive(input, pref);
  };
  var toPrimitive = toPrimitive$1;
  var isSymbol = isSymbol$2;
  var toPropertyKey$2 = function(argument) {
    var key = toPrimitive(argument, "string");
    return isSymbol(key) ? key : key + "";
  };
  var global$6 = global$d;
  var isObject$d = isObject$g;
  var document$1 = global$6.document;
  var EXISTS$1 = isObject$d(document$1) && isObject$d(document$1.createElement);
  var documentCreateElement$1 = function(it) {
    return EXISTS$1 ? document$1.createElement(it) : {};
  };
  var DESCRIPTORS$7 = descriptors;
  var fails$6 = fails$b;
  var createElement = documentCreateElement$1;
  var ie8DomDefine = !DESCRIPTORS$7 && !fails$6(function() {
    return Object.defineProperty(createElement("div"), "a", {
      get: function() {
        return 7;
      }
    }).a !== 7;
  });
  var DESCRIPTORS$6 = descriptors;
  var call$4 = functionCall;
  var propertyIsEnumerableModule = objectPropertyIsEnumerable;
  var createPropertyDescriptor$4 = createPropertyDescriptor$5;
  var toIndexedObject$4 = toIndexedObject$5;
  var toPropertyKey$1 = toPropertyKey$2;
  var hasOwn$7 = hasOwnProperty_1;
  var IE8_DOM_DEFINE$1 = ie8DomDefine;
  var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
  objectGetOwnPropertyDescriptor.f = DESCRIPTORS$6 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor2(O, P) {
    O = toIndexedObject$4(O);
    P = toPropertyKey$1(P);
    if (IE8_DOM_DEFINE$1)
      try {
        return $getOwnPropertyDescriptor$1(O, P);
      } catch (error) {
      }
    if (hasOwn$7(O, P))
      return createPropertyDescriptor$4(!call$4(propertyIsEnumerableModule.f, O, P), O[P]);
  };
  var fails$5 = fails$b;
  var isCallable$7 = isCallable$d;
  var replacement = /#|\.prototype\./;
  var isForced$1 = function(feature, detection) {
    var value2 = data[normalize$2(feature)];
    return value2 === POLYFILL ? true : value2 === NATIVE ? false : isCallable$7(detection) ? fails$5(detection) : !!detection;
  };
  var normalize$2 = isForced$1.normalize = function(string) {
    return String(string).replace(replacement, ".").toLowerCase();
  };
  var data = isForced$1.data = {};
  var NATIVE = isForced$1.NATIVE = "N";
  var POLYFILL = isForced$1.POLYFILL = "P";
  var isForced_1 = isForced$1;
  var uncurryThis$6 = functionUncurryThisClause;
  var aCallable$2 = aCallable$4;
  var NATIVE_BIND = functionBindNative;
  var bind$2 = uncurryThis$6(uncurryThis$6.bind);
  var functionBindContext = function(fn, that) {
    aCallable$2(fn);
    return that === void 0 ? fn : NATIVE_BIND ? bind$2(fn, that) : function() {
      return fn.apply(that, arguments);
    };
  };
  var objectDefineProperty = {};
  var DESCRIPTORS$5 = descriptors;
  var fails$4 = fails$b;
  var v8PrototypeDefineBug = DESCRIPTORS$5 && fails$4(function() {
    return Object.defineProperty(function() {
    }, "prototype", {
      value: 42,
      writable: false
    }).prototype !== 42;
  });
  var isObject$c = isObject$g;
  var $String$2 = String;
  var $TypeError$4 = TypeError;
  var anObject$8 = function(argument) {
    if (isObject$c(argument))
      return argument;
    throw new $TypeError$4($String$2(argument) + " is not an object");
  };
  var DESCRIPTORS$4 = descriptors;
  var IE8_DOM_DEFINE = ie8DomDefine;
  var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
  var anObject$7 = anObject$8;
  var toPropertyKey = toPropertyKey$2;
  var $TypeError$3 = TypeError;
  var $defineProperty = Object.defineProperty;
  var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var ENUMERABLE = "enumerable";
  var CONFIGURABLE$1 = "configurable";
  var WRITABLE = "writable";
  objectDefineProperty.f = DESCRIPTORS$4 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty2(O, P, Attributes) {
    anObject$7(O);
    P = toPropertyKey(P);
    anObject$7(Attributes);
    if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
      var current = $getOwnPropertyDescriptor(O, P);
      if (current && current[WRITABLE]) {
        O[P] = Attributes.value;
        Attributes = {
          configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
          enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
          writable: false
        };
      }
    }
    return $defineProperty(O, P, Attributes);
  } : $defineProperty : function defineProperty2(O, P, Attributes) {
    anObject$7(O);
    P = toPropertyKey(P);
    anObject$7(Attributes);
    if (IE8_DOM_DEFINE)
      try {
        return $defineProperty(O, P, Attributes);
      } catch (error) {
      }
    if ("get" in Attributes || "set" in Attributes)
      throw new $TypeError$3("Accessors not supported");
    if ("value" in Attributes)
      O[P] = Attributes.value;
    return O;
  };
  var DESCRIPTORS$3 = descriptors;
  var definePropertyModule$2 = objectDefineProperty;
  var createPropertyDescriptor$3 = createPropertyDescriptor$5;
  var createNonEnumerableProperty$9 = DESCRIPTORS$3 ? function(object, key, value2) {
    return definePropertyModule$2.f(object, key, createPropertyDescriptor$3(1, value2));
  } : function(object, key, value2) {
    object[key] = value2;
    return object;
  };
  var global$5 = global$d;
  var apply$2 = functionApply;
  var uncurryThis$5 = functionUncurryThisClause;
  var isCallable$6 = isCallable$d;
  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
  var isForced = isForced_1;
  var path$2 = path$4;
  var bind$1 = functionBindContext;
  var createNonEnumerableProperty$8 = createNonEnumerableProperty$9;
  var hasOwn$6 = hasOwnProperty_1;
  var wrapConstructor = function(NativeConstructor) {
    var Wrapper = function(a, b, c) {
      if (this instanceof Wrapper) {
        switch (arguments.length) {
          case 0:
            return new NativeConstructor();
          case 1:
            return new NativeConstructor(a);
          case 2:
            return new NativeConstructor(a, b);
        }
        return new NativeConstructor(a, b, c);
      }
      return apply$2(NativeConstructor, this, arguments);
    };
    Wrapper.prototype = NativeConstructor.prototype;
    return Wrapper;
  };
  var _export = function(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var PROTO = options.proto;
    var nativeSource = GLOBAL ? global$5 : STATIC ? global$5[TARGET] : (global$5[TARGET] || {}).prototype;
    var target = GLOBAL ? path$2 : path$2[TARGET] || createNonEnumerableProperty$8(path$2, TARGET, {})[TARGET];
    var targetPrototype = target.prototype;
    var FORCED2, USE_NATIVE, VIRTUAL_PROTOTYPE;
    var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;
    for (key in source) {
      FORCED2 = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
      USE_NATIVE = !FORCED2 && nativeSource && hasOwn$6(nativeSource, key);
      targetProperty = target[key];
      if (USE_NATIVE)
        if (options.dontCallGetSet) {
          descriptor = getOwnPropertyDescriptor(nativeSource, key);
          nativeProperty = descriptor && descriptor.value;
        } else
          nativeProperty = nativeSource[key];
      sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];
      if (USE_NATIVE && typeof targetProperty == typeof sourceProperty)
        continue;
      if (options.bind && USE_NATIVE)
        resultProperty = bind$1(sourceProperty, global$5);
      else if (options.wrap && USE_NATIVE)
        resultProperty = wrapConstructor(sourceProperty);
      else if (PROTO && isCallable$6(sourceProperty))
        resultProperty = uncurryThis$5(sourceProperty);
      else
        resultProperty = sourceProperty;
      if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty$8(resultProperty, "sham", true);
      }
      createNonEnumerableProperty$8(target, key, resultProperty);
      if (PROTO) {
        VIRTUAL_PROTOTYPE = TARGET + "Prototype";
        if (!hasOwn$6(path$2, VIRTUAL_PROTOTYPE)) {
          createNonEnumerableProperty$8(path$2, VIRTUAL_PROTOTYPE, {});
        }
        createNonEnumerableProperty$8(path$2[VIRTUAL_PROTOTYPE], key, sourceProperty);
        if (options.real && targetPrototype && (FORCED2 || !targetPrototype[key])) {
          createNonEnumerableProperty$8(targetPrototype, key, sourceProperty);
        }
      }
    }
  };
  var shared$1 = sharedExports;
  var uid = uid$2;
  var keys$2 = shared$1("keys");
  var sharedKey$3 = function(key) {
    return keys$2[key] || (keys$2[key] = uid(key));
  };
  var fails$3 = fails$b;
  var correctPrototypeGetter = !fails$3(function() {
    function F2() {
    }
    F2.prototype.constructor = null;
    return Object.getPrototypeOf(new F2()) !== F2.prototype;
  });
  var hasOwn$5 = hasOwnProperty_1;
  var isCallable$5 = isCallable$d;
  var toObject$1 = toObject$3;
  var sharedKey$2 = sharedKey$3;
  var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;
  var IE_PROTO$1 = sharedKey$2("IE_PROTO");
  var $Object$1 = Object;
  var ObjectPrototype = $Object$1.prototype;
  var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object$1.getPrototypeOf : function(O) {
    var object = toObject$1(O);
    if (hasOwn$5(object, IE_PROTO$1))
      return object[IE_PROTO$1];
    var constructor = object.constructor;
    if (isCallable$5(constructor) && object instanceof constructor) {
      return constructor.prototype;
    }
    return object instanceof $Object$1 ? ObjectPrototype : null;
  };
  var uncurryThis$4 = functionUncurryThis;
  var aCallable$1 = aCallable$4;
  var functionUncurryThisAccessor = function(object, key, method) {
    try {
      return uncurryThis$4(aCallable$1(Object.getOwnPropertyDescriptor(object, key)[method]));
    } catch (error) {
    }
  };
  var isCallable$4 = isCallable$d;
  var $String$1 = String;
  var $TypeError$2 = TypeError;
  var aPossiblePrototype$1 = function(argument) {
    if (typeof argument == "object" || isCallable$4(argument))
      return argument;
    throw new $TypeError$2("Can't set " + $String$1(argument) + " as a prototype");
  };
  var uncurryThisAccessor = functionUncurryThisAccessor;
  var anObject$6 = anObject$8;
  var aPossiblePrototype = aPossiblePrototype$1;
  var objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? function() {
    var CORRECT_SETTER = false;
    var test2 = {};
    var setter;
    try {
      setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
      setter(test2, []);
      CORRECT_SETTER = test2 instanceof Array;
    } catch (error) {
    }
    return function setPrototypeOf2(O, proto) {
      anObject$6(O);
      aPossiblePrototype(proto);
      if (CORRECT_SETTER)
        setter(O, proto);
      else
        O.__proto__ = proto;
      return O;
    };
  }() : void 0);
  var objectGetOwnPropertyNames = {};
  var ceil = Math.ceil;
  var floor = Math.floor;
  var mathTrunc = Math.trunc || function trunc2(x2) {
    var n2 = +x2;
    return (n2 > 0 ? floor : ceil)(n2);
  };
  var trunc = mathTrunc;
  var toIntegerOrInfinity$3 = function(argument) {
    var number2 = +argument;
    return number2 !== number2 || number2 === 0 ? 0 : trunc(number2);
  };
  var toIntegerOrInfinity$2 = toIntegerOrInfinity$3;
  var max$1 = Math.max;
  var min$2 = Math.min;
  var toAbsoluteIndex$1 = function(index2, length2) {
    var integer = toIntegerOrInfinity$2(index2);
    return integer < 0 ? max$1(integer + length2, 0) : min$2(integer, length2);
  };
  var toIntegerOrInfinity$1 = toIntegerOrInfinity$3;
  var min$1 = Math.min;
  var toLength$1 = function(argument) {
    return argument > 0 ? min$1(toIntegerOrInfinity$1(argument), 9007199254740991) : 0;
  };
  var toLength = toLength$1;
  var lengthOfArrayLike$2 = function(obj) {
    return toLength(obj.length);
  };
  var toIndexedObject$3 = toIndexedObject$5;
  var toAbsoluteIndex = toAbsoluteIndex$1;
  var lengthOfArrayLike$1 = lengthOfArrayLike$2;
  var createMethod$1 = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
      var O = toIndexedObject$3($this);
      var length2 = lengthOfArrayLike$1(O);
      var index2 = toAbsoluteIndex(fromIndex, length2);
      var value2;
      if (IS_INCLUDES && el !== el)
        while (length2 > index2) {
          value2 = O[index2++];
          if (value2 !== value2)
            return true;
        }
      else
        for (; length2 > index2; index2++) {
          if ((IS_INCLUDES || index2 in O) && O[index2] === el)
            return IS_INCLUDES || index2 || 0;
        }
      return !IS_INCLUDES && -1;
    };
  };
  var arrayIncludes = {
    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    includes: createMethod$1(true),
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod$1(false)
  };
  var hiddenKeys$4 = {};
  var uncurryThis$3 = functionUncurryThis;
  var hasOwn$4 = hasOwnProperty_1;
  var toIndexedObject$2 = toIndexedObject$5;
  var indexOf = arrayIncludes.indexOf;
  var hiddenKeys$3 = hiddenKeys$4;
  var push$1 = uncurryThis$3([].push);
  var objectKeysInternal = function(object, names) {
    var O = toIndexedObject$2(object);
    var i2 = 0;
    var result = [];
    var key;
    for (key in O)
      !hasOwn$4(hiddenKeys$3, key) && hasOwn$4(O, key) && push$1(result, key);
    while (names.length > i2)
      if (hasOwn$4(O, key = names[i2++])) {
        ~indexOf(result, key) || push$1(result, key);
      }
    return result;
  };
  var enumBugKeys$3 = [
    "constructor",
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toLocaleString",
    "toString",
    "valueOf"
  ];
  var internalObjectKeys$1 = objectKeysInternal;
  var enumBugKeys$2 = enumBugKeys$3;
  var hiddenKeys$2 = enumBugKeys$2.concat("length", "prototype");
  objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return internalObjectKeys$1(O, hiddenKeys$2);
  };
  var objectGetOwnPropertySymbols = {};
  objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
  var getBuiltIn$3 = getBuiltIn$5;
  var uncurryThis$2 = functionUncurryThis;
  var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
  var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
  var anObject$5 = anObject$8;
  var concat$2 = uncurryThis$2([].concat);
  var ownKeys$1 = getBuiltIn$3("Reflect", "ownKeys") || function ownKeys2(it) {
    var keys2 = getOwnPropertyNamesModule.f(anObject$5(it));
    var getOwnPropertySymbols2 = getOwnPropertySymbolsModule.f;
    return getOwnPropertySymbols2 ? concat$2(keys2, getOwnPropertySymbols2(it)) : keys2;
  };
  var hasOwn$3 = hasOwnProperty_1;
  var ownKeys = ownKeys$1;
  var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
  var definePropertyModule$1 = objectDefineProperty;
  var copyConstructorProperties$2 = function(target, source, exceptions2) {
    var keys2 = ownKeys(source);
    var defineProperty2 = definePropertyModule$1.f;
    var getOwnPropertyDescriptor2 = getOwnPropertyDescriptorModule.f;
    for (var i2 = 0; i2 < keys2.length; i2++) {
      var key = keys2[i2];
      if (!hasOwn$3(target, key) && !(exceptions2 && hasOwn$3(exceptions2, key))) {
        defineProperty2(target, key, getOwnPropertyDescriptor2(source, key));
      }
    }
  };
  var objectDefineProperties = {};
  var internalObjectKeys = objectKeysInternal;
  var enumBugKeys$1 = enumBugKeys$3;
  var objectKeys$2 = Object.keys || function keys2(O) {
    return internalObjectKeys(O, enumBugKeys$1);
  };
  var DESCRIPTORS$2 = descriptors;
  var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
  var definePropertyModule = objectDefineProperty;
  var anObject$4 = anObject$8;
  var toIndexedObject$1 = toIndexedObject$5;
  var objectKeys$1 = objectKeys$2;
  objectDefineProperties.f = DESCRIPTORS$2 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject$4(O);
    var props = toIndexedObject$1(Properties);
    var keys2 = objectKeys$1(Properties);
    var length2 = keys2.length;
    var index2 = 0;
    var key;
    while (length2 > index2)
      definePropertyModule.f(O, key = keys2[index2++], props[key]);
    return O;
  };
  var getBuiltIn$2 = getBuiltIn$5;
  var html$1 = getBuiltIn$2("document", "documentElement");
  var anObject$3 = anObject$8;
  var definePropertiesModule = objectDefineProperties;
  var enumBugKeys = enumBugKeys$3;
  var hiddenKeys$1 = hiddenKeys$4;
  var html = html$1;
  var documentCreateElement = documentCreateElement$1;
  var sharedKey$1 = sharedKey$3;
  var GT = ">";
  var LT = "<";
  var PROTOTYPE = "prototype";
  var SCRIPT = "script";
  var IE_PROTO = sharedKey$1("IE_PROTO");
  var EmptyConstructor = function() {
  };
  var scriptTag = function(content) {
    return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
  };
  var NullProtoObjectViaActiveX = function(activeXDocument2) {
    activeXDocument2.write(scriptTag(""));
    activeXDocument2.close();
    var temp = activeXDocument2.parentWindow.Object;
    activeXDocument2 = null;
    return temp;
  };
  var NullProtoObjectViaIFrame = function() {
    var iframe = documentCreateElement("iframe");
    var JS = "java" + SCRIPT + ":";
    var iframeDocument;
    iframe.style.display = "none";
    html.appendChild(iframe);
    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag("document.F=Object"));
    iframeDocument.close();
    return iframeDocument.F;
  };
  var activeXDocument;
  var NullProtoObject = function() {
    try {
      activeXDocument = new ActiveXObject("htmlfile");
    } catch (error) {
    }
    NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
    var length2 = enumBugKeys.length;
    while (length2--)
      delete NullProtoObject[PROTOTYPE][enumBugKeys[length2]];
    return NullProtoObject();
  };
  hiddenKeys$1[IE_PROTO] = true;
  var objectCreate = Object.create || function create2(O, Properties) {
    var result;
    if (O !== null) {
      EmptyConstructor[PROTOTYPE] = anObject$3(O);
      result = new EmptyConstructor();
      EmptyConstructor[PROTOTYPE] = null;
      result[IE_PROTO] = O;
    } else
      result = NullProtoObject();
    return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
  };
  var isObject$b = isObject$g;
  var createNonEnumerableProperty$7 = createNonEnumerableProperty$9;
  var installErrorCause$2 = function(O, options) {
    if (isObject$b(options) && "cause" in options) {
      createNonEnumerableProperty$7(O, "cause", options.cause);
    }
  };
  var uncurryThis$1 = functionUncurryThis;
  var $Error$1 = Error;
  var replace = uncurryThis$1("".replace);
  var TEST = function(arg) {
    return String(new $Error$1(arg).stack);
  }("zxcasd");
  var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
  var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
  var errorStackClear = function(stack, dropEntries) {
    if (IS_V8_OR_CHAKRA_STACK && typeof stack == "string" && !$Error$1.prepareStackTrace) {
      while (dropEntries--)
        stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, "");
    }
    return stack;
  };
  var fails$2 = fails$b;
  var createPropertyDescriptor$2 = createPropertyDescriptor$5;
  var errorStackInstallable = !fails$2(function() {
    var error = new Error("a");
    if (!("stack" in error))
      return true;
    Object.defineProperty(error, "stack", createPropertyDescriptor$2(1, 7));
    return error.stack !== 7;
  });
  var createNonEnumerableProperty$6 = createNonEnumerableProperty$9;
  var clearErrorStack = errorStackClear;
  var ERROR_STACK_INSTALLABLE = errorStackInstallable;
  var captureStackTrace = Error.captureStackTrace;
  var errorStackInstall = function(error, C, stack, dropEntries) {
    if (ERROR_STACK_INSTALLABLE) {
      if (captureStackTrace)
        captureStackTrace(error, C);
      else
        createNonEnumerableProperty$6(error, "stack", clearErrorStack(stack, dropEntries));
    }
  };
  var iterators = {};
  var wellKnownSymbol$8 = wellKnownSymbol$a;
  var Iterators$5 = iterators;
  var ITERATOR$3 = wellKnownSymbol$8("iterator");
  var ArrayPrototype = Array.prototype;
  var isArrayIteratorMethod$1 = function(it) {
    return it !== void 0 && (Iterators$5.Array === it || ArrayPrototype[ITERATOR$3] === it);
  };
  var wellKnownSymbol$7 = wellKnownSymbol$a;
  var TO_STRING_TAG$4 = wellKnownSymbol$7("toStringTag");
  var test = {};
  test[TO_STRING_TAG$4] = "z";
  var toStringTagSupport = String(test) === "[object z]";
  var TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;
  var isCallable$3 = isCallable$d;
  var classofRaw = classofRaw$2;
  var wellKnownSymbol$6 = wellKnownSymbol$a;
  var TO_STRING_TAG$3 = wellKnownSymbol$6("toStringTag");
  var $Object = Object;
  var CORRECT_ARGUMENTS = classofRaw(function() {
    return arguments;
  }()) === "Arguments";
  var tryGet = function(it, key) {
    try {
      return it[key];
    } catch (error) {
    }
  };
  var classof$4 = TO_STRING_TAG_SUPPORT$2 ? classofRaw : function(it) {
    var O, tag, result;
    return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG$3)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === "Object" && isCallable$3(O.callee) ? "Arguments" : result;
  };
  var classof$3 = classof$4;
  var getMethod$1 = getMethod$3;
  var isNullOrUndefined = isNullOrUndefined$3;
  var Iterators$4 = iterators;
  var wellKnownSymbol$5 = wellKnownSymbol$a;
  var ITERATOR$2 = wellKnownSymbol$5("iterator");
  var getIteratorMethod$2 = function(it) {
    if (!isNullOrUndefined(it))
      return getMethod$1(it, ITERATOR$2) || getMethod$1(it, "@@iterator") || Iterators$4[classof$3(it)];
  };
  var call$3 = functionCall;
  var aCallable = aCallable$4;
  var anObject$2 = anObject$8;
  var tryToString$1 = tryToString$3;
  var getIteratorMethod$1 = getIteratorMethod$2;
  var $TypeError$1 = TypeError;
  var getIterator$1 = function(argument, usingIterator) {
    var iteratorMethod = arguments.length < 2 ? getIteratorMethod$1(argument) : usingIterator;
    if (aCallable(iteratorMethod))
      return anObject$2(call$3(iteratorMethod, argument));
    throw new $TypeError$1(tryToString$1(argument) + " is not iterable");
  };
  var call$2 = functionCall;
  var anObject$1 = anObject$8;
  var getMethod = getMethod$3;
  var iteratorClose$1 = function(iterator2, kind, value2) {
    var innerResult, innerError;
    anObject$1(iterator2);
    try {
      innerResult = getMethod(iterator2, "return");
      if (!innerResult) {
        if (kind === "throw")
          throw value2;
        return value2;
      }
      innerResult = call$2(innerResult, iterator2);
    } catch (error) {
      innerError = true;
      innerResult = error;
    }
    if (kind === "throw")
      throw value2;
    if (innerError)
      throw innerResult;
    anObject$1(innerResult);
    return value2;
  };
  var bind = functionBindContext;
  var call$1 = functionCall;
  var anObject = anObject$8;
  var tryToString = tryToString$3;
  var isArrayIteratorMethod = isArrayIteratorMethod$1;
  var lengthOfArrayLike = lengthOfArrayLike$2;
  var isPrototypeOf$2 = objectIsPrototypeOf;
  var getIterator = getIterator$1;
  var getIteratorMethod = getIteratorMethod$2;
  var iteratorClose = iteratorClose$1;
  var $TypeError = TypeError;
  var Result = function(stopped, result) {
    this.stopped = stopped;
    this.result = result;
  };
  var ResultPrototype = Result.prototype;
  var iterate$1 = function(iterable, unboundFunction, options) {
    var that = options && options.that;
    var AS_ENTRIES = !!(options && options.AS_ENTRIES);
    var IS_RECORD = !!(options && options.IS_RECORD);
    var IS_ITERATOR = !!(options && options.IS_ITERATOR);
    var INTERRUPTED = !!(options && options.INTERRUPTED);
    var fn = bind(unboundFunction, that);
    var iterator2, iterFn, index2, length2, result, next, step;
    var stop = function(condition) {
      if (iterator2)
        iteratorClose(iterator2, "normal", condition);
      return new Result(true, condition);
    };
    var callFn = function(value2) {
      if (AS_ENTRIES) {
        anObject(value2);
        return INTERRUPTED ? fn(value2[0], value2[1], stop) : fn(value2[0], value2[1]);
      }
      return INTERRUPTED ? fn(value2, stop) : fn(value2);
    };
    if (IS_RECORD) {
      iterator2 = iterable.iterator;
    } else if (IS_ITERATOR) {
      iterator2 = iterable;
    } else {
      iterFn = getIteratorMethod(iterable);
      if (!iterFn)
        throw new $TypeError(tryToString(iterable) + " is not iterable");
      if (isArrayIteratorMethod(iterFn)) {
        for (index2 = 0, length2 = lengthOfArrayLike(iterable); length2 > index2; index2++) {
          result = callFn(iterable[index2]);
          if (result && isPrototypeOf$2(ResultPrototype, result))
            return result;
        }
        return new Result(false);
      }
      iterator2 = getIterator(iterable, iterFn);
    }
    next = IS_RECORD ? iterable.next : iterator2.next;
    while (!(step = call$1(next, iterator2)).done) {
      try {
        result = callFn(step.value);
      } catch (error) {
        iteratorClose(iterator2, "throw", error);
      }
      if (typeof result == "object" && result && isPrototypeOf$2(ResultPrototype, result))
        return result;
    }
    return new Result(false);
  };
  var classof$2 = classof$4;
  var $String = String;
  var toString$5 = function(argument) {
    if (classof$2(argument) === "Symbol")
      throw new TypeError("Cannot convert a Symbol value to a string");
    return $String(argument);
  };
  var toString$4 = toString$5;
  var normalizeStringArgument$2 = function(argument, $default) {
    return argument === void 0 ? arguments.length < 2 ? "" : $default : toString$4(argument);
  };
  var $$3 = _export;
  var isPrototypeOf$1 = objectIsPrototypeOf;
  var getPrototypeOf$2 = objectGetPrototypeOf;
  var setPrototypeOf$2 = objectSetPrototypeOf;
  var copyConstructorProperties$1 = copyConstructorProperties$2;
  var create$2 = objectCreate;
  var createNonEnumerableProperty$5 = createNonEnumerableProperty$9;
  var createPropertyDescriptor$1 = createPropertyDescriptor$5;
  var installErrorCause$1 = installErrorCause$2;
  var installErrorStack$1 = errorStackInstall;
  var iterate = iterate$1;
  var normalizeStringArgument$1 = normalizeStringArgument$2;
  var wellKnownSymbol$4 = wellKnownSymbol$a;
  var TO_STRING_TAG$2 = wellKnownSymbol$4("toStringTag");
  var $Error = Error;
  var push = [].push;
  var $AggregateError$1 = function AggregateError2(errors, message) {
    var isInstance = isPrototypeOf$1(AggregateErrorPrototype, this);
    var that;
    if (setPrototypeOf$2) {
      that = setPrototypeOf$2(new $Error(), isInstance ? getPrototypeOf$2(this) : AggregateErrorPrototype);
    } else {
      that = isInstance ? this : create$2(AggregateErrorPrototype);
      createNonEnumerableProperty$5(that, TO_STRING_TAG$2, "Error");
    }
    if (message !== void 0)
      createNonEnumerableProperty$5(that, "message", normalizeStringArgument$1(message));
    installErrorStack$1(that, $AggregateError$1, that.stack, 1);
    if (arguments.length > 2)
      installErrorCause$1(that, arguments[2]);
    var errorsArray = [];
    iterate(errors, push, { that: errorsArray });
    createNonEnumerableProperty$5(that, "errors", errorsArray);
    return that;
  };
  if (setPrototypeOf$2)
    setPrototypeOf$2($AggregateError$1, $Error);
  else
    copyConstructorProperties$1($AggregateError$1, $Error, { name: true });
  var AggregateErrorPrototype = $AggregateError$1.prototype = create$2($Error.prototype, {
    constructor: createPropertyDescriptor$1(1, $AggregateError$1),
    message: createPropertyDescriptor$1(1, ""),
    name: createPropertyDescriptor$1(1, "AggregateError")
  });
  $$3({ global: true, constructor: true, arity: 2 }, {
    AggregateError: $AggregateError$1
  });
  var defineProperty$1 = objectDefineProperty.f;
  var proxyAccessor$1 = function(Target, Source, key) {
    key in Target || defineProperty$1(Target, key, {
      configurable: true,
      get: function() {
        return Source[key];
      },
      set: function(it) {
        Source[key] = it;
      }
    });
  };
  var isCallable$2 = isCallable$d;
  var isObject$a = isObject$g;
  var setPrototypeOf$1 = objectSetPrototypeOf;
  var inheritIfRequired$1 = function($this, dummy, Wrapper) {
    var NewTarget, NewTargetPrototype;
    if (
      // it can work only with native `setPrototypeOf`
      setPrototypeOf$1 && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
      isCallable$2(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject$a(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
    )
      setPrototypeOf$1($this, NewTargetPrototype);
    return $this;
  };
  var getBuiltIn$1 = getBuiltIn$5;
  var createNonEnumerableProperty$4 = createNonEnumerableProperty$9;
  var isPrototypeOf = objectIsPrototypeOf;
  var setPrototypeOf = objectSetPrototypeOf;
  var copyConstructorProperties = copyConstructorProperties$2;
  var proxyAccessor = proxyAccessor$1;
  var inheritIfRequired = inheritIfRequired$1;
  var normalizeStringArgument = normalizeStringArgument$2;
  var installErrorCause = installErrorCause$2;
  var installErrorStack = errorStackInstall;
  var DESCRIPTORS$1 = descriptors;
  var wrapErrorConstructorWithCause$2 = function(FULL_NAME, wrapper, FORCED2, IS_AGGREGATE_ERROR) {
    var STACK_TRACE_LIMIT = "stackTraceLimit";
    var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;
    var path2 = FULL_NAME.split(".");
    var ERROR_NAME = path2[path2.length - 1];
    var OriginalError = getBuiltIn$1.apply(null, path2);
    if (!OriginalError)
      return;
    var OriginalErrorPrototype = OriginalError.prototype;
    if (!FORCED2)
      return OriginalError;
    var BaseError = getBuiltIn$1("Error");
    var WrappedError = wrapper(function(a, b) {
      var message = normalizeStringArgument(IS_AGGREGATE_ERROR ? b : a, void 0);
      var result = IS_AGGREGATE_ERROR ? new OriginalError(a) : new OriginalError();
      if (message !== void 0)
        createNonEnumerableProperty$4(result, "message", message);
      installErrorStack(result, WrappedError, result.stack, 2);
      if (this && isPrototypeOf(OriginalErrorPrototype, this))
        inheritIfRequired(result, this, WrappedError);
      if (arguments.length > OPTIONS_POSITION)
        installErrorCause(result, arguments[OPTIONS_POSITION]);
      return result;
    });
    WrappedError.prototype = OriginalErrorPrototype;
    if (ERROR_NAME !== "Error") {
      if (setPrototypeOf)
        setPrototypeOf(WrappedError, BaseError);
      else
        copyConstructorProperties(WrappedError, BaseError, { name: true });
    } else if (DESCRIPTORS$1 && STACK_TRACE_LIMIT in OriginalError) {
      proxyAccessor(WrappedError, OriginalError, STACK_TRACE_LIMIT);
      proxyAccessor(WrappedError, OriginalError, "prepareStackTrace");
    }
    copyConstructorProperties(WrappedError, OriginalError);
    return WrappedError;
  };
  var $$2 = _export;
  var global$4 = global$d;
  var apply$1 = functionApply;
  var wrapErrorConstructorWithCause$1 = wrapErrorConstructorWithCause$2;
  var WEB_ASSEMBLY = "WebAssembly";
  var WebAssembly = global$4[WEB_ASSEMBLY];
  var FORCED$1 = new Error("e", { cause: 7 }).cause !== 7;
  var exportGlobalErrorCauseWrapper = function(ERROR_NAME, wrapper) {
    var O = {};
    O[ERROR_NAME] = wrapErrorConstructorWithCause$1(ERROR_NAME, wrapper, FORCED$1);
    $$2({ global: true, constructor: true, arity: 1, forced: FORCED$1 }, O);
  };
  var exportWebAssemblyErrorCauseWrapper = function(ERROR_NAME, wrapper) {
    if (WebAssembly && WebAssembly[ERROR_NAME]) {
      var O = {};
      O[ERROR_NAME] = wrapErrorConstructorWithCause$1(WEB_ASSEMBLY + "." + ERROR_NAME, wrapper, FORCED$1);
      $$2({ target: WEB_ASSEMBLY, stat: true, constructor: true, arity: 1, forced: FORCED$1 }, O);
    }
  };
  exportGlobalErrorCauseWrapper("Error", function(init2) {
    return function Error2(message) {
      return apply$1(init2, this, arguments);
    };
  });
  exportGlobalErrorCauseWrapper("EvalError", function(init2) {
    return function EvalError2(message) {
      return apply$1(init2, this, arguments);
    };
  });
  exportGlobalErrorCauseWrapper("RangeError", function(init2) {
    return function RangeError2(message) {
      return apply$1(init2, this, arguments);
    };
  });
  exportGlobalErrorCauseWrapper("ReferenceError", function(init2) {
    return function ReferenceError2(message) {
      return apply$1(init2, this, arguments);
    };
  });
  exportGlobalErrorCauseWrapper("SyntaxError", function(init2) {
    return function SyntaxError2(message) {
      return apply$1(init2, this, arguments);
    };
  });
  exportGlobalErrorCauseWrapper("TypeError", function(init2) {
    return function TypeError2(message) {
      return apply$1(init2, this, arguments);
    };
  });
  exportGlobalErrorCauseWrapper("URIError", function(init2) {
    return function URIError2(message) {
      return apply$1(init2, this, arguments);
    };
  });
  exportWebAssemblyErrorCauseWrapper("CompileError", function(init2) {
    return function CompileError(message) {
      return apply$1(init2, this, arguments);
    };
  });
  exportWebAssemblyErrorCauseWrapper("LinkError", function(init2) {
    return function LinkError(message) {
      return apply$1(init2, this, arguments);
    };
  });
  exportWebAssemblyErrorCauseWrapper("RuntimeError", function(init2) {
    return function RuntimeError(message) {
      return apply$1(init2, this, arguments);
    };
  });
  var $$1 = _export;
  var getBuiltIn = getBuiltIn$5;
  var apply = functionApply;
  var fails$1 = fails$b;
  var wrapErrorConstructorWithCause = wrapErrorConstructorWithCause$2;
  var AGGREGATE_ERROR = "AggregateError";
  var $AggregateError = getBuiltIn(AGGREGATE_ERROR);
  var FORCED = !fails$1(function() {
    return $AggregateError([1]).errors[0] !== 1;
  }) && fails$1(function() {
    return $AggregateError([1], AGGREGATE_ERROR, { cause: 7 }).cause !== 7;
  });
  $$1({ global: true, constructor: true, arity: 2, forced: FORCED }, {
    AggregateError: wrapErrorConstructorWithCause(AGGREGATE_ERROR, function(init2) {
      return function AggregateError2(errors, message) {
        return apply(init2, this, arguments);
      };
    }, FORCED, true)
  });
  var global$3 = global$d;
  var isCallable$1 = isCallable$d;
  var WeakMap$4 = global$3.WeakMap;
  var weakMapBasicDetection = isCallable$1(WeakMap$4) && /native code/.test(String(WeakMap$4));
  var NATIVE_WEAK_MAP = weakMapBasicDetection;
  var global$2 = global$d;
  var isObject$9 = isObject$g;
  var createNonEnumerableProperty$3 = createNonEnumerableProperty$9;
  var hasOwn$2 = hasOwnProperty_1;
  var shared = sharedStore;
  var sharedKey = sharedKey$3;
  var hiddenKeys = hiddenKeys$4;
  var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
  var TypeError$1 = global$2.TypeError;
  var WeakMap$3 = global$2.WeakMap;
  var set, get$2, has;
  var enforce = function(it) {
    return has(it) ? get$2(it) : set(it, {});
  };
  var getterFor = function(TYPE) {
    return function(it) {
      var state2;
      if (!isObject$9(it) || (state2 = get$2(it)).type !== TYPE) {
        throw new TypeError$1("Incompatible receiver, " + TYPE + " required");
      }
      return state2;
    };
  };
  if (NATIVE_WEAK_MAP || shared.state) {
    var store = shared.state || (shared.state = new WeakMap$3());
    store.get = store.get;
    store.has = store.has;
    store.set = store.set;
    set = function(it, metadata) {
      if (store.has(it))
        throw new TypeError$1(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      store.set(it, metadata);
      return metadata;
    };
    get$2 = function(it) {
      return store.get(it) || {};
    };
    has = function(it) {
      return store.has(it);
    };
  } else {
    var STATE = sharedKey("state");
    hiddenKeys[STATE] = true;
    set = function(it, metadata) {
      if (hasOwn$2(it, STATE))
        throw new TypeError$1(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it;
      createNonEnumerableProperty$3(it, STATE, metadata);
      return metadata;
    };
    get$2 = function(it) {
      return hasOwn$2(it, STATE) ? it[STATE] : {};
    };
    has = function(it) {
      return hasOwn$2(it, STATE);
    };
  }
  var internalState = {
    set,
    get: get$2,
    has,
    enforce,
    getterFor
  };
  var DESCRIPTORS = descriptors;
  var hasOwn$1 = hasOwnProperty_1;
  var FunctionPrototype = Function.prototype;
  var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
  var EXISTS = hasOwn$1(FunctionPrototype, "name");
  var PROPER = EXISTS && (function something() {
  }).name === "something";
  var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
  var functionName = {
    EXISTS,
    PROPER,
    CONFIGURABLE
  };
  var createNonEnumerableProperty$2 = createNonEnumerableProperty$9;
  var defineBuiltIn$2 = function(target, key, value2, options) {
    if (options && options.enumerable)
      target[key] = value2;
    else
      createNonEnumerableProperty$2(target, key, value2);
    return target;
  };
  var fails = fails$b;
  var isCallable = isCallable$d;
  var isObject$8 = isObject$g;
  var create$1 = objectCreate;
  var getPrototypeOf$1 = objectGetPrototypeOf;
  var defineBuiltIn$1 = defineBuiltIn$2;
  var wellKnownSymbol$3 = wellKnownSymbol$a;
  var ITERATOR$1 = wellKnownSymbol$3("iterator");
  var BUGGY_SAFARI_ITERATORS$1 = false;
  var IteratorPrototype$1, PrototypeOfArrayIteratorPrototype, arrayIterator;
  if ([].keys) {
    arrayIterator = [].keys();
    if (!("next" in arrayIterator))
      BUGGY_SAFARI_ITERATORS$1 = true;
    else {
      PrototypeOfArrayIteratorPrototype = getPrototypeOf$1(getPrototypeOf$1(arrayIterator));
      if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
        IteratorPrototype$1 = PrototypeOfArrayIteratorPrototype;
    }
  }
  var NEW_ITERATOR_PROTOTYPE = !isObject$8(IteratorPrototype$1) || fails(function() {
    var test2 = {};
    return IteratorPrototype$1[ITERATOR$1].call(test2) !== test2;
  });
  if (NEW_ITERATOR_PROTOTYPE)
    IteratorPrototype$1 = {};
  else
    IteratorPrototype$1 = create$1(IteratorPrototype$1);
  if (!isCallable(IteratorPrototype$1[ITERATOR$1])) {
    defineBuiltIn$1(IteratorPrototype$1, ITERATOR$1, function() {
      return this;
    });
  }
  var iteratorsCore = {
    IteratorPrototype: IteratorPrototype$1,
    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
  };
  var TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;
  var classof$1 = classof$4;
  var objectToString$2 = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString2() {
    return "[object " + classof$1(this) + "]";
  };
  var TO_STRING_TAG_SUPPORT = toStringTagSupport;
  var defineProperty = objectDefineProperty.f;
  var createNonEnumerableProperty$1 = createNonEnumerableProperty$9;
  var hasOwn = hasOwnProperty_1;
  var toString$3 = objectToString$2;
  var wellKnownSymbol$2 = wellKnownSymbol$a;
  var TO_STRING_TAG$1 = wellKnownSymbol$2("toStringTag");
  var setToStringTag$2 = function(it, TAG2, STATIC, SET_METHOD) {
    if (it) {
      var target = STATIC ? it : it.prototype;
      if (!hasOwn(target, TO_STRING_TAG$1)) {
        defineProperty(target, TO_STRING_TAG$1, { configurable: true, value: TAG2 });
      }
      if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
        createNonEnumerableProperty$1(target, "toString", toString$3);
      }
    }
  };
  var IteratorPrototype = iteratorsCore.IteratorPrototype;
  var create = objectCreate;
  var createPropertyDescriptor = createPropertyDescriptor$5;
  var setToStringTag$1 = setToStringTag$2;
  var Iterators$3 = iterators;
  var returnThis$1 = function() {
    return this;
  };
  var iteratorCreateConstructor = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
    var TO_STRING_TAG2 = NAME + " Iterator";
    IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
    setToStringTag$1(IteratorConstructor, TO_STRING_TAG2, false, true);
    Iterators$3[TO_STRING_TAG2] = returnThis$1;
    return IteratorConstructor;
  };
  var $ = _export;
  var call = functionCall;
  var FunctionName = functionName;
  var createIteratorConstructor = iteratorCreateConstructor;
  var getPrototypeOf = objectGetPrototypeOf;
  var setToStringTag = setToStringTag$2;
  var defineBuiltIn = defineBuiltIn$2;
  var wellKnownSymbol$1 = wellKnownSymbol$a;
  var Iterators$2 = iterators;
  var IteratorsCore = iteratorsCore;
  var PROPER_FUNCTION_NAME = FunctionName.PROPER;
  FunctionName.CONFIGURABLE;
  IteratorsCore.IteratorPrototype;
  var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
  var ITERATOR = wellKnownSymbol$1("iterator");
  var KEYS = "keys";
  var VALUES = "values";
  var ENTRIES = "entries";
  var returnThis = function() {
    return this;
  };
  var iteratorDefine = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED2) {
    createIteratorConstructor(IteratorConstructor, NAME, next);
    var getIterationMethod = function(KIND) {
      if (KIND === DEFAULT && defaultIterator)
        return defaultIterator;
      if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype)
        return IterablePrototype[KIND];
      switch (KIND) {
        case KEYS:
          return function keys2() {
            return new IteratorConstructor(this, KIND);
          };
        case VALUES:
          return function values2() {
            return new IteratorConstructor(this, KIND);
          };
        case ENTRIES:
          return function entries() {
            return new IteratorConstructor(this, KIND);
          };
      }
      return function() {
        return new IteratorConstructor(this);
      };
    };
    var TO_STRING_TAG2 = NAME + " Iterator";
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY;
    if (anyNativeIterator) {
      CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
      if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
        setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG2, true, true);
        Iterators$2[TO_STRING_TAG2] = returnThis;
      }
    }
    if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
      {
        INCORRECT_VALUES_NAME = true;
        defaultIterator = function values2() {
          return call(nativeIterator, this);
        };
      }
    }
    if (DEFAULT) {
      methods = {
        values: getIterationMethod(VALUES),
        keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
        entries: getIterationMethod(ENTRIES)
      };
      if (FORCED2)
        for (KEY in methods) {
          if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
            defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
          }
        }
      else
        $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
    }
    if (FORCED2 && IterablePrototype[ITERATOR] !== defaultIterator) {
      defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
    }
    Iterators$2[NAME] = defaultIterator;
    return methods;
  };
  var createIterResultObject$2 = function(value2, done) {
    return { value: value2, done };
  };
  var toIndexedObject = toIndexedObject$5;
  var Iterators$1 = iterators;
  var InternalStateModule$1 = internalState;
  objectDefineProperty.f;
  var defineIterator$1 = iteratorDefine;
  var createIterResultObject$1 = createIterResultObject$2;
  var ARRAY_ITERATOR = "Array Iterator";
  var setInternalState$1 = InternalStateModule$1.set;
  var getInternalState$1 = InternalStateModule$1.getterFor(ARRAY_ITERATOR);
  defineIterator$1(Array, "Array", function(iterated, kind) {
    setInternalState$1(this, {
      type: ARRAY_ITERATOR,
      target: toIndexedObject(iterated),
      // target
      index: 0,
      // next index
      kind
      // kind
    });
  }, function() {
    var state2 = getInternalState$1(this);
    var target = state2.target;
    var kind = state2.kind;
    var index2 = state2.index++;
    if (!target || index2 >= target.length) {
      state2.target = void 0;
      return createIterResultObject$1(void 0, true);
    }
    switch (kind) {
      case "keys":
        return createIterResultObject$1(index2, false);
      case "values":
        return createIterResultObject$1(target[index2], false);
    }
    return createIterResultObject$1([index2, target[index2]], false);
  }, "values");
  Iterators$1.Arguments = Iterators$1.Array;
  var uncurryThis = functionUncurryThis;
  var toIntegerOrInfinity = toIntegerOrInfinity$3;
  var toString$2 = toString$5;
  var requireObjectCoercible = requireObjectCoercible$3;
  var charAt$1 = uncurryThis("".charAt);
  var charCodeAt = uncurryThis("".charCodeAt);
  var stringSlice = uncurryThis("".slice);
  var createMethod = function(CONVERT_TO_STRING) {
    return function($this, pos) {
      var S = toString$2(requireObjectCoercible($this));
      var position2 = toIntegerOrInfinity(pos);
      var size = S.length;
      var first2, second;
      if (position2 < 0 || position2 >= size)
        return CONVERT_TO_STRING ? "" : void 0;
      first2 = charCodeAt(S, position2);
      return first2 < 55296 || first2 > 56319 || position2 + 1 === size || (second = charCodeAt(S, position2 + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt$1(S, position2) : first2 : CONVERT_TO_STRING ? stringSlice(S, position2, position2 + 2) : (first2 - 55296 << 10) + (second - 56320) + 65536;
    };
  };
  var stringMultibyte = {
    // `String.prototype.codePointAt` method
    // https://tc39.es/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod(true)
  };
  var charAt = stringMultibyte.charAt;
  var toString$1 = toString$5;
  var InternalStateModule = internalState;
  var defineIterator = iteratorDefine;
  var createIterResultObject = createIterResultObject$2;
  var STRING_ITERATOR = "String Iterator";
  var setInternalState = InternalStateModule.set;
  var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
  defineIterator(String, "String", function(iterated) {
    setInternalState(this, {
      type: STRING_ITERATOR,
      string: toString$1(iterated),
      index: 0
    });
  }, function next() {
    var state2 = getInternalState(this);
    var string = state2.string;
    var index2 = state2.index;
    var point;
    if (index2 >= string.length)
      return createIterResultObject(void 0, true);
    point = charAt(string, index2);
    state2.index += point.length;
    return createIterResultObject(point, false);
  });
  var path$1 = path$4;
  var aggregateError$5 = path$1.AggregateError;
  var domIterables = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  };
  var DOMIterables = domIterables;
  var global$1 = global$d;
  var classof = classof$4;
  var createNonEnumerableProperty = createNonEnumerableProperty$9;
  var Iterators = iterators;
  var wellKnownSymbol = wellKnownSymbol$a;
  var TO_STRING_TAG = wellKnownSymbol("toStringTag");
  for (var COLLECTION_NAME in DOMIterables) {
    var Collection = global$1[COLLECTION_NAME];
    var CollectionPrototype = Collection && Collection.prototype;
    if (CollectionPrototype && classof(CollectionPrototype) !== TO_STRING_TAG) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    Iterators[COLLECTION_NAME] = Iterators.Array;
  }
  var parent$2 = aggregateError$5;
  var aggregateError$4 = parent$2;
  var parent$1 = aggregateError$4;
  var aggregateError$3 = parent$1;
  var parent = aggregateError$3;
  var aggregateError$2 = parent;
  var aggregateError$1 = aggregateError$2;
  var aggregateError = aggregateError$1;
  const _AggregateError = /* @__PURE__ */ getDefaultExportFromCjs(aggregateError);
  class ApiDOMAggregateError extends _AggregateError {
    constructor(errors, message, options) {
      super(errors, message, options);
      this.name = this.constructor.name;
      if (typeof message === "string") {
        this.message = message;
      }
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error(message).stack;
      }
      if (isPlainObject$1(options) && hasIn$1("cause", options) && !hasIn$1("cause", this)) {
        const {
          cause
        } = options;
        this.cause = cause;
        if (cause instanceof Error && hasIn$1("stack", cause)) {
          this.stack = `${this.stack}
CAUSE: ${cause === null || cause === void 0 ? void 0 : cause.stack}`;
        }
      }
    }
  }
  const ApiDOMAggregateError$1 = ApiDOMAggregateError;
  class ApiDOMError extends Error {
    static [Symbol.hasInstance](instance) {
      return super[Symbol.hasInstance](instance) || Function.prototype[Symbol.hasInstance].call(ApiDOMAggregateError$1, instance);
    }
    constructor(message, options) {
      super(message, options);
      this.name = this.constructor.name;
      if (typeof message === "string") {
        this.message = message;
      }
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error(message).stack;
      }
      if (isPlainObject$1(options) && hasIn$1("cause", options) && !hasIn$1("cause", this)) {
        const {
          cause
        } = options;
        this.cause = cause;
        if (cause instanceof Error && hasIn$1("stack", cause)) {
          this.stack = `${this.stack}
CAUSE: ${cause === null || cause === void 0 ? void 0 : cause.stack}`;
        }
      }
    }
  }
  const ApiDOMError$1 = ApiDOMError;
  class ApiDOMStructuredError extends ApiDOMError$1 {
    constructor(message, structuredOptions) {
      super(message, structuredOptions);
      if (typeof structuredOptions !== "undefined") {
        Object.assign(this, omit$2(["cause"], structuredOptions));
      }
    }
  }
  const ApiDOMStructuredError$1 = ApiDOMStructuredError;
  class UnsupportedOperationError extends ApiDOMError$1 {
  }
  const UnsupportedOperationError$1 = UnsupportedOperationError;
  let NotImplementedError$2 = class NotImplementedError extends UnsupportedOperationError$1 {
  };
  const NotImplementedError$3 = NotImplementedError$2;
  class NotImplementedError extends ApiDOMError$1 {
    constructor(message = "Not Implemented", options) {
      super(message, options);
    }
  }
  const NotImplementedError$1 = NotImplementedError;
  class ResolverError extends ApiDOMError$1 {
  }
  const ResolverError$1 = ResolverError;
  class UnmatchedResolverError extends ResolverError$1 {
  }
  const UnmatchedResolverError$1 = UnmatchedResolverError;
  class ParserError extends ApiDOMError$1 {
  }
  const ParserError$1 = ParserError;
  class PluginError extends ApiDOMError$1 {
    constructor(message, options) {
      super(message, {
        cause: options.cause
      });
      this.plugin = options.plugin;
    }
  }
  const PluginError$1 = PluginError;
  class InvalidSelectorError extends ApiDOMError$1 {
  }
  const InvalidSelectorError$1 = InvalidSelectorError;
  class MaximumResolverDepthError extends ResolverError$1 {
  }
  const MaximumResolverDepthError$1 = MaximumResolverDepthError;
  class DereferenceError extends ApiDOMError$1 {
  }
  const DereferenceError$1 = DereferenceError;
  class UnmatchedDereferenceStrategyError extends ParserError$1 {
  }
  const UnmatchedDereferenceStrategyError$1 = UnmatchedDereferenceStrategyError;
  class MaximumDereferenceDepthError extends DereferenceError$1 {
  }
  const MaximumDereferenceDepthError$1 = MaximumDereferenceDepthError;
  const filter$4 = async (method, file, plugins2) => {
    const pluginResults = await Promise.all(plugins2.map(invokeArgs$1([method], [file])));
    return plugins2.filter((plugin2, index2) => pluginResults[index2]);
  };
  const run = async (method, parameters2, plugins2) => {
    let lastError;
    for (const plugin2 of plugins2) {
      try {
        const result = await plugin2[method].call(plugin2, ...parameters2);
        return {
          plugin: plugin2,
          result
        };
      } catch (error) {
        lastError = new PluginError$1("Error while running plugin", {
          cause: error,
          plugin: plugin2
        });
      }
    }
    return Promise.reject(lastError);
  };
  const readFile = async (file, options) => {
    const optsBoundResolvers = options.resolve.resolvers.map((resolver) => {
      const clonedResolver = Object.create(resolver);
      return Object.assign(clonedResolver, options.resolve.resolverOpts);
    });
    const resolvers = await filter$4("canRead", file, optsBoundResolvers);
    if (isEmpty$2(resolvers)) {
      throw new UnmatchedResolverError$1(file.uri);
    }
    try {
      const {
        result
      } = await run("read", [file], resolvers);
      return result;
    } catch (error) {
      throw new ResolverError$1(`Error while reading file "${file.uri}"`, {
        cause: error
      });
    }
  };
  const parseFile = async (file, options) => {
    const optsBoundParsers = options.parse.parsers.map((parser2) => {
      const clonedParser = Object.create(parser2);
      return Object.assign(clonedParser, options.parse.parserOpts);
    });
    const parsers = await filter$4("canParse", file, optsBoundParsers);
    if (isEmpty$2(parsers)) {
      throw new UnmatchedResolverError$1(file.uri);
    }
    try {
      const {
        plugin: plugin2,
        result
      } = await run("parse", [file], parsers);
      if (!plugin2.allowEmpty && result.isEmpty) {
        return Promise.reject(new ParserError$1(`Error while parsing file "${file.uri}". File is empty.`));
      }
      return result;
    } catch (error) {
      throw new ParserError$1(`Error while parsing file "${file.uri}"`, {
        cause: error
      });
    }
  };
  const parse$4 = async (uri, options) => {
    const file = File$2({
      uri: sanitize(stripHash(uri)),
      mediaType: options.parse.mediaType
    });
    const data2 = await readFile(file, options);
    return parseFile(File$2({
      ...file,
      data: data2
    }), options);
  };
  const parse$5 = parse$4;
  function isNull$1(value2) {
    return value2 === null;
  }
  var isNull_1 = isNull$1;
  var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var _freeGlobal = freeGlobal$1;
  var freeGlobal = _freeGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root$9 = freeGlobal || freeSelf || Function("return this")();
  var _root = root$9;
  var root$8 = _root;
  var Symbol$4 = root$8.Symbol;
  var _Symbol = Symbol$4;
  var Symbol$3 = _Symbol;
  var objectProto$b = Object.prototype;
  var hasOwnProperty$a = objectProto$b.hasOwnProperty;
  var nativeObjectToString$1 = objectProto$b.toString;
  var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : void 0;
  function getRawTag$1(value2) {
    var isOwn = hasOwnProperty$a.call(value2, symToStringTag$1), tag = value2[symToStringTag$1];
    try {
      value2[symToStringTag$1] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString$1.call(value2);
    if (unmasked) {
      if (isOwn) {
        value2[symToStringTag$1] = tag;
      } else {
        delete value2[symToStringTag$1];
      }
    }
    return result;
  }
  var _getRawTag = getRawTag$1;
  var objectProto$a = Object.prototype;
  var nativeObjectToString = objectProto$a.toString;
  function objectToString$1(value2) {
    return nativeObjectToString.call(value2);
  }
  var _objectToString = objectToString$1;
  var Symbol$2 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
  function baseGetTag$7(value2) {
    if (value2 == null) {
      return value2 === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
  }
  var _baseGetTag = baseGetTag$7;
  var isArray$6 = Array.isArray;
  var isArray_1 = isArray$6;
  function isObjectLike$7(value2) {
    return value2 != null && typeof value2 == "object";
  }
  var isObjectLike_1 = isObjectLike$7;
  var baseGetTag$6 = _baseGetTag, isArray$5 = isArray_1, isObjectLike$6 = isObjectLike_1;
  var stringTag$2 = "[object String]";
  function isString$2(value2) {
    return typeof value2 == "string" || !isArray$5(value2) && isObjectLike$6(value2) && baseGetTag$6(value2) == stringTag$2;
  }
  var isString_1 = isString$2;
  var baseGetTag$5 = _baseGetTag, isObjectLike$5 = isObjectLike_1;
  var numberTag$2 = "[object Number]";
  function isNumber$2(value2) {
    return typeof value2 == "number" || isObjectLike$5(value2) && baseGetTag$5(value2) == numberTag$2;
  }
  var isNumber_1 = isNumber$2;
  var baseGetTag$4 = _baseGetTag, isObjectLike$4 = isObjectLike_1;
  var boolTag$2 = "[object Boolean]";
  function isBoolean$2(value2) {
    return value2 === true || value2 === false || isObjectLike$4(value2) && baseGetTag$4(value2) == boolTag$2;
  }
  var isBoolean_1 = isBoolean$2;
  function isObject$7(value2) {
    var type2 = typeof value2;
    return value2 != null && (type2 == "object" || type2 == "function");
  }
  var isObject_1$1 = isObject$7;
  let JSONSerialiser$1 = class JSONSerialiser {
    constructor(namespace2) {
      this.namespace = namespace2 || new this.Namespace();
    }
    /**
     * @param {Element} element
     * @returns {object}
     */
    serialise(element) {
      if (!(element instanceof this.namespace.elements.Element)) {
        throw new TypeError(`Given element \`${element}\` is not an Element instance`);
      }
      const payload = {
        element: element.element
      };
      if (element._meta && element._meta.length > 0) {
        payload.meta = this.serialiseObject(element.meta);
      }
      if (element._attributes && element._attributes.length > 0) {
        payload.attributes = this.serialiseObject(element.attributes);
      }
      const content = this.serialiseContent(element.content);
      if (content !== void 0) {
        payload.content = content;
      }
      return payload;
    }
    /**
     * @param {object} value
     * @returns {Element}
     */
    deserialise(value2) {
      if (!value2.element) {
        throw new Error("Given value is not an object containing an element name");
      }
      const ElementClass = this.namespace.getElementClass(value2.element);
      const element = new ElementClass();
      if (element.element !== value2.element) {
        element.element = value2.element;
      }
      if (value2.meta) {
        this.deserialiseObject(value2.meta, element.meta);
      }
      if (value2.attributes) {
        this.deserialiseObject(value2.attributes, element.attributes);
      }
      const content = this.deserialiseContent(value2.content);
      if (content !== void 0 || element.content === null) {
        element.content = content;
      }
      return element;
    }
    // Private API
    serialiseContent(content) {
      if (content instanceof this.namespace.elements.Element) {
        return this.serialise(content);
      }
      if (content instanceof this.namespace.KeyValuePair) {
        const pair = {
          key: this.serialise(content.key)
        };
        if (content.value) {
          pair.value = this.serialise(content.value);
        }
        return pair;
      }
      if (content && content.map) {
        if (content.length === 0) {
          return void 0;
        }
        return content.map(this.serialise, this);
      }
      return content;
    }
    deserialiseContent(content) {
      if (content) {
        if (content.element) {
          return this.deserialise(content);
        }
        if (content.key) {
          const pair = new this.namespace.KeyValuePair(this.deserialise(content.key));
          if (content.value) {
            pair.value = this.deserialise(content.value);
          }
          return pair;
        }
        if (content.map) {
          return content.map(this.deserialise, this);
        }
      }
      return content;
    }
    serialiseObject(obj) {
      const result = {};
      obj.forEach((value2, key) => {
        if (value2) {
          result[key.toValue()] = this.serialise(value2);
        }
      });
      if (Object.keys(result).length === 0) {
        return void 0;
      }
      return result;
    }
    deserialiseObject(from2, to) {
      Object.keys(from2).forEach((key) => {
        to.set(key, this.deserialise(from2[key]));
      });
    }
  };
  var JSONSerialiser_1 = JSONSerialiser$1;
  function listCacheClear$1() {
    this.__data__ = [];
    this.size = 0;
  }
  var _listCacheClear = listCacheClear$1;
  function eq$2(value2, other) {
    return value2 === other || value2 !== value2 && other !== other;
  }
  var eq_1 = eq$2;
  var eq$1 = eq_1;
  function assocIndexOf$4(array, key) {
    var length2 = array.length;
    while (length2--) {
      if (eq$1(array[length2][0], key)) {
        return length2;
      }
    }
    return -1;
  }
  var _assocIndexOf = assocIndexOf$4;
  var assocIndexOf$3 = _assocIndexOf;
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete$1(key) {
    var data2 = this.__data__, index2 = assocIndexOf$3(data2, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data2.length - 1;
    if (index2 == lastIndex) {
      data2.pop();
    } else {
      splice.call(data2, index2, 1);
    }
    --this.size;
    return true;
  }
  var _listCacheDelete = listCacheDelete$1;
  var assocIndexOf$2 = _assocIndexOf;
  function listCacheGet$1(key) {
    var data2 = this.__data__, index2 = assocIndexOf$2(data2, key);
    return index2 < 0 ? void 0 : data2[index2][1];
  }
  var _listCacheGet = listCacheGet$1;
  var assocIndexOf$1 = _assocIndexOf;
  function listCacheHas$1(key) {
    return assocIndexOf$1(this.__data__, key) > -1;
  }
  var _listCacheHas = listCacheHas$1;
  var assocIndexOf = _assocIndexOf;
  function listCacheSet$1(key, value2) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key);
    if (index2 < 0) {
      ++this.size;
      data2.push([key, value2]);
    } else {
      data2[index2][1] = value2;
    }
    return this;
  }
  var _listCacheSet = listCacheSet$1;
  var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
  function ListCache$4(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache$4.prototype.clear = listCacheClear;
  ListCache$4.prototype["delete"] = listCacheDelete;
  ListCache$4.prototype.get = listCacheGet;
  ListCache$4.prototype.has = listCacheHas;
  ListCache$4.prototype.set = listCacheSet;
  var _ListCache = ListCache$4;
  var ListCache$3 = _ListCache;
  function stackClear$1() {
    this.__data__ = new ListCache$3();
    this.size = 0;
  }
  var _stackClear = stackClear$1;
  function stackDelete$1(key) {
    var data2 = this.__data__, result = data2["delete"](key);
    this.size = data2.size;
    return result;
  }
  var _stackDelete = stackDelete$1;
  function stackGet$1(key) {
    return this.__data__.get(key);
  }
  var _stackGet = stackGet$1;
  function stackHas$1(key) {
    return this.__data__.has(key);
  }
  var _stackHas = stackHas$1;
  var baseGetTag$3 = _baseGetTag, isObject$6 = isObject_1$1;
  var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction$5(value2) {
    if (!isObject$6(value2)) {
      return false;
    }
    var tag = baseGetTag$3(value2);
    return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  var isFunction_1 = isFunction$5;
  var root$7 = _root;
  var coreJsData$1 = root$7["__core-js_shared__"];
  var _coreJsData = coreJsData$1;
  var coreJsData = _coreJsData;
  var maskSrcKey = function() {
    var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid2 ? "Symbol(src)_1." + uid2 : "";
  }();
  function isMasked$1(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var _isMasked = isMasked$1;
  var funcProto$1 = Function.prototype;
  var funcToString$1 = funcProto$1.toString;
  function toSource$2(func) {
    if (func != null) {
      try {
        return funcToString$1.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  var _toSource = toSource$2;
  var isFunction$4 = isFunction_1, isMasked = _isMasked, isObject$5 = isObject_1$1, toSource$1 = _toSource;
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype, objectProto$9 = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty$9 = objectProto$9.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty$9).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative$1(value2) {
    if (!isObject$5(value2) || isMasked(value2)) {
      return false;
    }
    var pattern = isFunction$4(value2) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource$1(value2));
  }
  var _baseIsNative = baseIsNative$1;
  function getValue$1(object, key) {
    return object == null ? void 0 : object[key];
  }
  var _getValue = getValue$1;
  var baseIsNative = _baseIsNative, getValue = _getValue;
  function getNative$6(object, key) {
    var value2 = getValue(object, key);
    return baseIsNative(value2) ? value2 : void 0;
  }
  var _getNative = getNative$6;
  var getNative$5 = _getNative, root$6 = _root;
  var Map$4 = getNative$5(root$6, "Map");
  var _Map = Map$4;
  var getNative$4 = _getNative;
  var nativeCreate$4 = getNative$4(Object, "create");
  var _nativeCreate = nativeCreate$4;
  var nativeCreate$3 = _nativeCreate;
  function hashClear$1() {
    this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
    this.size = 0;
  }
  var _hashClear = hashClear$1;
  function hashDelete$1(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  var _hashDelete = hashDelete$1;
  var nativeCreate$2 = _nativeCreate;
  var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
  var objectProto$8 = Object.prototype;
  var hasOwnProperty$8 = objectProto$8.hasOwnProperty;
  function hashGet$1(key) {
    var data2 = this.__data__;
    if (nativeCreate$2) {
      var result = data2[key];
      return result === HASH_UNDEFINED$2 ? void 0 : result;
    }
    return hasOwnProperty$8.call(data2, key) ? data2[key] : void 0;
  }
  var _hashGet = hashGet$1;
  var nativeCreate$1 = _nativeCreate;
  var objectProto$7 = Object.prototype;
  var hasOwnProperty$7 = objectProto$7.hasOwnProperty;
  function hashHas$1(key) {
    var data2 = this.__data__;
    return nativeCreate$1 ? data2[key] !== void 0 : hasOwnProperty$7.call(data2, key);
  }
  var _hashHas = hashHas$1;
  var nativeCreate = _nativeCreate;
  var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
  function hashSet$1(key, value2) {
    var data2 = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data2[key] = nativeCreate && value2 === void 0 ? HASH_UNDEFINED$1 : value2;
    return this;
  }
  var _hashSet = hashSet$1;
  var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
  function Hash$1(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  Hash$1.prototype.clear = hashClear;
  Hash$1.prototype["delete"] = hashDelete;
  Hash$1.prototype.get = hashGet;
  Hash$1.prototype.has = hashHas;
  Hash$1.prototype.set = hashSet;
  var _Hash = Hash$1;
  var Hash = _Hash, ListCache$2 = _ListCache, Map$3 = _Map;
  function mapCacheClear$1() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map$3 || ListCache$2)(),
      "string": new Hash()
    };
  }
  var _mapCacheClear = mapCacheClear$1;
  function isKeyable$1(value2) {
    var type2 = typeof value2;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value2 !== "__proto__" : value2 === null;
  }
  var _isKeyable = isKeyable$1;
  var isKeyable = _isKeyable;
  function getMapData$4(map2, key) {
    var data2 = map2.__data__;
    return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
  }
  var _getMapData = getMapData$4;
  var getMapData$3 = _getMapData;
  function mapCacheDelete$1(key) {
    var result = getMapData$3(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  var _mapCacheDelete = mapCacheDelete$1;
  var getMapData$2 = _getMapData;
  function mapCacheGet$1(key) {
    return getMapData$2(this, key).get(key);
  }
  var _mapCacheGet = mapCacheGet$1;
  var getMapData$1 = _getMapData;
  function mapCacheHas$1(key) {
    return getMapData$1(this, key).has(key);
  }
  var _mapCacheHas = mapCacheHas$1;
  var getMapData = _getMapData;
  function mapCacheSet$1(key, value2) {
    var data2 = getMapData(this, key), size = data2.size;
    data2.set(key, value2);
    this.size += data2.size == size ? 0 : 1;
    return this;
  }
  var _mapCacheSet = mapCacheSet$1;
  var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
  function MapCache$2(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache$2.prototype.clear = mapCacheClear;
  MapCache$2.prototype["delete"] = mapCacheDelete;
  MapCache$2.prototype.get = mapCacheGet;
  MapCache$2.prototype.has = mapCacheHas;
  MapCache$2.prototype.set = mapCacheSet;
  var _MapCache = MapCache$2;
  var ListCache$1 = _ListCache, Map$2 = _Map, MapCache$1 = _MapCache;
  var LARGE_ARRAY_SIZE = 200;
  function stackSet$1(key, value2) {
    var data2 = this.__data__;
    if (data2 instanceof ListCache$1) {
      var pairs2 = data2.__data__;
      if (!Map$2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
        pairs2.push([key, value2]);
        this.size = ++data2.size;
        return this;
      }
      data2 = this.__data__ = new MapCache$1(pairs2);
    }
    data2.set(key, value2);
    this.size = data2.size;
    return this;
  }
  var _stackSet = stackSet$1;
  var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
  function Stack$1(entries) {
    var data2 = this.__data__ = new ListCache(entries);
    this.size = data2.size;
  }
  Stack$1.prototype.clear = stackClear;
  Stack$1.prototype["delete"] = stackDelete;
  Stack$1.prototype.get = stackGet;
  Stack$1.prototype.has = stackHas;
  Stack$1.prototype.set = stackSet;
  var _Stack = Stack$1;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function setCacheAdd$1(value2) {
    this.__data__.set(value2, HASH_UNDEFINED);
    return this;
  }
  var _setCacheAdd = setCacheAdd$1;
  function setCacheHas$1(value2) {
    return this.__data__.has(value2);
  }
  var _setCacheHas = setCacheHas$1;
  var MapCache = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
  function SetCache$1(values2) {
    var index2 = -1, length2 = values2 == null ? 0 : values2.length;
    this.__data__ = new MapCache();
    while (++index2 < length2) {
      this.add(values2[index2]);
    }
  }
  SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
  SetCache$1.prototype.has = setCacheHas;
  var _SetCache = SetCache$1;
  function arraySome$1(array, predicate) {
    var index2 = -1, length2 = array == null ? 0 : array.length;
    while (++index2 < length2) {
      if (predicate(array[index2], index2, array)) {
        return true;
      }
    }
    return false;
  }
  var _arraySome = arraySome$1;
  function cacheHas$1(cache, key) {
    return cache.has(key);
  }
  var _cacheHas = cacheHas$1;
  var SetCache = _SetCache, arraySome = _arraySome, cacheHas = _cacheHas;
  var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
  function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }
    var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index2 < arrLength) {
      var arrValue = array[index2], othValue = other[index2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  var _equalArrays = equalArrays$2;
  var root$5 = _root;
  var Uint8Array$2 = root$5.Uint8Array;
  var _Uint8Array = Uint8Array$2;
  function mapToArray$1(map2) {
    var index2 = -1, result = Array(map2.size);
    map2.forEach(function(value2, key) {
      result[++index2] = [key, value2];
    });
    return result;
  }
  var _mapToArray = mapToArray$1;
  function setToArray$1(set2) {
    var index2 = -1, result = Array(set2.size);
    set2.forEach(function(value2) {
      result[++index2] = value2;
    });
    return result;
  }
  var _setToArray = setToArray$1;
  var Symbol$1 = _Symbol, Uint8Array$1 = _Uint8Array, eq = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray = _setToArray;
  var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2;
  var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag = "[object Symbol]";
  var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]";
  var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag$2:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag$1:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
          return false;
        }
        return true;
      case boolTag$1:
      case dateTag$1:
      case numberTag$1:
        return eq(+object, +other);
      case errorTag$1:
        return object.name == other.name && object.message == other.message;
      case regexpTag$1:
      case stringTag$1:
        return object == other + "";
      case mapTag$2:
        var convert = mapToArray;
      case setTag$2:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object, other);
        var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  var _equalByTag = equalByTag$1;
  function arrayPush$1(array, values2) {
    var index2 = -1, length2 = values2.length, offset = array.length;
    while (++index2 < length2) {
      array[offset + index2] = values2[index2];
    }
    return array;
  }
  var _arrayPush = arrayPush$1;
  var arrayPush = _arrayPush, isArray$4 = isArray_1;
  function baseGetAllKeys$1(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray$4(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  var _baseGetAllKeys = baseGetAllKeys$1;
  function arrayFilter$1(array, predicate) {
    var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index2 < length2) {
      var value2 = array[index2];
      if (predicate(value2, index2, array)) {
        result[resIndex++] = value2;
      }
    }
    return result;
  }
  var _arrayFilter = arrayFilter$1;
  function stubArray$1() {
    return [];
  }
  var stubArray_1 = stubArray$1;
  var arrayFilter = _arrayFilter, stubArray = stubArray_1;
  var objectProto$6 = Object.prototype;
  var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols$1 = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable$1.call(object, symbol);
    });
  };
  var _getSymbols = getSymbols$1;
  function baseTimes$1(n2, iteratee) {
    var index2 = -1, result = Array(n2);
    while (++index2 < n2) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  var _baseTimes = baseTimes$1;
  var baseGetTag$2 = _baseGetTag, isObjectLike$3 = isObjectLike_1;
  var argsTag$2 = "[object Arguments]";
  function baseIsArguments$1(value2) {
    return isObjectLike$3(value2) && baseGetTag$2(value2) == argsTag$2;
  }
  var _baseIsArguments = baseIsArguments$1;
  var baseIsArguments = _baseIsArguments, isObjectLike$2 = isObjectLike_1;
  var objectProto$5 = Object.prototype;
  var hasOwnProperty$6 = objectProto$5.hasOwnProperty;
  var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;
  var isArguments$1 = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value2) {
    return isObjectLike$2(value2) && hasOwnProperty$6.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
  };
  var isArguments_1 = isArguments$1;
  var isBuffer$2 = { exports: {} };
  function stubFalse() {
    return false;
  }
  var stubFalse_1 = stubFalse;
  isBuffer$2.exports;
  (function(module2, exports3) {
    var root2 = _root, stubFalse2 = stubFalse_1;
    var freeExports = exports3 && !exports3.nodeType && exports3;
    var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root2.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer2 = nativeIsBuffer || stubFalse2;
    module2.exports = isBuffer2;
  })(isBuffer$2, isBuffer$2.exports);
  var isBufferExports = isBuffer$2.exports;
  var MAX_SAFE_INTEGER$1 = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex$1(value2, length2) {
    var type2 = typeof value2;
    length2 = length2 == null ? MAX_SAFE_INTEGER$1 : length2;
    return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length2);
  }
  var _isIndex = isIndex$1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength$2(value2) {
    return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
  }
  var isLength_1 = isLength$2;
  var baseGetTag$1 = _baseGetTag, isLength$1 = isLength_1, isObjectLike$1 = isObjectLike_1;
  var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag$1 = "[object Map]", numberTag = "[object Number]", objectTag$2 = "[object Object]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", weakMapTag$1 = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag] = typedArrayTags[setTag$1] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag$1] = false;
  function baseIsTypedArray$1(value2) {
    return isObjectLike$1(value2) && isLength$1(value2.length) && !!typedArrayTags[baseGetTag$1(value2)];
  }
  var _baseIsTypedArray = baseIsTypedArray$1;
  function baseUnary$1(func) {
    return function(value2) {
      return func(value2);
    };
  }
  var _baseUnary = baseUnary$1;
  var _nodeUtil = { exports: {} };
  _nodeUtil.exports;
  (function(module2, exports3) {
    var freeGlobal2 = _freeGlobal;
    var freeExports = exports3 && !exports3.nodeType && exports3;
    var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal2.process;
    var nodeUtil2 = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module2.exports = nodeUtil2;
  })(_nodeUtil, _nodeUtil.exports);
  var _nodeUtilExports = _nodeUtil.exports;
  var baseIsTypedArray = _baseIsTypedArray, baseUnary = _baseUnary, nodeUtil = _nodeUtilExports;
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray$2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  var isTypedArray_1 = isTypedArray$2;
  var baseTimes = _baseTimes, isArguments = isArguments_1, isArray$3 = isArray_1, isBuffer$1 = isBufferExports, isIndex = _isIndex, isTypedArray$1 = isTypedArray_1;
  var objectProto$4 = Object.prototype;
  var hasOwnProperty$5 = objectProto$4.hasOwnProperty;
  function arrayLikeKeys$1(value2, inherited) {
    var isArr = isArray$3(value2), isArg = !isArr && isArguments(value2), isBuff = !isArr && !isArg && isBuffer$1(value2), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value2.length, String) : [], length2 = result.length;
    for (var key in value2) {
      if ((inherited || hasOwnProperty$5.call(value2, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex(key, length2)))) {
        result.push(key);
      }
    }
    return result;
  }
  var _arrayLikeKeys = arrayLikeKeys$1;
  var objectProto$3 = Object.prototype;
  function isPrototype$1(value2) {
    var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$3;
    return value2 === proto;
  }
  var _isPrototype = isPrototype$1;
  function overArg$1(func, transform2) {
    return function(arg) {
      return func(transform2(arg));
    };
  }
  var _overArg = overArg$1;
  var overArg = _overArg;
  var nativeKeys$1 = overArg(Object.keys, Object);
  var _nativeKeys = nativeKeys$1;
  var isPrototype = _isPrototype, nativeKeys = _nativeKeys;
  var objectProto$2 = Object.prototype;
  var hasOwnProperty$4 = objectProto$2.hasOwnProperty;
  function baseKeys$1(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty$4.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  var _baseKeys = baseKeys$1;
  var isFunction$3 = isFunction_1, isLength = isLength_1;
  function isArrayLike$2(value2) {
    return value2 != null && isLength(value2.length) && !isFunction$3(value2);
  }
  var isArrayLike_1 = isArrayLike$2;
  var arrayLikeKeys = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$1 = isArrayLike_1;
  function keys$1(object) {
    return isArrayLike$1(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  var keys_1 = keys$1;
  var baseGetAllKeys = _baseGetAllKeys, getSymbols = _getSymbols, keys = keys_1;
  function getAllKeys$1(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }
  var _getAllKeys = getAllKeys$1;
  var getAllKeys = _getAllKeys;
  var COMPARE_PARTIAL_FLAG$1 = 1;
  var objectProto$1 = Object.prototype;
  var hasOwnProperty$3 = objectProto$1.hasOwnProperty;
  function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index2 = objLength;
    while (index2--) {
      var key = objProps[index2];
      if (!(isPartial ? key in other : hasOwnProperty$3.call(other, key))) {
        return false;
      }
    }
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index2 < objLength) {
      key = objProps[index2];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  var _equalObjects = equalObjects$1;
  var getNative$3 = _getNative, root$4 = _root;
  var DataView$2 = getNative$3(root$4, "DataView");
  var _DataView = DataView$2;
  var getNative$2 = _getNative, root$3 = _root;
  var Promise$2 = getNative$2(root$3, "Promise");
  var _Promise = Promise$2;
  var getNative$1 = _getNative, root$2 = _root;
  var Set$2 = getNative$1(root$2, "Set");
  var _Set = Set$2;
  var getNative = _getNative, root$1 = _root;
  var WeakMap$2 = getNative(root$1, "WeakMap");
  var _WeakMap = WeakMap$2;
  var DataView$1 = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$1 = _Set, WeakMap$1 = _WeakMap, baseGetTag = _baseGetTag, toSource = _toSource;
  var mapTag = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
  var dataViewTag = "[object DataView]";
  var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
  var getTag$1 = baseGetTag;
  if (DataView$1 && getTag$1(new DataView$1(new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag$1(new Map$1()) != mapTag || Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag || Set$1 && getTag$1(new Set$1()) != setTag || WeakMap$1 && getTag$1(new WeakMap$1()) != weakMapTag) {
    getTag$1 = function(value2) {
      var result = baseGetTag(value2), Ctor = result == objectTag$1 ? value2.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  var _getTag = getTag$1;
  var Stack = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag = _getTag, isArray$2 = isArray_1, isBuffer = isBufferExports, isTypedArray = isTypedArray_1;
  var COMPARE_PARTIAL_FLAG = 1;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
  var objectProto = Object.prototype;
  var hasOwnProperty$2 = objectProto.hasOwnProperty;
  function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray$2(object), othIsArr = isArray$2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty$2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$2.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }
  var _baseIsEqualDeep = baseIsEqualDeep$1;
  var baseIsEqualDeep = _baseIsEqualDeep, isObjectLike = isObjectLike_1;
  function baseIsEqual$1(value2, other, bitmask, customizer, stack) {
    if (value2 === other) {
      return true;
    }
    if (value2 == null || other == null || !isObjectLike(value2) && !isObjectLike(other)) {
      return value2 !== value2 && other !== other;
    }
    return baseIsEqualDeep(value2, other, bitmask, customizer, baseIsEqual$1, stack);
  }
  var _baseIsEqual = baseIsEqual$1;
  var baseIsEqual = _baseIsEqual;
  function isEqual$2(value2, other) {
    return baseIsEqual(value2, other);
  }
  var isEqual_1 = isEqual$2;
  let KeyValuePair$4 = class KeyValuePair2 {
    constructor(key, value2) {
      this.key = key;
      this.value = value2;
    }
    /**
     * @returns {KeyValuePair}
     */
    clone() {
      const clone = new KeyValuePair2();
      if (this.key) {
        clone.key = this.key.clone();
      }
      if (this.value) {
        clone.value = this.value.clone();
      }
      return clone;
    }
  };
  var KeyValuePair_1 = KeyValuePair$4;
  var FUNC_ERROR_TEXT = "Expected a function";
  function negate$5(predicate) {
    if (typeof predicate != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    return function() {
      var args = arguments;
      switch (args.length) {
        case 0:
          return !predicate.call(this);
        case 1:
          return !predicate.call(this, args[0]);
        case 2:
          return !predicate.call(this, args[0], args[1]);
        case 3:
          return !predicate.call(this, args[0], args[1], args[2]);
      }
      return !predicate.apply(this, args);
    };
  }
  var negate_1 = negate$5;
  const negate$4 = negate_1;
  function coerceElementMatchingCallback(value2) {
    if (typeof value2 === "string") {
      return (element) => element.element === value2;
    }
    if (value2.constructor && value2.extend) {
      return (element) => element instanceof value2;
    }
    return value2;
  }
  let ArraySlice$5 = class ArraySlice2 {
    constructor(elements2) {
      this.elements = elements2 || [];
    }
    /**
     * @returns {Array}
     */
    toValue() {
      return this.elements.map((element) => element.toValue());
    }
    // High Order Functions
    /**
     * @param callback - Function to execute for each element
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @returns {array} A new array with each element being the result of the callback function
     */
    map(callback, thisArg) {
      return this.elements.map(callback, thisArg);
    }
    /**
     * Maps and then flattens the results.
     * @param callback - Function to execute for each element.
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @returns {array}
     */
    flatMap(callback, thisArg) {
      return this.map(callback, thisArg).reduce((a, b) => a.concat(b), []);
    }
    /**
     * Returns an array containing the truthy results of calling the given transformation with each element of this sequence
     * @param transform - A closure that accepts an element of this array as its argument and returns an optional value.
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @memberof ArraySlice.prototype
     * @returns An array of the non-undefined results of calling transform with each element of the array
     */
    compactMap(transform2, thisArg) {
      const results = [];
      this.forEach((element) => {
        const result = transform2.bind(thisArg)(element);
        if (result) {
          results.push(result);
        }
      });
      return results;
    }
    /**
     * @param callback - Function to execute for each element. This may be a callback, an element name or an element class.
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @returns {ArraySlice}
     * @memberof ArraySlice.prototype
     */
    filter(callback, thisArg) {
      callback = coerceElementMatchingCallback(callback);
      return new ArraySlice2(this.elements.filter(callback, thisArg));
    }
    /**
     * @param callback - Function to execute for each element. This may be a callback, an element name or an element class.
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @returns {ArraySlice}
     * @memberof ArraySlice.prototype
     */
    reject(callback, thisArg) {
      callback = coerceElementMatchingCallback(callback);
      return new ArraySlice2(this.elements.filter(negate$4(callback), thisArg));
    }
    /**
     * Returns the first element in the array that satisfies the given value
     * @param callback - Function to execute for each element. This may be a callback, an element name or an element class.
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @returns {Element}
     * @memberof ArraySlice.prototype
     */
    find(callback, thisArg) {
      callback = coerceElementMatchingCallback(callback);
      return this.elements.find(callback, thisArg);
    }
    /**
     * @param callback - Function to execute for each element
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @memberof ArraySlice.prototype
     */
    forEach(callback, thisArg) {
      this.elements.forEach(callback, thisArg);
    }
    /**
     * @param callback - Function to execute for each element
     * @param initialValue
     * @memberof ArraySlice.prototype
     */
    reduce(callback, initialValue) {
      return this.elements.reduce(callback, initialValue);
    }
    /**
     * @param value
     * @returns {boolean}
     * @memberof ArraySlice.prototype
     */
    includes(value2) {
      return this.elements.some((element) => element.equals(value2));
    }
    // Mutation
    /**
     * Removes the first element from the slice
     * @returns {Element} The removed element or undefined if the slice is empty
     * @memberof ArraySlice.prototype
     */
    shift() {
      return this.elements.shift();
    }
    /**
     * Adds the given element to the begining of the slice
     * @parameter {Element} value
     * @memberof ArraySlice.prototype
     */
    unshift(value2) {
      this.elements.unshift(this.refract(value2));
    }
    /**
     * Adds the given element to the end of the slice
     * @parameter {Element} value
     * @memberof ArraySlice.prototype
     */
    push(value2) {
      this.elements.push(this.refract(value2));
      return this;
    }
    /**
     * @parameter {Element} value
     * @memberof ArraySlice.prototype
     */
    add(value2) {
      this.push(value2);
    }
    // Accessors
    /**
     * @parameter {number} index
     * @returns {Element}
     * @memberof ArraySlice.prototype
     */
    get(index2) {
      return this.elements[index2];
    }
    /**
     * @parameter {number} index
     * @memberof ArraySlice.prototype
     */
    getValue(index2) {
      const element = this.elements[index2];
      if (element) {
        return element.toValue();
      }
      return void 0;
    }
    /**
     * Returns the number of elements in the slice
     * @type number
     */
    get length() {
      return this.elements.length;
    }
    /**
     * Returns whether the slice is empty
     * @type boolean
     */
    get isEmpty() {
      return this.elements.length === 0;
    }
    /**
     * Returns the first element in the slice or undefined if the slice is empty
     * @type Element
     */
    get first() {
      return this.elements[0];
    }
  };
  if (typeof Symbol !== "undefined") {
    ArraySlice$5.prototype[Symbol.iterator] = function symbol() {
      return this.elements[Symbol.iterator]();
    };
  }
  var ArraySlice_1 = ArraySlice$5;
  const isEqual$1 = isEqual_1;
  const KeyValuePair$3 = KeyValuePair_1;
  const ArraySlice$4 = ArraySlice_1;
  let Element$b = class Element2 {
    constructor(content, meta, attributes) {
      if (meta) {
        this.meta = meta;
      }
      if (attributes) {
        this.attributes = attributes;
      }
      this.content = content;
    }
    /**
     * Freezes the element to prevent any mutation.
     * A frozen element will add `parent` property to every child element
     * to allow traversing up the element tree.
     */
    freeze() {
      if (Object.isFrozen(this)) {
        return;
      }
      if (this._meta) {
        this.meta.parent = this;
        this.meta.freeze();
      }
      if (this._attributes) {
        this.attributes.parent = this;
        this.attributes.freeze();
      }
      this.children.forEach((element) => {
        element.parent = this;
        element.freeze();
      }, this);
      if (this.content && Array.isArray(this.content)) {
        Object.freeze(this.content);
      }
      Object.freeze(this);
    }
    primitive() {
    }
    /**
     * Creates a deep clone of the instance
     */
    clone() {
      const copy2 = new this.constructor();
      copy2.element = this.element;
      if (this.meta.length) {
        copy2._meta = this.meta.clone();
      }
      if (this.attributes.length) {
        copy2._attributes = this.attributes.clone();
      }
      if (this.content) {
        if (this.content.clone) {
          copy2.content = this.content.clone();
        } else if (Array.isArray(this.content)) {
          copy2.content = this.content.map((element) => element.clone());
        } else {
          copy2.content = this.content;
        }
      } else {
        copy2.content = this.content;
      }
      return copy2;
    }
    /**
     */
    toValue() {
      if (this.content instanceof Element2) {
        return this.content.toValue();
      }
      if (this.content instanceof KeyValuePair$3) {
        return {
          key: this.content.key.toValue(),
          value: this.content.value ? this.content.value.toValue() : void 0
        };
      }
      if (this.content && this.content.map) {
        return this.content.map((element) => element.toValue(), this);
      }
      return this.content;
    }
    /**
     * Creates a reference pointing at the Element
     * @returns {RefElement}
     * @memberof Element.prototype
     */
    toRef(path2) {
      if (this.id.toValue() === "") {
        throw Error("Cannot create reference to an element that does not contain an ID");
      }
      const ref = new this.RefElement(this.id.toValue());
      if (path2) {
        ref.path = path2;
      }
      return ref;
    }
    /**
     * Finds the given elements in the element tree.
     * When providing multiple element names, you must first freeze the element.
     *
     * @param names {...elementNames}
     * @returns {ArraySlice}
     */
    findRecursive(...elementNames) {
      if (arguments.length > 1 && !this.isFrozen) {
        throw new Error("Cannot find recursive with multiple element names without first freezing the element. Call `element.freeze()`");
      }
      const elementName = elementNames.pop();
      let elements2 = new ArraySlice$4();
      const append = (array, element) => {
        array.push(element);
        return array;
      };
      const checkElement = (array, element) => {
        if (element.element === elementName) {
          array.push(element);
        }
        const items = element.findRecursive(elementName);
        if (items) {
          items.reduce(append, array);
        }
        if (element.content instanceof KeyValuePair$3) {
          if (element.content.key) {
            checkElement(array, element.content.key);
          }
          if (element.content.value) {
            checkElement(array, element.content.value);
          }
        }
        return array;
      };
      if (this.content) {
        if (this.content.element) {
          checkElement(elements2, this.content);
        }
        if (Array.isArray(this.content)) {
          this.content.reduce(checkElement, elements2);
        }
      }
      if (!elementNames.isEmpty) {
        elements2 = elements2.filter((element) => {
          let parentElements = element.parents.map((e) => e.element);
          for (const namesIndex in elementNames) {
            const name = elementNames[namesIndex];
            const index2 = parentElements.indexOf(name);
            if (index2 !== -1) {
              parentElements = parentElements.splice(0, index2);
            } else {
              return false;
            }
          }
          return true;
        });
      }
      return elements2;
    }
    set(content) {
      this.content = content;
      return this;
    }
    equals(value2) {
      return isEqual$1(this.toValue(), value2);
    }
    getMetaProperty(name, value2) {
      if (!this.meta.hasKey(name)) {
        if (this.isFrozen) {
          const element = this.refract(value2);
          element.freeze();
          return element;
        }
        this.meta.set(name, value2);
      }
      return this.meta.get(name);
    }
    setMetaProperty(name, value2) {
      this.meta.set(name, value2);
    }
    /**
     * @type String
     */
    get element() {
      return this._storedElement || "element";
    }
    set element(element) {
      this._storedElement = element;
    }
    get content() {
      return this._content;
    }
    set content(value2) {
      if (value2 instanceof Element2) {
        this._content = value2;
      } else if (value2 instanceof ArraySlice$4) {
        this.content = value2.elements;
      } else if (typeof value2 == "string" || typeof value2 == "number" || typeof value2 == "boolean" || value2 === "null" || value2 == void 0) {
        this._content = value2;
      } else if (value2 instanceof KeyValuePair$3) {
        this._content = value2;
      } else if (Array.isArray(value2)) {
        this._content = value2.map(this.refract);
      } else if (typeof value2 === "object") {
        this._content = Object.keys(value2).map((key) => new this.MemberElement(key, value2[key]));
      } else {
        throw new Error("Cannot set content to given value");
      }
    }
    /**
     * @type ObjectElement
     */
    get meta() {
      if (!this._meta) {
        if (this.isFrozen) {
          const meta = new this.ObjectElement();
          meta.freeze();
          return meta;
        }
        this._meta = new this.ObjectElement();
      }
      return this._meta;
    }
    set meta(value2) {
      if (value2 instanceof this.ObjectElement) {
        this._meta = value2;
      } else {
        this.meta.set(value2 || {});
      }
    }
    /**
     * The attributes property defines attributes about the given instance
     * of the element, as specified by the element property.
     *
     * @type ObjectElement
     */
    get attributes() {
      if (!this._attributes) {
        if (this.isFrozen) {
          const meta = new this.ObjectElement();
          meta.freeze();
          return meta;
        }
        this._attributes = new this.ObjectElement();
      }
      return this._attributes;
    }
    set attributes(value2) {
      if (value2 instanceof this.ObjectElement) {
        this._attributes = value2;
      } else {
        this.attributes.set(value2 || {});
      }
    }
    /**
     * Unique Identifier, MUST be unique throughout an entire element tree.
     * @type StringElement
     */
    get id() {
      return this.getMetaProperty("id", "");
    }
    set id(element) {
      this.setMetaProperty("id", element);
    }
    /**
     * @type ArrayElement
     */
    get classes() {
      return this.getMetaProperty("classes", []);
    }
    set classes(element) {
      this.setMetaProperty("classes", element);
    }
    /**
     * Human-readable title of element
     * @type StringElement
     */
    get title() {
      return this.getMetaProperty("title", "");
    }
    set title(element) {
      this.setMetaProperty("title", element);
    }
    /**
     * Human-readable description of element
     * @type StringElement
     */
    get description() {
      return this.getMetaProperty("description", "");
    }
    set description(element) {
      this.setMetaProperty("description", element);
    }
    /**
     * @type ArrayElement
     */
    get links() {
      return this.getMetaProperty("links", []);
    }
    set links(element) {
      this.setMetaProperty("links", element);
    }
    /**
     * Returns whether the element is frozen.
     * @type boolean
     * @see freeze
     */
    get isFrozen() {
      return Object.isFrozen(this);
    }
    /**
     * Returns all of the parent elements.
     * @type ArraySlice
     */
    get parents() {
      let { parent: parent2 } = this;
      const parents = new ArraySlice$4();
      while (parent2) {
        parents.push(parent2);
        parent2 = parent2.parent;
      }
      return parents;
    }
    /**
     * Returns all of the children elements found within the element.
     * @type ArraySlice
     * @see recursiveChildren
     */
    get children() {
      if (Array.isArray(this.content)) {
        return new ArraySlice$4(this.content);
      }
      if (this.content instanceof KeyValuePair$3) {
        const children = new ArraySlice$4([this.content.key]);
        if (this.content.value) {
          children.push(this.content.value);
        }
        return children;
      }
      if (this.content instanceof Element2) {
        return new ArraySlice$4([this.content]);
      }
      return new ArraySlice$4();
    }
    /**
    * Returns all of the children elements found within the element recursively.
    * @type ArraySlice
    * @see children
    */
    get recursiveChildren() {
      const children = new ArraySlice$4();
      this.children.forEach((element) => {
        children.push(element);
        element.recursiveChildren.forEach((child) => {
          children.push(child);
        });
      });
      return children;
    }
  };
  var Element_1 = Element$b;
  const Element$a = Element_1;
  let NullElement$2 = class NullElement extends Element$a {
    constructor(content, meta, attributes) {
      super(content || null, meta, attributes);
      this.element = "null";
    }
    primitive() {
      return "null";
    }
    set() {
      return new Error("Cannot set the value of null");
    }
  };
  var NullElement_1 = NullElement$2;
  const Element$9 = Element_1;
  var StringElement_1 = class StringElement extends Element$9 {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "string";
    }
    primitive() {
      return "string";
    }
    /**
     * The length of the string.
     * @type number
     */
    get length() {
      return this.content.length;
    }
  };
  const Element$8 = Element_1;
  var NumberElement_1 = class NumberElement extends Element$8 {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "number";
    }
    primitive() {
      return "number";
    }
  };
  const Element$7 = Element_1;
  var BooleanElement_1 = class BooleanElement extends Element$7 {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "boolean";
    }
    primitive() {
      return "boolean";
    }
  };
  const negate$3 = negate_1;
  const Element$6 = Element_1;
  const ArraySlice$3 = ArraySlice_1;
  let ArrayElement$3 = class ArrayElement extends Element$6 {
    constructor(content, meta, attributes) {
      super(content || [], meta, attributes);
      this.element = "array";
    }
    primitive() {
      return "array";
    }
    /**
     * @returns {Element}
     */
    get(index2) {
      return this.content[index2];
    }
    /**
     * Helper for returning the value of an item
     * This works for both ArrayElement and ObjectElement instances
     */
    getValue(indexOrKey) {
      const item = this.get(indexOrKey);
      if (item) {
        return item.toValue();
      }
      return void 0;
    }
    /**
     * @returns {Element}
     */
    getIndex(index2) {
      return this.content[index2];
    }
    set(index2, value2) {
      this.content[index2] = this.refract(value2);
      return this;
    }
    remove(index2) {
      const removed = this.content.splice(index2, 1);
      if (removed.length) {
        return removed[0];
      }
      return null;
    }
    /**
     * @param callback - Function to execute for each element
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     */
    map(callback, thisArg) {
      return this.content.map(callback, thisArg);
    }
    /**
     * Maps and then flattens the results.
     * @param callback - Function to execute for each element.
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @returns {array}
     */
    flatMap(callback, thisArg) {
      return this.map(callback, thisArg).reduce((a, b) => a.concat(b), []);
    }
    /**
     * Returns an array containing the truthy results of calling the given transformation with each element of this sequence
     * @param transform - A closure that accepts an element of this array as its argument and returns an optional value.
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @memberof ArrayElement.prototype
     * @returns An array of the non-undefined results of calling transform with each element of the array
     */
    compactMap(transform2, thisArg) {
      const results = [];
      this.forEach((element) => {
        const result = transform2.bind(thisArg)(element);
        if (result) {
          results.push(result);
        }
      });
      return results;
    }
    /**
     * @param callback - Function to execute for each element
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @returns {ArraySlice}
     */
    filter(callback, thisArg) {
      return new ArraySlice$3(this.content.filter(callback, thisArg));
    }
    /**
     * @param callback - Function to execute for each element
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @returns {ArraySlice}
     */
    reject(callback, thisArg) {
      return this.filter(negate$3(callback), thisArg);
    }
    /**
     * This is a reduce function specifically for Minim arrays and objects. It
     * allows for returning normal values or Minim instances, so it converts any
     * primitives on each step.
     */
    reduce(callback, initialValue) {
      let startIndex;
      let memo;
      if (initialValue !== void 0) {
        startIndex = 0;
        memo = this.refract(initialValue);
      } else {
        startIndex = 1;
        memo = this.primitive() === "object" ? this.first.value : this.first;
      }
      for (let i2 = startIndex; i2 < this.length; i2 += 1) {
        const item = this.content[i2];
        if (this.primitive() === "object") {
          memo = this.refract(callback(memo, item.value, item.key, item, this));
        } else {
          memo = this.refract(callback(memo, item, i2, this));
        }
      }
      return memo;
    }
    /**
     * @callback forEachCallback
     * @param {Element} currentValue
     * @param {NumberElement} index
     */
    /**
     * @param {forEachCallback} callback - Function to execute for each element
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @memberof ArrayElement.prototype
     */
    forEach(callback, thisArg) {
      this.content.forEach((item, index2) => {
        callback.bind(thisArg)(item, this.refract(index2));
      });
    }
    /**
     * @returns {Element}
     */
    shift() {
      return this.content.shift();
    }
    /**
     * @param value
     */
    unshift(value2) {
      this.content.unshift(this.refract(value2));
    }
    /**
     * @param value
     */
    push(value2) {
      this.content.push(this.refract(value2));
      return this;
    }
    /**
     * @param value
     */
    add(value2) {
      this.push(value2);
    }
    /**
     * Recusively search all descendents using a condition function.
     * @returns {Element[]}
     */
    findElements(condition, givenOptions) {
      const options = givenOptions || {};
      const recursive = !!options.recursive;
      const results = options.results === void 0 ? [] : options.results;
      this.forEach((item, keyOrIndex, member) => {
        if (recursive && item.findElements !== void 0) {
          item.findElements(condition, {
            results,
            recursive
          });
        }
        if (condition(item, keyOrIndex, member)) {
          results.push(item);
        }
      });
      return results;
    }
    /**
     * Recusively search all descendents using a condition function.
     * @param condition
     * @returns {ArraySlice}
     */
    find(condition) {
      return new ArraySlice$3(this.findElements(condition, { recursive: true }));
    }
    /**
     * @param {string} element
     * @returns {ArraySlice}
     */
    findByElement(element) {
      return this.find((item) => item.element === element);
    }
    /**
     * @param {string} className
     * @returns {ArraySlice}
     * @memberof ArrayElement.prototype
     */
    findByClass(className) {
      return this.find((item) => item.classes.includes(className));
    }
    /**
     * Search the tree recursively and find the element with the matching ID
     * @param {string} id
     * @returns {Element}
     * @memberof ArrayElement.prototype
     */
    getById(id2) {
      return this.find((item) => item.id.toValue() === id2).first;
    }
    /**
     * Looks for matching children using deep equality
     * @param value
     * @returns {boolean}
     */
    includes(value2) {
      return this.content.some((element) => element.equals(value2));
    }
    /**
     * Looks for matching children using deep equality
     * @param value
     * @returns {boolean}
     * @see includes
     * @deprecated method was replaced by includes
     */
    contains(value2) {
      return this.includes(value2);
    }
    // Fantasy Land
    /**
     * @returns {ArrayElement} An empty array element
     */
    empty() {
      return new this.constructor([]);
    }
    ["fantasy-land/empty"]() {
      return this.empty();
    }
    /**
     * @param {ArrayElement} other
     * @returns {ArrayElement}
     */
    concat(other) {
      return new this.constructor(this.content.concat(other.content));
    }
    ["fantasy-land/concat"](other) {
      return this.concat(other);
    }
    ["fantasy-land/map"](transform2) {
      return new this.constructor(this.map(transform2));
    }
    ["fantasy-land/chain"](transform2) {
      return this.map((element) => transform2(element), this).reduce((a, b) => a.concat(b), this.empty());
    }
    ["fantasy-land/filter"](callback) {
      return new this.constructor(this.content.filter(callback));
    }
    ["fantasy-land/reduce"](transform2, initialValue) {
      return this.content.reduce(transform2, initialValue);
    }
    /**
     * Returns the length of the collection
     * @type number
     */
    get length() {
      return this.content.length;
    }
    /**
     * Returns whether the collection is empty
     * @type boolean
     */
    get isEmpty() {
      return this.content.length === 0;
    }
    /**
     * Return the first item in the collection
     * @type Element
     */
    get first() {
      return this.getIndex(0);
    }
    /**
     * Return the second item in the collection
     * @type Element
     */
    get second() {
      return this.getIndex(1);
    }
    /**
     * Return the last item in the collection
     * @type Element
     */
    get last() {
      return this.getIndex(this.length - 1);
    }
  };
  ArrayElement$3.empty = function empty2() {
    return new this();
  };
  ArrayElement$3["fantasy-land/empty"] = ArrayElement$3.empty;
  if (typeof Symbol !== "undefined") {
    ArrayElement$3.prototype[Symbol.iterator] = function symbol() {
      return this.content[Symbol.iterator]();
    };
  }
  var ArrayElement_1 = ArrayElement$3;
  const KeyValuePair$2 = KeyValuePair_1;
  const Element$5 = Element_1;
  var MemberElement_1 = class MemberElement extends Element$5 {
    constructor(key, value2, meta, attributes) {
      super(new KeyValuePair$2(), meta, attributes);
      this.element = "member";
      this.key = key;
      this.value = value2;
    }
    /**
     * @type Element
     */
    get key() {
      return this.content.key;
    }
    set key(key) {
      this.content.key = this.refract(key);
    }
    /**
     * @type Element
     */
    get value() {
      return this.content.value;
    }
    set value(value2) {
      this.content.value = this.refract(value2);
    }
  };
  const negate$2 = negate_1;
  const ArraySlice$2 = ArraySlice_1;
  let ObjectSlice$3 = class ObjectSlice2 extends ArraySlice$2 {
    map(callback, thisArg) {
      return this.elements.map((member) => callback.bind(thisArg)(member.value, member.key, member));
    }
    filter(callback, thisArg) {
      return new ObjectSlice2(this.elements.filter((member) => callback.bind(thisArg)(member.value, member.key, member)));
    }
    reject(callback, thisArg) {
      return this.filter(negate$2(callback.bind(thisArg)));
    }
    forEach(callback, thisArg) {
      return this.elements.forEach((member, index2) => {
        callback.bind(thisArg)(member.value, member.key, member, index2);
      });
    }
    /**
     * @returns {array}
     */
    keys() {
      return this.map((value2, key) => key.toValue());
    }
    /**
     * @returns {array}
     */
    values() {
      return this.map((value2) => value2.toValue());
    }
  };
  var ObjectSlice_1 = ObjectSlice$3;
  const negate$1 = negate_1;
  const isObject$4 = isObject_1$1;
  const ArrayElement$2 = ArrayElement_1;
  const MemberElement$2 = MemberElement_1;
  const ObjectSlice$2 = ObjectSlice_1;
  let ObjectElement$2 = class ObjectElement extends ArrayElement$2 {
    constructor(content, meta, attributes) {
      super(content || [], meta, attributes);
      this.element = "object";
    }
    primitive() {
      return "object";
    }
    toValue() {
      return this.content.reduce((results, el) => {
        results[el.key.toValue()] = el.value ? el.value.toValue() : void 0;
        return results;
      }, {});
    }
    /**
     * @param key
     * @returns {Element}
     */
    get(name) {
      const member = this.getMember(name);
      if (member) {
        return member.value;
      }
      return void 0;
    }
    /**
     * @param key
     * @returns {MemberElement}
     */
    getMember(name) {
      if (name === void 0) {
        return void 0;
      }
      return this.content.find((element) => element.key.toValue() === name);
    }
    /**
     * @param key
     */
    remove(name) {
      let removed = null;
      this.content = this.content.filter((item) => {
        if (item.key.toValue() === name) {
          removed = item;
          return false;
        }
        return true;
      });
      return removed;
    }
    /**
     * @param key
     * @returns {Element}
     */
    getKey(name) {
      const member = this.getMember(name);
      if (member) {
        return member.key;
      }
      return void 0;
    }
    /**
     * Set allows either a key/value pair to be given or an object
     * If an object is given, each key is set to its respective value
     */
    set(keyOrObject, value2) {
      if (isObject$4(keyOrObject)) {
        Object.keys(keyOrObject).forEach((objectKey) => {
          this.set(objectKey, keyOrObject[objectKey]);
        });
        return this;
      }
      const key = keyOrObject;
      const member = this.getMember(key);
      if (member) {
        member.value = value2;
      } else {
        this.content.push(new MemberElement$2(key, value2));
      }
      return this;
    }
    /**
     */
    keys() {
      return this.content.map((item) => item.key.toValue());
    }
    /**
     */
    values() {
      return this.content.map((item) => item.value.toValue());
    }
    /**
     * @returns {boolean}
     */
    hasKey(value2) {
      return this.content.some((member) => member.key.equals(value2));
    }
    /**
     * @returns {array}
     */
    items() {
      return this.content.map((item) => [item.key.toValue(), item.value.toValue()]);
    }
    /**
     * @param callback
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     */
    map(callback, thisArg) {
      return this.content.map((item) => callback.bind(thisArg)(item.value, item.key, item));
    }
    /**
     * Returns an array containing the truthy results of calling the given transformation with each element of this sequence
     * @param transform - A closure that accepts the value, key and member element of this object as its argument and returns an optional value.
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     * @returns An array of the non-undefined results of calling transform with each element of the array
     */
    compactMap(callback, thisArg) {
      const results = [];
      this.forEach((value2, key, member) => {
        const result = callback.bind(thisArg)(value2, key, member);
        if (result) {
          results.push(result);
        }
      });
      return results;
    }
    /**
     * @param callback
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     *
     * @returns {ObjectSlice}
     */
    filter(callback, thisArg) {
      return new ObjectSlice$2(this.content).filter(callback, thisArg);
    }
    /**
     * @param callback
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     *
     * @returns {ObjectSlice}
     *
     * @memberof ObjectElement.prototype
     */
    reject(callback, thisArg) {
      return this.filter(negate$1(callback), thisArg);
    }
    /**
     * @param callback
     * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
     *
     * @memberof ObjectElement.prototype
     */
    forEach(callback, thisArg) {
      return this.content.forEach((item) => callback.bind(thisArg)(item.value, item.key, item));
    }
  };
  var ObjectElement_1 = ObjectElement$2;
  const Element$4 = Element_1;
  var LinkElement_1 = class LinkElement extends Element$4 {
    constructor(content, meta, attributes) {
      super(content || [], meta, attributes);
      this.element = "link";
    }
    /**
     * The relation identifier for the link, as defined in RFC 5988.
     * @type StringElement
     */
    get relation() {
      return this.attributes.get("relation");
    }
    set relation(relation) {
      this.attributes.set("relation", relation);
    }
    /**
     * The URI for the given link.
     * @type StringElement
     */
    get href() {
      return this.attributes.get("href");
    }
    set href(href) {
      this.attributes.set("href", href);
    }
  };
  const Element$3 = Element_1;
  var RefElement_1 = class RefElement extends Element$3 {
    constructor(content, meta, attributes) {
      super(content || [], meta, attributes);
      this.element = "ref";
      if (!this.path) {
        this.path = "element";
      }
    }
    /**
     * Path of referenced element to transclude instead of element itself.
     * @type StringElement
     * @default element
     */
    get path() {
      return this.attributes.get("path");
    }
    set path(newValue) {
      this.attributes.set("path", newValue);
    }
  };
  const Element$2 = Element_1;
  const NullElement$1 = NullElement_1;
  const StringElement$1 = StringElement_1;
  const NumberElement$1 = NumberElement_1;
  const BooleanElement$1 = BooleanElement_1;
  const ArrayElement$1 = ArrayElement_1;
  const MemberElement$1 = MemberElement_1;
  const ObjectElement$1 = ObjectElement_1;
  const LinkElement$3 = LinkElement_1;
  const RefElement$1 = RefElement_1;
  const ArraySlice$1 = ArraySlice_1;
  const ObjectSlice$1 = ObjectSlice_1;
  const KeyValuePair$1 = KeyValuePair_1;
  function refract$5(value2) {
    if (value2 instanceof Element$2) {
      return value2;
    }
    if (typeof value2 === "string") {
      return new StringElement$1(value2);
    }
    if (typeof value2 === "number") {
      return new NumberElement$1(value2);
    }
    if (typeof value2 === "boolean") {
      return new BooleanElement$1(value2);
    }
    if (value2 === null) {
      return new NullElement$1();
    }
    if (Array.isArray(value2)) {
      return new ArrayElement$1(value2.map(refract$5));
    }
    if (typeof value2 === "object") {
      const element = new ObjectElement$1(value2);
      return element;
    }
    return value2;
  }
  Element$2.prototype.ObjectElement = ObjectElement$1;
  Element$2.prototype.RefElement = RefElement$1;
  Element$2.prototype.MemberElement = MemberElement$1;
  Element$2.prototype.refract = refract$5;
  ArraySlice$1.prototype.refract = refract$5;
  var elements$2 = {
    Element: Element$2,
    NullElement: NullElement$1,
    StringElement: StringElement$1,
    NumberElement: NumberElement$1,
    BooleanElement: BooleanElement$1,
    ArrayElement: ArrayElement$1,
    MemberElement: MemberElement$1,
    ObjectElement: ObjectElement$1,
    LinkElement: LinkElement$3,
    RefElement: RefElement$1,
    refract: refract$5,
    ArraySlice: ArraySlice$1,
    ObjectSlice: ObjectSlice$1,
    KeyValuePair: KeyValuePair$1
  };
  const isNull = isNull_1;
  const isString$1 = isString_1;
  const isNumber$1 = isNumber_1;
  const isBoolean$1 = isBoolean_1;
  const isObject$3 = isObject_1$1;
  const JSONSerialiser = JSONSerialiser_1;
  const elements$1 = elements$2;
  let Namespace$2 = class Namespace {
    constructor(options) {
      this.elementMap = {};
      this.elementDetection = [];
      this.Element = elements$1.Element;
      this.KeyValuePair = elements$1.KeyValuePair;
      if (!options || !options.noDefault) {
        this.useDefault();
      }
      this._attributeElementKeys = [];
      this._attributeElementArrayKeys = [];
    }
    /**
     * Use a namespace plugin or load a generic plugin.
     *
     * @param plugin
     */
    use(plugin2) {
      if (plugin2.namespace) {
        plugin2.namespace({ base: this });
      }
      if (plugin2.load) {
        plugin2.load({ base: this });
      }
      return this;
    }
    /*
     * Use the default namespace. This preloads all the default elements
     * into this registry instance.
     */
    useDefault() {
      this.register("null", elements$1.NullElement).register("string", elements$1.StringElement).register("number", elements$1.NumberElement).register("boolean", elements$1.BooleanElement).register("array", elements$1.ArrayElement).register("object", elements$1.ObjectElement).register("member", elements$1.MemberElement).register("ref", elements$1.RefElement).register("link", elements$1.LinkElement);
      this.detect(isNull, elements$1.NullElement, false).detect(isString$1, elements$1.StringElement, false).detect(isNumber$1, elements$1.NumberElement, false).detect(isBoolean$1, elements$1.BooleanElement, false).detect(Array.isArray, elements$1.ArrayElement, false).detect(isObject$3, elements$1.ObjectElement, false);
      return this;
    }
    /**
     * Register a new element class for an element.
     *
     * @param {string} name
     * @param elementClass
     */
    register(name, ElementClass) {
      this._elements = void 0;
      this.elementMap[name] = ElementClass;
      return this;
    }
    /**
     * Unregister a previously registered class for an element.
     *
     * @param {string} name
     */
    unregister(name) {
      this._elements = void 0;
      delete this.elementMap[name];
      return this;
    }
    /*
     * Add a new detection function to determine which element
     * class to use when converting existing js instances into
     * refract element.
     */
    detect(test2, ElementClass, givenPrepend) {
      const prepend = givenPrepend === void 0 ? true : givenPrepend;
      if (prepend) {
        this.elementDetection.unshift([test2, ElementClass]);
      } else {
        this.elementDetection.push([test2, ElementClass]);
      }
      return this;
    }
    /*
     * Convert an existing Javascript object into refract element instances, which
     * can be further processed or serialized into refract.
     * If the item passed in is already refracted, then it is returned
     * unmodified.
     */
    toElement(value2) {
      if (value2 instanceof this.Element) {
        return value2;
      }
      let element;
      for (let i2 = 0; i2 < this.elementDetection.length; i2 += 1) {
        const test2 = this.elementDetection[i2][0];
        const ElementClass = this.elementDetection[i2][1];
        if (test2(value2)) {
          element = new ElementClass(value2);
          break;
        }
      }
      return element;
    }
    /*
     * Get an element class given an element name.
     */
    getElementClass(element) {
      const ElementClass = this.elementMap[element];
      if (ElementClass === void 0) {
        return this.Element;
      }
      return ElementClass;
    }
    /*
     * Convert a refract document into refract element instances.
     */
    fromRefract(doc) {
      return this.serialiser.deserialise(doc);
    }
    /*
     * Convert an element to a Refracted JSON object.
     */
    toRefract(element) {
      return this.serialiser.serialise(element);
    }
    /*
     * Get an object that contains all registered element classes, where
     * the key is the PascalCased element name and the value is the class.
     */
    get elements() {
      if (this._elements === void 0) {
        this._elements = {
          Element: this.Element
        };
        Object.keys(this.elementMap).forEach((name) => {
          const pascal = name[0].toUpperCase() + name.substr(1);
          this._elements[pascal] = this.elementMap[name];
        });
      }
      return this._elements;
    }
    /**
     * Convinience method for getting a JSON Serialiser configured with the
     * current namespace
     *
     * @type JSONSerialiser
     * @readonly
     *
     * @memberof Namespace.prototype
     */
    get serialiser() {
      return new JSONSerialiser(this);
    }
  };
  JSONSerialiser.prototype.Namespace = Namespace$2;
  var Namespace_1$1 = Namespace$2;
  const Namespace$1 = Namespace_1$1;
  const elements = elements$2;
  var Namespace_1 = Namespace$1;
  var KeyValuePair = KeyValuePair_1;
  var ArraySlice = elements.ArraySlice;
  var ObjectSlice = elements.ObjectSlice;
  var Element$1 = elements.Element;
  var StringElement = elements.StringElement;
  var NumberElement = elements.NumberElement;
  var BooleanElement = elements.BooleanElement;
  var NullElement = elements.NullElement;
  var ArrayElement = elements.ArrayElement;
  var ObjectElement = elements.ObjectElement;
  var MemberElement = elements.MemberElement;
  var RefElement = elements.RefElement;
  var LinkElement$2 = elements.LinkElement;
  var refract$4 = elements.refract;
  class Annotation extends StringElement {
    // classes: warning | error
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "annotation";
    }
    get code() {
      return this.attributes.get("code");
    }
    set code(value2) {
      this.attributes.set("code", value2);
    }
  }
  const AnnotationElement = Annotation;
  class Comment extends StringElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "comment";
    }
  }
  const CommentElement = Comment;
  class ParseResult extends ArrayElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "parseResult";
    }
    get api() {
      return this.children.filter((item) => item.classes.contains("api")).first;
    }
    get results() {
      return this.children.filter((item) => item.classes.contains("result"));
    }
    get result() {
      return this.results.first;
    }
    get annotations() {
      return this.children.filter((item) => item.element === "annotation");
    }
    get warnings() {
      return this.children.filter((item) => item.element === "annotation" && item.classes.contains("warning"));
    }
    get errors() {
      return this.children.filter((item) => item.element === "annotation" && item.classes.contains("error"));
    }
    get isEmpty() {
      return this.children.reject((item) => item.element === "annotation").isEmpty;
    }
    replaceResult(replacement2) {
      const {
        result
      } = this;
      if (isUndefined$1(result)) {
        return false;
      }
      const searchIndex = this.content.findIndex((e) => e === result);
      if (searchIndex === -1) {
        return false;
      }
      this.content[searchIndex] = replacement2;
      return true;
    }
  }
  const ParseResultElement = ParseResult;
  class SourceMap extends ArrayElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "sourceMap";
    }
    get positionStart() {
      return this.children.filter((item) => item.classes.contains("position")).get(0);
    }
    get positionEnd() {
      return this.children.filter((item) => item.classes.contains("position")).get(1);
    }
    set position(position2) {
      if (position2 === null) {
        return;
      }
      const start = new ArrayElement([position2.start.row, position2.start.column, position2.start.char]);
      const end = new ArrayElement([position2.end.row, position2.end.column, position2.end.char]);
      start.classes.push("position");
      end.classes.push("position");
      this.push(start).push(end);
    }
  }
  const SourceMapElement = SourceMap;
  const hasMethod = (name, obj) => typeof (obj === null || obj === void 0 ? void 0 : obj[name]) === "function";
  const hasBasicElementProps = (element) => element != null && Object.prototype.hasOwnProperty.call(element, "_storedElement") && Object.prototype.hasOwnProperty.call(element, "_content");
  const primitiveEq = (val, obj) => {
    var _obj$primitive;
    return (obj === null || obj === void 0 || (_obj$primitive = obj.primitive) === null || _obj$primitive === void 0 ? void 0 : _obj$primitive.call(obj)) === val;
  };
  const hasClass = (cls, obj) => {
    var _obj$classes, _obj$classes$includes;
    return (obj === null || obj === void 0 || (_obj$classes = obj.classes) === null || _obj$classes === void 0 || (_obj$classes$includes = _obj$classes.includes) === null || _obj$classes$includes === void 0 ? void 0 : _obj$classes$includes.call(_obj$classes, cls)) || false;
  };
  const isElementType = (name, element) => (element === null || element === void 0 ? void 0 : element.element) === name;
  const createPredicate = (predicateCreator) => {
    return predicateCreator({
      hasMethod,
      hasBasicElementProps,
      primitiveEq,
      isElementType,
      hasClass
    });
  };
  const createPredicate$1 = createPredicate;
  const isElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof Element$1 || hasBasicElementProps2(element) && primitiveEq2(void 0, element);
  });
  const isStringElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof StringElement || hasBasicElementProps2(element) && primitiveEq2("string", element);
  });
  const isNumberElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof NumberElement || hasBasicElementProps2(element) && primitiveEq2("number", element);
  });
  const isNullElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof NullElement || hasBasicElementProps2(element) && primitiveEq2("null", element);
  });
  const isBooleanElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof BooleanElement || hasBasicElementProps2(element) && primitiveEq2("boolean", element);
  });
  const isObjectElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    primitiveEq: primitiveEq2,
    hasMethod: hasMethod2
  }) => {
    return (element) => element instanceof ObjectElement || hasBasicElementProps2(element) && primitiveEq2("object", element) && hasMethod2("keys", element) && hasMethod2("values", element) && hasMethod2("items", element);
  });
  const isArrayElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    primitiveEq: primitiveEq2,
    hasMethod: hasMethod2
  }) => {
    return (element) => element instanceof ArrayElement && !(element instanceof ObjectElement) || hasBasicElementProps2(element) && primitiveEq2("array", element) && hasMethod2("push", element) && hasMethod2("unshift", element) && hasMethod2("map", element) && hasMethod2("reduce", element);
  });
  const isMemberElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof MemberElement || hasBasicElementProps2(element) && isElementType2("member", element) && primitiveEq2(void 0, element);
  });
  const isLinkElement$2 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof LinkElement$2 || hasBasicElementProps2(element) && isElementType2("link", element) && primitiveEq2(void 0, element);
  });
  const isRefElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof RefElement || hasBasicElementProps2(element) && isElementType2("ref", element) && primitiveEq2(void 0, element);
  });
  const isAnnotationElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof AnnotationElement || hasBasicElementProps2(element) && isElementType2("annotation", element) && primitiveEq2("array", element);
  });
  const isCommentElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof CommentElement || hasBasicElementProps2(element) && isElementType2("comment", element) && primitiveEq2("string", element);
  });
  const isParseResultElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof ParseResultElement || hasBasicElementProps2(element) && isElementType2("parseResult", element) && primitiveEq2("array", element);
  });
  const isSourceMapElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof SourceMapElement || hasBasicElementProps2(element) && isElementType2("sourceMap", element) && primitiveEq2("array", element);
  });
  const isPrimitiveElement = (element) => {
    return isElementType("object", element) || isElementType("array", element) || isElementType("boolean", element) || isElementType("number", element) || isElementType("string", element) || isElementType("null", element) || isElementType("member", element);
  };
  const hasElementSourceMap = (element) => {
    var _element$meta, _element$meta$get;
    return isSourceMapElement(element === null || element === void 0 || (_element$meta = element.meta) === null || _element$meta === void 0 || (_element$meta$get = _element$meta.get) === null || _element$meta$get === void 0 ? void 0 : _element$meta$get.call(_element$meta, "sourceMap"));
  };
  const includesSymbols = (symbols, element) => {
    if (symbols.length === 0) {
      return true;
    }
    const elementSymbols = element.attributes.get("symbols");
    if (!isArrayElement(elementSymbols)) {
      return false;
    }
    return all$1(included$1(elementSymbols.toValue()), symbols);
  };
  const includesClasses = (classes, element) => {
    if (classes.length === 0) {
      return true;
    }
    return all$1(included$1(element.classes.toValue()), classes);
  };
  const basePredicates = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    hasElementSourceMap,
    includesClasses,
    includesSymbols,
    isAnnotationElement,
    isArrayElement,
    isBooleanElement,
    isCommentElement,
    isElement,
    isLinkElement: isLinkElement$2,
    isMemberElement,
    isNullElement,
    isNumberElement,
    isObjectElement,
    isParseResultElement,
    isPrimitiveElement,
    isRefElement,
    isSourceMapElement,
    isStringElement
  }, Symbol.toStringTag, { value: "Module" }));
  class Namespace extends Namespace_1 {
    constructor() {
      super();
      this.register("annotation", AnnotationElement);
      this.register("comment", CommentElement);
      this.register("parseResult", ParseResultElement);
      this.register("sourceMap", SourceMapElement);
    }
  }
  const namespace = new Namespace();
  const createNamespace = (namespacePlugin) => {
    const namespaceInstance = new Namespace();
    if (isPlainObject$1(namespacePlugin)) {
      namespaceInstance.use(namespacePlugin);
    }
    return namespaceInstance;
  };
  const createToolbox$6 = () => {
    const predicates2 = {
      ...basePredicates
    };
    return {
      predicates: predicates2,
      namespace
    };
  };
  const createToolbox$7 = createToolbox$6;
  const getVisitFn = (visitor2, type2, isLeaving) => {
    const typeVisitor = visitor2[type2];
    if (typeVisitor != null) {
      if (!isLeaving && typeof typeVisitor === "function") {
        return typeVisitor;
      }
      const typeSpecificVisitor = isLeaving ? typeVisitor.leave : typeVisitor.enter;
      if (typeof typeSpecificVisitor === "function") {
        return typeSpecificVisitor;
      }
    } else {
      const specificVisitor = isLeaving ? visitor2.leave : visitor2.enter;
      if (specificVisitor != null) {
        if (typeof specificVisitor === "function") {
          return specificVisitor;
        }
        const specificTypeVisitor = specificVisitor[type2];
        if (typeof specificTypeVisitor === "function") {
          return specificTypeVisitor;
        }
      }
    }
    return null;
  };
  const BREAK = {};
  const getNodeType$4 = (node) => node === null || node === void 0 ? void 0 : node.type;
  const isNode$1 = (node) => typeof getNodeType$4(node) === "string";
  const cloneNode$1 = (node) => Object.create(Object.getPrototypeOf(node), Object.getOwnPropertyDescriptors(node));
  const mergeAll$1 = (visitors, {
    visitFnGetter = getVisitFn,
    nodeTypeGetter: nodeTypeGetter2 = getNodeType$4
  } = {}) => {
    const skipping = new Array(visitors.length).fill(null);
    return {
      enter(node, ...rest) {
        for (let i2 = 0; i2 < visitors.length; i2 += 1) {
          if (skipping[i2] === null) {
            const fn = visitFnGetter(
              visitors[i2],
              nodeTypeGetter2(node),
              /* isLeaving */
              false
            );
            if (typeof fn === "function") {
              const result = fn.call(visitors[i2], node, ...rest);
              if (result === false) {
                skipping[i2] = node;
              } else if (result === BREAK) {
                skipping[i2] = BREAK;
              } else if (result !== void 0) {
                return result;
              }
            }
          }
        }
        return void 0;
      },
      leave(node, ...rest) {
        for (let i2 = 0; i2 < visitors.length; i2 += 1) {
          if (skipping[i2] === null) {
            const fn = visitFnGetter(
              visitors[i2],
              nodeTypeGetter2(node),
              /* isLeaving */
              true
            );
            if (typeof fn === "function") {
              const result = fn.call(visitors[i2], node, ...rest);
              if (result === BREAK) {
                skipping[i2] = BREAK;
              } else if (result !== void 0 && result !== false) {
                return result;
              }
            }
          } else if (skipping[i2] === node) {
            skipping[i2] = null;
          }
        }
        return void 0;
      }
    };
  };
  const visit$2 = (root2, visitor2, {
    keyMap: keyMap2 = null,
    state: state2 = {},
    breakSymbol = BREAK,
    deleteNodeSymbol = null,
    skipVisitingNodeSymbol = false,
    visitFnGetter = getVisitFn,
    nodeTypeGetter: nodeTypeGetter2 = getNodeType$4,
    nodePredicate = isNode$1,
    nodeCloneFn = cloneNode$1,
    detectCycles = true
  } = {}) => {
    const visitorKeys = keyMap2 || {};
    let stack;
    let inArray = Array.isArray(root2);
    let keys2 = [root2];
    let index2 = -1;
    let parent2;
    let edits = [];
    let node = root2;
    const path2 = [];
    const ancestors = [];
    do {
      index2 += 1;
      const isLeaving = index2 === keys2.length;
      let key;
      const isEdited = isLeaving && edits.length !== 0;
      if (isLeaving) {
        key = ancestors.length === 0 ? void 0 : path2.pop();
        node = parent2;
        parent2 = ancestors.pop();
        if (isEdited) {
          if (inArray) {
            node = node.slice();
            let editOffset = 0;
            for (const [editKey, editValue] of edits) {
              const arrayKey = editKey - editOffset;
              if (editValue === deleteNodeSymbol) {
                node.splice(arrayKey, 1);
                editOffset += 1;
              } else {
                node[arrayKey] = editValue;
              }
            }
          } else {
            node = nodeCloneFn(node);
            for (const [editKey, editValue] of edits) {
              node[editKey] = editValue;
            }
          }
        }
        index2 = stack.index;
        keys2 = stack.keys;
        edits = stack.edits;
        inArray = stack.inArray;
        stack = stack.prev;
      } else if (parent2 !== deleteNodeSymbol && parent2 !== void 0) {
        key = inArray ? index2 : keys2[index2];
        node = parent2[key];
        if (node === deleteNodeSymbol || node === void 0) {
          continue;
        }
        path2.push(key);
      }
      if (ancestors.includes(node)) {
        continue;
      }
      let result;
      if (!Array.isArray(node)) {
        if (!nodePredicate(node)) {
          throw new ApiDOMError$1(`Invalid AST Node:  ${JSON.stringify(node)}`);
        }
        if (detectCycles && ancestors.includes(node)) {
          path2.pop();
          continue;
        }
        const visitFn = visitFnGetter(visitor2, nodeTypeGetter2(node), isLeaving);
        if (visitFn) {
          for (const [stateKey, stateValue] of Object.entries(state2)) {
            visitor2[stateKey] = stateValue;
          }
          result = visitFn.call(visitor2, node, key, parent2, path2, ancestors);
        }
        if (result === breakSymbol) {
          break;
        }
        if (result === skipVisitingNodeSymbol) {
          if (!isLeaving) {
            path2.pop();
            continue;
          }
        } else if (result !== void 0) {
          edits.push([key, result]);
          if (!isLeaving) {
            if (nodePredicate(result)) {
              node = result;
            } else {
              path2.pop();
              continue;
            }
          }
        }
      }
      if (result === void 0 && isEdited) {
        edits.push([key, node]);
      }
      if (!isLeaving) {
        var _visitorKeys$nodeType;
        stack = {
          inArray,
          index: index2,
          keys: keys2,
          edits,
          prev: stack
        };
        inArray = Array.isArray(node);
        keys2 = inArray ? node : (_visitorKeys$nodeType = visitorKeys[nodeTypeGetter2(node)]) !== null && _visitorKeys$nodeType !== void 0 ? _visitorKeys$nodeType : [];
        index2 = -1;
        edits = [];
        if (parent2 !== deleteNodeSymbol && parent2 !== void 0) {
          ancestors.push(parent2);
        }
        parent2 = node;
      }
    } while (stack !== void 0);
    if (edits.length !== 0) {
      return edits.at(-1)[1];
    }
    return root2;
  };
  visit$2[Symbol.for("nodejs.util.promisify.custom")] = async (root2, visitor2, {
    keyMap: keyMap2 = null,
    state: state2 = {},
    breakSymbol = BREAK,
    deleteNodeSymbol = null,
    skipVisitingNodeSymbol = false,
    visitFnGetter = getVisitFn,
    nodeTypeGetter: nodeTypeGetter2 = getNodeType$4,
    nodePredicate = isNode$1,
    nodeCloneFn = cloneNode$1,
    detectCycles = true
  } = {}) => {
    const visitorKeys = keyMap2 || {};
    let stack;
    let inArray = Array.isArray(root2);
    let keys2 = [root2];
    let index2 = -1;
    let parent2;
    let edits = [];
    let node = root2;
    const path2 = [];
    const ancestors = [];
    do {
      index2 += 1;
      const isLeaving = index2 === keys2.length;
      let key;
      const isEdited = isLeaving && edits.length !== 0;
      if (isLeaving) {
        key = ancestors.length === 0 ? void 0 : path2.pop();
        node = parent2;
        parent2 = ancestors.pop();
        if (isEdited) {
          if (inArray) {
            node = node.slice();
            let editOffset = 0;
            for (const [editKey, editValue] of edits) {
              const arrayKey = editKey - editOffset;
              if (editValue === deleteNodeSymbol) {
                node.splice(arrayKey, 1);
                editOffset += 1;
              } else {
                node[arrayKey] = editValue;
              }
            }
          } else {
            node = nodeCloneFn(node);
            for (const [editKey, editValue] of edits) {
              node[editKey] = editValue;
            }
          }
        }
        index2 = stack.index;
        keys2 = stack.keys;
        edits = stack.edits;
        inArray = stack.inArray;
        stack = stack.prev;
      } else if (parent2 !== deleteNodeSymbol && parent2 !== void 0) {
        key = inArray ? index2 : keys2[index2];
        node = parent2[key];
        if (node === deleteNodeSymbol || node === void 0) {
          continue;
        }
        path2.push(key);
      }
      let result;
      if (!Array.isArray(node)) {
        if (!nodePredicate(node)) {
          throw new ApiDOMError$1(`Invalid AST Node:  ${JSON.stringify(node)}`);
        }
        if (detectCycles && ancestors.includes(node)) {
          path2.pop();
          continue;
        }
        const visitFn = visitFnGetter(visitor2, nodeTypeGetter2(node), isLeaving);
        if (visitFn) {
          for (const [stateKey, stateValue] of Object.entries(state2)) {
            visitor2[stateKey] = stateValue;
          }
          result = await visitFn.call(visitor2, node, key, parent2, path2, ancestors);
        }
        if (result === breakSymbol) {
          break;
        }
        if (result === skipVisitingNodeSymbol) {
          if (!isLeaving) {
            path2.pop();
            continue;
          }
        } else if (result !== void 0) {
          edits.push([key, result]);
          if (!isLeaving) {
            if (nodePredicate(result)) {
              node = result;
            } else {
              path2.pop();
              continue;
            }
          }
        }
      }
      if (result === void 0 && isEdited) {
        edits.push([key, node]);
      }
      if (!isLeaving) {
        var _visitorKeys$nodeType2;
        stack = {
          inArray,
          index: index2,
          keys: keys2,
          edits,
          prev: stack
        };
        inArray = Array.isArray(node);
        keys2 = inArray ? node : (_visitorKeys$nodeType2 = visitorKeys[nodeTypeGetter2(node)]) !== null && _visitorKeys$nodeType2 !== void 0 ? _visitorKeys$nodeType2 : [];
        index2 = -1;
        edits = [];
        if (parent2 !== deleteNodeSymbol && parent2 !== void 0) {
          ancestors.push(parent2);
        }
        parent2 = node;
      }
    } while (stack !== void 0);
    if (edits.length !== 0) {
      return edits.at(-1)[1];
    }
    return root2;
  };
  class CloneError extends ApiDOMStructuredError$1 {
  }
  const CloneError$1 = CloneError;
  class DeepCloneError extends CloneError$1 {
  }
  const DeepCloneError$1 = DeepCloneError;
  class ShallowCloneError extends CloneError$1 {
  }
  const ShallowCloneError$1 = ShallowCloneError;
  const invokeClone = (value2) => {
    if (typeof (value2 === null || value2 === void 0 ? void 0 : value2.clone) === "function") {
      return value2.clone();
    }
    return value2;
  };
  const cloneDeep = (value2) => {
    if (value2 instanceof ObjectSlice) {
      const items = [...value2].map(invokeClone);
      return new ObjectSlice(items);
    }
    if (value2 instanceof ArraySlice) {
      const items = [...value2].map(invokeClone);
      return new ArraySlice(items);
    }
    if (typeof (value2 === null || value2 === void 0 ? void 0 : value2.clone) === "function") {
      return value2.clone();
    }
    throw new DeepCloneError$1("Value provided to cloneDeep function couldn't be cloned", {
      value: value2
    });
  };
  cloneDeep.safe = (value2) => {
    try {
      return cloneDeep(value2);
    } catch {
      return value2;
    }
  };
  const cloneShallowKeyValuePair = (keyValuePair) => {
    const {
      key,
      value: value2
    } = keyValuePair;
    return new KeyValuePair(key, value2);
  };
  const cloneShallowArraySlice = (arraySlice) => {
    const items = [...arraySlice];
    return new ArraySlice(items);
  };
  const cloneShallowObjectSlice = (objectSlice) => {
    const items = [...objectSlice];
    return new ObjectSlice(items);
  };
  const cloneShallowElement = (element) => {
    const copy2 = new element.constructor();
    copy2.element = element.element;
    if (element.meta.length > 0) {
      copy2._meta = cloneDeep(element.meta);
    }
    if (element.attributes.length > 0) {
      copy2._attributes = cloneDeep(element.attributes);
    }
    if (isElement(element.content)) {
      const content = element.content;
      copy2.content = cloneShallowElement(content);
    } else if (Array.isArray(element.content)) {
      copy2.content = [...element.content];
    } else if (element.content instanceof KeyValuePair) {
      copy2.content = cloneShallowKeyValuePair(element.content);
    } else {
      copy2.content = element.content;
    }
    return copy2;
  };
  const cloneShallow = (value2) => {
    if (value2 instanceof KeyValuePair) {
      return cloneShallowKeyValuePair(value2);
    }
    if (value2 instanceof ObjectSlice) {
      return cloneShallowObjectSlice(value2);
    }
    if (value2 instanceof ArraySlice) {
      return cloneShallowArraySlice(value2);
    }
    if (isElement(value2)) {
      return cloneShallowElement(value2);
    }
    throw new ShallowCloneError$1("Value provided to cloneShallow function couldn't be cloned", {
      value: value2
    });
  };
  cloneShallow.safe = (value2) => {
    try {
      return cloneShallow(value2);
    } catch {
      return value2;
    }
  };
  const getNodeType$3 = (element) => {
    return isObjectElement(element) ? "ObjectElement" : isArrayElement(element) ? "ArrayElement" : isMemberElement(element) ? "MemberElement" : isStringElement(element) ? "StringElement" : isBooleanElement(element) ? "BooleanElement" : isNumberElement(element) ? "NumberElement" : isNullElement(element) ? "NullElement" : isLinkElement$2(element) ? "LinkElement" : isRefElement(element) ? "RefElement" : void 0;
  };
  const cloneNode = (node) => {
    if (isElement(node)) {
      return cloneShallow(node);
    }
    return cloneNode$1(node);
  };
  const isNode = pipe$2(getNodeType$3, isString$4);
  const keyMapDefault$1 = {
    ObjectElement: ["content"],
    ArrayElement: ["content"],
    MemberElement: ["key", "value"],
    StringElement: [],
    BooleanElement: [],
    NumberElement: [],
    NullElement: [],
    RefElement: [],
    LinkElement: [],
    Annotation: [],
    Comment: [],
    ParseResultElement: ["content"],
    SourceMap: ["content"]
  };
  const PredicateVisitor = stampit({
    props: {
      result: [],
      predicate: stubFalse$1,
      returnOnTrue: void 0,
      returnOnFalse: void 0
    },
    init({
      // @ts-ignore
      predicate = this.predicate,
      // @ts-ignore
      returnOnTrue = this.returnOnTrue,
      // @ts-ignore
      returnOnFalse = this.returnOnFalse
    } = {}) {
      this.result = [];
      this.predicate = predicate;
      this.returnOnTrue = returnOnTrue;
      this.returnOnFalse = returnOnFalse;
    },
    methods: {
      enter(element) {
        if (this.predicate(element)) {
          this.result.push(element);
          return this.returnOnTrue;
        }
        return this.returnOnFalse;
      }
    }
  });
  const visit$1 = (root2, visitor2, {
    keyMap: keyMap2 = keyMapDefault$1,
    ...rest
  } = {}) => {
    return visit$2(root2, visitor2, {
      // @ts-ignore
      keyMap: keyMap2,
      // @ts-ignore
      nodeTypeGetter: getNodeType$3,
      nodePredicate: isNode,
      nodeCloneFn: cloneNode,
      ...rest
    });
  };
  visit$1[Symbol.for("nodejs.util.promisify.custom")] = async (root2, visitor2, {
    keyMap: keyMap2 = keyMapDefault$1,
    ...rest
  } = {}) => {
    return visit$2[Symbol.for("nodejs.util.promisify.custom")](root2, visitor2, {
      // @ts-ignore
      keyMap: keyMap2,
      // @ts-ignore
      nodeTypeGetter: getNodeType$3,
      nodePredicate: isNode,
      nodeCloneFn: cloneNode,
      ...rest
    });
  };
  const dispatchPlugins = (element, plugins2, options = {}) => {
    if (plugins2.length === 0)
      return element;
    const toolboxCreator = propOr$1(createToolbox$7, "toolboxCreator", options);
    const visitorOptions = propOr$1({}, "visitorOptions", options);
    const nodeTypeGetter2 = propOr$1(getNodeType$3, "nodeTypeGetter", visitorOptions);
    const toolbox = toolboxCreator();
    const pluginsSpecs = plugins2.map((plugin2) => plugin2(toolbox));
    const pluginsVisitor = mergeAll$1(pluginsSpecs.map(propOr$1({}, "visitor")), {
      nodeTypeGetter: nodeTypeGetter2
    });
    pluginsSpecs.forEach(invokeArgs$1(["pre"], []));
    const newElement = visit$1(element, pluginsVisitor, visitorOptions);
    pluginsSpecs.forEach(invokeArgs$1(["post"], []));
    return newElement;
  };
  class MediaTypes extends Array {
    constructor() {
      super(...arguments);
      __publicField(this, "unknownMediaType", "application/octet-stream");
    }
    // eslint-disable-next-line class-methods-use-this
    filterByFormat() {
      throw new NotImplementedError$3('"filterByFormat" method is not implemented.');
    }
    // eslint-disable-next-line class-methods-use-this
    findBy() {
      throw new NotImplementedError$3('"findBy" method is not implemented.');
    }
    // eslint-disable-next-line class-methods-use-this
    latest() {
      throw new NotImplementedError$3('"latest" method is not implemented.');
    }
  }
  const MediaTypes$1 = MediaTypes;
  const refract$3 = (value2, {
    Type: Type2,
    plugins: plugins2 = []
  }) => {
    const element = new Type2(value2);
    return dispatchPlugins(element, plugins2, {
      toolboxCreator: createToolbox$7,
      visitorOptions: {
        nodeTypeGetter: getNodeType$3
      }
    });
  };
  const createRefractor$3 = (Type2) => (value2, options = {}) => refract$3(value2, {
    ...options,
    Type: Type2
  });
  ObjectElement.refract = createRefractor$3(ObjectElement);
  ArrayElement.refract = createRefractor$3(ArrayElement);
  StringElement.refract = createRefractor$3(StringElement);
  BooleanElement.refract = createRefractor$3(BooleanElement);
  NullElement.refract = createRefractor$3(NullElement);
  NumberElement.refract = createRefractor$3(NumberElement);
  LinkElement$2.refract = createRefractor$3(LinkElement$2);
  RefElement.refract = createRefractor$3(RefElement);
  AnnotationElement.refract = createRefractor$3(AnnotationElement);
  CommentElement.refract = createRefractor$3(CommentElement);
  ParseResultElement.refract = createRefractor$3(ParseResultElement);
  SourceMapElement.refract = createRefractor$3(SourceMapElement);
  const filter$2 = (predicate, element) => {
    const visitor2 = PredicateVisitor({
      predicate
    });
    visit$1(element, visitor2);
    return new ArraySlice(visitor2.result);
  };
  const filter$3 = filter$2;
  const find$1 = (predicate, element) => {
    const visitor2 = PredicateVisitor({
      predicate,
      returnOnTrue: BREAK
    });
    visit$1(element, visitor2);
    return pathOr$1(void 0, [0], visitor2.result);
  };
  const find$2 = find$1;
  const nodeTypeGetter = (node) => {
    if (typeof (node === null || node === void 0 ? void 0 : node.type) === "string") {
      return node.type;
    }
    return getNodeType$3(node);
  };
  const keyMapDefault = {
    EphemeralObject: ["content"],
    EphemeralArray: ["content"],
    ...keyMapDefault$1
  };
  const visit = (root2, visitor2, {
    keyMap: keyMap2 = keyMapDefault,
    ...rest
  } = {}) => {
    return visit$1(root2, visitor2, {
      keyMap: keyMap2,
      // @ts-ignore
      nodeTypeGetter,
      nodePredicate: stubTrue,
      detectCycles: false,
      deleteNodeSymbol: Symbol.for("delete-node"),
      skipVisitingNodeSymbol: Symbol.for("skip-visiting-node"),
      ...rest
    });
  };
  visit[Symbol.for("nodejs.util.promisify.custom")] = async (root2, {
    keyMap: keyMap2 = keyMapDefault,
    ...rest
  } = {}) => {
    return visit$1[Symbol.for("nodejs.util.promisify.custom")](root2, visitor, {
      keyMap: keyMap2,
      nodeTypeGetter,
      nodePredicate: stubTrue,
      detectCycles: false,
      deleteNodeSymbol: Symbol.for("delete-node"),
      skipVisitingNodeSymbol: Symbol.for("skip-visiting-node"),
      ...rest
    });
  };
  class EphemeralArray {
    constructor(content) {
      __publicField(this, "type", "EphemeralArray");
      __publicField(this, "content", []);
      __publicField(this, "reference");
      this.content = content;
      this.reference = [];
    }
    toReference() {
      return this.reference;
    }
    toArray() {
      this.reference.push(...this.content);
      return this.reference;
    }
  }
  const EphemeralArray$1 = EphemeralArray;
  class EphemeralObject {
    constructor(content) {
      __publicField(this, "type", "EphemeralObject");
      __publicField(this, "content", []);
      __publicField(this, "reference");
      this.content = content;
      this.reference = {};
    }
    toReference() {
      return this.reference;
    }
    toObject() {
      return Object.assign(this.reference, Object.fromEntries(this.content));
    }
  }
  const EphemeralObject$1 = EphemeralObject;
  const Visitor$4 = stampit.init(function _Visitor() {
    const references = /* @__PURE__ */ new WeakMap();
    this.BooleanElement = function _BooleanElement(element) {
      return element.toValue();
    };
    this.NumberElement = function _NumberElement(element) {
      return element.toValue();
    };
    this.StringElement = function _StringElement(element) {
      return element.toValue();
    };
    this.NullElement = function _NullElement() {
      return null;
    };
    this.ObjectElement = {
      enter(element) {
        if (references.has(element)) {
          return references.get(element).toReference();
        }
        const ephemeral = new EphemeralObject$1(element.content);
        references.set(element, ephemeral);
        return ephemeral;
      }
    };
    this.EphemeralObject = {
      leave(ephemeral) {
        return ephemeral.toObject();
      }
    };
    this.MemberElement = {
      enter(element) {
        return [element.key, element.value];
      }
    };
    this.ArrayElement = {
      enter(element) {
        if (references.has(element)) {
          return references.get(element).toReference();
        }
        const ephemeral = new EphemeralArray$1(element.content);
        references.set(element, ephemeral);
        return ephemeral;
      }
    };
    this.EphemeralArray = {
      leave(ephemeral) {
        return ephemeral.toArray();
      }
    };
  });
  const serializer = (element) => {
    if (!isElement(element))
      return element;
    if (isStringElement(element) || isNumberElement(element) || isBooleanElement(element) || isNullElement(element)) {
      return element.toValue();
    }
    return visit(element, Visitor$4());
  };
  const toValue = serializer;
  const computeEdges = (element, edges = /* @__PURE__ */ new WeakMap()) => {
    if (isMemberElement(element)) {
      edges.set(element.key, element);
      computeEdges(element.key, edges);
      edges.set(element.value, element);
      computeEdges(element.value, edges);
    } else {
      element.children.forEach((childElement) => {
        edges.set(childElement, element);
        computeEdges(childElement, edges);
      });
    }
    return edges;
  };
  const transcludeChildOfMemberElement = (search, replace2, edges) => {
    const memberElement = edges.get(search);
    if (!isMemberElement(memberElement)) {
      return;
    }
    if (memberElement.key === search) {
      memberElement.key = replace2;
      edges.delete(search);
      edges.set(replace2, memberElement);
    }
    if (memberElement.value === search) {
      memberElement.value = replace2;
      edges.delete(search);
      edges.set(replace2, memberElement);
    }
  };
  const transcludeChildOfObjectElement = (search, replace2, edges) => {
    const objectElement = edges.get(search);
    if (!isObjectElement(objectElement)) {
      return;
    }
    objectElement.content = objectElement.map((value2, key, member) => {
      if (member === search) {
        edges.delete(search);
        edges.set(replace2, objectElement);
        return replace2;
      }
      return member;
    });
  };
  const transcludeChildOfArrayElement = (search, replace2, edges) => {
    const arrayElement = edges.get(search);
    if (!isArrayElement(arrayElement)) {
      return;
    }
    arrayElement.content = arrayElement.map((element) => {
      if (element === search) {
        edges.delete(search);
        edges.set(replace2, arrayElement);
        return replace2;
      }
      return element;
    });
  };
  const Transcluder = stampit.init(function TranscluderConstructor({
    element
  }) {
    let edges;
    this.transclude = function transclude2(search, replace2) {
      var _edges;
      if (search === element)
        return replace2;
      if (search === replace2)
        return element;
      edges = (_edges = edges) !== null && _edges !== void 0 ? _edges : computeEdges(element);
      const parent2 = edges.get(search);
      if (isUndefined$1(parent2)) {
        return void 0;
      }
      if (isObjectElement(parent2)) {
        transcludeChildOfObjectElement(search, replace2, edges);
      } else if (isArrayElement(parent2)) {
        transcludeChildOfArrayElement(search, replace2, edges);
      } else if (isMemberElement(parent2)) {
        transcludeChildOfMemberElement(search, replace2, edges);
      }
      return element;
    };
  });
  const Transcluder$1 = Transcluder;
  const transclude = (search, replace2, element) => {
    const transcluder = Transcluder$1({
      element
    });
    return transcluder.transclude(search, replace2);
  };
  const dereference = (object, root2) => {
    const rootObject = defaultTo$1(object, root2);
    return mapObjIndexed$1((val) => {
      if (isPlainObject$1(val) && has$2("$ref", val) && propSatisfies$1(isString$4, "$ref", val)) {
        const $ref = path$6(["$ref"], val);
        const pointer = trimCharsStart$1("#/", $ref);
        return path$6(pointer.split("/"), rootObject);
      }
      if (isPlainObject$1(val)) {
        return dereference(val, rootObject);
      }
      return val;
    }, object);
  };
  const from$1 = (data2, namespace$1 = namespace) => {
    if (isString$4(data2)) {
      try {
        return namespace$1.fromRefract(JSON.parse(data2));
      } catch {
      }
    }
    if (isPlainObject$1(data2) && has$2("element", data2)) {
      return namespace$1.fromRefract(data2);
    }
    return namespace$1.toElement(data2);
  };
  const from$2 = from$1;
  const emptyElement = (element) => {
    const meta = cloneDeep(element.meta);
    const attributes = cloneDeep(element.attributes);
    return new element.constructor(void 0, meta, attributes);
  };
  const cloneUnlessOtherwiseSpecified = (element, options) => options.clone && options.isMergeableElement(element) ? deepmerge(emptyElement(element), element, options) : element;
  const getMergeFunction = (keyElement, options) => {
    if (typeof options.customMerge !== "function") {
      return deepmerge;
    }
    const customMerge = options.customMerge(keyElement, options);
    return typeof customMerge === "function" ? customMerge : deepmerge;
  };
  const mergeArrayElement = (targetElement, sourceElement, options) => targetElement.concat(sourceElement)["fantasy-land/map"]((item) => cloneUnlessOtherwiseSpecified(item, options));
  const mergeObjectElement = (targetElement, sourceElement, options) => {
    const destination = isObjectElement(targetElement) ? emptyElement(targetElement) : emptyElement(sourceElement);
    if (isObjectElement(targetElement)) {
      targetElement.forEach((value2, key, member) => {
        const clonedMember = cloneShallow(member);
        clonedMember.value = cloneUnlessOtherwiseSpecified(value2, options);
        destination.content.push(clonedMember);
      });
    }
    sourceElement.forEach((value2, key, member) => {
      const keyValue = toValue(key);
      let clonedMember;
      if (isObjectElement(targetElement) && targetElement.hasKey(keyValue) && options.isMergeableElement(value2)) {
        const targetValue = targetElement.get(keyValue);
        clonedMember = cloneShallow(member);
        clonedMember.value = getMergeFunction(key, options)(targetValue, value2);
      } else {
        clonedMember = cloneShallow(member);
        clonedMember.value = cloneUnlessOtherwiseSpecified(value2, options);
      }
      destination.remove(keyValue);
      destination.content.push(clonedMember);
    });
    return destination;
  };
  function deepmerge(targetElement, sourceElement, options) {
    var _mergedOptions$isMerg, _mergedOptions$arrayE, _mergedOptions$object;
    const defaultOptions2 = {
      clone: true,
      isMergeableElement: (element) => isObjectElement(element) || isArrayElement(element),
      arrayElementMerge: mergeArrayElement,
      objectElementMerge: mergeObjectElement,
      customMerge: void 0
    };
    const mergedOptions = {
      ...defaultOptions2,
      ...options
    };
    mergedOptions.isMergeableElement = (_mergedOptions$isMerg = mergedOptions.isMergeableElement) !== null && _mergedOptions$isMerg !== void 0 ? _mergedOptions$isMerg : defaultOptions2.isMergeableElement;
    mergedOptions.arrayElementMerge = (_mergedOptions$arrayE = mergedOptions.arrayElementMerge) !== null && _mergedOptions$arrayE !== void 0 ? _mergedOptions$arrayE : defaultOptions2.arrayElementMerge;
    mergedOptions.objectElementMerge = (_mergedOptions$object = mergedOptions.objectElementMerge) !== null && _mergedOptions$object !== void 0 ? _mergedOptions$object : defaultOptions2.objectElementMerge;
    const sourceIsArrayElement = isArrayElement(sourceElement);
    const targetIsArrayElement = isArrayElement(targetElement);
    const sourceAndTargetTypesMatch = sourceIsArrayElement === targetIsArrayElement;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(sourceElement, mergedOptions);
    }
    if (sourceIsArrayElement && typeof mergedOptions.arrayElementMerge === "function") {
      return mergedOptions.arrayElementMerge(targetElement, sourceElement, mergedOptions);
    }
    return mergedOptions.objectElementMerge(targetElement, sourceElement, mergedOptions);
  }
  deepmerge.all = (list2, options) => {
    if (!Array.isArray(list2)) {
      throw new TypeError("First argument should be an array.");
    }
    if (list2.length === 0) {
      return new ObjectElement();
    }
    return list2.reduce((target, source) => {
      return deepmerge(target, source, options);
    }, emptyElement(list2[0]));
  };
  const dereferenceApiDOM$1 = async (element, options) => {
    let parseResult = element;
    let surrogateWrapping = false;
    if (!isParseResultElement(element)) {
      const elementClone = cloneShallow(element);
      elementClone.classes.push("result");
      parseResult = new ParseResultElement([elementClone]);
      surrogateWrapping = true;
    }
    const file = File$2({
      uri: options.resolve.baseURI,
      parseResult,
      mediaType: options.parse.mediaType
    });
    const dereferenceStrategies = await filter$4("canDereference", file, options.dereference.strategies);
    if (isEmpty$2(dereferenceStrategies)) {
      throw new UnmatchedDereferenceStrategyError$1(file.uri);
    }
    try {
      const {
        result
      } = await run("dereference", [file, options], dereferenceStrategies);
      return surrogateWrapping ? result.get(0) : result;
    } catch (error) {
      throw new DereferenceError$1(`Error while dereferencing file "${file.uri}"`, {
        cause: error
      });
    }
  };
  const Parser = stampit({
    props: {
      name: "",
      /**
       * Whether to allow "empty" files. This includes zero-byte files.
       */
      allowEmpty: true,
      /**
       * Whether to generate source map during parsing.
       */
      sourceMap: false,
      /**
       * List of supported file extensions.
       */
      fileExtensions: [],
      /**
       * List of supported media types.
       */
      mediaTypes: []
    },
    init({
      allowEmpty = this.allowEmpty,
      sourceMap = this.sourceMap,
      fileExtensions = this.fileExtensions,
      mediaTypes: mediaTypes2 = this.mediaTypes
    } = {}) {
      this.allowEmpty = allowEmpty;
      this.sourceMap = sourceMap;
      this.fileExtensions = fileExtensions;
      this.mediaTypes = mediaTypes2;
    },
    methods: {
      async canParse() {
        throw new NotImplementedError$1();
      },
      async parse() {
        throw new NotImplementedError$1();
      }
    }
  });
  const Parser$1 = Parser;
  const Resolver = stampit({
    props: {
      name: null
    },
    methods: {
      canRead() {
        return false;
      },
      async read() {
        throw new NotImplementedError$1();
      }
    }
  });
  const Resolver$1 = Resolver;
  const HttpResolver = stampit(Resolver$1, {
    props: {
      timeout: 5e3,
      redirects: 5,
      withCredentials: false
    },
    init({
      timeout: timeout2 = this.timeout,
      redirects = this.redirects,
      withCredentials = this.withCredentials
    } = {}) {
      this.timeout = timeout2;
      this.redirects = redirects;
      this.withCredentials = withCredentials;
    },
    methods: {
      canRead(file) {
        return isHttpUrl(file.uri);
      },
      async read() {
        throw new NotImplementedError$1();
      },
      getHttpClient() {
        throw new NotImplementedError$1();
      }
    }
  });
  const HttpResolver$1 = HttpResolver;
  const ResolveStrategy = stampit({
    props: {
      name: null
    },
    methods: {
      canResolve() {
        return false;
      },
      async resolve() {
        throw new NotImplementedError$1();
      }
    }
  });
  const ResolveStrategy$1 = ResolveStrategy;
  const DereferenceStrategy = stampit({
    props: {
      name: null
    },
    methods: {
      canDereference() {
        return false;
      },
      async dereference() {
        throw new NotImplementedError$1();
      }
    }
  });
  const DereferenceStrategy$1 = DereferenceStrategy;
  class AncestorLineage extends Array {
    includesCycle(element) {
      return this.filter((ancestors) => ancestors.has(element)).length > 1;
    }
    includes(searchElement, fromIndex) {
      if (searchElement instanceof WeakSet) {
        return super.includes(searchElement, fromIndex);
      }
      return this.some((ancestors) => ancestors.has(searchElement));
    }
  }
  const Reference$2 = stampit({
    props: {
      uri: "",
      value: null,
      depth: 0,
      refSet: null,
      errors: []
    },
    init({
      depth = this.depth,
      refSet = this.refSet,
      uri = this.uri,
      value: value2 = this.value
    } = {}) {
      this.uri = uri;
      this.value = value2;
      this.depth = depth;
      this.refSet = refSet;
      this.errors = [];
    }
  });
  const Reference$3 = Reference$2;
  const ReferenceSet = stampit({
    props: {
      rootRef: null,
      refs: [],
      circular: false
    },
    init({
      refs = []
    } = {}) {
      this.refs = [];
      refs.forEach((ref) => this.add(ref));
    },
    methods: {
      get size() {
        return this.refs.length;
      },
      add(reference) {
        if (!this.has(reference)) {
          this.refs.push(reference);
          this.rootRef = this.rootRef === null ? reference : this.rootRef;
          reference.refSet = this;
        }
        return this;
      },
      merge(anotherRefSet) {
        for (const reference of anotherRefSet.values()) {
          this.add(reference);
        }
        return this;
      },
      has(thing) {
        const uri = isString$4(thing) ? thing : thing.uri;
        return isNotUndefined$1(this.find(propEq$1(uri, "uri")));
      },
      find(callback) {
        return this.refs.find(callback);
      },
      *values() {
        yield* this.refs;
      },
      clean() {
        this.refs.forEach((ref) => {
          ref.refSet = null;
        });
        this.refs = [];
      }
    }
  });
  const ReferenceSet$1 = ReferenceSet;
  const dereferenceApiDOM = async (element, options = {}) => {
    const mergedOptions = merge$3(defaultOptions$1, options);
    return dereferenceApiDOM$1(element, mergedOptions);
  };
  function createErrorType(name, init2) {
    function E() {
      if (!Error.captureStackTrace) {
        this.stack = new Error().stack;
      } else {
        Error.captureStackTrace(this, this.constructor);
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      [this.message] = args;
      if (init2) {
        init2.apply(this, args);
      }
    }
    E.prototype = new Error();
    E.prototype.name = name;
    E.prototype.constructor = E;
    return E;
  }
  function toS(obj) {
    return Object.prototype.toString.call(obj);
  }
  function isDate$2(obj) {
    return toS(obj) === "[object Date]";
  }
  function isRegExp(obj) {
    return toS(obj) === "[object RegExp]";
  }
  function isError(obj) {
    return toS(obj) === "[object Error]";
  }
  function isBoolean(obj) {
    return toS(obj) === "[object Boolean]";
  }
  function isNumber(obj) {
    return toS(obj) === "[object Number]";
  }
  function isString(obj) {
    return toS(obj) === "[object String]";
  }
  var isArray$1 = Array.isArray || function isArray2(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
  function forEach(xs, fn) {
    if (xs.forEach) {
      return xs.forEach(fn);
    }
    for (var i2 = 0; i2 < xs.length; i2++) {
      fn(xs[i2], i2, xs);
    }
    return void 0;
  }
  var objectKeys = Object.keys || function keys2(obj) {
    var res = [];
    for (var key in obj) {
      res.push(key);
    }
    return res;
  };
  var hasOwnProperty$1 = Object.prototype.hasOwnProperty || function(obj, key) {
    return key in obj;
  };
  function copy(src2) {
    if (typeof src2 === "object" && src2 !== null) {
      var dst;
      if (isArray$1(src2)) {
        dst = [];
      } else if (isDate$2(src2)) {
        dst = new Date(src2.getTime ? src2.getTime() : src2);
      } else if (isRegExp(src2)) {
        dst = new RegExp(src2);
      } else if (isError(src2)) {
        dst = { message: src2.message };
      } else if (isBoolean(src2) || isNumber(src2) || isString(src2)) {
        dst = Object(src2);
      } else if (Object.create && Object.getPrototypeOf) {
        dst = Object.create(Object.getPrototypeOf(src2));
      } else if (src2.constructor === Object) {
        dst = {};
      } else {
        var proto = src2.constructor && src2.constructor.prototype || src2.__proto__ || {};
        var T2 = function T3() {
        };
        T2.prototype = proto;
        dst = new T2();
      }
      forEach(objectKeys(src2), function(key) {
        dst[key] = src2[key];
      });
      return dst;
    }
    return src2;
  }
  function walk(root2, cb, immutable) {
    var path2 = [];
    var parents = [];
    var alive = true;
    return function walker(node_) {
      var node = immutable ? copy(node_) : node_;
      var modifiers = {};
      var keepGoing = true;
      var state2 = {
        node,
        node_,
        path: [].concat(path2),
        parent: parents[parents.length - 1],
        parents,
        key: path2[path2.length - 1],
        isRoot: path2.length === 0,
        level: path2.length,
        circular: null,
        update: function(x2, stopHere) {
          if (!state2.isRoot) {
            state2.parent.node[state2.key] = x2;
          }
          state2.node = x2;
          if (stopHere) {
            keepGoing = false;
          }
        },
        delete: function(stopHere) {
          delete state2.parent.node[state2.key];
          if (stopHere) {
            keepGoing = false;
          }
        },
        remove: function(stopHere) {
          if (isArray$1(state2.parent.node)) {
            state2.parent.node.splice(state2.key, 1);
          } else {
            delete state2.parent.node[state2.key];
          }
          if (stopHere) {
            keepGoing = false;
          }
        },
        keys: null,
        before: function(f2) {
          modifiers.before = f2;
        },
        after: function(f2) {
          modifiers.after = f2;
        },
        pre: function(f2) {
          modifiers.pre = f2;
        },
        post: function(f2) {
          modifiers.post = f2;
        },
        stop: function() {
          alive = false;
        },
        block: function() {
          keepGoing = false;
        }
      };
      if (!alive) {
        return state2;
      }
      function updateState() {
        if (typeof state2.node === "object" && state2.node !== null) {
          if (!state2.keys || state2.node_ !== state2.node) {
            state2.keys = objectKeys(state2.node);
          }
          state2.isLeaf = state2.keys.length === 0;
          for (var i2 = 0; i2 < parents.length; i2++) {
            if (parents[i2].node_ === node_) {
              state2.circular = parents[i2];
              break;
            }
          }
        } else {
          state2.isLeaf = true;
          state2.keys = null;
        }
        state2.notLeaf = !state2.isLeaf;
        state2.notRoot = !state2.isRoot;
      }
      updateState();
      var ret = cb.call(state2, state2.node);
      if (ret !== void 0 && state2.update) {
        state2.update(ret);
      }
      if (modifiers.before) {
        modifiers.before.call(state2, state2.node);
      }
      if (!keepGoing) {
        return state2;
      }
      if (typeof state2.node === "object" && state2.node !== null && !state2.circular) {
        parents.push(state2);
        updateState();
        forEach(state2.keys, function(key, i2) {
          path2.push(key);
          if (modifiers.pre) {
            modifiers.pre.call(state2, state2.node[key], key);
          }
          var child = walker(state2.node[key]);
          if (immutable && hasOwnProperty$1.call(state2.node, key)) {
            state2.node[key] = child.node;
          }
          child.isLast = i2 === state2.keys.length - 1;
          child.isFirst = i2 === 0;
          if (modifiers.post) {
            modifiers.post.call(state2, child);
          }
          path2.pop();
        });
        parents.pop();
      }
      if (modifiers.after) {
        modifiers.after.call(state2, state2.node);
      }
      return state2;
    }(root2).node;
  }
  function Traverse(obj) {
    this.value = obj;
  }
  Traverse.prototype.get = function(ps) {
    var node = this.value;
    for (var i2 = 0; i2 < ps.length; i2++) {
      var key = ps[i2];
      if (!node || !hasOwnProperty$1.call(node, key)) {
        return void 0;
      }
      node = node[key];
    }
    return node;
  };
  Traverse.prototype.has = function(ps) {
    var node = this.value;
    for (var i2 = 0; i2 < ps.length; i2++) {
      var key = ps[i2];
      if (!node || !hasOwnProperty$1.call(node, key)) {
        return false;
      }
      node = node[key];
    }
    return true;
  };
  Traverse.prototype.set = function(ps, value2) {
    var node = this.value;
    for (var i2 = 0; i2 < ps.length - 1; i2++) {
      var key = ps[i2];
      if (!hasOwnProperty$1.call(node, key)) {
        node[key] = {};
      }
      node = node[key];
    }
    node[ps[i2]] = value2;
    return value2;
  };
  Traverse.prototype.map = function(cb) {
    return walk(this.value, cb, true);
  };
  Traverse.prototype.forEach = function(cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
  };
  Traverse.prototype.reduce = function(cb, init2) {
    var skip2 = arguments.length === 1;
    var acc = skip2 ? this.value : init2;
    this.forEach(function(x2) {
      if (!this.isRoot || !skip2) {
        acc = cb.call(this, acc, x2);
      }
    });
    return acc;
  };
  Traverse.prototype.paths = function() {
    var acc = [];
    this.forEach(function() {
      acc.push(this.path);
    });
    return acc;
  };
  Traverse.prototype.nodes = function() {
    var acc = [];
    this.forEach(function() {
      acc.push(this.node);
    });
    return acc;
  };
  Traverse.prototype.clone = function() {
    var parents = [];
    var nodes = [];
    return function clone(src2) {
      for (var i2 = 0; i2 < parents.length; i2++) {
        if (parents[i2] === src2) {
          return nodes[i2];
        }
      }
      if (typeof src2 === "object" && src2 !== null) {
        var dst = copy(src2);
        parents.push(src2);
        nodes.push(dst);
        forEach(objectKeys(src2), function(key) {
          dst[key] = clone(src2[key]);
        });
        parents.pop();
        nodes.pop();
        return dst;
      }
      return src2;
    }(this.value);
  };
  function traverse(obj) {
    return new Traverse(obj);
  }
  forEach(objectKeys(Traverse.prototype), function(key) {
    traverse[key] = function(obj) {
      var args = [].slice.call(arguments, 1);
      var t2 = new Traverse(obj);
      return t2[key].apply(t2, args);
    };
  });
  var traverse_1 = traverse;
  const traverse$1 = /* @__PURE__ */ getDefaultExportFromCjs(traverse_1);
  const freelyNamedKeyParents = ["properties"];
  const nonFreelyNamedKeyGrandparents = ["properties"];
  const freelyNamedPaths = [
    // Swagger 2.0
    "definitions",
    "parameters",
    "responses",
    "securityDefinitions",
    // OpenAPI 3.0
    "components/schemas",
    "components/responses",
    "components/parameters",
    "components/securitySchemes"
  ];
  const freelyNamedAncestors = ["schema/example", "items/example"];
  function isFreelyNamed(parentPath) {
    const parentKey = parentPath[parentPath.length - 1];
    const grandparentKey = parentPath[parentPath.length - 2];
    const parentStr = parentPath.join("/");
    return (
      // eslint-disable-next-line max-len
      freelyNamedKeyParents.indexOf(parentKey) > -1 && nonFreelyNamedKeyGrandparents.indexOf(grandparentKey) === -1 || freelyNamedPaths.indexOf(parentStr) > -1 || freelyNamedAncestors.some((el) => parentStr.indexOf(el) > -1)
    );
  }
  function generateAbsoluteRefPatches(obj, basePath) {
    let {
      specmap,
      getBaseUrlForNodePath = (path2) => specmap.getContext([...basePath, ...path2]).baseDoc,
      targetKeys = ["$ref", "$$ref"]
    } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const patches = [];
    traverse$1(obj).forEach(function callback() {
      if (targetKeys.includes(this.key) && typeof this.node === "string") {
        const nodePath = this.path;
        const fullPath = basePath.concat(this.path);
        const absolutifiedRefValue = absolutifyPointer(this.node, getBaseUrlForNodePath(nodePath));
        patches.push(specmap.replace(fullPath, absolutifiedRefValue));
      }
    });
    return patches;
  }
  function absolutifyPointer(pointer, baseUrl2) {
    const [urlPart, fragmentPart] = pointer.split("#");
    const safeBaseUrl = baseUrl2 !== null && baseUrl2 !== void 0 ? baseUrl2 : "";
    const safeUrlPart = urlPart !== null && urlPart !== void 0 ? urlPart : "";
    let newRefUrlPart;
    if (!isHttpUrl(safeBaseUrl)) {
      const absoluteBaseUrl = resolve$2(DEFAULT_BASE_URL, safeBaseUrl);
      const absoluteRefUrlPart = resolve$2(absoluteBaseUrl, safeUrlPart);
      const rawRefUrlPart = absoluteRefUrlPart.replace(DEFAULT_BASE_URL, "");
      newRefUrlPart = safeUrlPart.startsWith("/") ? rawRefUrlPart : rawRefUrlPart.substring(1);
    } else {
      newRefUrlPart = resolve$2(safeBaseUrl, safeUrlPart);
    }
    return fragmentPart ? `${newRefUrlPart}#${fragmentPart}` : newRefUrlPart;
  }
  const ABSOLUTE_URL_REGEXP = /^([a-z]+:\/\/|\/\/)/i;
  const JSONRefError = createErrorType("JSONRefError", function cb(message, extra, oriError) {
    this.originalError = oriError;
    Object.assign(this, extra || {});
  });
  const docCache = {};
  const specmapRefs = /* @__PURE__ */ new WeakMap();
  const skipResolutionTestFns = [
    // OpenAPI 2.0 response examples
    (path2) => (
      // ["paths", *, *, "responses", *, "examples"]
      path2[0] === "paths" && path2[3] === "responses" && path2[5] === "examples"
    ),
    // OpenAPI 3.0 Response Media Type Examples
    (path2) => (
      // ["paths", *, *, "responses", *, "content", *, "example"]
      path2[0] === "paths" && path2[3] === "responses" && path2[5] === "content" && path2[7] === "example"
    ),
    (path2) => (
      // ["paths", *, *, "responses", *, "content", *, "examples", *, "value"]
      path2[0] === "paths" && path2[3] === "responses" && path2[5] === "content" && path2[7] === "examples" && path2[9] === "value"
    ),
    // OpenAPI 3.0 Request Body Media Type Examples
    (path2) => (
      // ["paths", *, *, "requestBody", "content", *, "example"]
      path2[0] === "paths" && path2[3] === "requestBody" && path2[4] === "content" && path2[6] === "example"
    ),
    (path2) => (
      // ["paths", *, *, "requestBody", "content", *, "examples", *, "value"]
      path2[0] === "paths" && path2[3] === "requestBody" && path2[4] === "content" && path2[6] === "examples" && path2[8] === "value"
    ),
    // OAS 3.0 Parameter Examples
    (path2) => (
      // ["paths", *, "parameters", *, "example"]
      path2[0] === "paths" && path2[2] === "parameters" && path2[4] === "example"
    ),
    (path2) => (
      // ["paths", *, *, "parameters", *, "example"]
      path2[0] === "paths" && path2[3] === "parameters" && path2[5] === "example"
    ),
    (path2) => (
      // ["paths", *, "parameters", *, "examples", *, "value"]
      path2[0] === "paths" && path2[2] === "parameters" && path2[4] === "examples" && path2[6] === "value"
    ),
    (path2) => (
      // ["paths", *, *, "parameters", *, "examples", *, "value"]
      path2[0] === "paths" && path2[3] === "parameters" && path2[5] === "examples" && path2[7] === "value"
    ),
    (path2) => (
      // ["paths", *, "parameters", *, "content", *, "example"]
      path2[0] === "paths" && path2[2] === "parameters" && path2[4] === "content" && path2[6] === "example"
    ),
    (path2) => (
      // ["paths", *, "parameters", *, "content", *, "examples", *, "value"]
      path2[0] === "paths" && path2[2] === "parameters" && path2[4] === "content" && path2[6] === "examples" && path2[8] === "value"
    ),
    (path2) => (
      // ["paths", *, *, "parameters", *, "content", *, "example"]
      path2[0] === "paths" && path2[3] === "parameters" && path2[4] === "content" && path2[7] === "example"
    ),
    (path2) => (
      // ["paths", *, *, "parameters", *, "content", *, "examples", *, "value"]
      path2[0] === "paths" && path2[3] === "parameters" && path2[5] === "content" && path2[7] === "examples" && path2[9] === "value"
    )
  ];
  const shouldSkipResolution = (path2) => skipResolutionTestFns.some((fn) => fn(path2));
  const plugin$6 = {
    key: "$ref",
    plugin: (ref, key, fullPath, specmap) => {
      const specmapInstance = specmap.getInstance();
      const parent2 = fullPath.slice(0, -1);
      if (isFreelyNamed(parent2) || shouldSkipResolution(parent2)) {
        return void 0;
      }
      const {
        baseDoc
      } = specmap.getContext(fullPath);
      if (typeof ref !== "string") {
        return new JSONRefError("$ref: must be a string (JSON-Ref)", {
          $ref: ref,
          baseDoc,
          fullPath
        });
      }
      const splitString = split$1(ref);
      const refPath = splitString[0];
      const pointer = splitString[1] || "";
      let basePath;
      try {
        basePath = baseDoc || refPath ? absoluteify(refPath, baseDoc) : null;
      } catch (e) {
        return wrapError$1(e, {
          pointer,
          $ref: ref,
          basePath,
          fullPath
        });
      }
      let promOrVal;
      let tokens;
      if (pointerAlreadyInPath(pointer, basePath, parent2, specmap)) {
        if (!specmapInstance.useCircularStructures) {
          const absolutifiedRef2 = absolutifyPointer(ref, basePath);
          if (ref === absolutifiedRef2) {
            return null;
          }
          return lib$4.replace(fullPath, absolutifiedRef2);
        }
      }
      if (basePath == null) {
        tokens = jsonPointerToArray(pointer);
        promOrVal = specmap.get(tokens);
        if (typeof promOrVal === "undefined") {
          promOrVal = new JSONRefError(`Could not resolve reference: ${ref}`, {
            pointer,
            $ref: ref,
            baseDoc,
            fullPath
          });
        }
      } else {
        promOrVal = extractFromDoc(basePath, pointer);
        if (promOrVal.__value != null) {
          promOrVal = promOrVal.__value;
        } else {
          promOrVal = promOrVal.catch((e) => {
            throw wrapError$1(e, {
              pointer,
              $ref: ref,
              baseDoc,
              fullPath
            });
          });
        }
      }
      if (promOrVal instanceof Error) {
        return [lib$4.remove(fullPath), promOrVal];
      }
      const absolutifiedRef = absolutifyPointer(ref, basePath);
      const patch = lib$4.replace(parent2, promOrVal, {
        $$ref: absolutifiedRef
      });
      if (basePath && basePath !== baseDoc) {
        return [patch, lib$4.context(parent2, {
          baseDoc: basePath
        })];
      }
      try {
        if (!patchValueAlreadyInPath(specmap.state, patch) || specmapInstance.useCircularStructures) {
          return patch;
        }
      } catch (e) {
        return null;
      }
      return void 0;
    }
  };
  const mod = Object.assign(plugin$6, {
    docCache,
    absoluteify,
    clearCache: clearCache$1,
    JSONRefError,
    wrapError: wrapError$1,
    getDoc,
    split: split$1,
    extractFromDoc,
    fetchJSON,
    extract,
    jsonPointerToArray,
    unescapeJsonPointerToken
  });
  function absoluteify(path2, basePath) {
    if (!ABSOLUTE_URL_REGEXP.test(path2)) {
      if (!basePath) {
        throw new JSONRefError(`Tried to resolve a relative URL, without having a basePath. path: '${path2}' basePath: '${basePath}'`);
      }
      return resolve$2(basePath, path2);
    }
    return path2;
  }
  function wrapError$1(e, extra) {
    let message;
    if (e && e.response && e.response.body) {
      message = `${e.response.body.code} ${e.response.body.message}`;
    } else {
      message = e.message;
    }
    return new JSONRefError(`Could not resolve reference: ${message}`, extra, e);
  }
  function split$1(ref) {
    return (ref + "").split("#");
  }
  function extractFromDoc(docPath, pointer) {
    const doc = docCache[docPath];
    if (doc && !lib$4.isPromise(doc)) {
      try {
        const v = extract(pointer, doc);
        return Object.assign(Promise.resolve(v), {
          __value: v
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    return getDoc(docPath).then((_doc) => extract(pointer, _doc));
  }
  function clearCache$1(item) {
    if (typeof item !== "undefined") {
      delete docCache[item];
    } else {
      Object.keys(docCache).forEach((key) => {
        delete docCache[key];
      });
    }
  }
  function getDoc(docPath) {
    const val = docCache[docPath];
    if (val) {
      return lib$4.isPromise(val) ? val : Promise.resolve(val);
    }
    docCache[docPath] = mod.fetchJSON(docPath).then((doc) => {
      docCache[docPath] = doc;
      return doc;
    });
    return docCache[docPath];
  }
  function fetchJSON(docPath) {
    return fetch(docPath, {
      headers: {
        Accept: ACCEPT_HEADER_VALUE_FOR_DOCUMENTS
      },
      loadSpec: true
    }).then((res) => res.text()).then((text) => jsYaml.load(text));
  }
  function extract(pointer, obj) {
    const tokens = jsonPointerToArray(pointer);
    if (tokens.length < 1) {
      return obj;
    }
    const val = lib$4.getIn(obj, tokens);
    if (typeof val === "undefined") {
      throw new JSONRefError(`Could not resolve pointer: ${pointer} does not exist in document`, {
        pointer
      });
    }
    return val;
  }
  function jsonPointerToArray(pointer) {
    if (typeof pointer !== "string") {
      throw new TypeError(`Expected a string, got a ${typeof pointer}`);
    }
    if (pointer[0] === "/") {
      pointer = pointer.substr(1);
    }
    if (pointer === "") {
      return [];
    }
    return pointer.split("/").map(unescapeJsonPointerToken);
  }
  function unescapeJsonPointerToken(token) {
    if (typeof token !== "string") {
      return token;
    }
    const params = new URLSearchParams(`=${token.replace(/~1/g, "/").replace(/~0/g, "~")}`);
    return params.get("");
  }
  function escapeJsonPointerToken(token) {
    const params = new URLSearchParams([["", token.replace(/~/g, "~0").replace(/\//g, "~1")]]);
    return params.toString().slice(1);
  }
  function arrayToJsonPointer(arr) {
    if (arr.length === 0) {
      return "";
    }
    return `/${arr.map(escapeJsonPointerToken).join("/")}`;
  }
  const pointerBoundaryChar = (c) => !c || c === "/" || c === "#";
  function pointerIsAParent(pointer, parentPointer) {
    if (pointerBoundaryChar(parentPointer)) {
      return true;
    }
    const nextChar = pointer.charAt(parentPointer.length);
    const lastParentChar = parentPointer.slice(-1);
    return pointer.indexOf(parentPointer) === 0 && (!nextChar || nextChar === "/" || nextChar === "#") && lastParentChar !== "#";
  }
  function pointerAlreadyInPath(pointer, basePath, parent2, specmap) {
    let refs = specmapRefs.get(specmap);
    if (!refs) {
      refs = {};
      specmapRefs.set(specmap, refs);
    }
    const parentPointer = arrayToJsonPointer(parent2);
    const fullyQualifiedPointer = `${basePath || "<specmap-base>"}#${pointer}`;
    const safeParentPointer = parentPointer.replace(/allOf\/\d+\/?/g, "");
    const rootDoc = specmap.contextTree.get([]).baseDoc;
    if (basePath === rootDoc && pointerIsAParent(safeParentPointer, pointer)) {
      return true;
    }
    let currPath = "";
    const hasIndirectCycle = parent2.some((token) => {
      currPath = `${currPath}/${escapeJsonPointerToken(token)}`;
      return refs[currPath] && refs[currPath].some((ref) => pointerIsAParent(ref, fullyQualifiedPointer) || pointerIsAParent(fullyQualifiedPointer, ref));
    });
    if (hasIndirectCycle) {
      return true;
    }
    refs[safeParentPointer] = (refs[safeParentPointer] || []).concat(fullyQualifiedPointer);
    return void 0;
  }
  function patchValueAlreadyInPath(root2, patch) {
    const ancestors = [root2];
    patch.path.reduce((parent2, p2) => {
      ancestors.push(parent2[p2]);
      return parent2[p2];
    }, root2);
    return pointToAncestor(patch.value);
    function pointToAncestor(obj) {
      return lib$4.isObject(obj) && (ancestors.indexOf(obj) >= 0 || Object.keys(obj).some((k2) => pointToAncestor(obj[k2])));
    }
  }
  const allOf = {
    key: "allOf",
    plugin: (val, key, fullPath, specmap, patch) => {
      if (patch.meta && patch.meta.$$ref) {
        return void 0;
      }
      const parent2 = fullPath.slice(0, -1);
      if (isFreelyNamed(parent2)) {
        return void 0;
      }
      if (!Array.isArray(val)) {
        const err = new TypeError("allOf must be an array");
        err.fullPath = fullPath;
        return err;
      }
      let alreadyAddError = false;
      let originalDefinitionObj = patch.value;
      parent2.forEach((part) => {
        if (!originalDefinitionObj)
          return;
        originalDefinitionObj = originalDefinitionObj[part];
      });
      originalDefinitionObj = {
        ...originalDefinitionObj
      };
      if (Object.keys(originalDefinitionObj).length === 0) {
        return void 0;
      }
      delete originalDefinitionObj.allOf;
      const patches = [];
      patches.push(specmap.replace(parent2, {}));
      val.forEach((toMerge, i2) => {
        if (!specmap.isObject(toMerge)) {
          if (alreadyAddError) {
            return null;
          }
          alreadyAddError = true;
          const err = new TypeError("Elements in allOf must be objects");
          err.fullPath = fullPath;
          return patches.push(err);
        }
        patches.push(specmap.mergeDeep(parent2, toMerge));
        const collapsedFullPath = fullPath.slice(0, -1);
        const absoluteRefPatches = generateAbsoluteRefPatches(toMerge, collapsedFullPath, {
          getBaseUrlForNodePath: (nodePath) => specmap.getContext([...fullPath, i2, ...nodePath]).baseDoc,
          specmap
        });
        patches.push(...absoluteRefPatches);
        return void 0;
      });
      if (originalDefinitionObj.example) {
        patches.push(specmap.remove([].concat(parent2, "example")));
      }
      patches.push(specmap.mergeDeep(parent2, originalDefinitionObj));
      if (!originalDefinitionObj.$$ref) {
        patches.push(specmap.remove([].concat(parent2, "$$ref")));
      }
      return patches;
    }
  };
  const parameters = {
    key: "parameters",
    plugin: (parameters2, key, fullPath, specmap) => {
      if (Array.isArray(parameters2) && parameters2.length) {
        const val = Object.assign([], parameters2);
        const opPath = fullPath.slice(0, -1);
        const op = {
          ...lib$4.getIn(specmap.spec, opPath)
        };
        for (let i2 = 0; i2 < parameters2.length; i2 += 1) {
          const param = parameters2[i2];
          try {
            val[i2].default = specmap.parameterMacro(op, param);
          } catch (e) {
            const err = new Error(e);
            err.fullPath = fullPath;
            return err;
          }
        }
        return lib$4.replace(fullPath, val);
      }
      return lib$4.replace(fullPath, parameters2);
    }
  };
  const properties = {
    key: "properties",
    plugin: (properties2, key, fullPath, specmap) => {
      const val = {
        ...properties2
      };
      for (const k2 in properties2) {
        try {
          val[k2].default = specmap.modelPropertyMacro(val[k2]);
        } catch (e) {
          const err = new Error(e);
          err.fullPath = fullPath;
          return err;
        }
      }
      const patch = lib$4.replace(fullPath, val);
      return patch;
    }
  };
  class ContextTree {
    constructor(value2) {
      this.root = createNode(value2 || {});
    }
    set(path2, value2) {
      const parent2 = this.getParent(path2, true);
      if (!parent2) {
        updateNode(this.root, value2, null);
        return;
      }
      const key = path2[path2.length - 1];
      const {
        children
      } = parent2;
      if (children[key]) {
        updateNode(children[key], value2, parent2);
        return;
      }
      children[key] = createNode(value2, parent2);
    }
    // Get the "best" node (node or nearest parent) and return its value.
    get(path2) {
      path2 = path2 || [];
      if (path2.length < 1) {
        return this.root.value;
      }
      let branch = this.root;
      let child;
      let token;
      for (let i2 = 0; i2 < path2.length; i2 += 1) {
        token = path2[i2];
        child = branch.children;
        if (!child[token]) {
          break;
        }
        branch = child[token];
      }
      return branch && branch.protoValue;
    }
    getParent(path2, ensureExists) {
      if (!path2 || path2.length < 1) {
        return null;
      }
      if (path2.length < 2) {
        return this.root;
      }
      return path2.slice(0, -1).reduce((branch, token) => {
        if (!branch) {
          return branch;
        }
        const {
          children
        } = branch;
        if (!children[token] && ensureExists) {
          children[token] = createNode(null, branch);
        }
        return children[token];
      }, this.root);
    }
  }
  function createNode(value2, parent2) {
    return updateNode({
      children: {}
    }, value2, parent2);
  }
  function updateNode(node, value2, parent2) {
    node.value = value2 || {};
    node.protoValue = parent2 ? {
      ...parent2.protoValue,
      ...node.value
    } : node.value;
    Object.keys(node.children).forEach((prop2) => {
      const child = node.children[prop2];
      node.children[prop2] = updateNode(child, child.value, node);
    });
    return node;
  }
  const HARD_LIMIT = 100;
  const noop$1 = () => {
  };
  class SpecMap {
    static getPluginName(plugin2) {
      return plugin2.pluginName;
    }
    static getPatchesOfType(patches, fn) {
      return patches.filter(fn);
    }
    constructor(opts) {
      Object.assign(this, {
        spec: "",
        debugLevel: "info",
        plugins: [],
        pluginHistory: {},
        errors: [],
        mutations: [],
        promisedPatches: [],
        state: {},
        patches: [],
        context: {},
        contextTree: new ContextTree(),
        showDebug: false,
        allPatches: [],
        // only populated if showDebug is true
        pluginProp: "specMap",
        libMethods: Object.assign(Object.create(this), lib$4, {
          getInstance: () => this
        }),
        allowMetaPatches: false
      }, opts);
      this.get = this._get.bind(this);
      this.getContext = this._getContext.bind(this);
      this.hasRun = this._hasRun.bind(this);
      this.wrappedPlugins = this.plugins.map(this.wrapPlugin.bind(this)).filter(lib$4.isFunction);
      this.patches.push(lib$4.add([], this.spec));
      this.patches.push(lib$4.context([], this.context));
      this.updatePatches(this.patches);
    }
    debug(level) {
      if (this.debugLevel === level) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        console.log(...args);
      }
    }
    verbose(header2) {
      if (this.debugLevel === "verbose") {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        console.log(`[${header2}]   `, ...args);
      }
    }
    wrapPlugin(plugin2, name) {
      const {
        pathDiscriminator
      } = this;
      let ctx = null;
      let fn;
      if (plugin2[this.pluginProp]) {
        ctx = plugin2;
        fn = plugin2[this.pluginProp];
      } else if (lib$4.isFunction(plugin2)) {
        fn = plugin2;
      } else if (lib$4.isObject(plugin2)) {
        fn = createKeyBasedPlugin(plugin2);
      }
      return Object.assign(fn.bind(ctx), {
        pluginName: plugin2.name || name,
        isGenerator: lib$4.isGenerator(fn)
      });
      function createKeyBasedPlugin(pluginObj) {
        const isSubPath = (path2, tested) => {
          if (!Array.isArray(path2)) {
            return true;
          }
          return path2.every((val, i2) => val === tested[i2]);
        };
        return function* generator(patches, specmap) {
          const refCache = {};
          for (const patch of patches.filter(lib$4.isAdditiveMutation)) {
            yield* traverse2(patch.value, patch.path, patch);
          }
          function* traverse2(obj, path2, patch) {
            if (!lib$4.isObject(obj)) {
              if (pluginObj.key === path2[path2.length - 1]) {
                yield pluginObj.plugin(obj, pluginObj.key, path2, specmap);
              }
            } else {
              const parentIndex = path2.length - 1;
              const parent2 = path2[parentIndex];
              const indexOfFirstProperties = path2.indexOf("properties");
              const isRootProperties = parent2 === "properties" && parentIndex === indexOfFirstProperties;
              const traversed = specmap.allowMetaPatches && refCache[obj.$$ref];
              for (const key of Object.keys(obj)) {
                const val = obj[key];
                const updatedPath = path2.concat(key);
                const isObj2 = lib$4.isObject(val);
                const objRef = obj.$$ref;
                if (!traversed) {
                  if (isObj2) {
                    if (specmap.allowMetaPatches && objRef) {
                      refCache[objRef] = true;
                    }
                    yield* traverse2(val, updatedPath, patch);
                  }
                }
                if (!isRootProperties && key === pluginObj.key) {
                  const isWithinPathDiscriminator = isSubPath(pathDiscriminator, path2);
                  if (!pathDiscriminator || isWithinPathDiscriminator) {
                    yield pluginObj.plugin(val, key, updatedPath, specmap, patch);
                  }
                }
              }
            }
          }
        };
      }
    }
    nextPlugin() {
      return this.wrappedPlugins.find((plugin2) => {
        const mutations = this.getMutationsForPlugin(plugin2);
        return mutations.length > 0;
      });
    }
    nextPromisedPatch() {
      if (this.promisedPatches.length > 0) {
        return Promise.race(this.promisedPatches.map((patch) => patch.value));
      }
      return void 0;
    }
    getPluginHistory(plugin2) {
      const name = this.constructor.getPluginName(plugin2);
      return this.pluginHistory[name] || [];
    }
    getPluginRunCount(plugin2) {
      return this.getPluginHistory(plugin2).length;
    }
    getPluginHistoryTip(plugin2) {
      const history = this.getPluginHistory(plugin2);
      const val = history && history[history.length - 1];
      return val || {};
    }
    getPluginMutationIndex(plugin2) {
      const mi = this.getPluginHistoryTip(plugin2).mutationIndex;
      return typeof mi !== "number" ? -1 : mi;
    }
    updatePluginHistory(plugin2, val) {
      const name = this.constructor.getPluginName(plugin2);
      this.pluginHistory[name] = this.pluginHistory[name] || [];
      this.pluginHistory[name].push(val);
    }
    updatePatches(patches) {
      lib$4.normalizeArray(patches).forEach((patch) => {
        if (patch instanceof Error) {
          this.errors.push(patch);
          return;
        }
        try {
          if (!lib$4.isObject(patch)) {
            this.debug("updatePatches", "Got a non-object patch", patch);
            return;
          }
          if (this.showDebug) {
            this.allPatches.push(patch);
          }
          if (lib$4.isPromise(patch.value)) {
            this.promisedPatches.push(patch);
            this.promisedPatchThen(patch);
            return;
          }
          if (lib$4.isContextPatch(patch)) {
            this.setContext(patch.path, patch.value);
            return;
          }
          if (lib$4.isMutation(patch)) {
            this.updateMutations(patch);
          }
        } catch (e) {
          console.error(e);
          this.errors.push(e);
        }
      });
    }
    updateMutations(patch) {
      if (typeof patch.value === "object" && !Array.isArray(patch.value) && this.allowMetaPatches) {
        patch.value = {
          ...patch.value
        };
      }
      const result = lib$4.applyPatch(this.state, patch, {
        allowMetaPatches: this.allowMetaPatches
      });
      if (result) {
        this.mutations.push(patch);
        this.state = result;
      }
    }
    removePromisedPatch(patch) {
      const index2 = this.promisedPatches.indexOf(patch);
      if (index2 < 0) {
        this.debug("Tried to remove a promisedPatch that isn't there!");
        return;
      }
      this.promisedPatches.splice(index2, 1);
    }
    promisedPatchThen(patch) {
      patch.value = patch.value.then((val) => {
        const promisedPatch = {
          ...patch,
          value: val
        };
        this.removePromisedPatch(patch);
        this.updatePatches(promisedPatch);
      }).catch((e) => {
        this.removePromisedPatch(patch);
        this.updatePatches(e);
      });
      return patch.value;
    }
    getMutations(from2, to) {
      from2 = from2 || 0;
      if (typeof to !== "number") {
        to = this.mutations.length;
      }
      return this.mutations.slice(from2, to);
    }
    getCurrentMutations() {
      return this.getMutationsForPlugin(this.getCurrentPlugin());
    }
    getMutationsForPlugin(plugin2) {
      const tip = this.getPluginMutationIndex(plugin2);
      return this.getMutations(tip + 1);
    }
    getCurrentPlugin() {
      return this.currentPlugin;
    }
    getLib() {
      return this.libMethods;
    }
    // eslint-disable-next-line no-underscore-dangle
    _get(path2) {
      return lib$4.getIn(this.state, path2);
    }
    // eslint-disable-next-line no-underscore-dangle
    _getContext(path2) {
      return this.contextTree.get(path2);
    }
    setContext(path2, value2) {
      return this.contextTree.set(path2, value2);
    }
    // eslint-disable-next-line no-underscore-dangle
    _hasRun(count2) {
      const times = this.getPluginRunCount(this.getCurrentPlugin());
      return times > (count2 || 0);
    }
    dispatch() {
      const that = this;
      const plugin2 = this.nextPlugin();
      if (!plugin2) {
        const nextPromise = this.nextPromisedPatch();
        if (nextPromise) {
          return nextPromise.then(() => this.dispatch()).catch(() => this.dispatch());
        }
        const result = {
          spec: this.state,
          errors: this.errors
        };
        if (this.showDebug) {
          result.patches = this.allPatches;
        }
        return Promise.resolve(result);
      }
      that.pluginCount = that.pluginCount || {};
      that.pluginCount[plugin2] = (that.pluginCount[plugin2] || 0) + 1;
      if (that.pluginCount[plugin2] > HARD_LIMIT) {
        return Promise.resolve({
          spec: that.state,
          errors: that.errors.concat(new Error(`We've reached a hard limit of ${HARD_LIMIT} plugin runs`))
        });
      }
      if (plugin2 !== this.currentPlugin && this.promisedPatches.length) {
        const promises = this.promisedPatches.map((p2) => p2.value);
        return Promise.all(promises.map((promise) => promise.then(noop$1, noop$1))).then(() => this.dispatch());
      }
      return executePlugin();
      function executePlugin() {
        that.currentPlugin = plugin2;
        const mutations = that.getCurrentMutations();
        const lastMutationIndex = that.mutations.length - 1;
        try {
          if (plugin2.isGenerator) {
            for (const yieldedPatches of plugin2(mutations, that.getLib())) {
              updatePatches(yieldedPatches);
            }
          } else {
            const newPatches = plugin2(mutations, that.getLib());
            updatePatches(newPatches);
          }
        } catch (e) {
          console.error(e);
          updatePatches([Object.assign(Object.create(e), {
            plugin: plugin2
          })]);
        } finally {
          that.updatePluginHistory(plugin2, {
            mutationIndex: lastMutationIndex
          });
        }
        return that.dispatch();
      }
      function updatePatches(patches) {
        if (patches) {
          patches = lib$4.fullyNormalizeArray(patches);
          that.updatePatches(patches, plugin2);
        }
      }
    }
  }
  function mapSpec(opts) {
    return new SpecMap(opts).dispatch();
  }
  const plugins = {
    refs: mod,
    allOf,
    parameters,
    properties
  };
  const replaceSpecialCharsWithUnderscore$1 = (operationId) => operationId.replace(/\W/gi, "_");
  function idFromPathMethod(pathName, method) {
    let {
      v2OperationIdCompatibilityMode
    } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (v2OperationIdCompatibilityMode) {
      let res = `${method.toLowerCase()}_${pathName}`.replace(/[\s!@#$%^&*()_+=[{\]};:<>|./?,\\'""-]/g, "_");
      res = res || `${pathName.substring(1)}_${method}`;
      return res.replace(/((_){2,})/g, "_").replace(/^(_)*/g, "").replace(/([_])*$/g, "");
    }
    return `${method.toLowerCase()}${replaceSpecialCharsWithUnderscore$1(pathName)}`;
  }
  function opId(operation, pathName) {
    let method = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
    let {
      v2OperationIdCompatibilityMode
    } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (!operation || typeof operation !== "object") {
      return null;
    }
    const idWithoutWhitespace = (operation.operationId || "").replace(/\s/g, "");
    if (idWithoutWhitespace.length) {
      return replaceSpecialCharsWithUnderscore$1(operation.operationId);
    }
    return idFromPathMethod(pathName, method, {
      v2OperationIdCompatibilityMode
    });
  }
  function normalize$1(parsedSpec) {
    const {
      spec
    } = parsedSpec;
    const {
      paths: paths2
    } = spec;
    const map2 = {};
    if (!paths2 || spec.$$normalized) {
      return parsedSpec;
    }
    for (const pathName in paths2) {
      const path2 = paths2[pathName];
      if (path2 == null || !["object", "function"].includes(typeof path2)) {
        continue;
      }
      const pathParameters = path2.parameters;
      for (const method in path2) {
        const operation = path2[method];
        if (operation == null || !["object", "function"].includes(typeof operation)) {
          continue;
        }
        const oid = opId(operation, pathName, method);
        if (oid) {
          if (map2[oid]) {
            map2[oid].push(operation);
          } else {
            map2[oid] = [operation];
          }
          const opList = map2[oid];
          if (opList.length > 1) {
            opList.forEach((o, i2) => {
              o.__originalOperationId = o.__originalOperationId || o.operationId;
              o.operationId = `${oid}${i2 + 1}`;
            });
          } else if (typeof operation.operationId !== "undefined") {
            const obj = opList[0];
            obj.__originalOperationId = obj.__originalOperationId || operation.operationId;
            obj.operationId = oid;
          }
        }
        if (method !== "parameters") {
          const inheritsList = [];
          const toBeInherit = {};
          for (const key in spec) {
            if (key === "produces" || key === "consumes" || key === "security") {
              toBeInherit[key] = spec[key];
              inheritsList.push(toBeInherit);
            }
          }
          if (pathParameters) {
            toBeInherit.parameters = pathParameters;
            inheritsList.push(toBeInherit);
          }
          if (inheritsList.length) {
            for (const inherits2 of inheritsList) {
              for (const inheritName in inherits2) {
                if (!operation[inheritName]) {
                  operation[inheritName] = inherits2[inheritName];
                } else if (inheritName === "parameters") {
                  for (const param of inherits2[inheritName]) {
                    const exists2 = operation[inheritName].some((opParam) => opParam.name && opParam.name === param.name || opParam.$ref && opParam.$ref === param.$ref || opParam.$$ref && opParam.$$ref === param.$$ref || opParam === param);
                    if (!exists2) {
                      operation[inheritName].push(param);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    spec.$$normalized = true;
    return parsedSpec;
  }
  async function resolveGenericStrategy(options) {
    const {
      spec,
      mode,
      allowMetaPatches = true,
      pathDiscriminator,
      modelPropertyMacro,
      parameterMacro,
      requestInterceptor,
      responseInterceptor,
      skipNormalization,
      useCircularStructures
    } = options;
    const retrievalURI$1 = retrievalURI(options);
    const httpClient$1 = httpClient(options);
    return doResolve(spec);
    function doResolve(_spec) {
      if (retrievalURI$1) {
        plugins.refs.docCache[retrievalURI$1] = _spec;
      }
      plugins.refs.fetchJSON = makeFetchJSON(httpClient$1, {
        requestInterceptor,
        responseInterceptor
      });
      const plugs = [plugins.refs];
      if (typeof parameterMacro === "function") {
        plugs.push(plugins.parameters);
      }
      if (typeof modelPropertyMacro === "function") {
        plugs.push(plugins.properties);
      }
      if (mode !== "strict") {
        plugs.push(plugins.allOf);
      }
      return mapSpec({
        spec: _spec,
        context: {
          baseDoc: retrievalURI$1
        },
        plugins: plugs,
        allowMetaPatches,
        // allows adding .meta patches, which include adding `$$ref`s to the spec
        pathDiscriminator,
        // for lazy resolution
        parameterMacro,
        modelPropertyMacro,
        useCircularStructures
        // eslint-disable-next-line camelcase
      }).then(skipNormalization ? async (a) => a : normalize$1);
    }
  }
  function clearCache() {
    plugins.refs.clearCache();
  }
  const genericStrategy = {
    name: "generic",
    match() {
      return true;
    },
    normalize(_ref) {
      let {
        spec
      } = _ref;
      const {
        spec: normalized
      } = normalize$1({
        spec
      });
      return normalized;
    },
    async resolve(options) {
      return resolveGenericStrategy(options);
    }
  };
  async function resolveOpenAPI2Strategy(options) {
    return resolveGenericStrategy(options);
  }
  const isOpenAPI2 = (spec) => {
    try {
      const {
        swagger
      } = spec;
      return swagger === "2.0";
    } catch {
      return false;
    }
  };
  const isOpenAPI30 = (spec) => {
    try {
      const {
        openapi
      } = spec;
      return typeof openapi === "string" && /^3\.0\.([0123])(?:-rc[012])?$/.test(openapi);
    } catch {
      return false;
    }
  };
  const isOpenAPI31 = (spec) => {
    try {
      const {
        openapi
      } = spec;
      return typeof openapi === "string" && /^3\.1\.(?:[1-9]\d*|0)$/.test(openapi);
    } catch {
      return false;
    }
  };
  const isOpenAPI3 = (spec) => isOpenAPI30(spec) || isOpenAPI31(spec);
  const openApi2Strategy = {
    name: "openapi-2",
    match(_ref) {
      let {
        spec
      } = _ref;
      return isOpenAPI2(spec);
    },
    normalize(_ref2) {
      let {
        spec
      } = _ref2;
      const {
        spec: normalized
      } = normalize$1({
        spec
      });
      return normalized;
    },
    async resolve(options) {
      return resolveOpenAPI2Strategy(options);
    }
  };
  async function resolveOpenAPI30Strategy(options) {
    return resolveGenericStrategy(options);
  }
  const openApi30Strategy = {
    name: "openapi-3-0",
    match(_ref) {
      let {
        spec
      } = _ref;
      return isOpenAPI30(spec);
    },
    normalize(_ref2) {
      let {
        spec
      } = _ref2;
      const {
        spec: normalized
      } = normalize$1({
        spec
      });
      return normalized;
    },
    async resolve(options) {
      return resolveOpenAPI30Strategy(options);
    }
  };
  const resolve = async (options) => {
    const {
      spec,
      requestInterceptor,
      responseInterceptor
    } = options;
    const retrievalURI$1 = retrievalURI(options);
    const httpClient$1 = httpClient(options);
    const retrievedSpec = spec || await makeFetchJSON(httpClient$1, {
      requestInterceptor,
      responseInterceptor
    })(retrievalURI$1);
    const strategyOptions = {
      ...options,
      spec: retrievedSpec
    };
    const strategy = options.strategies.find((strg) => strg.match(strategyOptions));
    return strategy.resolve(strategyOptions);
  };
  const makeResolve = (defaultOptions2) => async (options) => {
    const mergedOptions = {
      ...defaultOptions2,
      ...options
    };
    return resolve(mergedOptions);
  };
  const resolve$1 = makeResolve({
    strategies: [openApi30Strategy, openApi2Strategy, genericStrategy]
  });
  const resolveSubtree = async function(obj, path2) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const {
      returnEntireTree,
      baseDoc,
      requestInterceptor,
      responseInterceptor,
      parameterMacro,
      modelPropertyMacro,
      useCircularStructures,
      strategies
    } = options;
    const resolveOptions = {
      spec: obj,
      pathDiscriminator: path2,
      baseDoc,
      requestInterceptor,
      responseInterceptor,
      parameterMacro,
      modelPropertyMacro,
      useCircularStructures,
      strategies
    };
    const strategy = strategies.find((strg) => strg.match(resolveOptions));
    const normalized = strategy.normalize(resolveOptions);
    const result = await resolve$1({
      ...resolveOptions,
      spec: normalized,
      allowMetaPatches: true,
      skipNormalization: true
    });
    if (!returnEntireTree && Array.isArray(path2) && path2.length) {
      result.spec = path2.reduce((acc, pathSegment) => acc === null || acc === void 0 ? void 0 : acc[pathSegment], result.spec) || null;
    }
    return result;
  };
  const makeResolveSubtree = (defaultOptions2) => async function(obj, path2) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const mergedOptions = {
      ...defaultOptions2,
      ...options
    };
    return resolveSubtree(obj, path2, mergedOptions);
  };
  class JsonPointerError extends ApiDOMStructuredError$1 {
  }
  const JsonPointerError$1 = JsonPointerError;
  class InvalidJsonPointerError extends JsonPointerError$1 {
    constructor(message, structuredOptions) {
      super(message, structuredOptions);
      if (typeof structuredOptions !== "undefined") {
        this.pointer = structuredOptions.pointer;
      }
    }
  }
  const InvalidJsonPointerError$1 = InvalidJsonPointerError;
  class CompilationJsonPointerError extends JsonPointerError$1 {
    constructor(message, structuredOptions) {
      super(message, structuredOptions);
      if (typeof structuredOptions !== "undefined") {
        this.tokens = [...structuredOptions.tokens];
      }
    }
  }
  const CompilationJsonPointerError$1 = CompilationJsonPointerError;
  class EvaluationJsonPointerError extends JsonPointerError$1 {
    constructor(message, structuredOptions) {
      super(message, structuredOptions);
      if (typeof structuredOptions !== "undefined") {
        this.pointer = structuredOptions.pointer;
        if (Array.isArray(structuredOptions.tokens)) {
          this.tokens = [...structuredOptions.tokens];
        }
        this.failedToken = structuredOptions.failedToken;
        this.failedTokenPosition = structuredOptions.failedTokenPosition;
        this.element = structuredOptions.element.element;
        if (hasElementSourceMap(structuredOptions.element)) {
          this.elementSourceMap = toValue(structuredOptions.element.getMetaProperty("sourceMap"));
        }
      }
    }
  }
  const EvaluationJsonPointerError$1 = EvaluationJsonPointerError;
  const escape$1 = pipe$2(replace$2(/~/g, "~0"), replace$2(/\//g, "~1"), encodeURIComponent);
  const escape$2 = escape$1;
  const safeDecodeURIComponent = (encodedURIComponent) => {
    try {
      return decodeURIComponent(encodedURIComponent);
    } catch {
      return encodedURIComponent;
    }
  };
  const unescape$1 = pipe$2(replace$2(/~1/g, "/"), replace$2(/~0/g, "~"), safeDecodeURIComponent);
  const unescape$2 = unescape$1;
  const parse$3 = (pointer) => {
    if (isEmptyString$1(pointer)) {
      return [];
    }
    if (!startsWith$1("/", pointer)) {
      throw new InvalidJsonPointerError$1(`Invalid JSON Pointer "${pointer}". JSON Pointers must begin with "/"`, {
        pointer
      });
    }
    try {
      const tokens = pipe$2(split$4("/"), map$4(unescape$2))(pointer);
      return tail$1(tokens);
    } catch (error) {
      throw new InvalidJsonPointerError$1(`JSON Pointer parsing of "${pointer}" encountered an error.`, {
        pointer,
        cause: error
      });
    }
  };
  const getHash = (uri) => {
    const hashIndex = uri.indexOf("#");
    if (hashIndex !== -1) {
      return uri.substring(hashIndex);
    }
    return "#";
  };
  const uriToPointer = (uri) => {
    const hash2 = getHash(uri);
    return trimCharsStart$1("#", hash2);
  };
  const compile = (tokens) => {
    try {
      if (tokens.length === 0) {
        return "";
      }
      return `/${tokens.map(escape$2).join("/")}`;
    } catch (error) {
      throw new CompilationJsonPointerError$1("JSON Pointer compilation of tokens encountered an error.", {
        tokens,
        cause: error
      });
    }
  };
  const jsonPointerCompile = compile;
  const evaluate$2 = (pointer, element) => {
    let tokens;
    try {
      tokens = parse$3(pointer);
    } catch (error) {
      throw new EvaluationJsonPointerError$1(`JSON Pointer evaluation failed while parsing the pointer "${pointer}".`, {
        pointer,
        element,
        cause: error
      });
    }
    return tokens.reduce((acc, token, tokenPosition) => {
      if (isObjectElement(acc)) {
        if (!acc.hasKey(token)) {
          throw new EvaluationJsonPointerError$1(`JSON Pointer evaluation failed while evaluating token "${token}" against an ObjectElement`, {
            pointer,
            tokens,
            failedToken: token,
            failedTokenPosition: tokenPosition,
            element: acc
          });
        }
        return acc.get(token);
      }
      if (isArrayElement(acc)) {
        if (!(token in acc.content) || !isInteger$2(Number(token))) {
          throw new EvaluationJsonPointerError$1(`JSON Pointer evaluation failed while evaluating token "${token}" against an ArrayElement`, {
            pointer,
            tokens,
            failedToken: token,
            failedTokenPosition: tokenPosition,
            element: acc
          });
        }
        return acc.get(Number(token));
      }
      throw new EvaluationJsonPointerError$1(`JSON Pointer evaluation failed while evaluating token "${token}" against an unexpected Element`, {
        pointer,
        tokens,
        failedToken: token,
        failedTokenPosition: tokenPosition,
        element: acc
      });
    }, element);
  };
  const jsonPointerEvaluate = evaluate$2;
  class OpenAPIMediaTypes extends MediaTypes$1 {
    filterByFormat(format = "generic") {
      const effectiveFormat = format === "generic" ? "openapi;version" : format;
      return this.filter((mediaType) => mediaType.includes(effectiveFormat));
    }
    findBy(version2 = "3.1.0", format = "generic") {
      const search = format === "generic" ? `vnd.oai.openapi;version=${version2}` : `vnd.oai.openapi+${format};version=${version2}`;
      const found = this.find((mediaType) => mediaType.includes(search));
      return found || this.unknownMediaType;
    }
    latest(format = "generic") {
      return last$2(this.filterByFormat(format));
    }
  }
  const mediaTypes = new OpenAPIMediaTypes("application/vnd.oai.openapi;version=3.1.0", "application/vnd.oai.openapi+json;version=3.1.0", "application/vnd.oai.openapi+yaml;version=3.1.0");
  const mediaTypes$1 = mediaTypes;
  let Callback$1 = class Callback extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "callback";
    }
  };
  const CallbackElement$1 = Callback$1;
  let Components$1 = class Components extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "components";
    }
    get schemas() {
      return this.get("schemas");
    }
    set schemas(schemas) {
      this.set("schemas", schemas);
    }
    get responses() {
      return this.get("responses");
    }
    set responses(responses) {
      this.set("responses", responses);
    }
    get parameters() {
      return this.get("parameters");
    }
    set parameters(parameters2) {
      this.set("parameters", parameters2);
    }
    get examples() {
      return this.get("examples");
    }
    set examples(examples) {
      this.set("examples", examples);
    }
    get requestBodies() {
      return this.get("requestBodies");
    }
    set requestBodies(requestBodies) {
      this.set("requestBodies", requestBodies);
    }
    get headers() {
      return this.get("headers");
    }
    set headers(headers) {
      this.set("headers", headers);
    }
    get securitySchemes() {
      return this.get("securitySchemes");
    }
    set securitySchemes(securitySchemes) {
      this.set("securitySchemes", securitySchemes);
    }
    get links() {
      return this.get("links");
    }
    set links(links) {
      this.set("links", links);
    }
    get callbacks() {
      return this.get("callbacks");
    }
    set callbacks(callbacks) {
      this.set("callbacks", callbacks);
    }
  };
  const ComponentsElement$1 = Components$1;
  let Contact$1 = class Contact extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "contact";
    }
    get name() {
      return this.get("name");
    }
    set name(name) {
      this.set("name", name);
    }
    get url() {
      return this.get("url");
    }
    set url(url2) {
      this.set("url", url2);
    }
    get email() {
      return this.get("email");
    }
    set email(email) {
      this.set("email", email);
    }
  };
  const ContactElement$1 = Contact$1;
  let Discriminator$1 = class Discriminator extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "discriminator";
    }
    get propertyName() {
      return this.get("propertyName");
    }
    set propertyName(propertyName) {
      this.set("propertyName", propertyName);
    }
    get mapping() {
      return this.get("mapping");
    }
    set mapping(mapping) {
      this.set("mapping", mapping);
    }
  };
  const DiscriminatorElement$1 = Discriminator$1;
  let Encoding$1 = class Encoding extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "encoding";
    }
    get contentType() {
      return this.get("contentType");
    }
    set contentType(contentType) {
      this.set("contentType", contentType);
    }
    get headers() {
      return this.get("headers");
    }
    set headers(headers) {
      this.set("headers", headers);
    }
    get style() {
      return this.get("style");
    }
    set style(style) {
      this.set("style", style);
    }
    get explode() {
      return this.get("explode");
    }
    set explode(explode) {
      this.set("explode", explode);
    }
    get allowedReserved() {
      return this.get("allowedReserved");
    }
    set allowedReserved(allowedReserved) {
      this.set("allowedReserved", allowedReserved);
    }
  };
  const EncodingElement$1 = Encoding$1;
  let Example$1 = class Example extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "example";
    }
    get summary() {
      return this.get("summary");
    }
    set summary(summary) {
      this.set("summary", summary);
    }
    get description() {
      return this.get("description");
    }
    set description(description) {
      this.set("description", description);
    }
    get value() {
      return this.get("value");
    }
    set value(value2) {
      this.set("value", value2);
    }
    get externalValue() {
      return this.get("externalValue");
    }
    set externalValue(externalValue) {
      this.set("externalValue", externalValue);
    }
  };
  const ExampleElement$1 = Example$1;
  let ExternalDocumentation$1 = class ExternalDocumentation extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "externalDocumentation";
    }
    get description() {
      return this.get("description");
    }
    set description(description) {
      this.set("description", description);
    }
    get url() {
      return this.get("url");
    }
    set url(url2) {
      this.set("url", url2);
    }
  };
  const ExternalDocumentationElement$1 = ExternalDocumentation$1;
  let Header$1 = class Header extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "header";
    }
    get required() {
      if (this.hasKey("required")) {
        return this.get("required");
      }
      return new BooleanElement(false);
    }
    set required(required) {
      this.set("required", required);
    }
    get deprecated() {
      if (this.hasKey("deprecated")) {
        return this.get("deprecated");
      }
      return new BooleanElement(false);
    }
    set deprecated(deprecated) {
      this.set("deprecated", deprecated);
    }
    get allowEmptyValue() {
      return this.get("allowEmptyValue");
    }
    set allowEmptyValue(allowEmptyValue) {
      this.set("allowEmptyValue", allowEmptyValue);
    }
    get style() {
      return this.get("style");
    }
    set style(style) {
      this.set("style", style);
    }
    get explode() {
      return this.get("explode");
    }
    set explode(explode) {
      this.set("explode", explode);
    }
    get allowReserved() {
      return this.get("allowReserved");
    }
    set allowReserved(allowReserved) {
      this.set("allowReserved", allowReserved);
    }
    get schema() {
      return this.get("schema");
    }
    set schema(schema2) {
      this.set("schema", schema2);
    }
    get example() {
      return this.get("example");
    }
    set example(example) {
      this.set("example", example);
    }
    get examples() {
      return this.get("examples");
    }
    set examples(examples) {
      this.set("examples", examples);
    }
    get contentProp() {
      return this.get("content");
    }
    set contentProp(content) {
      this.set("content", content);
    }
  };
  Object.defineProperty(Header$1.prototype, "description", {
    get() {
      return this.get("description");
    },
    set(description) {
      this.set("description", description);
    },
    enumerable: true
  });
  const HeaderElement$1 = Header$1;
  let Info$1 = class Info extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "info";
      this.classes.push("info");
    }
    get title() {
      return this.get("title");
    }
    set title(title) {
      this.set("title", title);
    }
    get description() {
      return this.get("description");
    }
    set description(description) {
      this.set("description", description);
    }
    get termsOfService() {
      return this.get("termsOfService");
    }
    set termsOfService(tos) {
      this.set("termsOfService", tos);
    }
    get contact() {
      return this.get("contact");
    }
    set contact(contactElement) {
      this.set("contact", contactElement);
    }
    get license() {
      return this.get("license");
    }
    set license(licenseElement) {
      this.set("license", licenseElement);
    }
    get version() {
      return this.get("version");
    }
    set version(version2) {
      this.set("version", version2);
    }
  };
  const InfoElement$1 = Info$1;
  let License$1 = class License extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "license";
    }
    get name() {
      return this.get("name");
    }
    set name(name) {
      this.set("name", name);
    }
    get url() {
      return this.get("url");
    }
    set url(url2) {
      this.set("url", url2);
    }
  };
  const LicenseElement$1 = License$1;
  let Link$1 = class Link extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "link";
    }
    get operationRef() {
      return this.get("operationRef");
    }
    set operationRef(operationRef) {
      this.set("operationRef", operationRef);
    }
    get operationId() {
      return this.get("operationId");
    }
    set operationId(operationId) {
      this.set("operationId", operationId);
    }
    get operation() {
      if (isStringElement(this.operationRef)) {
        var _this$operationRef;
        return (_this$operationRef = this.operationRef) === null || _this$operationRef === void 0 ? void 0 : _this$operationRef.meta.get("operation");
      }
      if (isStringElement(this.operationId)) {
        var _this$operationId;
        return (_this$operationId = this.operationId) === null || _this$operationId === void 0 ? void 0 : _this$operationId.meta.get("operation");
      }
      return void 0;
    }
    set operation(operation) {
      this.set("operation", operation);
    }
    get parameters() {
      return this.get("parameters");
    }
    set parameters(parameters2) {
      this.set("parameters", parameters2);
    }
    get requestBody() {
      return this.get("requestBody");
    }
    set requestBody(requestBody) {
      this.set("requestBody", requestBody);
    }
    get description() {
      return this.get("description");
    }
    set description(description) {
      this.set("description", description);
    }
    get server() {
      return this.get("server");
    }
    set server(server) {
      this.set("server", server);
    }
  };
  const LinkElement$1 = Link$1;
  let MediaType$1 = class MediaType extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "mediaType";
    }
    get schema() {
      return this.get("schema");
    }
    set schema(schema2) {
      this.set("schema", schema2);
    }
    get example() {
      return this.get("example");
    }
    set example(example) {
      this.set("example", example);
    }
    get examples() {
      return this.get("examples");
    }
    set examples(examples) {
      this.set("examples", examples);
    }
    get encoding() {
      return this.get("encoding");
    }
    set encoding(encoding) {
      this.set("encoding", encoding);
    }
  };
  const MediaTypeElement$1 = MediaType$1;
  let OAuthFlow$1 = class OAuthFlow extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "oAuthFlow";
    }
    get authorizationUrl() {
      return this.get("authorizationUrl");
    }
    set authorizationUrl(authorizationUrl) {
      this.set("authorizationUrl", authorizationUrl);
    }
    get tokenUrl() {
      return this.get("tokenUrl");
    }
    set tokenUrl(tokenUrl) {
      this.set("tokenUrl", tokenUrl);
    }
    get refreshUrl() {
      return this.get("refreshUrl");
    }
    set refreshUrl(refreshUrl) {
      this.set("refreshUrl", refreshUrl);
    }
    get scopes() {
      return this.get("scopes");
    }
    set scopes(scopes) {
      this.set("scopes", scopes);
    }
  };
  const OAuthFlowElement$1 = OAuthFlow$1;
  let OAuthFlows$1 = class OAuthFlows extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "oAuthFlows";
    }
    get implicit() {
      return this.get("implicit");
    }
    set implicit(implicit) {
      this.set("implicit", implicit);
    }
    get password() {
      return this.get("password");
    }
    set password(password) {
      this.set("password", password);
    }
    get clientCredentials() {
      return this.get("clientCredentials");
    }
    set clientCredentials(clientCredentials) {
      this.set("clientCredentials", clientCredentials);
    }
    get authorizationCode() {
      return this.get("authorizationCode");
    }
    set authorizationCode(authorizationCode) {
      this.set("authorizationCode", authorizationCode);
    }
  };
  const OAuthFlowsElement$1 = OAuthFlows$1;
  let Openapi$1 = class Openapi extends StringElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "openapi";
      this.classes.push("spec-version");
      this.classes.push("version");
    }
  };
  const OpenapiElement$1 = Openapi$1;
  class OpenApi3_0 extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "openApi3_0";
      this.classes.push("api");
    }
    get openapi() {
      return this.get("openapi");
    }
    set openapi(openapi) {
      this.set("openapi", openapi);
    }
    get info() {
      return this.get("info");
    }
    set info(info) {
      this.set("info", info);
    }
    get servers() {
      return this.get("servers");
    }
    set servers(servers) {
      this.set("servers", servers);
    }
    get paths() {
      return this.get("paths");
    }
    set paths(paths2) {
      this.set("paths", paths2);
    }
    get components() {
      return this.get("components");
    }
    set components(components) {
      this.set("components", components);
    }
    get security() {
      return this.get("security");
    }
    set security(security) {
      this.set("security", security);
    }
    get tags() {
      return this.get("tags");
    }
    set tags(tags2) {
      this.set("tags", tags2);
    }
    get externalDocs() {
      return this.get("externalDocs");
    }
    set externalDocs(externalDocs) {
      this.set("externalDocs", externalDocs);
    }
  }
  const OpenApi3_0Element = OpenApi3_0;
  let Operation$1 = class Operation extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "operation";
    }
    get tags() {
      return this.get("tags");
    }
    set tags(tags2) {
      this.set("tags", tags2);
    }
    get summary() {
      return this.get("summary");
    }
    set summary(description) {
      this.set("summary", description);
    }
    get description() {
      return this.get("description");
    }
    set description(description) {
      this.set("description", description);
    }
    set externalDocs(externalDocs) {
      this.set("externalDocs", externalDocs);
    }
    get externalDocs() {
      return this.get("externalDocs");
    }
    get operationId() {
      return this.get("operationId");
    }
    set operationId(operationId) {
      this.set("operationId", operationId);
    }
    get parameters() {
      return this.get("parameters");
    }
    set parameters(parameters2) {
      this.set("parameters", parameters2);
    }
    get requestBody() {
      return this.get("requestBody");
    }
    set requestBody(requestBody) {
      this.set("requestBody", requestBody);
    }
    get responses() {
      return this.get("responses");
    }
    set responses(responses) {
      this.set("responses", responses);
    }
    get callbacks() {
      return this.get("callbacks");
    }
    set callbacks(callbacks) {
      this.set("callbacks", callbacks);
    }
    get deprecated() {
      if (this.hasKey("deprecated")) {
        return this.get("deprecated");
      }
      return new BooleanElement(false);
    }
    set deprecated(deprecated) {
      this.set("deprecated", deprecated);
    }
    get security() {
      return this.get("security");
    }
    set security(security) {
      this.set("security", security);
    }
    get servers() {
      return this.get("severs");
    }
    set servers(servers) {
      this.set("servers", servers);
    }
  };
  const OperationElement$1 = Operation$1;
  let Parameter$1 = class Parameter extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "parameter";
    }
    get name() {
      return this.get("name");
    }
    set name(name) {
      this.set("name", name);
    }
    get in() {
      return this.get("in");
    }
    set in(val) {
      this.set("in", val);
    }
    get required() {
      if (this.hasKey("required")) {
        return this.get("required");
      }
      return new BooleanElement(false);
    }
    set required(required) {
      this.set("required", required);
    }
    get deprecated() {
      if (this.hasKey("deprecated")) {
        return this.get("deprecated");
      }
      return new BooleanElement(false);
    }
    set deprecated(deprecated) {
      this.set("deprecated", deprecated);
    }
    get allowEmptyValue() {
      return this.get("allowEmptyValue");
    }
    set allowEmptyValue(allowEmptyValue) {
      this.set("allowEmptyValue", allowEmptyValue);
    }
    get style() {
      return this.get("style");
    }
    set style(style) {
      this.set("style", style);
    }
    get explode() {
      return this.get("explode");
    }
    set explode(explode) {
      this.set("explode", explode);
    }
    get allowReserved() {
      return this.get("allowReserved");
    }
    set allowReserved(allowReserved) {
      this.set("allowReserved", allowReserved);
    }
    get schema() {
      return this.get("schema");
    }
    set schema(schema2) {
      this.set("schema", schema2);
    }
    get example() {
      return this.get("example");
    }
    set example(example) {
      this.set("example", example);
    }
    get examples() {
      return this.get("examples");
    }
    set examples(examples) {
      this.set("examples", examples);
    }
    get contentProp() {
      return this.get("content");
    }
    set contentProp(content) {
      this.set("content", content);
    }
  };
  Object.defineProperty(Parameter$1.prototype, "description", {
    get() {
      return this.get("description");
    },
    set(description) {
      this.set("description", description);
    },
    enumerable: true
  });
  const ParameterElement$1 = Parameter$1;
  let PathItem$1 = class PathItem extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "pathItem";
    }
    get $ref() {
      return this.get("$ref");
    }
    set $ref($ref) {
      this.set("$ref", $ref);
    }
    get summary() {
      return this.get("summary");
    }
    set summary(summary) {
      this.set("summary", summary);
    }
    get description() {
      return this.get("description");
    }
    set description(description) {
      this.set("description", description);
    }
    get GET() {
      return this.get("get");
    }
    set GET(operation) {
      this.set("GET", operation);
    }
    get PUT() {
      return this.get("put");
    }
    set PUT(operation) {
      this.set("PUT", operation);
    }
    get POST() {
      return this.get("post");
    }
    set POST(operation) {
      this.set("POST", operation);
    }
    get DELETE() {
      return this.get("delete");
    }
    set DELETE(operation) {
      this.set("DELETE", operation);
    }
    get OPTIONS() {
      return this.get("options");
    }
    set OPTIONS(operation) {
      this.set("OPTIONS", operation);
    }
    get HEAD() {
      return this.get("head");
    }
    set HEAD(operation) {
      this.set("HEAD", operation);
    }
    get PATCH() {
      return this.get("patch");
    }
    set PATCH(operation) {
      this.set("PATCH", operation);
    }
    get TRACE() {
      return this.get("trace");
    }
    set TRACE(operation) {
      this.set("TRACE", operation);
    }
    get servers() {
      return this.get("servers");
    }
    set servers(servers) {
      this.set("servers", servers);
    }
    get parameters() {
      return this.get("parameters");
    }
    set parameters(parameters2) {
      this.set("parameters", parameters2);
    }
  };
  const PathItemElement$1 = PathItem$1;
  let Paths$1 = class Paths extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "paths";
    }
  };
  const PathsElement$1 = Paths$1;
  let Reference$1 = class Reference extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "reference";
      this.classes.push("openapi-reference");
    }
    get $ref() {
      return this.get("$ref");
    }
    set $ref($ref) {
      this.set("$ref", $ref);
    }
  };
  const ReferenceElement$1 = Reference$1;
  let RequestBody$1 = class RequestBody extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "requestBody";
    }
    get description() {
      return this.get("description");
    }
    set description(description) {
      this.set("description", description);
    }
    get contentProp() {
      return this.get("content");
    }
    set contentProp(content) {
      this.set("content", content);
    }
    get required() {
      if (this.hasKey("required")) {
        return this.get("required");
      }
      return new BooleanElement(false);
    }
    set required(required) {
      this.set("required", required);
    }
  };
  const RequestBodyElement$1 = RequestBody$1;
  let Response$2 = class Response extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "response";
    }
    get description() {
      return this.get("description");
    }
    set description(description) {
      this.set("description", description);
    }
    get headers() {
      return this.get("headers");
    }
    set headers(headers) {
      this.set("headers", headers);
    }
    get contentProp() {
      return this.get("content");
    }
    set contentProp(contentProp) {
      this.set("content", contentProp);
    }
    get links() {
      return this.get("links");
    }
    set links(links) {
      this.set("links", links);
    }
  };
  const ResponseElement$1 = Response$2;
  let Responses$1 = class Responses extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "responses";
    }
    get default() {
      return this.get("default");
    }
    set default(defaultValue) {
      this.set("default", defaultValue);
    }
  };
  const ResponsesElement$1 = Responses$1;
  class JSONSchema extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "JSONSchemaDraft4";
    }
    /**
     * Core vocabulary
     *
     * URI: https://tools.ietf.org/html/draft-wright-json-schema-00
     */
    get idProp() {
      return this.get("id");
    }
    set idProp(idProp) {
      this.set("id", idProp);
    }
    get $schema() {
      return this.get("$schema");
    }
    set $schema($schema) {
      this.set("idProp", $schema);
    }
    /**
     * Validation vocabulary
     *
     * URI: https://tools.ietf.org/html/draft-wright-json-schema-validation-00
     */
    /**
     *  Validation keywords for numeric instances (number and integer)
     */
    get multipleOf() {
      return this.get("multipleOf");
    }
    set multipleOf(multipleOf) {
      this.set("multipleOf", multipleOf);
    }
    get maximum() {
      return this.get("maximum");
    }
    set maximum(maximum) {
      this.set("maximum", maximum);
    }
    get exclusiveMaximum() {
      return this.get("exclusiveMaximum");
    }
    set exclusiveMaximum(exclusiveMaximum) {
      this.set("exclusiveMaximum", exclusiveMaximum);
    }
    get minimum() {
      return this.get("minimum");
    }
    set minimum(minimum) {
      this.set("minimum", minimum);
    }
    get exclusiveMinimum() {
      return this.get("exclusiveMinimum");
    }
    set exclusiveMinimum(exclusiveMinimum) {
      this.set("exclusiveMinimum", exclusiveMinimum);
    }
    /**
     * Validation keywords for strings
     */
    get maxLength() {
      return this.get("maxLength");
    }
    set maxLength(maxLength) {
      this.set("maxLength", maxLength);
    }
    get minLength() {
      return this.get("minLength");
    }
    set minLength(minLength) {
      this.set("minLength", minLength);
    }
    get pattern() {
      return this.get("pattern");
    }
    set pattern(pattern) {
      this.set("pattern", pattern);
    }
    /**
     * Validation keywords for arrays
     */
    get additionalItems() {
      return this.get("additionalItems");
    }
    set additionalItems(additionalItems) {
      this.set("additionalItems", additionalItems);
    }
    get items() {
      return this.get("items");
    }
    set items(items) {
      this.set("items", items);
    }
    get maxItems() {
      return this.get("maxItems");
    }
    set maxItems(maxItems) {
      this.set("maxItems", maxItems);
    }
    get minItems() {
      return this.get("minItems");
    }
    set minItems(minItems) {
      this.set("minItems", minItems);
    }
    get uniqueItems() {
      return this.get("uniqueItems");
    }
    set uniqueItems(uniqueItems) {
      this.set("uniqueItems", uniqueItems);
    }
    /**
     * Validation keywords for objects
     */
    get maxProperties() {
      return this.get("maxProperties");
    }
    set maxProperties(maxProperties) {
      this.set("maxProperties", maxProperties);
    }
    get minProperties() {
      return this.get("minProperties");
    }
    set minProperties(minProperties) {
      this.set("minProperties", minProperties);
    }
    get required() {
      return this.get("required");
    }
    set required(required) {
      this.set("required", required);
    }
    get properties() {
      return this.get("properties");
    }
    set properties(properties2) {
      this.set("properties", properties2);
    }
    get additionalProperties() {
      return this.get("additionalProperties");
    }
    set additionalProperties(additionalProperties) {
      this.set("additionalProperties", additionalProperties);
    }
    get patternProperties() {
      return this.get("patternProperties");
    }
    set patternProperties(patternProperties) {
      this.set("patternProperties", patternProperties);
    }
    get dependencies() {
      return this.get("dependencies");
    }
    set dependencies(dependencies) {
      this.set("dependencies", dependencies);
    }
    /**
     *  Validation keywords for any instance type
     */
    get enum() {
      return this.get("enum");
    }
    set enum(enumValue) {
      this.set("enum", enumValue);
    }
    get type() {
      return this.get("type");
    }
    set type(type2) {
      this.set("type", type2);
    }
    get allOf() {
      return this.get("allOf");
    }
    set allOf(allOf2) {
      this.set("allOf", allOf2);
    }
    get anyOf() {
      return this.get("anyOf");
    }
    set anyOf(anyOf) {
      this.set("anyOf", anyOf);
    }
    get oneOf() {
      return this.get("oneOf");
    }
    set oneOf(oneOf) {
      this.set("oneOf", oneOf);
    }
    get not() {
      return this.get("not");
    }
    set not(not2) {
      this.set("not", not2);
    }
    get definitions() {
      return this.get("definitions");
    }
    set definitions(definitions) {
      this.set("definitions", definitions);
    }
    /**
     * Metadata keywords
     *
     * URI: https://datatracker.ietf.org/doc/html/draft-wright-json-schema-validation-00#section-6
     */
    get title() {
      return this.get("title");
    }
    set title(title) {
      this.set("title", title);
    }
    get description() {
      return this.get("description");
    }
    set description(description) {
      this.set("description", description);
    }
    get default() {
      return this.get("default");
    }
    set default(defaultValue) {
      this.set("default", defaultValue);
    }
    /**
     * Semantic validation with "format"
     *
     * URI: https://datatracker.ietf.org/doc/html/draft-wright-json-schema-validation-00#section-7
     */
    get format() {
      return this.get("format");
    }
    set format(format) {
      this.set("format", format);
    }
    /**
     * JSON Hyper-Schema
     *
     * URI: https://datatracker.ietf.org/doc/html/draft-wright-json-schema-hyperschema-00
     */
    get base() {
      return this.get("base");
    }
    set base(base2) {
      this.set("base", base2);
    }
    get links() {
      return this.get("links");
    }
    set links(links) {
      this.set("links", links);
    }
    get media() {
      return this.get("media");
    }
    set media(media) {
      this.set("media", media);
    }
    get readOnly() {
      return this.get("readOnly");
    }
    set readOnly(readOnly) {
      this.set("readOnly", readOnly);
    }
  }
  const JSONSchemaElement = JSONSchema;
  class JSONReference extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "JSONReference";
      this.classes.push("json-reference");
    }
    get $ref() {
      return this.get("$ref");
    }
    set $ref($ref) {
      this.set("$ref", $ref);
    }
  }
  const JSONReferenceElement = JSONReference;
  class Media extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "media";
    }
    get binaryEncoding() {
      return this.get("binaryEncoding");
    }
    set binaryEncoding(binaryEncoding) {
      this.set("binaryEncoding", binaryEncoding);
    }
    get type() {
      return this.get("type");
    }
    set type(type2) {
      this.set("type", type2);
    }
  }
  const MediaElement = Media;
  class LinkDescription extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "linkDescription";
    }
    get href() {
      return this.get("href");
    }
    set href(href) {
      this.set("href", href);
    }
    get rel() {
      return this.get("rel");
    }
    set rel(rel) {
      this.set("rel", rel);
    }
    get title() {
      return this.get("title");
    }
    set title(title) {
      this.set("title", title);
    }
    get targetSchema() {
      return this.get("targetSchema");
    }
    set targetSchema(targetSchema) {
      this.set("targetSchema", targetSchema);
    }
    get mediaType() {
      return this.get("mediaType");
    }
    set mediaType(mediaType) {
      this.set("mediaType", mediaType);
    }
    get method() {
      return this.get("method");
    }
    set method(method) {
      this.set("method", method);
    }
    get encType() {
      return this.get("encType");
    }
    set encType(encType) {
      this.set("encType", encType);
    }
    get schema() {
      return this.get("schema");
    }
    set schema(schema2) {
      this.set("schema", schema2);
    }
  }
  const LinkDescriptionElement = LinkDescription;
  const jsonSchemaDraft4 = {
    namespace: (options) => {
      const {
        base: base2
      } = options;
      base2.register("jSONSchemaDraft4", JSONSchemaElement);
      base2.register("jSONReference", JSONReferenceElement);
      base2.register("media", MediaElement);
      base2.register("linkDescription", LinkDescriptionElement);
      return base2;
    }
  };
  const jsonSchemaDraft4Namespace = jsonSchemaDraft4;
  const getNodeType$2 = (element) => {
    if (!isElement(element)) {
      return void 0;
    }
    return `${element.element.charAt(0).toUpperCase() + element.element.slice(1)}Element`;
  };
  const keyMap$2 = {
    JSONSchemaDraft4Element: ["content"],
    JSONReferenceElement: ["content"],
    MediaElement: ["content"],
    LinkDescriptionElement: ["content"],
    ...keyMapDefault$1
  };
  const Visitor$2 = stampit({
    props: {
      element: null
    },
    // @ts-ignore
    methods: {
      copyMetaAndAttributes(from2, to) {
        if (hasElementSourceMap(from2)) {
          to.meta.set("sourceMap", from2.meta.get("sourceMap"));
        }
      }
    }
  });
  const Visitor$3 = Visitor$2;
  const FallbackVisitor$2 = stampit(Visitor$3, {
    methods: {
      enter(element) {
        this.element = cloneDeep(element);
        return BREAK;
      }
    }
  });
  const FallbackVisitor$3 = FallbackVisitor$2;
  const SpecificationVisitor$2 = stampit(Visitor$3, {
    props: {
      specObj: null,
      passingOptionsNames: ["specObj"]
    },
    init({
      // @ts-ignore
      specObj = this.specObj
    }) {
      this.specObj = specObj;
    },
    methods: {
      retrievePassingOptions() {
        return pick$2(this.passingOptionsNames, this);
      },
      retrieveFixedFields(specPath) {
        return pipe$2(path$6(["visitors", ...specPath, "fixedFields"]), keys$4)(this.specObj);
      },
      retrieveVisitor(specPath) {
        if (pathSatisfies$1(isFunction$7, ["visitors", ...specPath], this.specObj)) {
          return path$6(["visitors", ...specPath], this.specObj);
        }
        return path$6(["visitors", ...specPath, "$visitor"], this.specObj);
      },
      retrieveVisitorInstance(specPath, options = {}) {
        const passingOpts = this.retrievePassingOptions();
        return this.retrieveVisitor(specPath)({
          ...passingOpts,
          ...options
        });
      },
      toRefractedElement(specPath, element, options = {}) {
        const visitor2 = this.retrieveVisitorInstance(specPath, options);
        const visitorPrototype = Object.getPrototypeOf(visitor2);
        if (isUndefined$1(this.fallbackVisitorPrototype)) {
          this.fallbackVisitorPrototype = Object.getPrototypeOf(this.retrieveVisitorInstance(["value"]));
        }
        if (this.fallbackVisitorPrototype === visitorPrototype) {
          return cloneDeep(element);
        }
        visit$1(element, visitor2, {
          keyMap: keyMap$2,
          nodeTypeGetter: getNodeType$2,
          ...options
        });
        return visitor2.element;
      }
    }
  });
  const SpecificationVisitor$3 = SpecificationVisitor$2;
  const FixedFieldsVisitor$2 = stampit(SpecificationVisitor$3, {
    props: {
      specPath: noop$3,
      ignoredFields: []
    },
    init({
      // @ts-ignore
      specPath = this.specPath,
      // @ts-ignore
      ignoredFields = this.ignoredFields
    } = {}) {
      this.specPath = specPath;
      this.ignoredFields = ignoredFields;
    },
    methods: {
      ObjectElement(objectElement) {
        const specPath = this.specPath(objectElement);
        const fields = this.retrieveFixedFields(specPath);
        objectElement.forEach((value2, key, memberElement) => {
          if (isStringElement(key) && fields.includes(toValue(key)) && !this.ignoredFields.includes(toValue(key))) {
            const fixedFieldElement = this.toRefractedElement([...specPath, "fixedFields", toValue(key)], value2);
            const newMemberElement = new MemberElement(cloneDeep(key), fixedFieldElement);
            this.copyMetaAndAttributes(memberElement, newMemberElement);
            newMemberElement.classes.push("fixed-field");
            this.element.content.push(newMemberElement);
          } else if (!this.ignoredFields.includes(toValue(key))) {
            this.element.content.push(cloneDeep(memberElement));
          }
        });
        this.copyMetaAndAttributes(objectElement, this.element);
        return BREAK;
      }
    }
  });
  const FixedFieldsVisitor$3 = FixedFieldsVisitor$2;
  const JSONSchemaVisitor = stampit(FixedFieldsVisitor$3, FallbackVisitor$3, {
    props: {
      specPath: always$1(["document", "objects", "JSONSchema"])
    },
    init() {
      this.element = new JSONSchemaElement();
    }
  });
  const JSONSchemaVisitor$1 = JSONSchemaVisitor;
  const IdVisitor = FallbackVisitor$3;
  const JSONSchemaIdVisitor = IdVisitor;
  const $schemaVisitor$1 = FallbackVisitor$3;
  const JSONSchema$schemaVisitor = $schemaVisitor$1;
  const MultipleOfVisitor$1 = FallbackVisitor$3;
  const JSONSchemaMultipleOfVisitor = MultipleOfVisitor$1;
  const MaximumVisitor$1 = FallbackVisitor$3;
  const JSONSchemaMaximumVisitor = MaximumVisitor$1;
  const ExclusiveMaximumVisitor$1 = FallbackVisitor$3;
  const JSONSchemaExclusiveMaximumVisitor = ExclusiveMaximumVisitor$1;
  const MinimumVisitor$1 = FallbackVisitor$3;
  const JSONSchemaMinimumVisitor = MinimumVisitor$1;
  const ExclusiveMinimumVisitor$1 = FallbackVisitor$3;
  const JSONSchemaExclusiveMinimumVisitor = ExclusiveMinimumVisitor$1;
  const MaxLengthVisitor$1 = FallbackVisitor$3;
  const JSONSchemaMaxLengthVisitor = MaxLengthVisitor$1;
  const MinLengthVisitor$1 = FallbackVisitor$3;
  const JSONSchemaMinLengthVisitor = MinLengthVisitor$1;
  const PatternVisitor$1 = FallbackVisitor$3;
  const JSONSchemaPatternVisitor = PatternVisitor$1;
  const ParentSchemaAwareVisitor$2 = stampit({
    props: {
      parent: null
    },
    // @ts-ignore
    init({
      parent: parent2 = this.parent
    }) {
      this.parent = parent2;
      this.passingOptionsNames = [...this.passingOptionsNames, "parent"];
    }
  });
  const ParentSchemaAwareVisitor$3 = ParentSchemaAwareVisitor$2;
  const isJSONReferenceLikeElement = (element) => {
    return isObjectElement(element) && element.hasKey("$ref");
  };
  const ItemsVisitor$2 = stampit(SpecificationVisitor$3, ParentSchemaAwareVisitor$3, FallbackVisitor$3, {
    methods: {
      ObjectElement(objectElement) {
        const specPath = isJSONReferenceLikeElement(objectElement) ? ["document", "objects", "JSONReference"] : ["document", "objects", "JSONSchema"];
        this.element = this.toRefractedElement(specPath, objectElement);
        return BREAK;
      },
      ArrayElement(arrayElement) {
        this.element = new ArrayElement();
        this.element.classes.push("json-schema-items");
        arrayElement.forEach((item) => {
          const specPath = isJSONReferenceLikeElement(item) ? ["document", "objects", "JSONReference"] : ["document", "objects", "JSONSchema"];
          const element = this.toRefractedElement(specPath, item);
          this.element.push(element);
        });
        this.copyMetaAndAttributes(arrayElement, this.element);
        return BREAK;
      }
    }
  });
  const JSONSchemaItemsVisitor$1 = ItemsVisitor$2;
  const MaxItemsVisitor$1 = FallbackVisitor$3;
  const JSONSchemaMaxItemsVisitor = MaxItemsVisitor$1;
  const MinItemsVisitor$1 = FallbackVisitor$3;
  const JSONSchemaMinItemsVisitor = MinItemsVisitor$1;
  const UniqueItemsVisitor$1 = FallbackVisitor$3;
  const JSONSchemaUniqueItemsVisitor = UniqueItemsVisitor$1;
  const MaxPropertiesVisitor$1 = FallbackVisitor$3;
  const JSONSchemaMaxPropertiesVisitor = MaxPropertiesVisitor$1;
  const MinPropertiesVisitor$1 = FallbackVisitor$3;
  const JSONSchemaMinPropertiesVisitor = MinPropertiesVisitor$1;
  const RequiredVisitor$4 = stampit(FallbackVisitor$3, {
    methods: {
      ArrayElement(arrayElement) {
        this.element = cloneDeep(arrayElement);
        this.element.classes.push("json-schema-required");
        return BREAK;
      }
    }
  });
  const JSONSchemaRequiredVisitor = RequiredVisitor$4;
  const PatternedFieldsJsonObjectVisitor$1 = stampit(SpecificationVisitor$3, {
    props: {
      fieldPatternPredicate: stubFalse$1,
      specPath: noop$3,
      ignoredFields: []
    },
    init({
      // @ts-ignore
      specPath = this.specPath,
      // @ts-ignore
      ignoredFields = this.ignoredFields
    } = {}) {
      this.specPath = specPath;
      this.ignoredFields = ignoredFields;
    },
    methods: {
      ObjectElement(objectElement) {
        objectElement.forEach((value2, key, memberElement) => {
          if (!this.ignoredFields.includes(toValue(key)) && this.fieldPatternPredicate(toValue(key))) {
            const specPath = this.specPath(value2);
            const patternedFieldElement = this.toRefractedElement(specPath, value2);
            const newMemberElement = new MemberElement(cloneDeep(key), patternedFieldElement);
            this.copyMetaAndAttributes(memberElement, newMemberElement);
            newMemberElement.classes.push("patterned-field");
            this.element.content.push(newMemberElement);
          } else if (!this.ignoredFields.includes(toValue(key))) {
            this.element.content.push(cloneDeep(memberElement));
          }
        });
        this.copyMetaAndAttributes(objectElement, this.element);
        return BREAK;
      }
    }
  });
  const PatternedFieldsVisitor$1 = PatternedFieldsJsonObjectVisitor$1;
  const MapVisitor$2 = stampit(PatternedFieldsVisitor$1, {
    props: {
      fieldPatternPredicate: isNonEmptyString$1
    }
  });
  const MapVisitor$3 = MapVisitor$2;
  const PropertiesVisitor$2 = stampit(MapVisitor$3, ParentSchemaAwareVisitor$3, FallbackVisitor$3, {
    props: {
      specPath: (element) => isJSONReferenceLikeElement(element) ? ["document", "objects", "JSONReference"] : ["document", "objects", "JSONSchema"]
    },
    init() {
      this.element = new ObjectElement();
      this.element.classes.push("json-schema-properties");
    }
  });
  const JSONSchemaPropertiesVisitor$1 = PropertiesVisitor$2;
  const PatternPropertiesVisitor$2 = stampit(MapVisitor$3, ParentSchemaAwareVisitor$3, FallbackVisitor$3, {
    props: {
      specPath: (element) => isJSONReferenceLikeElement(element) ? ["document", "objects", "JSONReference"] : ["document", "objects", "JSONSchema"]
    },
    init() {
      this.element = new ObjectElement();
      this.element.classes.push("json-schema-patternProperties");
    }
  });
  const JSONSchemaPatternPropertiesVisitor$1 = PatternPropertiesVisitor$2;
  const DependenciesVisitor$1 = stampit(MapVisitor$3, ParentSchemaAwareVisitor$3, FallbackVisitor$3, {
    props: {
      specPath: (element) => isJSONReferenceLikeElement(element) ? ["document", "objects", "JSONReference"] : ["document", "objects", "JSONSchema"]
    },
    init() {
      this.element = new ObjectElement();
      this.element.classes.push("json-schema-dependencies");
    }
  });
  const JSONSchemaDependenciesVisitor$1 = DependenciesVisitor$1;
  const EnumVisitor$2 = stampit(FallbackVisitor$3, {
    methods: {
      ArrayElement(arrayElement) {
        this.element = cloneDeep(arrayElement);
        this.element.classes.push("json-schema-enum");
        return BREAK;
      }
    }
  });
  const JSONSchemaEnumVisitor = EnumVisitor$2;
  const TypeVisitor$3 = stampit(FallbackVisitor$3, {
    methods: {
      StringElement(stringElement) {
        this.element = cloneDeep(stringElement);
        this.element.classes.push("json-schema-type");
        return BREAK;
      },
      ArrayElement(arrayElement) {
        this.element = cloneDeep(arrayElement);
        this.element.classes.push("json-schema-type");
        return BREAK;
      }
    }
  });
  const JSONSchemaTypeVisitor$1 = TypeVisitor$3;
  const AllOfVisitor$3 = stampit(SpecificationVisitor$3, ParentSchemaAwareVisitor$3, FallbackVisitor$3, {
    init() {
      this.element = new ArrayElement();
      this.element.classes.push("json-schema-allOf");
    },
    methods: {
      ArrayElement(arrayElement) {
        arrayElement.forEach((item) => {
          const specPath = isJSONReferenceLikeElement(item) ? ["document", "objects", "JSONReference"] : ["document", "objects", "JSONSchema"];
          const element = this.toRefractedElement(specPath, item);
          this.element.push(element);
        });
        this.copyMetaAndAttributes(arrayElement, this.element);
        return BREAK;
      }
    }
  });
  const JSONSchemaAllOfVisitor$1 = AllOfVisitor$3;
  const AnyOfVisitor$2 = stampit(SpecificationVisitor$3, ParentSchemaAwareVisitor$3, FallbackVisitor$3, {
    init() {
      this.element = new ArrayElement();
      this.element.classes.push("json-schema-anyOf");
    },
    methods: {
      ArrayElement(arrayElement) {
        arrayElement.forEach((item) => {
          const specPath = isJSONReferenceLikeElement(item) ? ["document", "objects", "JSONReference"] : ["document", "objects", "JSONSchema"];
          const element = this.toRefractedElement(specPath, item);
          this.element.push(element);
        });
        this.copyMetaAndAttributes(arrayElement, this.element);
        return BREAK;
      }
    }
  });
  const JSONSchemaAnyOfVisitor$1 = AnyOfVisitor$2;
  const OneOfVisitor$2 = stampit(SpecificationVisitor$3, ParentSchemaAwareVisitor$3, FallbackVisitor$3, {
    init() {
      this.element = new ArrayElement();
      this.element.classes.push("json-schema-oneOf");
    },
    methods: {
      ArrayElement(arrayElement) {
        arrayElement.forEach((item) => {
          const specPath = isJSONReferenceLikeElement(item) ? ["document", "objects", "JSONReference"] : ["document", "objects", "JSONSchema"];
          const element = this.toRefractedElement(specPath, item);
          this.element.push(element);
        });
        this.copyMetaAndAttributes(arrayElement, this.element);
        return BREAK;
      }
    }
  });
  const JSONSchemaOneOfVisitor$1 = OneOfVisitor$2;
  const DefinitionsVisitor$1 = stampit(MapVisitor$3, ParentSchemaAwareVisitor$3, FallbackVisitor$3, {
    props: {
      specPath: (element) => isJSONReferenceLikeElement(element) ? ["document", "objects", "JSONReference"] : ["document", "objects", "JSONSchema"]
    },
    init() {
      this.element = new ObjectElement();
      this.element.classes.push("json-schema-definitions");
    }
  });
  const JSONSchemaDefinitionsVisitor$1 = DefinitionsVisitor$1;
  const TitleVisitor$3 = FallbackVisitor$3;
  const JSONSchemaTitleVisitor = TitleVisitor$3;
  const DescriptionVisitor$g = FallbackVisitor$3;
  const JSONSchemaDescriptionVisitor = DescriptionVisitor$g;
  const DefaultVisitor$3 = FallbackVisitor$3;
  const JSONSchemaDefaultVisitor = DefaultVisitor$3;
  const FormatVisitor$1 = FallbackVisitor$3;
  const JSONSchemaFormatVisitor = FormatVisitor$1;
  const BaseVisitor = FallbackVisitor$3;
  const JSONSchemaBaseVisitor = BaseVisitor;
  const LinksVisitor$1 = stampit(SpecificationVisitor$3, ParentSchemaAwareVisitor$3, FallbackVisitor$3, {
    init() {
      this.element = new ArrayElement();
      this.element.classes.push("json-schema-links");
    },
    methods: {
      ArrayElement(arrayElement) {
        arrayElement.forEach((item) => {
          const linkDescriptionElement = this.toRefractedElement(["document", "objects", "LinkDescription"], item);
          this.element.push(linkDescriptionElement);
        });
        this.copyMetaAndAttributes(arrayElement, this.element);
        return BREAK;
      }
    }
  });
  const JSONSchemaLinksVisitor = LinksVisitor$1;
  const ReadOnlyVisitor$1 = FallbackVisitor$3;
  const JSONSchemaReadOnlyVisitor = ReadOnlyVisitor$1;
  const JSONReferenceVisitor = stampit(FixedFieldsVisitor$3, FallbackVisitor$3, {
    props: {
      specPath: always$1(["document", "objects", "JSONReference"])
    },
    init() {
      this.element = new JSONReferenceElement();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = FixedFieldsVisitor$3.compose.methods.ObjectElement.call(this, objectElement);
        if (isStringElement(this.element.$ref)) {
          this.element.classes.push("reference-element");
        }
        return result;
      }
    }
  });
  const JSONReferenceVisitor$1 = JSONReferenceVisitor;
  const $RefVisitor$2 = stampit(FallbackVisitor$3, {
    methods: {
      StringElement(stringElement) {
        this.element = cloneDeep(stringElement);
        this.element.classes.push("reference-value");
        return BREAK;
      }
    }
  });
  const JSONReference$RefVisitor = $RefVisitor$2;
  const AlternatingVisitor$2 = stampit(SpecificationVisitor$3, {
    props: {
      alternator: []
    },
    methods: {
      enter(element) {
        const functions = this.alternator.map(({
          predicate,
          specPath: specPath2
        }) => ifElse$1(predicate, always$1(specPath2), stubUndefined$1));
        const specPath = dispatch$9(functions)(element);
        this.element = this.toRefractedElement(specPath, element);
        return BREAK;
      }
    }
  });
  const AlternatingVisitor$3 = AlternatingVisitor$2;
  const SchemaOrReferenceVisitor$2 = stampit(AlternatingVisitor$3, {
    props: {
      alternator: [{
        predicate: isJSONReferenceLikeElement,
        specPath: ["document", "objects", "JSONReference"]
      }, {
        predicate: stubTrue,
        specPath: ["document", "objects", "JSONSchema"]
      }]
    }
  });
  const JSONSchemaOrJSONReferenceVisitor$1 = SchemaOrReferenceVisitor$2;
  const MediaVisitor = stampit(FixedFieldsVisitor$3, FallbackVisitor$3, {
    props: {
      specPath: always$1(["document", "objects", "Media"])
    },
    init() {
      this.element = new MediaElement();
    }
  });
  const MediaVisitor$1 = MediaVisitor;
  const BinaryEncodingVisitor = FallbackVisitor$3;
  const MediaBinaryEncodingVisitor = BinaryEncodingVisitor;
  const TypeVisitor$2 = FallbackVisitor$3;
  const MediaTypeVisitor$5 = TypeVisitor$2;
  const LinkDescriptionVisitor$1 = stampit(FixedFieldsVisitor$3, FallbackVisitor$3, {
    props: {
      specPath: always$1(["document", "objects", "LinkDescription"])
    },
    init() {
      this.element = new LinkDescriptionElement();
    }
  });
  const LinkDescriptionVisitor$2 = LinkDescriptionVisitor$1;
  const HrefVisitor = FallbackVisitor$3;
  const LinkDescriptionHrefVisitor = HrefVisitor;
  const RelVisitor = FallbackVisitor$3;
  const LinkDescriptionRelVisitor = RelVisitor;
  const TitleVisitor$2 = FallbackVisitor$3;
  const LinkDescriptionTitleVisitor = TitleVisitor$2;
  const MediaTypeVisitor$4 = FallbackVisitor$3;
  const LinkDescriptionMediaTypeVisitor = MediaTypeVisitor$4;
  const MethodVisitor = FallbackVisitor$3;
  const LinkDescriptionMethodVisitor = MethodVisitor;
  const EncTypeVisitor = FallbackVisitor$3;
  const LinkDescriptionEncTypeVisitor = EncTypeVisitor;
  const specification$3 = {
    visitors: {
      value: FallbackVisitor$3,
      JSONSchemaOrJSONReferenceVisitor: JSONSchemaOrJSONReferenceVisitor$1,
      document: {
        objects: {
          JSONSchema: {
            $visitor: JSONSchemaVisitor$1,
            fixedFields: {
              // core vocabulary
              id: JSONSchemaIdVisitor,
              $schema: JSONSchema$schemaVisitor,
              // validation vocabulary
              // validation keywords for numeric instances (number and integer)
              multipleOf: JSONSchemaMultipleOfVisitor,
              maximum: JSONSchemaMaximumVisitor,
              exclusiveMaximum: JSONSchemaExclusiveMaximumVisitor,
              minimum: JSONSchemaMinimumVisitor,
              exclusiveMinimum: JSONSchemaExclusiveMinimumVisitor,
              // validation keywords for strings
              maxLength: JSONSchemaMaxLengthVisitor,
              minLength: JSONSchemaMinLengthVisitor,
              pattern: JSONSchemaPatternVisitor,
              // validation keywords for arrays
              additionalItems: JSONSchemaOrJSONReferenceVisitor$1,
              items: JSONSchemaItemsVisitor$1,
              maxItems: JSONSchemaMaxItemsVisitor,
              minItems: JSONSchemaMinItemsVisitor,
              uniqueItems: JSONSchemaUniqueItemsVisitor,
              // validation keywords for objects
              maxProperties: JSONSchemaMaxPropertiesVisitor,
              minProperties: JSONSchemaMinPropertiesVisitor,
              required: JSONSchemaRequiredVisitor,
              properties: JSONSchemaPropertiesVisitor$1,
              additionalProperties: JSONSchemaOrJSONReferenceVisitor$1,
              patternProperties: JSONSchemaPatternPropertiesVisitor$1,
              dependencies: JSONSchemaDependenciesVisitor$1,
              // validation keywords for any instance type
              enum: JSONSchemaEnumVisitor,
              type: JSONSchemaTypeVisitor$1,
              allOf: JSONSchemaAllOfVisitor$1,
              anyOf: JSONSchemaAnyOfVisitor$1,
              oneOf: JSONSchemaOneOfVisitor$1,
              not: JSONSchemaOrJSONReferenceVisitor$1,
              definitions: JSONSchemaDefinitionsVisitor$1,
              // metadata keywords
              title: JSONSchemaTitleVisitor,
              description: JSONSchemaDescriptionVisitor,
              default: JSONSchemaDefaultVisitor,
              // semantic validation with "format"
              format: JSONSchemaFormatVisitor,
              // JSON Hyper-Schema
              base: JSONSchemaBaseVisitor,
              links: JSONSchemaLinksVisitor,
              media: {
                $ref: "#/visitors/document/objects/Media"
              },
              readOnly: JSONSchemaReadOnlyVisitor
            }
          },
          JSONReference: {
            $visitor: JSONReferenceVisitor$1,
            fixedFields: {
              $ref: JSONReference$RefVisitor
            }
          },
          Media: {
            $visitor: MediaVisitor$1,
            fixedFields: {
              binaryEncoding: MediaBinaryEncodingVisitor,
              type: MediaTypeVisitor$5
            }
          },
          LinkDescription: {
            $visitor: LinkDescriptionVisitor$2,
            fixedFields: {
              href: LinkDescriptionHrefVisitor,
              rel: LinkDescriptionRelVisitor,
              title: LinkDescriptionTitleVisitor,
              targetSchema: JSONSchemaOrJSONReferenceVisitor$1,
              mediaType: LinkDescriptionMediaTypeVisitor,
              method: LinkDescriptionMethodVisitor,
              encType: LinkDescriptionEncTypeVisitor,
              schema: JSONSchemaOrJSONReferenceVisitor$1
            }
          }
        }
      }
    }
  };
  const JSONSchemaDraft4Specification = specification$3;
  const isJSONSchemaElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof JSONSchemaElement || hasBasicElementProps2(element) && isElementType2("JSONSchemaDraft4", element) && primitiveEq2("object", element);
  });
  const isJSONReferenceElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof JSONReferenceElement || hasBasicElementProps2(element) && isElementType2("JSONReference", element) && primitiveEq2("object", element);
  });
  const isMediaElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof MediaElement || hasBasicElementProps2(element) && isElementType2("media", element) && primitiveEq2("object", element);
  });
  const isLinkDescriptionElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof LinkDescriptionElement || hasBasicElementProps2(element) && isElementType2("linkDescription", element) && primitiveEq2("object", element);
  });
  const jsonSchemaDraft4Predicates = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    isJSONReferenceElement,
    isJSONSchemaElement,
    isLinkDescriptionElement,
    isMediaElement
  }, Symbol.toStringTag, { value: "Module" }));
  const createToolbox$4 = () => {
    const namespace2 = createNamespace(jsonSchemaDraft4Namespace);
    const predicates2 = {
      ...jsonSchemaDraft4Predicates,
      isStringElement
    };
    return {
      predicates: predicates2,
      namespace: namespace2
    };
  };
  const createToolbox$5 = createToolbox$4;
  const refract$2 = (value2, {
    specPath = ["visitors", "document", "objects", "JSONSchema", "$visitor"],
    plugins: plugins2 = [],
    specificationObj = JSONSchemaDraft4Specification
  } = {}) => {
    const element = refract$4(value2);
    const resolvedSpec = dereference(specificationObj);
    const rootVisitor = invokeArgs$1(specPath, [], resolvedSpec);
    visit$1(element, rootVisitor, {
      state: {
        specObj: resolvedSpec
      }
    });
    return dispatchPlugins(rootVisitor.element, plugins2, {
      toolboxCreator: createToolbox$5,
      visitorOptions: {
        keyMap: keyMap$2,
        nodeTypeGetter: getNodeType$2
      }
    });
  };
  const createRefractor$2 = (specPath) => (value2, options = {}) => refract$2(value2, {
    specPath,
    ...options
  });
  JSONSchemaElement.refract = createRefractor$2(["visitors", "document", "objects", "JSONSchema", "$visitor"]);
  JSONReferenceElement.refract = createRefractor$2(["visitors", "document", "objects", "JSONReference", "$visitor"]);
  MediaElement.refract = createRefractor$2(["visitors", "document", "objects", "Media", "$visitor"]);
  LinkDescriptionElement.refract = createRefractor$2(["visitors", "document", "objects", "LinkDescription", "$visitor"]);
  let Schema$1 = class Schema extends JSONSchemaElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "schema";
      this.classes.push("json-schema-draft-4");
    }
    /**
     * Validation keywords for arrays
     */
    get additionalItems() {
      return this.get("additionalItems");
    }
    set additionalItems(additionalItems) {
      this.set("additionalItems", additionalItems);
    }
    get items() {
      return this.get("items");
    }
    set items(items) {
      this.set("items", items);
    }
    /**
     * Validation keywords for objects
     */
    get additionalProperties() {
      return this.get("additionalProperties");
    }
    set additionalProperties(additionalProperties) {
      this.set("additionalProperties", additionalProperties);
    }
    /**
     *  Validation keywords for any instance type
     */
    get type() {
      return this.get("type");
    }
    set type(type2) {
      this.set("type", type2);
    }
    get not() {
      return this.get("not");
    }
    set not(not2) {
      this.set("not", not2);
    }
    /**
     * OpenAPI vocabulary
     */
    get nullable() {
      return this.get("nullable");
    }
    set nullable(nullable) {
      this.set("nullable", nullable);
    }
    get discriminator() {
      return this.get("discriminator");
    }
    set discriminator(discriminator) {
      this.set("discriminator", discriminator);
    }
    get writeOnly() {
      return this.get("writeOnly");
    }
    set writeOnly(writeOnly) {
      this.set("writeOnly", writeOnly);
    }
    get xml() {
      return this.get("xml");
    }
    set xml(xml) {
      this.set("xml", xml);
    }
    get externalDocs() {
      return this.get("externalDocs");
    }
    set externalDocs(externalDocs) {
      this.set("externalDocs", externalDocs);
    }
    get example() {
      return this.get("example");
    }
    set example(example) {
      this.set("example", example);
    }
    get deprecated() {
      return this.get("deprecated");
    }
    set deprecated(deprecated) {
      this.set("deprecated", deprecated);
    }
  };
  const SchemaElement$1 = Schema$1;
  let SecurityRequirement$1 = class SecurityRequirement extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "securityRequirement";
    }
  };
  const SecurityRequirementElement$1 = SecurityRequirement$1;
  let SecurityScheme$1 = class SecurityScheme extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "securityScheme";
    }
    get type() {
      return this.get("type");
    }
    set type(type2) {
      this.set("type", type2);
    }
    get description() {
      return this.get("description");
    }
    set description(description) {
      this.set("description", description);
    }
    get name() {
      return this.get("name");
    }
    set name(name) {
      this.set("name", name);
    }
    get in() {
      return this.get("in");
    }
    set in(inVal) {
      this.set("in", inVal);
    }
    get scheme() {
      return this.get("scheme");
    }
    set scheme(scheme) {
      this.set("scheme", scheme);
    }
    get bearerFormat() {
      return this.get("bearerFormat");
    }
    set bearerFormat(bearerFormat) {
      this.set("bearerFormat", bearerFormat);
    }
    get flows() {
      return this.get("flows");
    }
    set flows(flows) {
      this.set("flows", flows);
    }
    get openIdConnectUrl() {
      return this.get("openIdConnectUrl");
    }
    set openIdConnectUrl(openIdConnectUrl) {
      this.set("openIdConnectUrl", openIdConnectUrl);
    }
  };
  const SecuritySchemeElement$1 = SecurityScheme$1;
  let Server$1 = class Server extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "server";
    }
    get url() {
      return this.get("url");
    }
    set url(url2) {
      this.set("url", url2);
    }
    get description() {
      return this.get("description");
    }
    set description(description) {
      this.set("description", description);
    }
    get variables() {
      return this.get("variables");
    }
    set variables(variables) {
      this.set("variables", variables);
    }
  };
  const ServerElement$1 = Server$1;
  let ServerVariable$1 = class ServerVariable extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "serverVariable";
    }
    get enum() {
      return this.get("enum");
    }
    set enum(value2) {
      this.set("enum", value2);
    }
    get default() {
      return this.get("default");
    }
    set default(value2) {
      this.set("default", value2);
    }
    get description() {
      return this.get("description");
    }
    set description(description) {
      this.set("description", description);
    }
  };
  const ServerVariableElement$1 = ServerVariable$1;
  let Tag$1 = class Tag extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "tag";
    }
    get name() {
      return this.get("name");
    }
    set name(name) {
      this.set("name", name);
    }
    get description() {
      return this.get("description");
    }
    set description(description) {
      this.set("description", description);
    }
    get externalDocs() {
      return this.get("externalDocs");
    }
    set externalDocs(externalDocs) {
      this.set("externalDocs", externalDocs);
    }
  };
  const TagElement$1 = Tag$1;
  let Xml$1 = class Xml extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "xml";
    }
    get name() {
      return this.get("name");
    }
    set name(name) {
      this.set("name", name);
    }
    get namespace() {
      return this.get("namespace");
    }
    set namespace(namespace2) {
      this.set("namespace", namespace2);
    }
    get prefix() {
      return this.get("prefix");
    }
    set prefix(prefix) {
      this.set("prefix", prefix);
    }
    get attribute() {
      return this.get("attribute");
    }
    set attribute(attribute) {
      this.set("attribute", attribute);
    }
    get wrapped() {
      return this.get("wrapped");
    }
    set wrapped(wrapped) {
      this.set("wrapped", wrapped);
    }
  };
  const XmlElement$1 = Xml$1;
  const openApi3_0 = {
    namespace: (options) => {
      const {
        base: base2
      } = options;
      base2.register("callback", CallbackElement$1);
      base2.register("components", ComponentsElement$1);
      base2.register("contact", ContactElement$1);
      base2.register("discriminator", DiscriminatorElement$1);
      base2.register("encoding", EncodingElement$1);
      base2.register("example", ExampleElement$1);
      base2.register("externalDocumentation", ExternalDocumentationElement$1);
      base2.register("header", HeaderElement$1);
      base2.register("info", InfoElement$1);
      base2.register("license", LicenseElement$1);
      base2.register("link", LinkElement$1);
      base2.register("mediaType", MediaTypeElement$1);
      base2.register("oAuthFlow", OAuthFlowElement$1);
      base2.register("oAuthFlows", OAuthFlowsElement$1);
      base2.register("openapi", OpenapiElement$1);
      base2.register("openApi3_0", OpenApi3_0Element);
      base2.register("operation", OperationElement$1);
      base2.register("parameter", ParameterElement$1);
      base2.register("pathItem", PathItemElement$1);
      base2.register("paths", PathsElement$1);
      base2.register("reference", ReferenceElement$1);
      base2.register("requestBody", RequestBodyElement$1);
      base2.register("response", ResponseElement$1);
      base2.register("responses", ResponsesElement$1);
      base2.register("schema", SchemaElement$1);
      base2.register("securityRequirement", SecurityRequirementElement$1);
      base2.register("securityScheme", SecuritySchemeElement$1);
      base2.register("server", ServerElement$1);
      base2.register("serverVariable", ServerVariableElement$1);
      base2.register("tag", TagElement$1);
      base2.register("xml", XmlElement$1);
      return base2;
    }
  };
  const openApi3_0Namespace = openApi3_0;
  const _Servers = class _Servers extends ArrayElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_Servers.primaryClass);
    }
  };
  __publicField(_Servers, "primaryClass", "servers");
  let Servers = _Servers;
  const ServersElement = Servers;
  const _Security = class _Security extends ArrayElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_Security.primaryClass);
    }
  };
  __publicField(_Security, "primaryClass", "security");
  let Security = _Security;
  const SecurityElement = Security;
  const _Tags = class _Tags extends ArrayElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_Tags.primaryClass);
    }
  };
  __publicField(_Tags, "primaryClass", "tags");
  let Tags = _Tags;
  const TagsElement = Tags;
  const _ServerVariables = class _ServerVariables extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_ServerVariables.primaryClass);
    }
  };
  __publicField(_ServerVariables, "primaryClass", "server-variables");
  let ServerVariables = _ServerVariables;
  const ServerVariablesElement = ServerVariables;
  const _ComponentsSchemas = class _ComponentsSchemas extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_ComponentsSchemas.primaryClass);
    }
  };
  __publicField(_ComponentsSchemas, "primaryClass", "components-schemas");
  let ComponentsSchemas = _ComponentsSchemas;
  const ComponentsSchemasElement = ComponentsSchemas;
  const _ComponentsResponses = class _ComponentsResponses extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_ComponentsResponses.primaryClass);
    }
  };
  __publicField(_ComponentsResponses, "primaryClass", "components-responses");
  let ComponentsResponses = _ComponentsResponses;
  const ComponentsResponsesElement = ComponentsResponses;
  const _ComponentsParameters = class _ComponentsParameters extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_ComponentsParameters.primaryClass);
      this.classes.push("parameters");
    }
  };
  __publicField(_ComponentsParameters, "primaryClass", "components-parameters");
  let ComponentsParameters = _ComponentsParameters;
  const ComponentsParametersElement = ComponentsParameters;
  const _ComponentsExamples = class _ComponentsExamples extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_ComponentsExamples.primaryClass);
      this.classes.push("examples");
    }
  };
  __publicField(_ComponentsExamples, "primaryClass", "components-examples");
  let ComponentsExamples = _ComponentsExamples;
  const ComponentsExamplesElement = ComponentsExamples;
  const _ComponentsRequestBodies = class _ComponentsRequestBodies extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_ComponentsRequestBodies.primaryClass);
    }
  };
  __publicField(_ComponentsRequestBodies, "primaryClass", "components-request-bodies");
  let ComponentsRequestBodies = _ComponentsRequestBodies;
  const ComponentsRequestBodiesElement = ComponentsRequestBodies;
  const _ComponentsHeaders = class _ComponentsHeaders extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_ComponentsHeaders.primaryClass);
    }
  };
  __publicField(_ComponentsHeaders, "primaryClass", "components-headers");
  let ComponentsHeaders = _ComponentsHeaders;
  const ComponentsHeadersElement = ComponentsHeaders;
  const _ComponentsSecuritySchemes = class _ComponentsSecuritySchemes extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_ComponentsSecuritySchemes.primaryClass);
    }
  };
  __publicField(_ComponentsSecuritySchemes, "primaryClass", "components-security-schemes");
  let ComponentsSecuritySchemes = _ComponentsSecuritySchemes;
  const ComponentsSecuritySchemesElement = ComponentsSecuritySchemes;
  const _ComponentsLinks = class _ComponentsLinks extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_ComponentsLinks.primaryClass);
    }
  };
  __publicField(_ComponentsLinks, "primaryClass", "components-links");
  let ComponentsLinks = _ComponentsLinks;
  const ComponentsLinksElement = ComponentsLinks;
  const _ComponentsCallbacks = class _ComponentsCallbacks extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_ComponentsCallbacks.primaryClass);
    }
  };
  __publicField(_ComponentsCallbacks, "primaryClass", "components-callbacks");
  let ComponentsCallbacks = _ComponentsCallbacks;
  const ComponentsCallbacksElement = ComponentsCallbacks;
  const _PathItemServers = class _PathItemServers extends ArrayElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_PathItemServers.primaryClass);
      this.classes.push("servers");
    }
  };
  __publicField(_PathItemServers, "primaryClass", "path-item-servers");
  let PathItemServers = _PathItemServers;
  const PathItemServersElement = PathItemServers;
  const _PathItemParameters = class _PathItemParameters extends ArrayElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_PathItemParameters.primaryClass);
      this.classes.push("parameters");
    }
  };
  __publicField(_PathItemParameters, "primaryClass", "path-item-parameters");
  let PathItemParameters = _PathItemParameters;
  const PathItemParametersElement = PathItemParameters;
  const _OperationParameters = class _OperationParameters extends ArrayElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_OperationParameters.primaryClass);
      this.classes.push("parameters");
    }
  };
  __publicField(_OperationParameters, "primaryClass", "operation-parameters");
  let OperationParameters = _OperationParameters;
  const OperationParametersElement = OperationParameters;
  const _ParameterExamples = class _ParameterExamples extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_ParameterExamples.primaryClass);
      this.classes.push("examples");
    }
  };
  __publicField(_ParameterExamples, "primaryClass", "parameter-examples");
  let ParameterExamples = _ParameterExamples;
  const ParameterExamplesElement = ParameterExamples;
  const _ParameterContent = class _ParameterContent extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_ParameterContent.primaryClass);
      this.classes.push("content");
    }
  };
  __publicField(_ParameterContent, "primaryClass", "parameter-content");
  let ParameterContent = _ParameterContent;
  const ParameterContentElement = ParameterContent;
  const _OperationTags = class _OperationTags extends ArrayElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_OperationTags.primaryClass);
    }
  };
  __publicField(_OperationTags, "primaryClass", "operation-tags");
  let OperationTags = _OperationTags;
  const OperationTagsElement = OperationTags;
  const _OperationCallbacks = class _OperationCallbacks extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_OperationCallbacks.primaryClass);
    }
  };
  __publicField(_OperationCallbacks, "primaryClass", "operation-callbacks");
  let OperationCallbacks = _OperationCallbacks;
  const OperationCallbacksElement = OperationCallbacks;
  const _OperationSecurity = class _OperationSecurity extends ArrayElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_OperationSecurity.primaryClass);
      this.classes.push("security");
    }
  };
  __publicField(_OperationSecurity, "primaryClass", "operation-security");
  let OperationSecurity = _OperationSecurity;
  const OperationSecurityElement = OperationSecurity;
  const _OperationServers = class _OperationServers extends ArrayElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_OperationServers.primaryClass);
      this.classes.push("servers");
    }
  };
  __publicField(_OperationServers, "primaryClass", "operation-servers");
  let OperationServers = _OperationServers;
  const OperationServersElement = OperationServers;
  const _RequestBodyContent = class _RequestBodyContent extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_RequestBodyContent.primaryClass);
      this.classes.push("content");
    }
  };
  __publicField(_RequestBodyContent, "primaryClass", "request-body-content");
  let RequestBodyContent = _RequestBodyContent;
  const RequestBodyContentElement = RequestBodyContent;
  const _MediaTypeExamples = class _MediaTypeExamples extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_MediaTypeExamples.primaryClass);
      this.classes.push("examples");
    }
  };
  __publicField(_MediaTypeExamples, "primaryClass", "media-type-examples");
  let MediaTypeExamples = _MediaTypeExamples;
  const MediaTypeExamplesElement = MediaTypeExamples;
  const _MediaTypeEncoding = class _MediaTypeEncoding extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_MediaTypeEncoding.primaryClass);
    }
  };
  __publicField(_MediaTypeEncoding, "primaryClass", "media-type-encoding");
  let MediaTypeEncoding = _MediaTypeEncoding;
  const MediaTypeEncodingElement = MediaTypeEncoding;
  const _EncodingHeaders = class _EncodingHeaders extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_EncodingHeaders.primaryClass);
    }
  };
  __publicField(_EncodingHeaders, "primaryClass", "encoding-headers");
  let EncodingHeaders = _EncodingHeaders;
  const EncodingHeadersElement = EncodingHeaders;
  const _ResponseHeaders = class _ResponseHeaders extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_ResponseHeaders.primaryClass);
    }
  };
  __publicField(_ResponseHeaders, "primaryClass", "response-headers");
  let ResponseHeaders = _ResponseHeaders;
  const ResponseHeadersElement = ResponseHeaders;
  const _ResponseContent = class _ResponseContent extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_ResponseContent.primaryClass);
      this.classes.push("content");
    }
  };
  __publicField(_ResponseContent, "primaryClass", "response-content");
  let ResponseContent = _ResponseContent;
  const ResponseContentElement = ResponseContent;
  const _ResponseLinks = class _ResponseLinks extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_ResponseLinks.primaryClass);
    }
  };
  __publicField(_ResponseLinks, "primaryClass", "response-links");
  let ResponseLinks = _ResponseLinks;
  const ResponseLinksElement = ResponseLinks;
  const _DiscriminatorMapping = class _DiscriminatorMapping extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_DiscriminatorMapping.primaryClass);
    }
  };
  __publicField(_DiscriminatorMapping, "primaryClass", "discriminator-mapping");
  let DiscriminatorMapping = _DiscriminatorMapping;
  const DiscriminatorMappingElement = DiscriminatorMapping;
  const _OAuthFlowScopes = class _OAuthFlowScopes extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_OAuthFlowScopes.primaryClass);
    }
  };
  __publicField(_OAuthFlowScopes, "primaryClass", "oauth-flow-scopes");
  let OAuthFlowScopes = _OAuthFlowScopes;
  const OAuthFlowScopesElement = OAuthFlowScopes;
  const _LinkParameters = class _LinkParameters extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_LinkParameters.primaryClass);
    }
  };
  __publicField(_LinkParameters, "primaryClass", "link-parameters");
  let LinkParameters = _LinkParameters;
  const LinkParametersElement = LinkParameters;
  const _HeaderExamples = class _HeaderExamples extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_HeaderExamples.primaryClass);
      this.classes.push("examples");
    }
  };
  __publicField(_HeaderExamples, "primaryClass", "header-examples");
  let HeaderExamples = _HeaderExamples;
  const HeaderExamplesElement = HeaderExamples;
  const _HeaderContent = class _HeaderContent extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_HeaderContent.primaryClass);
      this.classes.push("content");
    }
  };
  __publicField(_HeaderContent, "primaryClass", "header-content");
  let HeaderContent = _HeaderContent;
  const HeaderContentElement = HeaderContent;
  const getNodeType$1 = (element) => {
    if (!isElement(element)) {
      return void 0;
    }
    return `${element.element.charAt(0).toUpperCase() + element.element.slice(1)}Element`;
  };
  const keyMap$1 = {
    CallbackElement: ["content"],
    ComponentsElement: ["content"],
    ContactElement: ["content"],
    DiscriminatorElement: ["content"],
    Encoding: ["content"],
    Example: ["content"],
    ExternalDocumentationElement: ["content"],
    HeaderElement: ["content"],
    InfoElement: ["content"],
    LicenseElement: ["content"],
    MediaTypeElement: ["content"],
    OAuthFlowElement: ["content"],
    OAuthFlowsElement: ["content"],
    OpenApi3_0Element: ["content"],
    OperationElement: ["content"],
    ParameterElement: ["content"],
    PathItemElement: ["content"],
    PathsElement: ["content"],
    ReferenceElement: ["content"],
    RequestBodyElement: ["content"],
    ResponseElement: ["content"],
    ResponsesElement: ["content"],
    SchemaElement: ["content"],
    SecurityRequirementElement: ["content"],
    SecuritySchemeElement: ["content"],
    ServerElement: ["content"],
    ServerVariableElement: ["content"],
    TagElement: ["content"],
    ...keyMapDefault$1
  };
  const Visitor = stampit({
    props: {
      element: null
    },
    // @ts-ignore
    methods: {
      copyMetaAndAttributes(from2, to) {
        if (hasElementSourceMap(from2)) {
          to.meta.set("sourceMap", from2.meta.get("sourceMap"));
        }
      }
    }
  });
  const Visitor$1 = Visitor;
  const SpecificationVisitor = stampit(Visitor$1, {
    props: {
      passingOptionsNames: ["specObj", "openApiGenericElement", "openApiSemanticElement"],
      specObj: null,
      openApiGenericElement: null,
      openApiSemanticElement: null
    },
    init({
      // @ts-ignore
      specObj = this.specObj,
      // @ts-ignore
      openApiGenericElement = this.openApiGenericElement,
      // @ts-ignore
      openApiSemanticElement = this.openApiSemanticElement
    }) {
      this.specObj = specObj;
      this.openApiGenericElement = openApiGenericElement;
      this.openApiSemanticElement = openApiSemanticElement;
    },
    methods: {
      retrievePassingOptions() {
        return pick$2(this.passingOptionsNames, this);
      },
      retrieveFixedFields(specPath) {
        return pipe$2(path$6(["visitors", ...specPath, "fixedFields"]), keys$4)(this.specObj);
      },
      retrieveVisitor(specPath) {
        if (pathSatisfies$1(isFunction$7, ["visitors", ...specPath], this.specObj)) {
          return path$6(["visitors", ...specPath], this.specObj);
        }
        return path$6(["visitors", ...specPath, "$visitor"], this.specObj);
      },
      retrieveVisitorInstance(specPath, options = {}) {
        const passingOpts = this.retrievePassingOptions();
        return this.retrieveVisitor(specPath)({
          ...passingOpts,
          ...options
        });
      },
      toRefractedElement(specPath, element, options = {}) {
        const visitor2 = this.retrieveVisitorInstance(specPath, options);
        const visitorPrototype = Object.getPrototypeOf(visitor2);
        if (isUndefined$1(this.fallbackVisitorPrototype)) {
          this.fallbackVisitorPrototype = Object.getPrototypeOf(this.retrieveVisitorInstance(["value"]));
        }
        if (this.fallbackVisitorPrototype === visitorPrototype) {
          return cloneDeep(element);
        }
        visit$1(element, visitor2, {
          keyMap: keyMap$1,
          nodeTypeGetter: getNodeType$1,
          ...options
        });
        return visitor2.element;
      }
    }
  });
  const SpecificationVisitor$1 = SpecificationVisitor;
  const isOpenApi3_0LikeElement = (element) => {
    return isObjectElement(element) && element.hasKey("openapi") && element.hasKey("info");
  };
  const isParameterLikeElement = (element) => {
    return isObjectElement(element) && element.hasKey("name") && element.hasKey("in");
  };
  const isReferenceLikeElement = (element) => {
    return isObjectElement(element) && element.hasKey("$ref");
  };
  const isRequestBodyLikeElement = (element) => {
    return isObjectElement(element) && element.hasKey("content");
  };
  const isResponseLikeElement = (element) => {
    return isObjectElement(element) && element.hasKey("description");
  };
  const isServerLikeElement = isObjectElement;
  const isTagLikeElement = isObjectElement;
  const isOpenApiExtension = (element) => {
    return isStringElement(element.key) && startsWith$1("x-", toValue(element.key));
  };
  const refractorPredicates = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    isOpenApi3_0LikeElement,
    isOpenApiExtension,
    isParameterLikeElement,
    isReferenceLikeElement,
    isRequestBodyLikeElement,
    isResponseLikeElement,
    isServerLikeElement,
    isTagLikeElement
  }, Symbol.toStringTag, { value: "Module" }));
  const FixedFieldsVisitor = stampit(SpecificationVisitor$1, {
    props: {
      specPath: noop$3,
      ignoredFields: [],
      canSupportSpecificationExtensions: true,
      specificationExtensionPredicate: isOpenApiExtension
    },
    init({
      // @ts-ignore
      specPath = this.specPath,
      // @ts-ignore
      ignoredFields = this.ignoredFields,
      // @ts-ignore
      canSupportSpecificationExtensions = this.canSupportSpecificationExtensions,
      // @ts-ignore
      specificationExtensionPredicate = this.specificationExtensionPredicate
    } = {}) {
      this.specPath = specPath;
      this.ignoredFields = ignoredFields;
      this.canSupportSpecificationExtensions = canSupportSpecificationExtensions;
      this.specificationExtensionPredicate = specificationExtensionPredicate;
    },
    methods: {
      ObjectElement(objectElement) {
        const specPath = this.specPath(objectElement);
        const fields = this.retrieveFixedFields(specPath);
        objectElement.forEach((value2, key, memberElement) => {
          if (isStringElement(key) && fields.includes(toValue(key)) && !this.ignoredFields.includes(toValue(key))) {
            const fixedFieldElement = this.toRefractedElement([...specPath, "fixedFields", toValue(key)], value2);
            const newMemberElement = new MemberElement(cloneDeep(key), fixedFieldElement);
            this.copyMetaAndAttributes(memberElement, newMemberElement);
            newMemberElement.classes.push("fixed-field");
            this.element.content.push(newMemberElement);
          } else if (this.canSupportSpecificationExtensions && this.specificationExtensionPredicate(memberElement)) {
            const extensionElement = this.toRefractedElement(["document", "extension"], memberElement);
            this.element.content.push(extensionElement);
          } else if (!this.ignoredFields.includes(toValue(key))) {
            this.element.content.push(cloneDeep(memberElement));
          }
        });
        this.copyMetaAndAttributes(objectElement, this.element);
        return BREAK;
      }
    }
  });
  const FixedFieldsVisitor$1 = FixedFieldsVisitor;
  const FallbackVisitor = stampit(Visitor$1, {
    methods: {
      enter(element) {
        this.element = cloneDeep(element);
        return BREAK;
      }
    }
  });
  const FallbackVisitor$1 = FallbackVisitor;
  const OpenApi3_0Visitor = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "OpenApi"]),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new OpenApi3_0Element();
    },
    methods: {
      ObjectElement(objectElement) {
        this.unrefractedElement = objectElement;
        return FixedFieldsVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
      }
    }
  });
  const OpenApi3_0Visitor$1 = OpenApi3_0Visitor;
  const OpenapiVisitor = stampit(SpecificationVisitor$1, FallbackVisitor$1, {
    methods: {
      StringElement(stringElement) {
        const openapiElement = new OpenapiElement$1(toValue(stringElement));
        this.copyMetaAndAttributes(stringElement, openapiElement);
        this.element = openapiElement;
        return BREAK;
      }
    }
  });
  const OpenapiVisitor$1 = OpenapiVisitor;
  const SpecificationExtensionVisitor = stampit(SpecificationVisitor$1, {
    methods: {
      MemberElement(memberElement) {
        this.element = cloneDeep(memberElement);
        this.element.classes.push("specification-extension");
        return BREAK;
      }
    }
  });
  const SpecificationExtensionVisitor$1 = SpecificationExtensionVisitor;
  const InfoVisitor$2 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "Info"]),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new InfoElement$1();
    }
  });
  const InfoVisitor$3 = InfoVisitor$2;
  const TitleVisitor$1 = FallbackVisitor$1;
  const InfoTitleVisitor = TitleVisitor$1;
  const DescriptionVisitor$f = FallbackVisitor$1;
  const InfoDescriptionVisitor = DescriptionVisitor$f;
  const TermsOfServiceVisitor = FallbackVisitor$1;
  const InfoTermsOfServiceVisitor = TermsOfServiceVisitor;
  const VersionVisitor = stampit(FallbackVisitor$1, {
    methods: {
      StringElement(stringElement) {
        this.element = cloneDeep(stringElement);
        this.element.classes.push("api-version");
        this.element.classes.push("version");
        return BREAK;
      }
    }
  });
  const InfoVersionVisitor = VersionVisitor;
  const ContactVisitor$2 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "Contact"]),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new ContactElement$1();
    }
  });
  const ContactVisitor$3 = ContactVisitor$2;
  const NameVisitor$5 = FallbackVisitor$1;
  const ContactNameVisitor = NameVisitor$5;
  const UrlVisitor$3 = FallbackVisitor$1;
  const ContactUrlVisitor = UrlVisitor$3;
  const EmailVisitor = FallbackVisitor$1;
  const ContactEmailVisitor = EmailVisitor;
  const LicenseVisitor$2 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "License"]),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new LicenseElement$1();
    }
  });
  const LicenseVisitor$3 = LicenseVisitor$2;
  const NameVisitor$4 = FallbackVisitor$1;
  const LicenseNameVisitor = NameVisitor$4;
  const UrlVisitor$2 = FallbackVisitor$1;
  const LicenseUrlVisitor = UrlVisitor$2;
  const LinkVisitor$2 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "Link"]),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new LinkElement$1();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = FixedFieldsVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        if (isStringElement(this.element.operationId) || isStringElement(this.element.operationRef)) {
          this.element.classes.push("reference-element");
        }
        return result;
      }
    }
  });
  const LinkVisitor$3 = LinkVisitor$2;
  const OperationRefVisitor = stampit(FallbackVisitor$1, {
    methods: {
      StringElement(stringElement) {
        this.element = cloneDeep(stringElement);
        this.element.classes.push("reference-value");
        return BREAK;
      }
    }
  });
  const LinkOperationRefVisitor = OperationRefVisitor;
  const OperationIdVisitor$1 = stampit(FallbackVisitor$1, {
    methods: {
      StringElement(stringElement) {
        this.element = cloneDeep(stringElement);
        this.element.classes.push("reference-value");
        return BREAK;
      }
    }
  });
  const LinkOperationIdVisitor = OperationIdVisitor$1;
  const PatternedFieldsJsonObjectVisitor = stampit(SpecificationVisitor$1, {
    props: {
      fieldPatternPredicate: stubFalse$1,
      specPath: noop$3,
      ignoredFields: [],
      canSupportSpecificationExtensions: false,
      specificationExtensionPredicate: isOpenApiExtension
    },
    init({
      // @ts-ignore
      specPath = this.specPath,
      // @ts-ignore
      ignoredFields = this.ignoredFields,
      // @ts-ignore
      canSupportSpecificationExtensions = this.canSupportSpecificationExtensions,
      // @ts-ignore
      specificationExtensionPredicate = this.specificationExtensionPredicate
    } = {}) {
      this.specPath = specPath;
      this.ignoredFields = ignoredFields;
      this.canSupportSpecificationExtensions = canSupportSpecificationExtensions;
      this.specificationExtensionPredicate = specificationExtensionPredicate;
    },
    methods: {
      ObjectElement(objectElement) {
        objectElement.forEach((value2, key, memberElement) => {
          if (this.canSupportSpecificationExtensions && this.specificationExtensionPredicate(memberElement)) {
            const extensionElement = this.toRefractedElement(["document", "extension"], memberElement);
            this.element.content.push(extensionElement);
          } else if (!this.ignoredFields.includes(toValue(key)) && this.fieldPatternPredicate(toValue(key))) {
            const specPath = this.specPath(value2);
            const patternedFieldElement = this.toRefractedElement(specPath, value2);
            const newMemberElement = new MemberElement(cloneDeep(key), patternedFieldElement);
            this.copyMetaAndAttributes(memberElement, newMemberElement);
            newMemberElement.classes.push("patterned-field");
            this.element.content.push(newMemberElement);
          } else if (!this.ignoredFields.includes(toValue(key))) {
            this.element.content.push(cloneDeep(memberElement));
          }
        });
        this.copyMetaAndAttributes(objectElement, this.element);
        return BREAK;
      }
    }
  });
  const PatternedFieldsVisitor = PatternedFieldsJsonObjectVisitor;
  const MapVisitor = stampit(PatternedFieldsVisitor, {
    props: {
      fieldPatternPredicate: isNonEmptyString$1
    }
  });
  const MapVisitor$1 = MapVisitor;
  const ParametersVisitor$5 = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["value"])
    },
    init() {
      this.element = new LinkParametersElement();
    }
  });
  const LinkParametersVisitor = ParametersVisitor$5;
  const RequestBodyVisitor$5 = FallbackVisitor$1;
  const LinkRequestBodyVisitor = RequestBodyVisitor$5;
  const DescriptionVisitor$e = FallbackVisitor$1;
  const LinkDescriptionVisitor = DescriptionVisitor$e;
  const ServerVisitor$2 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "Server"]),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new ServerElement$1();
    }
  });
  const ServerVisitor$3 = ServerVisitor$2;
  const UrlVisitor$1 = stampit(FallbackVisitor$1, {
    methods: {
      StringElement(stringElement) {
        this.element = cloneDeep(stringElement);
        this.element.classes.push("server-url");
        return BREAK;
      }
    }
  });
  const ServerUrlVisitor = UrlVisitor$1;
  const DescriptionVisitor$d = FallbackVisitor$1;
  const ServerDescriptionVisitor = DescriptionVisitor$d;
  const ServersVisitor$2 = stampit(SpecificationVisitor$1, FallbackVisitor$1, {
    init() {
      this.element = new ServersElement();
    },
    methods: {
      ArrayElement(arrayElement) {
        arrayElement.forEach((item) => {
          const specPath = isServerLikeElement(item) ? ["document", "objects", "Server"] : ["value"];
          const element = this.toRefractedElement(specPath, item);
          this.element.push(element);
        });
        this.copyMetaAndAttributes(arrayElement, this.element);
        return BREAK;
      }
    }
  });
  const ServersVisitor$3 = ServersVisitor$2;
  const ServerVariableVisitor$2 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "ServerVariable"]),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new ServerVariableElement$1();
    }
  });
  const ServerVariableVisitor$3 = ServerVariableVisitor$2;
  const EnumVisitor$1 = FallbackVisitor$1;
  const ServerVariableEnumVisitor = EnumVisitor$1;
  const DefaultVisitor$2 = FallbackVisitor$1;
  const ServerVariableDefaultVisitor = DefaultVisitor$2;
  const DescriptionVisitor$c = FallbackVisitor$1;
  const ServerVariableDescriptionVisitor = DescriptionVisitor$c;
  const VariablesVisitor = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "ServerVariable"])
    },
    init() {
      this.element = new ServerVariablesElement();
    }
  });
  const ServerVariablesVisitor = VariablesVisitor;
  const MediaTypeVisitor$2 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "MediaType"]),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new MediaTypeElement$1();
    }
  });
  const MediaTypeVisitor$3 = MediaTypeVisitor$2;
  const AlternatingVisitor = stampit(SpecificationVisitor$1, {
    props: {
      alternator: []
    },
    methods: {
      enter(element) {
        const functions = this.alternator.map(({
          predicate,
          specPath: specPath2
        }) => ifElse$1(predicate, always$1(specPath2), stubUndefined$1));
        const specPath = dispatch$9(functions)(element);
        this.element = this.toRefractedElement(specPath, element);
        return BREAK;
      }
    }
  });
  const AlternatingVisitor$1 = AlternatingVisitor;
  const isCallbackElement$1 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof CallbackElement$1 || hasBasicElementProps2(element) && isElementType2("callback", element) && primitiveEq2("object", element);
  });
  const isComponentsElement$1 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof ComponentsElement$1 || hasBasicElementProps2(element) && isElementType2("components", element) && primitiveEq2("object", element);
  });
  const isContactElement$1 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof ContactElement$1 || hasBasicElementProps2(element) && isElementType2("contact", element) && primitiveEq2("object", element);
  });
  const isExampleElement$1 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof ExampleElement$1 || hasBasicElementProps2(element) && isElementType2("example", element) && primitiveEq2("object", element);
  });
  const isExternalDocumentationElement$1 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof ExternalDocumentationElement$1 || hasBasicElementProps2(element) && isElementType2("externalDocumentation", element) && primitiveEq2("object", element);
  });
  const isHeaderElement$1 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof HeaderElement$1 || hasBasicElementProps2(element) && isElementType2("header", element) && primitiveEq2("object", element);
  });
  const isInfoElement$1 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof InfoElement$1 || hasBasicElementProps2(element) && isElementType2("info", element) && primitiveEq2("object", element);
  });
  const isLicenseElement$1 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof LicenseElement$1 || hasBasicElementProps2(element) && isElementType2("license", element) && primitiveEq2("object", element);
  });
  const isLinkElement$1 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof LinkElement$1 || hasBasicElementProps2(element) && isElementType2("link", element) && primitiveEq2("object", element);
  });
  const isLinkElementExternal$1 = (element) => {
    if (!isLinkElement$1(element)) {
      return false;
    }
    if (!isStringElement(element.operationRef)) {
      return false;
    }
    const value2 = toValue(element.operationRef);
    return typeof value2 === "string" && value2.length > 0 && !value2.startsWith("#");
  };
  const isOpenapiElement$1 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof OpenapiElement$1 || hasBasicElementProps2(element) && isElementType2("openapi", element) && primitiveEq2("string", element);
  });
  const isOpenApi3_0Element = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2,
    hasClass: hasClass2
  }) => {
    return (element) => element instanceof OpenApi3_0Element || hasBasicElementProps2(element) && isElementType2("openApi3_0", element) && primitiveEq2("object", element) && hasClass2("api", element);
  });
  const isOperationElement$1 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof OperationElement$1 || hasBasicElementProps2(element) && isElementType2("operation", element) && primitiveEq2("object", element);
  });
  const isParameterElement$1 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof ParameterElement$1 || hasBasicElementProps2(element) && isElementType2("parameter", element) && primitiveEq2("object", element);
  });
  const isPathItemElement$1 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof PathItemElement$1 || hasBasicElementProps2(element) && isElementType2("pathItem", element) && primitiveEq2("object", element);
  });
  const isPathItemElementExternal$1 = (element) => {
    if (!isPathItemElement$1(element)) {
      return false;
    }
    if (!isStringElement(element.$ref)) {
      return false;
    }
    const value2 = toValue(element.$ref);
    return typeof value2 === "string" && value2.length > 0 && !value2.startsWith("#");
  };
  const isPathsElement$1 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof PathsElement$1 || hasBasicElementProps2(element) && isElementType2("paths", element) && primitiveEq2("object", element);
  });
  const isReferenceElement$1 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof ReferenceElement$1 || hasBasicElementProps2(element) && isElementType2("reference", element) && primitiveEq2("object", element);
  });
  const isReferenceElementExternal$1 = (element) => {
    if (!isReferenceElement$1(element)) {
      return false;
    }
    if (!isStringElement(element.$ref)) {
      return false;
    }
    const value2 = toValue(element.$ref);
    return typeof value2 === "string" && value2.length > 0 && !value2.startsWith("#");
  };
  const isRequestBodyElement$1 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof RequestBodyElement$1 || hasBasicElementProps2(element) && isElementType2("requestBody", element) && primitiveEq2("object", element);
  });
  const isResponseElement$1 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof ResponseElement$1 || hasBasicElementProps2(element) && isElementType2("response", element) && primitiveEq2("object", element);
  });
  const isResponsesElement$1 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof ResponsesElement$1 || hasBasicElementProps2(element) && isElementType2("responses", element) && primitiveEq2("object", element);
  });
  const isSchemaElement$1 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof SchemaElement$1 || hasBasicElementProps2(element) && isElementType2("schema", element) && primitiveEq2("object", element);
  });
  const isBooleanJsonSchemaElement$1 = (element) => {
    return isBooleanElement(element) && element.classes.includes("boolean-json-schema");
  };
  const isSecurityRequirementElement$1 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof SecurityRequirementElement$1 || hasBasicElementProps2(element) && isElementType2("securityRequirement", element) && primitiveEq2("object", element);
  });
  const isServerElement$1 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof ServerElement$1 || hasBasicElementProps2(element) && isElementType2("server", element) && primitiveEq2("object", element);
  });
  const isServerVariableElement$1 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof ServerVariableElement$1 || hasBasicElementProps2(element) && isElementType2("serverVariable", element) && primitiveEq2("object", element);
  });
  const isMediaTypeElement$1 = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof MediaTypeElement$1 || hasBasicElementProps2(element) && isElementType2("mediaType", element) && primitiveEq2("object", element);
  });
  const openApi3_0Predicates = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    isBooleanJsonSchemaElement: isBooleanJsonSchemaElement$1,
    isCallbackElement: isCallbackElement$1,
    isComponentsElement: isComponentsElement$1,
    isContactElement: isContactElement$1,
    isExampleElement: isExampleElement$1,
    isExternalDocumentationElement: isExternalDocumentationElement$1,
    isHeaderElement: isHeaderElement$1,
    isInfoElement: isInfoElement$1,
    isLicenseElement: isLicenseElement$1,
    isLinkElement: isLinkElement$1,
    isLinkElementExternal: isLinkElementExternal$1,
    isMediaTypeElement: isMediaTypeElement$1,
    isOpenApi3_0Element,
    isOpenapiElement: isOpenapiElement$1,
    isOperationElement: isOperationElement$1,
    isParameterElement: isParameterElement$1,
    isPathItemElement: isPathItemElement$1,
    isPathItemElementExternal: isPathItemElementExternal$1,
    isPathsElement: isPathsElement$1,
    isReferenceElement: isReferenceElement$1,
    isReferenceElementExternal: isReferenceElementExternal$1,
    isRequestBodyElement: isRequestBodyElement$1,
    isResponseElement: isResponseElement$1,
    isResponsesElement: isResponsesElement$1,
    isSchemaElement: isSchemaElement$1,
    isSecurityRequirementElement: isSecurityRequirementElement$1,
    isServerElement: isServerElement$1,
    isServerVariableElement: isServerVariableElement$1
  }, Symbol.toStringTag, { value: "Module" }));
  const SchemaVisitor$6 = stampit(AlternatingVisitor$1, FallbackVisitor$1, {
    props: {
      alternator: [{
        predicate: isReferenceLikeElement,
        specPath: ["document", "objects", "Reference"]
      }, {
        predicate: stubTrue,
        specPath: ["document", "objects", "Schema"]
      }]
    },
    methods: {
      ObjectElement(objectElement) {
        const result = AlternatingVisitor$1.compose.methods.enter.call(this, objectElement);
        if (isReferenceElement$1(this.element)) {
          this.element.setMetaProperty("referenced-element", "schema");
        }
        return result;
      }
    }
  });
  const MediaTypeSchemaVisitor = SchemaVisitor$6;
  const ExampleVisitor$8 = FallbackVisitor$1;
  const MediaTypeExampleVisitor = ExampleVisitor$8;
  const ExamplesVisitor$6 = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: (element) => isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Example"],
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new ObjectElement();
      this.element.classes.push("examples");
    },
    methods: {
      ObjectElement(objectElement) {
        const result = MapVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isReferenceElement$1).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "example");
        });
        return result;
      }
    }
  });
  const BaseExamplesVisitor = ExamplesVisitor$6;
  const ExamplesVisitor$5 = stampit(BaseExamplesVisitor, {
    init() {
      this.element = new MediaTypeExamplesElement();
    }
  });
  const MediaTypeExamplesVisitor = ExamplesVisitor$5;
  const EncodingVisitor$4 = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "Encoding"])
    },
    init() {
      this.element = new MediaTypeEncodingElement();
    }
  });
  const MediaTypeEncodingVisitor = EncodingVisitor$4;
  const SecurityRequirementVisitor$2 = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["value"])
    },
    init() {
      this.element = new SecurityRequirementElement$1();
    }
  });
  const SecurityRequirementVisitor$3 = SecurityRequirementVisitor$2;
  const SecurityVisitor$1 = stampit(SpecificationVisitor$1, FallbackVisitor$1, {
    init() {
      this.element = new SecurityElement();
    },
    methods: {
      ArrayElement(arrayElement) {
        arrayElement.forEach((item) => {
          if (isObjectElement(item)) {
            const element = this.toRefractedElement(["document", "objects", "SecurityRequirement"], item);
            this.element.push(element);
          } else {
            this.element.push(cloneDeep(item));
          }
        });
        this.copyMetaAndAttributes(arrayElement, this.element);
        return BREAK;
      }
    }
  });
  const SecurityVisitor$2 = SecurityVisitor$1;
  const ComponentsVisitor$2 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "Components"]),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new ComponentsElement$1();
    }
  });
  const ComponentsVisitor$3 = ComponentsVisitor$2;
  const TagVisitor$2 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "Tag"]),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new TagElement$1();
    }
  });
  const TagVisitor$3 = TagVisitor$2;
  const NameVisitor$3 = FallbackVisitor$1;
  const TagNameVisitor = NameVisitor$3;
  const DescriptionVisitor$b = FallbackVisitor$1;
  const TagDescriptionVisitor = DescriptionVisitor$b;
  const ReferenceVisitor$2 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "Reference"]),
      canSupportSpecificationExtensions: false
    },
    init() {
      this.element = new ReferenceElement$1();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = FixedFieldsVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        if (isStringElement(this.element.$ref)) {
          this.element.classes.push("reference-element");
        }
        return result;
      }
    }
  });
  const ReferenceVisitor$3 = ReferenceVisitor$2;
  const $RefVisitor$1 = stampit(FallbackVisitor$1, {
    methods: {
      StringElement(stringElement) {
        this.element = cloneDeep(stringElement);
        this.element.classes.push("reference-value");
        return BREAK;
      }
    }
  });
  const Reference$RefVisitor = $RefVisitor$1;
  const ParameterVisitor$2 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "Parameter"]),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new ParameterElement$1();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = FixedFieldsVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        if (isObjectElement(this.element.contentProp)) {
          this.element.contentProp.filter(isMediaTypeElement$1).forEach((mediaTypeElement, key) => {
            mediaTypeElement.setMetaProperty("media-type", toValue(key));
          });
        }
        return result;
      }
    }
  });
  const ParameterVisitor$3 = ParameterVisitor$2;
  const NameVisitor$2 = FallbackVisitor$1;
  const ParameterNameVisitor = NameVisitor$2;
  const InVisitor$1 = FallbackVisitor$1;
  const ParameterInVisitor = InVisitor$1;
  const DescriptionVisitor$a = FallbackVisitor$1;
  const ParameterDescriptionVisitor = DescriptionVisitor$a;
  const RequiredVisitor$3 = FallbackVisitor$1;
  const ParameterRequiredVisitor = RequiredVisitor$3;
  const DeprecatedVisitor$4 = FallbackVisitor$1;
  const ParameterDeprecatedVisitor = DeprecatedVisitor$4;
  const AllowEmptyValueVisitor$1 = FallbackVisitor$1;
  const ParameterAllowEmptyValueVisitor = AllowEmptyValueVisitor$1;
  const StyleVisitor$2 = FallbackVisitor$1;
  const ParameterStyleVisitor = StyleVisitor$2;
  const ExplodeVisitor$2 = FallbackVisitor$1;
  const ParameterExplodeVisitor = ExplodeVisitor$2;
  const AllowReservedVisitor$2 = FallbackVisitor$1;
  const ParameterAllowReservedVisitor = AllowReservedVisitor$2;
  const SchemaVisitor$5 = stampit(AlternatingVisitor$1, FallbackVisitor$1, {
    props: {
      alternator: [{
        predicate: isReferenceLikeElement,
        specPath: ["document", "objects", "Reference"]
      }, {
        predicate: stubTrue,
        specPath: ["document", "objects", "Schema"]
      }]
    },
    methods: {
      ObjectElement(objectElement) {
        const result = AlternatingVisitor$1.compose.methods.enter.call(this, objectElement);
        if (isReferenceElement$1(this.element)) {
          this.element.setMetaProperty("referenced-element", "schema");
        }
        return result;
      }
    }
  });
  const ParameterSchemaVisitor = SchemaVisitor$5;
  const HeaderVisitor$2 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "Header"]),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new HeaderElement$1();
    }
  });
  const HeaderVisitor$3 = HeaderVisitor$2;
  const DescriptionVisitor$9 = FallbackVisitor$1;
  const HeaderDescriptionVisitor = DescriptionVisitor$9;
  const RequiredVisitor$2 = FallbackVisitor$1;
  const HeaderRequiredVisitor = RequiredVisitor$2;
  const DeprecatedVisitor$3 = FallbackVisitor$1;
  const HeaderDeprecatedVisitor = DeprecatedVisitor$3;
  const AllowEmptyValueVisitor = FallbackVisitor$1;
  const HeaderAllowEmptyValueVisitor = AllowEmptyValueVisitor;
  const StyleVisitor$1 = FallbackVisitor$1;
  const HeaderStyleVisitor = StyleVisitor$1;
  const ExplodeVisitor$1 = FallbackVisitor$1;
  const HeaderExplodeVisitor = ExplodeVisitor$1;
  const AllowReservedVisitor$1 = FallbackVisitor$1;
  const HeaderAllowReservedVisitor = AllowReservedVisitor$1;
  const SchemaVisitor$4 = stampit(AlternatingVisitor$1, FallbackVisitor$1, {
    props: {
      alternator: [{
        predicate: isReferenceLikeElement,
        specPath: ["document", "objects", "Reference"]
      }, {
        predicate: stubTrue,
        specPath: ["document", "objects", "Schema"]
      }]
    },
    methods: {
      ObjectElement(objectElement) {
        const result = AlternatingVisitor$1.compose.methods.enter.call(this, objectElement);
        if (isReferenceElement$1(this.element)) {
          this.element.setMetaProperty("referenced-element", "schema");
        }
        return result;
      }
    }
  });
  const HeaderSchemaVisitor = SchemaVisitor$4;
  const ExampleVisitor$7 = FallbackVisitor$1;
  const HeaderExampleVisitor = ExampleVisitor$7;
  const ExamplesVisitor$4 = stampit(BaseExamplesVisitor, {
    init() {
      this.element = new HeaderExamplesElement();
    }
  });
  const HeaderExamplesVisitor = ExamplesVisitor$4;
  const ContentVisitor$3 = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "MediaType"])
    },
    init() {
      this.element = new ObjectElement();
      this.element.classes.push("content");
    }
  });
  const BaseContentVisitor = ContentVisitor$3;
  const ContentVisitor$2 = stampit(BaseContentVisitor, {
    init() {
      this.element = new HeaderContentElement();
    }
  });
  const HeaderContentVisitor = ContentVisitor$2;
  const SchemaVisitor$2 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "Schema"]),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new SchemaElement$1();
    }
  });
  const SchemaVisitor$3 = SchemaVisitor$2;
  const {
    allOf: JSONSchemaAllOfVisitor
  } = JSONSchemaDraft4Specification.visitors.document.objects.JSONSchema.fixedFields;
  const AllOfVisitor$2 = stampit(JSONSchemaAllOfVisitor, {
    methods: {
      ArrayElement(arrayElement) {
        const result = JSONSchemaAllOfVisitor.compose.methods.ArrayElement.call(this, arrayElement);
        this.element.filter(isReferenceElement$1).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "schema");
        });
        return result;
      }
    }
  });
  const SchemaAllOfVisitor$1 = AllOfVisitor$2;
  const {
    anyOf: JSONSchemaAnyOfVisitor
  } = JSONSchemaDraft4Specification.visitors.document.objects.JSONSchema.fixedFields;
  const AnyOfVisitor$1 = stampit(JSONSchemaAnyOfVisitor, {
    methods: {
      ArrayElement(arrayElement) {
        const result = JSONSchemaAnyOfVisitor.compose.methods.ArrayElement.call(this, arrayElement);
        this.element.filter(isReferenceElement$1).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "schema");
        });
        return result;
      }
    }
  });
  const SchemaAnyOfVisitor$1 = AnyOfVisitor$1;
  const {
    oneOf: JSONSchemaOneOfVisitor
  } = JSONSchemaDraft4Specification.visitors.document.objects.JSONSchema.fixedFields;
  const OneOfVisitor$1 = stampit(JSONSchemaOneOfVisitor, {
    methods: {
      ArrayElement(arrayElement) {
        const result = JSONSchemaOneOfVisitor.compose.methods.ArrayElement.call(this, arrayElement);
        this.element.filter(isReferenceElement$1).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "schema");
        });
        return result;
      }
    }
  });
  const SchemaOneOfVisitor$1 = OneOfVisitor$1;
  const {
    definitions: JSONSchemaDefinitionsVisitor
  } = JSONSchemaDraft4Specification.visitors.document.objects.JSONSchema.fixedFields;
  const DefinitionsVisitor = stampit(JSONSchemaDefinitionsVisitor, {
    methods: {
      ObjectElement(objectElement) {
        const result = JSONSchemaDefinitionsVisitor.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isReferenceElement$1).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "schema");
        });
        return result;
      }
    }
  });
  const SchemaDefinitionsVisitor = DefinitionsVisitor;
  const {
    dependencies: JSONSchemaDependenciesVisitor
  } = JSONSchemaDraft4Specification.visitors.document.objects.JSONSchema.fixedFields;
  const DependenciesVisitor = stampit(JSONSchemaDependenciesVisitor, {
    methods: {
      ObjectElement(objectElement) {
        const result = JSONSchemaDependenciesVisitor.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isReferenceElement$1).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "schema");
        });
        return result;
      }
    }
  });
  const SchemaDependenciesVisitor = DependenciesVisitor;
  const {
    items: JSONSchemaItemsVisitor
  } = JSONSchemaDraft4Specification.visitors.document.objects.JSONSchema.fixedFields;
  const ItemsVisitor$1 = stampit(JSONSchemaItemsVisitor, {
    methods: {
      ObjectElement(objectElement) {
        const result = JSONSchemaItemsVisitor.compose.methods.ObjectElement.call(this, objectElement);
        if (isReferenceElement$1(this.element)) {
          this.element.setMetaProperty("referenced-element", "schema");
        }
        return result;
      },
      ArrayElement(arrayElement) {
        this.element = cloneDeep(arrayElement);
        return BREAK;
      }
    }
  });
  const SchemaItemsVisitor = ItemsVisitor$1;
  const {
    properties: JSONSchemaPropertiesVisitor
  } = JSONSchemaDraft4Specification.visitors.document.objects.JSONSchema.fixedFields;
  const PropertiesVisitor$1 = stampit(JSONSchemaPropertiesVisitor, {
    methods: {
      ObjectElement(objectElement) {
        const result = JSONSchemaPropertiesVisitor.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isReferenceElement$1).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "schema");
        });
        return result;
      }
    }
  });
  const SchemaPropertiesVisitor$1 = PropertiesVisitor$1;
  const {
    patternProperties: JSONSchemaPatternPropertiesVisitor
  } = JSONSchemaDraft4Specification.visitors.document.objects.JSONSchema.fixedFields;
  const PatternPropertiesVisitor$1 = stampit(JSONSchemaPatternPropertiesVisitor, {
    methods: {
      ObjectElement(objectElement) {
        const result = JSONSchemaPatternPropertiesVisitor.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isReferenceElement$1).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "schema");
        });
        return result;
      }
    }
  });
  const SchemaPatternPropertiesVisitor$1 = PatternPropertiesVisitor$1;
  const {
    type: JSONSchemaTypeVisitor
  } = JSONSchemaDraft4Specification.visitors.document.objects.JSONSchema.fixedFields;
  const ItemsVisitor = stampit(JSONSchemaTypeVisitor, {
    methods: {
      ArrayElement(arrayElement) {
        this.element = cloneDeep(arrayElement);
        return BREAK;
      }
    }
  });
  const SchemaTypeVisitor$1 = ItemsVisitor;
  const NullableVisitor = FallbackVisitor$1;
  const SchemaNullableVisitor = NullableVisitor;
  const WriteOnlyVisitor$1 = FallbackVisitor$1;
  const SchemaWriteOnlyVisitor$1 = WriteOnlyVisitor$1;
  const ExampleVisitor$6 = FallbackVisitor$1;
  const SchemaExampleVisitor$1 = ExampleVisitor$6;
  const DeprecatedVisitor$2 = FallbackVisitor$1;
  const SchemaDeprecatedVisitor$1 = DeprecatedVisitor$2;
  const {
    JSONSchemaOrJSONReferenceVisitor
  } = JSONSchemaDraft4Specification.visitors;
  const SchemaOrReferenceVisitor = stampit(JSONSchemaOrJSONReferenceVisitor, {
    methods: {
      ObjectElement(objectElement) {
        const result = JSONSchemaOrJSONReferenceVisitor.compose.methods.enter.call(this, objectElement);
        if (isReferenceElement$1(this.element)) {
          this.element.setMetaProperty("referenced-element", "schema");
        }
        return result;
      }
    }
  });
  const SchemaOrReferenceVisitor$1 = SchemaOrReferenceVisitor;
  const inheritedFixedFields = Object.fromEntries(Object.entries(JSONSchemaDraft4Specification.visitors.document.objects.JSONSchema.fixedFields).map(([fieldName, visitor2]) => {
    if (visitor2 === JSONSchemaDraft4Specification.visitors.JSONSchemaOrJSONReferenceVisitor) {
      return [fieldName, SchemaOrReferenceVisitor$1];
    }
    return [fieldName, visitor2];
  }));
  const schemaInheritedFixedFields = inheritedFixedFields;
  const DiscriminatorVisitor$2 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "Discriminator"]),
      canSupportSpecificationExtensions: false
    },
    init() {
      this.element = new DiscriminatorElement$1();
    }
  });
  const DiscriminatorVisitor$3 = DiscriminatorVisitor$2;
  const PropertyNameVisitor = FallbackVisitor$1;
  const DiscriminatorPropertyNameVisitor = PropertyNameVisitor;
  const MappingVisitor = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["value"])
    },
    init() {
      this.element = new DiscriminatorMappingElement();
    }
  });
  const DiscriminatorMappingVisitor = MappingVisitor;
  const XmlVisitor$2 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "XML"]),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new XmlElement$1();
    }
  });
  const XmlVisitor$3 = XmlVisitor$2;
  const NameVisitor$1 = FallbackVisitor$1;
  const XmlNameVisitor = NameVisitor$1;
  const NamespaceVisitor = FallbackVisitor$1;
  const XmlNamespaceVisitor = NamespaceVisitor;
  const PrefixVisitor = FallbackVisitor$1;
  const XmlPrefixVisitor = PrefixVisitor;
  const AttributeVisitor = FallbackVisitor$1;
  const XmlAttributeVisitor = AttributeVisitor;
  const WrappedVisitor = FallbackVisitor$1;
  const XmlWrappedVisitor = WrappedVisitor;
  const ExampleVisitor$5 = FallbackVisitor$1;
  const ParameterExampleVisitor = ExampleVisitor$5;
  const ExamplesVisitor$3 = stampit(BaseExamplesVisitor, {
    init() {
      this.element = new ParameterExamplesElement();
    }
  });
  const ParameterExamplesVisitor = ExamplesVisitor$3;
  const ExamplesVisitor$2 = stampit(BaseContentVisitor, {
    init() {
      this.element = new ParameterContentElement();
    }
  });
  const ParameterContentVisitor = ExamplesVisitor$2;
  const SchemasVisitor$1 = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: (element) => {
        return isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Schema"];
      }
    },
    init() {
      this.element = new ComponentsSchemasElement();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = MapVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isReferenceElement$1).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "schema");
        });
        return result;
      }
    }
  });
  const ComponentsSchemasVisitor$1 = SchemasVisitor$1;
  const ResponsesVisitor$4 = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: (element) => {
        return isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Response"];
      }
    },
    init() {
      this.element = new ComponentsResponsesElement();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = MapVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isReferenceElement$1).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "response");
        });
        this.element.filter(isResponseElement$1).forEach((value2, key) => {
          value2.setMetaProperty("http-status-code", toValue(key));
        });
        return result;
      }
    }
  });
  const ComponentsResponsesVisitor = ResponsesVisitor$4;
  const ParametersVisitor$4 = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: (element) => {
        return isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Parameter"];
      }
    },
    init() {
      this.element = new ComponentsParametersElement();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = MapVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isReferenceElement$1).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "parameter");
        });
        return result;
      }
    }
  });
  const ComponentsParametersVisitor = ParametersVisitor$4;
  const ExamplesVisitor$1 = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: (element) => {
        return isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Example"];
      }
    },
    init() {
      this.element = new ComponentsExamplesElement();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = MapVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isReferenceElement$1).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "example");
        });
        return result;
      }
    }
  });
  const ComponentsExamplesVisitor = ExamplesVisitor$1;
  const RequestBodiesVisitor = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: (element) => {
        return isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "RequestBody"];
      }
    },
    init() {
      this.element = new ComponentsRequestBodiesElement();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = MapVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isReferenceElement$1).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "requestBody");
        });
        return result;
      }
    }
  });
  const ComponentsRequestBodiesVisitor = RequestBodiesVisitor;
  const HeadersVisitor$3 = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: (element) => {
        return isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Header"];
      }
    },
    init() {
      this.element = new ComponentsHeadersElement();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = MapVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isReferenceElement$1).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "header");
        });
        this.element.filter(isHeaderElement$1).forEach((value2, key) => {
          value2.setMetaProperty("header-name", toValue(key));
        });
        return result;
      }
    }
  });
  const ComponentsHeadersVisitor = HeadersVisitor$3;
  const ParametersVisitor$3 = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: (element) => {
        return isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "SecurityScheme"];
      }
    },
    init() {
      this.element = new ComponentsSecuritySchemesElement();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = MapVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isReferenceElement$1).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "securityScheme");
        });
        return result;
      }
    }
  });
  const ComponentsSecuritySchemesVisitor = ParametersVisitor$3;
  const LinksVisitor = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: (element) => {
        return isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Link"];
      }
    },
    init() {
      this.element = new ComponentsLinksElement();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = MapVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isReferenceElement$1).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "link");
        });
        return result;
      }
    }
  });
  const ComponentsLinksVisitor = LinksVisitor;
  const CallbacksElement = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: (element) => {
        return isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Callback"];
      }
    },
    init() {
      this.element = new ComponentsCallbacksElement();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = MapVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isReferenceElement$1).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "callback");
        });
        return result;
      }
    }
  });
  const ComponentsCallbacksVisitor = CallbacksElement;
  const ExampleVisitor$3 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "Example"]),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new ExampleElement$1();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = FixedFieldsVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        if (isStringElement(this.element.externalValue)) {
          this.element.classes.push("reference-element");
        }
        return result;
      }
    }
  });
  const ExampleVisitor$4 = ExampleVisitor$3;
  const SummaryVisitor$4 = FallbackVisitor$1;
  const ExampleSummaryVisitor = SummaryVisitor$4;
  const DescriptionVisitor$8 = FallbackVisitor$1;
  const ExampleDescriptionVisitor = DescriptionVisitor$8;
  const ValueVisitor = FallbackVisitor$1;
  const ExampleValueVisitor = ValueVisitor;
  const ExternalValueVisitor = stampit(FallbackVisitor$1, {
    methods: {
      StringElement(stringElement) {
        this.element = cloneDeep(stringElement);
        this.element.classes.push("reference-value");
        return BREAK;
      }
    }
  });
  const ExampleExternalValueVisitor = ExternalValueVisitor;
  const ExternalDocumentationVisitor$2 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "ExternalDocumentation"]),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new ExternalDocumentationElement$1();
    }
  });
  const ExternalDocumentationVisitor$3 = ExternalDocumentationVisitor$2;
  const DescriptionVisitor$7 = FallbackVisitor$1;
  const ExternalDocumentationDescriptionVisitor = DescriptionVisitor$7;
  const UrlVisitor = FallbackVisitor$1;
  const ExternalDocumentationUrlVisitor = UrlVisitor;
  const EncodingVisitor$2 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "Encoding"]),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new EncodingElement$1();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = FixedFieldsVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        if (isObjectElement(this.element.headers)) {
          this.element.headers.filter(isHeaderElement$1).forEach((headerElement, key) => {
            headerElement.setMetaProperty("header-name", toValue(key));
          });
        }
        return result;
      }
    }
  });
  const EncodingVisitor$3 = EncodingVisitor$2;
  const ContentTypeVisitor = FallbackVisitor$1;
  const EncodingContentTypeVisitor = ContentTypeVisitor;
  const HeadersVisitor$2 = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: (element) => isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Header"]
    },
    init() {
      this.element = new EncodingHeadersElement();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = MapVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isReferenceElement$1).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "header");
        });
        this.element.forEach((value2, key) => {
          if (!isHeaderElement$1(value2))
            return;
          const headerName = toValue(key);
          value2.setMetaProperty("headerName", headerName);
        });
        return result;
      }
    }
  });
  const EncodingHeadersVisitor = HeadersVisitor$2;
  const StyleVisitor = FallbackVisitor$1;
  const EncodingStyleVisitor = StyleVisitor;
  const ExplodeVisitor = FallbackVisitor$1;
  const EncodingExplodeVisitor = ExplodeVisitor;
  const AllowReservedVisitor = FallbackVisitor$1;
  const EncodingAllowReserved = AllowReservedVisitor;
  const PathsVisitor$2 = stampit(PatternedFieldsVisitor, FallbackVisitor$1, {
    props: {
      fieldPatternPredicate: test$2(/^\/(?<path>.*)$/),
      specPath: always$1(["document", "objects", "PathItem"]),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new PathsElement$1();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = PatternedFieldsVisitor.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isPathItemElement$1).forEach((pathItemElement, key) => {
          pathItemElement.setMetaProperty("path", cloneDeep(key));
        });
        return result;
      }
    }
  });
  const PathsVisitor$3 = PathsVisitor$2;
  const RequestBodyVisitor$3 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "RequestBody"])
    },
    init() {
      this.element = new RequestBodyElement$1();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = FixedFieldsVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        if (isObjectElement(this.element.contentProp)) {
          this.element.contentProp.filter(isMediaTypeElement$1).forEach((mediaTypeElement, key) => {
            mediaTypeElement.setMetaProperty("media-type", toValue(key));
          });
        }
        return result;
      }
    }
  });
  const RequestBodyVisitor$4 = RequestBodyVisitor$3;
  const DescriptionVisitor$6 = FallbackVisitor$1;
  const RequestBodyDescriptionVisitor = DescriptionVisitor$6;
  const ContentVisitor$1 = stampit(BaseContentVisitor, {
    init() {
      this.element = new RequestBodyContentElement();
    }
  });
  const RequestBodyContentVisitor = ContentVisitor$1;
  const RequiredVisitor$1 = FallbackVisitor$1;
  const RequestBodyRequiredVisitor = RequiredVisitor$1;
  const CallbackVisitor$2 = stampit(PatternedFieldsVisitor, FallbackVisitor$1, {
    props: {
      fieldPatternPredicate: test$2(/{(?<expression>.*)}/),
      specPath: always$1(["document", "objects", "PathItem"]),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new CallbackElement$1();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = MapVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isPathItemElement$1).forEach((pathItemElement, key) => {
          pathItemElement.setMetaProperty("runtime-expression", toValue(key));
        });
        return result;
      }
    }
  });
  const CallbackVisitor$3 = CallbackVisitor$2;
  const ResponseVisitor$2 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "Response"])
    },
    init() {
      this.element = new ResponseElement$1();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = FixedFieldsVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        if (isObjectElement(this.element.contentProp)) {
          this.element.contentProp.filter(isMediaTypeElement$1).forEach((mediaTypeElement, key) => {
            mediaTypeElement.setMetaProperty("media-type", toValue(key));
          });
        }
        if (isObjectElement(this.element.headers)) {
          this.element.headers.filter(isHeaderElement$1).forEach((headerElement, key) => {
            headerElement.setMetaProperty("header-name", toValue(key));
          });
        }
        return result;
      }
    }
  });
  const ResponseVisitor$3 = ResponseVisitor$2;
  const DescriptionVisitor$5 = FallbackVisitor$1;
  const ResponseDescriptionVisitor = DescriptionVisitor$5;
  const HeadersVisitor$1 = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: (element) => {
        return isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Header"];
      }
    },
    init() {
      this.element = new ResponseHeadersElement();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = MapVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isReferenceElement$1).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "header");
        });
        this.element.forEach((value2, key) => {
          if (!isHeaderElement$1(value2))
            return;
          const headerName = toValue(key);
          value2.setMetaProperty("header-name", headerName);
        });
        return result;
      }
    }
  });
  const ResponseHeadersVisitor = HeadersVisitor$1;
  const ContentVisitor = stampit(BaseContentVisitor, {
    init() {
      this.element = new ResponseContentElement();
    }
  });
  const ResponseContentVisitor = ContentVisitor;
  const HeadersVisitor = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: (element) => {
        return isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Link"];
      }
    },
    init() {
      this.element = new ResponseLinksElement();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = MapVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isReferenceElement$1).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "link");
        });
        return result;
      }
    }
  });
  const ResponseLinksVisitor = HeadersVisitor;
  const MixedFieldsVisitor = stampit(FixedFieldsVisitor$1, PatternedFieldsVisitor, {
    props: {
      specPathFixedFields: noop$3,
      specPathPatternedFields: noop$3
    },
    methods: {
      ObjectElement(objectElement) {
        const {
          specPath,
          ignoredFields
        } = this;
        try {
          this.specPath = this.specPathFixedFields;
          const fixedFields = this.retrieveFixedFields(this.specPath(objectElement));
          this.ignoredFields = [...ignoredFields, ...difference$1(objectElement.keys(), fixedFields)];
          FixedFieldsVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
          this.specPath = this.specPathPatternedFields;
          this.ignoredFields = fixedFields;
          PatternedFieldsVisitor.compose.methods.ObjectElement.call(this, objectElement);
        } catch (e) {
          this.specPath = specPath;
          throw e;
        }
        return BREAK;
      }
    }
  });
  const MixedFieldsVisitor$1 = MixedFieldsVisitor;
  const ResponsesVisitor$2 = stampit(MixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPathFixedFields: always$1(["document", "objects", "Responses"]),
      specPathPatternedFields: (element) => {
        return isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Response"];
      },
      fieldPatternPredicate: test$2(new RegExp(`^(1XX|2XX|3XX|4XX|5XX|${range$2(100, 600).join("|")})$`)),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new ResponsesElement$1();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = MixedFieldsVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isReferenceElement$1).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "response");
        });
        this.element.filter(isResponseElement$1).forEach((value2, key) => {
          const httpStatusCode = cloneDeep(key);
          if (!this.fieldPatternPredicate(toValue(httpStatusCode)))
            return;
          value2.setMetaProperty("http-status-code", httpStatusCode);
        });
        return result;
      }
    }
  });
  const ResponsesVisitor$3 = ResponsesVisitor$2;
  const DefaultVisitor$1 = stampit(AlternatingVisitor$1, FallbackVisitor$1, {
    props: {
      alternator: [{
        predicate: isReferenceLikeElement,
        specPath: ["document", "objects", "Reference"]
      }, {
        predicate: stubTrue,
        specPath: ["document", "objects", "Response"]
      }]
    },
    methods: {
      ObjectElement(objectElement) {
        const result = AlternatingVisitor$1.compose.methods.enter.call(this, objectElement);
        if (isReferenceElement$1(this.element)) {
          this.element.setMetaProperty("referenced-element", "response");
        } else if (isResponseElement$1(this.element)) {
          this.element.setMetaProperty("http-status-code", "default");
        }
        return result;
      }
    }
  });
  const ResponsesDefaultVisitor = DefaultVisitor$1;
  const OperationVisitor$2 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "Operation"])
    },
    init() {
      this.element = new OperationElement$1();
    }
  });
  const OperationVisitor$3 = OperationVisitor$2;
  const TagsVisitor$2 = stampit(FallbackVisitor$1, {
    init() {
      this.element = new OperationTagsElement();
    },
    methods: {
      ArrayElement(arrayElement) {
        this.element = this.element.concat(cloneDeep(arrayElement));
        return BREAK;
      }
    }
  });
  const OperationTagsVisitor = TagsVisitor$2;
  const SummaryVisitor$3 = FallbackVisitor$1;
  const OperationSummaryVisitor = SummaryVisitor$3;
  const DescriptionVisitor$4 = FallbackVisitor$1;
  const OperationDescriptionVisitor = DescriptionVisitor$4;
  const OperationIdVisitor = FallbackVisitor$1;
  const OperationOperationIdVisitor = OperationIdVisitor;
  const ParametersVisitor$2 = stampit(SpecificationVisitor$1, FallbackVisitor$1, {
    init() {
      this.element = new ArrayElement();
      this.element.classes.push("parameters");
    },
    methods: {
      ArrayElement(arrayElement) {
        arrayElement.forEach((item) => {
          const specPath = isReferenceLikeElement(item) ? ["document", "objects", "Reference"] : ["document", "objects", "Parameter"];
          const element = this.toRefractedElement(specPath, item);
          if (isReferenceElement$1(element)) {
            element.setMetaProperty("referenced-element", "parameter");
          }
          this.element.push(element);
        });
        this.copyMetaAndAttributes(arrayElement, this.element);
        return BREAK;
      }
    }
  });
  const BaseParametersVisitor = ParametersVisitor$2;
  const ParametersVisitor$1 = stampit(BaseParametersVisitor, {
    init() {
      this.element = new OperationParametersElement();
    }
  });
  const OperationParametersVisitor = ParametersVisitor$1;
  const RequestBodyVisitor$2 = stampit(AlternatingVisitor$1, {
    props: {
      alternator: [{
        predicate: isReferenceLikeElement,
        specPath: ["document", "objects", "Reference"]
      }, {
        predicate: stubTrue,
        specPath: ["document", "objects", "RequestBody"]
      }]
    },
    methods: {
      ObjectElement(objectElement) {
        const result = AlternatingVisitor$1.compose.methods.enter.call(this, objectElement);
        if (isReferenceElement$1(this.element)) {
          this.element.setMetaProperty("referenced-element", "requestBody");
        }
        return result;
      }
    }
  });
  const OperationRequestBodyVisitor = RequestBodyVisitor$2;
  const CallbacksVisitor = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: (element) => isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Callback"]
    },
    init() {
      this.element = new OperationCallbacksElement();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = MapVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isReferenceElement$1).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "callback");
        });
        return result;
      }
    }
  });
  const OperationCallbacksVisitor = CallbacksVisitor;
  const DeprecatedVisitor$1 = FallbackVisitor$1;
  const OperationDeprecatedVisitor = DeprecatedVisitor$1;
  const SecurityVisitor = stampit(SpecificationVisitor$1, FallbackVisitor$1, {
    init() {
      this.element = new OperationSecurityElement();
    },
    methods: {
      ArrayElement(arrayElement) {
        arrayElement.forEach((item) => {
          const specPath = isObjectElement(item) ? ["document", "objects", "SecurityRequirement"] : ["value"];
          const element = this.toRefractedElement(specPath, item);
          this.element.push(element);
        });
        this.copyMetaAndAttributes(arrayElement, this.element);
        return BREAK;
      }
    }
  });
  const OperationSecurityVisitor = SecurityVisitor;
  const ServersVisitor$1 = stampit(ServersVisitor$3, {
    init() {
      this.element = new OperationServersElement();
    }
  });
  const OperationServersVisitor = ServersVisitor$1;
  const PathItemVisitor$2 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "PathItem"])
    },
    init() {
      this.element = new PathItemElement$1();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = FixedFieldsVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isOperationElement$1).forEach((operationElement, httpMethodElementCI) => {
          const httpMethodElementCS = cloneDeep(httpMethodElementCI);
          httpMethodElementCS.content = toValue(httpMethodElementCS).toUpperCase();
          operationElement.setMetaProperty("http-method", httpMethodElementCS);
        });
        if (isStringElement(this.element.$ref)) {
          this.element.classes.push("reference-element");
        }
        return result;
      }
    }
  });
  const PathItemVisitor$3 = PathItemVisitor$2;
  const $RefVisitor = stampit(FallbackVisitor$1, {
    methods: {
      StringElement(stringElement) {
        this.element = cloneDeep(stringElement);
        this.element.classes.push("reference-value");
        return BREAK;
      }
    }
  });
  const PathItem$RefVisitor = $RefVisitor;
  const SummaryVisitor$2 = FallbackVisitor$1;
  const PathItemSummaryVisitor = SummaryVisitor$2;
  const DescriptionVisitor$3 = FallbackVisitor$1;
  const PathItemDescriptionVisitor = DescriptionVisitor$3;
  const ServersVisitor = stampit(ServersVisitor$3, {
    init() {
      this.element = new PathItemServersElement();
    }
  });
  const PathItemServersVisitor = ServersVisitor;
  const ParametersVisitor = stampit(BaseParametersVisitor, {
    init() {
      this.element = new PathItemParametersElement();
    }
  });
  const PathItemParametersVisitor = ParametersVisitor;
  const SecuritySchemeVisitor$2 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "SecurityScheme"]),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new SecuritySchemeElement$1();
    }
  });
  const SecuritySchemeVisitor$3 = SecuritySchemeVisitor$2;
  const TypeVisitor$1 = FallbackVisitor$1;
  const SecuritySchemeTypeVisitor = TypeVisitor$1;
  const DescriptionVisitor$2 = FallbackVisitor$1;
  const SecuritySchemeDescriptionVisitor = DescriptionVisitor$2;
  const NameVisitor = FallbackVisitor$1;
  const SecuritySchemeNameVisitor = NameVisitor;
  const InVisitor = FallbackVisitor$1;
  const SecuritySchemeInVisitor = InVisitor;
  const SchemeVisitor = FallbackVisitor$1;
  const SecuritySchemeSchemeVisitor = SchemeVisitor;
  const BearerFormatVisitor = FallbackVisitor$1;
  const SecuritySchemeBearerFormatVisitor = BearerFormatVisitor;
  const OpenIdConnectUrlVisitor = FallbackVisitor$1;
  const SecuritySchemeOpenIdConnectUrlVisitor = OpenIdConnectUrlVisitor;
  const OAuthFlowsVisitor$2 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "OAuthFlows"]),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new OAuthFlowsElement$1();
    }
  });
  const OAuthFlowsVisitor$3 = OAuthFlowsVisitor$2;
  const OAuthFlowVisitor$2 = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "OAuthFlow"]),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new OAuthFlowElement$1();
    }
  });
  const OAuthFlowVisitor$3 = OAuthFlowVisitor$2;
  const AuthorizationUrlVisitor = FallbackVisitor$1;
  const OAuthFlowAuthorizationUrlVisitor = AuthorizationUrlVisitor;
  const TokenUrlVisitor = FallbackVisitor$1;
  const OAuthFlowTokenUrlVisitor = TokenUrlVisitor;
  const RefreshUrlVisitor = FallbackVisitor$1;
  const OAuthFlowRefreshUrlVisitor = RefreshUrlVisitor;
  const ScopesVisitor = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["value"])
    },
    init() {
      this.element = new OAuthFlowScopesElement();
    }
  });
  const OAuthFlowScopesVisitor = ScopesVisitor;
  const TagsVisitor = stampit(SpecificationVisitor$1, FallbackVisitor$1, {
    init() {
      this.element = new TagsElement();
    },
    methods: {
      ArrayElement(arrayElement) {
        arrayElement.forEach((item) => {
          const specPath = isTagLikeElement(item) ? ["document", "objects", "Tag"] : ["value"];
          const element = this.toRefractedElement(specPath, item);
          this.element.push(element);
        });
        this.copyMetaAndAttributes(arrayElement, this.element);
        return BREAK;
      }
    }
  });
  const TagsVisitor$1 = TagsVisitor;
  const ReferenceSpecification = {
    $visitor: ReferenceVisitor$3,
    fixedFields: {
      $ref: Reference$RefVisitor
    }
  };
  const SchemaSpecification = {
    $visitor: SchemaVisitor$3,
    fixedFields: {
      ...schemaInheritedFixedFields,
      // validation vocabulary
      // validation keywords for any instance type
      allOf: SchemaAllOfVisitor$1,
      anyOf: SchemaAnyOfVisitor$1,
      oneOf: SchemaOneOfVisitor$1,
      definitions: SchemaDefinitionsVisitor,
      // validation keywords for arrays
      items: SchemaItemsVisitor,
      // Validation keywords for objects
      dependencies: SchemaDependenciesVisitor,
      properties: SchemaPropertiesVisitor$1,
      patternProperties: SchemaPatternPropertiesVisitor$1,
      // validation keywords for any instance type
      type: SchemaTypeVisitor$1,
      // OpenAPI vocabulary
      nullable: SchemaNullableVisitor,
      discriminator: {
        $ref: "#/visitors/document/objects/Discriminator"
      },
      writeOnly: SchemaWriteOnlyVisitor$1,
      xml: {
        $ref: "#/visitors/document/objects/XML"
      },
      externalDocs: {
        $ref: "#/visitors/document/objects/ExternalDocumentation"
      },
      example: SchemaExampleVisitor$1,
      deprecated: SchemaDeprecatedVisitor$1
    }
  };
  const specification$2 = {
    visitors: {
      value: FallbackVisitor$1,
      document: {
        objects: {
          OpenApi: {
            $visitor: OpenApi3_0Visitor$1,
            fixedFields: {
              openapi: OpenapiVisitor$1,
              info: {
                $ref: "#/visitors/document/objects/Info"
              },
              servers: ServersVisitor$3,
              paths: {
                $ref: "#/visitors/document/objects/Paths"
              },
              components: {
                $ref: "#/visitors/document/objects/Components"
              },
              security: SecurityVisitor$2,
              tags: TagsVisitor$1,
              externalDocs: {
                $ref: "#/visitors/document/objects/ExternalDocumentation"
              }
            }
          },
          Info: {
            $visitor: InfoVisitor$3,
            fixedFields: {
              title: InfoTitleVisitor,
              description: InfoDescriptionVisitor,
              termsOfService: InfoTermsOfServiceVisitor,
              contact: {
                $ref: "#/visitors/document/objects/Contact"
              },
              license: {
                $ref: "#/visitors/document/objects/License"
              },
              version: InfoVersionVisitor
            }
          },
          Contact: {
            $visitor: ContactVisitor$3,
            fixedFields: {
              name: ContactNameVisitor,
              url: ContactUrlVisitor,
              email: ContactEmailVisitor
            }
          },
          License: {
            $visitor: LicenseVisitor$3,
            fixedFields: {
              name: LicenseNameVisitor,
              url: LicenseUrlVisitor
            }
          },
          Server: {
            $visitor: ServerVisitor$3,
            fixedFields: {
              url: ServerUrlVisitor,
              description: ServerDescriptionVisitor,
              variables: ServerVariablesVisitor
            }
          },
          ServerVariable: {
            $visitor: ServerVariableVisitor$3,
            fixedFields: {
              enum: ServerVariableEnumVisitor,
              default: ServerVariableDefaultVisitor,
              description: ServerVariableDescriptionVisitor
            }
          },
          Components: {
            $visitor: ComponentsVisitor$3,
            fixedFields: {
              schemas: ComponentsSchemasVisitor$1,
              responses: ComponentsResponsesVisitor,
              parameters: ComponentsParametersVisitor,
              examples: ComponentsExamplesVisitor,
              requestBodies: ComponentsRequestBodiesVisitor,
              headers: ComponentsHeadersVisitor,
              securitySchemes: ComponentsSecuritySchemesVisitor,
              links: ComponentsLinksVisitor,
              callbacks: ComponentsCallbacksVisitor
            }
          },
          Paths: {
            $visitor: PathsVisitor$3
          },
          PathItem: {
            $visitor: PathItemVisitor$3,
            fixedFields: {
              $ref: PathItem$RefVisitor,
              summary: PathItemSummaryVisitor,
              description: PathItemDescriptionVisitor,
              get: {
                $ref: "#/visitors/document/objects/Operation"
              },
              put: {
                $ref: "#/visitors/document/objects/Operation"
              },
              post: {
                $ref: "#/visitors/document/objects/Operation"
              },
              delete: {
                $ref: "#/visitors/document/objects/Operation"
              },
              options: {
                $ref: "#/visitors/document/objects/Operation"
              },
              head: {
                $ref: "#/visitors/document/objects/Operation"
              },
              patch: {
                $ref: "#/visitors/document/objects/Operation"
              },
              trace: {
                $ref: "#/visitors/document/objects/Operation"
              },
              servers: PathItemServersVisitor,
              parameters: PathItemParametersVisitor
            }
          },
          Operation: {
            $visitor: OperationVisitor$3,
            fixedFields: {
              tags: OperationTagsVisitor,
              summary: OperationSummaryVisitor,
              description: OperationDescriptionVisitor,
              externalDocs: {
                $ref: "#/visitors/document/objects/ExternalDocumentation"
              },
              operationId: OperationOperationIdVisitor,
              parameters: OperationParametersVisitor,
              requestBody: OperationRequestBodyVisitor,
              responses: {
                $ref: "#/visitors/document/objects/Responses"
              },
              callbacks: OperationCallbacksVisitor,
              deprecated: OperationDeprecatedVisitor,
              security: OperationSecurityVisitor,
              servers: OperationServersVisitor
            }
          },
          ExternalDocumentation: {
            $visitor: ExternalDocumentationVisitor$3,
            fixedFields: {
              description: ExternalDocumentationDescriptionVisitor,
              url: ExternalDocumentationUrlVisitor
            }
          },
          Parameter: {
            $visitor: ParameterVisitor$3,
            fixedFields: {
              name: ParameterNameVisitor,
              in: ParameterInVisitor,
              description: ParameterDescriptionVisitor,
              required: ParameterRequiredVisitor,
              deprecated: ParameterDeprecatedVisitor,
              allowEmptyValue: ParameterAllowEmptyValueVisitor,
              style: ParameterStyleVisitor,
              explode: ParameterExplodeVisitor,
              allowReserved: ParameterAllowReservedVisitor,
              schema: ParameterSchemaVisitor,
              example: ParameterExampleVisitor,
              examples: ParameterExamplesVisitor,
              content: ParameterContentVisitor
            }
          },
          RequestBody: {
            $visitor: RequestBodyVisitor$4,
            fixedFields: {
              description: RequestBodyDescriptionVisitor,
              content: RequestBodyContentVisitor,
              required: RequestBodyRequiredVisitor
            }
          },
          MediaType: {
            $visitor: MediaTypeVisitor$3,
            fixedFields: {
              schema: MediaTypeSchemaVisitor,
              example: MediaTypeExampleVisitor,
              examples: MediaTypeExamplesVisitor,
              encoding: MediaTypeEncodingVisitor
            }
          },
          Encoding: {
            $visitor: EncodingVisitor$3,
            fixedFields: {
              contentType: EncodingContentTypeVisitor,
              headers: EncodingHeadersVisitor,
              style: EncodingStyleVisitor,
              explode: EncodingExplodeVisitor,
              allowReserved: EncodingAllowReserved
            }
          },
          Responses: {
            $visitor: ResponsesVisitor$3,
            fixedFields: {
              default: ResponsesDefaultVisitor
            }
          },
          Response: {
            $visitor: ResponseVisitor$3,
            fixedFields: {
              description: ResponseDescriptionVisitor,
              headers: ResponseHeadersVisitor,
              content: ResponseContentVisitor,
              links: ResponseLinksVisitor
            }
          },
          Callback: {
            $visitor: CallbackVisitor$3
          },
          Example: {
            $visitor: ExampleVisitor$4,
            fixedFields: {
              summary: ExampleSummaryVisitor,
              description: ExampleDescriptionVisitor,
              value: ExampleValueVisitor,
              externalValue: ExampleExternalValueVisitor
            }
          },
          Link: {
            $visitor: LinkVisitor$3,
            fixedFields: {
              operationRef: LinkOperationRefVisitor,
              operationId: LinkOperationIdVisitor,
              parameters: LinkParametersVisitor,
              requestBody: LinkRequestBodyVisitor,
              description: LinkDescriptionVisitor,
              server: {
                $ref: "#/visitors/document/objects/Server"
              }
            }
          },
          Header: {
            $visitor: HeaderVisitor$3,
            fixedFields: {
              description: HeaderDescriptionVisitor,
              required: HeaderRequiredVisitor,
              deprecated: HeaderDeprecatedVisitor,
              allowEmptyValue: HeaderAllowEmptyValueVisitor,
              style: HeaderStyleVisitor,
              explode: HeaderExplodeVisitor,
              allowReserved: HeaderAllowReservedVisitor,
              schema: HeaderSchemaVisitor,
              example: HeaderExampleVisitor,
              examples: HeaderExamplesVisitor,
              content: HeaderContentVisitor
            }
          },
          Tag: {
            $visitor: TagVisitor$3,
            fixedFields: {
              name: TagNameVisitor,
              description: TagDescriptionVisitor,
              externalDocs: {
                $ref: "#/visitors/document/objects/ExternalDocumentation"
              }
            }
          },
          JSONReference: ReferenceSpecification,
          Reference: ReferenceSpecification,
          JSONSchema: SchemaSpecification,
          Schema: SchemaSpecification,
          LinkDescription: JSONSchemaDraft4Specification.visitors.document.objects.LinkDescription,
          Media: JSONSchemaDraft4Specification.visitors.document.objects.Media,
          Discriminator: {
            $visitor: DiscriminatorVisitor$3,
            fixedFields: {
              propertyName: DiscriminatorPropertyNameVisitor,
              mapping: DiscriminatorMappingVisitor
            }
          },
          XML: {
            $visitor: XmlVisitor$3,
            fixedFields: {
              name: XmlNameVisitor,
              namespace: XmlNamespaceVisitor,
              prefix: XmlPrefixVisitor,
              attribute: XmlAttributeVisitor,
              wrapped: XmlWrappedVisitor
            }
          },
          SecurityScheme: {
            $visitor: SecuritySchemeVisitor$3,
            fixedFields: {
              type: SecuritySchemeTypeVisitor,
              description: SecuritySchemeDescriptionVisitor,
              name: SecuritySchemeNameVisitor,
              in: SecuritySchemeInVisitor,
              scheme: SecuritySchemeSchemeVisitor,
              bearerFormat: SecuritySchemeBearerFormatVisitor,
              flows: {
                $ref: "#/visitors/document/objects/OAuthFlows"
              },
              openIdConnectUrl: SecuritySchemeOpenIdConnectUrlVisitor
            }
          },
          OAuthFlows: {
            $visitor: OAuthFlowsVisitor$3,
            fixedFields: {
              implicit: {
                $ref: "#/visitors/document/objects/OAuthFlow"
              },
              password: {
                $ref: "#/visitors/document/objects/OAuthFlow"
              },
              clientCredentials: {
                $ref: "#/visitors/document/objects/OAuthFlow"
              },
              authorizationCode: {
                $ref: "#/visitors/document/objects/OAuthFlow"
              }
            }
          },
          OAuthFlow: {
            $visitor: OAuthFlowVisitor$3,
            fixedFields: {
              authorizationUrl: OAuthFlowAuthorizationUrlVisitor,
              tokenUrl: OAuthFlowTokenUrlVisitor,
              refreshUrl: OAuthFlowRefreshUrlVisitor,
              scopes: OAuthFlowScopesVisitor
            }
          },
          SecurityRequirement: {
            $visitor: SecurityRequirementVisitor$3
          }
        },
        extension: {
          $visitor: SpecificationExtensionVisitor$1
        }
      }
    }
  };
  const OpenApi3_1Specification = specification$2;
  const createToolbox$2 = () => {
    const namespace2 = createNamespace(openApi3_0Namespace);
    const predicates2 = {
      ...refractorPredicates,
      ...openApi3_0Predicates,
      isStringElement
    };
    return {
      predicates: predicates2,
      namespace: namespace2
    };
  };
  const createToolbox$3 = createToolbox$2;
  const refract$1 = (value2, {
    specPath = ["visitors", "document", "objects", "OpenApi", "$visitor"],
    plugins: plugins2 = []
  } = {}) => {
    const element = refract$4(value2);
    const resolvedSpec = dereference(OpenApi3_1Specification);
    const rootVisitor = invokeArgs$1(specPath, [], resolvedSpec);
    visit$1(element, rootVisitor, {
      state: {
        specObj: resolvedSpec
      }
    });
    return dispatchPlugins(rootVisitor.element, plugins2, {
      toolboxCreator: createToolbox$3,
      visitorOptions: {
        keyMap: keyMap$1,
        nodeTypeGetter: getNodeType$1
      }
    });
  };
  const createRefractor$1 = (specPath) => (value2, options = {}) => refract$1(value2, {
    specPath,
    ...options
  });
  CallbackElement$1.refract = createRefractor$1(["visitors", "document", "objects", "Callback", "$visitor"]);
  ComponentsElement$1.refract = createRefractor$1(["visitors", "document", "objects", "Components", "$visitor"]);
  ContactElement$1.refract = createRefractor$1(["visitors", "document", "objects", "Contact", "$visitor"]);
  ExampleElement$1.refract = createRefractor$1(["visitors", "document", "objects", "Example", "$visitor"]);
  DiscriminatorElement$1.refract = createRefractor$1(["visitors", "document", "objects", "Discriminator", "$visitor"]);
  EncodingElement$1.refract = createRefractor$1(["visitors", "document", "objects", "Encoding", "$visitor"]);
  ExternalDocumentationElement$1.refract = createRefractor$1(["visitors", "document", "objects", "ExternalDocumentation", "$visitor"]);
  HeaderElement$1.refract = createRefractor$1(["visitors", "document", "objects", "Header", "$visitor"]);
  InfoElement$1.refract = createRefractor$1(["visitors", "document", "objects", "Info", "$visitor"]);
  LicenseElement$1.refract = createRefractor$1(["visitors", "document", "objects", "License", "$visitor"]);
  LinkElement$1.refract = createRefractor$1(["visitors", "document", "objects", "Link", "$visitor"]);
  MediaTypeElement$1.refract = createRefractor$1(["visitors", "document", "objects", "MediaType", "$visitor"]);
  OAuthFlowElement$1.refract = createRefractor$1(["visitors", "document", "objects", "OAuthFlow", "$visitor"]);
  OAuthFlowsElement$1.refract = createRefractor$1(["visitors", "document", "objects", "OAuthFlows", "$visitor"]);
  OpenapiElement$1.refract = createRefractor$1(["visitors", "document", "objects", "OpenApi", "fixedFields", "openapi"]);
  OpenApi3_0Element.refract = createRefractor$1(["visitors", "document", "objects", "OpenApi", "$visitor"]);
  OperationElement$1.refract = createRefractor$1(["visitors", "document", "objects", "Operation", "$visitor"]);
  ParameterElement$1.refract = createRefractor$1(["visitors", "document", "objects", "Parameter", "$visitor"]);
  PathItemElement$1.refract = createRefractor$1(["visitors", "document", "objects", "PathItem", "$visitor"]);
  PathsElement$1.refract = createRefractor$1(["visitors", "document", "objects", "Paths", "$visitor"]);
  ReferenceElement$1.refract = createRefractor$1(["visitors", "document", "objects", "Reference", "$visitor"]);
  RequestBodyElement$1.refract = createRefractor$1(["visitors", "document", "objects", "RequestBody", "$visitor"]);
  ResponseElement$1.refract = createRefractor$1(["visitors", "document", "objects", "Response", "$visitor"]);
  ResponsesElement$1.refract = createRefractor$1(["visitors", "document", "objects", "Responses", "$visitor"]);
  SchemaElement$1.refract = createRefractor$1(["visitors", "document", "objects", "Schema", "$visitor"]);
  SecurityRequirementElement$1.refract = createRefractor$1(["visitors", "document", "objects", "SecurityRequirement", "$visitor"]);
  SecuritySchemeElement$1.refract = createRefractor$1(["visitors", "document", "objects", "SecurityScheme", "$visitor"]);
  ServerElement$1.refract = createRefractor$1(["visitors", "document", "objects", "Server", "$visitor"]);
  ServerVariableElement$1.refract = createRefractor$1(["visitors", "document", "objects", "ServerVariable", "$visitor"]);
  TagElement$1.refract = createRefractor$1(["visitors", "document", "objects", "Tag", "$visitor"]);
  XmlElement$1.refract = createRefractor$1(["visitors", "document", "objects", "XML", "$visitor"]);
  class Callback extends CallbackElement$1 {
  }
  const CallbackElement = Callback;
  class Components extends ComponentsElement$1 {
    get pathItems() {
      return this.get("pathItems");
    }
    set pathItems(pathItems) {
      this.set("pathItems", pathItems);
    }
  }
  const ComponentsElement = Components;
  class Contact extends ContactElement$1 {
  }
  const ContactElement = Contact;
  class Discriminator extends DiscriminatorElement$1 {
  }
  const DiscriminatorElement = Discriminator;
  class Encoding extends EncodingElement$1 {
  }
  const EncodingElement = Encoding;
  class Example extends ExampleElement$1 {
  }
  const ExampleElement = Example;
  class ExternalDocumentation extends ExternalDocumentationElement$1 {
  }
  const ExternalDocumentationElement = ExternalDocumentation;
  class Header extends HeaderElement$1 {
    get schema() {
      return this.get("schema");
    }
    set schema(schema2) {
      this.set("schema", schema2);
    }
  }
  const HeaderElement = Header;
  class Info extends InfoElement$1 {
    get license() {
      return this.get("license");
    }
    set license(licenseElement) {
      this.set("license", licenseElement);
    }
    get summary() {
      return this.get("summary");
    }
    set summary(summary) {
      this.set("summary", summary);
    }
  }
  const InfoElement = Info;
  const _JsonSchemaDialect = class _JsonSchemaDialect extends StringElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "jsonSchemaDialect";
    }
  };
  __publicField(_JsonSchemaDialect, "default", new _JsonSchemaDialect("https://spec.openapis.org/oas/3.1/dialect/base"));
  let JsonSchemaDialect = _JsonSchemaDialect;
  const JsonSchemaDialectElement = JsonSchemaDialect;
  class License extends LicenseElement$1 {
    get identifier() {
      return this.get("identifier");
    }
    set identifier(name) {
      this.set("identifier", name);
    }
  }
  const LicenseElement = License;
  class Link extends LinkElement$1 {
  }
  const LinkElement = Link;
  class MediaType extends MediaTypeElement$1 {
    get schema() {
      return this.get("schema");
    }
    set schema(schema2) {
      this.set("schema", schema2);
    }
  }
  const MediaTypeElement = MediaType;
  class OAuthFlow extends OAuthFlowElement$1 {
  }
  const OAuthFlowElement = OAuthFlow;
  class OAuthFlows extends OAuthFlowsElement$1 {
  }
  const OAuthFlowsElement = OAuthFlows;
  class Openapi extends OpenapiElement$1 {
  }
  const OpenapiElement = Openapi;
  class OpenApi3_1 extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "openApi3_1";
      this.classes.push("api");
    }
    get openapi() {
      return this.get("openapi");
    }
    set openapi(openapi) {
      this.set("openapi", openapi);
    }
    get info() {
      return this.get("info");
    }
    set info(info) {
      this.set("info", info);
    }
    get jsonSchemaDialect() {
      return this.get("jsonSchemaDialect");
    }
    set jsonSchemaDialect(jsonSchemaDialect) {
      this.set("jsonSchemaDialect", jsonSchemaDialect);
    }
    get servers() {
      return this.get("servers");
    }
    set servers(servers) {
      this.set("servers", servers);
    }
    get paths() {
      return this.get("paths");
    }
    set paths(paths2) {
      this.set("paths", paths2);
    }
    get components() {
      return this.get("components");
    }
    set components(components) {
      this.set("components", components);
    }
    get security() {
      return this.get("security");
    }
    set security(security) {
      this.set("security", security);
    }
    get tags() {
      return this.get("tags");
    }
    set tags(tags2) {
      this.set("tags", tags2);
    }
    get externalDocs() {
      return this.get("externalDocs");
    }
    set externalDocs(externalDocs) {
      this.set("externalDocs", externalDocs);
    }
    get webhooks() {
      return this.get("webhooks");
    }
    set webhooks(webhooks) {
      this.set("webhooks", webhooks);
    }
  }
  const OpenApi3_1Element = OpenApi3_1;
  class Operation extends OperationElement$1 {
    get requestBody() {
      return this.get("requestBody");
    }
    set requestBody(requestBody) {
      this.set("requestBody", requestBody);
    }
  }
  const OperationElement = Operation;
  class Parameter extends ParameterElement$1 {
    get schema() {
      return this.get("schema");
    }
    set schema(schema2) {
      this.set("schema", schema2);
    }
  }
  const ParameterElement = Parameter;
  class PathItem extends PathItemElement$1 {
    get GET() {
      return this.get("get");
    }
    set GET(operation) {
      this.set("GET", operation);
    }
    get PUT() {
      return this.get("put");
    }
    set PUT(operation) {
      this.set("PUT", operation);
    }
    get POST() {
      return this.get("post");
    }
    set POST(operation) {
      this.set("POST", operation);
    }
    get DELETE() {
      return this.get("delete");
    }
    set DELETE(operation) {
      this.set("DELETE", operation);
    }
    get OPTIONS() {
      return this.get("options");
    }
    set OPTIONS(operation) {
      this.set("OPTIONS", operation);
    }
    get HEAD() {
      return this.get("head");
    }
    set HEAD(operation) {
      this.set("HEAD", operation);
    }
    get PATCH() {
      return this.get("patch");
    }
    set PATCH(operation) {
      this.set("PATCH", operation);
    }
    get TRACE() {
      return this.get("trace");
    }
    set TRACE(operation) {
      this.set("TRACE", operation);
    }
  }
  const PathItemElement = PathItem;
  class Paths extends PathsElement$1 {
  }
  const PathsElement = Paths;
  class Reference extends ReferenceElement$1 {
  }
  Object.defineProperty(Reference.prototype, "description", {
    get() {
      return this.get("description");
    },
    set(description) {
      this.set("description", description);
    },
    enumerable: true
  });
  Object.defineProperty(Reference.prototype, "summary", {
    get() {
      return this.get("summary");
    },
    set(description) {
      this.set("summary", description);
    },
    enumerable: true
  });
  const ReferenceElement = Reference;
  class RequestBody extends RequestBodyElement$1 {
  }
  const RequestBodyElement = RequestBody;
  let Response$1 = class Response extends ResponseElement$1 {
  };
  const ResponseElement = Response$1;
  class Responses extends ResponsesElement$1 {
  }
  const ResponsesElement = Responses;
  class Schema extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.element = "schema";
    }
    /**
     * Core vocabulary
     *
     * URI: https://json-schema.org/draft/2020-12/vocab/core
     */
    get $schema() {
      return this.get("$schema");
    }
    set $schema($schema) {
      this.set("$schema", $schema);
    }
    get $vocabulary() {
      return this.get("$vocabulary");
    }
    set $vocabulary($vocabulary) {
      this.set("$vocabulary", $vocabulary);
    }
    get $id() {
      return this.get("$id");
    }
    set $id($id) {
      this.set("$id", $id);
    }
    get $anchor() {
      return this.get("$anchor");
    }
    set $anchor($anchor) {
      this.set("$anchor", $anchor);
    }
    get $dynamicAnchor() {
      return this.get("$dynamicAnchor");
    }
    set $dynamicAnchor($dynamicAnchor) {
      this.set("$dynamicAnchor", $dynamicAnchor);
    }
    get $dynamicRef() {
      return this.get("$dynamicRef");
    }
    set $dynamicRef($dynamicRef) {
      this.set("$dynamicRef", $dynamicRef);
    }
    get $ref() {
      return this.get("$ref");
    }
    set $ref($ref) {
      this.set("$ref", $ref);
    }
    get $defs() {
      return this.get("$defs");
    }
    set $defs($defs) {
      this.set("$defs", $defs);
    }
    get $comment() {
      return this.get("$comment");
    }
    set $comment($comment) {
      this.set("$comment", $comment);
    }
    /**
     * Applicator vocabulary
     *
     * URI: https://json-schema.org/draft/2020-12/vocab/applicator
     */
    get allOf() {
      return this.get("allOf");
    }
    set allOf(allOf2) {
      this.set("allOf", allOf2);
    }
    get anyOf() {
      return this.get("anyOf");
    }
    set anyOf(anyOf) {
      this.set("anyOf", anyOf);
    }
    get oneOf() {
      return this.get("oneOf");
    }
    set oneOf(oneOf) {
      this.set("oneOf", oneOf);
    }
    get not() {
      return this.get("not");
    }
    set not(not2) {
      this.set("not", not2);
    }
    get if() {
      return this.get("if");
    }
    set if(ifSchema) {
      this.set("if", ifSchema);
    }
    get then() {
      return this.get("then");
    }
    set then(thenSchema) {
      this.set("then", thenSchema);
    }
    get else() {
      return this.get("else");
    }
    set else(elseSchema) {
      this.set("else", elseSchema);
    }
    get dependentSchemas() {
      return this.get("dependentSchemas");
    }
    set dependentSchemas(dependentSchemas) {
      this.set("dependentSchemas", dependentSchemas);
    }
    get prefixItems() {
      return this.get("prefixItems");
    }
    set prefixItems(prefixItems) {
      this.set("prefixItems", prefixItems);
    }
    get items() {
      return this.get("items");
    }
    set items(items) {
      this.set("items", items);
    }
    get containsProp() {
      return this.get("contains");
    }
    set containsProp(containsProp) {
      this.set("contains", containsProp);
    }
    get properties() {
      return this.get("properties");
    }
    set properties(properties2) {
      this.set("properties", properties2);
    }
    get patternProperties() {
      return this.get("patternProperties");
    }
    set patternProperties(patternProperties) {
      this.set("patternProperties", patternProperties);
    }
    get additionalProperties() {
      return this.get("additionalProperties");
    }
    set additionalProperties(additionalProperties) {
      this.set("additionalProperties", additionalProperties);
    }
    get propertyNames() {
      return this.get("propertyNames");
    }
    set propertyNames(propertyNames) {
      this.set("propertyNames", propertyNames);
    }
    /**
     * Unevaluated Locations vocabulary
     *
     * URI: https://json-schema.org/draft/2020-12/vocab/unevaluated
     */
    get unevaluatedItems() {
      return this.get("unevaluatedItems");
    }
    set unevaluatedItems(unevaluatedItems) {
      this.set("unevaluatedItems", unevaluatedItems);
    }
    get unevaluatedProperties() {
      return this.get("unevaluatedProperties");
    }
    set unevaluatedProperties(unevaluatedProperties) {
      this.set("unevaluatedProperties", unevaluatedProperties);
    }
    /**
     * Validation vocabulary
     *
     * URI: https://json-schema.org/draft/2020-12/vocab/validation
     */
    /**
     *  Validation Keywords for Any Instance Type
     *
     *  URI: https://json-schema.org/draft/2020-12/json-schema-validation.html#rfc.section.6.1
     */
    get type() {
      return this.get("type");
    }
    set type(type2) {
      this.set("type", type2);
    }
    get enum() {
      return this.get("enum");
    }
    set enum(enumVal) {
      this.set("enum", enumVal);
    }
    get const() {
      return this.get("const");
    }
    set const(constVal) {
      this.set("const", constVal);
    }
    /**
     * Validation Keywords for Numeric Instances (number and integer)
     *
     * URI: https://json-schema.org/draft/2020-12/json-schema-validation.html#numeric
     */
    get multipleOf() {
      return this.get("multipleOf");
    }
    set multipleOf(multipleOf) {
      this.set("multipleOf", multipleOf);
    }
    get maximum() {
      return this.get("maximum");
    }
    set maximum(maximum) {
      this.set("maximum", maximum);
    }
    get exclusiveMaximum() {
      return this.get("exclusiveMaximum");
    }
    set exclusiveMaximum(exclusiveMaximum) {
      this.set("exclusiveMaximum", exclusiveMaximum);
    }
    get minimum() {
      return this.get("minimum");
    }
    set minimum(minimum) {
      this.set("minimum", minimum);
    }
    get exclusiveMinimum() {
      return this.get("exclusiveMinimum");
    }
    set exclusiveMinimum(exclusiveMinimum) {
      this.set("exclusiveMinimum", exclusiveMinimum);
    }
    /**
     * Validation Keywords for Strings
     *
     * URI: https://json-schema.org/draft/2020-12/json-schema-validation.html#string
     */
    get maxLength() {
      return this.get("maxLength");
    }
    set maxLength(maxLength) {
      this.set("maxLength", maxLength);
    }
    get minLength() {
      return this.get("minLength");
    }
    set minLength(minLength) {
      this.set("minLength", minLength);
    }
    get pattern() {
      return this.get("pattern");
    }
    set pattern(pattern) {
      this.set("pattern", pattern);
    }
    /**
     * Validation Keywords for Arrays
     *
     * URI: https://json-schema.org/draft/2020-12/json-schema-validation.html#rfc.section.6.4
     */
    get maxItems() {
      return this.get("maxItems");
    }
    set maxItems(maxItems) {
      this.set("maxItems", maxItems);
    }
    get minItems() {
      return this.get("minItems");
    }
    set minItems(minItems) {
      this.set("minItems", minItems);
    }
    get uniqueItems() {
      return this.get("uniqueItems");
    }
    set uniqueItems(uniqueItems) {
      this.set("uniqueItems", uniqueItems);
    }
    get maxContains() {
      return this.get("maxContains");
    }
    set maxContains(maxContains) {
      this.set("maxContains", maxContains);
    }
    get minContains() {
      return this.get("minContains");
    }
    set minContains(minContains) {
      this.set("minContains", minContains);
    }
    /**
     * Validation Keywords for Objects
     *
     * URI: https://json-schema.org/draft/2020-12/json-schema-validation.html#rfc.section.6.5
     */
    get maxProperties() {
      return this.get("maxProperties");
    }
    set maxProperties(maxProperties) {
      this.set("maxProperties", maxProperties);
    }
    get minProperties() {
      return this.get("minProperties");
    }
    set minProperties(minProperties) {
      this.set("minProperties", minProperties);
    }
    get required() {
      return this.get("required");
    }
    set required(required) {
      this.set("required", required);
    }
    get dependentRequired() {
      return this.get("dependentRequired");
    }
    set dependentRequired(dependentRequired) {
      this.set("dependentRequired", dependentRequired);
    }
    /**
     * Vocabulary for Basic Meta-Data Annotations
     *
     * URI: https://json-schema.org/draft/2020-12/vocab/meta-data
     */
    get title() {
      return this.get("title");
    }
    set title(title) {
      this.set("title", title);
    }
    get description() {
      return this.get("description");
    }
    set description(description) {
      this.set("description", description);
    }
    get default() {
      return this.get("default");
    }
    set default(defaultVal) {
      this.set("default", defaultVal);
    }
    get deprecated() {
      return this.get("deprecated");
    }
    set deprecated(deprecated) {
      this.set("deprecated", deprecated);
    }
    get readOnly() {
      return this.get("readOnly");
    }
    set readOnly(readOnly) {
      this.set("readOnly", readOnly);
    }
    get writeOnly() {
      return this.get("writeOnly");
    }
    set writeOnly(writeOnly) {
      this.set("writeOnly", writeOnly);
    }
    get examples() {
      return this.get("examples");
    }
    set examples(examples) {
      this.set("examples", examples);
    }
    /**
     * Vocabularies for Semantic Content With "format"
     *
     * URI: https://json-schema.org/draft/2020-12/vocab/format-annotation
     */
    get format() {
      return this.get("format");
    }
    set format(format) {
      this.set("format", format);
    }
    /**
     * Vocabulary for the Contents of String-Encoded Data
     *
     * URI: https://json-schema.org/draft/2020-12/vocab/content
     */
    get contentEncoding() {
      return this.get("contentEncoding");
    }
    set contentEncoding(contentEncoding) {
      this.set("contentEncoding", contentEncoding);
    }
    get contentMediaType() {
      return this.get("contentMediaType");
    }
    set contentMediaType(contentMediaType) {
      this.set("contentMediaType", contentMediaType);
    }
    get contentSchema() {
      return this.get("contentSchema");
    }
    set contentSchema(contentSchema) {
      this.set("contentSchema", contentSchema);
    }
    /**
     * OAS base vocabulary
     *
     * URI: https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.1.0.md#baseVocabulary
     */
    get discriminator() {
      return this.get("discriminator");
    }
    set discriminator(discriminator) {
      this.set("discriminator", discriminator);
    }
    get xml() {
      return this.get("xml");
    }
    set xml(xml) {
      this.set("xml", xml);
    }
    get externalDocs() {
      return this.get("externalDocs");
    }
    set externalDocs(externalDocs) {
      this.set("externalDocs", externalDocs);
    }
    /**
     * @deprecated The example property has been deprecated in favor of the JSON Schema examples keyword. Use of example is discouraged, and later versions of this specification may remove it.
     */
    get example() {
      return this.get("example");
    }
    set example(example) {
      this.set("example", example);
    }
  }
  const SchemaElement = Schema;
  class SecurityRequirement extends SecurityRequirementElement$1 {
  }
  const SecurityRequirementElement = SecurityRequirement;
  class SecurityScheme extends SecuritySchemeElement$1 {
  }
  const SecuritySchemeElement = SecurityScheme;
  class Server extends ServerElement$1 {
  }
  const ServerElement = Server;
  class ServerVariable extends ServerVariableElement$1 {
  }
  const ServerVariableElement = ServerVariable;
  class Tag extends TagElement$1 {
  }
  const TagElement = Tag;
  class Xml extends XmlElement$1 {
  }
  const XmlElement = Xml;
  const openApi3_1 = {
    namespace: (options) => {
      const {
        base: base2
      } = options;
      base2.register("callback", CallbackElement);
      base2.register("components", ComponentsElement);
      base2.register("contact", ContactElement);
      base2.register("discriminator", DiscriminatorElement);
      base2.register("encoding", EncodingElement);
      base2.register("example", ExampleElement);
      base2.register("externalDocumentation", ExternalDocumentationElement);
      base2.register("header", HeaderElement);
      base2.register("info", InfoElement);
      base2.register("jsonSchemaDialect", JsonSchemaDialectElement);
      base2.register("license", LicenseElement);
      base2.register("link", LinkElement);
      base2.register("mediaType", MediaTypeElement);
      base2.register("oAuthFlow", OAuthFlowElement);
      base2.register("oAuthFlows", OAuthFlowsElement);
      base2.register("openapi", OpenapiElement);
      base2.register("openApi3_1", OpenApi3_1Element);
      base2.register("operation", OperationElement);
      base2.register("parameter", ParameterElement);
      base2.register("pathItem", PathItemElement);
      base2.register("paths", PathsElement);
      base2.register("reference", ReferenceElement);
      base2.register("requestBody", RequestBodyElement);
      base2.register("response", ResponseElement);
      base2.register("responses", ResponsesElement);
      base2.register("schema", SchemaElement);
      base2.register("securityRequirement", SecurityRequirementElement);
      base2.register("securityScheme", SecuritySchemeElement);
      base2.register("server", ServerElement);
      base2.register("serverVariable", ServerVariableElement);
      base2.register("tag", TagElement);
      base2.register("xml", XmlElement);
      return base2;
    }
  };
  const openApi3_1Namespace = openApi3_1;
  const _ComponentsPathItems = class _ComponentsPathItems extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_ComponentsPathItems.primaryClass);
    }
  };
  __publicField(_ComponentsPathItems, "primaryClass", "components-path-items");
  let ComponentsPathItems = _ComponentsPathItems;
  const ComponentsPathItemsElement = ComponentsPathItems;
  const _Webhooks = class _Webhooks extends ObjectElement {
    constructor(content, meta, attributes) {
      super(content, meta, attributes);
      this.classes.push(_Webhooks.primaryClass);
    }
  };
  __publicField(_Webhooks, "primaryClass", "webhooks");
  let Webhooks = _Webhooks;
  const WebhooksElement = Webhooks;
  const getNodeType = (element) => {
    if (!isElement(element)) {
      return void 0;
    }
    return `${element.element.charAt(0).toUpperCase() + element.element.slice(1)}Element`;
  };
  const keyMap = {
    CallbackElement: ["content"],
    ComponentsElement: ["content"],
    ContactElement: ["content"],
    DiscriminatorElement: ["content"],
    Encoding: ["content"],
    Example: ["content"],
    ExternalDocumentationElement: ["content"],
    HeaderElement: ["content"],
    InfoElement: ["content"],
    LicenseElement: ["content"],
    MediaTypeElement: ["content"],
    OAuthFlowElement: ["content"],
    OAuthFlowsElement: ["content"],
    OpenApi3_1Element: ["content"],
    OperationElement: ["content"],
    ParameterElement: ["content"],
    PathItemElement: ["content"],
    PathsElement: ["content"],
    ReferenceElement: ["content"],
    RequestBodyElement: ["content"],
    ResponseElement: ["content"],
    ResponsesElement: ["content"],
    SchemaElement: ["content"],
    SecurityRequirementElement: ["content"],
    SecuritySchemeElement: ["content"],
    ServerElement: ["content"],
    ServerVariableElement: ["content"],
    TagElement: ["content"],
    ...keyMapDefault$1
  };
  const plugin$5 = () => ({
    predicates: predicates2
  }) => {
    const parameterEquals = (parameter1, parameter2) => {
      if (!predicates2.isParameterElement(parameter1))
        return false;
      if (!predicates2.isParameterElement(parameter2))
        return false;
      if (!predicates2.isStringElement(parameter1.name))
        return false;
      if (!predicates2.isStringElement(parameter1.in))
        return false;
      if (!predicates2.isStringElement(parameter2.name))
        return false;
      if (!predicates2.isStringElement(parameter2.in))
        return false;
      return toValue(parameter1.name) === toValue(parameter2.name) && toValue(parameter1.in) === toValue(parameter2.in);
    };
    const pathItemParameters = [];
    return {
      visitor: {
        PathItemElement: {
          enter(pathItemElement, key, parent2, path2, ancestors) {
            if (ancestors.some(predicates2.isComponentsElement)) {
              return;
            }
            const {
              parameters: parameters2
            } = pathItemElement;
            if (predicates2.isArrayElement(parameters2)) {
              pathItemParameters.push([...parameters2.content]);
            } else {
              pathItemParameters.push([]);
            }
          },
          leave() {
            pathItemParameters.pop();
          }
        },
        OperationElement: {
          leave(operationElement) {
            const parentPathItemParameters = last$2(pathItemParameters);
            if (!Array.isArray(parentPathItemParameters) || parentPathItemParameters.length === 0) {
              return;
            }
            const operationParameters = pathOr$1([], ["parameters", "content"], operationElement);
            const mergedParameters = uniqWith$1(parameterEquals, [...operationParameters, ...parentPathItemParameters]);
            operationElement.parameters = new OperationParametersElement(mergedParameters);
          }
        }
      }
    };
  };
  const refractorPluginNormalizeParameters = plugin$5;
  const plugin$4 = () => ({
    predicates: predicates2
  }) => {
    let topLevelSecurity;
    return {
      visitor: {
        OpenApi3_1Element: {
          enter(openapiElement) {
            if (predicates2.isArrayElement(openapiElement.security)) {
              topLevelSecurity = openapiElement.security;
            }
          },
          leave() {
            topLevelSecurity = void 0;
          }
        },
        OperationElement: {
          leave(operationElement, key, parent2, path2, ancestors) {
            if (ancestors.some(predicates2.isComponentsElement)) {
              return;
            }
            const missingOperationLevelSecurity = typeof operationElement.security === "undefined";
            const hasTopLevelSecurity = typeof topLevelSecurity !== "undefined";
            if (missingOperationLevelSecurity && hasTopLevelSecurity) {
              var _topLevelSecurity;
              operationElement.security = new OperationSecurityElement((_topLevelSecurity = topLevelSecurity) === null || _topLevelSecurity === void 0 ? void 0 : _topLevelSecurity.content);
            }
          }
        }
      }
    };
  };
  const refractorPluginNormalizeSecurityRequirements = plugin$4;
  const plugin$3 = () => ({
    predicates: predicates2
  }) => {
    let openAPIServers;
    const pathItemServers = [];
    return {
      visitor: {
        OpenApi3_1Element: {
          enter(openapiElement) {
            if (predicates2.isArrayElement(openapiElement.servers)) {
              var _openapiElement$serve;
              openAPIServers = (_openapiElement$serve = openapiElement.servers) === null || _openapiElement$serve === void 0 ? void 0 : _openapiElement$serve.content;
            }
          },
          leave() {
            openAPIServers = void 0;
          }
        },
        PathItemElement: {
          enter(pathItemElement, key, parent2, path2, ancestors) {
            if (ancestors.some(predicates2.isComponentsElement)) {
              return;
            }
            if (typeof pathItemElement.servers === "undefined" && typeof openAPIServers !== "undefined") {
              pathItemElement.servers = new PathItemServersElement(openAPIServers);
            }
            const {
              servers
            } = pathItemElement;
            if (typeof servers !== "undefined" && predicates2.isArrayElement(servers)) {
              pathItemServers.push([...servers.content]);
            } else {
              pathItemServers.push(void 0);
            }
          },
          leave() {
            pathItemServers.pop();
          }
        },
        OperationElement: {
          enter(operationElement) {
            const parentPathItemServers = last$2(pathItemServers);
            if (typeof parentPathItemServers === "undefined")
              return;
            if (predicates2.isArrayElement(operationElement.servers))
              return;
            operationElement.servers = new OperationServersElement(parentPathItemServers);
          }
        }
      }
    };
  };
  const refractorPluginNormalizeServers = plugin$3;
  const removeSpaces = (operationId) => {
    return operationId.replace(/\s/g, "");
  };
  const replaceSpecialCharsWithUnderscore = (operationId) => {
    return operationId.replace(/\W/gi, "_");
  };
  const createNormalizedOperationId = (path2, method) => {
    const normalizedMethod = replaceSpecialCharsWithUnderscore(removeSpaces(method.toLowerCase()));
    const normalizedPath = replaceSpecialCharsWithUnderscore(removeSpaces(path2));
    return `${normalizedMethod}${normalizedPath}`;
  };
  const normalizeOperationId = (operationId, path2, method) => {
    const withoutSpaces = removeSpaces(operationId);
    if (withoutSpaces.length > 0) {
      return replaceSpecialCharsWithUnderscore(withoutSpaces);
    }
    return createNormalizedOperationId(path2, method);
  };
  const plugin$2 = ({
    operationIdNormalizer = normalizeOperationId
  } = {}) => ({
    predicates: predicates2,
    namespace: namespace2
  }) => {
    const paths2 = [];
    const normalizedOperations = [];
    const links = [];
    return {
      visitor: {
        OpenApi3_1Element: {
          leave() {
            const normalizedOperationGroups = groupBy$2((operationElement) => {
              return toValue(operationElement.operationId);
            }, normalizedOperations);
            Object.entries(normalizedOperationGroups).forEach(([normalizedOperationId, operationElements]) => {
              if (!Array.isArray(operationElements))
                return;
              if (operationElements.length <= 1)
                return;
              operationElements.forEach((operationElement, index2) => {
                const indexedNormalizedOperationId = `${normalizedOperationId}${index2 + 1}`;
                operationElement.operationId = new namespace2.elements.String(indexedNormalizedOperationId);
              });
            });
            links.forEach((linkElement) => {
              if (typeof linkElement.operationId === "undefined")
                return;
              const linkOperationId = String(toValue(linkElement.operationId));
              const operationElement = normalizedOperations.find((normalizedOperationElement) => {
                const originalOperationId = toValue(normalizedOperationElement.meta.get("originalOperationId"));
                return originalOperationId === linkOperationId;
              });
              if (typeof operationElement === "undefined")
                return;
              linkElement.operationId = cloneDeep.safe(operationElement.operationId);
              linkElement.meta.set("originalOperationId", linkOperationId);
              linkElement.set("__originalOperationId", linkOperationId);
            });
            normalizedOperations.length = 0;
            links.length = 0;
          }
        },
        PathItemElement: {
          enter(pathItemElement) {
            const path2 = defaultTo$1("path", toValue(pathItemElement.meta.get("path")));
            paths2.push(path2);
          },
          leave() {
            paths2.pop();
          }
        },
        OperationElement: {
          enter(operationElement) {
            if (typeof operationElement.operationId === "undefined")
              return;
            const originalOperationId = String(toValue(operationElement.operationId));
            const path2 = last$2(paths2);
            const method = defaultTo$1("method", toValue(operationElement.meta.get("http-method")));
            const normalizedOperationId = operationIdNormalizer(originalOperationId, path2, method);
            if (originalOperationId === normalizedOperationId)
              return;
            operationElement.operationId = new namespace2.elements.String(normalizedOperationId);
            operationElement.set("__originalOperationId", originalOperationId);
            operationElement.meta.set("originalOperationId", originalOperationId);
            normalizedOperations.push(operationElement);
          }
        },
        LinkElement: {
          leave(linkElement) {
            if (!predicates2.isLinkElement(linkElement))
              return;
            if (typeof linkElement.operationId === "undefined")
              return;
            links.push(linkElement);
          }
        }
      }
    };
  };
  const refractorPluginNormalizeOperationIds = plugin$2;
  const plugin$1 = () => ({
    predicates: predicates2
  }) => {
    return {
      visitor: {
        ParameterElement: {
          leave(parameterElement, key, parent2, path2, ancestors) {
            var _parameterElement$sch, _parameterElement$sch2;
            if (ancestors.some(predicates2.isComponentsElement)) {
              return;
            }
            if (typeof parameterElement.schema === "undefined" || !predicates2.isSchemaElement(parameterElement.schema)) {
              return;
            }
            if (typeof ((_parameterElement$sch = parameterElement.schema) === null || _parameterElement$sch === void 0 ? void 0 : _parameterElement$sch.example) === "undefined" && typeof ((_parameterElement$sch2 = parameterElement.schema) === null || _parameterElement$sch2 === void 0 ? void 0 : _parameterElement$sch2.examples) === "undefined") {
              return;
            }
            if (typeof parameterElement.examples !== "undefined" && predicates2.isObjectElement(parameterElement.examples)) {
              const examples = parameterElement.examples.map((example) => {
                return cloneDeep.safe(example.value);
              });
              if (typeof parameterElement.schema.examples !== "undefined") {
                parameterElement.schema.set("examples", examples);
              }
              if (typeof parameterElement.schema.example !== "undefined") {
                parameterElement.schema.set("example", examples);
              }
              return;
            }
            if (typeof parameterElement.example !== "undefined") {
              if (typeof parameterElement.schema.examples !== "undefined") {
                parameterElement.schema.set("examples", [cloneDeep(parameterElement.example)]);
              }
              if (typeof parameterElement.schema.example !== "undefined") {
                parameterElement.schema.set("example", cloneDeep(parameterElement.example));
              }
            }
          }
        }
      }
    };
  };
  const refractorPluginNormalizeParameterExamples = plugin$1;
  const plugin = () => ({
    predicates: predicates2
  }) => {
    return {
      visitor: {
        HeaderElement: {
          leave(headerElement, key, parent2, path2, ancestors) {
            var _headerElement$schema, _headerElement$schema2;
            if (ancestors.some(predicates2.isComponentsElement)) {
              return;
            }
            if (typeof headerElement.schema === "undefined" || !predicates2.isSchemaElement(headerElement.schema)) {
              return;
            }
            if (typeof ((_headerElement$schema = headerElement.schema) === null || _headerElement$schema === void 0 ? void 0 : _headerElement$schema.example) === "undefined" && typeof ((_headerElement$schema2 = headerElement.schema) === null || _headerElement$schema2 === void 0 ? void 0 : _headerElement$schema2.examples) === "undefined") {
              return;
            }
            if (typeof headerElement.examples !== "undefined" && predicates2.isObjectElement(headerElement.examples)) {
              const examples = headerElement.examples.map((example) => {
                return cloneDeep.safe(example.value);
              });
              if (typeof headerElement.schema.examples !== "undefined") {
                headerElement.schema.set("examples", examples);
              }
              if (typeof headerElement.schema.example !== "undefined") {
                headerElement.schema.set("example", examples);
              }
              return;
            }
            if (typeof headerElement.example !== "undefined") {
              if (typeof headerElement.schema.examples !== "undefined") {
                headerElement.schema.set("examples", [cloneDeep(headerElement.example)]);
              }
              if (typeof headerElement.schema.example !== "undefined") {
                headerElement.schema.set("example", cloneDeep(headerElement.example));
              }
            }
          }
        }
      }
    };
  };
  const refractorPluginNormalizeHeaderExamples = plugin;
  const isCallbackElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof CallbackElement || hasBasicElementProps2(element) && isElementType2("callback", element) && primitiveEq2("object", element);
  });
  const isComponentsElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof ComponentsElement || hasBasicElementProps2(element) && isElementType2("components", element) && primitiveEq2("object", element);
  });
  const isContactElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof ContactElement || hasBasicElementProps2(element) && isElementType2("contact", element) && primitiveEq2("object", element);
  });
  const isExampleElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof ExampleElement || hasBasicElementProps2(element) && isElementType2("example", element) && primitiveEq2("object", element);
  });
  const isExternalDocumentationElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof ExternalDocumentationElement || hasBasicElementProps2(element) && isElementType2("externalDocumentation", element) && primitiveEq2("object", element);
  });
  const isHeaderElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof HeaderElement || hasBasicElementProps2(element) && isElementType2("header", element) && primitiveEq2("object", element);
  });
  const isInfoElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof InfoElement || hasBasicElementProps2(element) && isElementType2("info", element) && primitiveEq2("object", element);
  });
  const isJsonSchemaDialectElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof JsonSchemaDialectElement || hasBasicElementProps2(element) && isElementType2("jsonSchemaDialect", element) && primitiveEq2("string", element);
  });
  const isLicenseElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof LicenseElement || hasBasicElementProps2(element) && isElementType2("license", element) && primitiveEq2("object", element);
  });
  const isLinkElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof LinkElement || hasBasicElementProps2(element) && isElementType2("link", element) && primitiveEq2("object", element);
  });
  const isLinkElementExternal = (element) => {
    if (!isLinkElement(element)) {
      return false;
    }
    if (!isStringElement(element.operationRef)) {
      return false;
    }
    const value2 = toValue(element.operationRef);
    return typeof value2 === "string" && value2.length > 0 && !value2.startsWith("#");
  };
  const isOpenapiElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof OpenapiElement || hasBasicElementProps2(element) && isElementType2("openapi", element) && primitiveEq2("string", element);
  });
  const isOpenApi3_1Element = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2,
    hasClass: hasClass2
  }) => {
    return (element) => element instanceof OpenApi3_1Element || hasBasicElementProps2(element) && isElementType2("openApi3_1", element) && primitiveEq2("object", element) && hasClass2("api", element);
  });
  const isOperationElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof OperationElement || hasBasicElementProps2(element) && isElementType2("operation", element) && primitiveEq2("object", element);
  });
  const isParameterElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof ParameterElement || hasBasicElementProps2(element) && isElementType2("parameter", element) && primitiveEq2("object", element);
  });
  const isPathItemElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof PathItemElement || hasBasicElementProps2(element) && isElementType2("pathItem", element) && primitiveEq2("object", element);
  });
  const isPathItemElementExternal = (element) => {
    if (!isPathItemElement(element)) {
      return false;
    }
    if (!isStringElement(element.$ref)) {
      return false;
    }
    const value2 = toValue(element.$ref);
    return typeof value2 === "string" && value2.length > 0 && !value2.startsWith("#");
  };
  const isPathsElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof PathsElement || hasBasicElementProps2(element) && isElementType2("paths", element) && primitiveEq2("object", element);
  });
  const isReferenceElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof ReferenceElement || hasBasicElementProps2(element) && isElementType2("reference", element) && primitiveEq2("object", element);
  });
  const isReferenceElementExternal = (element) => {
    if (!isReferenceElement(element)) {
      return false;
    }
    if (!isStringElement(element.$ref)) {
      return false;
    }
    const value2 = toValue(element.$ref);
    return typeof value2 === "string" && value2.length > 0 && !value2.startsWith("#");
  };
  const isRequestBodyElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof RequestBodyElement || hasBasicElementProps2(element) && isElementType2("requestBody", element) && primitiveEq2("object", element);
  });
  const isResponseElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof ResponseElement || hasBasicElementProps2(element) && isElementType2("response", element) && primitiveEq2("object", element);
  });
  const isResponsesElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof ResponsesElement || hasBasicElementProps2(element) && isElementType2("responses", element) && primitiveEq2("object", element);
  });
  const isSchemaElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof SchemaElement || hasBasicElementProps2(element) && isElementType2("schema", element) && primitiveEq2("object", element);
  });
  const isBooleanJsonSchemaElement = (element) => {
    return isBooleanElement(element) && element.classes.includes("boolean-json-schema");
  };
  const isSecurityRequirementElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof SecurityRequirementElement || hasBasicElementProps2(element) && isElementType2("securityRequirement", element) && primitiveEq2("object", element);
  });
  const isServerElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof ServerElement || hasBasicElementProps2(element) && isElementType2("server", element) && primitiveEq2("object", element);
  });
  const isServerVariableElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof ServerVariableElement || hasBasicElementProps2(element) && isElementType2("serverVariable", element) && primitiveEq2("object", element);
  });
  const isMediaTypeElement = createPredicate$1(({
    hasBasicElementProps: hasBasicElementProps2,
    isElementType: isElementType2,
    primitiveEq: primitiveEq2
  }) => {
    return (element) => element instanceof MediaTypeElement || hasBasicElementProps2(element) && isElementType2("mediaType", element) && primitiveEq2("object", element);
  });
  const openApi3_1Predicates = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    isBooleanJsonSchemaElement,
    isCallbackElement,
    isComponentsElement,
    isContactElement,
    isExampleElement,
    isExternalDocumentationElement,
    isHeaderElement,
    isInfoElement,
    isJsonSchemaDialectElement,
    isLicenseElement,
    isLinkElement,
    isLinkElementExternal,
    isMediaTypeElement,
    isOpenApi3_1Element,
    isOpenapiElement,
    isOperationElement,
    isParameterElement,
    isPathItemElement,
    isPathItemElementExternal,
    isPathsElement,
    isReferenceElement,
    isReferenceElementExternal,
    isRequestBodyElement,
    isResponseElement,
    isResponsesElement,
    isSchemaElement,
    isSecurityRequirementElement,
    isServerElement,
    isServerVariableElement
  }, Symbol.toStringTag, { value: "Module" }));
  const createToolbox = () => {
    const namespace2 = createNamespace(openApi3_1Namespace);
    const predicates2 = {
      ...openApi3_1Predicates,
      isStringElement,
      isArrayElement,
      isObjectElement,
      includesClasses
    };
    return {
      predicates: predicates2,
      namespace: namespace2
    };
  };
  const createToolbox$1 = createToolbox;
  const OpenApi3_1Visitor = stampit(FixedFieldsVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "OpenApi"]),
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new OpenApi3_1Element();
      this.openApiSemanticElement = this.element;
    },
    methods: {
      ObjectElement(objectElement) {
        this.openApiGenericElement = objectElement;
        return FixedFieldsVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
      }
    }
  });
  const OpenApi3_1Visitor$1 = OpenApi3_1Visitor;
  const {
    visitors: {
      document: {
        objects: {
          Info: {
            $visitor: BaseInfoVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const InfoVisitor = stampit(BaseInfoVisitor, {
    init() {
      this.element = new InfoElement();
    }
  });
  const InfoVisitor$1 = InfoVisitor;
  const SummaryVisitor$1 = FallbackVisitor$1;
  const InfoSummaryVisitor = SummaryVisitor$1;
  const {
    visitors: {
      document: {
        objects: {
          Contact: {
            $visitor: BaseContactVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const ContactVisitor = stampit(BaseContactVisitor, {
    init() {
      this.element = new ContactElement();
    }
  });
  const ContactVisitor$1 = ContactVisitor;
  const {
    visitors: {
      document: {
        objects: {
          License: {
            $visitor: BaseLicenseVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const LicenseVisitor = stampit(BaseLicenseVisitor, {
    init() {
      this.element = new LicenseElement();
    }
  });
  const LicenseVisitor$1 = LicenseVisitor;
  const IdentifierVisitor = FallbackVisitor$1;
  const LicenseIdentifierVisitor = IdentifierVisitor;
  const {
    visitors: {
      document: {
        objects: {
          Link: {
            $visitor: BaseLinkVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const LinkVisitor = stampit(BaseLinkVisitor, {
    init() {
      this.element = new LinkElement();
    }
  });
  const LinkVisitor$1 = LinkVisitor;
  const JsonSchemaDialectVisitor = stampit(SpecificationVisitor$1, FallbackVisitor$1, {
    methods: {
      StringElement(stringElement) {
        const jsonSchemaDialectElement = new JsonSchemaDialectElement(toValue(stringElement));
        this.copyMetaAndAttributes(stringElement, jsonSchemaDialectElement);
        this.element = jsonSchemaDialectElement;
        return BREAK;
      }
    }
  });
  const JsonSchemaDialectVisitor$1 = JsonSchemaDialectVisitor;
  const {
    visitors: {
      document: {
        objects: {
          Server: {
            $visitor: BaseServerVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const ServerVisitor = stampit(BaseServerVisitor, {
    init() {
      this.element = new ServerElement();
    }
  });
  const ServerVisitor$1 = ServerVisitor;
  const {
    visitors: {
      document: {
        objects: {
          ServerVariable: {
            $visitor: BaseServerVariableVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const ServerVariableVisitor = stampit(BaseServerVariableVisitor, {
    init() {
      this.element = new ServerVariableElement();
    }
  });
  const ServerVariableVisitor$1 = ServerVariableVisitor;
  const {
    visitors: {
      document: {
        objects: {
          MediaType: {
            $visitor: BaseMediaTypeVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const MediaTypeVisitor = stampit(BaseMediaTypeVisitor, {
    init() {
      this.element = new MediaTypeElement();
    }
  });
  const MediaTypeVisitor$1 = MediaTypeVisitor;
  const {
    visitors: {
      document: {
        objects: {
          SecurityRequirement: {
            $visitor: BaseSecurityRequirementVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const SecurityRequirementVisitor = stampit(BaseSecurityRequirementVisitor, {
    init() {
      this.element = new SecurityRequirementElement();
    }
  });
  const SecurityRequirementVisitor$1 = SecurityRequirementVisitor;
  const {
    visitors: {
      document: {
        objects: {
          Components: {
            $visitor: BaseComponentsVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const ComponentsVisitor = stampit(BaseComponentsVisitor, {
    init() {
      this.element = new ComponentsElement();
    }
  });
  const ComponentsVisitor$1 = ComponentsVisitor;
  const {
    visitors: {
      document: {
        objects: {
          Tag: {
            $visitor: BaseTagVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const TagVisitor = stampit(BaseTagVisitor, {
    init() {
      this.element = new TagElement();
    }
  });
  const TagVisitor$1 = TagVisitor;
  const {
    visitors: {
      document: {
        objects: {
          Reference: {
            $visitor: BaseReferenceVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const ReferenceVisitor = stampit(BaseReferenceVisitor, {
    init() {
      this.element = new ReferenceElement();
    }
  });
  const ReferenceVisitor$1 = ReferenceVisitor;
  const SummaryVisitor = FallbackVisitor$1;
  const ReferenceSummaryVisitor = SummaryVisitor;
  const DescriptionVisitor$1 = FallbackVisitor$1;
  const ReferenceDescriptionVisitor = DescriptionVisitor$1;
  const {
    visitors: {
      document: {
        objects: {
          Parameter: {
            $visitor: BaseParameterVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const ParameterVisitor = stampit(BaseParameterVisitor, {
    init() {
      this.element = new ParameterElement();
    }
  });
  const ParameterVisitor$1 = ParameterVisitor;
  const {
    visitors: {
      document: {
        objects: {
          Header: {
            $visitor: BaseHeaderVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const HeaderVisitor = stampit(BaseHeaderVisitor, {
    init() {
      this.element = new HeaderElement();
    }
  });
  const HeaderVisitor$1 = HeaderVisitor;
  const ParentSchemaAwareVisitor = stampit({
    props: {
      parent: null
    },
    // @ts-ignore
    init({
      parent: parent2 = this.parent
    }) {
      this.parent = parent2;
      this.passingOptionsNames = [...this.passingOptionsNames, "parent"];
    }
  });
  const ParentSchemaAwareVisitor$1 = ParentSchemaAwareVisitor;
  const SchemaVisitor = stampit(FixedFieldsVisitor$1, ParentSchemaAwareVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "Schema"]),
      canSupportSpecificationExtensions: true
    },
    // @ts-ignore
    init() {
      const getJsonSchemaDialect = () => {
        let jsonSchemaDialect;
        if (this.openApiSemanticElement !== null && isJsonSchemaDialectElement(this.openApiSemanticElement.jsonSchemaDialect)) {
          jsonSchemaDialect = toValue(this.openApiSemanticElement.jsonSchemaDialect);
        } else if (this.openApiGenericElement !== null && isStringElement(this.openApiGenericElement.get("jsonSchemaDialect"))) {
          jsonSchemaDialect = toValue(this.openApiGenericElement.get("jsonSchemaDialect"));
        } else {
          jsonSchemaDialect = toValue(JsonSchemaDialectElement.default);
        }
        return jsonSchemaDialect;
      };
      const handle$schema = (objectElement) => {
        if (isNull$3(this.parent) && !isStringElement(objectElement.get("$schema"))) {
          this.element.setMetaProperty("inherited$schema", getJsonSchemaDialect());
        } else if (isSchemaElement(this.parent) && !isStringElement(objectElement.get("$schema"))) {
          const inherited$schema = defaultTo$1(toValue(this.parent.meta.get("inherited$schema")), toValue(this.parent.$schema));
          this.element.setMetaProperty("inherited$schema", inherited$schema);
        }
      };
      const handle$id = (objectElement) => {
        const inherited$id = this.parent !== null ? cloneDeep(this.parent.getMetaProperty("inherited$id", [])) : new ArrayElement();
        const $id = toValue(objectElement.get("$id"));
        if (isNonEmptyString$1($id)) {
          inherited$id.push($id);
        }
        this.element.setMetaProperty("inherited$id", inherited$id);
      };
      this.ObjectElement = function _ObjectElement(objectElement) {
        this.element = new SchemaElement();
        handle$schema(objectElement);
        handle$id(objectElement);
        this.parent = this.element;
        const result = FixedFieldsVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        if (isStringElement(this.element.$ref)) {
          this.element.classes.push("reference-element");
          this.element.setMetaProperty("referenced-element", "schema");
        }
        return result;
      };
      this.BooleanElement = function _BooleanElement(booleanElement) {
        this.element = cloneDeep(booleanElement);
        this.element.classes.push("boolean-json-schema");
        return BREAK;
      };
    }
  });
  const SchemaVisitor$1 = SchemaVisitor;
  const $schemaVisitor = FallbackVisitor$1;
  const Schema$schemaVisitor = $schemaVisitor;
  const $vocabularyVisitor = stampit(FallbackVisitor$1, {
    methods: {
      ObjectElement(objectElement) {
        this.element = cloneDeep(objectElement);
        this.element.classes.push("json-schema-$vocabulary");
        return BREAK;
      }
    }
  });
  const Schema$vocabularyVisitor = $vocabularyVisitor;
  const $idVisitor = FallbackVisitor$1;
  const Schema$idVisitor = $idVisitor;
  const $anchorVisitor = FallbackVisitor$1;
  const Schema$anchorVisitor = $anchorVisitor;
  const $dynamicAnchorVisitor = FallbackVisitor$1;
  const Schema$dynamicAnchorVisitor = $dynamicAnchorVisitor;
  const $dynamicRefVisitor = FallbackVisitor$1;
  const Schema$dynamicRefVisitor = $dynamicRefVisitor;
  const $refVisitor = stampit(FallbackVisitor$1, {
    methods: {
      StringElement(stringElement) {
        this.element = cloneDeep(stringElement);
        this.element.classes.push("reference-value");
        return BREAK;
      }
    }
  });
  const Schema$refVisitor = $refVisitor;
  const $defsVisitor = stampit(MapVisitor$1, ParentSchemaAwareVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "Schema"])
    },
    init() {
      this.element = new ObjectElement();
      this.element.classes.push("json-schema-$defs");
    }
  });
  const Schema$defsVisitor = $defsVisitor;
  const $commentVisitor = FallbackVisitor$1;
  const Schema$commentVisitor = $commentVisitor;
  const AllOfVisitor$1 = stampit(SpecificationVisitor$1, ParentSchemaAwareVisitor$1, FallbackVisitor$1, {
    init() {
      this.element = new ArrayElement();
      this.element.classes.push("json-schema-allOf");
    },
    methods: {
      ArrayElement(arrayElement) {
        arrayElement.forEach((item) => {
          if (isObjectElement(item)) {
            const schemaElement = this.toRefractedElement(["document", "objects", "Schema"], item);
            this.element.push(schemaElement);
          } else {
            const element = cloneDeep(item);
            this.element.push(element);
          }
        });
        this.copyMetaAndAttributes(arrayElement, this.element);
        return BREAK;
      }
    }
  });
  const SchemaAllOfVisitor = AllOfVisitor$1;
  const AnyOfVisitor = stampit(SpecificationVisitor$1, ParentSchemaAwareVisitor$1, FallbackVisitor$1, {
    init() {
      this.element = new ArrayElement();
      this.element.classes.push("json-schema-anyOf");
    },
    methods: {
      ArrayElement(arrayElement) {
        arrayElement.forEach((item) => {
          if (isObjectElement(item)) {
            const schemaElement = this.toRefractedElement(["document", "objects", "Schema"], item);
            this.element.push(schemaElement);
          } else {
            const element = cloneDeep(item);
            this.element.push(element);
          }
        });
        this.copyMetaAndAttributes(arrayElement, this.element);
        return BREAK;
      }
    }
  });
  const SchemaAnyOfVisitor = AnyOfVisitor;
  const OneOfVisitor = stampit(SpecificationVisitor$1, ParentSchemaAwareVisitor$1, FallbackVisitor$1, {
    init() {
      this.element = new ArrayElement();
      this.element.classes.push("json-schema-oneOf");
    },
    methods: {
      ArrayElement(arrayElement) {
        arrayElement.forEach((item) => {
          if (isObjectElement(item)) {
            const schemaElement = this.toRefractedElement(["document", "objects", "Schema"], item);
            this.element.push(schemaElement);
          } else {
            const element = cloneDeep(item);
            this.element.push(element);
          }
        });
        this.copyMetaAndAttributes(arrayElement, this.element);
        return BREAK;
      }
    }
  });
  const SchemaOneOfVisitor = OneOfVisitor;
  const DependentSchemasVisitor = stampit(MapVisitor$1, ParentSchemaAwareVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "Schema"])
    },
    init() {
      this.element = new ObjectElement();
      this.element.classes.push("json-schema-dependentSchemas");
    }
  });
  const SchemaDependantSchemasVisitor = DependentSchemasVisitor;
  const PrefixItemsVisitor = stampit(SpecificationVisitor$1, ParentSchemaAwareVisitor$1, FallbackVisitor$1, {
    init() {
      this.element = new ArrayElement();
      this.element.classes.push("json-schema-prefixItems");
    },
    methods: {
      ArrayElement(arrayElement) {
        arrayElement.forEach((item) => {
          if (isObjectElement(item)) {
            const schemaElement = this.toRefractedElement(["document", "objects", "Schema"], item);
            this.element.push(schemaElement);
          } else {
            const element = cloneDeep(item);
            this.element.push(element);
          }
        });
        this.copyMetaAndAttributes(arrayElement, this.element);
        return BREAK;
      }
    }
  });
  const SchemaPrefixItemsVisitor = PrefixItemsVisitor;
  const PropertiesVisitor = stampit(MapVisitor$1, ParentSchemaAwareVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "Schema"])
    },
    // @ts-ignore
    init() {
      this.element = new ObjectElement();
      this.element.classes.push("json-schema-properties");
    }
  });
  const SchemaPropertiesVisitor = PropertiesVisitor;
  const PatternPropertiesVisitor = stampit(MapVisitor$1, ParentSchemaAwareVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "Schema"])
    },
    init() {
      this.element = new ObjectElement();
      this.element.classes.push("json-schema-patternProperties");
    }
  });
  const SchemaPatternPropertiesVisitor = PatternPropertiesVisitor;
  const TypeVisitor = stampit(FallbackVisitor$1, {
    methods: {
      StringElement(stringElement) {
        this.element = cloneDeep(stringElement);
        this.element.classes.push("json-schema-type");
        return BREAK;
      },
      ArrayElement(arrayElement) {
        this.element = cloneDeep(arrayElement);
        this.element.classes.push("json-schema-type");
        return BREAK;
      }
    }
  });
  const SchemaTypeVisitor = TypeVisitor;
  const EnumVisitor = stampit(FallbackVisitor$1, {
    methods: {
      ArrayElement(arrayElement) {
        this.element = cloneDeep(arrayElement);
        this.element.classes.push("json-schema-enum");
        return BREAK;
      }
    }
  });
  const SchemaEnumVisitor = EnumVisitor;
  const ConstVisitor = FallbackVisitor$1;
  const SchemaConstVisitor = ConstVisitor;
  const MultipleOfVisitor = FallbackVisitor$1;
  const SchemaMultipleOfVisitor = MultipleOfVisitor;
  const MaximumVisitor = FallbackVisitor$1;
  const SchemaMaximumVisitor = MaximumVisitor;
  const ExclusiveMaximumVisitor = FallbackVisitor$1;
  const SchemaExclusiveMaximumVisitor = ExclusiveMaximumVisitor;
  const MinimumVisitor = FallbackVisitor$1;
  const SchemaMinimumVisitor = MinimumVisitor;
  const ExclusiveMinimumVisitor = FallbackVisitor$1;
  const SchemaExclusiveMinimumVisitor = ExclusiveMinimumVisitor;
  const MaxLengthVisitor = FallbackVisitor$1;
  const SchemaMaxLengthVisitor = MaxLengthVisitor;
  const MinLengthVisitor = FallbackVisitor$1;
  const SchemaMinLengthVisitor = MinLengthVisitor;
  const PatternVisitor = FallbackVisitor$1;
  const SchemaPatternVisitor = PatternVisitor;
  const MaxItemsVisitor = FallbackVisitor$1;
  const SchemaMaxItemsVisitor = MaxItemsVisitor;
  const MinItemsVisitor = FallbackVisitor$1;
  const SchemaMinItemsVisitor = MinItemsVisitor;
  const UniqueItemsVisitor = FallbackVisitor$1;
  const SchemaUniqueItemsVisitor = UniqueItemsVisitor;
  const MaxContainsVisitor = FallbackVisitor$1;
  const SchemaMaxContainsVisitor = MaxContainsVisitor;
  const MinContainsVisitor = FallbackVisitor$1;
  const SchemaMinContainsVisitor = MinContainsVisitor;
  const MaxPropertiesVisitor = FallbackVisitor$1;
  const SchemaMaxPropertiesVisitor = MaxPropertiesVisitor;
  const MinPropertiesVisitor = FallbackVisitor$1;
  const SchemaMinPropertiesVisitor = MinPropertiesVisitor;
  const RequiredVisitor = stampit(FallbackVisitor$1, {
    methods: {
      ArrayElement(arrayElement) {
        this.element = cloneDeep(arrayElement);
        this.element.classes.push("json-schema-required");
        return BREAK;
      }
    }
  });
  const SchemaRequiredVisitor = RequiredVisitor;
  const DependentRequiredVisitor = stampit(FallbackVisitor$1, {
    methods: {
      ObjectElement(objectElement) {
        this.element = cloneDeep(objectElement);
        this.element.classes.push("json-schema-dependentRequired");
        return BREAK;
      }
    }
  });
  const SchemaDependentRequiredVisitor = DependentRequiredVisitor;
  const TitleVisitor = FallbackVisitor$1;
  const SchemaTitleVisitor = TitleVisitor;
  const DescriptionVisitor = FallbackVisitor$1;
  const SchemaDescriptionVisitor = DescriptionVisitor;
  const DefaultVisitor = FallbackVisitor$1;
  const SchemaDefaultVisitor = DefaultVisitor;
  const DeprecatedVisitor = FallbackVisitor$1;
  const SchemaDeprecatedVisitor = DeprecatedVisitor;
  const ReadOnlyVisitor = FallbackVisitor$1;
  const SchemaReadOnlyVisitor = ReadOnlyVisitor;
  const WriteOnlyVisitor = FallbackVisitor$1;
  const SchemaWriteOnlyVisitor = WriteOnlyVisitor;
  const ExamplesVisitor = stampit(FallbackVisitor$1, {
    methods: {
      ArrayElement(arrayElement) {
        this.element = cloneDeep(arrayElement);
        this.element.classes.push("json-schema-examples");
        return BREAK;
      }
    }
  });
  const SchemaExamplesVisitor = ExamplesVisitor;
  const FormatVisitor = FallbackVisitor$1;
  const SchemaFormatVisitor = FormatVisitor;
  const ContentEncodingVisitor = FallbackVisitor$1;
  const SchemaContentEncodingVisitor = ContentEncodingVisitor;
  const ContentMediaTypeVisitor = FallbackVisitor$1;
  const SchemaContentMediaTypeVisitor = ContentMediaTypeVisitor;
  const ExampleVisitor$2 = FallbackVisitor$1;
  const SchemaExampleVisitor = ExampleVisitor$2;
  const {
    visitors: {
      document: {
        objects: {
          Discriminator: {
            $visitor: BaseDiscriminatorVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const DiscriminatorVisitor = stampit(BaseDiscriminatorVisitor, {
    props: {
      canSupportSpecificationExtensions: true
    },
    init() {
      this.element = new DiscriminatorElement();
    }
  });
  const DiscriminatorVisitor$1 = DiscriminatorVisitor;
  const {
    visitors: {
      document: {
        objects: {
          XML: {
            $visitor: BaseXMLVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const XmlVisitor = stampit(BaseXMLVisitor, {
    init() {
      this.element = new XmlElement();
    }
  });
  const XmlVisitor$1 = XmlVisitor;
  const SchemasVisitor = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: always$1(["document", "objects", "Schema"])
    },
    init() {
      this.element = new ComponentsSchemasElement();
    }
  });
  const ComponentsSchemasVisitor = SchemasVisitor;
  const PathItemsVisitor = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: (element) => {
        return isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "PathItem"];
      }
    },
    init() {
      this.element = new ComponentsPathItemsElement();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = MapVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isReferenceElement).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "pathItem");
        });
        return result;
      }
    }
  });
  const ComponentsPathItemsVisitor = PathItemsVisitor;
  const {
    visitors: {
      document: {
        objects: {
          Example: {
            $visitor: BaseExampleVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const ExampleVisitor = stampit(BaseExampleVisitor, {
    init() {
      this.element = new ExampleElement();
    }
  });
  const ExampleVisitor$1 = ExampleVisitor;
  const {
    visitors: {
      document: {
        objects: {
          ExternalDocumentation: {
            $visitor: BaseExternalDocumentationVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const ExternalDocumentationVisitor = stampit(BaseExternalDocumentationVisitor, {
    init() {
      this.element = new ExternalDocumentationElement();
    }
  });
  const ExternalDocumentationVisitor$1 = ExternalDocumentationVisitor;
  const {
    visitors: {
      document: {
        objects: {
          Encoding: {
            $visitor: BaseEncodingVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const EncodingVisitor = stampit(BaseEncodingVisitor, {
    init() {
      this.element = new EncodingElement();
    }
  });
  const EncodingVisitor$1 = EncodingVisitor;
  const {
    visitors: {
      document: {
        objects: {
          Paths: {
            $visitor: BasePathsVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const PathsVisitor = stampit(BasePathsVisitor, {
    init() {
      this.element = new PathsElement();
    }
  });
  const PathsVisitor$1 = PathsVisitor;
  const {
    visitors: {
      document: {
        objects: {
          RequestBody: {
            $visitor: BaseRequestBodyVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const RequestBodyVisitor = stampit(BaseRequestBodyVisitor, {
    init() {
      this.element = new RequestBodyElement();
    }
  });
  const RequestBodyVisitor$1 = RequestBodyVisitor;
  const {
    visitors: {
      document: {
        objects: {
          Callback: {
            $visitor: BaseCallbackVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const CallbackVisitor = stampit(BaseCallbackVisitor, {
    props: {
      specPath: (element) => {
        return isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "PathItem"];
      }
    },
    init() {
      this.element = new CallbackElement();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = BaseCallbackVisitor.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isReferenceElement).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "pathItem");
        });
        return result;
      }
    }
  });
  const CallbackVisitor$1 = CallbackVisitor;
  const {
    visitors: {
      document: {
        objects: {
          Response: {
            $visitor: BaseResponseVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const ResponseVisitor = stampit(BaseResponseVisitor, {
    init() {
      this.element = new ResponseElement();
    }
  });
  const ResponseVisitor$1 = ResponseVisitor;
  const {
    visitors: {
      document: {
        objects: {
          Responses: {
            $visitor: BaseResponsesVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const ResponsesVisitor = stampit(BaseResponsesVisitor, {
    init() {
      this.element = new ResponsesElement();
    }
  });
  const ResponsesVisitor$1 = ResponsesVisitor;
  const {
    visitors: {
      document: {
        objects: {
          Operation: {
            $visitor: BaseOperationVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const OperationVisitor = stampit(BaseOperationVisitor, {
    init() {
      this.element = new OperationElement();
    }
  });
  const OperationVisitor$1 = OperationVisitor;
  const {
    visitors: {
      document: {
        objects: {
          PathItem: {
            $visitor: BasePathItemVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const PathItemVisitor = stampit(BasePathItemVisitor, {
    init() {
      this.element = new PathItemElement();
    }
  });
  const PathItemVisitor$1 = PathItemVisitor;
  const {
    visitors: {
      document: {
        objects: {
          SecurityScheme: {
            $visitor: BaseSecuritySchemeVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const SecuritySchemeVisitor = stampit(BaseSecuritySchemeVisitor, {
    init() {
      this.element = new SecuritySchemeElement();
    }
  });
  const SecuritySchemeVisitor$1 = SecuritySchemeVisitor;
  const {
    visitors: {
      document: {
        objects: {
          OAuthFlows: {
            $visitor: BaseOAuthFlowsVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const OAuthFlowsVisitor = stampit(BaseOAuthFlowsVisitor, {
    init() {
      this.element = new OAuthFlowsElement();
    }
  });
  const OAuthFlowsVisitor$1 = OAuthFlowsVisitor;
  const {
    visitors: {
      document: {
        objects: {
          OAuthFlow: {
            $visitor: BaseOAuthFlowVisitor
          }
        }
      }
    }
  } = OpenApi3_1Specification;
  const OAuthFlowVisitor = stampit(BaseOAuthFlowVisitor, {
    init() {
      this.element = new OAuthFlowElement();
    }
  });
  const OAuthFlowVisitor$1 = OAuthFlowVisitor;
  const WebhooksVisitor = stampit(MapVisitor$1, FallbackVisitor$1, {
    props: {
      specPath: (element) => {
        return isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "PathItem"];
      }
    },
    init() {
      this.element = new WebhooksElement();
    },
    methods: {
      ObjectElement(objectElement) {
        const result = MapVisitor$1.compose.methods.ObjectElement.call(this, objectElement);
        this.element.filter(isReferenceElement).forEach((referenceElement) => {
          referenceElement.setMetaProperty("referenced-element", "pathItem");
        });
        this.element.filter(isPathItemElement).forEach((pathItemElement, key) => {
          pathItemElement.setMetaProperty("webhook-name", toValue(key));
        });
        return result;
      }
    }
  });
  const WebhooksVisitor$1 = WebhooksVisitor;
  const specification = {
    visitors: {
      value: OpenApi3_1Specification.visitors.value,
      document: {
        objects: {
          OpenApi: {
            $visitor: OpenApi3_1Visitor$1,
            fixedFields: {
              openapi: OpenApi3_1Specification.visitors.document.objects.OpenApi.fixedFields.openapi,
              info: {
                $ref: "#/visitors/document/objects/Info"
              },
              jsonSchemaDialect: JsonSchemaDialectVisitor$1,
              servers: OpenApi3_1Specification.visitors.document.objects.OpenApi.fixedFields.servers,
              paths: {
                $ref: "#/visitors/document/objects/Paths"
              },
              webhooks: WebhooksVisitor$1,
              components: {
                $ref: "#/visitors/document/objects/Components"
              },
              security: OpenApi3_1Specification.visitors.document.objects.OpenApi.fixedFields.security,
              tags: OpenApi3_1Specification.visitors.document.objects.OpenApi.fixedFields.tags,
              externalDocs: {
                $ref: "#/visitors/document/objects/ExternalDocumentation"
              }
            }
          },
          Info: {
            $visitor: InfoVisitor$1,
            fixedFields: {
              title: OpenApi3_1Specification.visitors.document.objects.Info.fixedFields.title,
              description: OpenApi3_1Specification.visitors.document.objects.Info.fixedFields.description,
              summary: InfoSummaryVisitor,
              termsOfService: OpenApi3_1Specification.visitors.document.objects.Info.fixedFields.termsOfService,
              contact: {
                $ref: "#/visitors/document/objects/Contact"
              },
              license: {
                $ref: "#/visitors/document/objects/License"
              },
              version: OpenApi3_1Specification.visitors.document.objects.Info.fixedFields.version
            }
          },
          Contact: {
            $visitor: ContactVisitor$1,
            fixedFields: {
              name: OpenApi3_1Specification.visitors.document.objects.Contact.fixedFields.name,
              url: OpenApi3_1Specification.visitors.document.objects.Contact.fixedFields.url,
              email: OpenApi3_1Specification.visitors.document.objects.Contact.fixedFields.email
            }
          },
          License: {
            $visitor: LicenseVisitor$1,
            fixedFields: {
              name: OpenApi3_1Specification.visitors.document.objects.License.fixedFields.name,
              identifier: LicenseIdentifierVisitor,
              url: OpenApi3_1Specification.visitors.document.objects.License.fixedFields.url
            }
          },
          Server: {
            $visitor: ServerVisitor$1,
            fixedFields: {
              url: OpenApi3_1Specification.visitors.document.objects.Server.fixedFields.url,
              description: OpenApi3_1Specification.visitors.document.objects.Server.fixedFields.description,
              variables: OpenApi3_1Specification.visitors.document.objects.Server.fixedFields.variables
            }
          },
          ServerVariable: {
            $visitor: ServerVariableVisitor$1,
            fixedFields: {
              enum: OpenApi3_1Specification.visitors.document.objects.ServerVariable.fixedFields.enum,
              default: OpenApi3_1Specification.visitors.document.objects.ServerVariable.fixedFields.default,
              description: OpenApi3_1Specification.visitors.document.objects.ServerVariable.fixedFields.description
            }
          },
          Components: {
            $visitor: ComponentsVisitor$1,
            fixedFields: {
              schemas: ComponentsSchemasVisitor,
              responses: OpenApi3_1Specification.visitors.document.objects.Components.fixedFields.responses,
              parameters: OpenApi3_1Specification.visitors.document.objects.Components.fixedFields.parameters,
              examples: OpenApi3_1Specification.visitors.document.objects.Components.fixedFields.examples,
              requestBodies: OpenApi3_1Specification.visitors.document.objects.Components.fixedFields.requestBodies,
              headers: OpenApi3_1Specification.visitors.document.objects.Components.fixedFields.headers,
              securitySchemes: OpenApi3_1Specification.visitors.document.objects.Components.fixedFields.securitySchemes,
              links: OpenApi3_1Specification.visitors.document.objects.Components.fixedFields.links,
              callbacks: OpenApi3_1Specification.visitors.document.objects.Components.fixedFields.callbacks,
              pathItems: ComponentsPathItemsVisitor
            }
          },
          Paths: {
            $visitor: PathsVisitor$1
          },
          PathItem: {
            $visitor: PathItemVisitor$1,
            fixedFields: {
              $ref: OpenApi3_1Specification.visitors.document.objects.PathItem.fixedFields.$ref,
              summary: OpenApi3_1Specification.visitors.document.objects.PathItem.fixedFields.summary,
              description: OpenApi3_1Specification.visitors.document.objects.PathItem.fixedFields.description,
              get: {
                $ref: "#/visitors/document/objects/Operation"
              },
              put: {
                $ref: "#/visitors/document/objects/Operation"
              },
              post: {
                $ref: "#/visitors/document/objects/Operation"
              },
              delete: {
                $ref: "#/visitors/document/objects/Operation"
              },
              options: {
                $ref: "#/visitors/document/objects/Operation"
              },
              head: {
                $ref: "#/visitors/document/objects/Operation"
              },
              patch: {
                $ref: "#/visitors/document/objects/Operation"
              },
              trace: {
                $ref: "#/visitors/document/objects/Operation"
              },
              servers: OpenApi3_1Specification.visitors.document.objects.PathItem.fixedFields.servers,
              parameters: OpenApi3_1Specification.visitors.document.objects.PathItem.fixedFields.parameters
            }
          },
          Operation: {
            $visitor: OperationVisitor$1,
            fixedFields: {
              tags: OpenApi3_1Specification.visitors.document.objects.Operation.fixedFields.tags,
              summary: OpenApi3_1Specification.visitors.document.objects.Operation.fixedFields.summary,
              description: OpenApi3_1Specification.visitors.document.objects.Operation.fixedFields.description,
              externalDocs: {
                $ref: "#/visitors/document/objects/ExternalDocumentation"
              },
              operationId: OpenApi3_1Specification.visitors.document.objects.Operation.fixedFields.operationId,
              parameters: OpenApi3_1Specification.visitors.document.objects.Operation.fixedFields.parameters,
              requestBody: OpenApi3_1Specification.visitors.document.objects.Operation.fixedFields.requestBody,
              responses: {
                $ref: "#/visitors/document/objects/Responses"
              },
              callbacks: OpenApi3_1Specification.visitors.document.objects.Operation.fixedFields.callbacks,
              deprecated: OpenApi3_1Specification.visitors.document.objects.Operation.fixedFields.deprecated,
              security: OpenApi3_1Specification.visitors.document.objects.Operation.fixedFields.security,
              servers: OpenApi3_1Specification.visitors.document.objects.Operation.fixedFields.servers
            }
          },
          ExternalDocumentation: {
            $visitor: ExternalDocumentationVisitor$1,
            fixedFields: {
              description: OpenApi3_1Specification.visitors.document.objects.ExternalDocumentation.fixedFields.description,
              url: OpenApi3_1Specification.visitors.document.objects.ExternalDocumentation.fixedFields.url
            }
          },
          Parameter: {
            $visitor: ParameterVisitor$1,
            fixedFields: {
              name: OpenApi3_1Specification.visitors.document.objects.Parameter.fixedFields.name,
              in: OpenApi3_1Specification.visitors.document.objects.Parameter.fixedFields.in,
              description: OpenApi3_1Specification.visitors.document.objects.Parameter.fixedFields.description,
              required: OpenApi3_1Specification.visitors.document.objects.Parameter.fixedFields.required,
              deprecated: OpenApi3_1Specification.visitors.document.objects.Parameter.fixedFields.deprecated,
              allowEmptyValue: OpenApi3_1Specification.visitors.document.objects.Parameter.fixedFields.allowEmptyValue,
              style: OpenApi3_1Specification.visitors.document.objects.Parameter.fixedFields.style,
              explode: OpenApi3_1Specification.visitors.document.objects.Parameter.fixedFields.explode,
              allowReserved: OpenApi3_1Specification.visitors.document.objects.Parameter.fixedFields.allowReserved,
              schema: {
                $ref: "#/visitors/document/objects/Schema"
              },
              example: OpenApi3_1Specification.visitors.document.objects.Parameter.fixedFields.example,
              examples: OpenApi3_1Specification.visitors.document.objects.Parameter.fixedFields.examples,
              content: OpenApi3_1Specification.visitors.document.objects.Parameter.fixedFields.content
            }
          },
          RequestBody: {
            $visitor: RequestBodyVisitor$1,
            fixedFields: {
              description: OpenApi3_1Specification.visitors.document.objects.RequestBody.fixedFields.description,
              content: OpenApi3_1Specification.visitors.document.objects.RequestBody.fixedFields.content,
              required: OpenApi3_1Specification.visitors.document.objects.RequestBody.fixedFields.required
            }
          },
          MediaType: {
            $visitor: MediaTypeVisitor$1,
            fixedFields: {
              schema: {
                $ref: "#/visitors/document/objects/Schema"
              },
              example: OpenApi3_1Specification.visitors.document.objects.MediaType.fixedFields.example,
              examples: OpenApi3_1Specification.visitors.document.objects.MediaType.fixedFields.examples,
              encoding: OpenApi3_1Specification.visitors.document.objects.MediaType.fixedFields.encoding
            }
          },
          Encoding: {
            $visitor: EncodingVisitor$1,
            fixedFields: {
              contentType: OpenApi3_1Specification.visitors.document.objects.Encoding.fixedFields.contentType,
              headers: OpenApi3_1Specification.visitors.document.objects.Encoding.fixedFields.headers,
              style: OpenApi3_1Specification.visitors.document.objects.Encoding.fixedFields.style,
              explode: OpenApi3_1Specification.visitors.document.objects.Encoding.fixedFields.explode,
              allowReserved: OpenApi3_1Specification.visitors.document.objects.Encoding.fixedFields.allowReserved
            }
          },
          Responses: {
            $visitor: ResponsesVisitor$1,
            fixedFields: {
              default: OpenApi3_1Specification.visitors.document.objects.Responses.fixedFields.default
            }
          },
          Response: {
            $visitor: ResponseVisitor$1,
            fixedFields: {
              description: OpenApi3_1Specification.visitors.document.objects.Response.fixedFields.description,
              headers: OpenApi3_1Specification.visitors.document.objects.Response.fixedFields.headers,
              content: OpenApi3_1Specification.visitors.document.objects.Response.fixedFields.content,
              links: OpenApi3_1Specification.visitors.document.objects.Response.fixedFields.links
            }
          },
          Callback: {
            $visitor: CallbackVisitor$1
          },
          Example: {
            $visitor: ExampleVisitor$1,
            fixedFields: {
              summary: OpenApi3_1Specification.visitors.document.objects.Example.fixedFields.summary,
              description: OpenApi3_1Specification.visitors.document.objects.Example.fixedFields.description,
              value: OpenApi3_1Specification.visitors.document.objects.Example.fixedFields.value,
              externalValue: OpenApi3_1Specification.visitors.document.objects.Example.fixedFields.externalValue
            }
          },
          Link: {
            $visitor: LinkVisitor$1,
            fixedFields: {
              operationRef: OpenApi3_1Specification.visitors.document.objects.Link.fixedFields.operationRef,
              operationId: OpenApi3_1Specification.visitors.document.objects.Link.fixedFields.operationId,
              parameters: OpenApi3_1Specification.visitors.document.objects.Link.fixedFields.parameters,
              requestBody: OpenApi3_1Specification.visitors.document.objects.Link.fixedFields.requestBody,
              description: OpenApi3_1Specification.visitors.document.objects.Link.fixedFields.description,
              server: {
                $ref: "#/visitors/document/objects/Server"
              }
            }
          },
          Header: {
            $visitor: HeaderVisitor$1,
            fixedFields: {
              description: OpenApi3_1Specification.visitors.document.objects.Header.fixedFields.description,
              required: OpenApi3_1Specification.visitors.document.objects.Header.fixedFields.required,
              deprecated: OpenApi3_1Specification.visitors.document.objects.Header.fixedFields.deprecated,
              allowEmptyValue: OpenApi3_1Specification.visitors.document.objects.Header.fixedFields.allowEmptyValue,
              style: OpenApi3_1Specification.visitors.document.objects.Header.fixedFields.style,
              explode: OpenApi3_1Specification.visitors.document.objects.Header.fixedFields.explode,
              allowReserved: OpenApi3_1Specification.visitors.document.objects.Header.fixedFields.allowReserved,
              schema: {
                $ref: "#/visitors/document/objects/Schema"
              },
              example: OpenApi3_1Specification.visitors.document.objects.Header.fixedFields.example,
              examples: OpenApi3_1Specification.visitors.document.objects.Header.fixedFields.examples,
              content: OpenApi3_1Specification.visitors.document.objects.Header.fixedFields.content
            }
          },
          Tag: {
            $visitor: TagVisitor$1,
            fixedFields: {
              name: OpenApi3_1Specification.visitors.document.objects.Tag.fixedFields.name,
              description: OpenApi3_1Specification.visitors.document.objects.Tag.fixedFields.description,
              externalDocs: {
                $ref: "#/visitors/document/objects/ExternalDocumentation"
              }
            }
          },
          Reference: {
            $visitor: ReferenceVisitor$1,
            fixedFields: {
              $ref: OpenApi3_1Specification.visitors.document.objects.Reference.fixedFields.$ref,
              summary: ReferenceSummaryVisitor,
              description: ReferenceDescriptionVisitor
            }
          },
          Schema: {
            $visitor: SchemaVisitor$1,
            fixedFields: {
              // core vocabulary
              $schema: Schema$schemaVisitor,
              $vocabulary: Schema$vocabularyVisitor,
              $id: Schema$idVisitor,
              $anchor: Schema$anchorVisitor,
              $dynamicAnchor: Schema$dynamicAnchorVisitor,
              $dynamicRef: Schema$dynamicRefVisitor,
              $ref: Schema$refVisitor,
              $defs: Schema$defsVisitor,
              $comment: Schema$commentVisitor,
              // applicator vocabulary
              allOf: SchemaAllOfVisitor,
              anyOf: SchemaAnyOfVisitor,
              oneOf: SchemaOneOfVisitor,
              not: {
                $ref: "#/visitors/document/objects/Schema"
              },
              if: {
                $ref: "#/visitors/document/objects/Schema"
              },
              then: {
                $ref: "#/visitors/document/objects/Schema"
              },
              else: {
                $ref: "#/visitors/document/objects/Schema"
              },
              dependentSchemas: SchemaDependantSchemasVisitor,
              prefixItems: SchemaPrefixItemsVisitor,
              items: {
                $ref: "#/visitors/document/objects/Schema"
              },
              contains: {
                $ref: "#/visitors/document/objects/Schema"
              },
              properties: SchemaPropertiesVisitor,
              patternProperties: SchemaPatternPropertiesVisitor,
              additionalProperties: {
                $ref: "#/visitors/document/objects/Schema"
              },
              propertyNames: {
                $ref: "#/visitors/document/objects/Schema"
              },
              // unevaluated Locations vocabulary
              unevaluatedItems: {
                $ref: "#/visitors/document/objects/Schema"
              },
              unevaluatedProperties: {
                $ref: "#/visitors/document/objects/Schema"
              },
              // validation vocabulary
              // validation Keywords for Any Instance Type
              type: SchemaTypeVisitor,
              enum: SchemaEnumVisitor,
              const: SchemaConstVisitor,
              // validation Keywords for Numeric Instances (number and integer)
              multipleOf: SchemaMultipleOfVisitor,
              maximum: SchemaMaximumVisitor,
              exclusiveMaximum: SchemaExclusiveMaximumVisitor,
              minimum: SchemaMinimumVisitor,
              exclusiveMinimum: SchemaExclusiveMinimumVisitor,
              // validation Keywords for Strings
              maxLength: SchemaMaxLengthVisitor,
              minLength: SchemaMinLengthVisitor,
              pattern: SchemaPatternVisitor,
              // validation Keywords for Arrays
              maxItems: SchemaMaxItemsVisitor,
              minItems: SchemaMinItemsVisitor,
              uniqueItems: SchemaUniqueItemsVisitor,
              maxContains: SchemaMaxContainsVisitor,
              minContains: SchemaMinContainsVisitor,
              // validation Keywords for Objects
              maxProperties: SchemaMaxPropertiesVisitor,
              minProperties: SchemaMinPropertiesVisitor,
              required: SchemaRequiredVisitor,
              dependentRequired: SchemaDependentRequiredVisitor,
              // basic Meta-Data Annotations vocabulary
              title: SchemaTitleVisitor,
              description: SchemaDescriptionVisitor,
              default: SchemaDefaultVisitor,
              deprecated: SchemaDeprecatedVisitor,
              readOnly: SchemaReadOnlyVisitor,
              writeOnly: SchemaWriteOnlyVisitor,
              examples: SchemaExamplesVisitor,
              // semantic Content With "format" vocabulary
              format: SchemaFormatVisitor,
              // contents of String-Encoded Data vocabulary
              contentEncoding: SchemaContentEncodingVisitor,
              contentMediaType: SchemaContentMediaTypeVisitor,
              contentSchema: {
                $ref: "#/visitors/document/objects/Schema"
              },
              // OAS base vocabulary
              discriminator: {
                $ref: "#/visitors/document/objects/Discriminator"
              },
              xml: {
                $ref: "#/visitors/document/objects/XML"
              },
              externalDocs: {
                $ref: "#/visitors/document/objects/ExternalDocumentation"
              },
              example: SchemaExampleVisitor
            }
          },
          Discriminator: {
            $visitor: DiscriminatorVisitor$1,
            fixedFields: {
              propertyName: OpenApi3_1Specification.visitors.document.objects.Discriminator.fixedFields.propertyName,
              mapping: OpenApi3_1Specification.visitors.document.objects.Discriminator.fixedFields.mapping
            }
          },
          XML: {
            $visitor: XmlVisitor$1,
            fixedFields: {
              name: OpenApi3_1Specification.visitors.document.objects.XML.fixedFields.name,
              namespace: OpenApi3_1Specification.visitors.document.objects.XML.fixedFields.namespace,
              prefix: OpenApi3_1Specification.visitors.document.objects.XML.fixedFields.prefix,
              attribute: OpenApi3_1Specification.visitors.document.objects.XML.fixedFields.attribute,
              wrapped: OpenApi3_1Specification.visitors.document.objects.XML.fixedFields.wrapped
            }
          },
          SecurityScheme: {
            $visitor: SecuritySchemeVisitor$1,
            fixedFields: {
              type: OpenApi3_1Specification.visitors.document.objects.SecurityScheme.fixedFields.type,
              description: OpenApi3_1Specification.visitors.document.objects.SecurityScheme.fixedFields.description,
              name: OpenApi3_1Specification.visitors.document.objects.SecurityScheme.fixedFields.name,
              in: OpenApi3_1Specification.visitors.document.objects.SecurityScheme.fixedFields.in,
              scheme: OpenApi3_1Specification.visitors.document.objects.SecurityScheme.fixedFields.scheme,
              bearerFormat: OpenApi3_1Specification.visitors.document.objects.SecurityScheme.fixedFields.bearerFormat,
              flows: {
                $ref: "#/visitors/document/objects/OAuthFlows"
              },
              openIdConnectUrl: OpenApi3_1Specification.visitors.document.objects.SecurityScheme.fixedFields.openIdConnectUrl
            }
          },
          OAuthFlows: {
            $visitor: OAuthFlowsVisitor$1,
            fixedFields: {
              implicit: {
                $ref: "#/visitors/document/objects/OAuthFlow"
              },
              password: {
                $ref: "#/visitors/document/objects/OAuthFlow"
              },
              clientCredentials: {
                $ref: "#/visitors/document/objects/OAuthFlow"
              },
              authorizationCode: {
                $ref: "#/visitors/document/objects/OAuthFlow"
              }
            }
          },
          OAuthFlow: {
            $visitor: OAuthFlowVisitor$1,
            fixedFields: {
              authorizationUrl: OpenApi3_1Specification.visitors.document.objects.OAuthFlow.fixedFields.authorizationUrl,
              tokenUrl: OpenApi3_1Specification.visitors.document.objects.OAuthFlow.fixedFields.tokenUrl,
              refreshUrl: OpenApi3_1Specification.visitors.document.objects.OAuthFlow.fixedFields.refreshUrl,
              scopes: OpenApi3_1Specification.visitors.document.objects.OAuthFlow.fixedFields.scopes
            }
          },
          SecurityRequirement: {
            $visitor: SecurityRequirementVisitor$1
          }
        },
        extension: {
          $visitor: OpenApi3_1Specification.visitors.document.extension.$visitor
        }
      }
    }
  };
  const specification$1 = specification;
  const refract = (value2, {
    specPath = ["visitors", "document", "objects", "OpenApi", "$visitor"],
    plugins: plugins2 = []
  } = {}) => {
    const element = refract$4(value2);
    const resolvedSpec = dereference(specification$1);
    const rootVisitor = invokeArgs$1(specPath, [], resolvedSpec);
    visit$1(element, rootVisitor, {
      state: {
        specObj: resolvedSpec
      }
    });
    return dispatchPlugins(rootVisitor.element, plugins2, {
      toolboxCreator: createToolbox$1,
      visitorOptions: {
        keyMap,
        nodeTypeGetter: getNodeType
      }
    });
  };
  const createRefractor = (specPath) => (value2, options = {}) => refract(value2, {
    specPath,
    ...options
  });
  CallbackElement.refract = createRefractor(["visitors", "document", "objects", "Callback", "$visitor"]);
  ComponentsElement.refract = createRefractor(["visitors", "document", "objects", "Components", "$visitor"]);
  ContactElement.refract = createRefractor(["visitors", "document", "objects", "Contact", "$visitor"]);
  ExampleElement.refract = createRefractor(["visitors", "document", "objects", "Example", "$visitor"]);
  DiscriminatorElement.refract = createRefractor(["visitors", "document", "objects", "Discriminator", "$visitor"]);
  EncodingElement.refract = createRefractor(["visitors", "document", "objects", "Encoding", "$visitor"]);
  ExternalDocumentationElement.refract = createRefractor(["visitors", "document", "objects", "ExternalDocumentation", "$visitor"]);
  HeaderElement.refract = createRefractor(["visitors", "document", "objects", "Header", "$visitor"]);
  InfoElement.refract = createRefractor(["visitors", "document", "objects", "Info", "$visitor"]);
  JsonSchemaDialectElement.refract = createRefractor(["visitors", "document", "objects", "OpenApi", "fixedFields", "jsonSchemaDialect"]);
  LicenseElement.refract = createRefractor(["visitors", "document", "objects", "License", "$visitor"]);
  LinkElement.refract = createRefractor(["visitors", "document", "objects", "Link", "$visitor"]);
  MediaTypeElement.refract = createRefractor(["visitors", "document", "objects", "MediaType", "$visitor"]);
  OAuthFlowElement.refract = createRefractor(["visitors", "document", "objects", "OAuthFlow", "$visitor"]);
  OAuthFlowsElement.refract = createRefractor(["visitors", "document", "objects", "OAuthFlows", "$visitor"]);
  OpenapiElement.refract = createRefractor(["visitors", "document", "objects", "OpenApi", "fixedFields", "openapi"]);
  OpenApi3_1Element.refract = createRefractor(["visitors", "document", "objects", "OpenApi", "$visitor"]);
  OperationElement.refract = createRefractor(["visitors", "document", "objects", "Operation", "$visitor"]);
  ParameterElement.refract = createRefractor(["visitors", "document", "objects", "Parameter", "$visitor"]);
  PathItemElement.refract = createRefractor(["visitors", "document", "objects", "PathItem", "$visitor"]);
  PathsElement.refract = createRefractor(["visitors", "document", "objects", "Paths", "$visitor"]);
  ReferenceElement.refract = createRefractor(["visitors", "document", "objects", "Reference", "$visitor"]);
  RequestBodyElement.refract = createRefractor(["visitors", "document", "objects", "RequestBody", "$visitor"]);
  ResponseElement.refract = createRefractor(["visitors", "document", "objects", "Response", "$visitor"]);
  ResponsesElement.refract = createRefractor(["visitors", "document", "objects", "Responses", "$visitor"]);
  SchemaElement.refract = createRefractor(["visitors", "document", "objects", "Schema", "$visitor"]);
  SecurityRequirementElement.refract = createRefractor(["visitors", "document", "objects", "SecurityRequirement", "$visitor"]);
  SecuritySchemeElement.refract = createRefractor(["visitors", "document", "objects", "SecurityScheme", "$visitor"]);
  ServerElement.refract = createRefractor(["visitors", "document", "objects", "Server", "$visitor"]);
  ServerVariableElement.refract = createRefractor(["visitors", "document", "objects", "ServerVariable", "$visitor"]);
  TagElement.refract = createRefractor(["visitors", "document", "objects", "Tag", "$visitor"]);
  XmlElement.refract = createRefractor(["visitors", "document", "objects", "XML", "$visitor"]);
  const BinaryParser = stampit(Parser$1, {
    props: {
      name: "binary"
    },
    methods: {
      async canParse(file) {
        const hasSupportedFileExtension = this.fileExtensions.length === 0 ? true : this.fileExtensions.includes(file.extension);
        return hasSupportedFileExtension;
      },
      async parse(file) {
        try {
          const binaryString = unescape(encodeURIComponent(file.toString()));
          const base64String = btoa(binaryString);
          const parseResultElement = new ParseResultElement();
          if (base64String.length !== 0) {
            const base64StringElement = new StringElement(base64String);
            base64StringElement.classes.push("result");
            parseResultElement.push(base64StringElement);
          }
          return parseResultElement;
        } catch (error) {
          throw new ParserError$1(`Error parsing "${file.uri}"`, {
            cause: error
          });
        }
      }
    }
  });
  const BinaryParser$1 = BinaryParser;
  class EvaluationJsonSchemaUriError extends ApiDOMError$1 {
  }
  class EvaluationJsonSchema$anchorError extends ApiDOMError$1 {
  }
  class InvalidJsonSchema$anchorError extends InvalidSelectorError$1 {
    constructor(anchor) {
      super(`Invalid JSON Schema $anchor "${anchor}".`);
    }
  }
  const isAnchor = (uri) => {
    return /^[A-Za-z_][A-Za-z_0-9.-]*$/.test(uri);
  };
  const uriToAnchor = (uri) => {
    const hash2 = getHash$1(uri);
    return trimCharsStart$1("#", hash2);
  };
  const parse$2 = (anchor) => {
    if (!isAnchor(anchor)) {
      throw new InvalidJsonSchema$anchorError(anchor);
    }
    return anchor;
  };
  const evaluate$1 = (anchor, element) => {
    const token = parse$2(anchor);
    const result = find$2((e) => isSchemaElement(e) && toValue(e.$anchor) === token, element);
    if (isUndefined$1(result)) {
      throw new EvaluationJsonSchema$anchorError(`Evaluation failed on token: "${token}"`);
    }
    return result;
  };
  const resolveSchema$refField = (retrievalURI2, schemaElement) => {
    if (typeof schemaElement.$ref === "undefined") {
      return void 0;
    }
    const hash2 = getHash$1(toValue(schemaElement.$ref));
    const inherited$id = toValue(schemaElement.meta.get("inherited$id"));
    const $refBaseURI = reduce$2((acc, uri) => {
      return resolve$2(acc, sanitize(stripHash(uri)));
    }, retrievalURI2, [...inherited$id, toValue(schemaElement.$ref)]);
    return `${$refBaseURI}${hash2 === "#" ? "" : hash2}`;
  };
  const resolveSchema$idField = (retrievalURI2, schemaElement) => {
    if (typeof schemaElement.$id === "undefined") {
      return void 0;
    }
    const inherited$id = toValue(schemaElement.meta.get("inherited$id"));
    return reduce$2((acc, $id) => {
      return resolve$2(acc, sanitize(stripHash($id)));
    }, retrievalURI2, [...inherited$id, toValue(schemaElement.$id)]);
  };
  const refractToSchemaElement = (element) => {
    if (refractToSchemaElement.cache.has(element)) {
      return refractToSchemaElement.cache.get(element);
    }
    const refracted = SchemaElement.refract(element);
    refractToSchemaElement.cache.set(element, refracted);
    return refracted;
  };
  refractToSchemaElement.cache = /* @__PURE__ */ new WeakMap();
  const maybeRefractToSchemaElement = (element) => {
    if (isPrimitiveElement(element)) {
      return refractToSchemaElement(element);
    }
    return element;
  };
  const evaluate = (uri, element) => {
    const {
      cache
    } = evaluate;
    const uriStrippedHash = stripHash(uri);
    const isSchemaElementWith$id = (e) => isSchemaElement(e) && typeof e.$id !== "undefined";
    if (!cache.has(element)) {
      const schemaObjectElements = filter$3(isSchemaElementWith$id, element);
      cache.set(element, Array.from(schemaObjectElements));
    }
    const result = cache.get(element).find((e) => {
      const $idBaseURI = resolveSchema$idField(uriStrippedHash, e);
      return $idBaseURI === uriStrippedHash;
    });
    if (isUndefined$1(result)) {
      throw new EvaluationJsonSchemaUriError(`Evaluation failed on URI: "${uri}"`);
    }
    let fragmentEvaluate;
    let selector;
    if (isAnchor(uriToAnchor(uri))) {
      fragmentEvaluate = evaluate$1;
      selector = uriToAnchor(uri);
    } else {
      fragmentEvaluate = jsonPointerEvaluate;
      selector = uriToPointer(uri);
    }
    return fragmentEvaluate(selector, result);
  };
  evaluate.cache = /* @__PURE__ */ new WeakMap();
  const visitAsync$5 = visit$1[Symbol.for("nodejs.util.promisify.custom")];
  const OpenApi3_1ResolveVisitor = stampit({
    props: {
      indirections: [],
      namespace: null,
      reference: null,
      crawledElements: null,
      crawlingMap: null,
      visited: null,
      options: null
    },
    init({
      reference,
      namespace: namespace2,
      indirections = [],
      visited = /* @__PURE__ */ new WeakSet(),
      options
    }) {
      this.indirections = indirections;
      this.namespace = namespace2;
      this.reference = reference;
      this.crawledElements = [];
      this.crawlingMap = {};
      this.visited = visited;
      this.options = options;
    },
    methods: {
      toBaseURI(uri) {
        return resolve$2(this.reference.uri, sanitize(stripHash(uri)));
      },
      async toReference(uri) {
        if (this.reference.depth >= this.options.resolve.maxDepth) {
          throw new MaximumResolverDepthError$1(`Maximum resolution depth of ${this.options.resolve.maxDepth} has been exceeded by file "${this.reference.uri}"`);
        }
        const baseURI = this.toBaseURI(uri);
        const {
          refSet
        } = this.reference;
        if (refSet.has(baseURI)) {
          return refSet.find(propEq$1(baseURI, "uri"));
        }
        const parseResult = await parse$5(unsanitize(baseURI), {
          ...this.options,
          parse: {
            ...this.options.parse,
            mediaType: "text/plain"
          }
        });
        const reference = Reference$3({
          uri: baseURI,
          value: parseResult,
          depth: this.reference.depth + 1
        });
        refSet.add(reference);
        return reference;
      },
      ReferenceElement(referenceElement) {
        if (!this.options.resolve.external && isReferenceElementExternal(referenceElement)) {
          return false;
        }
        const uri = toValue(referenceElement.$ref);
        const baseURI = this.toBaseURI(uri);
        if (!has$2(baseURI, this.crawlingMap)) {
          this.crawlingMap[baseURI] = this.toReference(uri);
        }
        this.crawledElements.push(referenceElement);
        return void 0;
      },
      PathItemElement(pathItemElement) {
        if (!isStringElement(pathItemElement.$ref)) {
          return void 0;
        }
        if (!this.options.resolve.external && isPathItemElementExternal(pathItemElement)) {
          return void 0;
        }
        const uri = toValue(pathItemElement.$ref);
        const baseURI = this.toBaseURI(uri);
        if (!has$2(baseURI, this.crawlingMap)) {
          this.crawlingMap[baseURI] = this.toReference(uri);
        }
        this.crawledElements.push(pathItemElement);
        return void 0;
      },
      LinkElement(linkElement) {
        if (!isStringElement(linkElement.operationRef) && !isStringElement(linkElement.operationId)) {
          return void 0;
        }
        if (!this.options.resolve.external && isLinkElementExternal(linkElement)) {
          return void 0;
        }
        if (isStringElement(linkElement.operationRef) && isStringElement(linkElement.operationId)) {
          throw new Error("LinkElement operationRef and operationId are mutually exclusive.");
        }
        if (isLinkElementExternal(linkElement)) {
          const uri = toValue(linkElement.operationRef);
          const baseURI = this.toBaseURI(uri);
          if (!has$2(baseURI, this.crawlingMap)) {
            this.crawlingMap[baseURI] = this.toReference(uri);
          }
        }
        return void 0;
      },
      ExampleElement(exampleElement) {
        if (!isStringElement(exampleElement.externalValue)) {
          return void 0;
        }
        if (!this.options.resolve.external && isStringElement(exampleElement.externalValue)) {
          return void 0;
        }
        if (exampleElement.hasKey("value") && isStringElement(exampleElement.externalValue)) {
          throw new Error("ExampleElement value and externalValue fields are mutually exclusive.");
        }
        const uri = toValue(exampleElement.externalValue);
        const baseURI = this.toBaseURI(uri);
        if (!has$2(baseURI, this.crawlingMap)) {
          this.crawlingMap[baseURI] = this.toReference(uri);
        }
        return void 0;
      },
      async SchemaElement(schemaElement) {
        if (this.visited.has(schemaElement)) {
          return false;
        }
        if (!isStringElement(schemaElement.$ref)) {
          this.visited.add(schemaElement);
          return void 0;
        }
        const reference = await this.toReference(unsanitize(this.reference.uri));
        const {
          uri: retrievalURI2
        } = reference;
        const $refBaseURI = resolveSchema$refField(retrievalURI2, schemaElement);
        const $refBaseURIStrippedHash = stripHash($refBaseURI);
        const file = File$2({
          uri: $refBaseURIStrippedHash
        });
        const isUnknownURI = none$1((r) => r.canRead(file), this.options.resolve.resolvers);
        const isURL = !isUnknownURI;
        const isExternal = !isUnknownURI && retrievalURI2 !== $refBaseURIStrippedHash;
        if (!this.options.resolve.external && isExternal) {
          this.visited.add(schemaElement);
          return void 0;
        }
        if (!has$2($refBaseURIStrippedHash, this.crawlingMap)) {
          try {
            if (isUnknownURI || isURL) {
              this.crawlingMap[$refBaseURIStrippedHash] = reference;
            } else {
              this.crawlingMap[$refBaseURIStrippedHash] = this.toReference(unsanitize($refBaseURI));
            }
          } catch (error) {
            if (isURL && error instanceof EvaluationJsonSchemaUriError) {
              this.crawlingMap[$refBaseURIStrippedHash] = this.toReference(unsanitize($refBaseURI));
            } else {
              throw error;
            }
          }
        }
        this.crawledElements.push(schemaElement);
        return void 0;
      },
      async crawlReferenceElement(referenceElement) {
        const reference = await this.toReference(toValue(referenceElement.$ref));
        this.indirections.push(referenceElement);
        const jsonPointer = uriToPointer(toValue(referenceElement.$ref));
        let fragment = jsonPointerEvaluate(jsonPointer, reference.value.result);
        if (isPrimitiveElement(fragment)) {
          const referencedElementType = toValue(referenceElement.meta.get("referenced-element"));
          if (isReferenceLikeElement(fragment)) {
            fragment = ReferenceElement.refract(fragment);
            fragment.setMetaProperty("referenced-element", referencedElementType);
          } else {
            const ElementClass = this.namespace.getElementClass(referencedElementType);
            fragment = ElementClass.refract(fragment);
          }
        }
        if (this.indirections.includes(fragment)) {
          throw new Error("Recursive Reference Object detected");
        }
        if (this.indirections.length > this.options.dereference.maxDepth) {
          throw new MaximumDereferenceDepthError$1(`Maximum dereference depth of "${this.options.dereference.maxDepth}" has been exceeded in file "${this.reference.uri}"`);
        }
        const visitor2 = OpenApi3_1ResolveVisitor({
          reference,
          namespace: this.namespace,
          indirections: [...this.indirections],
          options: this.options
        });
        await visitAsync$5(fragment, visitor2, {
          keyMap,
          nodeTypeGetter: getNodeType
        });
        await visitor2.crawl();
        this.indirections.pop();
      },
      async crawlPathItemElement(pathItemElement) {
        const reference = await this.toReference(toValue(pathItemElement.$ref));
        this.indirections.push(pathItemElement);
        const jsonPointer = uriToPointer(toValue(pathItemElement.$ref));
        let referencedElement = jsonPointerEvaluate(jsonPointer, reference.value.result);
        if (isPrimitiveElement(referencedElement)) {
          referencedElement = PathItemElement.refract(referencedElement);
        }
        if (this.indirections.includes(referencedElement)) {
          throw new Error("Recursive Path Item Object reference detected");
        }
        if (this.indirections.length > this.options.dereference.maxDepth) {
          throw new MaximumDereferenceDepthError$1(`Maximum dereference depth of "${this.options.dereference.maxDepth}" has been exceeded in file "${this.reference.uri}"`);
        }
        const visitor2 = OpenApi3_1ResolveVisitor({
          reference,
          namespace: this.namespace,
          indirections: [...this.indirections],
          options: this.options
        });
        await visitAsync$5(referencedElement, visitor2, {
          keyMap,
          nodeTypeGetter: getNodeType
        });
        await visitor2.crawl();
        this.indirections.pop();
      },
      async crawlSchemaElement(referencingElement) {
        let reference = await this.toReference(unsanitize(this.reference.uri));
        const {
          uri: retrievalURI2
        } = reference;
        const $refBaseURI = resolveSchema$refField(retrievalURI2, referencingElement);
        const $refBaseURIStrippedHash = stripHash($refBaseURI);
        const file = File$2({
          uri: $refBaseURIStrippedHash
        });
        const isUnknownURI = none$1((r) => r.canRead(file), this.options.resolve.resolvers);
        const isURL = !isUnknownURI;
        this.indirections.push(referencingElement);
        let referencedElement;
        try {
          if (isUnknownURI || isURL) {
            const selector = $refBaseURI;
            referencedElement = evaluate(
              selector,
              // @ts-ignore
              maybeRefractToSchemaElement(reference.value.result)
            );
          } else {
            reference = await this.toReference(unsanitize($refBaseURI));
            const selector = uriToPointer($refBaseURI);
            referencedElement = maybeRefractToSchemaElement(
              // @ts-ignore
              jsonPointerEvaluate(selector, reference.value.result)
            );
          }
        } catch (error) {
          if (isURL && error instanceof EvaluationJsonSchemaUriError) {
            if (isAnchor(uriToAnchor($refBaseURI))) {
              reference = await this.toReference(unsanitize($refBaseURI));
              const selector = uriToAnchor($refBaseURI);
              referencedElement = evaluate$1(
                selector,
                // @ts-ignore
                maybeRefractToSchemaElement(reference.value.result)
              );
            } else {
              reference = await this.toReference(unsanitize($refBaseURI));
              const selector = uriToPointer($refBaseURI);
              referencedElement = maybeRefractToSchemaElement(
                // @ts-ignore
                jsonPointerEvaluate(selector, reference.value.result)
              );
            }
          } else {
            throw error;
          }
        }
        this.visited.add(referencingElement);
        if (this.indirections.includes(referencedElement)) {
          throw new Error("Recursive Schema Object reference detected");
        }
        if (this.indirections.length > this.options.dereference.maxDepth) {
          throw new MaximumDereferenceDepthError$1(`Maximum dereference depth of "${this.options.dereference.maxDepth}" has been exceeded in file "${this.reference.uri}"`);
        }
        const visitor2 = OpenApi3_1ResolveVisitor({
          reference,
          namespace: this.namespace,
          indirections: [...this.indirections],
          options: this.options,
          visited: this.visited
        });
        await visitAsync$5(referencedElement, visitor2, {
          keyMap,
          nodeTypeGetter: getNodeType
        });
        await visitor2.crawl();
        this.indirections.pop();
      },
      async crawl() {
        await pipe$2(values$1, allP$1)(this.crawlingMap);
        this.crawlingMap = null;
        for (const element of this.crawledElements) {
          if (isReferenceElement(element)) {
            await this.crawlReferenceElement(element);
          } else if (isSchemaElement(element)) {
            await this.crawlSchemaElement(element);
          } else if (isPathItemElement(element)) {
            await this.crawlPathItemElement(element);
          }
        }
      }
    }
  });
  const OpenApi3_1ResolveVisitor$1 = OpenApi3_1ResolveVisitor;
  const visitAsync$4 = visit$1[Symbol.for("nodejs.util.promisify.custom")];
  const OpenApi3_1ResolveStrategy = stampit(ResolveStrategy$1, {
    init() {
      this.name = "openapi-3-1";
    },
    methods: {
      canResolve(file) {
        var _file$parseResult;
        if (file.mediaType !== "text/plain") {
          return mediaTypes$1.includes(file.mediaType);
        }
        return isOpenApi3_1Element((_file$parseResult = file.parseResult) === null || _file$parseResult === void 0 ? void 0 : _file$parseResult.result);
      },
      async resolve(file, options) {
        const namespace2 = createNamespace(openApi3_1Namespace);
        const reference = Reference$3({
          uri: file.uri,
          value: file.parseResult
        });
        const visitor2 = OpenApi3_1ResolveVisitor$1({
          reference,
          namespace: namespace2,
          options
        });
        const refSet = ReferenceSet$1();
        refSet.add(reference);
        await visitAsync$4(refSet.rootRef.value, visitor2, {
          keyMap,
          nodeTypeGetter: getNodeType
        });
        await visitor2.crawl();
        return refSet;
      }
    }
  });
  const OpenApi3_1ResolveStrategy$1 = OpenApi3_1ResolveStrategy;
  const normalize = (element) => {
    if (!isObjectElement(element))
      return element;
    if (element.hasKey("$$normalized"))
      return element;
    const plugins2 = [refractorPluginNormalizeOperationIds({
      operationIdNormalizer: (operationId, path2, method) => opId({
        operationId
      }, path2, method, {
        v2OperationIdCompatibilityMode: false
      })
    }), refractorPluginNormalizeParameters(), refractorPluginNormalizeSecurityRequirements(), refractorPluginNormalizeServers(), refractorPluginNormalizeParameterExamples(), refractorPluginNormalizeHeaderExamples()];
    const normalized = dispatchPlugins(element, plugins2, {
      toolboxCreator: createToolbox$1,
      visitorOptions: {
        keyMap,
        nodeTypeGetter: getNodeType
      }
    });
    normalized.set("$$normalized", true);
    return normalized;
  };
  const pojoAdapter = (normalizeFn) => (spec) => {
    if (spec !== null && spec !== void 0 && spec.$$normalized)
      return spec;
    if (pojoAdapter.cache.has(spec))
      return spec;
    const openApiElement = OpenApi3_1Element.refract(spec);
    const normalized = normalizeFn(openApiElement);
    const value2 = toValue(normalized);
    pojoAdapter.cache.set(spec, value2);
    return value2;
  };
  pojoAdapter.cache = /* @__PURE__ */ new WeakMap();
  const {
    AbortController: AbortController$1,
    AbortSignal
  } = globalThis;
  if (typeof globalThis.AbortController === "undefined") {
    globalThis.AbortController = AbortController$1;
  }
  if (typeof globalThis.AbortSignal === "undefined") {
    globalThis.AbortSignal = AbortSignal;
  }
  const HttpResolverSwaggerClient = HttpResolver$1.compose({
    props: {
      name: "http-swagger-client",
      swaggerHTTPClient: http,
      swaggerHTTPClientConfig: {}
    },
    init() {
      let {
        swaggerHTTPClient = this.swaggerHTTPClient
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.swaggerHTTPClient = swaggerHTTPClient;
    },
    methods: {
      getHttpClient() {
        return this.swaggerHTTPClient;
      },
      async read(file) {
        const client2 = this.getHttpClient();
        const controller = new AbortController();
        const {
          signal
        } = controller;
        const timeoutID = setTimeout(() => {
          controller.abort();
        }, this.timeout);
        const credentials = this.getHttpClient().withCredentials || this.withCredentials ? "include" : "same-origin";
        const redirect = this.redirects === 0 ? "error" : "follow";
        const follow = this.redirects > 0 ? this.redirects : void 0;
        try {
          const response = await client2({
            url: file.uri,
            signal,
            userFetch: async (resource, options) => {
              let res = await fetch(resource, options);
              try {
                res.headers.delete("Content-Type");
              } catch {
                res = new Response(res.body, {
                  ...res,
                  headers: new Headers(res.headers)
                });
                res.headers.delete("Content-Type");
              }
              return res;
            },
            credentials,
            redirect,
            follow,
            ...this.swaggerHTTPClientConfig
          });
          return response.text.arrayBuffer();
        } catch (error) {
          throw new ResolverError$1(`Error downloading "${file.uri}"`, {
            cause: error
          });
        } finally {
          clearTimeout(timeoutID);
        }
      }
    }
  });
  const JsonParser = Parser$1.compose({
    props: {
      name: "json-swagger-client",
      fileExtensions: [".json"],
      mediaTypes: ["application/json"]
    },
    methods: {
      async canParse(file) {
        const hasSupportedFileExtension = this.fileExtensions.length === 0 ? true : this.fileExtensions.includes(file.extension);
        const hasSupportedMediaType = this.mediaTypes.includes(file.mediaType);
        if (!hasSupportedFileExtension)
          return false;
        if (hasSupportedMediaType)
          return true;
        if (!hasSupportedMediaType) {
          try {
            JSON.parse(file.toString());
            return true;
          } catch (error) {
            return false;
          }
        }
        return false;
      },
      async parse(file) {
        if (this.sourceMap) {
          throw new ParserError$1("json-swagger-client parser plugin doesn't support sourceMaps option");
        }
        const parseResultElement = new ParseResultElement();
        const source = file.toString();
        if (this.allowEmpty && source.trim() === "") {
          return parseResultElement;
        }
        try {
          const element = from$2(JSON.parse(source));
          element.classes.push("result");
          parseResultElement.push(element);
          return parseResultElement;
        } catch (error) {
          throw new ParserError$1(`Error parsing "${file.uri}"`, {
            cause: error
          });
        }
      }
    }
  });
  const YamlParser = Parser$1.compose({
    props: {
      name: "yaml-1-2-swagger-client",
      fileExtensions: [".yaml", ".yml"],
      mediaTypes: ["text/yaml", "application/yaml"]
    },
    methods: {
      async canParse(file) {
        const hasSupportedFileExtension = this.fileExtensions.length === 0 ? true : this.fileExtensions.includes(file.extension);
        const hasSupportedMediaType = this.mediaTypes.includes(file.mediaType);
        if (!hasSupportedFileExtension)
          return false;
        if (hasSupportedMediaType)
          return true;
        if (!hasSupportedMediaType) {
          try {
            jsYaml.load(file.toString(), {
              schema: JSON_SCHEMA
            });
            return true;
          } catch (error) {
            return false;
          }
        }
        return false;
      },
      async parse(file) {
        if (this.sourceMap) {
          throw new ParserError$1("yaml-1-2-swagger-client parser plugin doesn't support sourceMaps option");
        }
        const parseResultElement = new ParseResultElement();
        const source = file.toString();
        try {
          const pojo = jsYaml.load(source, {
            schema: JSON_SCHEMA
          });
          if (this.allowEmpty && typeof pojo === "undefined") {
            return parseResultElement;
          }
          const element = from$2(pojo);
          element.classes.push("result");
          parseResultElement.push(element);
          return parseResultElement;
        } catch (error) {
          throw new ParserError$1(`Error parsing "${file.uri}"`, {
            cause: error
          });
        }
      }
    }
  });
  const OpenApiJson3_1Parser = Parser$1.compose({
    props: {
      name: "openapi-json-3-1-swagger-client",
      fileExtensions: [".json"],
      mediaTypes: new OpenAPIMediaTypes(...mediaTypes$1.filterByFormat("generic"), ...mediaTypes$1.filterByFormat("json")),
      detectionRegExp: /"openapi"\s*:\s*"(?<version_json>3\.1\.(?:[1-9]\d*|0))"/
    },
    methods: {
      async canParse(file) {
        const hasSupportedFileExtension = this.fileExtensions.length === 0 ? true : this.fileExtensions.includes(file.extension);
        const hasSupportedMediaType = this.mediaTypes.includes(file.mediaType);
        if (!hasSupportedFileExtension)
          return false;
        if (hasSupportedMediaType)
          return true;
        if (!hasSupportedMediaType) {
          try {
            const source = file.toString();
            JSON.parse(source);
            return this.detectionRegExp.test(source);
          } catch (error) {
            return false;
          }
        }
        return false;
      },
      async parse(file) {
        if (this.sourceMap) {
          throw new ParserError$1("openapi-json-3-1-swagger-client parser plugin doesn't support sourceMaps option");
        }
        const parseResultElement = new ParseResultElement();
        const source = file.toString();
        if (this.allowEmpty && source.trim() === "") {
          return parseResultElement;
        }
        try {
          const pojo = JSON.parse(source);
          const element = OpenApi3_1Element.refract(pojo, this.refractorOpts);
          element.classes.push("result");
          parseResultElement.push(element);
          return parseResultElement;
        } catch (error) {
          throw new ParserError$1(`Error parsing "${file.uri}"`, {
            cause: error
          });
        }
      }
    }
  });
  const OpenApiYaml3_1Parser = Parser$1.compose({
    props: {
      name: "openapi-yaml-3-1-swagger-client",
      fileExtensions: [".yaml", ".yml"],
      mediaTypes: new OpenAPIMediaTypes(...mediaTypes$1.filterByFormat("generic"), ...mediaTypes$1.filterByFormat("yaml")),
      detectionRegExp: /(?<YAML>^(["']?)openapi\2\s*:\s*(["']?)(?<version_yaml>3\.1\.(?:[1-9]\d*|0))\3(?:\s+|$))|(?<JSON>"openapi"\s*:\s*"(?<version_json>3\.1\.(?:[1-9]\d*|0))")/m
    },
    methods: {
      async canParse(file) {
        const hasSupportedFileExtension = this.fileExtensions.length === 0 ? true : this.fileExtensions.includes(file.extension);
        const hasSupportedMediaType = this.mediaTypes.includes(file.mediaType);
        if (!hasSupportedFileExtension)
          return false;
        if (hasSupportedMediaType)
          return true;
        if (!hasSupportedMediaType) {
          try {
            const source = file.toString();
            jsYaml.load(source);
            return this.detectionRegExp.test(source);
          } catch (error) {
            return false;
          }
        }
        return false;
      },
      async parse(file) {
        if (this.sourceMap) {
          throw new ParserError$1("openapi-yaml-3-1-swagger-client parser plugin doesn't support sourceMaps option");
        }
        const parseResultElement = new ParseResultElement();
        const source = file.toString();
        try {
          const pojo = jsYaml.load(source, {
            schema: JSON_SCHEMA
          });
          if (this.allowEmpty && typeof pojo === "undefined") {
            return parseResultElement;
          }
          const element = OpenApi3_1Element.refract(pojo, this.refractorOpts);
          element.classes.push("result");
          parseResultElement.push(element);
          return parseResultElement;
        } catch (error) {
          throw new ParserError$1(`Error parsing "${file.uri}"`, {
            cause: error
          });
        }
      }
    }
  });
  const visitAsync$3 = visit$1[Symbol.for("nodejs.util.promisify.custom")];
  const OpenApi3_1DereferenceVisitor = stampit({
    props: {
      indirections: null,
      namespace: null,
      reference: null,
      options: null,
      ancestors: null
    },
    init({
      indirections = [],
      reference,
      namespace: namespace2,
      options,
      ancestors = new AncestorLineage()
    }) {
      this.indirections = indirections;
      this.namespace = namespace2;
      this.reference = reference;
      this.options = options;
      this.ancestors = new AncestorLineage(...ancestors);
    },
    methods: {
      toBaseURI(uri) {
        return resolve$2(this.reference.uri, sanitize(stripHash(uri)));
      },
      async toReference(uri) {
        if (this.reference.depth >= this.options.resolve.maxDepth) {
          throw new MaximumResolverDepthError$1(`Maximum resolution depth of ${this.options.resolve.maxDepth} has been exceeded by file "${this.reference.uri}"`);
        }
        const baseURI = this.toBaseURI(uri);
        const {
          refSet
        } = this.reference;
        if (refSet.has(baseURI)) {
          return refSet.find(propEq$1(baseURI, "uri"));
        }
        const parseResult = await parse$5(unsanitize(baseURI), {
          ...this.options,
          parse: {
            ...this.options.parse,
            mediaType: "text/plain"
          }
        });
        const reference = Reference$3({
          uri: baseURI,
          value: parseResult,
          depth: this.reference.depth + 1
        });
        refSet.add(reference);
        return reference;
      },
      toAncestorLineage(ancestors) {
        const directAncestors = new WeakSet(ancestors.filter(isElement));
        const ancestorsLineage = new AncestorLineage(...this.ancestors, directAncestors);
        return [ancestorsLineage, directAncestors];
      },
      async ReferenceElement(referencingElement, key, parent2, path2, ancestors) {
        const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent2]);
        if (ancestorsLineage.includesCycle(referencingElement)) {
          return false;
        }
        if (!this.options.resolve.external && isReferenceElementExternal(referencingElement)) {
          return false;
        }
        const reference = await this.toReference(toValue(referencingElement.$ref));
        const {
          uri: retrievalURI2
        } = reference;
        const $refBaseURI = resolve$2(retrievalURI2, toValue(referencingElement.$ref));
        this.indirections.push(referencingElement);
        const jsonPointer = uriToPointer($refBaseURI);
        let referencedElement = jsonPointerEvaluate(jsonPointer, reference.value.result);
        if (isPrimitiveElement(referencedElement)) {
          const referencedElementType = toValue(referencingElement.meta.get("referenced-element"));
          if (isReferenceLikeElement(referencedElement)) {
            referencedElement = ReferenceElement.refract(referencedElement);
            referencedElement.setMetaProperty("referenced-element", referencedElementType);
          } else {
            const ElementClass = this.namespace.getElementClass(referencedElementType);
            referencedElement = ElementClass.refract(referencedElement);
          }
        }
        if (this.indirections.includes(referencedElement)) {
          throw new Error("Recursive Reference Object detected");
        }
        if (this.indirections.length > this.options.dereference.maxDepth) {
          throw new MaximumDereferenceDepthError$1(`Maximum dereference depth of "${this.options.dereference.maxDepth}" has been exceeded in file "${this.reference.uri}"`);
        }
        directAncestors.add(referencingElement);
        const visitor2 = OpenApi3_1DereferenceVisitor({
          reference,
          namespace: this.namespace,
          indirections: [...this.indirections],
          options: this.options,
          ancestors: ancestorsLineage
        });
        referencedElement = await visitAsync$3(referencedElement, visitor2, {
          keyMap,
          nodeTypeGetter: getNodeType
        });
        directAncestors.delete(referencingElement);
        this.indirections.pop();
        const mergeAndAnnotateReferencedElement = (refedElement) => {
          const copy2 = cloneShallow(refedElement);
          copy2.setMetaProperty("ref-fields", {
            $ref: toValue(referencingElement.$ref),
            // @ts-ignore
            description: toValue(referencingElement.description),
            // @ts-ignore
            summary: toValue(referencingElement.summary)
          });
          copy2.setMetaProperty("ref-origin", reference.uri);
          if (isObjectElement(refedElement)) {
            if (referencingElement.hasKey("description") && "description" in refedElement) {
              copy2.remove("description");
              copy2.set("description", referencingElement.get("description"));
            }
            if (referencingElement.hasKey("summary") && "summary" in refedElement) {
              copy2.remove("summary");
              copy2.set("summary", referencingElement.get("summary"));
            }
          }
          return copy2;
        };
        if (ancestorsLineage.includes(referencedElement)) {
          if (isMemberElement(parent2)) {
            parent2.value = mergeAndAnnotateReferencedElement(referencedElement);
          } else if (Array.isArray(parent2)) {
            parent2[key] = mergeAndAnnotateReferencedElement(referencedElement);
          }
          return false;
        }
        return mergeAndAnnotateReferencedElement(referencedElement);
      },
      async PathItemElement(referencingElement, key, parent2, path2, ancestors) {
        const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent2]);
        if (!isStringElement(referencingElement.$ref)) {
          return void 0;
        }
        if (ancestorsLineage.includesCycle(referencingElement)) {
          return false;
        }
        if (!this.options.resolve.external && isPathItemElementExternal(referencingElement)) {
          return void 0;
        }
        const reference = await this.toReference(toValue(referencingElement.$ref));
        const {
          uri: retrievalURI2
        } = reference;
        const $refBaseURI = resolve$2(retrievalURI2, toValue(referencingElement.$ref));
        this.indirections.push(referencingElement);
        const jsonPointer = uriToPointer($refBaseURI);
        let referencedElement = jsonPointerEvaluate(jsonPointer, reference.value.result);
        if (isPrimitiveElement(referencedElement)) {
          referencedElement = PathItemElement.refract(referencedElement);
        }
        if (this.indirections.includes(referencedElement)) {
          throw new Error("Recursive Path Item Object reference detected");
        }
        if (this.indirections.length > this.options.dereference.maxDepth) {
          throw new MaximumDereferenceDepthError$1(`Maximum dereference depth of "${this.options.dereference.maxDepth}" has been exceeded in file "${this.reference.uri}"`);
        }
        directAncestors.add(referencingElement);
        const visitor2 = OpenApi3_1DereferenceVisitor({
          reference,
          namespace: this.namespace,
          indirections: [...this.indirections],
          options: this.options,
          ancestors: ancestorsLineage
        });
        referencedElement = await visitAsync$3(referencedElement, visitor2, {
          keyMap,
          nodeTypeGetter: getNodeType
        });
        directAncestors.delete(referencingElement);
        this.indirections.pop();
        const mergeAndAnnotateReferencedElement = (refedElement) => {
          const mergedElement = new PathItemElement([...refedElement.content], cloneDeep(refedElement.meta), cloneDeep(refedElement.attributes));
          referencingElement.forEach((value2, keyElement, item) => {
            mergedElement.remove(toValue(keyElement));
            mergedElement.content.push(item);
          });
          mergedElement.remove("$ref");
          mergedElement.setMetaProperty("ref-fields", {
            $ref: toValue(referencingElement.$ref)
          });
          mergedElement.setMetaProperty("ref-origin", reference.uri);
          return mergedElement;
        };
        if (ancestorsLineage.includes(referencedElement)) {
          if (isMemberElement(parent2)) {
            parent2.value = mergeAndAnnotateReferencedElement(referencedElement);
          } else if (Array.isArray(parent2)) {
            parent2[key] = mergeAndAnnotateReferencedElement(referencedElement);
          }
          return false;
        }
        return mergeAndAnnotateReferencedElement(referencedElement);
      },
      async LinkElement(linkElement) {
        if (!isStringElement(linkElement.operationRef) && !isStringElement(linkElement.operationId)) {
          return void 0;
        }
        if (!this.options.resolve.external && isLinkElementExternal(linkElement)) {
          return void 0;
        }
        if (isStringElement(linkElement.operationRef) && isStringElement(linkElement.operationId)) {
          throw new Error("LinkElement operationRef and operationId fields are mutually exclusive.");
        }
        let operationElement;
        if (isStringElement(linkElement.operationRef)) {
          var _linkElementCopy$oper;
          const jsonPointer = uriToPointer(toValue(linkElement.operationRef));
          const reference = await this.toReference(toValue(linkElement.operationRef));
          operationElement = jsonPointerEvaluate(jsonPointer, reference.value.result);
          if (isPrimitiveElement(operationElement)) {
            operationElement = OperationElement.refract(operationElement);
          }
          operationElement = cloneShallow(operationElement);
          operationElement.setMetaProperty("ref-origin", reference.uri);
          const linkElementCopy = cloneShallow(linkElement);
          (_linkElementCopy$oper = linkElementCopy.operationRef) === null || _linkElementCopy$oper === void 0 || _linkElementCopy$oper.meta.set("operation", operationElement);
          return linkElementCopy;
        }
        if (isStringElement(linkElement.operationId)) {
          var _linkElementCopy$oper2;
          const operationId = toValue(linkElement.operationId);
          const reference = await this.toReference(unsanitize(this.reference.uri));
          operationElement = find$2((e) => isOperationElement(e) && e.operationId.equals(operationId), reference.value.result);
          if (isUndefined$1(operationElement)) {
            throw new Error(`OperationElement(operationId=${operationId}) not found.`);
          }
          const linkElementCopy = cloneShallow(linkElement);
          (_linkElementCopy$oper2 = linkElementCopy.operationId) === null || _linkElementCopy$oper2 === void 0 || _linkElementCopy$oper2.meta.set("operation", operationElement);
          return linkElementCopy;
        }
        return void 0;
      },
      async ExampleElement(exampleElement, key, parent2, path2, ancestors) {
        const [ancestorsLineage] = this.toAncestorLineage([...ancestors, parent2]);
        if (!isStringElement(exampleElement.externalValue)) {
          return void 0;
        }
        if (ancestorsLineage.includesCycle(exampleElement)) {
          return false;
        }
        if (!this.options.resolve.external && isStringElement(exampleElement.externalValue)) {
          return void 0;
        }
        if (exampleElement.hasKey("value") && isStringElement(exampleElement.externalValue)) {
          throw new Error("ExampleElement value and externalValue fields are mutually exclusive.");
        }
        const reference = await this.toReference(toValue(exampleElement.externalValue));
        const valueElement = cloneShallow(reference.value.result);
        valueElement.setMetaProperty("ref-origin", reference.uri);
        const exampleElementCopy = cloneShallow(exampleElement);
        exampleElementCopy.value = valueElement;
        return exampleElementCopy;
      },
      async SchemaElement(referencingElement, key, parent2, path2, ancestors) {
        const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent2]);
        if (!isStringElement(referencingElement.$ref)) {
          return void 0;
        }
        if (ancestorsLineage.includesCycle(referencingElement)) {
          return false;
        }
        let reference = await this.toReference(unsanitize(this.reference.uri));
        let {
          uri: retrievalURI2
        } = reference;
        const $refBaseURI = resolveSchema$refField(retrievalURI2, referencingElement);
        const $refBaseURIStrippedHash = stripHash($refBaseURI);
        const file = File$2({
          uri: $refBaseURIStrippedHash
        });
        const isUnknownURI = none$1((r) => r.canRead(file), this.options.resolve.resolvers);
        const isURL = !isUnknownURI;
        const isExternal = isURL && retrievalURI2 !== $refBaseURIStrippedHash;
        if (!this.options.resolve.external && isExternal) {
          return void 0;
        }
        this.indirections.push(referencingElement);
        let referencedElement;
        try {
          if (isUnknownURI || isURL) {
            const selector = $refBaseURI;
            referencedElement = evaluate(
              selector,
              // @ts-ignore
              maybeRefractToSchemaElement(reference.value.result)
            );
          } else {
            reference = await this.toReference(unsanitize($refBaseURI));
            const selector = uriToPointer($refBaseURI);
            referencedElement = maybeRefractToSchemaElement(
              // @ts-ignore
              jsonPointerEvaluate(selector, reference.value.result)
            );
          }
        } catch (error) {
          if (isURL && error instanceof EvaluationJsonSchemaUriError) {
            if (isAnchor(uriToAnchor($refBaseURI))) {
              reference = await this.toReference(unsanitize($refBaseURI));
              retrievalURI2 = reference.uri;
              const selector = uriToAnchor($refBaseURI);
              referencedElement = evaluate$1(
                selector,
                // @ts-ignore
                maybeRefractToSchemaElement(reference.value.result)
              );
            } else {
              reference = await this.toReference(unsanitize($refBaseURI));
              retrievalURI2 = reference.uri;
              const selector = uriToPointer($refBaseURI);
              referencedElement = maybeRefractToSchemaElement(
                // @ts-ignore
                jsonPointerEvaluate(selector, reference.value.result)
              );
            }
          } else {
            throw error;
          }
        }
        if (this.indirections.includes(referencedElement)) {
          throw new Error("Recursive Schema Object reference detected");
        }
        if (this.indirections.length > this.options.dereference.maxDepth) {
          throw new MaximumDereferenceDepthError$1(`Maximum dereference depth of "${this.options.dereference.maxDepth}" has been exceeded in file "${this.reference.uri}"`);
        }
        directAncestors.add(referencingElement);
        const visitor2 = OpenApi3_1DereferenceVisitor({
          reference,
          namespace: this.namespace,
          indirections: [...this.indirections],
          options: this.options,
          ancestors: ancestorsLineage
        });
        referencedElement = await visitAsync$3(referencedElement, visitor2, {
          keyMap,
          nodeTypeGetter: getNodeType
        });
        directAncestors.delete(referencingElement);
        this.indirections.pop();
        if (isBooleanJsonSchemaElement(referencedElement)) {
          const booleanJsonSchemaElement = cloneDeep(referencedElement);
          booleanJsonSchemaElement.setMetaProperty("ref-fields", {
            $ref: toValue(referencingElement.$ref)
          });
          booleanJsonSchemaElement.setMetaProperty("ref-origin", reference.uri);
          return booleanJsonSchemaElement;
        }
        const mergeAndAnnotateReferencedElement = (refedElement) => {
          const mergedElement = new SchemaElement([...refedElement.content], cloneDeep(refedElement.meta), cloneDeep(refedElement.attributes));
          referencingElement.forEach((value2, keyElement, item) => {
            mergedElement.remove(toValue(keyElement));
            mergedElement.content.push(item);
          });
          mergedElement.remove("$ref");
          mergedElement.setMetaProperty("ref-fields", {
            $ref: toValue(referencingElement.$ref)
          });
          mergedElement.setMetaProperty("ref-origin", reference.uri);
          return mergedElement;
        };
        if (ancestorsLineage.includes(referencedElement)) {
          if (isMemberElement(parent2)) {
            parent2.value = mergeAndAnnotateReferencedElement(referencedElement);
          } else if (Array.isArray(parent2)) {
            parent2[key] = mergeAndAnnotateReferencedElement(referencedElement);
          }
          return false;
        }
        return mergeAndAnnotateReferencedElement(referencedElement);
      }
    }
  });
  const OpenApi3_1DereferenceVisitor$1 = OpenApi3_1DereferenceVisitor;
  const visitAsync$2 = visit$1[Symbol.for("nodejs.util.promisify.custom")];
  const OpenApi3_1DereferenceStrategy = stampit(DereferenceStrategy$1, {
    init() {
      this.name = "openapi-3-1";
    },
    methods: {
      canDereference(file) {
        var _file$parseResult;
        if (file.mediaType !== "text/plain") {
          return mediaTypes$1.includes(file.mediaType);
        }
        return isOpenApi3_1Element((_file$parseResult = file.parseResult) === null || _file$parseResult === void 0 ? void 0 : _file$parseResult.result);
      },
      async dereference(file, options) {
        const namespace2 = createNamespace(openApi3_1Namespace);
        const refSet = defaultTo$1(ReferenceSet$1(), options.dereference.refSet);
        let reference;
        if (!refSet.has(file.uri)) {
          reference = Reference$3({
            uri: file.uri,
            value: file.parseResult
          });
          refSet.add(reference);
        } else {
          reference = refSet.find(propEq$1(file.uri, "uri"));
        }
        const visitor2 = OpenApi3_1DereferenceVisitor$1({
          reference,
          namespace: namespace2,
          options
        });
        const dereferencedElement = await visitAsync$2(refSet.rootRef.value, visitor2, {
          keyMap,
          nodeTypeGetter: getNodeType
        });
        if (options.dereference.refSet === null) {
          refSet.clean();
        }
        return dereferencedElement;
      }
    }
  });
  const OpenApi3_1DereferenceStrategy$1 = OpenApi3_1DereferenceStrategy;
  const trimParseResult = (elementPath) => elementPath.slice(2);
  const toPath = (elementPath) => {
    const elementPathSanitized = trimParseResult(elementPath);
    return elementPathSanitized.reduce((path2, element, index2) => {
      if (isMemberElement(element)) {
        const token = String(toValue(element.key));
        path2.push(token);
      } else if (isArrayElement(elementPathSanitized[index2 - 2])) {
        const token = elementPathSanitized[index2 - 2].content.indexOf(element);
        path2.push(token);
      }
      return path2;
    }, []);
  };
  const getRootCause = (error) => {
    if (error.cause == null)
      return error;
    let {
      cause
    } = error;
    while (cause.cause != null) {
      cause = cause.cause;
    }
    return cause;
  };
  const SchemaRefError = createErrorType("SchemaRefError", function cb(message, extra, oriError) {
    this.originalError = oriError;
    Object.assign(this, extra || {});
  });
  const {
    wrapError
  } = mod;
  const visitAsync$1 = visit$1[Symbol.for("nodejs.util.promisify.custom")];
  const OpenApi3_1SwaggerClientDereferenceVisitor = OpenApi3_1DereferenceVisitor$1.compose({
    props: {
      useCircularStructures: true,
      allowMetaPatches: false,
      basePath: null
    },
    init(_ref) {
      let {
        allowMetaPatches = this.allowMetaPatches,
        useCircularStructures = this.useCircularStructures,
        basePath = this.basePath
      } = _ref;
      this.allowMetaPatches = allowMetaPatches;
      this.useCircularStructures = useCircularStructures;
      this.basePath = basePath;
    },
    methods: {
      async ReferenceElement(referencingElement, key, parent2, path2, ancestors) {
        try {
          var _this$basePath;
          const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent2]);
          if (ancestorsLineage.includesCycle(referencingElement)) {
            return false;
          }
          if (!this.options.resolve.external && isReferenceElementExternal(referencingElement)) {
            return false;
          }
          const reference = await this.toReference(toValue(referencingElement.$ref));
          const {
            uri: retrievalURI2
          } = reference;
          const $refBaseURI = resolve$2(retrievalURI2, toValue(referencingElement.$ref));
          this.indirections.push(referencingElement);
          const jsonPointer = uriToPointer($refBaseURI);
          let referencedElement = jsonPointerEvaluate(jsonPointer, reference.value.result);
          if (isPrimitiveElement(referencedElement)) {
            const referencedElementType = toValue(referencingElement.meta.get("referenced-element"));
            if (isReferenceLikeElement(referencedElement)) {
              referencedElement = ReferenceElement.refract(referencedElement);
              referencedElement.setMetaProperty("referenced-element", referencedElementType);
            } else {
              const ElementClass = this.namespace.getElementClass(referencedElementType);
              referencedElement = ElementClass.refract(referencedElement);
            }
          }
          if (this.indirections.includes(referencedElement)) {
            throw new Error("Recursive JSON Pointer detected");
          }
          if (this.indirections.length > this.options.dereference.maxDepth) {
            throw new MaximumDereferenceDepthError$1(`Maximum dereference depth of "${this.options.dereference.maxDepth}" has been exceeded in file "${this.reference.uri}"`);
          }
          if (!this.useCircularStructures) {
            const hasCycles = ancestorsLineage.includes(referencedElement);
            if (hasCycles) {
              if (isHttpUrl(retrievalURI2) || isFileSystemPath(retrievalURI2)) {
                return new ReferenceElement({
                  $ref: $refBaseURI
                }, cloneDeep(referencingElement.meta), cloneDeep(referencingElement.attributes));
              }
              return false;
            }
          }
          directAncestors.add(referencingElement);
          const visitor2 = OpenApi3_1SwaggerClientDereferenceVisitor({
            reference,
            namespace: this.namespace,
            indirections: [...this.indirections],
            options: this.options,
            ancestors: ancestorsLineage,
            allowMetaPatches: this.allowMetaPatches,
            useCircularStructures: this.useCircularStructures,
            basePath: (_this$basePath = this.basePath) !== null && _this$basePath !== void 0 ? _this$basePath : [...toPath([...ancestors, parent2, referencingElement]), "$ref"]
          });
          referencedElement = await visitAsync$1(referencedElement, visitor2, {
            keyMap,
            nodeTypeGetter: getNodeType
          });
          directAncestors.delete(referencingElement);
          this.indirections.pop();
          const mergeAndAnnotateReferencedElement = (refedElement) => {
            const copy2 = cloneShallow(refedElement);
            copy2.setMetaProperty("ref-fields", {
              $ref: toValue(referencingElement.$ref),
              // @ts-ignore
              description: toValue(referencingElement.description),
              // @ts-ignore
              summary: toValue(referencingElement.summary)
            });
            copy2.setMetaProperty("ref-origin", reference.uri);
            if (isObjectElement(refedElement)) {
              if (referencingElement.hasKey("description") && "description" in refedElement) {
                copy2.remove("description");
                copy2.set("description", referencingElement.get("description"));
              }
              if (referencingElement.hasKey("summary") && "summary" in refedElement) {
                copy2.remove("summary");
                copy2.set("summary", referencingElement.get("summary"));
              }
            }
            if (this.allowMetaPatches && isObjectElement(copy2)) {
              if (!copy2.hasKey("$$ref")) {
                const baseURI = resolve$2(retrievalURI2, $refBaseURI);
                copy2.set("$$ref", baseURI);
              }
            }
            return copy2;
          };
          if (ancestorsLineage.includes(referencedElement)) {
            if (isMemberElement(parent2)) {
              parent2.value = mergeAndAnnotateReferencedElement(referencedElement);
            } else if (Array.isArray(parent2)) {
              parent2[key] = mergeAndAnnotateReferencedElement(referencedElement);
            }
            return false;
          }
          return mergeAndAnnotateReferencedElement(referencedElement);
        } catch (error) {
          var _this$basePath2, _this$options$derefer, _this$options$derefer2;
          const rootCause = getRootCause(error);
          const wrappedError = wrapError(rootCause, {
            baseDoc: this.reference.uri,
            $ref: toValue(referencingElement.$ref),
            pointer: uriToPointer(toValue(referencingElement.$ref)),
            fullPath: (_this$basePath2 = this.basePath) !== null && _this$basePath2 !== void 0 ? _this$basePath2 : [...toPath([...ancestors, parent2, referencingElement]), "$ref"]
          });
          (_this$options$derefer = this.options.dereference.dereferenceOpts) === null || _this$options$derefer === void 0 || (_this$options$derefer = _this$options$derefer.errors) === null || _this$options$derefer === void 0 || (_this$options$derefer2 = _this$options$derefer.push) === null || _this$options$derefer2 === void 0 || _this$options$derefer2.call(_this$options$derefer, wrappedError);
          return void 0;
        }
      },
      async PathItemElement(pathItemElement, key, parent2, path2, ancestors) {
        try {
          var _this$basePath3;
          const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent2]);
          if (!isStringElement(pathItemElement.$ref)) {
            return void 0;
          }
          if (ancestorsLineage.includesCycle(pathItemElement)) {
            return false;
          }
          if (!this.options.resolve.external && isPathItemElementExternal(pathItemElement)) {
            return void 0;
          }
          const reference = await this.toReference(toValue(pathItemElement.$ref));
          const {
            uri: retrievalURI2
          } = reference;
          const $refBaseURI = resolve$2(retrievalURI2, toValue(pathItemElement.$ref));
          this.indirections.push(pathItemElement);
          const jsonPointer = uriToPointer($refBaseURI);
          let referencedElement = jsonPointerEvaluate(jsonPointer, reference.value.result);
          if (isPrimitiveElement(referencedElement)) {
            referencedElement = PathItemElement.refract(referencedElement);
          }
          if (this.indirections.includes(referencedElement)) {
            throw new Error("Recursive JSON Pointer detected");
          }
          if (this.indirections.length > this.options.dereference.maxDepth) {
            throw new MaximumDereferenceDepthError$1(`Maximum dereference depth of "${this.options.dereference.maxDepth}" has been exceeded in file "${this.reference.uri}"`);
          }
          if (!this.useCircularStructures) {
            const hasCycles = ancestorsLineage.includes(referencedElement);
            if (hasCycles) {
              if (isHttpUrl(retrievalURI2) || isFileSystemPath(retrievalURI2)) {
                return new PathItemElement({
                  $ref: $refBaseURI
                }, cloneDeep(pathItemElement.meta), cloneDeep(pathItemElement.attributes));
              }
              return false;
            }
          }
          directAncestors.add(pathItemElement);
          const visitor2 = OpenApi3_1SwaggerClientDereferenceVisitor({
            reference,
            namespace: this.namespace,
            indirections: [...this.indirections],
            options: this.options,
            ancestors: ancestorsLineage,
            allowMetaPatches: this.allowMetaPatches,
            useCircularStructures: this.useCircularStructures,
            basePath: (_this$basePath3 = this.basePath) !== null && _this$basePath3 !== void 0 ? _this$basePath3 : [...toPath([...ancestors, parent2, pathItemElement]), "$ref"]
          });
          referencedElement = await visitAsync$1(referencedElement, visitor2, {
            keyMap,
            nodeTypeGetter: getNodeType
          });
          directAncestors.delete(pathItemElement);
          this.indirections.pop();
          const mergeAndAnnotateReferencedElement = (refedElement) => {
            const mergedElement = new PathItemElement([...refedElement.content], cloneDeep(refedElement.meta), cloneDeep(refedElement.attributes));
            pathItemElement.forEach((value2, keyElement, item) => {
              mergedElement.remove(toValue(keyElement));
              mergedElement.content.push(item);
            });
            mergedElement.remove("$ref");
            mergedElement.setMetaProperty("ref-fields", {
              $ref: toValue(pathItemElement.$ref)
            });
            mergedElement.setMetaProperty("ref-origin", reference.uri);
            if (this.allowMetaPatches) {
              if (typeof mergedElement.get("$$ref") === "undefined") {
                const baseURI = resolve$2(retrievalURI2, $refBaseURI);
                mergedElement.set("$$ref", baseURI);
              }
            }
            return mergedElement;
          };
          if (ancestorsLineage.includes(referencedElement)) {
            if (isMemberElement(parent2)) {
              parent2.value = mergeAndAnnotateReferencedElement(referencedElement);
            } else if (Array.isArray(parent2)) {
              parent2[key] = mergeAndAnnotateReferencedElement(referencedElement);
            }
            return false;
          }
          return mergeAndAnnotateReferencedElement(referencedElement);
        } catch (error) {
          var _this$basePath4, _this$options$derefer3, _this$options$derefer4;
          const rootCause = getRootCause(error);
          const wrappedError = wrapError(rootCause, {
            baseDoc: this.reference.uri,
            $ref: toValue(pathItemElement.$ref),
            pointer: uriToPointer(toValue(pathItemElement.$ref)),
            fullPath: (_this$basePath4 = this.basePath) !== null && _this$basePath4 !== void 0 ? _this$basePath4 : [...toPath([...ancestors, parent2, pathItemElement]), "$ref"]
          });
          (_this$options$derefer3 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer3 === void 0 || (_this$options$derefer3 = _this$options$derefer3.errors) === null || _this$options$derefer3 === void 0 || (_this$options$derefer4 = _this$options$derefer3.push) === null || _this$options$derefer4 === void 0 || _this$options$derefer4.call(_this$options$derefer3, wrappedError);
          return void 0;
        }
      },
      async SchemaElement(referencingElement, key, parent2, path2, ancestors) {
        try {
          var _this$basePath5;
          const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent2]);
          if (!isStringElement(referencingElement.$ref)) {
            return void 0;
          }
          if (ancestorsLineage.includesCycle(referencingElement)) {
            return false;
          }
          let reference = await this.toReference(unsanitize(this.reference.uri));
          let {
            uri: retrievalURI2
          } = reference;
          const $refBaseURI = resolveSchema$refField(retrievalURI2, referencingElement);
          const $refBaseURIStrippedHash = stripHash($refBaseURI);
          const file = File$2({
            uri: $refBaseURIStrippedHash
          });
          const isUnknownURI = !this.options.resolve.resolvers.some((r) => r.canRead(file));
          const isURL = !isUnknownURI;
          const isExternal = isURL && retrievalURI2 !== $refBaseURIStrippedHash;
          if (!this.options.resolve.external && isExternal) {
            return void 0;
          }
          this.indirections.push(referencingElement);
          let referencedElement;
          try {
            if (isUnknownURI || isURL) {
              const selector = $refBaseURI;
              referencedElement = evaluate(selector, maybeRefractToSchemaElement(reference.value.result));
            } else {
              reference = await this.toReference(unsanitize($refBaseURI));
              retrievalURI2 = reference.uri;
              const selector = uriToPointer($refBaseURI);
              referencedElement = maybeRefractToSchemaElement(jsonPointerEvaluate(selector, reference.value.result));
            }
          } catch (error) {
            if (isURL && error instanceof EvaluationJsonSchemaUriError) {
              if (isAnchor(uriToAnchor($refBaseURI))) {
                reference = await this.toReference(unsanitize($refBaseURI));
                retrievalURI2 = reference.uri;
                const selector = uriToAnchor($refBaseURI);
                referencedElement = evaluate$1(selector, maybeRefractToSchemaElement(reference.value.result));
              } else {
                reference = await this.toReference(unsanitize($refBaseURI));
                retrievalURI2 = reference.uri;
                const selector = uriToPointer($refBaseURI);
                referencedElement = maybeRefractToSchemaElement(jsonPointerEvaluate(selector, reference.value.result));
              }
            } else {
              throw error;
            }
          }
          if (this.indirections.includes(referencedElement)) {
            throw new Error("Recursive Schema Object reference detected");
          }
          if (this.indirections.length > this.options.dereference.maxDepth) {
            throw new MaximumDereferenceDepthError$1(`Maximum dereference depth of "${this.options.dereference.maxDepth}" has been exceeded in file "${this.reference.uri}"`);
          }
          if (!this.useCircularStructures) {
            const hasCycles = ancestorsLineage.some((ancs) => ancs.has(referencedElement));
            if (hasCycles) {
              if (isHttpUrl(retrievalURI2) || isFileSystemPath(retrievalURI2)) {
                const baseURI = resolve$2(retrievalURI2, $refBaseURI);
                return new SchemaElement({
                  $ref: baseURI
                }, cloneDeep(referencingElement.meta), cloneDeep(referencingElement.attributes));
              }
              return false;
            }
          }
          directAncestors.add(referencingElement);
          const mergeVisitor = OpenApi3_1SwaggerClientDereferenceVisitor({
            reference,
            namespace: this.namespace,
            indirections: [...this.indirections],
            options: this.options,
            useCircularStructures: this.useCircularStructures,
            allowMetaPatches: this.allowMetaPatches,
            ancestors: ancestorsLineage,
            basePath: (_this$basePath5 = this.basePath) !== null && _this$basePath5 !== void 0 ? _this$basePath5 : [...toPath([...ancestors, parent2, referencingElement]), "$ref"]
          });
          referencedElement = await visitAsync$1(referencedElement, mergeVisitor, {
            keyMap,
            nodeTypeGetter: getNodeType
          });
          directAncestors.delete(referencingElement);
          this.indirections.pop();
          if (isBooleanJsonSchemaElement(referencedElement)) {
            const booleanJsonSchemaElement = cloneDeep(referencedElement);
            booleanJsonSchemaElement.setMetaProperty("ref-fields", {
              $ref: toValue(referencingElement.$ref)
            });
            booleanJsonSchemaElement.setMetaProperty("ref-origin", reference.uri);
            return booleanJsonSchemaElement;
          }
          const mergeAndAnnotateReferencedElement = (refedElement) => {
            const mergedElement = new SchemaElement([...refedElement.content], cloneDeep(refedElement.meta), cloneDeep(refedElement.attributes));
            referencingElement.forEach((value2, keyElement, item) => {
              mergedElement.remove(toValue(keyElement));
              mergedElement.content.push(item);
            });
            mergedElement.remove("$ref");
            mergedElement.setMetaProperty("ref-fields", {
              $ref: toValue(referencingElement.$ref)
            });
            mergedElement.setMetaProperty("ref-origin", reference.uri);
            if (this.allowMetaPatches) {
              if (typeof mergedElement.get("$$ref") === "undefined") {
                const baseURI = resolve$2(retrievalURI2, $refBaseURI);
                mergedElement.set("$$ref", baseURI);
              }
            }
            return mergedElement;
          };
          if (ancestorsLineage.includes(referencedElement)) {
            if (isMemberElement(parent2)) {
              parent2.value = mergeAndAnnotateReferencedElement(referencedElement);
            } else if (Array.isArray(parent2)) {
              parent2[key] = mergeAndAnnotateReferencedElement(referencedElement);
            }
            return false;
          }
          return mergeAndAnnotateReferencedElement(referencedElement);
        } catch (error) {
          var _this$basePath6, _this$options$derefer5, _this$options$derefer6;
          const rootCause = getRootCause(error);
          const wrappedError = new SchemaRefError(`Could not resolve reference: ${rootCause.message}`, {
            baseDoc: this.reference.uri,
            $ref: toValue(referencingElement.$ref),
            fullPath: (_this$basePath6 = this.basePath) !== null && _this$basePath6 !== void 0 ? _this$basePath6 : [...toPath([...ancestors, parent2, referencingElement]), "$ref"]
          }, rootCause);
          (_this$options$derefer5 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer5 === void 0 || (_this$options$derefer5 = _this$options$derefer5.errors) === null || _this$options$derefer5 === void 0 || (_this$options$derefer6 = _this$options$derefer5.push) === null || _this$options$derefer6 === void 0 || _this$options$derefer6.call(_this$options$derefer5, wrappedError);
          return void 0;
        }
      },
      async LinkElement() {
        return void 0;
      },
      async ExampleElement(exampleElement, key, parent2, path2, ancestors) {
        try {
          return await OpenApi3_1DereferenceVisitor$1.compose.methods.ExampleElement.call(this, exampleElement, key, parent2, path2, ancestors);
        } catch (error) {
          var _this$basePath7, _this$options$derefer7, _this$options$derefer8;
          const rootCause = getRootCause(error);
          const wrappedError = wrapError(rootCause, {
            baseDoc: this.reference.uri,
            externalValue: toValue(exampleElement.externalValue),
            fullPath: (_this$basePath7 = this.basePath) !== null && _this$basePath7 !== void 0 ? _this$basePath7 : [...toPath([...ancestors, parent2, exampleElement]), "externalValue"]
          });
          (_this$options$derefer7 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer7 === void 0 || (_this$options$derefer7 = _this$options$derefer7.errors) === null || _this$options$derefer7 === void 0 || (_this$options$derefer8 = _this$options$derefer7.push) === null || _this$options$derefer8 === void 0 || _this$options$derefer8.call(_this$options$derefer7, wrappedError);
          return void 0;
        }
      }
    }
  });
  const compose = OpenApi3_1DereferenceStrategy$1.compose.bind();
  const ParameterMacroVisitor = compose({
    init(_ref) {
      let {
        parameterMacro,
        options
      } = _ref;
      this.parameterMacro = parameterMacro;
      this.options = options;
    },
    props: {
      parameterMacro: null,
      options: null,
      macroOperation: null,
      OperationElement: {
        enter(operationElement) {
          this.macroOperation = operationElement;
        },
        leave() {
          this.macroOperation = null;
        }
      },
      ParameterElement: {
        leave(parameterElement, key, parent2, path2, ancestors) {
          const pojoOperation = this.macroOperation === null ? null : toValue(this.macroOperation);
          const pojoParameter = toValue(parameterElement);
          try {
            const macroValue = this.parameterMacro(pojoOperation, pojoParameter);
            parameterElement.set("default", macroValue);
          } catch (error) {
            var _this$options$derefer, _this$options$derefer2;
            const macroError = new Error(error, {
              cause: error
            });
            macroError.fullPath = toPath([...ancestors, parent2]);
            (_this$options$derefer = this.options.dereference.dereferenceOpts) === null || _this$options$derefer === void 0 || (_this$options$derefer = _this$options$derefer.errors) === null || _this$options$derefer === void 0 || (_this$options$derefer2 = _this$options$derefer.push) === null || _this$options$derefer2 === void 0 || _this$options$derefer2.call(_this$options$derefer, macroError);
          }
        }
      }
    }
  });
  const ModelPropertyMacroVisitor = compose({
    init(_ref) {
      let {
        modelPropertyMacro,
        options
      } = _ref;
      this.modelPropertyMacro = modelPropertyMacro;
      this.options = options;
    },
    props: {
      modelPropertyMacro: null,
      options: null,
      SchemaElement: {
        leave(schemaElement, key, parent2, path2, ancestors) {
          if (typeof schemaElement.properties === "undefined")
            return;
          if (!isObjectElement(schemaElement.properties))
            return;
          schemaElement.properties.forEach((property) => {
            if (!isObjectElement(property))
              return;
            try {
              const macroValue = this.modelPropertyMacro(toValue(property));
              property.set("default", macroValue);
            } catch (error) {
              var _this$options$derefer, _this$options$derefer2;
              const macroError = new Error(error, {
                cause: error
              });
              macroError.fullPath = [...toPath([...ancestors, parent2, schemaElement]), "properties"];
              (_this$options$derefer = this.options.dereference.dereferenceOpts) === null || _this$options$derefer === void 0 || (_this$options$derefer = _this$options$derefer.errors) === null || _this$options$derefer === void 0 || (_this$options$derefer2 = _this$options$derefer.push) === null || _this$options$derefer2 === void 0 || _this$options$derefer2.call(_this$options$derefer, macroError);
            }
          });
        }
      }
    }
  });
  const AllOfVisitor = compose({
    init(_ref) {
      let {
        options
      } = _ref;
      this.options = options;
    },
    props: {
      options: null,
      SchemaElement: {
        leave(schemaElement, key, parent2, path2, ancestors) {
          if (typeof schemaElement.allOf === "undefined")
            return void 0;
          if (!isArrayElement(schemaElement.allOf)) {
            var _this$options$derefer, _this$options$derefer2;
            const error = new TypeError("allOf must be an array");
            error.fullPath = [...toPath([...ancestors, parent2, schemaElement]), "allOf"];
            (_this$options$derefer = this.options.dereference.dereferenceOpts) === null || _this$options$derefer === void 0 || (_this$options$derefer = _this$options$derefer.errors) === null || _this$options$derefer === void 0 || (_this$options$derefer2 = _this$options$derefer.push) === null || _this$options$derefer2 === void 0 || _this$options$derefer2.call(_this$options$derefer, error);
            return void 0;
          }
          if (schemaElement.allOf.isEmpty) {
            return new SchemaElement(schemaElement.content.filter((memberElement) => toValue(memberElement.key) !== "allOf"), cloneDeep(schemaElement.meta), cloneDeep(schemaElement.attributes));
          }
          const includesSchemaElementOnly = schemaElement.allOf.content.every(isSchemaElement);
          if (!includesSchemaElementOnly) {
            var _this$options$derefer3, _this$options$derefer4;
            const error = new TypeError("Elements in allOf must be objects");
            error.fullPath = [...toPath([...ancestors, parent2, schemaElement]), "allOf"];
            (_this$options$derefer3 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer3 === void 0 || (_this$options$derefer3 = _this$options$derefer3.errors) === null || _this$options$derefer3 === void 0 || (_this$options$derefer4 = _this$options$derefer3.push) === null || _this$options$derefer4 === void 0 || _this$options$derefer4.call(_this$options$derefer3, error);
            return void 0;
          }
          const mergedSchemaElement = deepmerge.all([...schemaElement.allOf.content, schemaElement]);
          if (!schemaElement.hasKey("$$ref")) {
            mergedSchemaElement.remove("$$ref");
          }
          if (schemaElement.hasKey("example")) {
            const member = mergedSchemaElement.getMember("example");
            member.value = schemaElement.get("example");
          }
          if (schemaElement.hasKey("examples")) {
            const member = mergedSchemaElement.getMember("examples");
            member.value = schemaElement.get("examples");
          }
          mergedSchemaElement.remove("allOf");
          return mergedSchemaElement;
        }
      }
    }
  });
  const visitAsync = visit$1[Symbol.for("nodejs.util.promisify.custom")];
  const OpenApi3_1SwaggerClientDereferenceStrategy = OpenApi3_1DereferenceStrategy$1.compose({
    props: {
      useCircularStructures: true,
      allowMetaPatches: false,
      parameterMacro: null,
      modelPropertyMacro: null,
      mode: "non-strict",
      ancestors: null
    },
    init() {
      let {
        useCircularStructures = this.useCircularStructures,
        allowMetaPatches = this.allowMetaPatches,
        parameterMacro = this.parameterMacro,
        modelPropertyMacro = this.modelPropertyMacro,
        mode = this.mode,
        ancestors = []
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.name = "openapi-3-1-swagger-client";
      this.useCircularStructures = useCircularStructures;
      this.allowMetaPatches = allowMetaPatches;
      this.parameterMacro = parameterMacro;
      this.modelPropertyMacro = modelPropertyMacro;
      this.mode = mode;
      this.ancestors = [...ancestors];
    },
    methods: {
      async dereference(file, options) {
        var _options$dereference$;
        const visitors = [];
        const namespace2 = createNamespace(openApi3_1Namespace);
        const refSet = (_options$dereference$ = options.dereference.refSet) !== null && _options$dereference$ !== void 0 ? _options$dereference$ : ReferenceSet$1();
        let reference;
        if (!refSet.has(file.uri)) {
          reference = Reference$3({
            uri: file.uri,
            value: file.parseResult
          });
          refSet.add(reference);
        } else {
          reference = refSet.find((ref) => ref.uri === file.uri);
        }
        const dereferenceVisitor = OpenApi3_1SwaggerClientDereferenceVisitor({
          reference,
          namespace: namespace2,
          options,
          useCircularStructures: this.useCircularStructures,
          allowMetaPatches: this.allowMetaPatches,
          ancestors: this.ancestors
        });
        visitors.push(dereferenceVisitor);
        if (typeof this.parameterMacro === "function") {
          const parameterMacroVisitor = ParameterMacroVisitor({
            parameterMacro: this.parameterMacro,
            options
          });
          visitors.push(parameterMacroVisitor);
        }
        if (typeof this.modelPropertyMacro === "function") {
          const modelPropertyMacroVisitor = ModelPropertyMacroVisitor({
            modelPropertyMacro: this.modelPropertyMacro,
            options
          });
          visitors.push(modelPropertyMacroVisitor);
        }
        if (this.mode !== "strict") {
          const allOfVisitor = AllOfVisitor({
            options
          });
          visitors.push(allOfVisitor);
        }
        const rootVisitor = mergeAll$1(visitors, {
          nodeTypeGetter: getNodeType
        });
        const dereferencedElement = await visitAsync(refSet.rootRef.value, rootVisitor, {
          keyMap,
          nodeTypeGetter: getNodeType
        });
        if (options.dereference.refSet === null) {
          refSet.clean();
        }
        return dereferencedElement;
      }
    }
  });
  const resolveOpenAPI31Strategy = async (options) => {
    const {
      spec,
      timeout: timeout2,
      redirects,
      requestInterceptor,
      responseInterceptor,
      pathDiscriminator = [],
      allowMetaPatches = false,
      useCircularStructures = false,
      skipNormalization = false,
      parameterMacro = null,
      modelPropertyMacro = null,
      mode = "non-strict"
    } = options;
    try {
      const {
        cache
      } = resolveOpenAPI31Strategy;
      const cwd$1 = isHttpUrl(cwd()) ? cwd() : DEFAULT_BASE_URL;
      const retrievalURI$1 = retrievalURI(options);
      const baseURI = resolve$2(cwd$1, retrievalURI$1);
      let openApiElement;
      if (cache.has(spec)) {
        openApiElement = cache.get(spec);
      } else {
        openApiElement = OpenApi3_1Element.refract(spec);
        openApiElement.classes.push("result");
        cache.set(spec, openApiElement);
      }
      const openApiParseResultElement = new ParseResultElement([openApiElement]);
      const jsonPointer = jsonPointerCompile(pathDiscriminator);
      const jsonPointerURI = jsonPointer === "" ? "" : `#${jsonPointer}`;
      const fragmentElement = jsonPointerEvaluate(jsonPointer, openApiElement);
      const openApiElementReference = Reference$3({
        uri: baseURI,
        value: openApiParseResultElement
      });
      const refSet = ReferenceSet$1({
        refs: [openApiElementReference]
      });
      if (jsonPointer !== "")
        refSet.rootRef = null;
      const ancestors = [new WeakSet([fragmentElement])];
      const errors = [];
      const dereferenced = await dereferenceApiDOM(fragmentElement, {
        resolve: {
          /**
           * swagger-client only supports resolving HTTP(S) URLs or spec objects.
           * If runtime env is detected as non-browser one,
           * and baseURI was not provided as part of resolver options,
           * then below baseURI check will make sure that constant HTTPS URL is used as baseURI.
           */
          baseURI: `${baseURI}${jsonPointerURI}`,
          resolvers: [HttpResolverSwaggerClient({
            timeout: timeout2 || 1e4,
            redirects: redirects || 10
          })],
          resolverOpts: {
            swaggerHTTPClientConfig: {
              requestInterceptor,
              responseInterceptor
            }
          },
          strategies: [OpenApi3_1ResolveStrategy$1()]
        },
        parse: {
          mediaType: mediaTypes$1.latest(),
          parsers: [OpenApiJson3_1Parser({
            allowEmpty: false,
            sourceMap: false
          }), OpenApiYaml3_1Parser({
            allowEmpty: false,
            sourceMap: false
          }), JsonParser({
            allowEmpty: false,
            sourceMap: false
          }), YamlParser({
            allowEmpty: false,
            sourceMap: false
          }), BinaryParser$1({
            allowEmpty: false,
            sourceMap: false
          })]
        },
        dereference: {
          maxDepth: 100,
          strategies: [OpenApi3_1SwaggerClientDereferenceStrategy({
            allowMetaPatches,
            useCircularStructures,
            parameterMacro,
            modelPropertyMacro,
            mode,
            ancestors
          })],
          refSet,
          dereferenceOpts: {
            errors
          }
        }
      });
      const transcluded = transclude(fragmentElement, dereferenced, openApiElement);
      const normalized = skipNormalization ? transcluded : normalize(transcluded);
      return {
        spec: toValue(normalized),
        errors
      };
    } catch (error) {
      if (error instanceof InvalidJsonPointerError$1 || error instanceof EvaluationJsonPointerError$1) {
        return {
          spec: null,
          errors: []
        };
      }
      throw error;
    }
  };
  resolveOpenAPI31Strategy.cache = /* @__PURE__ */ new WeakMap();
  const openApi31ApiDOMStrategy = {
    name: "openapi-3-1-apidom",
    match(_ref) {
      let {
        spec
      } = _ref;
      return isOpenAPI31(spec);
    },
    normalize(_ref2) {
      let {
        spec
      } = _ref2;
      return pojoAdapter(normalize)(spec);
    },
    async resolve(options) {
      return resolveOpenAPI31Strategy(options);
    }
  };
  function eachOperation(spec, cb, find2) {
    if (!spec || typeof spec !== "object" || !spec.paths || typeof spec.paths !== "object") {
      return null;
    }
    const {
      paths: paths2
    } = spec;
    for (const pathName in paths2) {
      for (const method in paths2[pathName]) {
        if (method.toUpperCase() === "PARAMETERS") {
          continue;
        }
        const operation = paths2[pathName][method];
        if (!operation || typeof operation !== "object") {
          continue;
        }
        const operationObj = {
          spec,
          pathName,
          method: method.toUpperCase(),
          operation
        };
        const cbValue = cb(operationObj);
        if (find2 && cbValue) {
          return operationObj;
        }
      }
    }
    return void 0;
  }
  function findOperation(spec, predicate) {
    return eachOperation(spec, predicate, true) || null;
  }
  function idFromPathMethodLegacy(pathName, method) {
    return `${method.toLowerCase()}-${pathName}`;
  }
  function getOperationRaw(spec, id2) {
    if (!spec || !spec.paths) {
      return null;
    }
    return findOperation(spec, (_ref) => {
      let {
        pathName,
        method,
        operation
      } = _ref;
      if (!operation || typeof operation !== "object") {
        return false;
      }
      const rawOperationId = operation.operationId;
      const operationId = opId(operation, pathName, method);
      const legacyOperationId = idFromPathMethodLegacy(pathName, method);
      return [operationId, legacyOperationId, rawOperationId].some((val) => val && val === id2);
    });
  }
  const nullFn = () => null;
  const normalizeArray = (arg) => Array.isArray(arg) ? arg : [arg];
  const self$2 = {
    mapTagOperations,
    makeExecute
  };
  function makeExecute() {
    let swaggerJs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return (_ref) => {
      let {
        pathName,
        method,
        operationId
      } = _ref;
      return function(parameters2) {
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          requestInterceptor,
          responseInterceptor,
          userFetch
        } = swaggerJs;
        return swaggerJs.execute({
          spec: swaggerJs.spec,
          requestInterceptor,
          responseInterceptor,
          userFetch,
          pathName,
          method,
          parameters: parameters2,
          operationId,
          ...opts
        });
      };
    };
  }
  function makeApisTagOperation() {
    let swaggerJs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const cb = self$2.makeExecute(swaggerJs);
    return {
      apis: self$2.mapTagOperations({
        v2OperationIdCompatibilityMode: swaggerJs.v2OperationIdCompatibilityMode,
        spec: swaggerJs.spec,
        cb
      })
    };
  }
  function mapTagOperations(_ref2) {
    let {
      spec,
      cb = nullFn,
      defaultTag = "default",
      v2OperationIdCompatibilityMode
    } = _ref2;
    const operationIdCounter = {};
    const tagOperations = {};
    eachOperation(spec, (_ref3) => {
      let {
        pathName,
        method,
        operation
      } = _ref3;
      const tags2 = operation.tags ? normalizeArray(operation.tags) : [defaultTag];
      tags2.forEach((tag) => {
        if (typeof tag !== "string") {
          return;
        }
        tagOperations[tag] = tagOperations[tag] || {};
        const tagObj = tagOperations[tag];
        const id2 = opId(operation, pathName, method, {
          v2OperationIdCompatibilityMode
        });
        const cbResult = cb({
          spec,
          pathName,
          method,
          operation,
          operationId: id2
        });
        if (operationIdCounter[id2]) {
          operationIdCounter[id2] += 1;
          tagObj[`${id2}${operationIdCounter[id2]}`] = cbResult;
        } else if (typeof tagObj[id2] !== "undefined") {
          const originalCounterValue = operationIdCounter[id2] || 1;
          operationIdCounter[id2] = originalCounterValue + 1;
          tagObj[`${id2}${operationIdCounter[id2]}`] = cbResult;
          const temp = tagObj[id2];
          delete tagObj[id2];
          tagObj[`${id2}${originalCounterValue}`] = temp;
        } else {
          tagObj[id2] = cbResult;
        }
      });
    });
    return tagOperations;
  }
  var cookie$1 = {};
  /*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  cookie$1.parse = parse$1;
  cookie$1.serialize = serialize$1;
  var __toString = Object.prototype.toString;
  var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
  function parse$1(str2, options) {
    if (typeof str2 !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var obj = {};
    var opt = options || {};
    var dec = opt.decode || decode$3;
    var index2 = 0;
    while (index2 < str2.length) {
      var eqIdx = str2.indexOf("=", index2);
      if (eqIdx === -1) {
        break;
      }
      var endIdx = str2.indexOf(";", index2);
      if (endIdx === -1) {
        endIdx = str2.length;
      } else if (endIdx < eqIdx) {
        index2 = str2.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      var key = str2.slice(index2, eqIdx).trim();
      if (void 0 === obj[key]) {
        var val = str2.slice(eqIdx + 1, endIdx).trim();
        if (val.charCodeAt(0) === 34) {
          val = val.slice(1, -1);
        }
        obj[key] = tryDecode(val, dec);
      }
      index2 = endIdx + 1;
    }
    return obj;
  }
  function serialize$1(name, val, options) {
    var opt = options || {};
    var enc = opt.encode || encode$3;
    if (typeof enc !== "function") {
      throw new TypeError("option encode is invalid");
    }
    if (!fieldContentRegExp.test(name)) {
      throw new TypeError("argument name is invalid");
    }
    var value2 = enc(val);
    if (value2 && !fieldContentRegExp.test(value2)) {
      throw new TypeError("argument val is invalid");
    }
    var str2 = name + "=" + value2;
    if (null != opt.maxAge) {
      var maxAge = opt.maxAge - 0;
      if (isNaN(maxAge) || !isFinite(maxAge)) {
        throw new TypeError("option maxAge is invalid");
      }
      str2 += "; Max-Age=" + Math.floor(maxAge);
    }
    if (opt.domain) {
      if (!fieldContentRegExp.test(opt.domain)) {
        throw new TypeError("option domain is invalid");
      }
      str2 += "; Domain=" + opt.domain;
    }
    if (opt.path) {
      if (!fieldContentRegExp.test(opt.path)) {
        throw new TypeError("option path is invalid");
      }
      str2 += "; Path=" + opt.path;
    }
    if (opt.expires) {
      var expires = opt.expires;
      if (!isDate$1(expires) || isNaN(expires.valueOf())) {
        throw new TypeError("option expires is invalid");
      }
      str2 += "; Expires=" + expires.toUTCString();
    }
    if (opt.httpOnly) {
      str2 += "; HttpOnly";
    }
    if (opt.secure) {
      str2 += "; Secure";
    }
    if (opt.priority) {
      var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
      switch (priority) {
        case "low":
          str2 += "; Priority=Low";
          break;
        case "medium":
          str2 += "; Priority=Medium";
          break;
        case "high":
          str2 += "; Priority=High";
          break;
        default:
          throw new TypeError("option priority is invalid");
      }
    }
    if (opt.sameSite) {
      var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
      switch (sameSite) {
        case true:
          str2 += "; SameSite=Strict";
          break;
        case "lax":
          str2 += "; SameSite=Lax";
          break;
        case "strict":
          str2 += "; SameSite=Strict";
          break;
        case "none":
          str2 += "; SameSite=None";
          break;
        default:
          throw new TypeError("option sameSite is invalid");
      }
    }
    return str2;
  }
  function decode$3(str2) {
    return str2.indexOf("%") !== -1 ? decodeURIComponent(str2) : str2;
  }
  function encode$3(val) {
    return encodeURIComponent(val);
  }
  function isDate$1(val) {
    return __toString.call(val) === "[object Date]" || val instanceof Date;
  }
  function tryDecode(str2, decode2) {
    try {
      return decode2(str2);
    } catch (e) {
      return str2;
    }
  }
  /*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  function isObject$2(o) {
    return Object.prototype.toString.call(o) === "[object Object]";
  }
  function isPlainObject(o) {
    var ctor, prot;
    if (isObject$2(o) === false)
      return false;
    ctor = o.constructor;
    if (ctor === void 0)
      return true;
    prot = ctor.prototype;
    if (isObject$2(prot) === false)
      return false;
    if (prot.hasOwnProperty("isPrototypeOf") === false) {
      return false;
    }
    return true;
  }
  const SWAGGER2_PARAMETER_BUILDERS = {
    body: bodyBuilder,
    header: headerBuilder,
    query: queryBuilder,
    path: pathBuilder,
    formData: formDataBuilder
  };
  function bodyBuilder(_ref) {
    let {
      req,
      value: value2
    } = _ref;
    req.body = value2;
  }
  function formDataBuilder(_ref2) {
    let {
      req,
      value: value2,
      parameter
    } = _ref2;
    if (value2 || parameter.allowEmptyValue) {
      req.form = req.form || {};
      req.form[parameter.name] = {
        value: value2,
        allowEmptyValue: parameter.allowEmptyValue,
        collectionFormat: parameter.collectionFormat
      };
    }
  }
  function headerBuilder(_ref3) {
    let {
      req,
      parameter,
      value: value2
    } = _ref3;
    req.headers = req.headers || {};
    if (typeof value2 !== "undefined") {
      req.headers[parameter.name] = value2;
    }
  }
  function pathBuilder(_ref4) {
    let {
      req,
      value: value2,
      parameter
    } = _ref4;
    req.url = req.url.split(`{${parameter.name}}`).join(encodeURIComponent(value2));
  }
  function queryBuilder(_ref5) {
    let {
      req,
      value: value2,
      parameter
    } = _ref5;
    req.query = req.query || {};
    if (value2 === false && parameter.type === "boolean") {
      value2 = "false";
    }
    if (value2 === 0 && ["number", "integer"].indexOf(parameter.type) > -1) {
      value2 = "0";
    }
    if (value2) {
      req.query[parameter.name] = {
        collectionFormat: parameter.collectionFormat,
        value: value2
      };
    } else if (parameter.allowEmptyValue && value2 !== void 0) {
      const paramName = parameter.name;
      req.query[paramName] = req.query[paramName] || {};
      req.query[paramName].allowEmptyValue = true;
    }
  }
  function serialize(value2, mediaType) {
    if (mediaType.includes("application/json")) {
      if (typeof value2 === "string") {
        return value2;
      }
      return JSON.stringify(value2);
    }
    return value2.toString();
  }
  function path(_ref) {
    let {
      req,
      value: value2,
      parameter
    } = _ref;
    const {
      name,
      style,
      explode,
      content
    } = parameter;
    if (content) {
      const effectiveMediaType = Object.keys(content)[0];
      req.url = req.url.split(`{${name}}`).join(encodeDisallowedCharacters(serialize(value2, effectiveMediaType), {
        escape: true
      }));
      return;
    }
    const styledValue = stylize({
      key: parameter.name,
      value: value2,
      style: style || "simple",
      explode: explode || false,
      escape: true
    });
    req.url = req.url.split(`{${name}}`).join(styledValue);
  }
  function query(_ref2) {
    let {
      req,
      value: value2,
      parameter
    } = _ref2;
    req.query = req.query || {};
    if (parameter.content) {
      const effectiveMediaType = Object.keys(parameter.content)[0];
      const serializedValue = serialize(value2, effectiveMediaType);
      if (serializedValue) {
        req.query[parameter.name] = serializedValue;
      } else if (parameter.allowEmptyValue && value2 !== void 0) {
        const paramName = parameter.name;
        req.query[paramName] = req.query[paramName] || {};
        req.query[paramName].allowEmptyValue = true;
      }
      return;
    }
    if (value2 === false) {
      value2 = "false";
    }
    if (value2 === 0) {
      value2 = "0";
    }
    if (value2) {
      const {
        style,
        explode,
        allowReserved
      } = parameter;
      req.query[parameter.name] = {
        value: value2,
        serializationOption: {
          style,
          explode,
          allowReserved
        }
      };
    } else if (parameter.allowEmptyValue && value2 !== void 0) {
      const paramName = parameter.name;
      req.query[paramName] = req.query[paramName] || {};
      req.query[paramName].allowEmptyValue = true;
    }
  }
  const PARAMETER_HEADER_BLACKLIST = ["accept", "authorization", "content-type"];
  function header(_ref3) {
    let {
      req,
      parameter,
      value: value2
    } = _ref3;
    req.headers = req.headers || {};
    if (PARAMETER_HEADER_BLACKLIST.indexOf(parameter.name.toLowerCase()) > -1) {
      return;
    }
    if (parameter.content) {
      const effectiveMediaType = Object.keys(parameter.content)[0];
      req.headers[parameter.name] = serialize(value2, effectiveMediaType);
      return;
    }
    if (typeof value2 !== "undefined") {
      req.headers[parameter.name] = stylize({
        key: parameter.name,
        value: value2,
        style: parameter.style || "simple",
        explode: typeof parameter.explode === "undefined" ? false : parameter.explode,
        escape: false
      });
    }
  }
  function cookie(_ref4) {
    let {
      req,
      parameter,
      value: value2
    } = _ref4;
    req.headers = req.headers || {};
    const type2 = typeof value2;
    if (parameter.content) {
      const effectiveMediaType = Object.keys(parameter.content)[0];
      req.headers.Cookie = `${parameter.name}=${serialize(value2, effectiveMediaType)}`;
      return;
    }
    if (type2 !== "undefined") {
      const prefix = type2 === "object" && !Array.isArray(value2) && parameter.explode ? "" : `${parameter.name}=`;
      req.headers.Cookie = prefix + stylize({
        key: parameter.name,
        value: value2,
        escape: false,
        style: parameter.style || "form",
        explode: typeof parameter.explode === "undefined" ? false : parameter.explode
      });
    }
  }
  const OAS3_PARAMETER_BUILDERS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    cookie,
    header,
    path,
    query
  }, Symbol.toStringTag, { value: "Module" }));
  const globalObject = (() => {
    if (typeof globalThis !== "undefined") {
      return globalThis;
    }
    if (typeof self !== "undefined") {
      return self;
    }
    return window;
  })();
  const {
    btoa: btoa$1
  } = globalObject;
  function buildRequest$2(options, req) {
    const {
      operation,
      requestBody,
      securities,
      spec,
      attachContentTypeForEmptyPayload
    } = options;
    let {
      requestContentType
    } = options;
    req = applySecurities$1({
      request: req,
      securities,
      operation,
      spec
    });
    const requestBodyDef = operation.requestBody || {};
    const requestBodyMediaTypes = Object.keys(requestBodyDef.content || {});
    const isExplicitContentTypeValid = requestContentType && requestBodyMediaTypes.indexOf(requestContentType) > -1;
    if (requestBody || attachContentTypeForEmptyPayload) {
      if (requestContentType && isExplicitContentTypeValid) {
        req.headers["Content-Type"] = requestContentType;
      } else if (!requestContentType) {
        const firstMediaType = requestBodyMediaTypes[0];
        if (firstMediaType) {
          req.headers["Content-Type"] = firstMediaType;
          requestContentType = firstMediaType;
        }
      }
    } else if (requestContentType && isExplicitContentTypeValid) {
      req.headers["Content-Type"] = requestContentType;
    }
    if (!options.responseContentType && operation.responses) {
      const mediaTypes2 = Object.entries(operation.responses).filter((_ref) => {
        let [key, value2] = _ref;
        const code2 = parseInt(key, 10);
        return code2 >= 200 && code2 < 300 && isPlainObject(value2.content);
      }).reduce((acc, _ref2) => {
        let [, value2] = _ref2;
        return acc.concat(Object.keys(value2.content));
      }, []);
      if (mediaTypes2.length > 0) {
        req.headers.accept = mediaTypes2.join(", ");
      }
    }
    if (requestBody) {
      if (requestContentType) {
        if (requestBodyMediaTypes.indexOf(requestContentType) > -1) {
          if (requestContentType === "application/x-www-form-urlencoded" || requestContentType === "multipart/form-data") {
            if (typeof requestBody === "object") {
              var _requestBodyDef$conte, _requestBodyDef$conte2;
              const encoding = (_requestBodyDef$conte = (_requestBodyDef$conte2 = requestBodyDef.content[requestContentType]) === null || _requestBodyDef$conte2 === void 0 ? void 0 : _requestBodyDef$conte2.encoding) !== null && _requestBodyDef$conte !== void 0 ? _requestBodyDef$conte : {};
              req.form = {};
              Object.keys(requestBody).forEach((k2) => {
                req.form[k2] = {
                  value: requestBody[k2],
                  encoding: encoding[k2] || {}
                };
              });
            } else {
              req.form = requestBody;
            }
          } else {
            req.body = requestBody;
          }
        }
      } else {
        req.body = requestBody;
      }
    }
    return req;
  }
  function applySecurities$1(_ref3) {
    var _spec$components;
    let {
      request,
      securities = {},
      operation = {},
      spec
    } = _ref3;
    const result = {
      ...request
    };
    const {
      authorized = {}
    } = securities;
    const security = operation.security || spec.security || [];
    const isAuthorized = authorized && !!Object.keys(authorized).length;
    const securityDef = (spec === null || spec === void 0 || (_spec$components = spec.components) === null || _spec$components === void 0 ? void 0 : _spec$components.securitySchemes) || {};
    result.headers = result.headers || {};
    result.query = result.query || {};
    if (!Object.keys(securities).length || !isAuthorized || !security || Array.isArray(operation.security) && !operation.security.length) {
      return request;
    }
    security.forEach((securityObj) => {
      Object.keys(securityObj).forEach((key) => {
        const auth = authorized[key];
        const schema2 = securityDef[key];
        if (!auth) {
          return;
        }
        const value2 = auth.value || auth;
        const {
          type: type2
        } = schema2;
        if (auth) {
          if (type2 === "apiKey") {
            if (schema2.in === "query") {
              result.query[schema2.name] = value2;
            }
            if (schema2.in === "header") {
              result.headers[schema2.name] = value2;
            }
            if (schema2.in === "cookie") {
              result.cookies[schema2.name] = value2;
            }
          } else if (type2 === "http") {
            if (/^basic$/i.test(schema2.scheme)) {
              const username = value2.username || "";
              const password = value2.password || "";
              const encoded = btoa$1(`${username}:${password}`);
              result.headers.Authorization = `Basic ${encoded}`;
            }
            if (/^bearer$/i.test(schema2.scheme)) {
              result.headers.Authorization = `Bearer ${value2}`;
            }
          } else if (type2 === "oauth2" || type2 === "openIdConnect") {
            const token = auth.token || {};
            const tokenName = schema2["x-tokenName"] || "access_token";
            const tokenValue = token[tokenName];
            let tokenType = token.token_type;
            if (!tokenType || tokenType.toLowerCase() === "bearer") {
              tokenType = "Bearer";
            }
            result.headers.Authorization = `${tokenType} ${tokenValue}`;
          }
        }
      });
    });
    return result;
  }
  function buildRequest$1(options, req) {
    const {
      spec,
      operation,
      securities,
      requestContentType,
      responseContentType,
      attachContentTypeForEmptyPayload
    } = options;
    req = applySecurities({
      request: req,
      securities,
      operation,
      spec
    });
    if (req.body || req.form || attachContentTypeForEmptyPayload) {
      if (requestContentType) {
        req.headers["Content-Type"] = requestContentType;
      } else if (Array.isArray(operation.consumes)) {
        [req.headers["Content-Type"]] = operation.consumes;
      } else if (Array.isArray(spec.consumes)) {
        [req.headers["Content-Type"]] = spec.consumes;
      } else if (operation.parameters && operation.parameters.filter((p2) => p2.type === "file").length) {
        req.headers["Content-Type"] = "multipart/form-data";
      } else if (operation.parameters && operation.parameters.filter((p2) => p2.in === "formData").length) {
        req.headers["Content-Type"] = "application/x-www-form-urlencoded";
      }
    } else if (requestContentType) {
      const isBodyParamPresent = operation.parameters && operation.parameters.filter((p2) => p2.in === "body").length > 0;
      const isFormDataParamPresent = operation.parameters && operation.parameters.filter((p2) => p2.in === "formData").length > 0;
      if (isBodyParamPresent || isFormDataParamPresent) {
        req.headers["Content-Type"] = requestContentType;
      }
    }
    if (!responseContentType && Array.isArray(operation.produces) && operation.produces.length > 0) {
      req.headers.accept = operation.produces.join(", ");
    }
    return req;
  }
  function applySecurities(_ref) {
    let {
      request,
      securities = {},
      operation = {},
      spec
    } = _ref;
    const result = {
      ...request
    };
    const {
      authorized = {},
      specSecurity = []
    } = securities;
    const security = operation.security || specSecurity;
    const isAuthorized = authorized && !!Object.keys(authorized).length;
    const securityDef = spec.securityDefinitions;
    result.headers = result.headers || {};
    result.query = result.query || {};
    if (!Object.keys(securities).length || !isAuthorized || !security || Array.isArray(operation.security) && !operation.security.length) {
      return request;
    }
    security.forEach((securityObj) => {
      Object.keys(securityObj).forEach((key) => {
        const auth = authorized[key];
        if (!auth) {
          return;
        }
        const {
          token
        } = auth;
        const value2 = auth.value || auth;
        const schema2 = securityDef[key];
        const {
          type: type2
        } = schema2;
        const tokenName = schema2["x-tokenName"] || "access_token";
        const oauthToken = token && token[tokenName];
        let tokenType = token && token.token_type;
        if (auth) {
          if (type2 === "apiKey") {
            const inType = schema2.in === "query" ? "query" : "headers";
            result[inType] = result[inType] || {};
            result[inType][schema2.name] = value2;
          } else if (type2 === "basic") {
            if (value2.header) {
              result.headers.authorization = value2.header;
            } else {
              const username = value2.username || "";
              const password = value2.password || "";
              value2.base64 = btoa$1(`${username}:${password}`);
              result.headers.authorization = `Basic ${value2.base64}`;
            }
          } else if (type2 === "oauth2" && oauthToken) {
            tokenType = !tokenType || tokenType.toLowerCase() === "bearer" ? "Bearer" : tokenType;
            result.headers.authorization = `${tokenType} ${oauthToken}`;
          }
        }
      });
    });
    return result;
  }
  const arrayOrEmpty = (ar) => Array.isArray(ar) ? ar : [];
  const parseURIReference = (uriReference) => {
    try {
      return new URL(uriReference);
    } catch {
      const parsedURL = new URL(uriReference, DEFAULT_BASE_URL);
      const pathname = String(uriReference).startsWith("/") ? parsedURL.pathname : parsedURL.pathname.substring(1);
      return {
        hash: parsedURL.hash,
        host: "",
        hostname: "",
        href: "",
        origin: "",
        password: "",
        pathname,
        port: "",
        protocol: "",
        search: parsedURL.search,
        searchParams: parsedURL.searchParams
      };
    }
  };
  const OperationNotFoundError = createErrorType("OperationNotFoundError", function cb(message, extra, oriError) {
    this.originalError = oriError;
    Object.assign(this, extra || {});
  });
  const findParametersWithName = (name, parameters2) => parameters2.filter((p2) => p2.name === name);
  const deduplicateParameters = (parameters2) => {
    const paramsMap = {};
    parameters2.forEach((p2) => {
      if (!paramsMap[p2.in]) {
        paramsMap[p2.in] = {};
      }
      paramsMap[p2.in][p2.name] = p2;
    });
    const dedupedParameters = [];
    Object.keys(paramsMap).forEach((i2) => {
      Object.keys(paramsMap[i2]).forEach((p2) => {
        dedupedParameters.push(paramsMap[i2][p2]);
      });
    });
    return dedupedParameters;
  };
  const self$1 = {
    buildRequest
  };
  function execute(_ref) {
    let {
      http: userHttp,
      fetch: fetch2,
      // This is legacy
      spec,
      operationId,
      pathName,
      method,
      parameters: parameters2,
      securities,
      ...extras
    } = _ref;
    const http$1 = userHttp || fetch2 || http;
    if (pathName && method && !operationId) {
      operationId = idFromPathMethodLegacy(pathName, method);
    }
    const request = self$1.buildRequest({
      spec,
      operationId,
      parameters: parameters2,
      securities,
      http: http$1,
      ...extras
    });
    if (request.body && (isPlainObject(request.body) || Array.isArray(request.body))) {
      request.body = JSON.stringify(request.body);
    }
    return http$1(request);
  }
  function buildRequest(options) {
    const {
      spec,
      operationId,
      responseContentType,
      scheme,
      requestInterceptor,
      responseInterceptor,
      contextUrl,
      userFetch,
      server,
      serverVariables,
      http: http2,
      signal
    } = options;
    let {
      parameters: parameters2,
      parameterBuilders
    } = options;
    const specIsOAS3 = isOpenAPI3(spec);
    if (!parameterBuilders) {
      if (specIsOAS3) {
        parameterBuilders = OAS3_PARAMETER_BUILDERS;
      } else {
        parameterBuilders = SWAGGER2_PARAMETER_BUILDERS;
      }
    }
    const credentials = http2 && http2.withCredentials ? "include" : "same-origin";
    let req = {
      url: "",
      credentials,
      headers: {},
      cookies: {}
    };
    if (signal) {
      req.signal = signal;
    }
    if (requestInterceptor) {
      req.requestInterceptor = requestInterceptor;
    }
    if (responseInterceptor) {
      req.responseInterceptor = responseInterceptor;
    }
    if (userFetch) {
      req.userFetch = userFetch;
    }
    const operationRaw = getOperationRaw(spec, operationId);
    if (!operationRaw) {
      throw new OperationNotFoundError(`Operation ${operationId} not found`);
    }
    const {
      operation = {},
      method,
      pathName
    } = operationRaw;
    req.url += baseUrl({
      spec,
      scheme,
      contextUrl,
      server,
      serverVariables,
      pathName,
      method
    });
    if (!operationId) {
      delete req.cookies;
      return req;
    }
    req.url += pathName;
    req.method = `${method}`.toUpperCase();
    parameters2 = parameters2 || {};
    const path2 = spec.paths[pathName] || {};
    if (responseContentType) {
      req.headers.accept = responseContentType;
    }
    const combinedParameters = deduplicateParameters([].concat(arrayOrEmpty(operation.parameters)).concat(arrayOrEmpty(path2.parameters)));
    combinedParameters.forEach((parameter) => {
      const builder = parameterBuilders[parameter.in];
      let value2;
      if (parameter.in === "body" && parameter.schema && parameter.schema.properties) {
        value2 = parameters2;
      }
      value2 = parameter && parameter.name && parameters2[parameter.name];
      if (typeof value2 === "undefined") {
        value2 = parameter && parameter.name && parameters2[`${parameter.in}.${parameter.name}`];
      } else if (findParametersWithName(parameter.name, combinedParameters).length > 1) {
        console.warn(`Parameter '${parameter.name}' is ambiguous because the defined spec has more than one parameter with the name: '${parameter.name}' and the passed-in parameter values did not define an 'in' value.`);
      }
      if (value2 === null) {
        return;
      }
      if (typeof parameter.default !== "undefined" && typeof value2 === "undefined") {
        value2 = parameter.default;
      }
      if (typeof value2 === "undefined" && parameter.required && !parameter.allowEmptyValue) {
        throw new Error(`Required parameter ${parameter.name} is not provided`);
      }
      if (specIsOAS3 && parameter.schema && parameter.schema.type === "object" && typeof value2 === "string") {
        try {
          value2 = JSON.parse(value2);
        } catch (e) {
          throw new Error("Could not parse object parameter value string as JSON");
        }
      }
      if (builder) {
        builder({
          req,
          parameter,
          value: value2,
          operation,
          spec
        });
      }
    });
    const versionSpecificOptions = {
      ...options,
      operation
    };
    if (specIsOAS3) {
      req = buildRequest$2(versionSpecificOptions, req);
    } else {
      req = buildRequest$1(versionSpecificOptions, req);
    }
    if (req.cookies && Object.keys(req.cookies).length) {
      const cookieString = Object.keys(req.cookies).reduce((prev2, cookieName) => {
        const cookieValue = req.cookies[cookieName];
        const prefix = prev2 ? "&" : "";
        const stringified = cookie$1.serialize(cookieName, cookieValue);
        return prev2 + prefix + stringified;
      }, "");
      req.headers.Cookie = cookieString;
    }
    if (req.cookies) {
      delete req.cookies;
    }
    mergeInQueryOrForm(req);
    return req;
  }
  const stripNonAlpha = (str2) => str2 ? str2.replace(/\W/g, "") : null;
  function baseUrl(obj) {
    const specIsOAS3 = isOpenAPI3(obj.spec);
    return specIsOAS3 ? oas3BaseUrl(obj) : swagger2BaseUrl(obj);
  }
  function oas3BaseUrl(_ref2) {
    var _spec$paths, _spec$paths2;
    let {
      spec,
      pathName,
      method,
      server,
      contextUrl,
      serverVariables = {}
    } = _ref2;
    const servers = (spec === null || spec === void 0 || (_spec$paths = spec.paths) === null || _spec$paths === void 0 || (_spec$paths = _spec$paths[pathName]) === null || _spec$paths === void 0 || (_spec$paths = _spec$paths[(method || "").toLowerCase()]) === null || _spec$paths === void 0 ? void 0 : _spec$paths.servers) || (spec === null || spec === void 0 || (_spec$paths2 = spec.paths) === null || _spec$paths2 === void 0 || (_spec$paths2 = _spec$paths2[pathName]) === null || _spec$paths2 === void 0 ? void 0 : _spec$paths2.servers) || (spec === null || spec === void 0 ? void 0 : spec.servers);
    let selectedServerUrl = "";
    let selectedServerObj = null;
    if (server && servers && servers.length) {
      const serverUrls = servers.map((srv) => srv.url);
      if (serverUrls.indexOf(server) > -1) {
        selectedServerUrl = server;
        selectedServerObj = servers[serverUrls.indexOf(server)];
      }
    }
    if (!selectedServerUrl && servers && servers.length) {
      selectedServerUrl = servers[0].url;
      [selectedServerObj] = servers;
    }
    if (selectedServerUrl.indexOf("{") > -1) {
      const varNames = getVariableTemplateNames(selectedServerUrl);
      varNames.forEach((vari) => {
        if (selectedServerObj.variables && selectedServerObj.variables[vari]) {
          const variableDefinition = selectedServerObj.variables[vari];
          const variableValue = serverVariables[vari] || variableDefinition.default;
          const re2 = new RegExp(`{${vari}}`, "g");
          selectedServerUrl = selectedServerUrl.replace(re2, variableValue);
        }
      });
    }
    return buildOas3UrlWithContext(selectedServerUrl, contextUrl);
  }
  function buildOas3UrlWithContext() {
    let ourUrl = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    let contextUrl = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const parsedUrl = ourUrl && contextUrl ? parseURIReference(resolve$2(contextUrl, ourUrl)) : parseURIReference(ourUrl);
    const parsedContextUrl = parseURIReference(contextUrl);
    const computedScheme = stripNonAlpha(parsedUrl.protocol) || stripNonAlpha(parsedContextUrl.protocol);
    const computedHost = parsedUrl.host || parsedContextUrl.host;
    const computedPath = parsedUrl.pathname;
    let res;
    if (computedScheme && computedHost) {
      res = `${computedScheme}://${computedHost + computedPath}`;
    } else {
      res = computedPath;
    }
    return res[res.length - 1] === "/" ? res.slice(0, -1) : res;
  }
  function getVariableTemplateNames(str2) {
    const results = [];
    const re2 = /{([^}]+)}/g;
    let text;
    while (text = re2.exec(str2)) {
      results.push(text[1]);
    }
    return results;
  }
  function swagger2BaseUrl(_ref3) {
    let {
      spec,
      scheme,
      contextUrl = ""
    } = _ref3;
    const parsedContextUrl = parseURIReference(contextUrl);
    const firstSchemeInSpec = Array.isArray(spec.schemes) ? spec.schemes[0] : null;
    const computedScheme = scheme || firstSchemeInSpec || stripNonAlpha(parsedContextUrl.protocol) || "http";
    const computedHost = spec.host || parsedContextUrl.host || "";
    const computedPath = spec.basePath || "";
    let res;
    if (computedScheme && computedHost) {
      res = `${computedScheme}://${computedHost + computedPath}`;
    } else {
      res = computedPath;
    }
    return res[res.length - 1] === "/" ? res.slice(0, -1) : res;
  }
  Swagger.http = http;
  Swagger.makeHttp = makeHttp.bind(null, Swagger.http);
  Swagger.resolveStrategies = {
    "openapi-3-1-apidom": openApi31ApiDOMStrategy,
    "openapi-3-0": openApi30Strategy,
    "openapi-2-0": openApi2Strategy,
    generic: genericStrategy
  };
  Swagger.resolve = makeResolve({
    strategies: [Swagger.resolveStrategies["openapi-3-1-apidom"], Swagger.resolveStrategies["openapi-3-0"], Swagger.resolveStrategies["openapi-2-0"], Swagger.resolveStrategies.generic]
  });
  Swagger.resolveSubtree = makeResolveSubtree({
    strategies: [Swagger.resolveStrategies["openapi-3-1-apidom"], Swagger.resolveStrategies["openapi-3-0"], Swagger.resolveStrategies["openapi-2-0"], Swagger.resolveStrategies.generic]
  });
  Swagger.execute = execute;
  Swagger.serializeRes = serializeRes;
  Swagger.serializeHeaders = serializeHeaders;
  Swagger.clearCache = clearCache;
  Swagger.makeApisTagOperation = makeApisTagOperation;
  Swagger.buildRequest = buildRequest;
  Swagger.helpers = {
    opId
  };
  Swagger.getBaseUrl = baseUrl;
  Swagger.apidom = {
    resolve: {
      resolvers: {
        HttpResolverSwaggerClient
      }
    },
    parse: {
      parsers: {
        JsonParser,
        YamlParser,
        OpenApiJson3_1Parser,
        OpenApiYaml3_1Parser
      }
    },
    dereference: {
      strategies: {
        OpenApi3_1SwaggerClientDereferenceStrategy
      }
    }
  };
  function Swagger(url2) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (typeof url2 === "string") {
      opts.url = url2;
    } else {
      opts = url2;
    }
    if (!(this instanceof Swagger)) {
      return new Swagger(opts);
    }
    Object.assign(this, opts);
    const prom = this.resolve().then(() => {
      if (!this.disableInterfaces) {
        Object.assign(this, Swagger.makeApisTagOperation(this));
      }
      return this;
    });
    prom.client = this;
    return prom;
  }
  Swagger.prototype = {
    http,
    execute(options) {
      this.applyDefaults();
      return Swagger.execute({
        spec: this.spec,
        http: this.http,
        securities: {
          authorized: this.authorizations
        },
        contextUrl: typeof this.url === "string" ? this.url : void 0,
        requestInterceptor: this.requestInterceptor || null,
        responseInterceptor: this.responseInterceptor || null,
        ...options
      });
    },
    resolve() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return Swagger.resolve({
        spec: this.spec,
        url: this.url,
        http: this.http || this.fetch,
        allowMetaPatches: this.allowMetaPatches,
        useCircularStructures: this.useCircularStructures,
        requestInterceptor: this.requestInterceptor || null,
        responseInterceptor: this.responseInterceptor || null,
        skipNormalization: this.skipNormalization || false,
        ...options
      }).then((obj) => {
        this.originalSpec = this.spec;
        this.spec = obj.spec;
        this.errors = obj.errors;
        return this;
      });
    }
  };
  Swagger.prototype.applyDefaults = function applyDefaults() {
    const {
      spec
    } = this;
    const specUrl = this.url;
    if (specUrl && specUrl.startsWith("http")) {
      const parsed = new URL(specUrl);
      if (!spec.host) {
        spec.host = parsed.host;
      }
      if (!spec.schemes) {
        spec.schemes = [parsed.protocol.replace(":", "")];
      }
      if (!spec.basePath) {
        spec.basePath = "/";
      }
    }
  };
  const {
    helpers
  } = Swagger;
  const es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: Swagger,
    helpers
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(es);
  var __assign = commonjsGlobal && commonjsGlobal.__assign || function() {
    __assign = Object.assign || function(t2) {
      for (var s, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s = arguments[i2];
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2))
            t2[p2] = s[p2];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  var __awaiter$3 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve2) {
        resolve2(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve2, reject2) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject2(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject2(e);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator$1 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f2, y, t2, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n2) {
      return function(v) {
        return step([n2, v]);
      };
    }
    function step(op) {
      if (f2)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _)
        try {
          if (f2 = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t2[1]) {
                _.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _.label < t2[2]) {
                _.label = t2[2];
                _.ops.push(op);
                break;
              }
              if (t2[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f2 = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  var __importDefault$b = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(lib$6, "__esModule", { value: true });
  var swagger_client_1 = __importDefault$b(require$$0$2);
  var TAG$2 = " | Client | ";
  function customHttpClient(req) {
    return new Promise(function(resolve2, reject2) {
      var timer2 = setTimeout(function() {
        reject2(new Error("Request timed out"));
      }, 1e4);
      swagger_client_1.default.http(req).then(function(response) {
        clearTimeout(timer2);
        resolve2(response);
      }).catch(function(err) {
        clearTimeout(timer2);
        reject2(err);
      });
    });
  }
  var Pioneer = (
    /** @class */
    function() {
      function Pioneer2(spec, config2) {
        this.spec = spec;
        this.queryKey = config2.queryKey;
        this.pioneer = {};
        this.timeout = config2.queryKey || 45e3;
      }
      Pioneer2.prototype.init = function() {
        return __awaiter$3(this, void 0, void 0, function() {
          var _a3, e_1;
          var _this = this;
          return __generator$1(this, function(_b) {
            switch (_b.label) {
              case 0:
                _b.label = 1;
              case 1:
                _b.trys.push([1, 3, , 4]);
                if (!this.queryKey)
                  throw Error(" You must create an api key! ");
                _a3 = this;
                return [4, new swagger_client_1.default({
                  url: this.spec,
                  requestInterceptor: function(req) {
                    req.headers.Authorization = _this.queryKey;
                    return req;
                  },
                  http: customHttpClient
                })];
              case 2:
                _a3.client = _b.sent();
                Object.keys(this.client.spec.paths).forEach(function(path2) {
                  Object.keys(_this.client.spec.paths[path2]).forEach(function(method) {
                    var operationId = _this.client.spec.paths[path2][method].operationId;
                    _this.pioneer[operationId] = function(parameters2) {
                      return __awaiter$3(_this, void 0, void 0, function() {
                        var request, result, e_2;
                        return __generator$1(this, function(_a4) {
                          switch (_a4.label) {
                            case 0:
                              _a4.trys.push([0, 2, , 3]);
                              request = {
                                operationId,
                                parameters: __assign(__assign({}, parameters2), { Authorization: this.queryKey }),
                                responseContentType: "application/json"
                              };
                              if (method === "post") {
                                request.requestBody = parameters2;
                              }
                              return [4, this.client.execute(request)];
                            case 1:
                              result = _a4.sent();
                              return [2, { data: result.body }];
                            case 2:
                              e_2 = _a4.sent();
                              console.error(e_2);
                              throw e_2;
                            case 3:
                              return [
                                2
                                /*return*/
                              ];
                          }
                        });
                      });
                    };
                  });
                });
                return [2, this.pioneer];
              case 3:
                e_1 = _b.sent();
                console.error(TAG$2 + "error: ", e_1);
                throw e_1;
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      return Pioneer2;
    }()
  );
  lib$6.default = Pioneer;
  var lib$3 = {};
  var dist = {};
  var arkeo = {};
  var utils$5 = {};
  /*! *****************************************************************************
  	Copyright (c) Microsoft Corporation.
  
  	Permission to use, copy, modify, and/or distribute this software for any
  	purpose with or without fee is hereby granted.
  
  	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  	PERFORMANCE OF THIS SOFTWARE.
  	***************************************************************************** */
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (b2.hasOwnProperty(p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  function __extends(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function isFunction$2(x2) {
    return typeof x2 === "function";
  }
  var _enable_super_gross_mode_that_will_cause_bad_things = false;
  var config$1 = {
    Promise: void 0,
    set useDeprecatedSynchronousErrorHandling(value2) {
      if (value2) {
        var error = /* @__PURE__ */ new Error();
        /* @__PURE__ */ console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + error.stack);
      }
      _enable_super_gross_mode_that_will_cause_bad_things = value2;
    },
    get useDeprecatedSynchronousErrorHandling() {
      return _enable_super_gross_mode_that_will_cause_bad_things;
    }
  };
  function hostReportError(err) {
    setTimeout(function() {
      throw err;
    }, 0);
  }
  var empty$2 = {
    closed: true,
    next: function(value2) {
    },
    error: function(err) {
      if (config$1.useDeprecatedSynchronousErrorHandling) {
        throw err;
      } else {
        hostReportError(err);
      }
    },
    complete: function() {
    }
  };
  var isArray = /* @__PURE__ */ function() {
    return Array.isArray || function(x2) {
      return x2 && typeof x2.length === "number";
    };
  }();
  function isObject$1(x2) {
    return x2 !== null && typeof x2 === "object";
  }
  var UnsubscriptionErrorImpl = /* @__PURE__ */ function() {
    function UnsubscriptionErrorImpl2(errors) {
      Error.call(this);
      this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
        return i2 + 1 + ") " + err.toString();
      }).join("\n  ") : "";
      this.name = "UnsubscriptionError";
      this.errors = errors;
      return this;
    }
    UnsubscriptionErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
    return UnsubscriptionErrorImpl2;
  }();
  var UnsubscriptionError = UnsubscriptionErrorImpl;
  var Subscription = /* @__PURE__ */ function() {
    function Subscription2(unsubscribe) {
      this.closed = false;
      this._parentOrParents = null;
      this._subscriptions = null;
      if (unsubscribe) {
        this._ctorUnsubscribe = true;
        this._unsubscribe = unsubscribe;
      }
    }
    Subscription2.prototype.unsubscribe = function() {
      var errors;
      if (this.closed) {
        return;
      }
      var _a3 = this, _parentOrParents = _a3._parentOrParents, _ctorUnsubscribe = _a3._ctorUnsubscribe, _unsubscribe = _a3._unsubscribe, _subscriptions = _a3._subscriptions;
      this.closed = true;
      this._parentOrParents = null;
      this._subscriptions = null;
      if (_parentOrParents instanceof Subscription2) {
        _parentOrParents.remove(this);
      } else if (_parentOrParents !== null) {
        for (var index2 = 0; index2 < _parentOrParents.length; ++index2) {
          var parent_1 = _parentOrParents[index2];
          parent_1.remove(this);
        }
      }
      if (isFunction$2(_unsubscribe)) {
        if (_ctorUnsubscribe) {
          this._unsubscribe = void 0;
        }
        try {
          _unsubscribe.call(this);
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
        }
      }
      if (isArray(_subscriptions)) {
        var index2 = -1;
        var len2 = _subscriptions.length;
        while (++index2 < len2) {
          var sub = _subscriptions[index2];
          if (isObject$1(sub)) {
            try {
              sub.unsubscribe();
            } catch (e) {
              errors = errors || [];
              if (e instanceof UnsubscriptionError) {
                errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
              } else {
                errors.push(e);
              }
            }
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    };
    Subscription2.prototype.add = function(teardown) {
      var subscription = teardown;
      if (!teardown) {
        return Subscription2.EMPTY;
      }
      switch (typeof teardown) {
        case "function":
          subscription = new Subscription2(teardown);
        case "object":
          if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== "function") {
            return subscription;
          } else if (this.closed) {
            subscription.unsubscribe();
            return subscription;
          } else if (!(subscription instanceof Subscription2)) {
            var tmp = subscription;
            subscription = new Subscription2();
            subscription._subscriptions = [tmp];
          }
          break;
        default: {
          throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
        }
      }
      var _parentOrParents = subscription._parentOrParents;
      if (_parentOrParents === null) {
        subscription._parentOrParents = this;
      } else if (_parentOrParents instanceof Subscription2) {
        if (_parentOrParents === this) {
          return subscription;
        }
        subscription._parentOrParents = [_parentOrParents, this];
      } else if (_parentOrParents.indexOf(this) === -1) {
        _parentOrParents.push(this);
      } else {
        return subscription;
      }
      var subscriptions = this._subscriptions;
      if (subscriptions === null) {
        this._subscriptions = [subscription];
      } else {
        subscriptions.push(subscription);
      }
      return subscription;
    };
    Subscription2.prototype.remove = function(subscription) {
      var subscriptions = this._subscriptions;
      if (subscriptions) {
        var subscriptionIndex = subscriptions.indexOf(subscription);
        if (subscriptionIndex !== -1) {
          subscriptions.splice(subscriptionIndex, 1);
        }
      }
    };
    Subscription2.EMPTY = function(empty2) {
      empty2.closed = true;
      return empty2;
    }(new Subscription2());
    return Subscription2;
  }();
  function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function(errs, err) {
      return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
    }, []);
  }
  var rxSubscriber = /* @__PURE__ */ function() {
    return typeof Symbol === "function" ? /* @__PURE__ */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* @__PURE__ */ Math.random();
  }();
  var Subscriber = /* @__PURE__ */ function(_super) {
    __extends(Subscriber2, _super);
    function Subscriber2(destinationOrNext, error, complete) {
      var _this = _super.call(this) || this;
      _this.syncErrorValue = null;
      _this.syncErrorThrown = false;
      _this.syncErrorThrowable = false;
      _this.isStopped = false;
      switch (arguments.length) {
        case 0:
          _this.destination = empty$2;
          break;
        case 1:
          if (!destinationOrNext) {
            _this.destination = empty$2;
            break;
          }
          if (typeof destinationOrNext === "object") {
            if (destinationOrNext instanceof Subscriber2) {
              _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
              _this.destination = destinationOrNext;
              destinationOrNext.add(_this);
            } else {
              _this.syncErrorThrowable = true;
              _this.destination = new SafeSubscriber(_this, destinationOrNext);
            }
            break;
          }
        default:
          _this.syncErrorThrowable = true;
          _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
          break;
      }
      return _this;
    }
    Subscriber2.prototype[rxSubscriber] = function() {
      return this;
    };
    Subscriber2.create = function(next, error, complete) {
      var subscriber = new Subscriber2(next, error, complete);
      subscriber.syncErrorThrowable = false;
      return subscriber;
    };
    Subscriber2.prototype.next = function(value2) {
      if (!this.isStopped) {
        this._next(value2);
      }
    };
    Subscriber2.prototype.error = function(err) {
      if (!this.isStopped) {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber2.prototype.complete = function() {
      if (!this.isStopped) {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber2.prototype.unsubscribe = function() {
      if (this.closed) {
        return;
      }
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
    };
    Subscriber2.prototype._next = function(value2) {
      this.destination.next(value2);
    };
    Subscriber2.prototype._error = function(err) {
      this.destination.error(err);
      this.unsubscribe();
    };
    Subscriber2.prototype._complete = function() {
      this.destination.complete();
      this.unsubscribe();
    };
    Subscriber2.prototype._unsubscribeAndRecycle = function() {
      var _parentOrParents = this._parentOrParents;
      this._parentOrParents = null;
      this.unsubscribe();
      this.closed = false;
      this.isStopped = false;
      this._parentOrParents = _parentOrParents;
      return this;
    };
    return Subscriber2;
  }(Subscription);
  var SafeSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SafeSubscriber2, _super);
    function SafeSubscriber2(_parentSubscriber, observerOrNext, error, complete) {
      var _this = _super.call(this) || this;
      _this._parentSubscriber = _parentSubscriber;
      var next;
      var context2 = _this;
      if (isFunction$2(observerOrNext)) {
        next = observerOrNext;
      } else if (observerOrNext) {
        next = observerOrNext.next;
        error = observerOrNext.error;
        complete = observerOrNext.complete;
        if (observerOrNext !== empty$2) {
          context2 = Object.create(observerOrNext);
          if (isFunction$2(context2.unsubscribe)) {
            _this.add(context2.unsubscribe.bind(context2));
          }
          context2.unsubscribe = _this.unsubscribe.bind(_this);
        }
      }
      _this._context = context2;
      _this._next = next;
      _this._error = error;
      _this._complete = complete;
      return _this;
    }
    SafeSubscriber2.prototype.next = function(value2) {
      if (!this.isStopped && this._next) {
        var _parentSubscriber = this._parentSubscriber;
        if (!config$1.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(this._next, value2);
        } else if (this.__tryOrSetError(_parentSubscriber, this._next, value2)) {
          this.unsubscribe();
        }
      }
    };
    SafeSubscriber2.prototype.error = function(err) {
      if (!this.isStopped) {
        var _parentSubscriber = this._parentSubscriber;
        var useDeprecatedSynchronousErrorHandling = config$1.useDeprecatedSynchronousErrorHandling;
        if (this._error) {
          if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
            this.__tryOrUnsub(this._error, err);
            this.unsubscribe();
          } else {
            this.__tryOrSetError(_parentSubscriber, this._error, err);
            this.unsubscribe();
          }
        } else if (!_parentSubscriber.syncErrorThrowable) {
          this.unsubscribe();
          if (useDeprecatedSynchronousErrorHandling) {
            throw err;
          }
          hostReportError(err);
        } else {
          if (useDeprecatedSynchronousErrorHandling) {
            _parentSubscriber.syncErrorValue = err;
            _parentSubscriber.syncErrorThrown = true;
          } else {
            hostReportError(err);
          }
          this.unsubscribe();
        }
      }
    };
    SafeSubscriber2.prototype.complete = function() {
      var _this = this;
      if (!this.isStopped) {
        var _parentSubscriber = this._parentSubscriber;
        if (this._complete) {
          var wrappedComplete = function() {
            return _this._complete.call(_this._context);
          };
          if (!config$1.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
            this.__tryOrUnsub(wrappedComplete);
            this.unsubscribe();
          } else {
            this.__tryOrSetError(_parentSubscriber, wrappedComplete);
            this.unsubscribe();
          }
        } else {
          this.unsubscribe();
        }
      }
    };
    SafeSubscriber2.prototype.__tryOrUnsub = function(fn, value2) {
      try {
        fn.call(this._context, value2);
      } catch (err) {
        this.unsubscribe();
        if (config$1.useDeprecatedSynchronousErrorHandling) {
          throw err;
        } else {
          hostReportError(err);
        }
      }
    };
    SafeSubscriber2.prototype.__tryOrSetError = function(parent2, fn, value2) {
      if (!config$1.useDeprecatedSynchronousErrorHandling) {
        throw new Error("bad call");
      }
      try {
        fn.call(this._context, value2);
      } catch (err) {
        if (config$1.useDeprecatedSynchronousErrorHandling) {
          parent2.syncErrorValue = err;
          parent2.syncErrorThrown = true;
          return true;
        } else {
          hostReportError(err);
          return true;
        }
      }
      return false;
    };
    SafeSubscriber2.prototype._unsubscribe = function() {
      var _parentSubscriber = this._parentSubscriber;
      this._context = null;
      this._parentSubscriber = null;
      _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber2;
  }(Subscriber);
  function canReportError(observer) {
    while (observer) {
      var _a3 = observer, closed_1 = _a3.closed, destination = _a3.destination, isStopped = _a3.isStopped;
      if (closed_1 || isStopped) {
        return false;
      } else if (destination && destination instanceof Subscriber) {
        observer = destination;
      } else {
        observer = null;
      }
    }
    return true;
  }
  function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
      if (nextOrObserver instanceof Subscriber) {
        return nextOrObserver;
      }
      if (nextOrObserver[rxSubscriber]) {
        return nextOrObserver[rxSubscriber]();
      }
    }
    if (!nextOrObserver && !error && !complete) {
      return new Subscriber(empty$2);
    }
    return new Subscriber(nextOrObserver, error, complete);
  }
  var observable = /* @__PURE__ */ function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();
  function identity(x2) {
    return x2;
  }
  function pipe$1() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
  }
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev2, fn) {
        return fn(prev2);
      }, input);
    };
  }
  var Observable = /* @__PURE__ */ function() {
    function Observable2(subscribe) {
      this._isScalar = false;
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable2.prototype.lift = function(operator) {
      var observable2 = new Observable2();
      observable2.source = this;
      observable2.operator = operator;
      return observable2;
    };
    Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
      var operator = this.operator;
      var sink = toSubscriber(observerOrNext, error, complete);
      if (operator) {
        sink.add(operator.call(sink, this.source));
      } else {
        sink.add(this.source || config$1.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
      }
      if (config$1.useDeprecatedSynchronousErrorHandling) {
        if (sink.syncErrorThrowable) {
          sink.syncErrorThrowable = false;
          if (sink.syncErrorThrown) {
            throw sink.syncErrorValue;
          }
        }
      }
      return sink;
    };
    Observable2.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        if (config$1.useDeprecatedSynchronousErrorHandling) {
          sink.syncErrorThrown = true;
          sink.syncErrorValue = err;
        }
        if (canReportError(sink)) {
          sink.error(err);
        } else {
          console.warn(err);
        }
      }
    };
    Observable2.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve2, reject2) {
        var subscription;
        subscription = _this.subscribe(function(value2) {
          try {
            next(value2);
          } catch (err) {
            reject2(err);
            if (subscription) {
              subscription.unsubscribe();
            }
          }
        }, reject2, resolve2);
      });
    };
    Observable2.prototype._subscribe = function(subscriber) {
      var source = this.source;
      return source && source.subscribe(subscriber);
    };
    Observable2.prototype[observable] = function() {
      return this;
    };
    Observable2.prototype.pipe = function() {
      var operations = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      if (operations.length === 0) {
        return this;
      }
      return pipeFromArray(operations)(this);
    };
    Observable2.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve2, reject2) {
        var value2;
        _this.subscribe(function(x2) {
          return value2 = x2;
        }, function(err) {
          return reject2(err);
        }, function() {
          return resolve2(value2);
        });
      });
    };
    Observable2.create = function(subscribe) {
      return new Observable2(subscribe);
    };
    return Observable2;
  }();
  function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
      promiseCtor = config$1.Promise || Promise;
    }
    if (!promiseCtor) {
      throw new Error("no Promise impl found");
    }
    return promiseCtor;
  }
  var ObjectUnsubscribedErrorImpl = /* @__PURE__ */ function() {
    function ObjectUnsubscribedErrorImpl2() {
      Error.call(this);
      this.message = "object unsubscribed";
      this.name = "ObjectUnsubscribedError";
      return this;
    }
    ObjectUnsubscribedErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
    return ObjectUnsubscribedErrorImpl2;
  }();
  var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
  var SubjectSubscription = /* @__PURE__ */ function(_super) {
    __extends(SubjectSubscription2, _super);
    function SubjectSubscription2(subject, subscriber) {
      var _this = _super.call(this) || this;
      _this.subject = subject;
      _this.subscriber = subscriber;
      _this.closed = false;
      return _this;
    }
    SubjectSubscription2.prototype.unsubscribe = function() {
      if (this.closed) {
        return;
      }
      this.closed = true;
      var subject = this.subject;
      var observers = subject.observers;
      this.subject = null;
      if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
        return;
      }
      var subscriberIndex = observers.indexOf(this.subscriber);
      if (subscriberIndex !== -1) {
        observers.splice(subscriberIndex, 1);
      }
    };
    return SubjectSubscription2;
  }(Subscription);
  var SubjectSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SubjectSubscriber2, _super);
    function SubjectSubscriber2(destination) {
      var _this = _super.call(this, destination) || this;
      _this.destination = destination;
      return _this;
    }
    return SubjectSubscriber2;
  }(Subscriber);
  var Subject = /* @__PURE__ */ function(_super) {
    __extends(Subject2, _super);
    function Subject2() {
      var _this = _super.call(this) || this;
      _this.observers = [];
      _this.closed = false;
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject2.prototype[rxSubscriber] = function() {
      return new SubjectSubscriber(this);
    };
    Subject2.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject2.prototype.next = function(value2) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
      if (!this.isStopped) {
        var observers = this.observers;
        var len2 = observers.length;
        var copy2 = observers.slice();
        for (var i2 = 0; i2 < len2; i2++) {
          copy2[i2].next(value2);
        }
      }
    };
    Subject2.prototype.error = function(err) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
      this.hasError = true;
      this.thrownError = err;
      this.isStopped = true;
      var observers = this.observers;
      var len2 = observers.length;
      var copy2 = observers.slice();
      for (var i2 = 0; i2 < len2; i2++) {
        copy2[i2].error(err);
      }
      this.observers.length = 0;
    };
    Subject2.prototype.complete = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
      this.isStopped = true;
      var observers = this.observers;
      var len2 = observers.length;
      var copy2 = observers.slice();
      for (var i2 = 0; i2 < len2; i2++) {
        copy2[i2].complete();
      }
      this.observers.length = 0;
    };
    Subject2.prototype.unsubscribe = function() {
      this.isStopped = true;
      this.closed = true;
      this.observers = null;
    };
    Subject2.prototype._trySubscribe = function(subscriber) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      } else {
        return _super.prototype._trySubscribe.call(this, subscriber);
      }
    };
    Subject2.prototype._subscribe = function(subscriber) {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      } else if (this.hasError) {
        subscriber.error(this.thrownError);
        return Subscription.EMPTY;
      } else if (this.isStopped) {
        subscriber.complete();
        return Subscription.EMPTY;
      } else {
        this.observers.push(subscriber);
        return new SubjectSubscription(this, subscriber);
      }
    };
    Subject2.prototype.asObservable = function() {
      var observable2 = new Observable();
      observable2.source = this;
      return observable2;
    };
    Subject2.create = function(destination, source) {
      return new AnonymousSubject(destination, source);
    };
    return Subject2;
  }(Observable);
  var AnonymousSubject = /* @__PURE__ */ function(_super) {
    __extends(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source;
      return _this;
    }
    AnonymousSubject2.prototype.next = function(value2) {
      var destination = this.destination;
      if (destination && destination.next) {
        destination.next(value2);
      }
    };
    AnonymousSubject2.prototype.error = function(err) {
      var destination = this.destination;
      if (destination && destination.error) {
        this.destination.error(err);
      }
    };
    AnonymousSubject2.prototype.complete = function() {
      var destination = this.destination;
      if (destination && destination.complete) {
        this.destination.complete();
      }
    };
    AnonymousSubject2.prototype._subscribe = function(subscriber) {
      var source = this.source;
      if (source) {
        return this.source.subscribe(subscriber);
      } else {
        return Subscription.EMPTY;
      }
    };
    return AnonymousSubject2;
  }(Subject);
  function refCount() {
    return function refCountOperatorFunction(source) {
      return source.lift(new RefCountOperator(source));
    };
  }
  var RefCountOperator = /* @__PURE__ */ function() {
    function RefCountOperator2(connectable) {
      this.connectable = connectable;
    }
    RefCountOperator2.prototype.call = function(subscriber, source) {
      var connectable = this.connectable;
      connectable._refCount++;
      var refCounter = new RefCountSubscriber(subscriber, connectable);
      var subscription = source.subscribe(refCounter);
      if (!refCounter.closed) {
        refCounter.connection = connectable.connect();
      }
      return subscription;
    };
    return RefCountOperator2;
  }();
  var RefCountSubscriber = /* @__PURE__ */ function(_super) {
    __extends(RefCountSubscriber2, _super);
    function RefCountSubscriber2(destination, connectable) {
      var _this = _super.call(this, destination) || this;
      _this.connectable = connectable;
      return _this;
    }
    RefCountSubscriber2.prototype._unsubscribe = function() {
      var connectable = this.connectable;
      if (!connectable) {
        this.connection = null;
        return;
      }
      this.connectable = null;
      var refCount2 = connectable._refCount;
      if (refCount2 <= 0) {
        this.connection = null;
        return;
      }
      connectable._refCount = refCount2 - 1;
      if (refCount2 > 1) {
        this.connection = null;
        return;
      }
      var connection = this.connection;
      var sharedConnection = connectable._connection;
      this.connection = null;
      if (sharedConnection && (!connection || sharedConnection === connection)) {
        sharedConnection.unsubscribe();
      }
    };
    return RefCountSubscriber2;
  }(Subscriber);
  var ConnectableObservable = /* @__PURE__ */ function(_super) {
    __extends(ConnectableObservable2, _super);
    function ConnectableObservable2(source, subjectFactory) {
      var _this = _super.call(this) || this;
      _this.source = source;
      _this.subjectFactory = subjectFactory;
      _this._refCount = 0;
      _this._isComplete = false;
      return _this;
    }
    ConnectableObservable2.prototype._subscribe = function(subscriber) {
      return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable2.prototype.getSubject = function() {
      var subject = this._subject;
      if (!subject || subject.isStopped) {
        this._subject = this.subjectFactory();
      }
      return this._subject;
    };
    ConnectableObservable2.prototype.connect = function() {
      var connection = this._connection;
      if (!connection) {
        this._isComplete = false;
        connection = this._connection = new Subscription();
        connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
        if (connection.closed) {
          this._connection = null;
          connection = Subscription.EMPTY;
        }
      }
      return connection;
    };
    ConnectableObservable2.prototype.refCount = function() {
      return refCount()(this);
    };
    return ConnectableObservable2;
  }(Observable);
  var connectableObservableDescriptor = /* @__PURE__ */ function() {
    var connectableProto = ConnectableObservable.prototype;
    return {
      operator: { value: null },
      _refCount: { value: 0, writable: true },
      _subject: { value: null, writable: true },
      _connection: { value: null, writable: true },
      _subscribe: { value: connectableProto._subscribe },
      _isComplete: { value: connectableProto._isComplete, writable: true },
      getSubject: { value: connectableProto.getSubject },
      connect: { value: connectableProto.connect },
      refCount: { value: connectableProto.refCount }
    };
  }();
  var ConnectableSubscriber = /* @__PURE__ */ function(_super) {
    __extends(ConnectableSubscriber2, _super);
    function ConnectableSubscriber2(destination, connectable) {
      var _this = _super.call(this, destination) || this;
      _this.connectable = connectable;
      return _this;
    }
    ConnectableSubscriber2.prototype._error = function(err) {
      this._unsubscribe();
      _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber2.prototype._complete = function() {
      this.connectable._isComplete = true;
      this._unsubscribe();
      _super.prototype._complete.call(this);
    };
    ConnectableSubscriber2.prototype._unsubscribe = function() {
      var connectable = this.connectable;
      if (connectable) {
        this.connectable = null;
        var connection = connectable._connection;
        connectable._refCount = 0;
        connectable._subject = null;
        connectable._connection = null;
        if (connection) {
          connection.unsubscribe();
        }
      }
    };
    return ConnectableSubscriber2;
  }(SubjectSubscriber);
  function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
    return function(source) {
      return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
    };
  }
  var GroupByOperator = /* @__PURE__ */ function() {
    function GroupByOperator2(keySelector, elementSelector, durationSelector, subjectSelector) {
      this.keySelector = keySelector;
      this.elementSelector = elementSelector;
      this.durationSelector = durationSelector;
      this.subjectSelector = subjectSelector;
    }
    GroupByOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
    };
    return GroupByOperator2;
  }();
  var GroupBySubscriber = /* @__PURE__ */ function(_super) {
    __extends(GroupBySubscriber2, _super);
    function GroupBySubscriber2(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
      var _this = _super.call(this, destination) || this;
      _this.keySelector = keySelector;
      _this.elementSelector = elementSelector;
      _this.durationSelector = durationSelector;
      _this.subjectSelector = subjectSelector;
      _this.groups = null;
      _this.attemptedToUnsubscribe = false;
      _this.count = 0;
      return _this;
    }
    GroupBySubscriber2.prototype._next = function(value2) {
      var key;
      try {
        key = this.keySelector(value2);
      } catch (err) {
        this.error(err);
        return;
      }
      this._group(value2, key);
    };
    GroupBySubscriber2.prototype._group = function(value2, key) {
      var groups = this.groups;
      if (!groups) {
        groups = this.groups = /* @__PURE__ */ new Map();
      }
      var group = groups.get(key);
      var element;
      if (this.elementSelector) {
        try {
          element = this.elementSelector(value2);
        } catch (err) {
          this.error(err);
        }
      } else {
        element = value2;
      }
      if (!group) {
        group = this.subjectSelector ? this.subjectSelector() : new Subject();
        groups.set(key, group);
        var groupedObservable = new GroupedObservable(key, group, this);
        this.destination.next(groupedObservable);
        if (this.durationSelector) {
          var duration = void 0;
          try {
            duration = this.durationSelector(new GroupedObservable(key, group));
          } catch (err) {
            this.error(err);
            return;
          }
          this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
        }
      }
      if (!group.closed) {
        group.next(element);
      }
    };
    GroupBySubscriber2.prototype._error = function(err) {
      var groups = this.groups;
      if (groups) {
        groups.forEach(function(group, key) {
          group.error(err);
        });
        groups.clear();
      }
      this.destination.error(err);
    };
    GroupBySubscriber2.prototype._complete = function() {
      var groups = this.groups;
      if (groups) {
        groups.forEach(function(group, key) {
          group.complete();
        });
        groups.clear();
      }
      this.destination.complete();
    };
    GroupBySubscriber2.prototype.removeGroup = function(key) {
      this.groups.delete(key);
    };
    GroupBySubscriber2.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.attemptedToUnsubscribe = true;
        if (this.count === 0) {
          _super.prototype.unsubscribe.call(this);
        }
      }
    };
    return GroupBySubscriber2;
  }(Subscriber);
  var GroupDurationSubscriber = /* @__PURE__ */ function(_super) {
    __extends(GroupDurationSubscriber2, _super);
    function GroupDurationSubscriber2(key, group, parent2) {
      var _this = _super.call(this, group) || this;
      _this.key = key;
      _this.group = group;
      _this.parent = parent2;
      return _this;
    }
    GroupDurationSubscriber2.prototype._next = function(value2) {
      this.complete();
    };
    GroupDurationSubscriber2.prototype._unsubscribe = function() {
      var _a3 = this, parent2 = _a3.parent, key = _a3.key;
      this.key = this.parent = null;
      if (parent2) {
        parent2.removeGroup(key);
      }
    };
    return GroupDurationSubscriber2;
  }(Subscriber);
  var GroupedObservable = /* @__PURE__ */ function(_super) {
    __extends(GroupedObservable2, _super);
    function GroupedObservable2(key, groupSubject, refCountSubscription) {
      var _this = _super.call(this) || this;
      _this.key = key;
      _this.groupSubject = groupSubject;
      _this.refCountSubscription = refCountSubscription;
      return _this;
    }
    GroupedObservable2.prototype._subscribe = function(subscriber) {
      var subscription = new Subscription();
      var _a3 = this, refCountSubscription = _a3.refCountSubscription, groupSubject = _a3.groupSubject;
      if (refCountSubscription && !refCountSubscription.closed) {
        subscription.add(new InnerRefCountSubscription(refCountSubscription));
      }
      subscription.add(groupSubject.subscribe(subscriber));
      return subscription;
    };
    return GroupedObservable2;
  }(Observable);
  var InnerRefCountSubscription = /* @__PURE__ */ function(_super) {
    __extends(InnerRefCountSubscription2, _super);
    function InnerRefCountSubscription2(parent2) {
      var _this = _super.call(this) || this;
      _this.parent = parent2;
      parent2.count++;
      return _this;
    }
    InnerRefCountSubscription2.prototype.unsubscribe = function() {
      var parent2 = this.parent;
      if (!parent2.closed && !this.closed) {
        _super.prototype.unsubscribe.call(this);
        parent2.count -= 1;
        if (parent2.count === 0 && parent2.attemptedToUnsubscribe) {
          parent2.unsubscribe();
        }
      }
    };
    return InnerRefCountSubscription2;
  }(Subscription);
  var BehaviorSubject = /* @__PURE__ */ function(_super) {
    __extends(BehaviorSubject2, _super);
    function BehaviorSubject2(_value) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      return _this;
    }
    Object.defineProperty(BehaviorSubject2.prototype, "value", {
      get: function() {
        return this.getValue();
      },
      enumerable: true,
      configurable: true
    });
    BehaviorSubject2.prototype._subscribe = function(subscriber) {
      var subscription = _super.prototype._subscribe.call(this, subscriber);
      if (subscription && !subscription.closed) {
        subscriber.next(this._value);
      }
      return subscription;
    };
    BehaviorSubject2.prototype.getValue = function() {
      if (this.hasError) {
        throw this.thrownError;
      } else if (this.closed) {
        throw new ObjectUnsubscribedError();
      } else {
        return this._value;
      }
    };
    BehaviorSubject2.prototype.next = function(value2) {
      _super.prototype.next.call(this, this._value = value2);
    };
    return BehaviorSubject2;
  }(Subject);
  var Action$1 = /* @__PURE__ */ function(_super) {
    __extends(Action2, _super);
    function Action2(scheduler, work) {
      return _super.call(this) || this;
    }
    Action2.prototype.schedule = function(state2, delay2) {
      return this;
    };
    return Action2;
  }(Subscription);
  var AsyncAction = /* @__PURE__ */ function(_super) {
    __extends(AsyncAction2, _super);
    function AsyncAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.pending = false;
      return _this;
    }
    AsyncAction2.prototype.schedule = function(state2, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (this.closed) {
        return this;
      }
      this.state = state2;
      var id2 = this.id;
      var scheduler = this.scheduler;
      if (id2 != null) {
        this.id = this.recycleAsyncId(scheduler, id2, delay2);
      }
      this.pending = true;
      this.delay = delay2;
      this.id = this.id || this.requestAsyncId(scheduler, this.id, delay2);
      return this;
    };
    AsyncAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return setInterval(scheduler.flush.bind(scheduler, this), delay2);
    };
    AsyncAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 !== null && this.delay === delay2 && this.pending === false) {
        return id2;
      }
      clearInterval(id2);
      return void 0;
    };
    AsyncAction2.prototype.execute = function(state2, delay2) {
      if (this.closed) {
        return new Error("executing a cancelled action");
      }
      this.pending = false;
      var error = this._execute(state2, delay2);
      if (error) {
        return error;
      } else if (this.pending === false && this.id != null) {
        this.id = this.recycleAsyncId(this.scheduler, this.id, null);
      }
    };
    AsyncAction2.prototype._execute = function(state2, delay2) {
      var errored = false;
      var errorValue = void 0;
      try {
        this.work(state2);
      } catch (e) {
        errored = true;
        errorValue = !!e && e || new Error(e);
      }
      if (errored) {
        this.unsubscribe();
        return errorValue;
      }
    };
    AsyncAction2.prototype._unsubscribe = function() {
      var id2 = this.id;
      var scheduler = this.scheduler;
      var actions = scheduler.actions;
      var index2 = actions.indexOf(this);
      this.work = null;
      this.state = null;
      this.pending = false;
      this.scheduler = null;
      if (index2 !== -1) {
        actions.splice(index2, 1);
      }
      if (id2 != null) {
        this.id = this.recycleAsyncId(scheduler, id2, null);
      }
      this.delay = null;
    };
    return AsyncAction2;
  }(Action$1);
  var QueueAction = /* @__PURE__ */ function(_super) {
    __extends(QueueAction2, _super);
    function QueueAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    QueueAction2.prototype.schedule = function(state2, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 > 0) {
        return _super.prototype.schedule.call(this, state2, delay2);
      }
      this.delay = delay2;
      this.state = state2;
      this.scheduler.flush(this);
      return this;
    };
    QueueAction2.prototype.execute = function(state2, delay2) {
      return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state2, delay2) : this._execute(state2, delay2);
    };
    QueueAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
      }
      return scheduler.flush(this);
    };
    return QueueAction2;
  }(AsyncAction);
  var Scheduler = /* @__PURE__ */ function() {
    function Scheduler2(SchedulerAction, now) {
      if (now === void 0) {
        now = Scheduler2.now;
      }
      this.SchedulerAction = SchedulerAction;
      this.now = now;
    }
    Scheduler2.prototype.schedule = function(work, delay2, state2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      return new this.SchedulerAction(this, work).schedule(state2, delay2);
    };
    Scheduler2.now = function() {
      return Date.now();
    };
    return Scheduler2;
  }();
  var AsyncScheduler = /* @__PURE__ */ function(_super) {
    __extends(AsyncScheduler2, _super);
    function AsyncScheduler2(SchedulerAction, now) {
      if (now === void 0) {
        now = Scheduler.now;
      }
      var _this = _super.call(this, SchedulerAction, function() {
        if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== _this) {
          return AsyncScheduler2.delegate.now();
        } else {
          return now();
        }
      }) || this;
      _this.actions = [];
      _this.active = false;
      _this.scheduled = void 0;
      return _this;
    }
    AsyncScheduler2.prototype.schedule = function(work, delay2, state2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== this) {
        return AsyncScheduler2.delegate.schedule(work, delay2, state2);
      } else {
        return _super.prototype.schedule.call(this, work, delay2, state2);
      }
    };
    AsyncScheduler2.prototype.flush = function(action) {
      var actions = this.actions;
      if (this.active) {
        actions.push(action);
        return;
      }
      var error;
      this.active = true;
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while (action = actions.shift());
      this.active = false;
      if (error) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AsyncScheduler2;
  }(Scheduler);
  var QueueScheduler = /* @__PURE__ */ function(_super) {
    __extends(QueueScheduler2, _super);
    function QueueScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler2;
  }(AsyncScheduler);
  var queueScheduler = /* @__PURE__ */ new QueueScheduler(QueueAction);
  var queue = queueScheduler;
  var EMPTY = /* @__PURE__ */ new Observable(function(subscriber) {
    return subscriber.complete();
  });
  function empty$1(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : EMPTY;
  }
  function emptyScheduled(scheduler) {
    return new Observable(function(subscriber) {
      return scheduler.schedule(function() {
        return subscriber.complete();
      });
    });
  }
  function isScheduler(value2) {
    return value2 && typeof value2.schedule === "function";
  }
  var subscribeToArray = function(array) {
    return function(subscriber) {
      for (var i2 = 0, len2 = array.length; i2 < len2 && !subscriber.closed; i2++) {
        subscriber.next(array[i2]);
      }
      subscriber.complete();
    };
  };
  function scheduleArray(input, scheduler) {
    return new Observable(function(subscriber) {
      var sub = new Subscription();
      var i2 = 0;
      sub.add(scheduler.schedule(function() {
        if (i2 === input.length) {
          subscriber.complete();
          return;
        }
        subscriber.next(input[i2++]);
        if (!subscriber.closed) {
          sub.add(this.schedule());
        }
      }));
      return sub;
    });
  }
  function fromArray(input, scheduler) {
    if (!scheduler) {
      return new Observable(subscribeToArray(input));
    } else {
      return scheduleArray(input, scheduler);
    }
  }
  function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args[args.length - 1];
    if (isScheduler(scheduler)) {
      args.pop();
      return scheduleArray(args, scheduler);
    } else {
      return fromArray(args);
    }
  }
  function throwError(error, scheduler) {
    if (!scheduler) {
      return new Observable(function(subscriber) {
        return subscriber.error(error);
      });
    } else {
      return new Observable(function(subscriber) {
        return scheduler.schedule(dispatch$7, 0, { error, subscriber });
      });
    }
  }
  function dispatch$7(_a3) {
    var error = _a3.error, subscriber = _a3.subscriber;
    subscriber.error(error);
  }
  var NotificationKind;
  /* @__PURE__ */ (function(NotificationKind2) {
    NotificationKind2["NEXT"] = "N";
    NotificationKind2["ERROR"] = "E";
    NotificationKind2["COMPLETE"] = "C";
  })(NotificationKind || (NotificationKind = {}));
  var Notification = /* @__PURE__ */ function() {
    function Notification2(kind, value2, error) {
      this.kind = kind;
      this.value = value2;
      this.error = error;
      this.hasValue = kind === "N";
    }
    Notification2.prototype.observe = function(observer) {
      switch (this.kind) {
        case "N":
          return observer.next && observer.next(this.value);
        case "E":
          return observer.error && observer.error(this.error);
        case "C":
          return observer.complete && observer.complete();
      }
    };
    Notification2.prototype.do = function(next, error, complete) {
      var kind = this.kind;
      switch (kind) {
        case "N":
          return next && next(this.value);
        case "E":
          return error && error(this.error);
        case "C":
          return complete && complete();
      }
    };
    Notification2.prototype.accept = function(nextOrObserver, error, complete) {
      if (nextOrObserver && typeof nextOrObserver.next === "function") {
        return this.observe(nextOrObserver);
      } else {
        return this.do(nextOrObserver, error, complete);
      }
    };
    Notification2.prototype.toObservable = function() {
      var kind = this.kind;
      switch (kind) {
        case "N":
          return of(this.value);
        case "E":
          return throwError(this.error);
        case "C":
          return empty$1();
      }
      throw new Error("unexpected notification kind value");
    };
    Notification2.createNext = function(value2) {
      if (typeof value2 !== "undefined") {
        return new Notification2("N", value2);
      }
      return Notification2.undefinedValueNotification;
    };
    Notification2.createError = function(err) {
      return new Notification2("E", void 0, err);
    };
    Notification2.createComplete = function() {
      return Notification2.completeNotification;
    };
    Notification2.completeNotification = new Notification2("C");
    Notification2.undefinedValueNotification = new Notification2("N", void 0);
    return Notification2;
  }();
  function observeOn(scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return function observeOnOperatorFunction(source) {
      return source.lift(new ObserveOnOperator(scheduler, delay2));
    };
  }
  var ObserveOnOperator = /* @__PURE__ */ function() {
    function ObserveOnOperator2(scheduler, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      this.scheduler = scheduler;
      this.delay = delay2;
    }
    ObserveOnOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator2;
  }();
  var ObserveOnSubscriber = /* @__PURE__ */ function(_super) {
    __extends(ObserveOnSubscriber2, _super);
    function ObserveOnSubscriber2(destination, scheduler, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      var _this = _super.call(this, destination) || this;
      _this.scheduler = scheduler;
      _this.delay = delay2;
      return _this;
    }
    ObserveOnSubscriber2.dispatch = function(arg) {
      var notification = arg.notification, destination = arg.destination;
      notification.observe(destination);
      this.unsubscribe();
    };
    ObserveOnSubscriber2.prototype.scheduleMessage = function(notification) {
      var destination = this.destination;
      destination.add(this.scheduler.schedule(ObserveOnSubscriber2.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber2.prototype._next = function(value2) {
      this.scheduleMessage(Notification.createNext(value2));
    };
    ObserveOnSubscriber2.prototype._error = function(err) {
      this.scheduleMessage(Notification.createError(err));
      this.unsubscribe();
    };
    ObserveOnSubscriber2.prototype._complete = function() {
      this.scheduleMessage(Notification.createComplete());
      this.unsubscribe();
    };
    return ObserveOnSubscriber2;
  }(Subscriber);
  var ObserveOnMessage = /* @__PURE__ */ function() {
    function ObserveOnMessage2(notification, destination) {
      this.notification = notification;
      this.destination = destination;
    }
    return ObserveOnMessage2;
  }();
  var ReplaySubject = /* @__PURE__ */ function(_super) {
    __extends(ReplaySubject2, _super);
    function ReplaySubject2(bufferSize, windowTime2, scheduler) {
      if (bufferSize === void 0) {
        bufferSize = Number.POSITIVE_INFINITY;
      }
      if (windowTime2 === void 0) {
        windowTime2 = Number.POSITIVE_INFINITY;
      }
      var _this = _super.call(this) || this;
      _this.scheduler = scheduler;
      _this._events = [];
      _this._infiniteTimeWindow = false;
      _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
      _this._windowTime = windowTime2 < 1 ? 1 : windowTime2;
      if (windowTime2 === Number.POSITIVE_INFINITY) {
        _this._infiniteTimeWindow = true;
        _this.next = _this.nextInfiniteTimeWindow;
      } else {
        _this.next = _this.nextTimeWindow;
      }
      return _this;
    }
    ReplaySubject2.prototype.nextInfiniteTimeWindow = function(value2) {
      if (!this.isStopped) {
        var _events = this._events;
        _events.push(value2);
        if (_events.length > this._bufferSize) {
          _events.shift();
        }
      }
      _super.prototype.next.call(this, value2);
    };
    ReplaySubject2.prototype.nextTimeWindow = function(value2) {
      if (!this.isStopped) {
        this._events.push(new ReplayEvent(this._getNow(), value2));
        this._trimBufferThenGetEvents();
      }
      _super.prototype.next.call(this, value2);
    };
    ReplaySubject2.prototype._subscribe = function(subscriber) {
      var _infiniteTimeWindow = this._infiniteTimeWindow;
      var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
      var scheduler = this.scheduler;
      var len2 = _events.length;
      var subscription;
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      } else if (this.isStopped || this.hasError) {
        subscription = Subscription.EMPTY;
      } else {
        this.observers.push(subscriber);
        subscription = new SubjectSubscription(this, subscriber);
      }
      if (scheduler) {
        subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
      }
      if (_infiniteTimeWindow) {
        for (var i2 = 0; i2 < len2 && !subscriber.closed; i2++) {
          subscriber.next(_events[i2]);
        }
      } else {
        for (var i2 = 0; i2 < len2 && !subscriber.closed; i2++) {
          subscriber.next(_events[i2].value);
        }
      }
      if (this.hasError) {
        subscriber.error(this.thrownError);
      } else if (this.isStopped) {
        subscriber.complete();
      }
      return subscription;
    };
    ReplaySubject2.prototype._getNow = function() {
      return (this.scheduler || queue).now();
    };
    ReplaySubject2.prototype._trimBufferThenGetEvents = function() {
      var now = this._getNow();
      var _bufferSize = this._bufferSize;
      var _windowTime = this._windowTime;
      var _events = this._events;
      var eventsCount = _events.length;
      var spliceCount = 0;
      while (spliceCount < eventsCount) {
        if (now - _events[spliceCount].time < _windowTime) {
          break;
        }
        spliceCount++;
      }
      if (eventsCount > _bufferSize) {
        spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
      }
      if (spliceCount > 0) {
        _events.splice(0, spliceCount);
      }
      return _events;
    };
    return ReplaySubject2;
  }(Subject);
  var ReplayEvent = /* @__PURE__ */ function() {
    function ReplayEvent2(time, value2) {
      this.time = time;
      this.value = value2;
    }
    return ReplayEvent2;
  }();
  var AsyncSubject = /* @__PURE__ */ function(_super) {
    __extends(AsyncSubject2, _super);
    function AsyncSubject2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.value = null;
      _this.hasNext = false;
      _this.hasCompleted = false;
      return _this;
    }
    AsyncSubject2.prototype._subscribe = function(subscriber) {
      if (this.hasError) {
        subscriber.error(this.thrownError);
        return Subscription.EMPTY;
      } else if (this.hasCompleted && this.hasNext) {
        subscriber.next(this.value);
        subscriber.complete();
        return Subscription.EMPTY;
      }
      return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject2.prototype.next = function(value2) {
      if (!this.hasCompleted) {
        this.value = value2;
        this.hasNext = true;
      }
    };
    AsyncSubject2.prototype.error = function(error) {
      if (!this.hasCompleted) {
        _super.prototype.error.call(this, error);
      }
    };
    AsyncSubject2.prototype.complete = function() {
      this.hasCompleted = true;
      if (this.hasNext) {
        _super.prototype.next.call(this, this.value);
      }
      _super.prototype.complete.call(this);
    };
    return AsyncSubject2;
  }(Subject);
  var nextHandle = 1;
  var RESOLVED = /* @__PURE__ */ function() {
    return /* @__PURE__ */ Promise.resolve();
  }();
  var activeHandles = {};
  function findAndClearHandle(handle) {
    if (handle in activeHandles) {
      delete activeHandles[handle];
      return true;
    }
    return false;
  }
  var Immediate = {
    setImmediate: function(cb) {
      var handle = nextHandle++;
      activeHandles[handle] = true;
      RESOLVED.then(function() {
        return findAndClearHandle(handle) && cb();
      });
      return handle;
    },
    clearImmediate: function(handle) {
      findAndClearHandle(handle);
    }
  };
  var AsapAction = /* @__PURE__ */ function(_super) {
    __extends(AsapAction2, _super);
    function AsapAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    AsapAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 !== null && delay2 > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
      }
      scheduler.actions.push(this);
      return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
        return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay2);
      }
      if (scheduler.actions.length === 0) {
        Immediate.clearImmediate(id2);
        scheduler.scheduled = void 0;
      }
      return void 0;
    };
    return AsapAction2;
  }(AsyncAction);
  var AsapScheduler = /* @__PURE__ */ function(_super) {
    __extends(AsapScheduler2, _super);
    function AsapScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler2.prototype.flush = function(action) {
      this.active = true;
      this.scheduled = void 0;
      var actions = this.actions;
      var error;
      var index2 = -1;
      var count2 = actions.length;
      action = action || actions.shift();
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while (++index2 < count2 && (action = actions.shift()));
      this.active = false;
      if (error) {
        while (++index2 < count2 && (action = actions.shift())) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AsapScheduler2;
  }(AsyncScheduler);
  var asapScheduler = /* @__PURE__ */ new AsapScheduler(AsapAction);
  var asap = asapScheduler;
  var asyncScheduler = /* @__PURE__ */ new AsyncScheduler(AsyncAction);
  var async = asyncScheduler;
  var AnimationFrameAction = /* @__PURE__ */ function(_super) {
    __extends(AnimationFrameAction2, _super);
    function AnimationFrameAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 !== null && delay2 > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
      }
      scheduler.actions.push(this);
      return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function() {
        return scheduler.flush(null);
      }));
    };
    AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
        return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay2);
      }
      if (scheduler.actions.length === 0) {
        cancelAnimationFrame(id2);
        scheduler.scheduled = void 0;
      }
      return void 0;
    };
    return AnimationFrameAction2;
  }(AsyncAction);
  var AnimationFrameScheduler = /* @__PURE__ */ function(_super) {
    __extends(AnimationFrameScheduler2, _super);
    function AnimationFrameScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler2.prototype.flush = function(action) {
      this.active = true;
      this.scheduled = void 0;
      var actions = this.actions;
      var error;
      var index2 = -1;
      var count2 = actions.length;
      action = action || actions.shift();
      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while (++index2 < count2 && (action = actions.shift()));
      this.active = false;
      if (error) {
        while (++index2 < count2 && (action = actions.shift())) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    return AnimationFrameScheduler2;
  }(AsyncScheduler);
  var animationFrameScheduler = /* @__PURE__ */ new AnimationFrameScheduler(AnimationFrameAction);
  var animationFrame = animationFrameScheduler;
  var VirtualTimeScheduler = /* @__PURE__ */ function(_super) {
    __extends(VirtualTimeScheduler2, _super);
    function VirtualTimeScheduler2(SchedulerAction, maxFrames) {
      if (SchedulerAction === void 0) {
        SchedulerAction = VirtualAction;
      }
      if (maxFrames === void 0) {
        maxFrames = Number.POSITIVE_INFINITY;
      }
      var _this = _super.call(this, SchedulerAction, function() {
        return _this.frame;
      }) || this;
      _this.maxFrames = maxFrames;
      _this.frame = 0;
      _this.index = -1;
      return _this;
    }
    VirtualTimeScheduler2.prototype.flush = function() {
      var _a3 = this, actions = _a3.actions, maxFrames = _a3.maxFrames;
      var error, action;
      while ((action = actions[0]) && action.delay <= maxFrames) {
        actions.shift();
        this.frame = action.delay;
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      }
      if (error) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error;
      }
    };
    VirtualTimeScheduler2.frameTimeFactor = 10;
    return VirtualTimeScheduler2;
  }(AsyncScheduler);
  var VirtualAction = /* @__PURE__ */ function(_super) {
    __extends(VirtualAction2, _super);
    function VirtualAction2(scheduler, work, index2) {
      if (index2 === void 0) {
        index2 = scheduler.index += 1;
      }
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.index = index2;
      _this.active = true;
      _this.index = scheduler.index = index2;
      return _this;
    }
    VirtualAction2.prototype.schedule = function(state2, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (!this.id) {
        return _super.prototype.schedule.call(this, state2, delay2);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state2, delay2);
    };
    VirtualAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      this.delay = scheduler.frame + delay2;
      var actions = scheduler.actions;
      actions.push(this);
      actions.sort(VirtualAction2.sortActions);
      return true;
    };
    VirtualAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
      return void 0;
    };
    VirtualAction2.prototype._execute = function(state2, delay2) {
      if (this.active === true) {
        return _super.prototype._execute.call(this, state2, delay2);
      }
    };
    VirtualAction2.sortActions = function(a, b) {
      if (a.delay === b.delay) {
        if (a.index === b.index) {
          return 0;
        } else if (a.index > b.index) {
          return 1;
        } else {
          return -1;
        }
      } else if (a.delay > b.delay) {
        return 1;
      } else {
        return -1;
      }
    };
    return VirtualAction2;
  }(AsyncAction);
  function noop() {
  }
  function isObservable(obj) {
    return !!obj && (obj instanceof Observable || typeof obj.lift === "function" && typeof obj.subscribe === "function");
  }
  var ArgumentOutOfRangeErrorImpl = /* @__PURE__ */ function() {
    function ArgumentOutOfRangeErrorImpl2() {
      Error.call(this);
      this.message = "argument out of range";
      this.name = "ArgumentOutOfRangeError";
      return this;
    }
    ArgumentOutOfRangeErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
    return ArgumentOutOfRangeErrorImpl2;
  }();
  var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
  var EmptyErrorImpl = /* @__PURE__ */ function() {
    function EmptyErrorImpl2() {
      Error.call(this);
      this.message = "no elements in sequence";
      this.name = "EmptyError";
      return this;
    }
    EmptyErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
    return EmptyErrorImpl2;
  }();
  var EmptyError = EmptyErrorImpl;
  var TimeoutErrorImpl = /* @__PURE__ */ function() {
    function TimeoutErrorImpl2() {
      Error.call(this);
      this.message = "Timeout has occurred";
      this.name = "TimeoutError";
      return this;
    }
    TimeoutErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
    return TimeoutErrorImpl2;
  }();
  var TimeoutError = TimeoutErrorImpl;
  function map$2(project, thisArg) {
    return function mapOperation(source) {
      if (typeof project !== "function") {
        throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
      }
      return source.lift(new MapOperator(project, thisArg));
    };
  }
  var MapOperator = /* @__PURE__ */ function() {
    function MapOperator2(project, thisArg) {
      this.project = project;
      this.thisArg = thisArg;
    }
    MapOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator2;
  }();
  var MapSubscriber = /* @__PURE__ */ function(_super) {
    __extends(MapSubscriber2, _super);
    function MapSubscriber2(destination, project, thisArg) {
      var _this = _super.call(this, destination) || this;
      _this.project = project;
      _this.count = 0;
      _this.thisArg = thisArg || _this;
      return _this;
    }
    MapSubscriber2.prototype._next = function(value2) {
      var result;
      try {
        result = this.project.call(this.thisArg, value2, this.count++);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      this.destination.next(result);
    };
    return MapSubscriber2;
  }(Subscriber);
  function bindCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
      if (isScheduler(resultSelector)) {
        scheduler = resultSelector;
      } else {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map$2(function(args2) {
            return isArray(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
          }));
        };
      }
    }
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var context2 = this;
      var subject;
      var params = {
        context: context2,
        subject,
        callbackFunc,
        scheduler
      };
      return new Observable(function(subscriber) {
        if (!scheduler) {
          if (!subject) {
            subject = new AsyncSubject();
            var handler = function() {
              var innerArgs = [];
              for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                innerArgs[_i2] = arguments[_i2];
              }
              subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
              subject.complete();
            };
            try {
              callbackFunc.apply(context2, args.concat([handler]));
            } catch (err) {
              if (canReportError(subject)) {
                subject.error(err);
              } else {
                console.warn(err);
              }
            }
          }
          return subject.subscribe(subscriber);
        } else {
          var state2 = {
            args,
            subscriber,
            params
          };
          return scheduler.schedule(dispatch$6, 0, state2);
        }
      });
    };
  }
  function dispatch$6(state2) {
    var _this = this;
    var args = state2.args, subscriber = state2.subscriber, params = state2.params;
    var callbackFunc = params.callbackFunc, context2 = params.context, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
      subject = params.subject = new AsyncSubject();
      var handler = function() {
        var innerArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          innerArgs[_i] = arguments[_i];
        }
        var value2 = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
        _this.add(scheduler.schedule(dispatchNext$3, 0, { value: value2, subject }));
      };
      try {
        callbackFunc.apply(context2, args.concat([handler]));
      } catch (err) {
        subject.error(err);
      }
    }
    this.add(subject.subscribe(subscriber));
  }
  function dispatchNext$3(state2) {
    var value2 = state2.value, subject = state2.subject;
    subject.next(value2);
    subject.complete();
  }
  function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
      if (isScheduler(resultSelector)) {
        scheduler = resultSelector;
      } else {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map$2(function(args2) {
            return isArray(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
          }));
        };
      }
    }
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var params = {
        subject: void 0,
        args,
        callbackFunc,
        scheduler,
        context: this
      };
      return new Observable(function(subscriber) {
        var context2 = params.context;
        var subject = params.subject;
        if (!scheduler) {
          if (!subject) {
            subject = params.subject = new AsyncSubject();
            var handler = function() {
              var innerArgs = [];
              for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                innerArgs[_i2] = arguments[_i2];
              }
              var err = innerArgs.shift();
              if (err) {
                subject.error(err);
                return;
              }
              subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
              subject.complete();
            };
            try {
              callbackFunc.apply(context2, args.concat([handler]));
            } catch (err) {
              if (canReportError(subject)) {
                subject.error(err);
              } else {
                console.warn(err);
              }
            }
          }
          return subject.subscribe(subscriber);
        } else {
          return scheduler.schedule(dispatch$5, 0, { params, subscriber, context: context2 });
        }
      });
    };
  }
  function dispatch$5(state2) {
    var _this = this;
    var params = state2.params, subscriber = state2.subscriber, context2 = state2.context;
    var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
      subject = params.subject = new AsyncSubject();
      var handler = function() {
        var innerArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          innerArgs[_i] = arguments[_i];
        }
        var err = innerArgs.shift();
        if (err) {
          _this.add(scheduler.schedule(dispatchError, 0, { err, subject }));
        } else {
          var value2 = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
          _this.add(scheduler.schedule(dispatchNext$2, 0, { value: value2, subject }));
        }
      };
      try {
        callbackFunc.apply(context2, args.concat([handler]));
      } catch (err) {
        this.add(scheduler.schedule(dispatchError, 0, { err, subject }));
      }
    }
    this.add(subject.subscribe(subscriber));
  }
  function dispatchNext$2(arg) {
    var value2 = arg.value, subject = arg.subject;
    subject.next(value2);
    subject.complete();
  }
  function dispatchError(arg) {
    var err = arg.err, subject = arg.subject;
    subject.error(err);
  }
  var OuterSubscriber = /* @__PURE__ */ function(_super) {
    __extends(OuterSubscriber2, _super);
    function OuterSubscriber2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    OuterSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      this.destination.next(innerValue);
    };
    OuterSubscriber2.prototype.notifyError = function(error, innerSub) {
      this.destination.error(error);
    };
    OuterSubscriber2.prototype.notifyComplete = function(innerSub) {
      this.destination.complete();
    };
    return OuterSubscriber2;
  }(Subscriber);
  var InnerSubscriber = /* @__PURE__ */ function(_super) {
    __extends(InnerSubscriber2, _super);
    function InnerSubscriber2(parent2, outerValue, outerIndex) {
      var _this = _super.call(this) || this;
      _this.parent = parent2;
      _this.outerValue = outerValue;
      _this.outerIndex = outerIndex;
      _this.index = 0;
      return _this;
    }
    InnerSubscriber2.prototype._next = function(value2) {
      this.parent.notifyNext(this.outerValue, value2, this.outerIndex, this.index++, this);
    };
    InnerSubscriber2.prototype._error = function(error) {
      this.parent.notifyError(error, this);
      this.unsubscribe();
    };
    InnerSubscriber2.prototype._complete = function() {
      this.parent.notifyComplete(this);
      this.unsubscribe();
    };
    return InnerSubscriber2;
  }(Subscriber);
  var subscribeToPromise = function(promise) {
    return function(subscriber) {
      promise.then(function(value2) {
        if (!subscriber.closed) {
          subscriber.next(value2);
          subscriber.complete();
        }
      }, function(err) {
        return subscriber.error(err);
      }).then(null, hostReportError);
      return subscriber;
    };
  };
  function getSymbolIterator() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  }
  var iterator = /* @__PURE__ */ getSymbolIterator();
  var subscribeToIterable = function(iterable) {
    return function(subscriber) {
      var iterator$1 = iterable[iterator]();
      do {
        var item = void 0;
        try {
          item = iterator$1.next();
        } catch (err) {
          subscriber.error(err);
          return subscriber;
        }
        if (item.done) {
          subscriber.complete();
          break;
        }
        subscriber.next(item.value);
        if (subscriber.closed) {
          break;
        }
      } while (true);
      if (typeof iterator$1.return === "function") {
        subscriber.add(function() {
          if (iterator$1.return) {
            iterator$1.return();
          }
        });
      }
      return subscriber;
    };
  };
  var subscribeToObservable = function(obj) {
    return function(subscriber) {
      var obs = obj[observable]();
      if (typeof obs.subscribe !== "function") {
        throw new TypeError("Provided object does not correctly implement Symbol.observable");
      } else {
        return obs.subscribe(subscriber);
      }
    };
  };
  var isArrayLike = function(x2) {
    return x2 && typeof x2.length === "number" && typeof x2 !== "function";
  };
  function isPromise(value2) {
    return !!value2 && typeof value2.subscribe !== "function" && typeof value2.then === "function";
  }
  var subscribeTo = function(result) {
    if (!!result && typeof result[observable] === "function") {
      return subscribeToObservable(result);
    } else if (isArrayLike(result)) {
      return subscribeToArray(result);
    } else if (isPromise(result)) {
      return subscribeToPromise(result);
    } else if (!!result && typeof result[iterator] === "function") {
      return subscribeToIterable(result);
    } else {
      var value2 = isObject$1(result) ? "an invalid object" : "'" + result + "'";
      var msg = "You provided " + value2 + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
      throw new TypeError(msg);
    }
  };
  function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
    if (innerSubscriber === void 0) {
      innerSubscriber = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    }
    if (innerSubscriber.closed) {
      return void 0;
    }
    if (result instanceof Observable) {
      return result.subscribe(innerSubscriber);
    }
    return subscribeTo(result)(innerSubscriber);
  }
  var NONE = {};
  function combineLatest$1() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      observables[_i] = arguments[_i];
    }
    var resultSelector = void 0;
    var scheduler = void 0;
    if (isScheduler(observables[observables.length - 1])) {
      scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === "function") {
      resultSelector = observables.pop();
    }
    if (observables.length === 1 && isArray(observables[0])) {
      observables = observables[0];
    }
    return fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
  }
  var CombineLatestOperator = /* @__PURE__ */ function() {
    function CombineLatestOperator2(resultSelector) {
      this.resultSelector = resultSelector;
    }
    CombineLatestOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
    };
    return CombineLatestOperator2;
  }();
  var CombineLatestSubscriber = /* @__PURE__ */ function(_super) {
    __extends(CombineLatestSubscriber2, _super);
    function CombineLatestSubscriber2(destination, resultSelector) {
      var _this = _super.call(this, destination) || this;
      _this.resultSelector = resultSelector;
      _this.active = 0;
      _this.values = [];
      _this.observables = [];
      return _this;
    }
    CombineLatestSubscriber2.prototype._next = function(observable2) {
      this.values.push(NONE);
      this.observables.push(observable2);
    };
    CombineLatestSubscriber2.prototype._complete = function() {
      var observables = this.observables;
      var len2 = observables.length;
      if (len2 === 0) {
        this.destination.complete();
      } else {
        this.active = len2;
        this.toRespond = len2;
        for (var i2 = 0; i2 < len2; i2++) {
          var observable2 = observables[i2];
          this.add(subscribeToResult(this, observable2, void 0, i2));
        }
      }
    };
    CombineLatestSubscriber2.prototype.notifyComplete = function(unused) {
      if ((this.active -= 1) === 0) {
        this.destination.complete();
      }
    };
    CombineLatestSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
      var values2 = this.values;
      var oldVal = values2[outerIndex];
      var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
      values2[outerIndex] = innerValue;
      if (toRespond === 0) {
        if (this.resultSelector) {
          this._tryResultSelector(values2);
        } else {
          this.destination.next(values2.slice());
        }
      }
    };
    CombineLatestSubscriber2.prototype._tryResultSelector = function(values2) {
      var result;
      try {
        result = this.resultSelector.apply(this, values2);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      this.destination.next(result);
    };
    return CombineLatestSubscriber2;
  }(OuterSubscriber);
  function scheduleObservable(input, scheduler) {
    return new Observable(function(subscriber) {
      var sub = new Subscription();
      sub.add(scheduler.schedule(function() {
        var observable$1 = input[observable]();
        sub.add(observable$1.subscribe({
          next: function(value2) {
            sub.add(scheduler.schedule(function() {
              return subscriber.next(value2);
            }));
          },
          error: function(err) {
            sub.add(scheduler.schedule(function() {
              return subscriber.error(err);
            }));
          },
          complete: function() {
            sub.add(scheduler.schedule(function() {
              return subscriber.complete();
            }));
          }
        }));
      }));
      return sub;
    });
  }
  function schedulePromise(input, scheduler) {
    return new Observable(function(subscriber) {
      var sub = new Subscription();
      sub.add(scheduler.schedule(function() {
        return input.then(function(value2) {
          sub.add(scheduler.schedule(function() {
            subscriber.next(value2);
            sub.add(scheduler.schedule(function() {
              return subscriber.complete();
            }));
          }));
        }, function(err) {
          sub.add(scheduler.schedule(function() {
            return subscriber.error(err);
          }));
        });
      }));
      return sub;
    });
  }
  function scheduleIterable(input, scheduler) {
    if (!input) {
      throw new Error("Iterable cannot be null");
    }
    return new Observable(function(subscriber) {
      var sub = new Subscription();
      var iterator$1;
      sub.add(function() {
        if (iterator$1 && typeof iterator$1.return === "function") {
          iterator$1.return();
        }
      });
      sub.add(scheduler.schedule(function() {
        iterator$1 = input[iterator]();
        sub.add(scheduler.schedule(function() {
          if (subscriber.closed) {
            return;
          }
          var value2;
          var done;
          try {
            var result = iterator$1.next();
            value2 = result.value;
            done = result.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }
          if (done) {
            subscriber.complete();
          } else {
            subscriber.next(value2);
            this.schedule();
          }
        }));
      }));
      return sub;
    });
  }
  function isInteropObservable(input) {
    return input && typeof input[observable] === "function";
  }
  function isIterable(input) {
    return input && typeof input[iterator] === "function";
  }
  function scheduled(input, scheduler) {
    if (input != null) {
      if (isInteropObservable(input)) {
        return scheduleObservable(input, scheduler);
      } else if (isPromise(input)) {
        return schedulePromise(input, scheduler);
      } else if (isArrayLike(input)) {
        return scheduleArray(input, scheduler);
      } else if (isIterable(input) || typeof input === "string") {
        return scheduleIterable(input, scheduler);
      }
    }
    throw new TypeError((input !== null && typeof input || input) + " is not observable");
  }
  function from(input, scheduler) {
    if (!scheduler) {
      if (input instanceof Observable) {
        return input;
      }
      return new Observable(subscribeTo(input));
    } else {
      return scheduled(input, scheduler);
    }
  }
  var SimpleInnerSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SimpleInnerSubscriber2, _super);
    function SimpleInnerSubscriber2(parent2) {
      var _this = _super.call(this) || this;
      _this.parent = parent2;
      return _this;
    }
    SimpleInnerSubscriber2.prototype._next = function(value2) {
      this.parent.notifyNext(value2);
    };
    SimpleInnerSubscriber2.prototype._error = function(error) {
      this.parent.notifyError(error);
      this.unsubscribe();
    };
    SimpleInnerSubscriber2.prototype._complete = function() {
      this.parent.notifyComplete();
      this.unsubscribe();
    };
    return SimpleInnerSubscriber2;
  }(Subscriber);
  var SimpleOuterSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SimpleOuterSubscriber2, _super);
    function SimpleOuterSubscriber2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SimpleOuterSubscriber2.prototype.notifyNext = function(innerValue) {
      this.destination.next(innerValue);
    };
    SimpleOuterSubscriber2.prototype.notifyError = function(err) {
      this.destination.error(err);
    };
    SimpleOuterSubscriber2.prototype.notifyComplete = function() {
      this.destination.complete();
    };
    return SimpleOuterSubscriber2;
  }(Subscriber);
  function innerSubscribe(result, innerSubscriber) {
    if (innerSubscriber.closed) {
      return void 0;
    }
    if (result instanceof Observable) {
      return result.subscribe(innerSubscriber);
    }
    var subscription;
    try {
      subscription = subscribeTo(result)(innerSubscriber);
    } catch (error) {
      innerSubscriber.error(error);
    }
    return subscription;
  }
  function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === "function") {
      return function(source) {
        return source.pipe(mergeMap(function(a, i2) {
          return from(project(a, i2)).pipe(map$2(function(b, ii) {
            return resultSelector(a, b, i2, ii);
          }));
        }, concurrent));
      };
    } else if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return function(source) {
      return source.lift(new MergeMapOperator(project, concurrent));
    };
  }
  var MergeMapOperator = /* @__PURE__ */ function() {
    function MergeMapOperator2(project, concurrent) {
      if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
      }
      this.project = project;
      this.concurrent = concurrent;
    }
    MergeMapOperator2.prototype.call = function(observer, source) {
      return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator2;
  }();
  var MergeMapSubscriber = /* @__PURE__ */ function(_super) {
    __extends(MergeMapSubscriber2, _super);
    function MergeMapSubscriber2(destination, project, concurrent) {
      if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
      }
      var _this = _super.call(this, destination) || this;
      _this.project = project;
      _this.concurrent = concurrent;
      _this.hasCompleted = false;
      _this.buffer = [];
      _this.active = 0;
      _this.index = 0;
      return _this;
    }
    MergeMapSubscriber2.prototype._next = function(value2) {
      if (this.active < this.concurrent) {
        this._tryNext(value2);
      } else {
        this.buffer.push(value2);
      }
    };
    MergeMapSubscriber2.prototype._tryNext = function(value2) {
      var result;
      var index2 = this.index++;
      try {
        result = this.project(value2, index2);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      this.active++;
      this._innerSub(result);
    };
    MergeMapSubscriber2.prototype._innerSub = function(ish) {
      var innerSubscriber = new SimpleInnerSubscriber(this);
      var destination = this.destination;
      destination.add(innerSubscriber);
      var innerSubscription = innerSubscribe(ish, innerSubscriber);
      if (innerSubscription !== innerSubscriber) {
        destination.add(innerSubscription);
      }
    };
    MergeMapSubscriber2.prototype._complete = function() {
      this.hasCompleted = true;
      if (this.active === 0 && this.buffer.length === 0) {
        this.destination.complete();
      }
      this.unsubscribe();
    };
    MergeMapSubscriber2.prototype.notifyNext = function(innerValue) {
      this.destination.next(innerValue);
    };
    MergeMapSubscriber2.prototype.notifyComplete = function() {
      var buffer2 = this.buffer;
      this.active--;
      if (buffer2.length > 0) {
        this._next(buffer2.shift());
      } else if (this.active === 0 && this.hasCompleted) {
        this.destination.complete();
      }
    };
    return MergeMapSubscriber2;
  }(SimpleOuterSubscriber);
  var flatMap = mergeMap;
  function mergeAll(concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    return mergeMap(identity, concurrent);
  }
  function concatAll() {
    return mergeAll(1);
  }
  function concat$1() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      observables[_i] = arguments[_i];
    }
    return concatAll()(of.apply(void 0, observables));
  }
  function defer(observableFactory) {
    return new Observable(function(subscriber) {
      var input;
      try {
        input = observableFactory();
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
      var source = input ? from(input) : empty$1();
      return source.subscribe(subscriber);
    });
  }
  function forkJoin() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    if (sources.length === 1) {
      var first_1 = sources[0];
      if (isArray(first_1)) {
        return forkJoinInternal(first_1, null);
      }
      if (isObject$1(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
        var keys2 = Object.keys(first_1);
        return forkJoinInternal(keys2.map(function(key) {
          return first_1[key];
        }), keys2);
      }
    }
    if (typeof sources[sources.length - 1] === "function") {
      var resultSelector_1 = sources.pop();
      sources = sources.length === 1 && isArray(sources[0]) ? sources[0] : sources;
      return forkJoinInternal(sources, null).pipe(map$2(function(args) {
        return resultSelector_1.apply(void 0, args);
      }));
    }
    return forkJoinInternal(sources, null);
  }
  function forkJoinInternal(sources, keys2) {
    return new Observable(function(subscriber) {
      var len2 = sources.length;
      if (len2 === 0) {
        subscriber.complete();
        return;
      }
      var values2 = new Array(len2);
      var completed = 0;
      var emitted = 0;
      var _loop_1 = function(i3) {
        var source = from(sources[i3]);
        var hasValue = false;
        subscriber.add(source.subscribe({
          next: function(value2) {
            if (!hasValue) {
              hasValue = true;
              emitted++;
            }
            values2[i3] = value2;
          },
          error: function(err) {
            return subscriber.error(err);
          },
          complete: function() {
            completed++;
            if (completed === len2 || !hasValue) {
              if (emitted === len2) {
                subscriber.next(keys2 ? keys2.reduce(function(result, key, i4) {
                  return result[key] = values2[i4], result;
                }, {}) : values2);
              }
              subscriber.complete();
            }
          }
        }));
      };
      for (var i2 = 0; i2 < len2; i2++) {
        _loop_1(i2);
      }
    });
  }
  function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction$2(options)) {
      resultSelector = options;
      options = void 0;
    }
    if (resultSelector) {
      return fromEvent(target, eventName, options).pipe(map$2(function(args) {
        return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
      }));
    }
    return new Observable(function(subscriber) {
      function handler(e) {
        if (arguments.length > 1) {
          subscriber.next(Array.prototype.slice.call(arguments));
        } else {
          subscriber.next(e);
        }
      }
      setupSubscription(target, eventName, handler, subscriber, options);
    });
  }
  function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
    var unsubscribe;
    if (isEventTarget(sourceObj)) {
      var source_1 = sourceObj;
      sourceObj.addEventListener(eventName, handler, options);
      unsubscribe = function() {
        return source_1.removeEventListener(eventName, handler, options);
      };
    } else if (isJQueryStyleEventEmitter(sourceObj)) {
      var source_2 = sourceObj;
      sourceObj.on(eventName, handler);
      unsubscribe = function() {
        return source_2.off(eventName, handler);
      };
    } else if (isNodeStyleEventEmitter(sourceObj)) {
      var source_3 = sourceObj;
      sourceObj.addListener(eventName, handler);
      unsubscribe = function() {
        return source_3.removeListener(eventName, handler);
      };
    } else if (sourceObj && sourceObj.length) {
      for (var i2 = 0, len2 = sourceObj.length; i2 < len2; i2++) {
        setupSubscription(sourceObj[i2], eventName, handler, subscriber, options);
      }
    } else {
      throw new TypeError("Invalid event target");
    }
    subscriber.add(unsubscribe);
  }
  function isNodeStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.addListener === "function" && typeof sourceObj.removeListener === "function";
  }
  function isJQueryStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.on === "function" && typeof sourceObj.off === "function";
  }
  function isEventTarget(sourceObj) {
    return sourceObj && typeof sourceObj.addEventListener === "function" && typeof sourceObj.removeEventListener === "function";
  }
  function fromEventPattern(addHandler, removeHandler, resultSelector) {
    if (resultSelector) {
      return fromEventPattern(addHandler, removeHandler).pipe(map$2(function(args) {
        return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
      }));
    }
    return new Observable(function(subscriber) {
      var handler = function() {
        var e = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          e[_i] = arguments[_i];
        }
        return subscriber.next(e.length === 1 ? e[0] : e);
      };
      var retValue;
      try {
        retValue = addHandler(handler);
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
      if (!isFunction$2(removeHandler)) {
        return void 0;
      }
      return function() {
        return removeHandler(handler, retValue);
      };
    });
  }
  function generate(initialStateOrOptions, condition, iterate2, resultSelectorOrObservable, scheduler) {
    var resultSelector;
    var initialState2;
    if (arguments.length == 1) {
      var options = initialStateOrOptions;
      initialState2 = options.initialState;
      condition = options.condition;
      iterate2 = options.iterate;
      resultSelector = options.resultSelector || identity;
      scheduler = options.scheduler;
    } else if (resultSelectorOrObservable === void 0 || isScheduler(resultSelectorOrObservable)) {
      initialState2 = initialStateOrOptions;
      resultSelector = identity;
      scheduler = resultSelectorOrObservable;
    } else {
      initialState2 = initialStateOrOptions;
      resultSelector = resultSelectorOrObservable;
    }
    return new Observable(function(subscriber) {
      var state2 = initialState2;
      if (scheduler) {
        return scheduler.schedule(dispatch$4, 0, {
          subscriber,
          iterate: iterate2,
          condition,
          resultSelector,
          state: state2
        });
      }
      do {
        if (condition) {
          var conditionResult = void 0;
          try {
            conditionResult = condition(state2);
          } catch (err) {
            subscriber.error(err);
            return void 0;
          }
          if (!conditionResult) {
            subscriber.complete();
            break;
          }
        }
        var value2 = void 0;
        try {
          value2 = resultSelector(state2);
        } catch (err) {
          subscriber.error(err);
          return void 0;
        }
        subscriber.next(value2);
        if (subscriber.closed) {
          break;
        }
        try {
          state2 = iterate2(state2);
        } catch (err) {
          subscriber.error(err);
          return void 0;
        }
      } while (true);
      return void 0;
    });
  }
  function dispatch$4(state2) {
    var subscriber = state2.subscriber, condition = state2.condition;
    if (subscriber.closed) {
      return void 0;
    }
    if (state2.needIterate) {
      try {
        state2.state = state2.iterate(state2.state);
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
    } else {
      state2.needIterate = true;
    }
    if (condition) {
      var conditionResult = void 0;
      try {
        conditionResult = condition(state2.state);
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
      if (!conditionResult) {
        subscriber.complete();
        return void 0;
      }
      if (subscriber.closed) {
        return void 0;
      }
    }
    var value2;
    try {
      value2 = state2.resultSelector(state2.state);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    if (subscriber.closed) {
      return void 0;
    }
    subscriber.next(value2);
    if (subscriber.closed) {
      return void 0;
    }
    return this.schedule(state2);
  }
  function iif(condition, trueResult, falseResult) {
    if (trueResult === void 0) {
      trueResult = EMPTY;
    }
    if (falseResult === void 0) {
      falseResult = EMPTY;
    }
    return defer(function() {
      return condition() ? trueResult : falseResult;
    });
  }
  function isNumeric(val) {
    return !isArray(val) && val - parseFloat(val) + 1 >= 0;
  }
  function interval(period, scheduler) {
    if (period === void 0) {
      period = 0;
    }
    if (scheduler === void 0) {
      scheduler = async;
    }
    if (!isNumeric(period) || period < 0) {
      period = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== "function") {
      scheduler = async;
    }
    return new Observable(function(subscriber) {
      subscriber.add(scheduler.schedule(dispatch$3, period, { subscriber, counter: 0, period }));
      return subscriber;
    });
  }
  function dispatch$3(state2) {
    var subscriber = state2.subscriber, counter = state2.counter, period = state2.period;
    subscriber.next(counter);
    this.schedule({ subscriber, counter: counter + 1, period }, period);
  }
  function merge$2() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      observables[_i] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last2 = observables[observables.length - 1];
    if (isScheduler(last2)) {
      scheduler = observables.pop();
      if (observables.length > 1 && typeof observables[observables.length - 1] === "number") {
        concurrent = observables.pop();
      }
    } else if (typeof last2 === "number") {
      concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
      return observables[0];
    }
    return mergeAll(concurrent)(fromArray(observables, scheduler));
  }
  var NEVER = /* @__PURE__ */ new Observable(noop);
  function never() {
    return NEVER;
  }
  function onErrorResumeNext$1() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    if (sources.length === 0) {
      return EMPTY;
    }
    var first2 = sources[0], remainder = sources.slice(1);
    if (sources.length === 1 && isArray(first2)) {
      return onErrorResumeNext$1.apply(void 0, first2);
    }
    return new Observable(function(subscriber) {
      var subNext = function() {
        return subscriber.add(onErrorResumeNext$1.apply(void 0, remainder).subscribe(subscriber));
      };
      return from(first2).subscribe({
        next: function(value2) {
          subscriber.next(value2);
        },
        error: subNext,
        complete: subNext
      });
    });
  }
  function pairs(obj, scheduler) {
    if (!scheduler) {
      return new Observable(function(subscriber) {
        var keys2 = Object.keys(obj);
        for (var i2 = 0; i2 < keys2.length && !subscriber.closed; i2++) {
          var key = keys2[i2];
          if (obj.hasOwnProperty(key)) {
            subscriber.next([key, obj[key]]);
          }
        }
        subscriber.complete();
      });
    } else {
      return new Observable(function(subscriber) {
        var keys2 = Object.keys(obj);
        var subscription = new Subscription();
        subscription.add(scheduler.schedule(dispatch$2, 0, { keys: keys2, index: 0, subscriber, subscription, obj }));
        return subscription;
      });
    }
  }
  function dispatch$2(state2) {
    var keys2 = state2.keys, index2 = state2.index, subscriber = state2.subscriber, subscription = state2.subscription, obj = state2.obj;
    if (!subscriber.closed) {
      if (index2 < keys2.length) {
        var key = keys2[index2];
        subscriber.next([key, obj[key]]);
        subscription.add(this.schedule({ keys: keys2, index: index2 + 1, subscriber, subscription, obj }));
      } else {
        subscriber.complete();
      }
    }
  }
  function not(pred, thisArg) {
    function notPred() {
      return !notPred.pred.apply(notPred.thisArg, arguments);
    }
    notPred.pred = pred;
    notPred.thisArg = thisArg;
    return notPred;
  }
  function filter$1(predicate, thisArg) {
    return function filterOperatorFunction(source) {
      return source.lift(new FilterOperator(predicate, thisArg));
    };
  }
  var FilterOperator = /* @__PURE__ */ function() {
    function FilterOperator2(predicate, thisArg) {
      this.predicate = predicate;
      this.thisArg = thisArg;
    }
    FilterOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator2;
  }();
  var FilterSubscriber = /* @__PURE__ */ function(_super) {
    __extends(FilterSubscriber2, _super);
    function FilterSubscriber2(destination, predicate, thisArg) {
      var _this = _super.call(this, destination) || this;
      _this.predicate = predicate;
      _this.thisArg = thisArg;
      _this.count = 0;
      return _this;
    }
    FilterSubscriber2.prototype._next = function(value2) {
      var result;
      try {
        result = this.predicate.call(this.thisArg, value2, this.count++);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      if (result) {
        this.destination.next(value2);
      }
    };
    return FilterSubscriber2;
  }(Subscriber);
  function partition$1(source, predicate, thisArg) {
    return [
      filter$1(predicate, thisArg)(new Observable(subscribeTo(source))),
      filter$1(not(predicate, thisArg))(new Observable(subscribeTo(source)))
    ];
  }
  function race$1() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      observables[_i] = arguments[_i];
    }
    if (observables.length === 1) {
      if (isArray(observables[0])) {
        observables = observables[0];
      } else {
        return observables[0];
      }
    }
    return fromArray(observables, void 0).lift(new RaceOperator());
  }
  var RaceOperator = /* @__PURE__ */ function() {
    function RaceOperator2() {
    }
    RaceOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator2;
  }();
  var RaceSubscriber = /* @__PURE__ */ function(_super) {
    __extends(RaceSubscriber2, _super);
    function RaceSubscriber2(destination) {
      var _this = _super.call(this, destination) || this;
      _this.hasFirst = false;
      _this.observables = [];
      _this.subscriptions = [];
      return _this;
    }
    RaceSubscriber2.prototype._next = function(observable2) {
      this.observables.push(observable2);
    };
    RaceSubscriber2.prototype._complete = function() {
      var observables = this.observables;
      var len2 = observables.length;
      if (len2 === 0) {
        this.destination.complete();
      } else {
        for (var i2 = 0; i2 < len2 && !this.hasFirst; i2++) {
          var observable2 = observables[i2];
          var subscription = subscribeToResult(this, observable2, void 0, i2);
          if (this.subscriptions) {
            this.subscriptions.push(subscription);
          }
          this.add(subscription);
        }
        this.observables = null;
      }
    };
    RaceSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
      if (!this.hasFirst) {
        this.hasFirst = true;
        for (var i2 = 0; i2 < this.subscriptions.length; i2++) {
          if (i2 !== outerIndex) {
            var subscription = this.subscriptions[i2];
            subscription.unsubscribe();
            this.remove(subscription);
          }
        }
        this.subscriptions = null;
      }
      this.destination.next(innerValue);
    };
    return RaceSubscriber2;
  }(OuterSubscriber);
  function range(start, count2, scheduler) {
    if (start === void 0) {
      start = 0;
    }
    return new Observable(function(subscriber) {
      if (count2 === void 0) {
        count2 = start;
        start = 0;
      }
      var index2 = 0;
      var current = start;
      if (scheduler) {
        return scheduler.schedule(dispatch$1, 0, {
          index: index2,
          count: count2,
          start,
          subscriber
        });
      } else {
        do {
          if (index2++ >= count2) {
            subscriber.complete();
            break;
          }
          subscriber.next(current++);
          if (subscriber.closed) {
            break;
          }
        } while (true);
      }
      return void 0;
    });
  }
  function dispatch$1(state2) {
    var start = state2.start, index2 = state2.index, count2 = state2.count, subscriber = state2.subscriber;
    if (index2 >= count2) {
      subscriber.complete();
      return;
    }
    subscriber.next(start);
    if (subscriber.closed) {
      return;
    }
    state2.index = index2 + 1;
    state2.start = start + 1;
    this.schedule(state2);
  }
  function timer(dueTime, periodOrScheduler, scheduler) {
    if (dueTime === void 0) {
      dueTime = 0;
    }
    var period = -1;
    if (isNumeric(periodOrScheduler)) {
      period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
    } else if (isScheduler(periodOrScheduler)) {
      scheduler = periodOrScheduler;
    }
    if (!isScheduler(scheduler)) {
      scheduler = async;
    }
    return new Observable(function(subscriber) {
      var due = isNumeric(dueTime) ? dueTime : +dueTime - scheduler.now();
      return scheduler.schedule(dispatch, due, {
        index: 0,
        period,
        subscriber
      });
    });
  }
  function dispatch(state2) {
    var index2 = state2.index, period = state2.period, subscriber = state2.subscriber;
    subscriber.next(index2);
    if (subscriber.closed) {
      return;
    } else if (period === -1) {
      return subscriber.complete();
    }
    state2.index = index2 + 1;
    this.schedule(state2, period);
  }
  function using(resourceFactory, observableFactory) {
    return new Observable(function(subscriber) {
      var resource;
      try {
        resource = resourceFactory();
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
      var result;
      try {
        result = observableFactory(resource);
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
      var source = result ? from(result) : EMPTY;
      var subscription = source.subscribe(subscriber);
      return function() {
        subscription.unsubscribe();
        if (resource) {
          resource.unsubscribe();
        }
      };
    });
  }
  function zip$1() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      observables[_i] = arguments[_i];
    }
    var resultSelector = observables[observables.length - 1];
    if (typeof resultSelector === "function") {
      observables.pop();
    }
    return fromArray(observables, void 0).lift(new ZipOperator(resultSelector));
  }
  var ZipOperator = /* @__PURE__ */ function() {
    function ZipOperator2(resultSelector) {
      this.resultSelector = resultSelector;
    }
    ZipOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
    };
    return ZipOperator2;
  }();
  var ZipSubscriber = /* @__PURE__ */ function(_super) {
    __extends(ZipSubscriber2, _super);
    function ZipSubscriber2(destination, resultSelector, values2) {
      var _this = _super.call(this, destination) || this;
      _this.resultSelector = resultSelector;
      _this.iterators = [];
      _this.active = 0;
      _this.resultSelector = typeof resultSelector === "function" ? resultSelector : void 0;
      return _this;
    }
    ZipSubscriber2.prototype._next = function(value2) {
      var iterators2 = this.iterators;
      if (isArray(value2)) {
        iterators2.push(new StaticArrayIterator(value2));
      } else if (typeof value2[iterator] === "function") {
        iterators2.push(new StaticIterator(value2[iterator]()));
      } else {
        iterators2.push(new ZipBufferIterator(this.destination, this, value2));
      }
    };
    ZipSubscriber2.prototype._complete = function() {
      var iterators2 = this.iterators;
      var len2 = iterators2.length;
      this.unsubscribe();
      if (len2 === 0) {
        this.destination.complete();
        return;
      }
      this.active = len2;
      for (var i2 = 0; i2 < len2; i2++) {
        var iterator2 = iterators2[i2];
        if (iterator2.stillUnsubscribed) {
          var destination = this.destination;
          destination.add(iterator2.subscribe());
        } else {
          this.active--;
        }
      }
    };
    ZipSubscriber2.prototype.notifyInactive = function() {
      this.active--;
      if (this.active === 0) {
        this.destination.complete();
      }
    };
    ZipSubscriber2.prototype.checkIterators = function() {
      var iterators2 = this.iterators;
      var len2 = iterators2.length;
      var destination = this.destination;
      for (var i2 = 0; i2 < len2; i2++) {
        var iterator2 = iterators2[i2];
        if (typeof iterator2.hasValue === "function" && !iterator2.hasValue()) {
          return;
        }
      }
      var shouldComplete = false;
      var args = [];
      for (var i2 = 0; i2 < len2; i2++) {
        var iterator2 = iterators2[i2];
        var result = iterator2.next();
        if (iterator2.hasCompleted()) {
          shouldComplete = true;
        }
        if (result.done) {
          destination.complete();
          return;
        }
        args.push(result.value);
      }
      if (this.resultSelector) {
        this._tryresultSelector(args);
      } else {
        destination.next(args);
      }
      if (shouldComplete) {
        destination.complete();
      }
    };
    ZipSubscriber2.prototype._tryresultSelector = function(args) {
      var result;
      try {
        result = this.resultSelector.apply(this, args);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      this.destination.next(result);
    };
    return ZipSubscriber2;
  }(Subscriber);
  var StaticIterator = /* @__PURE__ */ function() {
    function StaticIterator2(iterator2) {
      this.iterator = iterator2;
      this.nextResult = iterator2.next();
    }
    StaticIterator2.prototype.hasValue = function() {
      return true;
    };
    StaticIterator2.prototype.next = function() {
      var result = this.nextResult;
      this.nextResult = this.iterator.next();
      return result;
    };
    StaticIterator2.prototype.hasCompleted = function() {
      var nextResult = this.nextResult;
      return Boolean(nextResult && nextResult.done);
    };
    return StaticIterator2;
  }();
  var StaticArrayIterator = /* @__PURE__ */ function() {
    function StaticArrayIterator2(array) {
      this.array = array;
      this.index = 0;
      this.length = 0;
      this.length = array.length;
    }
    StaticArrayIterator2.prototype[iterator] = function() {
      return this;
    };
    StaticArrayIterator2.prototype.next = function(value2) {
      var i2 = this.index++;
      var array = this.array;
      return i2 < this.length ? { value: array[i2], done: false } : { value: null, done: true };
    };
    StaticArrayIterator2.prototype.hasValue = function() {
      return this.array.length > this.index;
    };
    StaticArrayIterator2.prototype.hasCompleted = function() {
      return this.array.length === this.index;
    };
    return StaticArrayIterator2;
  }();
  var ZipBufferIterator = /* @__PURE__ */ function(_super) {
    __extends(ZipBufferIterator2, _super);
    function ZipBufferIterator2(destination, parent2, observable2) {
      var _this = _super.call(this, destination) || this;
      _this.parent = parent2;
      _this.observable = observable2;
      _this.stillUnsubscribed = true;
      _this.buffer = [];
      _this.isComplete = false;
      return _this;
    }
    ZipBufferIterator2.prototype[iterator] = function() {
      return this;
    };
    ZipBufferIterator2.prototype.next = function() {
      var buffer2 = this.buffer;
      if (buffer2.length === 0 && this.isComplete) {
        return { value: null, done: true };
      } else {
        return { value: buffer2.shift(), done: false };
      }
    };
    ZipBufferIterator2.prototype.hasValue = function() {
      return this.buffer.length > 0;
    };
    ZipBufferIterator2.prototype.hasCompleted = function() {
      return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator2.prototype.notifyComplete = function() {
      if (this.buffer.length > 0) {
        this.isComplete = true;
        this.parent.notifyInactive();
      } else {
        this.destination.complete();
      }
    };
    ZipBufferIterator2.prototype.notifyNext = function(innerValue) {
      this.buffer.push(innerValue);
      this.parent.checkIterators();
    };
    ZipBufferIterator2.prototype.subscribe = function() {
      return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));
    };
    return ZipBufferIterator2;
  }(SimpleOuterSubscriber);
  const _esm5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    ArgumentOutOfRangeError,
    AsyncSubject,
    BehaviorSubject,
    ConnectableObservable,
    EMPTY,
    EmptyError,
    GroupedObservable,
    NEVER,
    Notification,
    get NotificationKind() {
      return NotificationKind;
    },
    ObjectUnsubscribedError,
    Observable,
    ReplaySubject,
    Scheduler,
    Subject,
    Subscriber,
    Subscription,
    TimeoutError,
    UnsubscriptionError,
    VirtualAction,
    VirtualTimeScheduler,
    animationFrame,
    animationFrameScheduler,
    asap,
    asapScheduler,
    async,
    asyncScheduler,
    bindCallback,
    bindNodeCallback,
    combineLatest: combineLatest$1,
    concat: concat$1,
    config: config$1,
    defer,
    empty: empty$1,
    forkJoin,
    from,
    fromEvent,
    fromEventPattern,
    generate,
    identity,
    iif,
    interval,
    isObservable,
    merge: merge$2,
    never,
    noop,
    observable,
    of,
    onErrorResumeNext: onErrorResumeNext$1,
    pairs,
    partition: partition$1,
    pipe: pipe$1,
    queue,
    queueScheduler,
    race: race$1,
    range,
    scheduled,
    throwError,
    timer,
    using,
    zip: zip$1
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(_esm5);
  function audit(durationSelector) {
    return function auditOperatorFunction(source) {
      return source.lift(new AuditOperator(durationSelector));
    };
  }
  var AuditOperator = /* @__PURE__ */ function() {
    function AuditOperator2(durationSelector) {
      this.durationSelector = durationSelector;
    }
    AuditOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
    };
    return AuditOperator2;
  }();
  var AuditSubscriber = /* @__PURE__ */ function(_super) {
    __extends(AuditSubscriber2, _super);
    function AuditSubscriber2(destination, durationSelector) {
      var _this = _super.call(this, destination) || this;
      _this.durationSelector = durationSelector;
      _this.hasValue = false;
      return _this;
    }
    AuditSubscriber2.prototype._next = function(value2) {
      this.value = value2;
      this.hasValue = true;
      if (!this.throttled) {
        var duration = void 0;
        try {
          var durationSelector = this.durationSelector;
          duration = durationSelector(value2);
        } catch (err) {
          return this.destination.error(err);
        }
        var innerSubscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
        if (!innerSubscription || innerSubscription.closed) {
          this.clearThrottle();
        } else {
          this.add(this.throttled = innerSubscription);
        }
      }
    };
    AuditSubscriber2.prototype.clearThrottle = function() {
      var _a3 = this, value2 = _a3.value, hasValue = _a3.hasValue, throttled = _a3.throttled;
      if (throttled) {
        this.remove(throttled);
        this.throttled = void 0;
        throttled.unsubscribe();
      }
      if (hasValue) {
        this.value = void 0;
        this.hasValue = false;
        this.destination.next(value2);
      }
    };
    AuditSubscriber2.prototype.notifyNext = function() {
      this.clearThrottle();
    };
    AuditSubscriber2.prototype.notifyComplete = function() {
      this.clearThrottle();
    };
    return AuditSubscriber2;
  }(SimpleOuterSubscriber);
  function auditTime(duration, scheduler) {
    if (scheduler === void 0) {
      scheduler = async;
    }
    return audit(function() {
      return timer(duration, scheduler);
    });
  }
  function buffer(closingNotifier) {
    return function bufferOperatorFunction(source) {
      return source.lift(new BufferOperator(closingNotifier));
    };
  }
  var BufferOperator = /* @__PURE__ */ function() {
    function BufferOperator2(closingNotifier) {
      this.closingNotifier = closingNotifier;
    }
    BufferOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
    };
    return BufferOperator2;
  }();
  var BufferSubscriber = /* @__PURE__ */ function(_super) {
    __extends(BufferSubscriber2, _super);
    function BufferSubscriber2(destination, closingNotifier) {
      var _this = _super.call(this, destination) || this;
      _this.buffer = [];
      _this.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(_this)));
      return _this;
    }
    BufferSubscriber2.prototype._next = function(value2) {
      this.buffer.push(value2);
    };
    BufferSubscriber2.prototype.notifyNext = function() {
      var buffer2 = this.buffer;
      this.buffer = [];
      this.destination.next(buffer2);
    };
    return BufferSubscriber2;
  }(SimpleOuterSubscriber);
  function bufferCount(bufferSize, startBufferEvery) {
    if (startBufferEvery === void 0) {
      startBufferEvery = null;
    }
    return function bufferCountOperatorFunction(source) {
      return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
    };
  }
  var BufferCountOperator = /* @__PURE__ */ function() {
    function BufferCountOperator2(bufferSize, startBufferEvery) {
      this.bufferSize = bufferSize;
      this.startBufferEvery = startBufferEvery;
      if (!startBufferEvery || bufferSize === startBufferEvery) {
        this.subscriberClass = BufferCountSubscriber;
      } else {
        this.subscriberClass = BufferSkipCountSubscriber;
      }
    }
    BufferCountOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
    };
    return BufferCountOperator2;
  }();
  var BufferCountSubscriber = /* @__PURE__ */ function(_super) {
    __extends(BufferCountSubscriber2, _super);
    function BufferCountSubscriber2(destination, bufferSize) {
      var _this = _super.call(this, destination) || this;
      _this.bufferSize = bufferSize;
      _this.buffer = [];
      return _this;
    }
    BufferCountSubscriber2.prototype._next = function(value2) {
      var buffer2 = this.buffer;
      buffer2.push(value2);
      if (buffer2.length == this.bufferSize) {
        this.destination.next(buffer2);
        this.buffer = [];
      }
    };
    BufferCountSubscriber2.prototype._complete = function() {
      var buffer2 = this.buffer;
      if (buffer2.length > 0) {
        this.destination.next(buffer2);
      }
      _super.prototype._complete.call(this);
    };
    return BufferCountSubscriber2;
  }(Subscriber);
  var BufferSkipCountSubscriber = /* @__PURE__ */ function(_super) {
    __extends(BufferSkipCountSubscriber2, _super);
    function BufferSkipCountSubscriber2(destination, bufferSize, startBufferEvery) {
      var _this = _super.call(this, destination) || this;
      _this.bufferSize = bufferSize;
      _this.startBufferEvery = startBufferEvery;
      _this.buffers = [];
      _this.count = 0;
      return _this;
    }
    BufferSkipCountSubscriber2.prototype._next = function(value2) {
      var _a3 = this, bufferSize = _a3.bufferSize, startBufferEvery = _a3.startBufferEvery, buffers = _a3.buffers, count2 = _a3.count;
      this.count++;
      if (count2 % startBufferEvery === 0) {
        buffers.push([]);
      }
      for (var i2 = buffers.length; i2--; ) {
        var buffer2 = buffers[i2];
        buffer2.push(value2);
        if (buffer2.length === bufferSize) {
          buffers.splice(i2, 1);
          this.destination.next(buffer2);
        }
      }
    };
    BufferSkipCountSubscriber2.prototype._complete = function() {
      var _a3 = this, buffers = _a3.buffers, destination = _a3.destination;
      while (buffers.length > 0) {
        var buffer2 = buffers.shift();
        if (buffer2.length > 0) {
          destination.next(buffer2);
        }
      }
      _super.prototype._complete.call(this);
    };
    return BufferSkipCountSubscriber2;
  }(Subscriber);
  function bufferTime(bufferTimeSpan) {
    var length2 = arguments.length;
    var scheduler = async;
    if (isScheduler(arguments[arguments.length - 1])) {
      scheduler = arguments[arguments.length - 1];
      length2--;
    }
    var bufferCreationInterval = null;
    if (length2 >= 2) {
      bufferCreationInterval = arguments[1];
    }
    var maxBufferSize = Number.POSITIVE_INFINITY;
    if (length2 >= 3) {
      maxBufferSize = arguments[2];
    }
    return function bufferTimeOperatorFunction(source) {
      return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
    };
  }
  var BufferTimeOperator = /* @__PURE__ */ function() {
    function BufferTimeOperator2(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
      this.bufferTimeSpan = bufferTimeSpan;
      this.bufferCreationInterval = bufferCreationInterval;
      this.maxBufferSize = maxBufferSize;
      this.scheduler = scheduler;
    }
    BufferTimeOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
    };
    return BufferTimeOperator2;
  }();
  var Context = /* @__PURE__ */ function() {
    function Context2() {
      this.buffer = [];
    }
    return Context2;
  }();
  var BufferTimeSubscriber = /* @__PURE__ */ function(_super) {
    __extends(BufferTimeSubscriber2, _super);
    function BufferTimeSubscriber2(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
      var _this = _super.call(this, destination) || this;
      _this.bufferTimeSpan = bufferTimeSpan;
      _this.bufferCreationInterval = bufferCreationInterval;
      _this.maxBufferSize = maxBufferSize;
      _this.scheduler = scheduler;
      _this.contexts = [];
      var context2 = _this.openContext();
      _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
      if (_this.timespanOnly) {
        var timeSpanOnlyState = { subscriber: _this, context: context2, bufferTimeSpan };
        _this.add(context2.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
      } else {
        var closeState = { subscriber: _this, context: context2 };
        var creationState = { bufferTimeSpan, bufferCreationInterval, subscriber: _this, scheduler };
        _this.add(context2.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
        _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
      }
      return _this;
    }
    BufferTimeSubscriber2.prototype._next = function(value2) {
      var contexts = this.contexts;
      var len2 = contexts.length;
      var filledBufferContext;
      for (var i2 = 0; i2 < len2; i2++) {
        var context_1 = contexts[i2];
        var buffer2 = context_1.buffer;
        buffer2.push(value2);
        if (buffer2.length == this.maxBufferSize) {
          filledBufferContext = context_1;
        }
      }
      if (filledBufferContext) {
        this.onBufferFull(filledBufferContext);
      }
    };
    BufferTimeSubscriber2.prototype._error = function(err) {
      this.contexts.length = 0;
      _super.prototype._error.call(this, err);
    };
    BufferTimeSubscriber2.prototype._complete = function() {
      var _a3 = this, contexts = _a3.contexts, destination = _a3.destination;
      while (contexts.length > 0) {
        var context_2 = contexts.shift();
        destination.next(context_2.buffer);
      }
      _super.prototype._complete.call(this);
    };
    BufferTimeSubscriber2.prototype._unsubscribe = function() {
      this.contexts = null;
    };
    BufferTimeSubscriber2.prototype.onBufferFull = function(context2) {
      this.closeContext(context2);
      var closeAction = context2.closeAction;
      closeAction.unsubscribe();
      this.remove(closeAction);
      if (!this.closed && this.timespanOnly) {
        context2 = this.openContext();
        var bufferTimeSpan = this.bufferTimeSpan;
        var timeSpanOnlyState = { subscriber: this, context: context2, bufferTimeSpan };
        this.add(context2.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
      }
    };
    BufferTimeSubscriber2.prototype.openContext = function() {
      var context2 = new Context();
      this.contexts.push(context2);
      return context2;
    };
    BufferTimeSubscriber2.prototype.closeContext = function(context2) {
      this.destination.next(context2.buffer);
      var contexts = this.contexts;
      var spliceIndex = contexts ? contexts.indexOf(context2) : -1;
      if (spliceIndex >= 0) {
        contexts.splice(contexts.indexOf(context2), 1);
      }
    };
    return BufferTimeSubscriber2;
  }(Subscriber);
  function dispatchBufferTimeSpanOnly(state2) {
    var subscriber = state2.subscriber;
    var prevContext = state2.context;
    if (prevContext) {
      subscriber.closeContext(prevContext);
    }
    if (!subscriber.closed) {
      state2.context = subscriber.openContext();
      state2.context.closeAction = this.schedule(state2, state2.bufferTimeSpan);
    }
  }
  function dispatchBufferCreation(state2) {
    var bufferCreationInterval = state2.bufferCreationInterval, bufferTimeSpan = state2.bufferTimeSpan, subscriber = state2.subscriber, scheduler = state2.scheduler;
    var context2 = subscriber.openContext();
    var action = this;
    if (!subscriber.closed) {
      subscriber.add(context2.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber, context: context2 }));
      action.schedule(state2, bufferCreationInterval);
    }
  }
  function dispatchBufferClose(arg) {
    var subscriber = arg.subscriber, context2 = arg.context;
    subscriber.closeContext(context2);
  }
  function bufferToggle(openings, closingSelector) {
    return function bufferToggleOperatorFunction(source) {
      return source.lift(new BufferToggleOperator(openings, closingSelector));
    };
  }
  var BufferToggleOperator = /* @__PURE__ */ function() {
    function BufferToggleOperator2(openings, closingSelector) {
      this.openings = openings;
      this.closingSelector = closingSelector;
    }
    BufferToggleOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return BufferToggleOperator2;
  }();
  var BufferToggleSubscriber = /* @__PURE__ */ function(_super) {
    __extends(BufferToggleSubscriber2, _super);
    function BufferToggleSubscriber2(destination, openings, closingSelector) {
      var _this = _super.call(this, destination) || this;
      _this.closingSelector = closingSelector;
      _this.contexts = [];
      _this.add(subscribeToResult(_this, openings));
      return _this;
    }
    BufferToggleSubscriber2.prototype._next = function(value2) {
      var contexts = this.contexts;
      var len2 = contexts.length;
      for (var i2 = 0; i2 < len2; i2++) {
        contexts[i2].buffer.push(value2);
      }
    };
    BufferToggleSubscriber2.prototype._error = function(err) {
      var contexts = this.contexts;
      while (contexts.length > 0) {
        var context_1 = contexts.shift();
        context_1.subscription.unsubscribe();
        context_1.buffer = null;
        context_1.subscription = null;
      }
      this.contexts = null;
      _super.prototype._error.call(this, err);
    };
    BufferToggleSubscriber2.prototype._complete = function() {
      var contexts = this.contexts;
      while (contexts.length > 0) {
        var context_2 = contexts.shift();
        this.destination.next(context_2.buffer);
        context_2.subscription.unsubscribe();
        context_2.buffer = null;
        context_2.subscription = null;
      }
      this.contexts = null;
      _super.prototype._complete.call(this);
    };
    BufferToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue) {
      outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
    };
    BufferToggleSubscriber2.prototype.notifyComplete = function(innerSub) {
      this.closeBuffer(innerSub.context);
    };
    BufferToggleSubscriber2.prototype.openBuffer = function(value2) {
      try {
        var closingSelector = this.closingSelector;
        var closingNotifier = closingSelector.call(this, value2);
        if (closingNotifier) {
          this.trySubscribe(closingNotifier);
        }
      } catch (err) {
        this._error(err);
      }
    };
    BufferToggleSubscriber2.prototype.closeBuffer = function(context2) {
      var contexts = this.contexts;
      if (contexts && context2) {
        var buffer2 = context2.buffer, subscription = context2.subscription;
        this.destination.next(buffer2);
        contexts.splice(contexts.indexOf(context2), 1);
        this.remove(subscription);
        subscription.unsubscribe();
      }
    };
    BufferToggleSubscriber2.prototype.trySubscribe = function(closingNotifier) {
      var contexts = this.contexts;
      var buffer2 = [];
      var subscription = new Subscription();
      var context2 = { buffer: buffer2, subscription };
      contexts.push(context2);
      var innerSubscription = subscribeToResult(this, closingNotifier, context2);
      if (!innerSubscription || innerSubscription.closed) {
        this.closeBuffer(context2);
      } else {
        innerSubscription.context = context2;
        this.add(innerSubscription);
        subscription.add(innerSubscription);
      }
    };
    return BufferToggleSubscriber2;
  }(OuterSubscriber);
  function bufferWhen(closingSelector) {
    return function(source) {
      return source.lift(new BufferWhenOperator(closingSelector));
    };
  }
  var BufferWhenOperator = /* @__PURE__ */ function() {
    function BufferWhenOperator2(closingSelector) {
      this.closingSelector = closingSelector;
    }
    BufferWhenOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
    };
    return BufferWhenOperator2;
  }();
  var BufferWhenSubscriber = /* @__PURE__ */ function(_super) {
    __extends(BufferWhenSubscriber2, _super);
    function BufferWhenSubscriber2(destination, closingSelector) {
      var _this = _super.call(this, destination) || this;
      _this.closingSelector = closingSelector;
      _this.subscribing = false;
      _this.openBuffer();
      return _this;
    }
    BufferWhenSubscriber2.prototype._next = function(value2) {
      this.buffer.push(value2);
    };
    BufferWhenSubscriber2.prototype._complete = function() {
      var buffer2 = this.buffer;
      if (buffer2) {
        this.destination.next(buffer2);
      }
      _super.prototype._complete.call(this);
    };
    BufferWhenSubscriber2.prototype._unsubscribe = function() {
      this.buffer = void 0;
      this.subscribing = false;
    };
    BufferWhenSubscriber2.prototype.notifyNext = function() {
      this.openBuffer();
    };
    BufferWhenSubscriber2.prototype.notifyComplete = function() {
      if (this.subscribing) {
        this.complete();
      } else {
        this.openBuffer();
      }
    };
    BufferWhenSubscriber2.prototype.openBuffer = function() {
      var closingSubscription = this.closingSubscription;
      if (closingSubscription) {
        this.remove(closingSubscription);
        closingSubscription.unsubscribe();
      }
      var buffer2 = this.buffer;
      if (this.buffer) {
        this.destination.next(buffer2);
      }
      this.buffer = [];
      var closingNotifier;
      try {
        var closingSelector = this.closingSelector;
        closingNotifier = closingSelector();
      } catch (err) {
        return this.error(err);
      }
      closingSubscription = new Subscription();
      this.closingSubscription = closingSubscription;
      this.add(closingSubscription);
      this.subscribing = true;
      closingSubscription.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(this)));
      this.subscribing = false;
    };
    return BufferWhenSubscriber2;
  }(SimpleOuterSubscriber);
  function catchError(selector) {
    return function catchErrorOperatorFunction(source) {
      var operator = new CatchOperator(selector);
      var caught = source.lift(operator);
      return operator.caught = caught;
    };
  }
  var CatchOperator = /* @__PURE__ */ function() {
    function CatchOperator2(selector) {
      this.selector = selector;
    }
    CatchOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator2;
  }();
  var CatchSubscriber = /* @__PURE__ */ function(_super) {
    __extends(CatchSubscriber2, _super);
    function CatchSubscriber2(destination, selector, caught) {
      var _this = _super.call(this, destination) || this;
      _this.selector = selector;
      _this.caught = caught;
      return _this;
    }
    CatchSubscriber2.prototype.error = function(err) {
      if (!this.isStopped) {
        var result = void 0;
        try {
          result = this.selector(err, this.caught);
        } catch (err2) {
          _super.prototype.error.call(this, err2);
          return;
        }
        this._unsubscribeAndRecycle();
        var innerSubscriber = new SimpleInnerSubscriber(this);
        this.add(innerSubscriber);
        var innerSubscription = innerSubscribe(result, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          this.add(innerSubscription);
        }
      }
    };
    return CatchSubscriber2;
  }(SimpleOuterSubscriber);
  function combineAll(project) {
    return function(source) {
      return source.lift(new CombineLatestOperator(project));
    };
  }
  function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      observables[_i] = arguments[_i];
    }
    var project = null;
    if (typeof observables[observables.length - 1] === "function") {
      project = observables.pop();
    }
    if (observables.length === 1 && isArray(observables[0])) {
      observables = observables[0].slice();
    }
    return function(source) {
      return source.lift.call(from([source].concat(observables)), new CombineLatestOperator(project));
    };
  }
  function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      observables[_i] = arguments[_i];
    }
    return function(source) {
      return source.lift.call(concat$1.apply(void 0, [source].concat(observables)));
    };
  }
  function concatMap(project, resultSelector) {
    return mergeMap(project, resultSelector, 1);
  }
  function concatMapTo(innerObservable, resultSelector) {
    return concatMap(function() {
      return innerObservable;
    }, resultSelector);
  }
  function count(predicate) {
    return function(source) {
      return source.lift(new CountOperator(predicate, source));
    };
  }
  var CountOperator = /* @__PURE__ */ function() {
    function CountOperator2(predicate, source) {
      this.predicate = predicate;
      this.source = source;
    }
    CountOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
    };
    return CountOperator2;
  }();
  var CountSubscriber = /* @__PURE__ */ function(_super) {
    __extends(CountSubscriber2, _super);
    function CountSubscriber2(destination, predicate, source) {
      var _this = _super.call(this, destination) || this;
      _this.predicate = predicate;
      _this.source = source;
      _this.count = 0;
      _this.index = 0;
      return _this;
    }
    CountSubscriber2.prototype._next = function(value2) {
      if (this.predicate) {
        this._tryPredicate(value2);
      } else {
        this.count++;
      }
    };
    CountSubscriber2.prototype._tryPredicate = function(value2) {
      var result;
      try {
        result = this.predicate(value2, this.index++, this.source);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      if (result) {
        this.count++;
      }
    };
    CountSubscriber2.prototype._complete = function() {
      this.destination.next(this.count);
      this.destination.complete();
    };
    return CountSubscriber2;
  }(Subscriber);
  function debounce(durationSelector) {
    return function(source) {
      return source.lift(new DebounceOperator(durationSelector));
    };
  }
  var DebounceOperator = /* @__PURE__ */ function() {
    function DebounceOperator2(durationSelector) {
      this.durationSelector = durationSelector;
    }
    DebounceOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
    };
    return DebounceOperator2;
  }();
  var DebounceSubscriber = /* @__PURE__ */ function(_super) {
    __extends(DebounceSubscriber2, _super);
    function DebounceSubscriber2(destination, durationSelector) {
      var _this = _super.call(this, destination) || this;
      _this.durationSelector = durationSelector;
      _this.hasValue = false;
      return _this;
    }
    DebounceSubscriber2.prototype._next = function(value2) {
      try {
        var result = this.durationSelector.call(this, value2);
        if (result) {
          this._tryNext(value2, result);
        }
      } catch (err) {
        this.destination.error(err);
      }
    };
    DebounceSubscriber2.prototype._complete = function() {
      this.emitValue();
      this.destination.complete();
    };
    DebounceSubscriber2.prototype._tryNext = function(value2, duration) {
      var subscription = this.durationSubscription;
      this.value = value2;
      this.hasValue = true;
      if (subscription) {
        subscription.unsubscribe();
        this.remove(subscription);
      }
      subscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
      if (subscription && !subscription.closed) {
        this.add(this.durationSubscription = subscription);
      }
    };
    DebounceSubscriber2.prototype.notifyNext = function() {
      this.emitValue();
    };
    DebounceSubscriber2.prototype.notifyComplete = function() {
      this.emitValue();
    };
    DebounceSubscriber2.prototype.emitValue = function() {
      if (this.hasValue) {
        var value2 = this.value;
        var subscription = this.durationSubscription;
        if (subscription) {
          this.durationSubscription = void 0;
          subscription.unsubscribe();
          this.remove(subscription);
        }
        this.value = void 0;
        this.hasValue = false;
        _super.prototype._next.call(this, value2);
      }
    };
    return DebounceSubscriber2;
  }(SimpleOuterSubscriber);
  function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) {
      scheduler = async;
    }
    return function(source) {
      return source.lift(new DebounceTimeOperator(dueTime, scheduler));
    };
  }
  var DebounceTimeOperator = /* @__PURE__ */ function() {
    function DebounceTimeOperator2(dueTime, scheduler) {
      this.dueTime = dueTime;
      this.scheduler = scheduler;
    }
    DebounceTimeOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator2;
  }();
  var DebounceTimeSubscriber = /* @__PURE__ */ function(_super) {
    __extends(DebounceTimeSubscriber2, _super);
    function DebounceTimeSubscriber2(destination, dueTime, scheduler) {
      var _this = _super.call(this, destination) || this;
      _this.dueTime = dueTime;
      _this.scheduler = scheduler;
      _this.debouncedSubscription = null;
      _this.lastValue = null;
      _this.hasValue = false;
      return _this;
    }
    DebounceTimeSubscriber2.prototype._next = function(value2) {
      this.clearDebounce();
      this.lastValue = value2;
      this.hasValue = true;
      this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$1, this.dueTime, this));
    };
    DebounceTimeSubscriber2.prototype._complete = function() {
      this.debouncedNext();
      this.destination.complete();
    };
    DebounceTimeSubscriber2.prototype.debouncedNext = function() {
      this.clearDebounce();
      if (this.hasValue) {
        var lastValue = this.lastValue;
        this.lastValue = null;
        this.hasValue = false;
        this.destination.next(lastValue);
      }
    };
    DebounceTimeSubscriber2.prototype.clearDebounce = function() {
      var debouncedSubscription = this.debouncedSubscription;
      if (debouncedSubscription !== null) {
        this.remove(debouncedSubscription);
        debouncedSubscription.unsubscribe();
        this.debouncedSubscription = null;
      }
    };
    return DebounceTimeSubscriber2;
  }(Subscriber);
  function dispatchNext$1(subscriber) {
    subscriber.debouncedNext();
  }
  function defaultIfEmpty(defaultValue) {
    if (defaultValue === void 0) {
      defaultValue = null;
    }
    return function(source) {
      return source.lift(new DefaultIfEmptyOperator(defaultValue));
    };
  }
  var DefaultIfEmptyOperator = /* @__PURE__ */ function() {
    function DefaultIfEmptyOperator2(defaultValue) {
      this.defaultValue = defaultValue;
    }
    DefaultIfEmptyOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
    };
    return DefaultIfEmptyOperator2;
  }();
  var DefaultIfEmptySubscriber = /* @__PURE__ */ function(_super) {
    __extends(DefaultIfEmptySubscriber2, _super);
    function DefaultIfEmptySubscriber2(destination, defaultValue) {
      var _this = _super.call(this, destination) || this;
      _this.defaultValue = defaultValue;
      _this.isEmpty = true;
      return _this;
    }
    DefaultIfEmptySubscriber2.prototype._next = function(value2) {
      this.isEmpty = false;
      this.destination.next(value2);
    };
    DefaultIfEmptySubscriber2.prototype._complete = function() {
      if (this.isEmpty) {
        this.destination.next(this.defaultValue);
      }
      this.destination.complete();
    };
    return DefaultIfEmptySubscriber2;
  }(Subscriber);
  function isDate(value2) {
    return value2 instanceof Date && !isNaN(+value2);
  }
  function delay(delay2, scheduler) {
    if (scheduler === void 0) {
      scheduler = async;
    }
    var absoluteDelay = isDate(delay2);
    var delayFor = absoluteDelay ? +delay2 - scheduler.now() : Math.abs(delay2);
    return function(source) {
      return source.lift(new DelayOperator(delayFor, scheduler));
    };
  }
  var DelayOperator = /* @__PURE__ */ function() {
    function DelayOperator2(delay2, scheduler) {
      this.delay = delay2;
      this.scheduler = scheduler;
    }
    DelayOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator2;
  }();
  var DelaySubscriber = /* @__PURE__ */ function(_super) {
    __extends(DelaySubscriber2, _super);
    function DelaySubscriber2(destination, delay2, scheduler) {
      var _this = _super.call(this, destination) || this;
      _this.delay = delay2;
      _this.scheduler = scheduler;
      _this.queue = [];
      _this.active = false;
      _this.errored = false;
      return _this;
    }
    DelaySubscriber2.dispatch = function(state2) {
      var source = state2.source;
      var queue2 = source.queue;
      var scheduler = state2.scheduler;
      var destination = state2.destination;
      while (queue2.length > 0 && queue2[0].time - scheduler.now() <= 0) {
        queue2.shift().notification.observe(destination);
      }
      if (queue2.length > 0) {
        var delay_1 = Math.max(0, queue2[0].time - scheduler.now());
        this.schedule(state2, delay_1);
      } else {
        this.unsubscribe();
        source.active = false;
      }
    };
    DelaySubscriber2.prototype._schedule = function(scheduler) {
      this.active = true;
      var destination = this.destination;
      destination.add(scheduler.schedule(DelaySubscriber2.dispatch, this.delay, {
        source: this,
        destination: this.destination,
        scheduler
      }));
    };
    DelaySubscriber2.prototype.scheduleNotification = function(notification) {
      if (this.errored === true) {
        return;
      }
      var scheduler = this.scheduler;
      var message = new DelayMessage(scheduler.now() + this.delay, notification);
      this.queue.push(message);
      if (this.active === false) {
        this._schedule(scheduler);
      }
    };
    DelaySubscriber2.prototype._next = function(value2) {
      this.scheduleNotification(Notification.createNext(value2));
    };
    DelaySubscriber2.prototype._error = function(err) {
      this.errored = true;
      this.queue = [];
      this.destination.error(err);
      this.unsubscribe();
    };
    DelaySubscriber2.prototype._complete = function() {
      this.scheduleNotification(Notification.createComplete());
      this.unsubscribe();
    };
    return DelaySubscriber2;
  }(Subscriber);
  var DelayMessage = /* @__PURE__ */ function() {
    function DelayMessage2(time, notification) {
      this.time = time;
      this.notification = notification;
    }
    return DelayMessage2;
  }();
  function delayWhen(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
      return function(source) {
        return new SubscriptionDelayObservable(source, subscriptionDelay).lift(new DelayWhenOperator(delayDurationSelector));
      };
    }
    return function(source) {
      return source.lift(new DelayWhenOperator(delayDurationSelector));
    };
  }
  var DelayWhenOperator = /* @__PURE__ */ function() {
    function DelayWhenOperator2(delayDurationSelector) {
      this.delayDurationSelector = delayDurationSelector;
    }
    DelayWhenOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
    };
    return DelayWhenOperator2;
  }();
  var DelayWhenSubscriber = /* @__PURE__ */ function(_super) {
    __extends(DelayWhenSubscriber2, _super);
    function DelayWhenSubscriber2(destination, delayDurationSelector) {
      var _this = _super.call(this, destination) || this;
      _this.delayDurationSelector = delayDurationSelector;
      _this.completed = false;
      _this.delayNotifierSubscriptions = [];
      _this.index = 0;
      return _this;
    }
    DelayWhenSubscriber2.prototype.notifyNext = function(outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
      this.destination.next(outerValue);
      this.removeSubscription(innerSub);
      this.tryComplete();
    };
    DelayWhenSubscriber2.prototype.notifyError = function(error, innerSub) {
      this._error(error);
    };
    DelayWhenSubscriber2.prototype.notifyComplete = function(innerSub) {
      var value2 = this.removeSubscription(innerSub);
      if (value2) {
        this.destination.next(value2);
      }
      this.tryComplete();
    };
    DelayWhenSubscriber2.prototype._next = function(value2) {
      var index2 = this.index++;
      try {
        var delayNotifier = this.delayDurationSelector(value2, index2);
        if (delayNotifier) {
          this.tryDelay(delayNotifier, value2);
        }
      } catch (err) {
        this.destination.error(err);
      }
    };
    DelayWhenSubscriber2.prototype._complete = function() {
      this.completed = true;
      this.tryComplete();
      this.unsubscribe();
    };
    DelayWhenSubscriber2.prototype.removeSubscription = function(subscription) {
      subscription.unsubscribe();
      var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
      if (subscriptionIdx !== -1) {
        this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
      }
      return subscription.outerValue;
    };
    DelayWhenSubscriber2.prototype.tryDelay = function(delayNotifier, value2) {
      var notifierSubscription = subscribeToResult(this, delayNotifier, value2);
      if (notifierSubscription && !notifierSubscription.closed) {
        var destination = this.destination;
        destination.add(notifierSubscription);
        this.delayNotifierSubscriptions.push(notifierSubscription);
      }
    };
    DelayWhenSubscriber2.prototype.tryComplete = function() {
      if (this.completed && this.delayNotifierSubscriptions.length === 0) {
        this.destination.complete();
      }
    };
    return DelayWhenSubscriber2;
  }(OuterSubscriber);
  var SubscriptionDelayObservable = /* @__PURE__ */ function(_super) {
    __extends(SubscriptionDelayObservable2, _super);
    function SubscriptionDelayObservable2(source, subscriptionDelay) {
      var _this = _super.call(this) || this;
      _this.source = source;
      _this.subscriptionDelay = subscriptionDelay;
      return _this;
    }
    SubscriptionDelayObservable2.prototype._subscribe = function(subscriber) {
      this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
    };
    return SubscriptionDelayObservable2;
  }(Observable);
  var SubscriptionDelaySubscriber = /* @__PURE__ */ function(_super) {
    __extends(SubscriptionDelaySubscriber2, _super);
    function SubscriptionDelaySubscriber2(parent2, source) {
      var _this = _super.call(this) || this;
      _this.parent = parent2;
      _this.source = source;
      _this.sourceSubscribed = false;
      return _this;
    }
    SubscriptionDelaySubscriber2.prototype._next = function(unused) {
      this.subscribeToSource();
    };
    SubscriptionDelaySubscriber2.prototype._error = function(err) {
      this.unsubscribe();
      this.parent.error(err);
    };
    SubscriptionDelaySubscriber2.prototype._complete = function() {
      this.unsubscribe();
      this.subscribeToSource();
    };
    SubscriptionDelaySubscriber2.prototype.subscribeToSource = function() {
      if (!this.sourceSubscribed) {
        this.sourceSubscribed = true;
        this.unsubscribe();
        this.source.subscribe(this.parent);
      }
    };
    return SubscriptionDelaySubscriber2;
  }(Subscriber);
  function dematerialize() {
    return function dematerializeOperatorFunction(source) {
      return source.lift(new DeMaterializeOperator());
    };
  }
  var DeMaterializeOperator = /* @__PURE__ */ function() {
    function DeMaterializeOperator2() {
    }
    DeMaterializeOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new DeMaterializeSubscriber(subscriber));
    };
    return DeMaterializeOperator2;
  }();
  var DeMaterializeSubscriber = /* @__PURE__ */ function(_super) {
    __extends(DeMaterializeSubscriber2, _super);
    function DeMaterializeSubscriber2(destination) {
      return _super.call(this, destination) || this;
    }
    DeMaterializeSubscriber2.prototype._next = function(value2) {
      value2.observe(this.destination);
    };
    return DeMaterializeSubscriber2;
  }(Subscriber);
  function distinct(keySelector, flushes) {
    return function(source) {
      return source.lift(new DistinctOperator(keySelector, flushes));
    };
  }
  var DistinctOperator = /* @__PURE__ */ function() {
    function DistinctOperator2(keySelector, flushes) {
      this.keySelector = keySelector;
      this.flushes = flushes;
    }
    DistinctOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
    };
    return DistinctOperator2;
  }();
  var DistinctSubscriber = /* @__PURE__ */ function(_super) {
    __extends(DistinctSubscriber2, _super);
    function DistinctSubscriber2(destination, keySelector, flushes) {
      var _this = _super.call(this, destination) || this;
      _this.keySelector = keySelector;
      _this.values = /* @__PURE__ */ new Set();
      if (flushes) {
        _this.add(innerSubscribe(flushes, new SimpleInnerSubscriber(_this)));
      }
      return _this;
    }
    DistinctSubscriber2.prototype.notifyNext = function() {
      this.values.clear();
    };
    DistinctSubscriber2.prototype.notifyError = function(error) {
      this._error(error);
    };
    DistinctSubscriber2.prototype._next = function(value2) {
      if (this.keySelector) {
        this._useKeySelector(value2);
      } else {
        this._finalizeNext(value2, value2);
      }
    };
    DistinctSubscriber2.prototype._useKeySelector = function(value2) {
      var key;
      var destination = this.destination;
      try {
        key = this.keySelector(value2);
      } catch (err) {
        destination.error(err);
        return;
      }
      this._finalizeNext(key, value2);
    };
    DistinctSubscriber2.prototype._finalizeNext = function(key, value2) {
      var values2 = this.values;
      if (!values2.has(key)) {
        values2.add(key);
        this.destination.next(value2);
      }
    };
    return DistinctSubscriber2;
  }(SimpleOuterSubscriber);
  function distinctUntilChanged(compare2, keySelector) {
    return function(source) {
      return source.lift(new DistinctUntilChangedOperator(compare2, keySelector));
    };
  }
  var DistinctUntilChangedOperator = /* @__PURE__ */ function() {
    function DistinctUntilChangedOperator2(compare2, keySelector) {
      this.compare = compare2;
      this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator2;
  }();
  var DistinctUntilChangedSubscriber = /* @__PURE__ */ function(_super) {
    __extends(DistinctUntilChangedSubscriber2, _super);
    function DistinctUntilChangedSubscriber2(destination, compare2, keySelector) {
      var _this = _super.call(this, destination) || this;
      _this.keySelector = keySelector;
      _this.hasKey = false;
      if (typeof compare2 === "function") {
        _this.compare = compare2;
      }
      return _this;
    }
    DistinctUntilChangedSubscriber2.prototype.compare = function(x2, y) {
      return x2 === y;
    };
    DistinctUntilChangedSubscriber2.prototype._next = function(value2) {
      var key;
      try {
        var keySelector = this.keySelector;
        key = keySelector ? keySelector(value2) : value2;
      } catch (err) {
        return this.destination.error(err);
      }
      var result = false;
      if (this.hasKey) {
        try {
          var compare2 = this.compare;
          result = compare2(this.key, key);
        } catch (err) {
          return this.destination.error(err);
        }
      } else {
        this.hasKey = true;
      }
      if (!result) {
        this.key = key;
        this.destination.next(value2);
      }
    };
    return DistinctUntilChangedSubscriber2;
  }(Subscriber);
  function distinctUntilKeyChanged(key, compare2) {
    return distinctUntilChanged(function(x2, y) {
      return compare2 ? compare2(x2[key], y[key]) : x2[key] === y[key];
    });
  }
  function throwIfEmpty(errorFactory) {
    if (errorFactory === void 0) {
      errorFactory = defaultErrorFactory;
    }
    return function(source) {
      return source.lift(new ThrowIfEmptyOperator(errorFactory));
    };
  }
  var ThrowIfEmptyOperator = /* @__PURE__ */ function() {
    function ThrowIfEmptyOperator2(errorFactory) {
      this.errorFactory = errorFactory;
    }
    ThrowIfEmptyOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
    };
    return ThrowIfEmptyOperator2;
  }();
  var ThrowIfEmptySubscriber = /* @__PURE__ */ function(_super) {
    __extends(ThrowIfEmptySubscriber2, _super);
    function ThrowIfEmptySubscriber2(destination, errorFactory) {
      var _this = _super.call(this, destination) || this;
      _this.errorFactory = errorFactory;
      _this.hasValue = false;
      return _this;
    }
    ThrowIfEmptySubscriber2.prototype._next = function(value2) {
      this.hasValue = true;
      this.destination.next(value2);
    };
    ThrowIfEmptySubscriber2.prototype._complete = function() {
      if (!this.hasValue) {
        var err = void 0;
        try {
          err = this.errorFactory();
        } catch (e) {
          err = e;
        }
        this.destination.error(err);
      } else {
        return this.destination.complete();
      }
    };
    return ThrowIfEmptySubscriber2;
  }(Subscriber);
  function defaultErrorFactory() {
    return new EmptyError();
  }
  function take(count2) {
    return function(source) {
      if (count2 === 0) {
        return empty$1();
      } else {
        return source.lift(new TakeOperator(count2));
      }
    };
  }
  var TakeOperator = /* @__PURE__ */ function() {
    function TakeOperator2(total) {
      this.total = total;
      if (this.total < 0) {
        throw new ArgumentOutOfRangeError();
      }
    }
    TakeOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator2;
  }();
  var TakeSubscriber = /* @__PURE__ */ function(_super) {
    __extends(TakeSubscriber2, _super);
    function TakeSubscriber2(destination, total) {
      var _this = _super.call(this, destination) || this;
      _this.total = total;
      _this.count = 0;
      return _this;
    }
    TakeSubscriber2.prototype._next = function(value2) {
      var total = this.total;
      var count2 = ++this.count;
      if (count2 <= total) {
        this.destination.next(value2);
        if (count2 === total) {
          this.destination.complete();
          this.unsubscribe();
        }
      }
    };
    return TakeSubscriber2;
  }(Subscriber);
  function elementAt(index2, defaultValue) {
    if (index2 < 0) {
      throw new ArgumentOutOfRangeError();
    }
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(filter$1(function(v, i2) {
        return i2 === index2;
      }), take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
        return new ArgumentOutOfRangeError();
      }));
    };
  }
  function endWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      array[_i] = arguments[_i];
    }
    return function(source) {
      return concat$1(source, of.apply(void 0, array));
    };
  }
  function every(predicate, thisArg) {
    return function(source) {
      return source.lift(new EveryOperator(predicate, thisArg, source));
    };
  }
  var EveryOperator = /* @__PURE__ */ function() {
    function EveryOperator2(predicate, thisArg, source) {
      this.predicate = predicate;
      this.thisArg = thisArg;
      this.source = source;
    }
    EveryOperator2.prototype.call = function(observer, source) {
      return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
    };
    return EveryOperator2;
  }();
  var EverySubscriber = /* @__PURE__ */ function(_super) {
    __extends(EverySubscriber2, _super);
    function EverySubscriber2(destination, predicate, thisArg, source) {
      var _this = _super.call(this, destination) || this;
      _this.predicate = predicate;
      _this.thisArg = thisArg;
      _this.source = source;
      _this.index = 0;
      _this.thisArg = thisArg || _this;
      return _this;
    }
    EverySubscriber2.prototype.notifyComplete = function(everyValueMatch) {
      this.destination.next(everyValueMatch);
      this.destination.complete();
    };
    EverySubscriber2.prototype._next = function(value2) {
      var result = false;
      try {
        result = this.predicate.call(this.thisArg, value2, this.index++, this.source);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      if (!result) {
        this.notifyComplete(false);
      }
    };
    EverySubscriber2.prototype._complete = function() {
      this.notifyComplete(true);
    };
    return EverySubscriber2;
  }(Subscriber);
  function exhaust() {
    return function(source) {
      return source.lift(new SwitchFirstOperator());
    };
  }
  var SwitchFirstOperator = /* @__PURE__ */ function() {
    function SwitchFirstOperator2() {
    }
    SwitchFirstOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new SwitchFirstSubscriber(subscriber));
    };
    return SwitchFirstOperator2;
  }();
  var SwitchFirstSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SwitchFirstSubscriber2, _super);
    function SwitchFirstSubscriber2(destination) {
      var _this = _super.call(this, destination) || this;
      _this.hasCompleted = false;
      _this.hasSubscription = false;
      return _this;
    }
    SwitchFirstSubscriber2.prototype._next = function(value2) {
      if (!this.hasSubscription) {
        this.hasSubscription = true;
        this.add(innerSubscribe(value2, new SimpleInnerSubscriber(this)));
      }
    };
    SwitchFirstSubscriber2.prototype._complete = function() {
      this.hasCompleted = true;
      if (!this.hasSubscription) {
        this.destination.complete();
      }
    };
    SwitchFirstSubscriber2.prototype.notifyComplete = function() {
      this.hasSubscription = false;
      if (this.hasCompleted) {
        this.destination.complete();
      }
    };
    return SwitchFirstSubscriber2;
  }(SimpleOuterSubscriber);
  function exhaustMap(project, resultSelector) {
    if (resultSelector) {
      return function(source) {
        return source.pipe(exhaustMap(function(a, i2) {
          return from(project(a, i2)).pipe(map$2(function(b, ii) {
            return resultSelector(a, b, i2, ii);
          }));
        }));
      };
    }
    return function(source) {
      return source.lift(new ExhaustMapOperator(project));
    };
  }
  var ExhaustMapOperator = /* @__PURE__ */ function() {
    function ExhaustMapOperator2(project) {
      this.project = project;
    }
    ExhaustMapOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
    };
    return ExhaustMapOperator2;
  }();
  var ExhaustMapSubscriber = /* @__PURE__ */ function(_super) {
    __extends(ExhaustMapSubscriber2, _super);
    function ExhaustMapSubscriber2(destination, project) {
      var _this = _super.call(this, destination) || this;
      _this.project = project;
      _this.hasSubscription = false;
      _this.hasCompleted = false;
      _this.index = 0;
      return _this;
    }
    ExhaustMapSubscriber2.prototype._next = function(value2) {
      if (!this.hasSubscription) {
        this.tryNext(value2);
      }
    };
    ExhaustMapSubscriber2.prototype.tryNext = function(value2) {
      var result;
      var index2 = this.index++;
      try {
        result = this.project(value2, index2);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      this.hasSubscription = true;
      this._innerSub(result);
    };
    ExhaustMapSubscriber2.prototype._innerSub = function(result) {
      var innerSubscriber = new SimpleInnerSubscriber(this);
      var destination = this.destination;
      destination.add(innerSubscriber);
      var innerSubscription = innerSubscribe(result, innerSubscriber);
      if (innerSubscription !== innerSubscriber) {
        destination.add(innerSubscription);
      }
    };
    ExhaustMapSubscriber2.prototype._complete = function() {
      this.hasCompleted = true;
      if (!this.hasSubscription) {
        this.destination.complete();
      }
      this.unsubscribe();
    };
    ExhaustMapSubscriber2.prototype.notifyNext = function(innerValue) {
      this.destination.next(innerValue);
    };
    ExhaustMapSubscriber2.prototype.notifyError = function(err) {
      this.destination.error(err);
    };
    ExhaustMapSubscriber2.prototype.notifyComplete = function() {
      this.hasSubscription = false;
      if (this.hasCompleted) {
        this.destination.complete();
      }
    };
    return ExhaustMapSubscriber2;
  }(SimpleOuterSubscriber);
  function expand(project, concurrent, scheduler) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
    return function(source) {
      return source.lift(new ExpandOperator(project, concurrent, scheduler));
    };
  }
  var ExpandOperator = /* @__PURE__ */ function() {
    function ExpandOperator2(project, concurrent, scheduler) {
      this.project = project;
      this.concurrent = concurrent;
      this.scheduler = scheduler;
    }
    ExpandOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
    };
    return ExpandOperator2;
  }();
  var ExpandSubscriber = /* @__PURE__ */ function(_super) {
    __extends(ExpandSubscriber2, _super);
    function ExpandSubscriber2(destination, project, concurrent, scheduler) {
      var _this = _super.call(this, destination) || this;
      _this.project = project;
      _this.concurrent = concurrent;
      _this.scheduler = scheduler;
      _this.index = 0;
      _this.active = 0;
      _this.hasCompleted = false;
      if (concurrent < Number.POSITIVE_INFINITY) {
        _this.buffer = [];
      }
      return _this;
    }
    ExpandSubscriber2.dispatch = function(arg) {
      var subscriber = arg.subscriber, result = arg.result, value2 = arg.value, index2 = arg.index;
      subscriber.subscribeToProjection(result, value2, index2);
    };
    ExpandSubscriber2.prototype._next = function(value2) {
      var destination = this.destination;
      if (destination.closed) {
        this._complete();
        return;
      }
      var index2 = this.index++;
      if (this.active < this.concurrent) {
        destination.next(value2);
        try {
          var project = this.project;
          var result = project(value2, index2);
          if (!this.scheduler) {
            this.subscribeToProjection(result, value2, index2);
          } else {
            var state2 = { subscriber: this, result, value: value2, index: index2 };
            var destination_1 = this.destination;
            destination_1.add(this.scheduler.schedule(ExpandSubscriber2.dispatch, 0, state2));
          }
        } catch (e) {
          destination.error(e);
        }
      } else {
        this.buffer.push(value2);
      }
    };
    ExpandSubscriber2.prototype.subscribeToProjection = function(result, value2, index2) {
      this.active++;
      var destination = this.destination;
      destination.add(innerSubscribe(result, new SimpleInnerSubscriber(this)));
    };
    ExpandSubscriber2.prototype._complete = function() {
      this.hasCompleted = true;
      if (this.hasCompleted && this.active === 0) {
        this.destination.complete();
      }
      this.unsubscribe();
    };
    ExpandSubscriber2.prototype.notifyNext = function(innerValue) {
      this._next(innerValue);
    };
    ExpandSubscriber2.prototype.notifyComplete = function() {
      var buffer2 = this.buffer;
      this.active--;
      if (buffer2 && buffer2.length > 0) {
        this._next(buffer2.shift());
      }
      if (this.hasCompleted && this.active === 0) {
        this.destination.complete();
      }
    };
    return ExpandSubscriber2;
  }(SimpleOuterSubscriber);
  function finalize$1(callback) {
    return function(source) {
      return source.lift(new FinallyOperator(callback));
    };
  }
  var FinallyOperator = /* @__PURE__ */ function() {
    function FinallyOperator2(callback) {
      this.callback = callback;
    }
    FinallyOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator2;
  }();
  var FinallySubscriber = /* @__PURE__ */ function(_super) {
    __extends(FinallySubscriber2, _super);
    function FinallySubscriber2(destination, callback) {
      var _this = _super.call(this, destination) || this;
      _this.add(new Subscription(callback));
      return _this;
    }
    return FinallySubscriber2;
  }(Subscriber);
  function find(predicate, thisArg) {
    if (typeof predicate !== "function") {
      throw new TypeError("predicate is not a function");
    }
    return function(source) {
      return source.lift(new FindValueOperator(predicate, source, false, thisArg));
    };
  }
  var FindValueOperator = /* @__PURE__ */ function() {
    function FindValueOperator2(predicate, source, yieldIndex, thisArg) {
      this.predicate = predicate;
      this.source = source;
      this.yieldIndex = yieldIndex;
      this.thisArg = thisArg;
    }
    FindValueOperator2.prototype.call = function(observer, source) {
      return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
    };
    return FindValueOperator2;
  }();
  var FindValueSubscriber = /* @__PURE__ */ function(_super) {
    __extends(FindValueSubscriber2, _super);
    function FindValueSubscriber2(destination, predicate, source, yieldIndex, thisArg) {
      var _this = _super.call(this, destination) || this;
      _this.predicate = predicate;
      _this.source = source;
      _this.yieldIndex = yieldIndex;
      _this.thisArg = thisArg;
      _this.index = 0;
      return _this;
    }
    FindValueSubscriber2.prototype.notifyComplete = function(value2) {
      var destination = this.destination;
      destination.next(value2);
      destination.complete();
      this.unsubscribe();
    };
    FindValueSubscriber2.prototype._next = function(value2) {
      var _a3 = this, predicate = _a3.predicate, thisArg = _a3.thisArg;
      var index2 = this.index++;
      try {
        var result = predicate.call(thisArg || this, value2, index2, this.source);
        if (result) {
          this.notifyComplete(this.yieldIndex ? index2 : value2);
        }
      } catch (err) {
        this.destination.error(err);
      }
    };
    FindValueSubscriber2.prototype._complete = function() {
      this.notifyComplete(this.yieldIndex ? -1 : void 0);
    };
    return FindValueSubscriber2;
  }(Subscriber);
  function findIndex(predicate, thisArg) {
    return function(source) {
      return source.lift(new FindValueOperator(predicate, source, true, thisArg));
    };
  }
  function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(predicate ? filter$1(function(v, i2) {
        return predicate(v, i2, source);
      }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
        return new EmptyError();
      }));
    };
  }
  function ignoreElements() {
    return function ignoreElementsOperatorFunction(source) {
      return source.lift(new IgnoreElementsOperator());
    };
  }
  var IgnoreElementsOperator = /* @__PURE__ */ function() {
    function IgnoreElementsOperator2() {
    }
    IgnoreElementsOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator2;
  }();
  var IgnoreElementsSubscriber = /* @__PURE__ */ function(_super) {
    __extends(IgnoreElementsSubscriber2, _super);
    function IgnoreElementsSubscriber2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    IgnoreElementsSubscriber2.prototype._next = function(unused) {
    };
    return IgnoreElementsSubscriber2;
  }(Subscriber);
  function isEmpty() {
    return function(source) {
      return source.lift(new IsEmptyOperator());
    };
  }
  var IsEmptyOperator = /* @__PURE__ */ function() {
    function IsEmptyOperator2() {
    }
    IsEmptyOperator2.prototype.call = function(observer, source) {
      return source.subscribe(new IsEmptySubscriber(observer));
    };
    return IsEmptyOperator2;
  }();
  var IsEmptySubscriber = /* @__PURE__ */ function(_super) {
    __extends(IsEmptySubscriber2, _super);
    function IsEmptySubscriber2(destination) {
      return _super.call(this, destination) || this;
    }
    IsEmptySubscriber2.prototype.notifyComplete = function(isEmpty2) {
      var destination = this.destination;
      destination.next(isEmpty2);
      destination.complete();
    };
    IsEmptySubscriber2.prototype._next = function(value2) {
      this.notifyComplete(false);
    };
    IsEmptySubscriber2.prototype._complete = function() {
      this.notifyComplete(true);
    };
    return IsEmptySubscriber2;
  }(Subscriber);
  function takeLast(count2) {
    return function takeLastOperatorFunction(source) {
      if (count2 === 0) {
        return empty$1();
      } else {
        return source.lift(new TakeLastOperator(count2));
      }
    };
  }
  var TakeLastOperator = /* @__PURE__ */ function() {
    function TakeLastOperator2(total) {
      this.total = total;
      if (this.total < 0) {
        throw new ArgumentOutOfRangeError();
      }
    }
    TakeLastOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator2;
  }();
  var TakeLastSubscriber = /* @__PURE__ */ function(_super) {
    __extends(TakeLastSubscriber2, _super);
    function TakeLastSubscriber2(destination, total) {
      var _this = _super.call(this, destination) || this;
      _this.total = total;
      _this.ring = new Array();
      _this.count = 0;
      return _this;
    }
    TakeLastSubscriber2.prototype._next = function(value2) {
      var ring2 = this.ring;
      var total = this.total;
      var count2 = this.count++;
      if (ring2.length < total) {
        ring2.push(value2);
      } else {
        var index2 = count2 % total;
        ring2[index2] = value2;
      }
    };
    TakeLastSubscriber2.prototype._complete = function() {
      var destination = this.destination;
      var count2 = this.count;
      if (count2 > 0) {
        var total = this.count >= this.total ? this.total : this.count;
        var ring2 = this.ring;
        for (var i2 = 0; i2 < total; i2++) {
          var idx = count2++ % total;
          destination.next(ring2[idx]);
        }
      }
      destination.complete();
    };
    return TakeLastSubscriber2;
  }(Subscriber);
  function last(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(predicate ? filter$1(function(v, i2) {
        return predicate(v, i2, source);
      }) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
        return new EmptyError();
      }));
    };
  }
  function mapTo(value2) {
    return function(source) {
      return source.lift(new MapToOperator(value2));
    };
  }
  var MapToOperator = /* @__PURE__ */ function() {
    function MapToOperator2(value2) {
      this.value = value2;
    }
    MapToOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator2;
  }();
  var MapToSubscriber = /* @__PURE__ */ function(_super) {
    __extends(MapToSubscriber2, _super);
    function MapToSubscriber2(destination, value2) {
      var _this = _super.call(this, destination) || this;
      _this.value = value2;
      return _this;
    }
    MapToSubscriber2.prototype._next = function(x2) {
      this.destination.next(this.value);
    };
    return MapToSubscriber2;
  }(Subscriber);
  function materialize() {
    return function materializeOperatorFunction(source) {
      return source.lift(new MaterializeOperator());
    };
  }
  var MaterializeOperator = /* @__PURE__ */ function() {
    function MaterializeOperator2() {
    }
    MaterializeOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new MaterializeSubscriber(subscriber));
    };
    return MaterializeOperator2;
  }();
  var MaterializeSubscriber = /* @__PURE__ */ function(_super) {
    __extends(MaterializeSubscriber2, _super);
    function MaterializeSubscriber2(destination) {
      return _super.call(this, destination) || this;
    }
    MaterializeSubscriber2.prototype._next = function(value2) {
      this.destination.next(Notification.createNext(value2));
    };
    MaterializeSubscriber2.prototype._error = function(err) {
      var destination = this.destination;
      destination.next(Notification.createError(err));
      destination.complete();
    };
    MaterializeSubscriber2.prototype._complete = function() {
      var destination = this.destination;
      destination.next(Notification.createComplete());
      destination.complete();
    };
    return MaterializeSubscriber2;
  }(Subscriber);
  function scan(accumulator, seed2) {
    var hasSeed = false;
    if (arguments.length >= 2) {
      hasSeed = true;
    }
    return function scanOperatorFunction(source) {
      return source.lift(new ScanOperator(accumulator, seed2, hasSeed));
    };
  }
  var ScanOperator = /* @__PURE__ */ function() {
    function ScanOperator2(accumulator, seed2, hasSeed) {
      if (hasSeed === void 0) {
        hasSeed = false;
      }
      this.accumulator = accumulator;
      this.seed = seed2;
      this.hasSeed = hasSeed;
    }
    ScanOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator2;
  }();
  var ScanSubscriber = /* @__PURE__ */ function(_super) {
    __extends(ScanSubscriber2, _super);
    function ScanSubscriber2(destination, accumulator, _seed, hasSeed) {
      var _this = _super.call(this, destination) || this;
      _this.accumulator = accumulator;
      _this._seed = _seed;
      _this.hasSeed = hasSeed;
      _this.index = 0;
      return _this;
    }
    Object.defineProperty(ScanSubscriber2.prototype, "seed", {
      get: function() {
        return this._seed;
      },
      set: function(value2) {
        this.hasSeed = true;
        this._seed = value2;
      },
      enumerable: true,
      configurable: true
    });
    ScanSubscriber2.prototype._next = function(value2) {
      if (!this.hasSeed) {
        this.seed = value2;
        this.destination.next(value2);
      } else {
        return this._tryNext(value2);
      }
    };
    ScanSubscriber2.prototype._tryNext = function(value2) {
      var index2 = this.index++;
      var result;
      try {
        result = this.accumulator(this.seed, value2, index2);
      } catch (err) {
        this.destination.error(err);
      }
      this.seed = result;
      this.destination.next(result);
    };
    return ScanSubscriber2;
  }(Subscriber);
  function reduce(accumulator, seed2) {
    if (arguments.length >= 2) {
      return function reduceOperatorFunctionWithSeed(source) {
        return pipe$1(scan(accumulator, seed2), takeLast(1), defaultIfEmpty(seed2))(source);
      };
    }
    return function reduceOperatorFunction(source) {
      return pipe$1(scan(function(acc, value2, index2) {
        return accumulator(acc, value2, index2 + 1);
      }), takeLast(1))(source);
    };
  }
  function max(comparer) {
    var max2 = typeof comparer === "function" ? function(x2, y) {
      return comparer(x2, y) > 0 ? x2 : y;
    } : function(x2, y) {
      return x2 > y ? x2 : y;
    };
    return reduce(max2);
  }
  function merge$1() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      observables[_i] = arguments[_i];
    }
    return function(source) {
      return source.lift.call(merge$2.apply(void 0, [source].concat(observables)));
    };
  }
  function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === "function") {
      return mergeMap(function() {
        return innerObservable;
      }, resultSelector, concurrent);
    }
    if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return mergeMap(function() {
      return innerObservable;
    }, concurrent);
  }
  function mergeScan(accumulator, seed2, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    return function(source) {
      return source.lift(new MergeScanOperator(accumulator, seed2, concurrent));
    };
  }
  var MergeScanOperator = /* @__PURE__ */ function() {
    function MergeScanOperator2(accumulator, seed2, concurrent) {
      this.accumulator = accumulator;
      this.seed = seed2;
      this.concurrent = concurrent;
    }
    MergeScanOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
    };
    return MergeScanOperator2;
  }();
  var MergeScanSubscriber = /* @__PURE__ */ function(_super) {
    __extends(MergeScanSubscriber2, _super);
    function MergeScanSubscriber2(destination, accumulator, acc, concurrent) {
      var _this = _super.call(this, destination) || this;
      _this.accumulator = accumulator;
      _this.acc = acc;
      _this.concurrent = concurrent;
      _this.hasValue = false;
      _this.hasCompleted = false;
      _this.buffer = [];
      _this.active = 0;
      _this.index = 0;
      return _this;
    }
    MergeScanSubscriber2.prototype._next = function(value2) {
      if (this.active < this.concurrent) {
        var index2 = this.index++;
        var destination = this.destination;
        var ish = void 0;
        try {
          var accumulator = this.accumulator;
          ish = accumulator(this.acc, value2, index2);
        } catch (e) {
          return destination.error(e);
        }
        this.active++;
        this._innerSub(ish);
      } else {
        this.buffer.push(value2);
      }
    };
    MergeScanSubscriber2.prototype._innerSub = function(ish) {
      var innerSubscriber = new SimpleInnerSubscriber(this);
      var destination = this.destination;
      destination.add(innerSubscriber);
      var innerSubscription = innerSubscribe(ish, innerSubscriber);
      if (innerSubscription !== innerSubscriber) {
        destination.add(innerSubscription);
      }
    };
    MergeScanSubscriber2.prototype._complete = function() {
      this.hasCompleted = true;
      if (this.active === 0 && this.buffer.length === 0) {
        if (this.hasValue === false) {
          this.destination.next(this.acc);
        }
        this.destination.complete();
      }
      this.unsubscribe();
    };
    MergeScanSubscriber2.prototype.notifyNext = function(innerValue) {
      var destination = this.destination;
      this.acc = innerValue;
      this.hasValue = true;
      destination.next(innerValue);
    };
    MergeScanSubscriber2.prototype.notifyComplete = function() {
      var buffer2 = this.buffer;
      this.active--;
      if (buffer2.length > 0) {
        this._next(buffer2.shift());
      } else if (this.active === 0 && this.hasCompleted) {
        if (this.hasValue === false) {
          this.destination.next(this.acc);
        }
        this.destination.complete();
      }
    };
    return MergeScanSubscriber2;
  }(SimpleOuterSubscriber);
  function min(comparer) {
    var min2 = typeof comparer === "function" ? function(x2, y) {
      return comparer(x2, y) < 0 ? x2 : y;
    } : function(x2, y) {
      return x2 < y ? x2 : y;
    };
    return reduce(min2);
  }
  function multicast(subjectOrSubjectFactory, selector) {
    return function multicastOperatorFunction(source) {
      var subjectFactory;
      if (typeof subjectOrSubjectFactory === "function") {
        subjectFactory = subjectOrSubjectFactory;
      } else {
        subjectFactory = function subjectFactory2() {
          return subjectOrSubjectFactory;
        };
      }
      if (typeof selector === "function") {
        return source.lift(new MulticastOperator(subjectFactory, selector));
      }
      var connectable = Object.create(source, connectableObservableDescriptor);
      connectable.source = source;
      connectable.subjectFactory = subjectFactory;
      return connectable;
    };
  }
  var MulticastOperator = /* @__PURE__ */ function() {
    function MulticastOperator2(subjectFactory, selector) {
      this.subjectFactory = subjectFactory;
      this.selector = selector;
    }
    MulticastOperator2.prototype.call = function(subscriber, source) {
      var selector = this.selector;
      var subject = this.subjectFactory();
      var subscription = selector(subject).subscribe(subscriber);
      subscription.add(source.subscribe(subject));
      return subscription;
    };
    return MulticastOperator2;
  }();
  function onErrorResumeNext() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      nextSources[_i] = arguments[_i];
    }
    if (nextSources.length === 1 && isArray(nextSources[0])) {
      nextSources = nextSources[0];
    }
    return function(source) {
      return source.lift(new OnErrorResumeNextOperator(nextSources));
    };
  }
  var OnErrorResumeNextOperator = /* @__PURE__ */ function() {
    function OnErrorResumeNextOperator2(nextSources) {
      this.nextSources = nextSources;
    }
    OnErrorResumeNextOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
    };
    return OnErrorResumeNextOperator2;
  }();
  var OnErrorResumeNextSubscriber = /* @__PURE__ */ function(_super) {
    __extends(OnErrorResumeNextSubscriber2, _super);
    function OnErrorResumeNextSubscriber2(destination, nextSources) {
      var _this = _super.call(this, destination) || this;
      _this.destination = destination;
      _this.nextSources = nextSources;
      return _this;
    }
    OnErrorResumeNextSubscriber2.prototype.notifyError = function() {
      this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber2.prototype.notifyComplete = function() {
      this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber2.prototype._error = function(err) {
      this.subscribeToNextSource();
      this.unsubscribe();
    };
    OnErrorResumeNextSubscriber2.prototype._complete = function() {
      this.subscribeToNextSource();
      this.unsubscribe();
    };
    OnErrorResumeNextSubscriber2.prototype.subscribeToNextSource = function() {
      var next = this.nextSources.shift();
      if (!!next) {
        var innerSubscriber = new SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe(next, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          destination.add(innerSubscription);
        }
      } else {
        this.destination.complete();
      }
    };
    return OnErrorResumeNextSubscriber2;
  }(SimpleOuterSubscriber);
  function pairwise() {
    return function(source) {
      return source.lift(new PairwiseOperator());
    };
  }
  var PairwiseOperator = /* @__PURE__ */ function() {
    function PairwiseOperator2() {
    }
    PairwiseOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator2;
  }();
  var PairwiseSubscriber = /* @__PURE__ */ function(_super) {
    __extends(PairwiseSubscriber2, _super);
    function PairwiseSubscriber2(destination) {
      var _this = _super.call(this, destination) || this;
      _this.hasPrev = false;
      return _this;
    }
    PairwiseSubscriber2.prototype._next = function(value2) {
      var pair;
      if (this.hasPrev) {
        pair = [this.prev, value2];
      } else {
        this.hasPrev = true;
      }
      this.prev = value2;
      if (pair) {
        this.destination.next(pair);
      }
    };
    return PairwiseSubscriber2;
  }(Subscriber);
  function partition(predicate, thisArg) {
    return function(source) {
      return [
        filter$1(predicate, thisArg)(source),
        filter$1(not(predicate, thisArg))(source)
      ];
    };
  }
  function pluck() {
    var properties2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      properties2[_i] = arguments[_i];
    }
    var length2 = properties2.length;
    if (length2 === 0) {
      throw new Error("list of properties cannot be empty.");
    }
    return function(source) {
      return map$2(plucker(properties2, length2))(source);
    };
  }
  function plucker(props, length2) {
    var mapper = function(x2) {
      var currentProp = x2;
      for (var i2 = 0; i2 < length2; i2++) {
        var p2 = currentProp != null ? currentProp[props[i2]] : void 0;
        if (p2 !== void 0) {
          currentProp = p2;
        } else {
          return void 0;
        }
      }
      return currentProp;
    };
    return mapper;
  }
  function publish(selector) {
    return selector ? multicast(function() {
      return new Subject();
    }, selector) : multicast(new Subject());
  }
  function publishBehavior(value2) {
    return function(source) {
      return multicast(new BehaviorSubject(value2))(source);
    };
  }
  function publishLast() {
    return function(source) {
      return multicast(new AsyncSubject())(source);
    };
  }
  function publishReplay(bufferSize, windowTime2, selectorOrScheduler, scheduler) {
    if (selectorOrScheduler && typeof selectorOrScheduler !== "function") {
      scheduler = selectorOrScheduler;
    }
    var selector = typeof selectorOrScheduler === "function" ? selectorOrScheduler : void 0;
    var subject = new ReplaySubject(bufferSize, windowTime2, scheduler);
    return function(source) {
      return multicast(function() {
        return subject;
      }, selector)(source);
    };
  }
  function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      observables[_i] = arguments[_i];
    }
    return function raceOperatorFunction(source) {
      if (observables.length === 1 && isArray(observables[0])) {
        observables = observables[0];
      }
      return source.lift.call(race$1.apply(void 0, [source].concat(observables)));
    };
  }
  function repeat(count2) {
    if (count2 === void 0) {
      count2 = -1;
    }
    return function(source) {
      if (count2 === 0) {
        return empty$1();
      } else if (count2 < 0) {
        return source.lift(new RepeatOperator(-1, source));
      } else {
        return source.lift(new RepeatOperator(count2 - 1, source));
      }
    };
  }
  var RepeatOperator = /* @__PURE__ */ function() {
    function RepeatOperator2(count2, source) {
      this.count = count2;
      this.source = source;
    }
    RepeatOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
    };
    return RepeatOperator2;
  }();
  var RepeatSubscriber = /* @__PURE__ */ function(_super) {
    __extends(RepeatSubscriber2, _super);
    function RepeatSubscriber2(destination, count2, source) {
      var _this = _super.call(this, destination) || this;
      _this.count = count2;
      _this.source = source;
      return _this;
    }
    RepeatSubscriber2.prototype.complete = function() {
      if (!this.isStopped) {
        var _a3 = this, source = _a3.source, count2 = _a3.count;
        if (count2 === 0) {
          return _super.prototype.complete.call(this);
        } else if (count2 > -1) {
          this.count = count2 - 1;
        }
        source.subscribe(this._unsubscribeAndRecycle());
      }
    };
    return RepeatSubscriber2;
  }(Subscriber);
  function repeatWhen(notifier) {
    return function(source) {
      return source.lift(new RepeatWhenOperator(notifier));
    };
  }
  var RepeatWhenOperator = /* @__PURE__ */ function() {
    function RepeatWhenOperator2(notifier) {
      this.notifier = notifier;
    }
    RepeatWhenOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
    };
    return RepeatWhenOperator2;
  }();
  var RepeatWhenSubscriber = /* @__PURE__ */ function(_super) {
    __extends(RepeatWhenSubscriber2, _super);
    function RepeatWhenSubscriber2(destination, notifier, source) {
      var _this = _super.call(this, destination) || this;
      _this.notifier = notifier;
      _this.source = source;
      _this.sourceIsBeingSubscribedTo = true;
      return _this;
    }
    RepeatWhenSubscriber2.prototype.notifyNext = function() {
      this.sourceIsBeingSubscribedTo = true;
      this.source.subscribe(this);
    };
    RepeatWhenSubscriber2.prototype.notifyComplete = function() {
      if (this.sourceIsBeingSubscribedTo === false) {
        return _super.prototype.complete.call(this);
      }
    };
    RepeatWhenSubscriber2.prototype.complete = function() {
      this.sourceIsBeingSubscribedTo = false;
      if (!this.isStopped) {
        if (!this.retries) {
          this.subscribeToRetries();
        }
        if (!this.retriesSubscription || this.retriesSubscription.closed) {
          return _super.prototype.complete.call(this);
        }
        this._unsubscribeAndRecycle();
        this.notifications.next(void 0);
      }
    };
    RepeatWhenSubscriber2.prototype._unsubscribe = function() {
      var _a3 = this, notifications = _a3.notifications, retriesSubscription = _a3.retriesSubscription;
      if (notifications) {
        notifications.unsubscribe();
        this.notifications = void 0;
      }
      if (retriesSubscription) {
        retriesSubscription.unsubscribe();
        this.retriesSubscription = void 0;
      }
      this.retries = void 0;
    };
    RepeatWhenSubscriber2.prototype._unsubscribeAndRecycle = function() {
      var _unsubscribe = this._unsubscribe;
      this._unsubscribe = null;
      _super.prototype._unsubscribeAndRecycle.call(this);
      this._unsubscribe = _unsubscribe;
      return this;
    };
    RepeatWhenSubscriber2.prototype.subscribeToRetries = function() {
      this.notifications = new Subject();
      var retries;
      try {
        var notifier = this.notifier;
        retries = notifier(this.notifications);
      } catch (e) {
        return _super.prototype.complete.call(this);
      }
      this.retries = retries;
      this.retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
    };
    return RepeatWhenSubscriber2;
  }(SimpleOuterSubscriber);
  function retry(count2) {
    if (count2 === void 0) {
      count2 = -1;
    }
    return function(source) {
      return source.lift(new RetryOperator(count2, source));
    };
  }
  var RetryOperator = /* @__PURE__ */ function() {
    function RetryOperator2(count2, source) {
      this.count = count2;
      this.source = source;
    }
    RetryOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
    };
    return RetryOperator2;
  }();
  var RetrySubscriber = /* @__PURE__ */ function(_super) {
    __extends(RetrySubscriber2, _super);
    function RetrySubscriber2(destination, count2, source) {
      var _this = _super.call(this, destination) || this;
      _this.count = count2;
      _this.source = source;
      return _this;
    }
    RetrySubscriber2.prototype.error = function(err) {
      if (!this.isStopped) {
        var _a3 = this, source = _a3.source, count2 = _a3.count;
        if (count2 === 0) {
          return _super.prototype.error.call(this, err);
        } else if (count2 > -1) {
          this.count = count2 - 1;
        }
        source.subscribe(this._unsubscribeAndRecycle());
      }
    };
    return RetrySubscriber2;
  }(Subscriber);
  function retryWhen(notifier) {
    return function(source) {
      return source.lift(new RetryWhenOperator(notifier, source));
    };
  }
  var RetryWhenOperator = /* @__PURE__ */ function() {
    function RetryWhenOperator2(notifier, source) {
      this.notifier = notifier;
      this.source = source;
    }
    RetryWhenOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
    };
    return RetryWhenOperator2;
  }();
  var RetryWhenSubscriber = /* @__PURE__ */ function(_super) {
    __extends(RetryWhenSubscriber2, _super);
    function RetryWhenSubscriber2(destination, notifier, source) {
      var _this = _super.call(this, destination) || this;
      _this.notifier = notifier;
      _this.source = source;
      return _this;
    }
    RetryWhenSubscriber2.prototype.error = function(err) {
      if (!this.isStopped) {
        var errors = this.errors;
        var retries = this.retries;
        var retriesSubscription = this.retriesSubscription;
        if (!retries) {
          errors = new Subject();
          try {
            var notifier = this.notifier;
            retries = notifier(errors);
          } catch (e) {
            return _super.prototype.error.call(this, e);
          }
          retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
        } else {
          this.errors = void 0;
          this.retriesSubscription = void 0;
        }
        this._unsubscribeAndRecycle();
        this.errors = errors;
        this.retries = retries;
        this.retriesSubscription = retriesSubscription;
        errors.next(err);
      }
    };
    RetryWhenSubscriber2.prototype._unsubscribe = function() {
      var _a3 = this, errors = _a3.errors, retriesSubscription = _a3.retriesSubscription;
      if (errors) {
        errors.unsubscribe();
        this.errors = void 0;
      }
      if (retriesSubscription) {
        retriesSubscription.unsubscribe();
        this.retriesSubscription = void 0;
      }
      this.retries = void 0;
    };
    RetryWhenSubscriber2.prototype.notifyNext = function() {
      var _unsubscribe = this._unsubscribe;
      this._unsubscribe = null;
      this._unsubscribeAndRecycle();
      this._unsubscribe = _unsubscribe;
      this.source.subscribe(this);
    };
    return RetryWhenSubscriber2;
  }(SimpleOuterSubscriber);
  function sample(notifier) {
    return function(source) {
      return source.lift(new SampleOperator(notifier));
    };
  }
  var SampleOperator = /* @__PURE__ */ function() {
    function SampleOperator2(notifier) {
      this.notifier = notifier;
    }
    SampleOperator2.prototype.call = function(subscriber, source) {
      var sampleSubscriber = new SampleSubscriber(subscriber);
      var subscription = source.subscribe(sampleSubscriber);
      subscription.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(sampleSubscriber)));
      return subscription;
    };
    return SampleOperator2;
  }();
  var SampleSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SampleSubscriber2, _super);
    function SampleSubscriber2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.hasValue = false;
      return _this;
    }
    SampleSubscriber2.prototype._next = function(value2) {
      this.value = value2;
      this.hasValue = true;
    };
    SampleSubscriber2.prototype.notifyNext = function() {
      this.emitValue();
    };
    SampleSubscriber2.prototype.notifyComplete = function() {
      this.emitValue();
    };
    SampleSubscriber2.prototype.emitValue = function() {
      if (this.hasValue) {
        this.hasValue = false;
        this.destination.next(this.value);
      }
    };
    return SampleSubscriber2;
  }(SimpleOuterSubscriber);
  function sampleTime(period, scheduler) {
    if (scheduler === void 0) {
      scheduler = async;
    }
    return function(source) {
      return source.lift(new SampleTimeOperator(period, scheduler));
    };
  }
  var SampleTimeOperator = /* @__PURE__ */ function() {
    function SampleTimeOperator2(period, scheduler) {
      this.period = period;
      this.scheduler = scheduler;
    }
    SampleTimeOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
    };
    return SampleTimeOperator2;
  }();
  var SampleTimeSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SampleTimeSubscriber2, _super);
    function SampleTimeSubscriber2(destination, period, scheduler) {
      var _this = _super.call(this, destination) || this;
      _this.period = period;
      _this.scheduler = scheduler;
      _this.hasValue = false;
      _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period }));
      return _this;
    }
    SampleTimeSubscriber2.prototype._next = function(value2) {
      this.lastValue = value2;
      this.hasValue = true;
    };
    SampleTimeSubscriber2.prototype.notifyNext = function() {
      if (this.hasValue) {
        this.hasValue = false;
        this.destination.next(this.lastValue);
      }
    };
    return SampleTimeSubscriber2;
  }(Subscriber);
  function dispatchNotification(state2) {
    var subscriber = state2.subscriber, period = state2.period;
    subscriber.notifyNext();
    this.schedule(state2, period);
  }
  function sequenceEqual(compareTo, comparator2) {
    return function(source) {
      return source.lift(new SequenceEqualOperator(compareTo, comparator2));
    };
  }
  var SequenceEqualOperator = /* @__PURE__ */ function() {
    function SequenceEqualOperator2(compareTo, comparator2) {
      this.compareTo = compareTo;
      this.comparator = comparator2;
    }
    SequenceEqualOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
    };
    return SequenceEqualOperator2;
  }();
  var SequenceEqualSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SequenceEqualSubscriber2, _super);
    function SequenceEqualSubscriber2(destination, compareTo, comparator2) {
      var _this = _super.call(this, destination) || this;
      _this.compareTo = compareTo;
      _this.comparator = comparator2;
      _this._a = [];
      _this._b = [];
      _this._oneComplete = false;
      _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
      return _this;
    }
    SequenceEqualSubscriber2.prototype._next = function(value2) {
      if (this._oneComplete && this._b.length === 0) {
        this.emit(false);
      } else {
        this._a.push(value2);
        this.checkValues();
      }
    };
    SequenceEqualSubscriber2.prototype._complete = function() {
      if (this._oneComplete) {
        this.emit(this._a.length === 0 && this._b.length === 0);
      } else {
        this._oneComplete = true;
      }
      this.unsubscribe();
    };
    SequenceEqualSubscriber2.prototype.checkValues = function() {
      var _c = this, _a3 = _c._a, _b = _c._b, comparator2 = _c.comparator;
      while (_a3.length > 0 && _b.length > 0) {
        var a = _a3.shift();
        var b = _b.shift();
        var areEqual = false;
        try {
          areEqual = comparator2 ? comparator2(a, b) : a === b;
        } catch (e) {
          this.destination.error(e);
        }
        if (!areEqual) {
          this.emit(false);
        }
      }
    };
    SequenceEqualSubscriber2.prototype.emit = function(value2) {
      var destination = this.destination;
      destination.next(value2);
      destination.complete();
    };
    SequenceEqualSubscriber2.prototype.nextB = function(value2) {
      if (this._oneComplete && this._a.length === 0) {
        this.emit(false);
      } else {
        this._b.push(value2);
        this.checkValues();
      }
    };
    SequenceEqualSubscriber2.prototype.completeB = function() {
      if (this._oneComplete) {
        this.emit(this._a.length === 0 && this._b.length === 0);
      } else {
        this._oneComplete = true;
      }
    };
    return SequenceEqualSubscriber2;
  }(Subscriber);
  var SequenceEqualCompareToSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SequenceEqualCompareToSubscriber2, _super);
    function SequenceEqualCompareToSubscriber2(destination, parent2) {
      var _this = _super.call(this, destination) || this;
      _this.parent = parent2;
      return _this;
    }
    SequenceEqualCompareToSubscriber2.prototype._next = function(value2) {
      this.parent.nextB(value2);
    };
    SequenceEqualCompareToSubscriber2.prototype._error = function(err) {
      this.parent.error(err);
      this.unsubscribe();
    };
    SequenceEqualCompareToSubscriber2.prototype._complete = function() {
      this.parent.completeB();
      this.unsubscribe();
    };
    return SequenceEqualCompareToSubscriber2;
  }(Subscriber);
  function shareSubjectFactory() {
    return new Subject();
  }
  function share() {
    return function(source) {
      return refCount()(multicast(shareSubjectFactory)(source));
    };
  }
  function shareReplay(configOrBufferSize, windowTime2, scheduler) {
    var config2;
    if (configOrBufferSize && typeof configOrBufferSize === "object") {
      config2 = configOrBufferSize;
    } else {
      config2 = {
        bufferSize: configOrBufferSize,
        windowTime: windowTime2,
        refCount: false,
        scheduler
      };
    }
    return function(source) {
      return source.lift(shareReplayOperator(config2));
    };
  }
  function shareReplayOperator(_a3) {
    var _b = _a3.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a3.windowTime, windowTime2 = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a3.refCount, scheduler = _a3.scheduler;
    var subject;
    var refCount2 = 0;
    var subscription;
    var hasError = false;
    var isComplete = false;
    return function shareReplayOperation(source) {
      refCount2++;
      var innerSub;
      if (!subject || hasError) {
        hasError = false;
        subject = new ReplaySubject(bufferSize, windowTime2, scheduler);
        innerSub = subject.subscribe(this);
        subscription = source.subscribe({
          next: function(value2) {
            subject.next(value2);
          },
          error: function(err) {
            hasError = true;
            subject.error(err);
          },
          complete: function() {
            isComplete = true;
            subscription = void 0;
            subject.complete();
          }
        });
        if (isComplete) {
          subscription = void 0;
        }
      } else {
        innerSub = subject.subscribe(this);
      }
      this.add(function() {
        refCount2--;
        innerSub.unsubscribe();
        innerSub = void 0;
        if (subscription && !isComplete && useRefCount && refCount2 === 0) {
          subscription.unsubscribe();
          subscription = void 0;
          subject = void 0;
        }
      });
    };
  }
  function single(predicate) {
    return function(source) {
      return source.lift(new SingleOperator(predicate, source));
    };
  }
  var SingleOperator = /* @__PURE__ */ function() {
    function SingleOperator2(predicate, source) {
      this.predicate = predicate;
      this.source = source;
    }
    SingleOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
    };
    return SingleOperator2;
  }();
  var SingleSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SingleSubscriber2, _super);
    function SingleSubscriber2(destination, predicate, source) {
      var _this = _super.call(this, destination) || this;
      _this.predicate = predicate;
      _this.source = source;
      _this.seenValue = false;
      _this.index = 0;
      return _this;
    }
    SingleSubscriber2.prototype.applySingleValue = function(value2) {
      if (this.seenValue) {
        this.destination.error("Sequence contains more than one element");
      } else {
        this.seenValue = true;
        this.singleValue = value2;
      }
    };
    SingleSubscriber2.prototype._next = function(value2) {
      var index2 = this.index++;
      if (this.predicate) {
        this.tryNext(value2, index2);
      } else {
        this.applySingleValue(value2);
      }
    };
    SingleSubscriber2.prototype.tryNext = function(value2, index2) {
      try {
        if (this.predicate(value2, index2, this.source)) {
          this.applySingleValue(value2);
        }
      } catch (err) {
        this.destination.error(err);
      }
    };
    SingleSubscriber2.prototype._complete = function() {
      var destination = this.destination;
      if (this.index > 0) {
        destination.next(this.seenValue ? this.singleValue : void 0);
        destination.complete();
      } else {
        destination.error(new EmptyError());
      }
    };
    return SingleSubscriber2;
  }(Subscriber);
  function skip(count2) {
    return function(source) {
      return source.lift(new SkipOperator(count2));
    };
  }
  var SkipOperator = /* @__PURE__ */ function() {
    function SkipOperator2(total) {
      this.total = total;
    }
    SkipOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new SkipSubscriber(subscriber, this.total));
    };
    return SkipOperator2;
  }();
  var SkipSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SkipSubscriber2, _super);
    function SkipSubscriber2(destination, total) {
      var _this = _super.call(this, destination) || this;
      _this.total = total;
      _this.count = 0;
      return _this;
    }
    SkipSubscriber2.prototype._next = function(x2) {
      if (++this.count > this.total) {
        this.destination.next(x2);
      }
    };
    return SkipSubscriber2;
  }(Subscriber);
  function skipLast(count2) {
    return function(source) {
      return source.lift(new SkipLastOperator(count2));
    };
  }
  var SkipLastOperator = /* @__PURE__ */ function() {
    function SkipLastOperator2(_skipCount) {
      this._skipCount = _skipCount;
      if (this._skipCount < 0) {
        throw new ArgumentOutOfRangeError();
      }
    }
    SkipLastOperator2.prototype.call = function(subscriber, source) {
      if (this._skipCount === 0) {
        return source.subscribe(new Subscriber(subscriber));
      } else {
        return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
      }
    };
    return SkipLastOperator2;
  }();
  var SkipLastSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SkipLastSubscriber2, _super);
    function SkipLastSubscriber2(destination, _skipCount) {
      var _this = _super.call(this, destination) || this;
      _this._skipCount = _skipCount;
      _this._count = 0;
      _this._ring = new Array(_skipCount);
      return _this;
    }
    SkipLastSubscriber2.prototype._next = function(value2) {
      var skipCount = this._skipCount;
      var count2 = this._count++;
      if (count2 < skipCount) {
        this._ring[count2] = value2;
      } else {
        var currentIndex = count2 % skipCount;
        var ring2 = this._ring;
        var oldValue = ring2[currentIndex];
        ring2[currentIndex] = value2;
        this.destination.next(oldValue);
      }
    };
    return SkipLastSubscriber2;
  }(Subscriber);
  function skipUntil(notifier) {
    return function(source) {
      return source.lift(new SkipUntilOperator(notifier));
    };
  }
  var SkipUntilOperator = /* @__PURE__ */ function() {
    function SkipUntilOperator2(notifier) {
      this.notifier = notifier;
    }
    SkipUntilOperator2.prototype.call = function(destination, source) {
      return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
    };
    return SkipUntilOperator2;
  }();
  var SkipUntilSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SkipUntilSubscriber2, _super);
    function SkipUntilSubscriber2(destination, notifier) {
      var _this = _super.call(this, destination) || this;
      _this.hasValue = false;
      var innerSubscriber = new SimpleInnerSubscriber(_this);
      _this.add(innerSubscriber);
      _this.innerSubscription = innerSubscriber;
      var innerSubscription = innerSubscribe(notifier, innerSubscriber);
      if (innerSubscription !== innerSubscriber) {
        _this.add(innerSubscription);
        _this.innerSubscription = innerSubscription;
      }
      return _this;
    }
    SkipUntilSubscriber2.prototype._next = function(value2) {
      if (this.hasValue) {
        _super.prototype._next.call(this, value2);
      }
    };
    SkipUntilSubscriber2.prototype.notifyNext = function() {
      this.hasValue = true;
      if (this.innerSubscription) {
        this.innerSubscription.unsubscribe();
      }
    };
    SkipUntilSubscriber2.prototype.notifyComplete = function() {
    };
    return SkipUntilSubscriber2;
  }(SimpleOuterSubscriber);
  function skipWhile(predicate) {
    return function(source) {
      return source.lift(new SkipWhileOperator(predicate));
    };
  }
  var SkipWhileOperator = /* @__PURE__ */ function() {
    function SkipWhileOperator2(predicate) {
      this.predicate = predicate;
    }
    SkipWhileOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
    };
    return SkipWhileOperator2;
  }();
  var SkipWhileSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SkipWhileSubscriber2, _super);
    function SkipWhileSubscriber2(destination, predicate) {
      var _this = _super.call(this, destination) || this;
      _this.predicate = predicate;
      _this.skipping = true;
      _this.index = 0;
      return _this;
    }
    SkipWhileSubscriber2.prototype._next = function(value2) {
      var destination = this.destination;
      if (this.skipping) {
        this.tryCallPredicate(value2);
      }
      if (!this.skipping) {
        destination.next(value2);
      }
    };
    SkipWhileSubscriber2.prototype.tryCallPredicate = function(value2) {
      try {
        var result = this.predicate(value2, this.index++);
        this.skipping = Boolean(result);
      } catch (err) {
        this.destination.error(err);
      }
    };
    return SkipWhileSubscriber2;
  }(Subscriber);
  function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      array[_i] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (isScheduler(scheduler)) {
      array.pop();
      return function(source) {
        return concat$1(array, source, scheduler);
      };
    } else {
      return function(source) {
        return concat$1(array, source);
      };
    }
  }
  var SubscribeOnObservable = /* @__PURE__ */ function(_super) {
    __extends(SubscribeOnObservable2, _super);
    function SubscribeOnObservable2(source, delayTime, scheduler) {
      if (delayTime === void 0) {
        delayTime = 0;
      }
      if (scheduler === void 0) {
        scheduler = asap;
      }
      var _this = _super.call(this) || this;
      _this.source = source;
      _this.delayTime = delayTime;
      _this.scheduler = scheduler;
      if (!isNumeric(delayTime) || delayTime < 0) {
        _this.delayTime = 0;
      }
      if (!scheduler || typeof scheduler.schedule !== "function") {
        _this.scheduler = asap;
      }
      return _this;
    }
    SubscribeOnObservable2.create = function(source, delay2, scheduler) {
      if (delay2 === void 0) {
        delay2 = 0;
      }
      if (scheduler === void 0) {
        scheduler = asap;
      }
      return new SubscribeOnObservable2(source, delay2, scheduler);
    };
    SubscribeOnObservable2.dispatch = function(arg) {
      var source = arg.source, subscriber = arg.subscriber;
      return this.add(source.subscribe(subscriber));
    };
    SubscribeOnObservable2.prototype._subscribe = function(subscriber) {
      var delay2 = this.delayTime;
      var source = this.source;
      var scheduler = this.scheduler;
      return scheduler.schedule(SubscribeOnObservable2.dispatch, delay2, {
        source,
        subscriber
      });
    };
    return SubscribeOnObservable2;
  }(Observable);
  function subscribeOn(scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return function subscribeOnOperatorFunction(source) {
      return source.lift(new SubscribeOnOperator(scheduler, delay2));
    };
  }
  var SubscribeOnOperator = /* @__PURE__ */ function() {
    function SubscribeOnOperator2(scheduler, delay2) {
      this.scheduler = scheduler;
      this.delay = delay2;
    }
    SubscribeOnOperator2.prototype.call = function(subscriber, source) {
      return new SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
    };
    return SubscribeOnOperator2;
  }();
  function switchMap(project, resultSelector) {
    if (typeof resultSelector === "function") {
      return function(source) {
        return source.pipe(switchMap(function(a, i2) {
          return from(project(a, i2)).pipe(map$2(function(b, ii) {
            return resultSelector(a, b, i2, ii);
          }));
        }));
      };
    }
    return function(source) {
      return source.lift(new SwitchMapOperator(project));
    };
  }
  var SwitchMapOperator = /* @__PURE__ */ function() {
    function SwitchMapOperator2(project) {
      this.project = project;
    }
    SwitchMapOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
    };
    return SwitchMapOperator2;
  }();
  var SwitchMapSubscriber = /* @__PURE__ */ function(_super) {
    __extends(SwitchMapSubscriber2, _super);
    function SwitchMapSubscriber2(destination, project) {
      var _this = _super.call(this, destination) || this;
      _this.project = project;
      _this.index = 0;
      return _this;
    }
    SwitchMapSubscriber2.prototype._next = function(value2) {
      var result;
      var index2 = this.index++;
      try {
        result = this.project(value2, index2);
      } catch (error) {
        this.destination.error(error);
        return;
      }
      this._innerSub(result);
    };
    SwitchMapSubscriber2.prototype._innerSub = function(result) {
      var innerSubscription = this.innerSubscription;
      if (innerSubscription) {
        innerSubscription.unsubscribe();
      }
      var innerSubscriber = new SimpleInnerSubscriber(this);
      var destination = this.destination;
      destination.add(innerSubscriber);
      this.innerSubscription = innerSubscribe(result, innerSubscriber);
      if (this.innerSubscription !== innerSubscriber) {
        destination.add(this.innerSubscription);
      }
    };
    SwitchMapSubscriber2.prototype._complete = function() {
      var innerSubscription = this.innerSubscription;
      if (!innerSubscription || innerSubscription.closed) {
        _super.prototype._complete.call(this);
      }
      this.unsubscribe();
    };
    SwitchMapSubscriber2.prototype._unsubscribe = function() {
      this.innerSubscription = void 0;
    };
    SwitchMapSubscriber2.prototype.notifyComplete = function() {
      this.innerSubscription = void 0;
      if (this.isStopped) {
        _super.prototype._complete.call(this);
      }
    };
    SwitchMapSubscriber2.prototype.notifyNext = function(innerValue) {
      this.destination.next(innerValue);
    };
    return SwitchMapSubscriber2;
  }(SimpleOuterSubscriber);
  function switchAll() {
    return switchMap(identity);
  }
  function switchMapTo(innerObservable, resultSelector) {
    return resultSelector ? switchMap(function() {
      return innerObservable;
    }, resultSelector) : switchMap(function() {
      return innerObservable;
    });
  }
  function takeUntil(notifier) {
    return function(source) {
      return source.lift(new TakeUntilOperator(notifier));
    };
  }
  var TakeUntilOperator = /* @__PURE__ */ function() {
    function TakeUntilOperator2(notifier) {
      this.notifier = notifier;
    }
    TakeUntilOperator2.prototype.call = function(subscriber, source) {
      var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
      var notifierSubscription = innerSubscribe(this.notifier, new SimpleInnerSubscriber(takeUntilSubscriber));
      if (notifierSubscription && !takeUntilSubscriber.seenValue) {
        takeUntilSubscriber.add(notifierSubscription);
        return source.subscribe(takeUntilSubscriber);
      }
      return takeUntilSubscriber;
    };
    return TakeUntilOperator2;
  }();
  var TakeUntilSubscriber = /* @__PURE__ */ function(_super) {
    __extends(TakeUntilSubscriber2, _super);
    function TakeUntilSubscriber2(destination) {
      var _this = _super.call(this, destination) || this;
      _this.seenValue = false;
      return _this;
    }
    TakeUntilSubscriber2.prototype.notifyNext = function() {
      this.seenValue = true;
      this.complete();
    };
    TakeUntilSubscriber2.prototype.notifyComplete = function() {
    };
    return TakeUntilSubscriber2;
  }(SimpleOuterSubscriber);
  function takeWhile(predicate, inclusive) {
    if (inclusive === void 0) {
      inclusive = false;
    }
    return function(source) {
      return source.lift(new TakeWhileOperator(predicate, inclusive));
    };
  }
  var TakeWhileOperator = /* @__PURE__ */ function() {
    function TakeWhileOperator2(predicate, inclusive) {
      this.predicate = predicate;
      this.inclusive = inclusive;
    }
    TakeWhileOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
    };
    return TakeWhileOperator2;
  }();
  var TakeWhileSubscriber = /* @__PURE__ */ function(_super) {
    __extends(TakeWhileSubscriber2, _super);
    function TakeWhileSubscriber2(destination, predicate, inclusive) {
      var _this = _super.call(this, destination) || this;
      _this.predicate = predicate;
      _this.inclusive = inclusive;
      _this.index = 0;
      return _this;
    }
    TakeWhileSubscriber2.prototype._next = function(value2) {
      var destination = this.destination;
      var result;
      try {
        result = this.predicate(value2, this.index++);
      } catch (err) {
        destination.error(err);
        return;
      }
      this.nextOrComplete(value2, result);
    };
    TakeWhileSubscriber2.prototype.nextOrComplete = function(value2, predicateResult) {
      var destination = this.destination;
      if (Boolean(predicateResult)) {
        destination.next(value2);
      } else {
        if (this.inclusive) {
          destination.next(value2);
        }
        destination.complete();
      }
    };
    return TakeWhileSubscriber2;
  }(Subscriber);
  function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
      return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
  }
  var DoOperator = /* @__PURE__ */ function() {
    function DoOperator2(nextOrObserver, error, complete) {
      this.nextOrObserver = nextOrObserver;
      this.error = error;
      this.complete = complete;
    }
    DoOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator2;
  }();
  var TapSubscriber = /* @__PURE__ */ function(_super) {
    __extends(TapSubscriber2, _super);
    function TapSubscriber2(destination, observerOrNext, error, complete) {
      var _this = _super.call(this, destination) || this;
      _this._tapNext = noop;
      _this._tapError = noop;
      _this._tapComplete = noop;
      _this._tapError = error || noop;
      _this._tapComplete = complete || noop;
      if (isFunction$2(observerOrNext)) {
        _this._context = _this;
        _this._tapNext = observerOrNext;
      } else if (observerOrNext) {
        _this._context = observerOrNext;
        _this._tapNext = observerOrNext.next || noop;
        _this._tapError = observerOrNext.error || noop;
        _this._tapComplete = observerOrNext.complete || noop;
      }
      return _this;
    }
    TapSubscriber2.prototype._next = function(value2) {
      try {
        this._tapNext.call(this._context, value2);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      this.destination.next(value2);
    };
    TapSubscriber2.prototype._error = function(err) {
      try {
        this._tapError.call(this._context, err);
      } catch (err2) {
        this.destination.error(err2);
        return;
      }
      this.destination.error(err);
    };
    TapSubscriber2.prototype._complete = function() {
      try {
        this._tapComplete.call(this._context);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      return this.destination.complete();
    };
    return TapSubscriber2;
  }(Subscriber);
  var defaultThrottleConfig = {
    leading: true,
    trailing: false
  };
  function throttle(durationSelector, config2) {
    if (config2 === void 0) {
      config2 = defaultThrottleConfig;
    }
    return function(source) {
      return source.lift(new ThrottleOperator(durationSelector, !!config2.leading, !!config2.trailing));
    };
  }
  var ThrottleOperator = /* @__PURE__ */ function() {
    function ThrottleOperator2(durationSelector, leading, trailing) {
      this.durationSelector = durationSelector;
      this.leading = leading;
      this.trailing = trailing;
    }
    ThrottleOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    };
    return ThrottleOperator2;
  }();
  var ThrottleSubscriber = /* @__PURE__ */ function(_super) {
    __extends(ThrottleSubscriber2, _super);
    function ThrottleSubscriber2(destination, durationSelector, _leading, _trailing) {
      var _this = _super.call(this, destination) || this;
      _this.destination = destination;
      _this.durationSelector = durationSelector;
      _this._leading = _leading;
      _this._trailing = _trailing;
      _this._hasValue = false;
      return _this;
    }
    ThrottleSubscriber2.prototype._next = function(value2) {
      this._hasValue = true;
      this._sendValue = value2;
      if (!this._throttled) {
        if (this._leading) {
          this.send();
        } else {
          this.throttle(value2);
        }
      }
    };
    ThrottleSubscriber2.prototype.send = function() {
      var _a3 = this, _hasValue = _a3._hasValue, _sendValue = _a3._sendValue;
      if (_hasValue) {
        this.destination.next(_sendValue);
        this.throttle(_sendValue);
      }
      this._hasValue = false;
      this._sendValue = void 0;
    };
    ThrottleSubscriber2.prototype.throttle = function(value2) {
      var duration = this.tryDurationSelector(value2);
      if (!!duration) {
        this.add(this._throttled = innerSubscribe(duration, new SimpleInnerSubscriber(this)));
      }
    };
    ThrottleSubscriber2.prototype.tryDurationSelector = function(value2) {
      try {
        return this.durationSelector(value2);
      } catch (err) {
        this.destination.error(err);
        return null;
      }
    };
    ThrottleSubscriber2.prototype.throttlingDone = function() {
      var _a3 = this, _throttled = _a3._throttled, _trailing = _a3._trailing;
      if (_throttled) {
        _throttled.unsubscribe();
      }
      this._throttled = void 0;
      if (_trailing) {
        this.send();
      }
    };
    ThrottleSubscriber2.prototype.notifyNext = function() {
      this.throttlingDone();
    };
    ThrottleSubscriber2.prototype.notifyComplete = function() {
      this.throttlingDone();
    };
    return ThrottleSubscriber2;
  }(SimpleOuterSubscriber);
  function throttleTime(duration, scheduler, config2) {
    if (scheduler === void 0) {
      scheduler = async;
    }
    if (config2 === void 0) {
      config2 = defaultThrottleConfig;
    }
    return function(source) {
      return source.lift(new ThrottleTimeOperator(duration, scheduler, config2.leading, config2.trailing));
    };
  }
  var ThrottleTimeOperator = /* @__PURE__ */ function() {
    function ThrottleTimeOperator2(duration, scheduler, leading, trailing) {
      this.duration = duration;
      this.scheduler = scheduler;
      this.leading = leading;
      this.trailing = trailing;
    }
    ThrottleTimeOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
    };
    return ThrottleTimeOperator2;
  }();
  var ThrottleTimeSubscriber = /* @__PURE__ */ function(_super) {
    __extends(ThrottleTimeSubscriber2, _super);
    function ThrottleTimeSubscriber2(destination, duration, scheduler, leading, trailing) {
      var _this = _super.call(this, destination) || this;
      _this.duration = duration;
      _this.scheduler = scheduler;
      _this.leading = leading;
      _this.trailing = trailing;
      _this._hasTrailingValue = false;
      _this._trailingValue = null;
      return _this;
    }
    ThrottleTimeSubscriber2.prototype._next = function(value2) {
      if (this.throttled) {
        if (this.trailing) {
          this._trailingValue = value2;
          this._hasTrailingValue = true;
        }
      } else {
        this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
        if (this.leading) {
          this.destination.next(value2);
        } else if (this.trailing) {
          this._trailingValue = value2;
          this._hasTrailingValue = true;
        }
      }
    };
    ThrottleTimeSubscriber2.prototype._complete = function() {
      if (this._hasTrailingValue) {
        this.destination.next(this._trailingValue);
        this.destination.complete();
      } else {
        this.destination.complete();
      }
    };
    ThrottleTimeSubscriber2.prototype.clearThrottle = function() {
      var throttled = this.throttled;
      if (throttled) {
        if (this.trailing && this._hasTrailingValue) {
          this.destination.next(this._trailingValue);
          this._trailingValue = null;
          this._hasTrailingValue = false;
        }
        throttled.unsubscribe();
        this.remove(throttled);
        this.throttled = null;
      }
    };
    return ThrottleTimeSubscriber2;
  }(Subscriber);
  function dispatchNext(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
  }
  function timeInterval(scheduler) {
    if (scheduler === void 0) {
      scheduler = async;
    }
    return function(source) {
      return defer(function() {
        return source.pipe(scan(function(_a3, value2) {
          var current = _a3.current;
          return { value: value2, current: scheduler.now(), last: current };
        }, { current: scheduler.now(), value: void 0, last: void 0 }), map$2(function(_a3) {
          var current = _a3.current, last2 = _a3.last, value2 = _a3.value;
          return new TimeInterval(value2, current - last2);
        }));
      });
    };
  }
  var TimeInterval = /* @__PURE__ */ function() {
    function TimeInterval2(value2, interval2) {
      this.value = value2;
      this.interval = interval2;
    }
    return TimeInterval2;
  }();
  function timeoutWith(due, withObservable, scheduler) {
    if (scheduler === void 0) {
      scheduler = async;
    }
    return function(source) {
      var absoluteTimeout = isDate(due);
      var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
      return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
    };
  }
  var TimeoutWithOperator = /* @__PURE__ */ function() {
    function TimeoutWithOperator2(waitFor, absoluteTimeout, withObservable, scheduler) {
      this.waitFor = waitFor;
      this.absoluteTimeout = absoluteTimeout;
      this.withObservable = withObservable;
      this.scheduler = scheduler;
    }
    TimeoutWithOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
    };
    return TimeoutWithOperator2;
  }();
  var TimeoutWithSubscriber = /* @__PURE__ */ function(_super) {
    __extends(TimeoutWithSubscriber2, _super);
    function TimeoutWithSubscriber2(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
      var _this = _super.call(this, destination) || this;
      _this.absoluteTimeout = absoluteTimeout;
      _this.waitFor = waitFor;
      _this.withObservable = withObservable;
      _this.scheduler = scheduler;
      _this.scheduleTimeout();
      return _this;
    }
    TimeoutWithSubscriber2.dispatchTimeout = function(subscriber) {
      var withObservable = subscriber.withObservable;
      subscriber._unsubscribeAndRecycle();
      subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));
    };
    TimeoutWithSubscriber2.prototype.scheduleTimeout = function() {
      var action = this.action;
      if (action) {
        this.action = action.schedule(this, this.waitFor);
      } else {
        this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber2.dispatchTimeout, this.waitFor, this));
      }
    };
    TimeoutWithSubscriber2.prototype._next = function(value2) {
      if (!this.absoluteTimeout) {
        this.scheduleTimeout();
      }
      _super.prototype._next.call(this, value2);
    };
    TimeoutWithSubscriber2.prototype._unsubscribe = function() {
      this.action = void 0;
      this.scheduler = null;
      this.withObservable = null;
    };
    return TimeoutWithSubscriber2;
  }(SimpleOuterSubscriber);
  function timeout(due, scheduler) {
    if (scheduler === void 0) {
      scheduler = async;
    }
    return timeoutWith(due, throwError(new TimeoutError()), scheduler);
  }
  function timestamp(scheduler) {
    if (scheduler === void 0) {
      scheduler = async;
    }
    return map$2(function(value2) {
      return new Timestamp(value2, scheduler.now());
    });
  }
  var Timestamp = /* @__PURE__ */ function() {
    function Timestamp2(value2, timestamp2) {
      this.value = value2;
      this.timestamp = timestamp2;
    }
    return Timestamp2;
  }();
  function toArrayReducer(arr, item, index2) {
    if (index2 === 0) {
      return [item];
    }
    arr.push(item);
    return arr;
  }
  function toArray$1() {
    return reduce(toArrayReducer, []);
  }
  function window$1(windowBoundaries) {
    return function windowOperatorFunction(source) {
      return source.lift(new WindowOperator$1(windowBoundaries));
    };
  }
  var WindowOperator$1 = /* @__PURE__ */ function() {
    function WindowOperator2(windowBoundaries) {
      this.windowBoundaries = windowBoundaries;
    }
    WindowOperator2.prototype.call = function(subscriber, source) {
      var windowSubscriber = new WindowSubscriber$1(subscriber);
      var sourceSubscription = source.subscribe(windowSubscriber);
      if (!sourceSubscription.closed) {
        windowSubscriber.add(innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(windowSubscriber)));
      }
      return sourceSubscription;
    };
    return WindowOperator2;
  }();
  var WindowSubscriber$1 = /* @__PURE__ */ function(_super) {
    __extends(WindowSubscriber2, _super);
    function WindowSubscriber2(destination) {
      var _this = _super.call(this, destination) || this;
      _this.window = new Subject();
      destination.next(_this.window);
      return _this;
    }
    WindowSubscriber2.prototype.notifyNext = function() {
      this.openWindow();
    };
    WindowSubscriber2.prototype.notifyError = function(error) {
      this._error(error);
    };
    WindowSubscriber2.prototype.notifyComplete = function() {
      this._complete();
    };
    WindowSubscriber2.prototype._next = function(value2) {
      this.window.next(value2);
    };
    WindowSubscriber2.prototype._error = function(err) {
      this.window.error(err);
      this.destination.error(err);
    };
    WindowSubscriber2.prototype._complete = function() {
      this.window.complete();
      this.destination.complete();
    };
    WindowSubscriber2.prototype._unsubscribe = function() {
      this.window = null;
    };
    WindowSubscriber2.prototype.openWindow = function() {
      var prevWindow = this.window;
      if (prevWindow) {
        prevWindow.complete();
      }
      var destination = this.destination;
      var newWindow = this.window = new Subject();
      destination.next(newWindow);
    };
    return WindowSubscriber2;
  }(SimpleOuterSubscriber);
  function windowCount(windowSize, startWindowEvery) {
    if (startWindowEvery === void 0) {
      startWindowEvery = 0;
    }
    return function windowCountOperatorFunction(source) {
      return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
    };
  }
  var WindowCountOperator = /* @__PURE__ */ function() {
    function WindowCountOperator2(windowSize, startWindowEvery) {
      this.windowSize = windowSize;
      this.startWindowEvery = startWindowEvery;
    }
    WindowCountOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
    };
    return WindowCountOperator2;
  }();
  var WindowCountSubscriber = /* @__PURE__ */ function(_super) {
    __extends(WindowCountSubscriber2, _super);
    function WindowCountSubscriber2(destination, windowSize, startWindowEvery) {
      var _this = _super.call(this, destination) || this;
      _this.destination = destination;
      _this.windowSize = windowSize;
      _this.startWindowEvery = startWindowEvery;
      _this.windows = [new Subject()];
      _this.count = 0;
      destination.next(_this.windows[0]);
      return _this;
    }
    WindowCountSubscriber2.prototype._next = function(value2) {
      var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
      var destination = this.destination;
      var windowSize = this.windowSize;
      var windows = this.windows;
      var len2 = windows.length;
      for (var i2 = 0; i2 < len2 && !this.closed; i2++) {
        windows[i2].next(value2);
      }
      var c = this.count - windowSize + 1;
      if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
        windows.shift().complete();
      }
      if (++this.count % startWindowEvery === 0 && !this.closed) {
        var window_1 = new Subject();
        windows.push(window_1);
        destination.next(window_1);
      }
    };
    WindowCountSubscriber2.prototype._error = function(err) {
      var windows = this.windows;
      if (windows) {
        while (windows.length > 0 && !this.closed) {
          windows.shift().error(err);
        }
      }
      this.destination.error(err);
    };
    WindowCountSubscriber2.prototype._complete = function() {
      var windows = this.windows;
      if (windows) {
        while (windows.length > 0 && !this.closed) {
          windows.shift().complete();
        }
      }
      this.destination.complete();
    };
    WindowCountSubscriber2.prototype._unsubscribe = function() {
      this.count = 0;
      this.windows = null;
    };
    return WindowCountSubscriber2;
  }(Subscriber);
  function windowTime(windowTimeSpan) {
    var scheduler = async;
    var windowCreationInterval = null;
    var maxWindowSize = Number.POSITIVE_INFINITY;
    if (isScheduler(arguments[3])) {
      scheduler = arguments[3];
    }
    if (isScheduler(arguments[2])) {
      scheduler = arguments[2];
    } else if (isNumeric(arguments[2])) {
      maxWindowSize = Number(arguments[2]);
    }
    if (isScheduler(arguments[1])) {
      scheduler = arguments[1];
    } else if (isNumeric(arguments[1])) {
      windowCreationInterval = Number(arguments[1]);
    }
    return function windowTimeOperatorFunction(source) {
      return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
    };
  }
  var WindowTimeOperator = /* @__PURE__ */ function() {
    function WindowTimeOperator2(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
      this.windowTimeSpan = windowTimeSpan;
      this.windowCreationInterval = windowCreationInterval;
      this.maxWindowSize = maxWindowSize;
      this.scheduler = scheduler;
    }
    WindowTimeOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
    };
    return WindowTimeOperator2;
  }();
  var CountedSubject = /* @__PURE__ */ function(_super) {
    __extends(CountedSubject2, _super);
    function CountedSubject2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._numberOfNextedValues = 0;
      return _this;
    }
    CountedSubject2.prototype.next = function(value2) {
      this._numberOfNextedValues++;
      _super.prototype.next.call(this, value2);
    };
    Object.defineProperty(CountedSubject2.prototype, "numberOfNextedValues", {
      get: function() {
        return this._numberOfNextedValues;
      },
      enumerable: true,
      configurable: true
    });
    return CountedSubject2;
  }(Subject);
  var WindowTimeSubscriber = /* @__PURE__ */ function(_super) {
    __extends(WindowTimeSubscriber2, _super);
    function WindowTimeSubscriber2(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
      var _this = _super.call(this, destination) || this;
      _this.destination = destination;
      _this.windowTimeSpan = windowTimeSpan;
      _this.windowCreationInterval = windowCreationInterval;
      _this.maxWindowSize = maxWindowSize;
      _this.scheduler = scheduler;
      _this.windows = [];
      var window2 = _this.openWindow();
      if (windowCreationInterval !== null && windowCreationInterval >= 0) {
        var closeState = { subscriber: _this, window: window2, context: null };
        var creationState = { windowTimeSpan, windowCreationInterval, subscriber: _this, scheduler };
        _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
        _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
      } else {
        var timeSpanOnlyState = { subscriber: _this, window: window2, windowTimeSpan };
        _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
      }
      return _this;
    }
    WindowTimeSubscriber2.prototype._next = function(value2) {
      var windows = this.windows;
      var len2 = windows.length;
      for (var i2 = 0; i2 < len2; i2++) {
        var window_1 = windows[i2];
        if (!window_1.closed) {
          window_1.next(value2);
          if (window_1.numberOfNextedValues >= this.maxWindowSize) {
            this.closeWindow(window_1);
          }
        }
      }
    };
    WindowTimeSubscriber2.prototype._error = function(err) {
      var windows = this.windows;
      while (windows.length > 0) {
        windows.shift().error(err);
      }
      this.destination.error(err);
    };
    WindowTimeSubscriber2.prototype._complete = function() {
      var windows = this.windows;
      while (windows.length > 0) {
        var window_2 = windows.shift();
        if (!window_2.closed) {
          window_2.complete();
        }
      }
      this.destination.complete();
    };
    WindowTimeSubscriber2.prototype.openWindow = function() {
      var window2 = new CountedSubject();
      this.windows.push(window2);
      var destination = this.destination;
      destination.next(window2);
      return window2;
    };
    WindowTimeSubscriber2.prototype.closeWindow = function(window2) {
      window2.complete();
      var windows = this.windows;
      windows.splice(windows.indexOf(window2), 1);
    };
    return WindowTimeSubscriber2;
  }(Subscriber);
  function dispatchWindowTimeSpanOnly(state2) {
    var subscriber = state2.subscriber, windowTimeSpan = state2.windowTimeSpan, window2 = state2.window;
    if (window2) {
      subscriber.closeWindow(window2);
    }
    state2.window = subscriber.openWindow();
    this.schedule(state2, windowTimeSpan);
  }
  function dispatchWindowCreation(state2) {
    var windowTimeSpan = state2.windowTimeSpan, subscriber = state2.subscriber, scheduler = state2.scheduler, windowCreationInterval = state2.windowCreationInterval;
    var window2 = subscriber.openWindow();
    var action = this;
    var context2 = { action, subscription: null };
    var timeSpanState = { subscriber, window: window2, context: context2 };
    context2.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context2.subscription);
    action.schedule(state2, windowCreationInterval);
  }
  function dispatchWindowClose(state2) {
    var subscriber = state2.subscriber, window2 = state2.window, context2 = state2.context;
    if (context2 && context2.action && context2.subscription) {
      context2.action.remove(context2.subscription);
    }
    subscriber.closeWindow(window2);
  }
  function windowToggle(openings, closingSelector) {
    return function(source) {
      return source.lift(new WindowToggleOperator(openings, closingSelector));
    };
  }
  var WindowToggleOperator = /* @__PURE__ */ function() {
    function WindowToggleOperator2(openings, closingSelector) {
      this.openings = openings;
      this.closingSelector = closingSelector;
    }
    WindowToggleOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return WindowToggleOperator2;
  }();
  var WindowToggleSubscriber = /* @__PURE__ */ function(_super) {
    __extends(WindowToggleSubscriber2, _super);
    function WindowToggleSubscriber2(destination, openings, closingSelector) {
      var _this = _super.call(this, destination) || this;
      _this.openings = openings;
      _this.closingSelector = closingSelector;
      _this.contexts = [];
      _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));
      return _this;
    }
    WindowToggleSubscriber2.prototype._next = function(value2) {
      var contexts = this.contexts;
      if (contexts) {
        var len2 = contexts.length;
        for (var i2 = 0; i2 < len2; i2++) {
          contexts[i2].window.next(value2);
        }
      }
    };
    WindowToggleSubscriber2.prototype._error = function(err) {
      var contexts = this.contexts;
      this.contexts = null;
      if (contexts) {
        var len2 = contexts.length;
        var index2 = -1;
        while (++index2 < len2) {
          var context_1 = contexts[index2];
          context_1.window.error(err);
          context_1.subscription.unsubscribe();
        }
      }
      _super.prototype._error.call(this, err);
    };
    WindowToggleSubscriber2.prototype._complete = function() {
      var contexts = this.contexts;
      this.contexts = null;
      if (contexts) {
        var len2 = contexts.length;
        var index2 = -1;
        while (++index2 < len2) {
          var context_2 = contexts[index2];
          context_2.window.complete();
          context_2.subscription.unsubscribe();
        }
      }
      _super.prototype._complete.call(this);
    };
    WindowToggleSubscriber2.prototype._unsubscribe = function() {
      var contexts = this.contexts;
      this.contexts = null;
      if (contexts) {
        var len2 = contexts.length;
        var index2 = -1;
        while (++index2 < len2) {
          var context_3 = contexts[index2];
          context_3.window.unsubscribe();
          context_3.subscription.unsubscribe();
        }
      }
    };
    WindowToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
      if (outerValue === this.openings) {
        var closingNotifier = void 0;
        try {
          var closingSelector = this.closingSelector;
          closingNotifier = closingSelector(innerValue);
        } catch (e) {
          return this.error(e);
        }
        var window_1 = new Subject();
        var subscription = new Subscription();
        var context_4 = { window: window_1, subscription };
        this.contexts.push(context_4);
        var innerSubscription = subscribeToResult(this, closingNotifier, context_4);
        if (innerSubscription.closed) {
          this.closeWindow(this.contexts.length - 1);
        } else {
          innerSubscription.context = context_4;
          subscription.add(innerSubscription);
        }
        this.destination.next(window_1);
      } else {
        this.closeWindow(this.contexts.indexOf(outerValue));
      }
    };
    WindowToggleSubscriber2.prototype.notifyError = function(err) {
      this.error(err);
    };
    WindowToggleSubscriber2.prototype.notifyComplete = function(inner) {
      if (inner !== this.openSubscription) {
        this.closeWindow(this.contexts.indexOf(inner.context));
      }
    };
    WindowToggleSubscriber2.prototype.closeWindow = function(index2) {
      if (index2 === -1) {
        return;
      }
      var contexts = this.contexts;
      var context2 = contexts[index2];
      var window2 = context2.window, subscription = context2.subscription;
      contexts.splice(index2, 1);
      window2.complete();
      subscription.unsubscribe();
    };
    return WindowToggleSubscriber2;
  }(OuterSubscriber);
  function windowWhen(closingSelector) {
    return function windowWhenOperatorFunction(source) {
      return source.lift(new WindowOperator(closingSelector));
    };
  }
  var WindowOperator = /* @__PURE__ */ function() {
    function WindowOperator2(closingSelector) {
      this.closingSelector = closingSelector;
    }
    WindowOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
    };
    return WindowOperator2;
  }();
  var WindowSubscriber = /* @__PURE__ */ function(_super) {
    __extends(WindowSubscriber2, _super);
    function WindowSubscriber2(destination, closingSelector) {
      var _this = _super.call(this, destination) || this;
      _this.destination = destination;
      _this.closingSelector = closingSelector;
      _this.openWindow();
      return _this;
    }
    WindowSubscriber2.prototype.notifyNext = function(_outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
      this.openWindow(innerSub);
    };
    WindowSubscriber2.prototype.notifyError = function(error) {
      this._error(error);
    };
    WindowSubscriber2.prototype.notifyComplete = function(innerSub) {
      this.openWindow(innerSub);
    };
    WindowSubscriber2.prototype._next = function(value2) {
      this.window.next(value2);
    };
    WindowSubscriber2.prototype._error = function(err) {
      this.window.error(err);
      this.destination.error(err);
      this.unsubscribeClosingNotification();
    };
    WindowSubscriber2.prototype._complete = function() {
      this.window.complete();
      this.destination.complete();
      this.unsubscribeClosingNotification();
    };
    WindowSubscriber2.prototype.unsubscribeClosingNotification = function() {
      if (this.closingNotification) {
        this.closingNotification.unsubscribe();
      }
    };
    WindowSubscriber2.prototype.openWindow = function(innerSub) {
      if (innerSub === void 0) {
        innerSub = null;
      }
      if (innerSub) {
        this.remove(innerSub);
        innerSub.unsubscribe();
      }
      var prevWindow = this.window;
      if (prevWindow) {
        prevWindow.complete();
      }
      var window2 = this.window = new Subject();
      this.destination.next(window2);
      var closingNotifier;
      try {
        var closingSelector = this.closingSelector;
        closingNotifier = closingSelector();
      } catch (e) {
        this.destination.error(e);
        this.window.error(e);
        return;
      }
      this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
    };
    return WindowSubscriber2;
  }(OuterSubscriber);
  function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return function(source) {
      var project;
      if (typeof args[args.length - 1] === "function") {
        project = args.pop();
      }
      var observables = args;
      return source.lift(new WithLatestFromOperator(observables, project));
    };
  }
  var WithLatestFromOperator = /* @__PURE__ */ function() {
    function WithLatestFromOperator2(observables, project) {
      this.observables = observables;
      this.project = project;
    }
    WithLatestFromOperator2.prototype.call = function(subscriber, source) {
      return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator2;
  }();
  var WithLatestFromSubscriber = /* @__PURE__ */ function(_super) {
    __extends(WithLatestFromSubscriber2, _super);
    function WithLatestFromSubscriber2(destination, observables, project) {
      var _this = _super.call(this, destination) || this;
      _this.observables = observables;
      _this.project = project;
      _this.toRespond = [];
      var len2 = observables.length;
      _this.values = new Array(len2);
      for (var i2 = 0; i2 < len2; i2++) {
        _this.toRespond.push(i2);
      }
      for (var i2 = 0; i2 < len2; i2++) {
        var observable2 = observables[i2];
        _this.add(subscribeToResult(_this, observable2, void 0, i2));
      }
      return _this;
    }
    WithLatestFromSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
      this.values[outerIndex] = innerValue;
      var toRespond = this.toRespond;
      if (toRespond.length > 0) {
        var found = toRespond.indexOf(outerIndex);
        if (found !== -1) {
          toRespond.splice(found, 1);
        }
      }
    };
    WithLatestFromSubscriber2.prototype.notifyComplete = function() {
    };
    WithLatestFromSubscriber2.prototype._next = function(value2) {
      if (this.toRespond.length === 0) {
        var args = [value2].concat(this.values);
        if (this.project) {
          this._tryProject(args);
        } else {
          this.destination.next(args);
        }
      }
    };
    WithLatestFromSubscriber2.prototype._tryProject = function(args) {
      var result;
      try {
        result = this.project.apply(this, args);
      } catch (err) {
        this.destination.error(err);
        return;
      }
      this.destination.next(result);
    };
    return WithLatestFromSubscriber2;
  }(OuterSubscriber);
  function zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      observables[_i] = arguments[_i];
    }
    return function zipOperatorFunction(source) {
      return source.lift.call(zip$1.apply(void 0, [source].concat(observables)));
    };
  }
  function zipAll(project) {
    return function(source) {
      return source.lift(new ZipOperator(project));
    };
  }
  const operators = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    audit,
    auditTime,
    buffer,
    bufferCount,
    bufferTime,
    bufferToggle,
    bufferWhen,
    catchError,
    combineAll,
    combineLatest,
    concat,
    concatAll,
    concatMap,
    concatMapTo,
    count,
    debounce,
    debounceTime,
    defaultIfEmpty,
    delay,
    delayWhen,
    dematerialize,
    distinct,
    distinctUntilChanged,
    distinctUntilKeyChanged,
    elementAt,
    endWith,
    every,
    exhaust,
    exhaustMap,
    expand,
    filter: filter$1,
    finalize: finalize$1,
    find,
    findIndex,
    first,
    flatMap,
    groupBy,
    ignoreElements,
    isEmpty,
    last,
    map: map$2,
    mapTo,
    materialize,
    max,
    merge: merge$1,
    mergeAll,
    mergeMap,
    mergeMapTo,
    mergeScan,
    min,
    multicast,
    observeOn,
    onErrorResumeNext,
    pairwise,
    partition,
    pluck,
    publish,
    publishBehavior,
    publishLast,
    publishReplay,
    race,
    reduce,
    refCount,
    repeat,
    repeatWhen,
    retry,
    retryWhen,
    sample,
    sampleTime,
    scan,
    sequenceEqual,
    share,
    shareReplay,
    single,
    skip,
    skipLast,
    skipUntil,
    skipWhile,
    startWith,
    subscribeOn,
    switchAll,
    switchMap,
    switchMapTo,
    take,
    takeLast,
    takeUntil,
    takeWhile,
    tap,
    throttle,
    throttleTime,
    throwIfEmpty,
    timeInterval,
    timeout,
    timeoutWith,
    timestamp,
    toArray: toArray$1,
    window: window$1,
    windowCount,
    windowTime,
    windowToggle,
    windowWhen,
    withLatestFrom,
    zip,
    zipAll
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$1 = /* @__PURE__ */ getAugmentedNamespace(operators);
  var __createBinding$5 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o[k22] = m2[k2];
  });
  var __setModuleDefault$5 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar$5 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k2 in mod2)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
          __createBinding$5(result, mod2, k2);
    }
    __setModuleDefault$5(result, mod2);
    return result;
  };
  Object.defineProperty(utils$5, "__esModule", { value: true });
  utils$5.sortTxFields = utils$5.isIndexable = utils$5.compatibleBufferConcat = utils$5.checkBufferConcat = utils$5.untouchable = utils$5.mustBeDefined = utils$5.toArrayBuffer = utils$5.relativePath = utils$5.hardenedPath = utils$5.satsFromStr = utils$5.slip44ByCoin = utils$5.base64toHEX = utils$5.stripHexPrefixAndLower = utils$5.stripHexPrefix = utils$5.takeFirstOfManyEvents = utils$5.addressNListToBIP32 = utils$5.bip32ToAddressNList = utils$5.bip32Like = utils$5.arrayify = utils$5.toHexString = utils$5.fromHexString = utils$5.isArray = utils$5.LONG_TIMEOUT = utils$5.DEFAULT_TIMEOUT = void 0;
  const Rx = __importStar$5(require$$0$1);
  const RxOp = __importStar$5(require$$1);
  utils$5.DEFAULT_TIMEOUT = 5e3;
  utils$5.LONG_TIMEOUT = 5 * 60 * 1e3;
  utils$5.isArray = Array.isArray || function(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  };
  const fromHexString = (hexString) => {
    const match2 = hexString.match(/.{1,2}/g) || [];
    return new Uint8Array(match2.map((byte) => parseInt(byte, 16)));
  };
  utils$5.fromHexString = fromHexString;
  function toHexString(arr) {
    return Array.prototype.map.call(arr, (x2) => ("00" + x2.toString(16)).slice(-2)).join("");
  }
  utils$5.toHexString = toHexString;
  function arrayify$1(value2) {
    if (value2 === null) {
      throw new Error("cannot convert null value to array");
    } else if (typeof value2 !== "string") {
      throw new Error("can only convert hex strings");
    }
    const match2 = value2.match(/^(0x)?[0-9a-fA-F]*$/);
    if (!match2) {
      throw new Error("invalid hexadecimal string");
    }
    if (match2[1] !== "0x") {
      throw new Error("hex string must have 0x prefix");
    }
    value2 = value2.substring(2);
    if (value2.length % 2) {
      value2 = "0" + value2;
    }
    const result = [];
    for (let i2 = 0; i2 < value2.length; i2 += 2) {
      result.push(parseInt(value2.substr(i2, 2), 16));
    }
    return new Uint8Array(result);
  }
  utils$5.arrayify = arrayify$1;
  const HARDENED = 2147483648;
  function bip32Like(path2) {
    if (path2 == "m/")
      return true;
    return /^m(((\/[0-9]+h)+|(\/[0-9]+H)+|(\/[0-9]+')*)((\/[0-9]+)*))$/.test(path2);
  }
  utils$5.bip32Like = bip32Like;
  function bip32ToAddressNList$1(path2) {
    if (!bip32Like(path2)) {
      throw new Error(`Not a bip32 path: '${path2}'`);
    }
    if (/^m\//i.test(path2)) {
      path2 = path2.slice(2);
    }
    const segments = path2.split("/");
    if (segments.length === 1 && segments[0] === "")
      return [];
    const ret = new Array(segments.length);
    for (let i2 = 0; i2 < segments.length; i2++) {
      const tmp = /(\d+)([hH']?)/.exec(segments[i2]);
      if (tmp === null) {
        throw new Error("Invalid input");
      }
      ret[i2] = parseInt(tmp[1], 10);
      if (ret[i2] >= HARDENED) {
        throw new Error("Invalid child index");
      }
      if (tmp[2] === "h" || tmp[2] === "H" || tmp[2] === "'") {
        ret[i2] += HARDENED;
      } else if (tmp[2].length !== 0) {
        throw new Error("Invalid modifier");
      }
    }
    return ret;
  }
  utils$5.bip32ToAddressNList = bip32ToAddressNList$1;
  function addressNListToBIP32$1(address2) {
    return `m/${address2.map((num) => num >= HARDENED ? `${num - HARDENED}'` : num).join("/")}`;
  }
  utils$5.addressNListToBIP32 = addressNListToBIP32$1;
  function takeFirstOfManyEvents(eventEmitter2, events2) {
    return Rx.merge(...events2.map((event2) => Rx.fromEvent(eventEmitter2, event2))).pipe(RxOp.first());
  }
  utils$5.takeFirstOfManyEvents = takeFirstOfManyEvents;
  function stripHexPrefix(value2) {
    return value2.replace("0x", "");
  }
  utils$5.stripHexPrefix = stripHexPrefix;
  function stripHexPrefixAndLower(value2) {
    return stripHexPrefix(value2).toLowerCase();
  }
  utils$5.stripHexPrefixAndLower = stripHexPrefixAndLower;
  function base64toHEX(base64) {
    const raw = atob(base64);
    let HEX2 = "";
    for (let i2 = 0; i2 < raw.length; i2++) {
      const _hex = raw.charCodeAt(i2).toString(16);
      HEX2 += _hex.length == 2 ? _hex : "0" + _hex;
    }
    return "0x" + HEX2.toUpperCase();
  }
  utils$5.base64toHEX = base64toHEX;
  const slip44Table = Object.freeze({
    Bitcoin: 0,
    Testnet: 1,
    BitcoinCash: 145,
    BitcoinGold: 156,
    Litecoin: 2,
    Dash: 5,
    DigiByte: 20,
    Dogecoin: 3,
    BitcoinSV: 236,
    Atom: 118,
    Osmo: 118,
    Arkeo: 118,
    Binance: 714,
    Ripple: 144,
    Eos: 194,
    Fio: 235,
    Thorchain: 931,
    Rune: 931,
    Cardano: 1815,
    Secret: 529,
    Terra: 330,
    Kava: 459,
    // EVM chains all use the same SLIP44
    Ethereum: 60,
    Avalanche: 60,
    Optimism: 60,
    BnbSmartChain: 60,
    Polygon: 60,
    Gnosis: 60,
    Arbitrum: 60
  });
  function slip44ByCoin(coin) {
    return slip44Table[coin];
  }
  utils$5.slip44ByCoin = slip44ByCoin;
  function satsFromStr(coins2) {
    const index2 = coins2.indexOf(".");
    const exponent = index2 > 0 ? 8 - (coins2.length - index2 - 1) : 8;
    return Number(coins2.replace(/\./g, "")) * 10 ** exponent;
  }
  utils$5.satsFromStr = satsFromStr;
  function hardenedPath(path2) {
    return path2.filter((segment) => segment >= 2147483648);
  }
  utils$5.hardenedPath = hardenedPath;
  function relativePath(path2) {
    return path2.filter((segment) => segment < 2147483648);
  }
  utils$5.relativePath = relativePath;
  function toArrayBuffer(x2) {
    if (x2 instanceof ArrayBuffer)
      return x2;
    return x2.buffer.slice(x2.byteOffset, x2.byteOffset + x2.byteLength);
  }
  utils$5.toArrayBuffer = toArrayBuffer;
  function mustBeDefined(x2) {
    if (x2 === null || x2 === void 0)
      throw new Error("expected a value");
    return x2;
  }
  utils$5.mustBeDefined = mustBeDefined;
  function untouchable(message) {
    const out = new Proxy({}, new Proxy({}, {
      get(_, p2) {
        return (_2, p22) => {
          if (p2 === "get" && p22 === "valueOf")
            return () => out;
          throw new Error(`${String(p2)}(${String(p22)}): ${message}`);
        };
      }
    }));
    return out;
  }
  utils$5.untouchable = untouchable;
  let needCompatibleBufferConcat = void 0;
  function checkBufferConcat() {
    if (needCompatibleBufferConcat === void 0) {
      try {
        buffer$1.Buffer.concat([new Uint8Array()]);
        needCompatibleBufferConcat = false;
      } catch (_a3) {
        needCompatibleBufferConcat = true;
      }
    }
    return needCompatibleBufferConcat;
  }
  utils$5.checkBufferConcat = checkBufferConcat;
  function compatibleBufferConcat(list2) {
    if (!checkBufferConcat())
      return buffer$1.Buffer.concat(list2);
    return buffer$1.Buffer.concat(list2.map((x2) => buffer$1.Buffer.isBuffer(x2) ? x2 : buffer$1.Buffer.from(x2)));
  }
  utils$5.compatibleBufferConcat = compatibleBufferConcat;
  function isIndexable(x2) {
    return x2 !== null && ["object", "function"].includes(typeof x2);
  }
  utils$5.isIndexable = isIndexable;
  const strSorter = (a, b) => a > b ? 1 : a < b ? -1 : 0;
  const isObj = (obj) => "object" === typeof obj && null !== obj;
  const sortInPlaceObjectKeys = (obj) => {
    const sorted = Object.entries(obj).sort((a, b) => strSorter(a[0], b[0]));
    for (const [key] of sorted) {
      delete obj[key];
    }
    return Object.assign(obj, Object.fromEntries(sorted));
  };
  function sortTxFields(obj) {
    const stack = [], checked = /* @__PURE__ */ new WeakSet();
    if (isObj(obj)) {
      stack.push(obj);
      while (stack.length) {
        let o = stack.pop();
        checked.add(o);
        o = !Array.isArray(o) && sortInPlaceObjectKeys(o);
        for (const val of Object.values(o)) {
          isObj(val) && !checked.has(val) && stack.push(val);
        }
      }
    }
    return obj;
  }
  utils$5.sortTxFields = sortTxFields;
  Object.defineProperty(arkeo, "__esModule", { value: true });
  arkeo.arkeoDescribePath = void 0;
  const utils_1$a = utils$5;
  function arkeoDescribePath(path2) {
    const pathStr = (0, utils_1$a.addressNListToBIP32)(path2);
    const unknown = {
      verbose: pathStr,
      coin: "Arkeo",
      isKnown: false
    };
    if (path2.length != 5) {
      return unknown;
    }
    if (path2[0] != 2147483648 + 44) {
      return unknown;
    }
    if (path2[1] != 2147483648 + (0, utils_1$a.slip44ByCoin)("Arkeo")) {
      return unknown;
    }
    if ((path2[2] & 2147483648) >>> 0 !== 2147483648) {
      return unknown;
    }
    if (path2[3] !== 0 || path2[4] !== 0) {
      return unknown;
    }
    const index2 = path2[2] & 2147483647;
    return {
      verbose: `Arkeo Account #${index2}`,
      accountIdx: index2,
      wholeAccount: true,
      coin: "Arkeo",
      isKnown: true,
      isPrefork: false
    };
  }
  arkeo.arkeoDescribePath = arkeoDescribePath;
  var binance = {};
  Object.defineProperty(binance, "__esModule", { value: true });
  binance.binanceDescribePath = void 0;
  const utils_1$9 = utils$5;
  function binanceDescribePath(path2) {
    const pathStr = (0, utils_1$9.addressNListToBIP32)(path2);
    const unknown = {
      verbose: pathStr,
      coin: "Binance",
      isKnown: false
    };
    if (path2.length != 5) {
      return unknown;
    }
    if (path2[0] != 2147483648 + 44) {
      return unknown;
    }
    if (path2[1] != 2147483648 + (0, utils_1$9.slip44ByCoin)("Binance")) {
      return unknown;
    }
    if ((path2[2] & 2147483648) >>> 0 !== 2147483648) {
      return unknown;
    }
    if (path2[3] !== 0 || path2[4] !== 0) {
      return unknown;
    }
    const index2 = path2[2] & 2147483647;
    return {
      verbose: `Binance Account #${index2}`,
      accountIdx: index2,
      wholeAccount: true,
      coin: "Binance",
      isKnown: true,
      isPrefork: false
    };
  }
  binance.binanceDescribePath = binanceDescribePath;
  var bitcoin = {};
  var lib$2 = {};
  Object.defineProperty(lib$2, "__esModule", { value: true });
  function assert() {
    return true;
  }
  lib$2.assert = assert;
  var __createBinding$4 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o[k22] = m2[k2];
  });
  var __setModuleDefault$4 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar$4 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k2 in mod2)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
          __createBinding$4(result, mod2, k2);
    }
    __setModuleDefault$4(result, mod2);
    return result;
  };
  Object.defineProperty(bitcoin, "__esModule", { value: true });
  bitcoin.segwitNativeAccount = bitcoin.segwitAccount = bitcoin.legacyAccount = bitcoin.describeUTXOPath = bitcoin.unknownUTXOPath = bitcoin.BTCOutputAddressType = bitcoin.BTCOutputScriptType = bitcoin.BTCInputScriptType = void 0;
  const ta = __importStar$4(lib$2);
  const utils_1$8 = utils$5;
  ta.assert();
  var BTCInputScriptType;
  (function(BTCInputScriptType2) {
    BTCInputScriptType2["CashAddr"] = "cashaddr";
    BTCInputScriptType2["Bech32"] = "bech32";
    BTCInputScriptType2["SpendAddress"] = "p2pkh";
    BTCInputScriptType2["SpendMultisig"] = "p2sh";
    BTCInputScriptType2["External"] = "external";
    BTCInputScriptType2["SpendWitness"] = "p2wpkh";
    BTCInputScriptType2["SpendP2SHWitness"] = "p2sh-p2wpkh";
  })(BTCInputScriptType || (bitcoin.BTCInputScriptType = BTCInputScriptType = {}));
  var BTCOutputScriptType;
  (function(BTCOutputScriptType2) {
    BTCOutputScriptType2["PayToAddress"] = "p2pkh";
    BTCOutputScriptType2["PayToMultisig"] = "p2sh";
    BTCOutputScriptType2["Bech32"] = "bech32";
    BTCOutputScriptType2["PayToWitness"] = "p2wpkh";
    BTCOutputScriptType2["PayToP2SHWitness"] = "p2sh-p2wpkh";
  })(BTCOutputScriptType || (bitcoin.BTCOutputScriptType = BTCOutputScriptType = {}));
  var BTCOutputAddressType;
  (function(BTCOutputAddressType2) {
    BTCOutputAddressType2["Spend"] = "spend";
    BTCOutputAddressType2["Transfer"] = "transfer";
    BTCOutputAddressType2["Change"] = "change";
  })(BTCOutputAddressType || (bitcoin.BTCOutputAddressType = BTCOutputAddressType = {}));
  function unknownUTXOPath(path2, coin, scriptType) {
    return {
      verbose: (0, utils_1$8.addressNListToBIP32)(path2),
      coin,
      scriptType,
      isKnown: false
    };
  }
  bitcoin.unknownUTXOPath = unknownUTXOPath;
  function describeUTXOPath(path2, coin, scriptType) {
    const unknown = unknownUTXOPath(path2, coin, scriptType);
    if (path2.length !== 3 && path2.length !== 5)
      return unknown;
    if ((path2[0] & 2147483648) >>> 0 !== 2147483648)
      return unknown;
    const purpose = path2[0] & 2147483647;
    if (![44, 49, 84].includes(purpose))
      return unknown;
    if (purpose === 44 && scriptType !== BTCInputScriptType.SpendAddress)
      return unknown;
    if (purpose === 49 && scriptType !== BTCInputScriptType.SpendP2SHWitness)
      return unknown;
    const wholeAccount = path2.length === 3;
    const script = {
      [BTCInputScriptType.SpendAddress]: ["Legacy"],
      [BTCInputScriptType.SpendP2SHWitness]: [],
      [BTCInputScriptType.SpendWitness]: ["Segwit"],
      [BTCInputScriptType.Bech32]: ["Segwit Native"]
    }[scriptType];
    let isPrefork = false;
    const slip44 = (0, utils_1$8.slip44ByCoin)(coin);
    if (slip44 === void 0)
      return unknown;
    if (path2[1] !== 2147483648 + slip44) {
      switch (coin) {
        case "BitcoinCash":
        case "BitcoinGold": {
          if (path2[1] === 2147483648 + (0, utils_1$8.slip44ByCoin)("Bitcoin")) {
            isPrefork = true;
            break;
          }
          return unknown;
        }
        case "BitcoinSV": {
          if (path2[1] === 2147483648 + (0, utils_1$8.slip44ByCoin)("Bitcoin") || path2[1] === 2147483648 + (0, utils_1$8.slip44ByCoin)("BitcoinCash")) {
            isPrefork = true;
            break;
          }
          return unknown;
        }
        default:
          return unknown;
      }
    }
    let attributes = isPrefork ? ["Prefork"] : [];
    switch (coin) {
      case "Bitcoin":
      case "Litecoin":
      case "BitcoinGold":
      case "Testnet": {
        if (script)
          attributes = attributes.concat(script);
        break;
      }
    }
    const attr = attributes.length ? ` (${attributes.join(", ")})` : "";
    const accountIdx = path2[2] & 2147483647;
    if (wholeAccount) {
      return {
        coin,
        verbose: `${coin} Account #${accountIdx}${attr}`,
        accountIdx,
        wholeAccount: true,
        isKnown: true,
        scriptType,
        isPrefork
      };
    } else {
      const change = path2[3] === 1 ? "Change " : "";
      const addressIdx = path2[4];
      return {
        coin,
        verbose: `${coin} Account #${accountIdx}, ${change}Address #${addressIdx}${attr}`,
        accountIdx,
        addressIdx,
        wholeAccount: false,
        isKnown: true,
        isChange: path2[3] === 1,
        scriptType,
        isPrefork
      };
    }
  }
  bitcoin.describeUTXOPath = describeUTXOPath;
  function legacyAccount(coin, slip44, accountIdx) {
    return {
      coin,
      scriptType: BTCInputScriptType.SpendAddress,
      addressNList: [2147483648 + 44, 2147483648 + slip44, 2147483648 + accountIdx]
    };
  }
  bitcoin.legacyAccount = legacyAccount;
  function segwitAccount(coin, slip44, accountIdx) {
    return {
      coin,
      scriptType: BTCInputScriptType.SpendP2SHWitness,
      addressNList: [2147483648 + 49, 2147483648 + slip44, 2147483648 + accountIdx]
    };
  }
  bitcoin.segwitAccount = segwitAccount;
  function segwitNativeAccount(coin, slip44, accountIdx) {
    return {
      coin,
      scriptType: BTCInputScriptType.SpendWitness,
      addressNList: [2147483648 + 84, 2147483648 + slip44, 2147483648 + accountIdx]
    };
  }
  bitcoin.segwitNativeAccount = segwitNativeAccount;
  var cosmos = {};
  Object.defineProperty(cosmos, "__esModule", { value: true });
  cosmos.cosmosDescribePath = void 0;
  const utils_1$7 = utils$5;
  function cosmosDescribePath(path2) {
    const pathStr = (0, utils_1$7.addressNListToBIP32)(path2);
    const unknown = {
      verbose: pathStr,
      coin: "Atom",
      isKnown: false
    };
    if (path2.length != 5) {
      return unknown;
    }
    if (path2[0] != 2147483648 + 44) {
      return unknown;
    }
    if (path2[1] != 2147483648 + (0, utils_1$7.slip44ByCoin)("Atom")) {
      return unknown;
    }
    if ((path2[2] & 2147483648) >>> 0 !== 2147483648) {
      return unknown;
    }
    if (path2[3] !== 0 || path2[4] !== 0) {
      return unknown;
    }
    const index2 = path2[2] & 2147483647;
    return {
      verbose: `Cosmos Account #${index2}`,
      accountIdx: index2,
      wholeAccount: true,
      coin: "Atom",
      isKnown: true,
      isPrefork: false
    };
  }
  cosmos.cosmosDescribePath = cosmosDescribePath;
  var osmosis = {};
  Object.defineProperty(osmosis, "__esModule", { value: true });
  osmosis.osmosisDescribePath = void 0;
  const utils_1$6 = utils$5;
  function osmosisDescribePath(path2) {
    const pathStr = (0, utils_1$6.addressNListToBIP32)(path2);
    const unknown = {
      verbose: pathStr,
      coin: "Atom",
      isKnown: false
    };
    if (path2.length != 5) {
      return unknown;
    }
    if (path2[0] != 2147483648 + 44) {
      return unknown;
    }
    if (path2[1] != 2147483648 + (0, utils_1$6.slip44ByCoin)("Osmo")) {
      return unknown;
    }
    if ((path2[2] & 2147483648) >>> 0 !== 2147483648) {
      return unknown;
    }
    if (path2[3] !== 0 || path2[4] !== 0) {
      return unknown;
    }
    const index2 = path2[2] & 2147483647;
    return {
      verbose: `Osmosis Account #${index2}`,
      accountIdx: index2,
      wholeAccount: true,
      coin: "Osmo",
      isKnown: true,
      isPrefork: false
    };
  }
  osmosis.osmosisDescribePath = osmosisDescribePath;
  var debuglink = {};
  Object.defineProperty(debuglink, "__esModule", { value: true });
  var eos = {};
  Object.defineProperty(eos, "__esModule", { value: true });
  var ethereum = {};
  Object.defineProperty(ethereum, "__esModule", { value: true });
  ethereum.describeETHPath = ethereum.ETHTransactionType = void 0;
  const utils_1$5 = utils$5;
  var ETHTransactionType;
  (function(ETHTransactionType2) {
    ETHTransactionType2[ETHTransactionType2["ETH_TX_TYPE_LEGACY"] = 0] = "ETH_TX_TYPE_LEGACY";
    ETHTransactionType2[ETHTransactionType2["ETH_TX_TYPE_EIP_2930"] = 1] = "ETH_TX_TYPE_EIP_2930";
    ETHTransactionType2[ETHTransactionType2["ETH_TX_TYPE_EIP_1559"] = 2] = "ETH_TX_TYPE_EIP_1559";
  })(ETHTransactionType || (ethereum.ETHTransactionType = ETHTransactionType = {}));
  function describeETHPath(path2) {
    const pathStr = (0, utils_1$5.addressNListToBIP32)(path2);
    const unknown = {
      verbose: pathStr,
      coin: "Ethereum",
      isKnown: false
    };
    if (path2.length !== 5)
      return unknown;
    if (path2[0] !== 2147483648 + 44)
      return unknown;
    if (path2[1] !== 2147483648 + (0, utils_1$5.slip44ByCoin)("Ethereum"))
      return unknown;
    if ((path2[2] & 2147483648) >>> 0 !== 2147483648)
      return unknown;
    if (path2[3] !== 0)
      return unknown;
    if (path2[4] !== 0)
      return unknown;
    const index2 = path2[2] & 2147483647;
    return {
      verbose: `Ethereum Account #${index2}`,
      accountIdx: index2,
      wholeAccount: true,
      coin: "Ethereum",
      isKnown: true,
      isPrefork: false
    };
  }
  ethereum.describeETHPath = describeETHPath;
  var event = {};
  Object.defineProperty(event, "__esModule", { value: true });
  event.makeEvent = event.Events = void 0;
  var Events$2;
  (function(Events2) {
    Events2["BUTTON_REQUEST"] = "BUTTON_REQUEST";
    Events2["CANCEL"] = "CANCEL";
    Events2["CHARACTER_REQUEST"] = "CHARACTER_REQUEST";
    Events2["CONNECT"] = "CONNECT";
    Events2["DISCONNECT"] = "DISCONNECT";
    Events2["FAILURE"] = "FAILURE";
    Events2["PASSPHRASE_REQUEST"] = "PASSPHRASE_REQUEST";
    Events2["PIN_REQUEST"] = "PIN_REQUEST";
    Events2["SUCCESS"] = "SUCCESS";
    Events2["WORD_REQUEST"] = "WORD_REQUEST";
  })(Events$2 || (event.Events = Events$2 = {}));
  function makeEvent(e) {
    return Object.assign({ date: Date.now() }, e);
  }
  event.makeEvent = makeEvent;
  var exceptions = {};
  Object.defineProperty(exceptions, "__esModule", { value: true });
  exceptions.NavigateToDashboard = exceptions.WebUSBCouldNotPair = exceptions.WebHIDCouldNotPair = exceptions.WebUSBCouldNotInitialize = exceptions.WebHIDCouldNotInitialize = exceptions.WebUSBNotAvailable = exceptions.WebHIDNotAvailable = exceptions.FirmwareUpdateRequired = exceptions.WrongApp = exceptions.SelectApp = exceptions.ConflictingApp = exceptions.PopupClosedError = exceptions.DeviceLocked = exceptions.DisconnectedDeviceDuringOperation = exceptions.DeviceDisconnected = exceptions.ActionCancelled = exceptions.HDWalletError = exceptions.HDWalletErrorType = void 0;
  var HDWalletErrorType;
  (function(HDWalletErrorType2) {
    HDWalletErrorType2["ActionCancelled"] = "ActionCancelled";
    HDWalletErrorType2["DeviceDisconnected"] = "DeviceDisconnected";
    HDWalletErrorType2["DisconnectedDeviceDuringOperation"] = "DisconnectedDeviceDuringOperation";
    HDWalletErrorType2["DeviceLocked"] = "DeviceLocked";
    HDWalletErrorType2["PopupClosedError"] = "PopupClosedError";
    HDWalletErrorType2["ConflictingApp"] = "ConflictingApp";
    HDWalletErrorType2["SelectApp"] = "SelectApp";
    HDWalletErrorType2["WrongApp"] = "WrongApp";
    HDWalletErrorType2["FirmwareUpdateRequired"] = "FirmwareUpdateRequired";
    HDWalletErrorType2["WebHIDNotAvailable"] = "WebHIDNotAvailable";
    HDWalletErrorType2["WebHIDCouldNotInitialize"] = "WebHIDCouldNotInitialize";
    HDWalletErrorType2["WebHIDCouldNotPair"] = "WebHIDCouldNotPair";
    HDWalletErrorType2["WebUSBNotAvailable"] = "WebUSBNotAvailable";
    HDWalletErrorType2["WebUSBCouldNotInitialize"] = "WebUSBCouldNotInitialize";
    HDWalletErrorType2["WebUSBCouldNotPair"] = "WebUSBCouldNotPair";
    HDWalletErrorType2["NavigateToDashboard"] = "NavigateToDashboard";
  })(HDWalletErrorType || (exceptions.HDWalletErrorType = HDWalletErrorType = {}));
  class HDWalletError extends Error {
    constructor(message, type2) {
      super(message);
      this.name = type2;
      this.type = type2;
      this.message = message;
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error(message).stack;
      }
    }
  }
  exceptions.HDWalletError = HDWalletError;
  class ActionCancelled extends HDWalletError {
    constructor() {
      super("Action cancelled", HDWalletErrorType.ActionCancelled);
    }
  }
  exceptions.ActionCancelled = ActionCancelled;
  class DeviceDisconnected extends HDWalletError {
    constructor() {
      super("Device disconnected", HDWalletErrorType.DeviceDisconnected);
    }
  }
  exceptions.DeviceDisconnected = DeviceDisconnected;
  class DisconnectedDeviceDuringOperation extends HDWalletError {
    constructor() {
      super("Ledger device disconnected during operation", HDWalletErrorType.DisconnectedDeviceDuringOperation);
    }
  }
  exceptions.DisconnectedDeviceDuringOperation = DisconnectedDeviceDuringOperation;
  class DeviceLocked extends HDWalletError {
    constructor() {
      super("Device locked", HDWalletErrorType.DeviceLocked);
    }
  }
  exceptions.DeviceLocked = DeviceLocked;
  class PopupClosedError extends HDWalletError {
    constructor() {
      super("TrezorConnect popup closed", HDWalletErrorType.PopupClosedError);
    }
  }
  exceptions.PopupClosedError = PopupClosedError;
  class ConflictingApp extends HDWalletError {
    constructor(model) {
      super(`Conflicting Application: Another wallet is trying to connect with your ${model}.`, HDWalletErrorType.ConflictingApp);
      this.model = model;
    }
  }
  exceptions.ConflictingApp = ConflictingApp;
  class SelectApp extends HDWalletError {
    constructor(model, app) {
      super(`Please open the ${app} app on your ${model}.`, HDWalletErrorType.SelectApp);
    }
  }
  exceptions.SelectApp = SelectApp;
  class WrongApp extends HDWalletError {
    constructor(model, app) {
      super(`Wrong app open. Please open the ${app} app on your ${model} and try again.`, HDWalletErrorType.WrongApp);
    }
  }
  exceptions.WrongApp = WrongApp;
  class FirmwareUpdateRequired extends HDWalletError {
    constructor(model, minVer) {
      super(`Firmware ${minVer} or later is required to use your ${model} with this client. Please update your device.`, HDWalletErrorType.FirmwareUpdateRequired);
    }
  }
  exceptions.FirmwareUpdateRequired = FirmwareUpdateRequired;
  class WebHIDNotAvailable extends HDWalletError {
    constructor() {
      super(`WebHID is not available in this browser. We recommend trying Chrome.`, HDWalletErrorType.WebHIDNotAvailable);
    }
  }
  exceptions.WebHIDNotAvailable = WebHIDNotAvailable;
  class WebUSBNotAvailable extends HDWalletError {
    constructor() {
      super(`WebUSB is not available in this browser. We recommend trying Chrome.`, HDWalletErrorType.WebUSBNotAvailable);
    }
  }
  exceptions.WebUSBNotAvailable = WebUSBNotAvailable;
  class WebHIDCouldNotInitialize extends HDWalletError {
    constructor(model, message) {
      super(`Could not initialize ${model}: ${message}`, HDWalletErrorType.WebHIDCouldNotInitialize);
    }
  }
  exceptions.WebHIDCouldNotInitialize = WebHIDCouldNotInitialize;
  class WebUSBCouldNotInitialize extends HDWalletError {
    constructor(model, message) {
      super(`Could not initialize ${model}: ${message}`, HDWalletErrorType.WebUSBCouldNotInitialize);
    }
  }
  exceptions.WebUSBCouldNotInitialize = WebUSBCouldNotInitialize;
  class WebHIDCouldNotPair extends HDWalletError {
    constructor(model, message) {
      super(`Could not pair ${model}: ${message}`, HDWalletErrorType.WebHIDCouldNotPair);
    }
  }
  exceptions.WebHIDCouldNotPair = WebHIDCouldNotPair;
  class WebUSBCouldNotPair extends HDWalletError {
    constructor(model, message) {
      super(`Could not pair ${model}: ${message}`, HDWalletErrorType.WebUSBCouldNotPair);
    }
  }
  exceptions.WebUSBCouldNotPair = WebUSBCouldNotPair;
  class NavigateToDashboard extends HDWalletError {
    constructor(model) {
      super(`Please navigate to the dashboard of your ${model}.`, HDWalletErrorType.NavigateToDashboard);
    }
  }
  exceptions.NavigateToDashboard = NavigateToDashboard;
  var fio = {};
  Object.defineProperty(fio, "__esModule", { value: true });
  fio.fioDescribePath = fio.FioEncryptionContentType = fio.Fio = void 0;
  const utils_1$4 = utils$5;
  var Fio;
  (function(Fio2) {
    (function(ContentType) {
      ContentType["REQUEST"] = "new_funds_content";
      ContentType["OBT"] = "record_obt_data_content";
    })(Fio2.ContentType || (Fio2.ContentType = {}));
  })(Fio || (fio.Fio = Fio = {}));
  fio.FioEncryptionContentType = Fio.ContentType;
  function fioDescribePath(path2) {
    const pathStr = (0, utils_1$4.addressNListToBIP32)(path2);
    const unknown = {
      verbose: pathStr,
      coin: "Fio",
      isKnown: false
    };
    if (path2.length != 5) {
      return unknown;
    }
    if (path2[0] != 2147483648 + 44) {
      return unknown;
    }
    if (path2[1] != 2147483648 + (0, utils_1$4.slip44ByCoin)("Fio")) {
      return unknown;
    }
    if ((path2[2] & 2147483648) >>> 0 !== 2147483648) {
      return unknown;
    }
    if (path2[3] !== 0 || path2[4] !== 0) {
      return unknown;
    }
    const index2 = path2[2] & 2147483647;
    return {
      verbose: `Fio Account #${index2}`,
      accountIdx: index2,
      wholeAccount: true,
      coin: "Fio",
      isKnown: true,
      isPrefork: false
    };
  }
  fio.fioDescribePath = fioDescribePath;
  var kava = {};
  Object.defineProperty(kava, "__esModule", { value: true });
  kava.kavaDescribePath = void 0;
  const utils_1$3 = utils$5;
  function kavaDescribePath(path2) {
    const pathStr = (0, utils_1$3.addressNListToBIP32)(path2);
    const unknown = {
      verbose: pathStr,
      coin: "Kava",
      isKnown: false
    };
    if (path2.length != 5) {
      return unknown;
    }
    if (path2[0] != 2147483648 + 44) {
      return unknown;
    }
    if (path2[1] != 2147483648 + (0, utils_1$3.slip44ByCoin)("Kava")) {
      return unknown;
    }
    if ((path2[2] & 2147483648) >>> 0 !== 2147483648) {
      return unknown;
    }
    if (path2[3] !== 0 || path2[4] !== 0) {
      return unknown;
    }
    const index2 = path2[2] & 2147483647;
    return {
      verbose: `Kava Account #${index2}`,
      accountIdx: index2,
      wholeAccount: true,
      coin: "Kava",
      isKnown: true,
      isPrefork: false
    };
  }
  kava.kavaDescribePath = kavaDescribePath;
  var keyring = {};
  var eventemitter2$2 = { exports: {} };
  (function(module2, exports3) {
    !function(undefined$12) {
      var isArray2 = Array.isArray ? Array.isArray : function _isArray2(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
      var defaultMaxListeners = 10;
      function init2() {
        this._events = {};
        if (this._conf) {
          configure.call(this, this._conf);
        }
      }
      function configure(conf) {
        if (conf) {
          this._conf = conf;
          conf.delimiter && (this.delimiter = conf.delimiter);
          this._maxListeners = conf.maxListeners !== undefined$12 ? conf.maxListeners : defaultMaxListeners;
          conf.wildcard && (this.wildcard = conf.wildcard);
          conf.newListener && (this._newListener = conf.newListener);
          conf.removeListener && (this._removeListener = conf.removeListener);
          conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);
          if (this.wildcard) {
            this.listenerTree = {};
          }
        } else {
          this._maxListeners = defaultMaxListeners;
        }
      }
      function logPossibleMemoryLeak(count2, eventName) {
        var errorMsg = "(node) warning: possible EventEmitter memory leak detected. " + count2 + " listeners added. Use emitter.setMaxListeners() to increase limit.";
        if (this.verboseMemoryLeak) {
          errorMsg += " Event name: " + eventName + ".";
        }
        if (typeof process$2 !== "undefined" && process$2.emitWarning) {
          var e = new Error(errorMsg);
          e.name = "MaxListenersExceededWarning";
          e.emitter = this;
          e.count = count2;
          process$2.emitWarning(e);
        } else {
          console.error(errorMsg);
          if (console.trace) {
            console.trace();
          }
        }
      }
      function EventEmitter2(conf) {
        this._events = {};
        this._newListener = false;
        this._removeListener = false;
        this.verboseMemoryLeak = false;
        configure.call(this, conf);
      }
      EventEmitter2.EventEmitter2 = EventEmitter2;
      function searchListenerTree(handlers, type2, tree, i2) {
        if (!tree) {
          return [];
        }
        var listeners = [], leaf, len2, branch, xTree, xxTree, isolatedBranch, endReached, typeLength = type2.length, currentType = type2[i2], nextType = type2[i2 + 1];
        if (i2 === typeLength && tree._listeners) {
          if (typeof tree._listeners === "function") {
            handlers && handlers.push(tree._listeners);
            return [tree];
          } else {
            for (leaf = 0, len2 = tree._listeners.length; leaf < len2; leaf++) {
              handlers && handlers.push(tree._listeners[leaf]);
            }
            return [tree];
          }
        }
        if (currentType === "*" || currentType === "**" || tree[currentType]) {
          if (currentType === "*") {
            for (branch in tree) {
              if (branch !== "_listeners" && tree.hasOwnProperty(branch)) {
                listeners = listeners.concat(searchListenerTree(handlers, type2, tree[branch], i2 + 1));
              }
            }
            return listeners;
          } else if (currentType === "**") {
            endReached = i2 + 1 === typeLength || i2 + 2 === typeLength && nextType === "*";
            if (endReached && tree._listeners) {
              listeners = listeners.concat(searchListenerTree(handlers, type2, tree, typeLength));
            }
            for (branch in tree) {
              if (branch !== "_listeners" && tree.hasOwnProperty(branch)) {
                if (branch === "*" || branch === "**") {
                  if (tree[branch]._listeners && !endReached) {
                    listeners = listeners.concat(searchListenerTree(handlers, type2, tree[branch], typeLength));
                  }
                  listeners = listeners.concat(searchListenerTree(handlers, type2, tree[branch], i2));
                } else if (branch === nextType) {
                  listeners = listeners.concat(searchListenerTree(handlers, type2, tree[branch], i2 + 2));
                } else {
                  listeners = listeners.concat(searchListenerTree(handlers, type2, tree[branch], i2));
                }
              }
            }
            return listeners;
          }
          listeners = listeners.concat(searchListenerTree(handlers, type2, tree[currentType], i2 + 1));
        }
        xTree = tree["*"];
        if (xTree) {
          searchListenerTree(handlers, type2, xTree, i2 + 1);
        }
        xxTree = tree["**"];
        if (xxTree) {
          if (i2 < typeLength) {
            if (xxTree._listeners) {
              searchListenerTree(handlers, type2, xxTree, typeLength);
            }
            for (branch in xxTree) {
              if (branch !== "_listeners" && xxTree.hasOwnProperty(branch)) {
                if (branch === nextType) {
                  searchListenerTree(handlers, type2, xxTree[branch], i2 + 2);
                } else if (branch === currentType) {
                  searchListenerTree(handlers, type2, xxTree[branch], i2 + 1);
                } else {
                  isolatedBranch = {};
                  isolatedBranch[branch] = xxTree[branch];
                  searchListenerTree(handlers, type2, { "**": isolatedBranch }, i2 + 1);
                }
              }
            }
          } else if (xxTree._listeners) {
            searchListenerTree(handlers, type2, xxTree, typeLength);
          } else if (xxTree["*"] && xxTree["*"]._listeners) {
            searchListenerTree(handlers, type2, xxTree["*"], typeLength);
          }
        }
        return listeners;
      }
      function growListenerTree(type2, listener) {
        type2 = typeof type2 === "string" ? type2.split(this.delimiter) : type2.slice();
        for (var i2 = 0, len2 = type2.length; i2 + 1 < len2; i2++) {
          if (type2[i2] === "**" && type2[i2 + 1] === "**") {
            return;
          }
        }
        var tree = this.listenerTree;
        var name = type2.shift();
        while (name !== undefined$12) {
          if (!tree[name]) {
            tree[name] = {};
          }
          tree = tree[name];
          if (type2.length === 0) {
            if (!tree._listeners) {
              tree._listeners = listener;
            } else {
              if (typeof tree._listeners === "function") {
                tree._listeners = [tree._listeners];
              }
              tree._listeners.push(listener);
              if (!tree._listeners.warned && this._maxListeners > 0 && tree._listeners.length > this._maxListeners) {
                tree._listeners.warned = true;
                logPossibleMemoryLeak.call(this, tree._listeners.length, name);
              }
            }
            return true;
          }
          name = type2.shift();
        }
        return true;
      }
      EventEmitter2.prototype.delimiter = ".";
      EventEmitter2.prototype.setMaxListeners = function(n2) {
        if (n2 !== undefined$12) {
          this._maxListeners = n2;
          if (!this._conf)
            this._conf = {};
          this._conf.maxListeners = n2;
        }
      };
      EventEmitter2.prototype.event = "";
      EventEmitter2.prototype.once = function(event2, fn) {
        return this._once(event2, fn, false);
      };
      EventEmitter2.prototype.prependOnceListener = function(event2, fn) {
        return this._once(event2, fn, true);
      };
      EventEmitter2.prototype._once = function(event2, fn, prepend) {
        this._many(event2, 1, fn, prepend);
        return this;
      };
      EventEmitter2.prototype.many = function(event2, ttl, fn) {
        return this._many(event2, ttl, fn, false);
      };
      EventEmitter2.prototype.prependMany = function(event2, ttl, fn) {
        return this._many(event2, ttl, fn, true);
      };
      EventEmitter2.prototype._many = function(event2, ttl, fn, prepend) {
        var self2 = this;
        if (typeof fn !== "function") {
          throw new Error("many only accepts instances of Function");
        }
        function listener() {
          if (--ttl === 0) {
            self2.off(event2, listener);
          }
          return fn.apply(this, arguments);
        }
        listener._origin = fn;
        this._on(event2, listener, prepend);
        return self2;
      };
      EventEmitter2.prototype.emit = function() {
        this._events || init2.call(this);
        var type2 = arguments[0];
        if (type2 === "newListener" && !this._newListener) {
          if (!this._events.newListener) {
            return false;
          }
        }
        var al = arguments.length;
        var args, l2, i2, j;
        var handler;
        if (this._all && this._all.length) {
          handler = this._all.slice();
          if (al > 3) {
            args = new Array(al);
            for (j = 0; j < al; j++)
              args[j] = arguments[j];
          }
          for (i2 = 0, l2 = handler.length; i2 < l2; i2++) {
            this.event = type2;
            switch (al) {
              case 1:
                handler[i2].call(this, type2);
                break;
              case 2:
                handler[i2].call(this, type2, arguments[1]);
                break;
              case 3:
                handler[i2].call(this, type2, arguments[1], arguments[2]);
                break;
              default:
                handler[i2].apply(this, args);
            }
          }
        }
        if (this.wildcard) {
          handler = [];
          var ns = typeof type2 === "string" ? type2.split(this.delimiter) : type2.slice();
          searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
        } else {
          handler = this._events[type2];
          if (typeof handler === "function") {
            this.event = type2;
            switch (al) {
              case 1:
                handler.call(this);
                break;
              case 2:
                handler.call(this, arguments[1]);
                break;
              case 3:
                handler.call(this, arguments[1], arguments[2]);
                break;
              default:
                args = new Array(al - 1);
                for (j = 1; j < al; j++)
                  args[j - 1] = arguments[j];
                handler.apply(this, args);
            }
            return true;
          } else if (handler) {
            handler = handler.slice();
          }
        }
        if (handler && handler.length) {
          if (al > 3) {
            args = new Array(al - 1);
            for (j = 1; j < al; j++)
              args[j - 1] = arguments[j];
          }
          for (i2 = 0, l2 = handler.length; i2 < l2; i2++) {
            this.event = type2;
            switch (al) {
              case 1:
                handler[i2].call(this);
                break;
              case 2:
                handler[i2].call(this, arguments[1]);
                break;
              case 3:
                handler[i2].call(this, arguments[1], arguments[2]);
                break;
              default:
                handler[i2].apply(this, args);
            }
          }
          return true;
        } else if (!this._all && type2 === "error") {
          if (arguments[1] instanceof Error) {
            throw arguments[1];
          } else {
            throw new Error("Uncaught, unspecified 'error' event.");
          }
        }
        return !!this._all;
      };
      EventEmitter2.prototype.emitAsync = function() {
        this._events || init2.call(this);
        var type2 = arguments[0];
        if (type2 === "newListener" && !this._newListener) {
          if (!this._events.newListener) {
            return Promise.resolve([false]);
          }
        }
        var promises = [];
        var al = arguments.length;
        var args, l2, i2, j;
        var handler;
        if (this._all) {
          if (al > 3) {
            args = new Array(al);
            for (j = 1; j < al; j++)
              args[j] = arguments[j];
          }
          for (i2 = 0, l2 = this._all.length; i2 < l2; i2++) {
            this.event = type2;
            switch (al) {
              case 1:
                promises.push(this._all[i2].call(this, type2));
                break;
              case 2:
                promises.push(this._all[i2].call(this, type2, arguments[1]));
                break;
              case 3:
                promises.push(this._all[i2].call(this, type2, arguments[1], arguments[2]));
                break;
              default:
                promises.push(this._all[i2].apply(this, args));
            }
          }
        }
        if (this.wildcard) {
          handler = [];
          var ns = typeof type2 === "string" ? type2.split(this.delimiter) : type2.slice();
          searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
        } else {
          handler = this._events[type2];
        }
        if (typeof handler === "function") {
          this.event = type2;
          switch (al) {
            case 1:
              promises.push(handler.call(this));
              break;
            case 2:
              promises.push(handler.call(this, arguments[1]));
              break;
            case 3:
              promises.push(handler.call(this, arguments[1], arguments[2]));
              break;
            default:
              args = new Array(al - 1);
              for (j = 1; j < al; j++)
                args[j - 1] = arguments[j];
              promises.push(handler.apply(this, args));
          }
        } else if (handler && handler.length) {
          handler = handler.slice();
          if (al > 3) {
            args = new Array(al - 1);
            for (j = 1; j < al; j++)
              args[j - 1] = arguments[j];
          }
          for (i2 = 0, l2 = handler.length; i2 < l2; i2++) {
            this.event = type2;
            switch (al) {
              case 1:
                promises.push(handler[i2].call(this));
                break;
              case 2:
                promises.push(handler[i2].call(this, arguments[1]));
                break;
              case 3:
                promises.push(handler[i2].call(this, arguments[1], arguments[2]));
                break;
              default:
                promises.push(handler[i2].apply(this, args));
            }
          }
        } else if (!this._all && type2 === "error") {
          if (arguments[1] instanceof Error) {
            return Promise.reject(arguments[1]);
          } else {
            return Promise.reject("Uncaught, unspecified 'error' event.");
          }
        }
        return Promise.all(promises);
      };
      EventEmitter2.prototype.on = function(type2, listener) {
        return this._on(type2, listener, false);
      };
      EventEmitter2.prototype.prependListener = function(type2, listener) {
        return this._on(type2, listener, true);
      };
      EventEmitter2.prototype.onAny = function(fn) {
        return this._onAny(fn, false);
      };
      EventEmitter2.prototype.prependAny = function(fn) {
        return this._onAny(fn, true);
      };
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prototype._onAny = function(fn, prepend) {
        if (typeof fn !== "function") {
          throw new Error("onAny only accepts instances of Function");
        }
        if (!this._all) {
          this._all = [];
        }
        if (prepend) {
          this._all.unshift(fn);
        } else {
          this._all.push(fn);
        }
        return this;
      };
      EventEmitter2.prototype._on = function(type2, listener, prepend) {
        if (typeof type2 === "function") {
          this._onAny(type2, listener);
          return this;
        }
        if (typeof listener !== "function") {
          throw new Error("on only accepts instances of Function");
        }
        this._events || init2.call(this);
        if (this._newListener)
          this.emit("newListener", type2, listener);
        if (this.wildcard) {
          growListenerTree.call(this, type2, listener);
          return this;
        }
        if (!this._events[type2]) {
          this._events[type2] = listener;
        } else {
          if (typeof this._events[type2] === "function") {
            this._events[type2] = [this._events[type2]];
          }
          if (prepend) {
            this._events[type2].unshift(listener);
          } else {
            this._events[type2].push(listener);
          }
          if (!this._events[type2].warned && this._maxListeners > 0 && this._events[type2].length > this._maxListeners) {
            this._events[type2].warned = true;
            logPossibleMemoryLeak.call(this, this._events[type2].length, type2);
          }
        }
        return this;
      };
      EventEmitter2.prototype.off = function(type2, listener) {
        if (typeof listener !== "function") {
          throw new Error("removeListener only takes instances of Function");
        }
        var handlers, leafs = [];
        if (this.wildcard) {
          var ns = typeof type2 === "string" ? type2.split(this.delimiter) : type2.slice();
          leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
        } else {
          if (!this._events[type2])
            return this;
          handlers = this._events[type2];
          leafs.push({ _listeners: handlers });
        }
        for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
          var leaf = leafs[iLeaf];
          handlers = leaf._listeners;
          if (isArray2(handlers)) {
            var position2 = -1;
            for (var i2 = 0, length2 = handlers.length; i2 < length2; i2++) {
              if (handlers[i2] === listener || handlers[i2].listener && handlers[i2].listener === listener || handlers[i2]._origin && handlers[i2]._origin === listener) {
                position2 = i2;
                break;
              }
            }
            if (position2 < 0) {
              continue;
            }
            if (this.wildcard) {
              leaf._listeners.splice(position2, 1);
            } else {
              this._events[type2].splice(position2, 1);
            }
            if (handlers.length === 0) {
              if (this.wildcard) {
                delete leaf._listeners;
              } else {
                delete this._events[type2];
              }
            }
            if (this._removeListener)
              this.emit("removeListener", type2, listener);
            return this;
          } else if (handlers === listener || handlers.listener && handlers.listener === listener || handlers._origin && handlers._origin === listener) {
            if (this.wildcard) {
              delete leaf._listeners;
            } else {
              delete this._events[type2];
            }
            if (this._removeListener)
              this.emit("removeListener", type2, listener);
          }
        }
        function recursivelyGarbageCollect(root2) {
          if (root2 === undefined$12) {
            return;
          }
          var keys2 = Object.keys(root2);
          for (var i3 in keys2) {
            var key = keys2[i3];
            var obj = root2[key];
            if (obj instanceof Function || typeof obj !== "object" || obj === null)
              continue;
            if (Object.keys(obj).length > 0) {
              recursivelyGarbageCollect(root2[key]);
            }
            if (Object.keys(obj).length === 0) {
              delete root2[key];
            }
          }
        }
        recursivelyGarbageCollect(this.listenerTree);
        return this;
      };
      EventEmitter2.prototype.offAny = function(fn) {
        var i2 = 0, l2 = 0, fns;
        if (fn && this._all && this._all.length > 0) {
          fns = this._all;
          for (i2 = 0, l2 = fns.length; i2 < l2; i2++) {
            if (fn === fns[i2]) {
              fns.splice(i2, 1);
              if (this._removeListener)
                this.emit("removeListenerAny", fn);
              return this;
            }
          }
        } else {
          fns = this._all;
          if (this._removeListener) {
            for (i2 = 0, l2 = fns.length; i2 < l2; i2++)
              this.emit("removeListenerAny", fns[i2]);
          }
          this._all = [];
        }
        return this;
      };
      EventEmitter2.prototype.removeListener = EventEmitter2.prototype.off;
      EventEmitter2.prototype.removeAllListeners = function(type2) {
        if (type2 === undefined$12) {
          !this._events || init2.call(this);
          return this;
        }
        if (this.wildcard) {
          var ns = typeof type2 === "string" ? type2.split(this.delimiter) : type2.slice();
          var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
          for (var iLeaf = 0; iLeaf < leafs.length; iLeaf++) {
            var leaf = leafs[iLeaf];
            leaf._listeners = null;
          }
        } else if (this._events) {
          this._events[type2] = null;
        }
        return this;
      };
      EventEmitter2.prototype.listeners = function(type2) {
        if (this.wildcard) {
          var handlers = [];
          var ns = typeof type2 === "string" ? type2.split(this.delimiter) : type2.slice();
          searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
          return handlers;
        }
        this._events || init2.call(this);
        if (!this._events[type2])
          this._events[type2] = [];
        if (!isArray2(this._events[type2])) {
          this._events[type2] = [this._events[type2]];
        }
        return this._events[type2];
      };
      EventEmitter2.prototype.eventNames = function() {
        return Object.keys(this._events);
      };
      EventEmitter2.prototype.listenerCount = function(type2) {
        return this.listeners(type2).length;
      };
      EventEmitter2.prototype.listenersAny = function() {
        if (this._all) {
          return this._all;
        } else {
          return [];
        }
      };
      if (typeof undefined$12 === "function" && undefined$12.amd) {
        undefined$12(function() {
          return EventEmitter2;
        });
      } else {
        module2.exports = EventEmitter2;
      }
    }();
  })(eventemitter2$2);
  var eventemitter2Exports = eventemitter2$2.exports;
  var __createBinding$3 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o[k22] = m2[k2];
  });
  var __setModuleDefault$3 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar$3 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k2 in mod2)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
          __createBinding$3(result, mod2, k2);
    }
    __setModuleDefault$3(result, mod2);
    return result;
  };
  var __awaiter$2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve2) {
        resolve2(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve2, reject2) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject2(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject2(e);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(keyring, "__esModule", { value: true });
  keyring.Keyring = void 0;
  const eventemitter2$1 = __importStar$3(eventemitter2Exports);
  class Keyring extends eventemitter2$1.EventEmitter2 {
    constructor() {
      super({ wildcard: true });
      this.wallets = {};
      this.aliases = {};
    }
    add(wallet2, deviceID) {
      const id2 = deviceID || (/* @__PURE__ */ new Date()).toString();
      if (!this.wallets[id2]) {
        this.wallets[id2] = wallet2;
        wallet2.transport && this.decorateEvents(id2, wallet2.transport);
        return true;
      }
      return false;
    }
    addAlias(aliasee, alias) {
      this.aliases[alias] = aliasee;
    }
    getAlias(aliasee) {
      const keys2 = Object.keys(this.aliases);
      const values2 = Object.values(this.aliases);
      const index2 = values2.indexOf(aliasee);
      if (index2 !== -1)
        return keys2[index2];
      return aliasee;
    }
    exec(method, ...args) {
      return __awaiter$2(this, void 0, void 0, function* () {
        return Promise.all(Object.values(this.wallets).map((w) => {
          const fn = w[method];
          if (typeof fn !== "function")
            throw new Error(`can't exec non-existent method ${method}`);
          return fn.call(w, ...args);
        })).then((values2) => values2.reduce((final, response, i2) => {
          final[Object.keys(this.wallets)[i2]] = response;
          return final;
        }, {}));
      });
    }
    get(deviceID) {
      if (deviceID && this.aliases[deviceID] && this.wallets[this.aliases[deviceID]])
        return this.wallets[this.aliases[deviceID]];
      if (deviceID && this.wallets[deviceID])
        return this.wallets[deviceID];
      if (!!Object.keys(this.wallets).length && !deviceID)
        return Object.values(this.wallets)[0];
      return null;
    }
    remove(deviceID) {
      return __awaiter$2(this, void 0, void 0, function* () {
        const wallet2 = this.get(deviceID);
        if (!wallet2)
          return;
        try {
          yield wallet2.disconnect();
        } catch (e) {
          console.error(e);
        } finally {
          const aliasee = this.aliases[deviceID];
          if (aliasee) {
            delete this.aliases[deviceID];
            delete this.wallets[aliasee];
          } else {
            delete this.wallets[deviceID];
          }
        }
      });
    }
    removeAll() {
      return __awaiter$2(this, void 0, void 0, function* () {
        yield Promise.all(Object.keys(this.wallets).map(this.remove.bind(this)));
        this.aliases = {};
      });
    }
    disconnectAll() {
      return __awaiter$2(this, void 0, void 0, function* () {
        const wallets = Object.values(this.wallets);
        for (let i2 = 0; i2 < wallets.length; i2++) {
          yield wallets[i2].disconnect();
        }
      });
    }
    decorateEvents(deviceID, events2) {
      const wallet2 = this.get(deviceID);
      if (!wallet2)
        return;
      const vendor = wallet2.getVendor();
      events2.onAny((e, ...values2) => this.emit([vendor, deviceID, typeof e === "string" ? e : e.join(";")], [deviceID, ...values2]));
    }
  }
  keyring.Keyring = Keyring;
  var ripple = {};
  Object.defineProperty(ripple, "__esModule", { value: true });
  var secret = {};
  Object.defineProperty(secret, "__esModule", { value: true });
  secret.secretDescribePath = void 0;
  const utils_1$2 = utils$5;
  function secretDescribePath(path2) {
    const pathStr = (0, utils_1$2.addressNListToBIP32)(path2);
    const unknown = {
      verbose: pathStr,
      coin: "Secret",
      isKnown: false
    };
    if (path2.length != 5) {
      return unknown;
    }
    if (path2[0] != 2147483648 + 44) {
      return unknown;
    }
    if (path2[1] != 2147483648 + (0, utils_1$2.slip44ByCoin)("Secret")) {
      return unknown;
    }
    if ((path2[2] & 2147483648) >>> 0 !== 2147483648) {
      return unknown;
    }
    if (path2[3] !== 0 || path2[4] !== 0) {
      return unknown;
    }
    const index2 = path2[2] & 2147483647;
    return {
      verbose: `Secret Account #${index2}`,
      accountIdx: index2,
      wholeAccount: true,
      coin: "Secret",
      isKnown: true,
      isPrefork: false
    };
  }
  secret.secretDescribePath = secretDescribePath;
  var terra = {};
  Object.defineProperty(terra, "__esModule", { value: true });
  terra.terraDescribePath = void 0;
  const utils_1$1 = utils$5;
  function terraDescribePath(path2) {
    const pathStr = (0, utils_1$1.addressNListToBIP32)(path2);
    const unknown = {
      verbose: pathStr,
      coin: "Terra",
      isKnown: false
    };
    if (path2.length != 5) {
      return unknown;
    }
    if (path2[0] != 2147483648 + 44) {
      return unknown;
    }
    if (path2[1] != 2147483648 + (0, utils_1$1.slip44ByCoin)("Terra")) {
      return unknown;
    }
    if ((path2[2] & 2147483648) >>> 0 !== 2147483648) {
      return unknown;
    }
    if (path2[3] !== 0 || path2[4] !== 0) {
      return unknown;
    }
    const index2 = path2[2] & 2147483647;
    return {
      verbose: `Terra Account #${index2}`,
      accountIdx: index2,
      wholeAccount: true,
      coin: "Terra",
      isKnown: true,
      isPrefork: false
    };
  }
  terra.terraDescribePath = terraDescribePath;
  var thorchain = {};
  Object.defineProperty(thorchain, "__esModule", { value: true });
  thorchain.thorchainDescribePath = void 0;
  const utils_1 = utils$5;
  function thorchainDescribePath(path2) {
    const pathStr = (0, utils_1.addressNListToBIP32)(path2);
    const unknown = {
      verbose: pathStr,
      coin: "Rune",
      isKnown: false
    };
    if (path2.length != 5) {
      return unknown;
    }
    if (path2[0] != 2147483648 + 44) {
      return unknown;
    }
    if (path2[1] != 2147483648 + (0, utils_1.slip44ByCoin)("Rune")) {
      return unknown;
    }
    if ((path2[2] & 2147483648) >>> 0 !== 2147483648) {
      return unknown;
    }
    if (path2[3] !== 0 || path2[4] !== 0) {
      return unknown;
    }
    const index2 = path2[2] & 2147483647;
    return {
      verbose: `Thorchain Account #${index2}`,
      accountIdx: index2,
      wholeAccount: true,
      coin: "Thorchain",
      isKnown: true,
      isPrefork: false
    };
  }
  thorchain.thorchainDescribePath = thorchainDescribePath;
  var transport$1 = {};
  var __createBinding$2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o[k22] = m2[k2];
  });
  var __setModuleDefault$2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar$2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k2 in mod2)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
          __createBinding$2(result, mod2, k2);
    }
    __setModuleDefault$2(result, mod2);
    return result;
  };
  var __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve2) {
        resolve2(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve2, reject2) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject2(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject2(e);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(transport$1, "__esModule", { value: true });
  transport$1.Transport = void 0;
  const eventemitter2 = __importStar$2(eventemitter2Exports);
  let Transport$1 = class Transport extends eventemitter2.EventEmitter2 {
    constructor(keyring2) {
      super();
      this.keyring = keyring2;
    }
    /**
     * Optional method to bootstrap connection to device
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    connect() {
      return __awaiter$1(this, void 0, void 0, function* () {
      });
    }
    /**
     * Optional function that gets called to clean up connection to device
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    disconnect() {
      return __awaiter$1(this, void 0, void 0, function* () {
      });
    }
  };
  transport$1.Transport = Transport$1;
  var wallet = {};
  var __importDefault$a = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(wallet, "__esModule", { value: true });
  wallet.supportsDebugLink = wallet.infoBinance = wallet.supportsBinance = wallet.infoRipple = wallet.supportsRipple = wallet.infoKava = wallet.supportsKava = wallet.infoTerra = wallet.supportsTerra = wallet.infoSecret = wallet.supportsSecret = wallet.infoFio = wallet.supportsFio = wallet.infoEos = wallet.supportsEos = wallet.infoThorchain = wallet.supportsThorchain = wallet.infoArkeo = wallet.supportsArkeo = wallet.infoOsmosis = wallet.supportsOsmosis = wallet.infoCosmos = wallet.supportsArbitrum = wallet.supportsGnosis = wallet.supportsPolygon = wallet.supportsBSC = wallet.supportsOptimism = wallet.supportsAvalanche = wallet.supportsEthSwitchChain = wallet.supportsCosmos = wallet.infoETH = wallet.supportsETH = wallet.infoBTC = wallet.supportsBTC = void 0;
  const isObject_1 = __importDefault$a(isObject_1$1);
  function supportsBTC(wallet2) {
    return (0, isObject_1.default)(wallet2) && wallet2._supportsBTC;
  }
  wallet.supportsBTC = supportsBTC;
  function infoBTC(info) {
    return (0, isObject_1.default)(info) && info._supportsBTCInfo;
  }
  wallet.infoBTC = infoBTC;
  function supportsETH(wallet2) {
    return (0, isObject_1.default)(wallet2) && wallet2._supportsETH;
  }
  wallet.supportsETH = supportsETH;
  function infoETH(info) {
    return (0, isObject_1.default)(info) && info._supportsETHInfo;
  }
  wallet.infoETH = infoETH;
  function supportsCosmos(wallet2) {
    return (0, isObject_1.default)(wallet2) && wallet2._supportsCosmos;
  }
  wallet.supportsCosmos = supportsCosmos;
  function supportsEthSwitchChain(wallet2) {
    return (0, isObject_1.default)(wallet2) && wallet2._supportsEthSwitchChain;
  }
  wallet.supportsEthSwitchChain = supportsEthSwitchChain;
  function supportsAvalanche(wallet2) {
    return (0, isObject_1.default)(wallet2) && wallet2._supportsAvalanche;
  }
  wallet.supportsAvalanche = supportsAvalanche;
  function supportsOptimism(wallet2) {
    return (0, isObject_1.default)(wallet2) && wallet2._supportsOptimism;
  }
  wallet.supportsOptimism = supportsOptimism;
  function supportsBSC(wallet2) {
    return (0, isObject_1.default)(wallet2) && wallet2._supportsBSC;
  }
  wallet.supportsBSC = supportsBSC;
  function supportsPolygon(wallet2) {
    return (0, isObject_1.default)(wallet2) && wallet2._supportsPolygon;
  }
  wallet.supportsPolygon = supportsPolygon;
  function supportsGnosis(wallet2) {
    return (0, isObject_1.default)(wallet2) && wallet2._supportsGnosis;
  }
  wallet.supportsGnosis = supportsGnosis;
  function supportsArbitrum(wallet2) {
    return (0, isObject_1.default)(wallet2) && wallet2._supportsArbitrum;
  }
  wallet.supportsArbitrum = supportsArbitrum;
  function infoCosmos(info) {
    return (0, isObject_1.default)(info) && info._supportsCosmosInfo;
  }
  wallet.infoCosmos = infoCosmos;
  function supportsOsmosis(wallet2) {
    return (0, isObject_1.default)(wallet2) && wallet2._supportsOsmosis;
  }
  wallet.supportsOsmosis = supportsOsmosis;
  function infoOsmosis(info) {
    return (0, isObject_1.default)(info) && info._supportsOsmosisInfo;
  }
  wallet.infoOsmosis = infoOsmosis;
  function supportsArkeo(wallet2) {
    return (0, isObject_1.default)(wallet2) && wallet2._supportsArkeo;
  }
  wallet.supportsArkeo = supportsArkeo;
  function infoArkeo(info) {
    return (0, isObject_1.default)(info) && info._supportsArkeoInfo;
  }
  wallet.infoArkeo = infoArkeo;
  function supportsThorchain(wallet2) {
    return (0, isObject_1.default)(wallet2) && wallet2._supportsThorchain;
  }
  wallet.supportsThorchain = supportsThorchain;
  function infoThorchain(info) {
    return (0, isObject_1.default)(info) && info._supportsThorchainInfo;
  }
  wallet.infoThorchain = infoThorchain;
  function supportsEos(wallet2) {
    return (0, isObject_1.default)(wallet2) && wallet2._supportsEos;
  }
  wallet.supportsEos = supportsEos;
  function infoEos(info) {
    return (0, isObject_1.default)(info) && info._supportsEosInfo;
  }
  wallet.infoEos = infoEos;
  function supportsFio(wallet2) {
    return (0, isObject_1.default)(wallet2) && wallet2._supportsFio;
  }
  wallet.supportsFio = supportsFio;
  function infoFio(info) {
    return (0, isObject_1.default)(info) && info._supportsFioInfo;
  }
  wallet.infoFio = infoFio;
  function supportsSecret(wallet2) {
    return (0, isObject_1.default)(wallet2) && wallet2._supportsSecret;
  }
  wallet.supportsSecret = supportsSecret;
  function infoSecret(info) {
    return (0, isObject_1.default)(info) && info._supportsSecretInfo;
  }
  wallet.infoSecret = infoSecret;
  function supportsTerra(wallet2) {
    return (0, isObject_1.default)(wallet2) && wallet2._supportsTerra;
  }
  wallet.supportsTerra = supportsTerra;
  function infoTerra(info) {
    return (0, isObject_1.default)(info) && info._supportsTerraInfo;
  }
  wallet.infoTerra = infoTerra;
  function supportsKava(wallet2) {
    return (0, isObject_1.default)(wallet2) && wallet2._supportsKava;
  }
  wallet.supportsKava = supportsKava;
  function infoKava(info) {
    return (0, isObject_1.default)(info) && info._supportsKavaInfo;
  }
  wallet.infoKava = infoKava;
  function supportsRipple(wallet2) {
    return (0, isObject_1.default)(wallet2) && wallet2._supportsRipple;
  }
  wallet.supportsRipple = supportsRipple;
  function infoRipple(info) {
    return (0, isObject_1.default)(info) && info._supportsRippleInfo;
  }
  wallet.infoRipple = infoRipple;
  function supportsBinance(wallet2) {
    return (0, isObject_1.default)(wallet2) && wallet2._supportsBinance;
  }
  wallet.supportsBinance = supportsBinance;
  function infoBinance(info) {
    return (0, isObject_1.default)(info) && info._supportsBinanceInfo;
  }
  wallet.infoBinance = infoBinance;
  function supportsDebugLink(wallet2) {
    return (0, isObject_1.default)(wallet2) && wallet2._supportsDebugLink;
  }
  wallet.supportsDebugLink = supportsDebugLink;
  (function(exports3) {
    var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o[k22] = m2[k2];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports4) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports4, p2))
          __createBinding2(exports4, m2, p2);
    };
    Object.defineProperty(exports3, "__esModule", { value: true });
    __exportStar(arkeo, exports3);
    __exportStar(binance, exports3);
    __exportStar(bitcoin, exports3);
    __exportStar(cosmos, exports3);
    __exportStar(osmosis, exports3);
    __exportStar(debuglink, exports3);
    __exportStar(eos, exports3);
    __exportStar(ethereum, exports3);
    __exportStar(event, exports3);
    __exportStar(exceptions, exports3);
    __exportStar(fio, exports3);
    __exportStar(kava, exports3);
    __exportStar(keyring, exports3);
    __exportStar(ripple, exports3);
    __exportStar(secret, exports3);
    __exportStar(terra, exports3);
    __exportStar(thorchain, exports3);
    __exportStar(transport$1, exports3);
    __exportStar(utils$5, exports3);
    __exportStar(wallet, exports3);
  })(dist);
  var TX_EMPTY_SIZE = 4 + 1 + 1 + 4;
  var TX_INPUT_BASE = 32 + 4 + 1 + 4;
  var TX_INPUT_PUBKEYHASH = 107;
  var TX_OUTPUT_BASE = 8 + 1;
  var TX_OUTPUT_PUBKEYHASH = 25;
  function inputBytes(input) {
    return TX_INPUT_BASE + (input.script ? input.script.length : TX_INPUT_PUBKEYHASH);
  }
  function outputBytes(output2) {
    return TX_OUTPUT_BASE + (output2.script ? output2.script.length : TX_OUTPUT_PUBKEYHASH);
  }
  function dustThreshold(output2, feeRate) {
    return inputBytes({}) * feeRate;
  }
  function transactionBytes(inputs, outputs) {
    return TX_EMPTY_SIZE + inputs.reduce(function(a, x2) {
      return a + inputBytes(x2);
    }, 0) + outputs.reduce(function(a, x2) {
      return a + outputBytes(x2);
    }, 0);
  }
  function uintOrNaN(v) {
    if (typeof v !== "number")
      return NaN;
    if (!isFinite(v))
      return NaN;
    if (Math.floor(v) !== v)
      return NaN;
    if (v < 0)
      return NaN;
    return v;
  }
  function sumForgiving(range2) {
    return range2.reduce(function(a, x2) {
      return a + (isFinite(x2.value) ? x2.value : 0);
    }, 0);
  }
  function sumOrNaN(range2) {
    return range2.reduce(function(a, x2) {
      return a + uintOrNaN(x2.value);
    }, 0);
  }
  var BLANK_OUTPUT = outputBytes({});
  function finalize(inputs, outputs, feeRate) {
    var bytesAccum = transactionBytes(inputs, outputs);
    var feeAfterExtraOutput = feeRate * (bytesAccum + BLANK_OUTPUT);
    var remainderAfterExtraOutput = sumOrNaN(inputs) - (sumOrNaN(outputs) + feeAfterExtraOutput);
    if (remainderAfterExtraOutput > dustThreshold({}, feeRate)) {
      outputs = outputs.concat({ value: remainderAfterExtraOutput });
    }
    var fee = sumOrNaN(inputs) - sumOrNaN(outputs);
    if (!isFinite(fee))
      return { fee: feeRate * bytesAccum };
    return {
      inputs,
      outputs,
      fee
    };
  }
  var utils$4 = {
    dustThreshold,
    finalize,
    inputBytes,
    outputBytes,
    sumOrNaN,
    sumForgiving,
    transactionBytes,
    uintOrNaN
  };
  var utils$3 = utils$4;
  var split = function split2(utxos, outputs, feeRate) {
    if (!isFinite(utils$3.uintOrNaN(feeRate)))
      return {};
    var bytesAccum = utils$3.transactionBytes(utxos, outputs);
    var fee = feeRate * bytesAccum;
    if (outputs.length === 0)
      return { fee };
    var inAccum = utils$3.sumOrNaN(utxos);
    var outAccum = utils$3.sumForgiving(outputs);
    var remaining = inAccum - outAccum - fee;
    if (!isFinite(remaining) || remaining < 0)
      return { fee };
    var unspecified = outputs.reduce(function(a, x2) {
      return a + !isFinite(x2.value);
    }, 0);
    if (remaining === 0 && unspecified === 0)
      return utils$3.finalize(utxos, outputs, feeRate);
    var splitOutputsCount = outputs.reduce(function(a, x2) {
      if (x2.value !== void 0)
        return a;
      return a + 1;
    }, 0);
    var splitValue = Math.floor(remaining / splitOutputsCount);
    if (!outputs.every(function(x2) {
      return x2.value !== void 0 || splitValue > utils$3.dustThreshold(x2, feeRate);
    }))
      return { fee };
    outputs = outputs.map(function(x2) {
      if (x2.value !== void 0)
        return x2;
      var y = {};
      for (var k2 in x2)
        y[k2] = x2[k2];
      y.value = splitValue;
      return y;
    });
    return utils$3.finalize(utxos, outputs, feeRate);
  };
  var utils$2 = utils$4;
  var accumulative$1 = function accumulative2(utxos, outputs, feeRate) {
    if (!isFinite(utils$2.uintOrNaN(feeRate)))
      return {};
    var bytesAccum = utils$2.transactionBytes([], outputs);
    var inAccum = 0;
    var inputs = [];
    var outAccum = utils$2.sumOrNaN(outputs);
    for (var i2 = 0; i2 < utxos.length; ++i2) {
      var utxo = utxos[i2];
      var utxoBytes = utils$2.inputBytes(utxo);
      var utxoFee = feeRate * utxoBytes;
      var utxoValue = utils$2.uintOrNaN(utxo.value);
      if (utxoFee > utxo.value) {
        if (i2 === utxos.length - 1)
          return { fee: feeRate * (bytesAccum + utxoBytes) };
        continue;
      }
      bytesAccum += utxoBytes;
      inAccum += utxoValue;
      inputs.push(utxo);
      var fee = feeRate * bytesAccum;
      if (inAccum < outAccum + fee)
        continue;
      return utils$2.finalize(inputs, outputs, feeRate);
    }
    return { fee: feeRate * bytesAccum };
  };
  var utils$1 = utils$4;
  var blackjack$1 = function blackjack2(utxos, outputs, feeRate) {
    if (!isFinite(utils$1.uintOrNaN(feeRate)))
      return {};
    var bytesAccum = utils$1.transactionBytes([], outputs);
    var inAccum = 0;
    var inputs = [];
    var outAccum = utils$1.sumOrNaN(outputs);
    var threshold = utils$1.dustThreshold({}, feeRate);
    for (var i2 = 0; i2 < utxos.length; ++i2) {
      var input = utxos[i2];
      var inputBytes2 = utils$1.inputBytes(input);
      var fee = feeRate * (bytesAccum + inputBytes2);
      var inputValue = utils$1.uintOrNaN(input.value);
      if (inAccum + inputValue > outAccum + fee + threshold)
        continue;
      bytesAccum += inputBytes2;
      inAccum += inputValue;
      inputs.push(input);
      if (inAccum < outAccum + fee)
        continue;
      return utils$1.finalize(inputs, outputs, feeRate);
    }
    return { fee: feeRate * bytesAccum };
  };
  var accumulative = accumulative$1;
  var blackjack = blackjack$1;
  var utils = utils$4;
  function utxoScore(x2, feeRate) {
    return x2.value - feeRate * utils.inputBytes(x2);
  }
  var coinselect = function coinSelect2(utxos, outputs, feeRate) {
    utxos = utxos.concat().sort(function(a, b) {
      return utxoScore(b, feeRate) - utxoScore(a, feeRate);
    });
    var base2 = blackjack(utxos, outputs, feeRate);
    if (base2.inputs)
      return base2;
    return accumulative(utxos, outputs, feeRate);
  };
  var bn = { exports: {} };
  bn.exports;
  (function(module2) {
    (function(module3, exports3) {
      function assert2(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number2, base2, endian) {
        if (BN2.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base2 === "le" || base2 === "be") {
            endian = base2;
            base2 = 10;
          }
          this._init(number2 || 0, base2 || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN2;
      } else {
        exports3.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require$$0$3.Buffer;
        }
      } catch (e) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max2(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min2(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init2(number2, base2, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base2, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base2, endian);
        }
        if (base2 === "hex") {
          base2 = 16;
        }
        assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number2.length) {
          if (base2 === 16) {
            this._parseHex(number2, start, endian);
          } else {
            this._parseBase(number2, base2, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base2, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number2, base2, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base2, endian);
      };
      BN2.prototype._initArray = function _initArray(number2, base2, endian) {
        assert2(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i2 = number2.length - 1, j = 0; i2 >= 0; i2 -= 3) {
            w = number2[i2] | number2[i2 - 1] << 8 | number2[i2 - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i2 = 0, j = 0; i2 < number2.length; i2 += 3) {
            w = number2[i2] | number2[i2 + 1] << 8 | number2[i2 + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string, index2) {
        var c = string.charCodeAt(index2);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert2(false, "Invalid character in " + string);
        }
      }
      function parseHexByte(string, lowerBound, index2) {
        var r = parseHex4Bits(string, index2);
        if (index2 - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index2 - 1) << 4;
        }
        return r;
      }
      BN2.prototype._parseHex = function _parseHex(number2, start, endian) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i2 = number2.length - 1; i2 >= start; i2 -= 2) {
            w = parseHexByte(number2, start, i2) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number2.length - start;
          for (i2 = parseLength % 2 === 0 ? start + 1 : start; i2 < number2.length; i2 += 2) {
            w = parseHexByte(number2, start, i2) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str2, start, end, mul) {
        var r = 0;
        var b = 0;
        var len2 = Math.min(str2.length, end);
        for (var i2 = start; i2 < len2; i2++) {
          var c = str2.charCodeAt(i2) - 48;
          r *= mul;
          if (c >= 49) {
            b = c - 49 + 10;
          } else if (c >= 17) {
            b = c - 17 + 10;
          } else {
            b = c;
          }
          assert2(c >= 0 && b < mul, "Invalid character");
          r += b;
        }
        return r;
      }
      BN2.prototype._parseBase = function _parseBase(number2, base2, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base2 | 0;
        var total = number2.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i2 = start; i2 < end; i2 += limbLen) {
          word = parseBase(number2, i2, i2 + limbLen, base2);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow = 1;
          word = parseBase(number2, i2, number2.length, base2);
          for (i2 = 0; i2 < mod2; i2++) {
            pow *= base2;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN2.prototype.copy = function copy2(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          dest.words[i2] = this.words[i2];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src2) {
        dest.words = src2.words;
        dest.length = src2.length;
        dest.negative = src2.negative;
        dest.red = src2.red;
      }
      BN2.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN2.prototype.clone = function clone() {
        var r = new BN2(null);
        this.copy(r);
        return r;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect2;
        } catch (e) {
          BN2.prototype.inspect = inspect2;
        }
      } else {
        BN2.prototype.inspect = inspect2;
      }
      function inspect2() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString2(base2, padding) {
        base2 = base2 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base2 === 16 || base2 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i2 = 0; i2 < this.length; i2++) {
            var w = this.words[i2];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i2--;
            }
            if (carry !== 0 || i2 !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
          var groupSize = groupSizes[base2];
          var groupBase = groupBases[base2];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base2);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros2[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer2) {
        BN2.prototype.toBuffer = function toBuffer(endian, length2) {
          return this.toArrayLike(Buffer2, endian, length2);
        };
      }
      BN2.prototype.toArray = function toArray2(endian, length2) {
        return this.toArrayLike(Array, endian, length2);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length2) {
        this._strip();
        var byteLength2 = this.byteLength();
        var reqLength = length2 || Math.max(1, byteLength2);
        assert2(byteLength2 <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix2 = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix2](res, byteLength2);
        return res;
      };
      BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
        var position2 = 0;
        var carry = 0;
        for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
          var word = this.words[i2] << shift | carry;
          res[position2++] = word & 255;
          if (position2 < res.length) {
            res[position2++] = word >> 8 & 255;
          }
          if (position2 < res.length) {
            res[position2++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position2 < res.length) {
              res[position2++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position2 < res.length) {
          res[position2++] = carry;
          while (position2 < res.length) {
            res[position2++] = 0;
          }
        }
      };
      BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
        var position2 = res.length - 1;
        var carry = 0;
        for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
          var word = this.words[i2] << shift | carry;
          res[position2--] = word & 255;
          if (position2 >= 0) {
            res[position2--] = word >> 8 & 255;
          }
          if (position2 >= 0) {
            res[position2--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position2 >= 0) {
              res[position2--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position2 >= 0) {
          res[position2--] = carry;
          while (position2 >= 0) {
            res[position2--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w) {
          var t2 = w;
          var r = 0;
          if (t2 >= 4096) {
            r += 13;
            t2 >>>= 13;
          }
          if (t2 >= 64) {
            r += 7;
            t2 >>>= 7;
          }
          if (t2 >= 8) {
            r += 4;
            t2 >>>= 4;
          }
          if (t2 >= 2) {
            r += 2;
            t2 >>>= 2;
          }
          return r + t2;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t2 = w;
        var r = 0;
        if ((t2 & 8191) === 0) {
          r += 13;
          t2 >>>= 13;
        }
        if ((t2 & 127) === 0) {
          r += 7;
          t2 >>>= 7;
        }
        if ((t2 & 15) === 0) {
          r += 4;
          t2 >>>= 4;
        }
        if ((t2 & 3) === 0) {
          r += 2;
          t2 >>>= 2;
        }
        if ((t2 & 1) === 0) {
          r++;
        }
        return r;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 1;
        }
        return w;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var b = this._zeroBits(this.words[i2]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN2.prototype.byteLength = function byteLength2() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i2 = 0; i2 < num.length; i2++) {
          this.words[i2] = this.words[i2] | num.words[i2];
        }
        return this._strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or2(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i2 = 0; i2 < b.length; i2++) {
          this.words[i2] = this.words[i2] & num.words[i2];
        }
        this.length = b.length;
        return this._strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and2(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i2 = 0; i2 < b.length; i2++) {
          this.words[i2] = a.words[i2] ^ b.words[i2];
        }
        if (this !== a) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert2(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i2 = 0; i2 < bytesNeeded; i2++) {
          this.words[i2] = ~this.words[i2] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b.length; i2++) {
          r = (a.words[i2] | 0) + (b.words[i2] | 0) + carry;
          this.words[i2] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i2 < a.length; i2++) {
          r = (a.words[i2] | 0) + carry;
          this.words[i2] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        return this;
      };
      BN2.prototype.add = function add2(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b.length; i2++) {
          r = (a.words[i2] | 0) - (b.words[i2] | 0) + carry;
          carry = r >> 26;
          this.words[i2] = r & 67108863;
        }
        for (; carry !== 0 && i2 < a.length; i2++) {
          r = (a.words[i2] | 0) + carry;
          carry = r >> 26;
          this.words[i2] = r & 67108863;
        }
        if (carry === 0 && i2 < a.length && a !== this) {
          for (; i2 < a.length; i2++) {
            this.words[i2] = a.words[i2];
          }
        }
        this.length = Math.max(this.length, i2);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len2 = self2.length + num.length | 0;
        out.length = len2;
        len2 = len2 - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k2 = 1; k2 < len2; k2++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
            var i2 = k2 - j | 0;
            a = self2.words[i2] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k2] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k2] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k2 = 0; k2 < out.length - 1; k2++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j = Math.max(0, k2 - self2.length + 1); j <= maxJ; j++) {
            var i2 = k2 - j;
            var a = self2.words[i2] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k2] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k2] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len2 = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len2 < 63) {
          res = smallMulTo(this, num, out);
        } else if (len2 < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w = (this.words[i2] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i2] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN2(1);
        var res = this;
        for (var i2 = 0; i2 < w.length; i2++, res = res.sqr()) {
          if (w[i2] !== 0)
            break;
        }
        if (++i2 < w.length) {
          for (var q2 = res.sqr(); i2 < w.length; i2++, q2 = q2.sqr()) {
            if (w[i2] === 0)
              continue;
            res = res.mul(q2);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i2;
        if (r !== 0) {
          var carry = 0;
          for (i2 = 0; i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask;
            var c = (this.words[i2] | 0) - newCarry << r;
            this.words[i2] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i2] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i2 = this.length - 1; i2 >= 0; i2--) {
            this.words[i2 + s] = this.words[i2];
          }
          for (i2 = 0; i2 < s; i2++) {
            this.words[i2] = 0;
          }
          this.length += s;
        }
        return this._strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert2(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert2(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i2 = 0; i2 < s; i2++) {
            maskedWords.words[i2] = this.words[i2];
          }
          maskedWords.length = s;
        }
        if (s === 0)
          ;
        else if (this.length > s) {
          this.length -= s;
          for (i2 = 0; i2 < this.length; i2++) {
            this.words[i2] = this.words[i2 + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q2 = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q2);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this._strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
          this.words[i2] -= 67108864;
          if (i2 === this.length - 1) {
            this.words[i2 + 1] = 1;
          } else {
            this.words[i2 + 1]++;
          }
        }
        this.length = Math.max(this.length, i2 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
            this.words[i2] += 67108864;
            this.words[i2 + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len2 = num.length + shift;
        var i2;
        this._expand(len2);
        var w;
        var carry = 0;
        for (i2 = 0; i2 < num.length; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i2 + shift] = w & 67108863;
        }
        for (; i2 < this.length - shift; i2++) {
          w = (this.words[i2 + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i2 + shift] = w & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert2(carry === -1);
        carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          w = -(this.words[i2] | 0) + carry;
          carry = w >> 26;
          this.words[i2] = w & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m2 = a.length - b.length;
        var q2;
        if (mode !== "mod") {
          q2 = new BN2(null);
          q2.length = m2 + 1;
          q2.words = new Array(q2.length);
          for (var i2 = 0; i2 < q2.length; i2++) {
            q2.words[i2] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m2);
        if (diff.negative === 0) {
          a = diff;
          if (q2) {
            q2.words[m2] = 1;
          }
        }
        for (var j = m2 - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q2) {
            q2.words[j] = qj;
          }
        }
        if (q2) {
          q2._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q2 || null,
          mod: a
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert2(num <= 67108863);
        var p2 = (1 << 26) % num;
        var acc = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          acc = (p2 * acc + (this.words[i2] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN2.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN2.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert2(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var w = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w / num | 0;
          carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p2) {
        assert2(p2.negative === 0);
        assert2(!p2.isZero());
        var x2 = this;
        var y = p2.clone();
        if (x2.negative !== 0) {
          x2 = x2.umod(p2);
        } else {
          x2 = x2.clone();
        }
        var A = new BN2(1);
        var B = new BN2(0);
        var C = new BN2(0);
        var D = new BN2(1);
        var g = 0;
        while (x2.isEven() && y.isEven()) {
          x2.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x2.clone();
        while (!x2.isZero()) {
          for (var i2 = 0, im = 1; (x2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            x2.iushrn(i2);
            while (i2-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x2.cmp(y) >= 0) {
            x2.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x2);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN2.prototype._invmp = function _invmp(p2) {
        assert2(p2.negative === 0);
        assert2(!p2.isZero());
        var a = this;
        var b = p2.clone();
        if (a.negative !== 0) {
          a = a.umod(p2);
        } else {
          a = a.clone();
        }
        var x1 = new BN2(1);
        var x2 = new BN2(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i2 = 0, im = 1; (a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
            ;
          if (i2 > 0) {
            a.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p2);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t2 = a;
            a = b;
            b = t2;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert2(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q2 = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q2;
          return this;
        }
        var carry = q2;
        for (var i2 = s; carry !== 0 && i2 < this.length; i2++) {
          var w = this.words[i2] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i2] = w;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var a = this.words[i2] | 0;
          var b = num.words[i2] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq2(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p2) {
        this.name = name;
        this.p = new BN2(p2, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split2(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits2(K256, MPrime);
      K256.prototype.split = function split2(input, output2) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i2 = 0; i2 < outLen; i2++) {
          output2.words[i2] = input.words[i2];
        }
        output2.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev2 = input.words[9];
        output2.words[output2.length++] = prev2 & mask;
        for (i2 = 10; i2 < input.length; i2++) {
          var next = input.words[i2] | 0;
          input.words[i2 - 10] = (next & mask) << 4 | prev2 >>> 22;
          prev2 = next;
        }
        prev2 >>>= 22;
        input.words[i2 - 10] = prev2;
        if (prev2 === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var w = num.words[i2] | 0;
          lo += w * 977;
          num.words[i2] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits2(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits2(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits2(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var hi = (num.words[i2] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i2] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m2) {
        if (typeof m2 === "string") {
          var prime = BN2._prime(m2);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert2(m2.gtn(1), "modulus must be greater than 1");
          this.m = m2;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert2(a.negative === 0, "red works only with positives");
        assert2(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert2((a.negative | b.negative) === 0, "red works only with positives");
        assert2(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add2(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q2 = this.m.subn(1);
        var s = 0;
        while (!q2.isZero() && q2.andln(1) === 0) {
          s++;
          q2.iushrn(1);
        }
        assert2(!q2.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z2 = this.m.bitLength();
        z2 = new BN2(2 * z2 * z2).toRed(this);
        while (this.pow(z2, lpow).cmp(nOne) !== 0) {
          z2.redIAdd(nOne);
        }
        var c = this.pow(z2, q2);
        var r = this.pow(a, q2.addn(1).iushrn(1));
        var t2 = this.pow(a, q2);
        var m2 = s;
        while (t2.cmp(one) !== 0) {
          var tmp = t2;
          for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
            tmp = tmp.redSqr();
          }
          assert2(i2 < m2);
          var b = this.pow(c, new BN2(1).iushln(m2 - i2 - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t2 = t2.redMul(c);
          m2 = i2;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a;
        for (var i2 = 2; i2 < wnd.length; i2++) {
          wnd[i2] = this.mul(wnd[i2 - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i2 = num.length - 1; i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i2 !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m2) {
        Red.call(this, m2);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits2(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t2 = a.imul(b);
        var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t2.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN2(0)._forceRed(this);
        var t2 = a.mul(b);
        var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t2.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(module2, commonjsGlobal);
  })(bn);
  var bnExports = bn.exports;
  const _BN = /* @__PURE__ */ getDefaultExportFromCjs(bnExports);
  const version$2 = "logger/5.7.0";
  let _permanentCensorErrors = false;
  let _censorErrors = false;
  const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
  let _logLevel = LogLevels["default"];
  let _globalLogger = null;
  function _checkNormalize() {
    try {
      const missing = [];
      ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
        try {
          if ("test".normalize(form) !== "test") {
            throw new Error("bad normalize");
          }
          ;
        } catch (error) {
          missing.push(form);
        }
      });
      if (missing.length) {
        throw new Error("missing " + missing.join(", "));
      }
      if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
        throw new Error("broken implementation");
      }
    } catch (error) {
      return error.message;
    }
    return null;
  }
  const _normalizeError = _checkNormalize();
  var LogLevel;
  (function(LogLevel2) {
    LogLevel2["DEBUG"] = "DEBUG";
    LogLevel2["INFO"] = "INFO";
    LogLevel2["WARNING"] = "WARNING";
    LogLevel2["ERROR"] = "ERROR";
    LogLevel2["OFF"] = "OFF";
  })(LogLevel || (LogLevel = {}));
  var ErrorCode;
  (function(ErrorCode2) {
    ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
    ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
    ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
    ErrorCode2["TIMEOUT"] = "TIMEOUT";
    ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
    ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
    ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
    ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
    ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
    ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
    ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
    ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
    ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
    ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
    ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
    ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
  })(ErrorCode || (ErrorCode = {}));
  const HEX = "0123456789abcdef";
  class Logger {
    constructor(version2) {
      Object.defineProperty(this, "version", {
        enumerable: true,
        value: version2,
        writable: false
      });
    }
    _log(logLevel, args) {
      const level = logLevel.toLowerCase();
      if (LogLevels[level] == null) {
        this.throwArgumentError("invalid log level name", "logLevel", logLevel);
      }
      if (_logLevel > LogLevels[level]) {
        return;
      }
      console.log.apply(console, args);
    }
    debug(...args) {
      this._log(Logger.levels.DEBUG, args);
    }
    info(...args) {
      this._log(Logger.levels.INFO, args);
    }
    warn(...args) {
      this._log(Logger.levels.WARNING, args);
    }
    makeError(message, code2, params) {
      if (_censorErrors) {
        return this.makeError("censored error", code2, {});
      }
      if (!code2) {
        code2 = Logger.errors.UNKNOWN_ERROR;
      }
      if (!params) {
        params = {};
      }
      const messageDetails = [];
      Object.keys(params).forEach((key) => {
        const value2 = params[key];
        try {
          if (value2 instanceof Uint8Array) {
            let hex = "";
            for (let i2 = 0; i2 < value2.length; i2++) {
              hex += HEX[value2[i2] >> 4];
              hex += HEX[value2[i2] & 15];
            }
            messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
          } else {
            messageDetails.push(key + "=" + JSON.stringify(value2));
          }
        } catch (error2) {
          messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
        }
      });
      messageDetails.push(`code=${code2}`);
      messageDetails.push(`version=${this.version}`);
      const reason = message;
      let url2 = "";
      switch (code2) {
        case ErrorCode.NUMERIC_FAULT: {
          url2 = "NUMERIC_FAULT";
          const fault = message;
          switch (fault) {
            case "overflow":
            case "underflow":
            case "division-by-zero":
              url2 += "-" + fault;
              break;
            case "negative-power":
            case "negative-width":
              url2 += "-unsupported";
              break;
            case "unbound-bitwise-result":
              url2 += "-unbound-result";
              break;
          }
          break;
        }
        case ErrorCode.CALL_EXCEPTION:
        case ErrorCode.INSUFFICIENT_FUNDS:
        case ErrorCode.MISSING_NEW:
        case ErrorCode.NONCE_EXPIRED:
        case ErrorCode.REPLACEMENT_UNDERPRICED:
        case ErrorCode.TRANSACTION_REPLACED:
        case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
          url2 = code2;
          break;
      }
      if (url2) {
        message += " [ See: https://links.ethers.org/v5-errors-" + url2 + " ]";
      }
      if (messageDetails.length) {
        message += " (" + messageDetails.join(", ") + ")";
      }
      const error = new Error(message);
      error.reason = reason;
      error.code = code2;
      Object.keys(params).forEach(function(key) {
        error[key] = params[key];
      });
      return error;
    }
    throwError(message, code2, params) {
      throw this.makeError(message, code2, params);
    }
    throwArgumentError(message, name, value2) {
      return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
        argument: name,
        value: value2
      });
    }
    assert(condition, message, code2, params) {
      if (!!condition) {
        return;
      }
      this.throwError(message, code2, params);
    }
    assertArgument(condition, message, name, value2) {
      if (!!condition) {
        return;
      }
      this.throwArgumentError(message, name, value2);
    }
    checkNormalize(message) {
      if (_normalizeError) {
        this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "String.prototype.normalize",
          form: _normalizeError
        });
      }
    }
    checkSafeUint53(value2, message) {
      if (typeof value2 !== "number") {
        return;
      }
      if (message == null) {
        message = "value not safe";
      }
      if (value2 < 0 || value2 >= 9007199254740991) {
        this.throwError(message, Logger.errors.NUMERIC_FAULT, {
          operation: "checkSafeInteger",
          fault: "out-of-safe-range",
          value: value2
        });
      }
      if (value2 % 1) {
        this.throwError(message, Logger.errors.NUMERIC_FAULT, {
          operation: "checkSafeInteger",
          fault: "non-integer",
          value: value2
        });
      }
    }
    checkArgumentCount(count2, expectedCount, message) {
      if (message) {
        message = ": " + message;
      } else {
        message = "";
      }
      if (count2 < expectedCount) {
        this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
          count: count2,
          expectedCount
        });
      }
      if (count2 > expectedCount) {
        this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
          count: count2,
          expectedCount
        });
      }
    }
    checkNew(target, kind) {
      if (target === Object || target == null) {
        this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
      }
    }
    checkAbstract(target, kind) {
      if (target === kind) {
        this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
      } else if (target === Object || target == null) {
        this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
      }
    }
    static globalLogger() {
      if (!_globalLogger) {
        _globalLogger = new Logger(version$2);
      }
      return _globalLogger;
    }
    static setCensorship(censorship, permanent) {
      if (!censorship && permanent) {
        this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "setCensorship"
        });
      }
      if (_permanentCensorErrors) {
        if (!censorship) {
          return;
        }
        this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "setCensorship"
        });
      }
      _censorErrors = !!censorship;
      _permanentCensorErrors = !!permanent;
    }
    static setLogLevel(logLevel) {
      const level = LogLevels[logLevel.toLowerCase()];
      if (level == null) {
        Logger.globalLogger().warn("invalid log level - " + logLevel);
        return;
      }
      _logLevel = level;
    }
    static from(version2) {
      return new Logger(version2);
    }
  }
  Logger.errors = ErrorCode;
  Logger.levels = LogLevel;
  const version$1 = "bytes/5.7.0";
  const logger$2 = new Logger(version$1);
  function isHexable(value2) {
    return !!value2.toHexString;
  }
  function addSlice(array) {
    if (array.slice) {
      return array;
    }
    array.slice = function() {
      const args = Array.prototype.slice.call(arguments);
      return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
    };
    return array;
  }
  function isInteger(value2) {
    return typeof value2 === "number" && value2 == value2 && value2 % 1 === 0;
  }
  function isBytes(value2) {
    if (value2 == null) {
      return false;
    }
    if (value2.constructor === Uint8Array) {
      return true;
    }
    if (typeof value2 === "string") {
      return false;
    }
    if (!isInteger(value2.length) || value2.length < 0) {
      return false;
    }
    for (let i2 = 0; i2 < value2.length; i2++) {
      const v = value2[i2];
      if (!isInteger(v) || v < 0 || v >= 256) {
        return false;
      }
    }
    return true;
  }
  function arrayify(value2, options) {
    if (!options) {
      options = {};
    }
    if (typeof value2 === "number") {
      logger$2.checkSafeUint53(value2, "invalid arrayify value");
      const result = [];
      while (value2) {
        result.unshift(value2 & 255);
        value2 = parseInt(String(value2 / 256));
      }
      if (result.length === 0) {
        result.push(0);
      }
      return addSlice(new Uint8Array(result));
    }
    if (options.allowMissingPrefix && typeof value2 === "string" && value2.substring(0, 2) !== "0x") {
      value2 = "0x" + value2;
    }
    if (isHexable(value2)) {
      value2 = value2.toHexString();
    }
    if (isHexString(value2)) {
      let hex = value2.substring(2);
      if (hex.length % 2) {
        if (options.hexPad === "left") {
          hex = "0" + hex;
        } else if (options.hexPad === "right") {
          hex += "0";
        } else {
          logger$2.throwArgumentError("hex data is odd-length", "value", value2);
        }
      }
      const result = [];
      for (let i2 = 0; i2 < hex.length; i2 += 2) {
        result.push(parseInt(hex.substring(i2, i2 + 2), 16));
      }
      return addSlice(new Uint8Array(result));
    }
    if (isBytes(value2)) {
      return addSlice(new Uint8Array(value2));
    }
    return logger$2.throwArgumentError("invalid arrayify value", "value", value2);
  }
  function isHexString(value2, length2) {
    if (typeof value2 !== "string" || !value2.match(/^0x[0-9A-Fa-f]*$/)) {
      return false;
    }
    if (length2 && value2.length !== 2 + 2 * length2) {
      return false;
    }
    return true;
  }
  const HexCharacters = "0123456789abcdef";
  function hexlify(value2, options) {
    if (!options) {
      options = {};
    }
    if (typeof value2 === "number") {
      logger$2.checkSafeUint53(value2, "invalid hexlify value");
      let hex = "";
      while (value2) {
        hex = HexCharacters[value2 & 15] + hex;
        value2 = Math.floor(value2 / 16);
      }
      if (hex.length) {
        if (hex.length % 2) {
          hex = "0" + hex;
        }
        return "0x" + hex;
      }
      return "0x00";
    }
    if (typeof value2 === "bigint") {
      value2 = value2.toString(16);
      if (value2.length % 2) {
        return "0x0" + value2;
      }
      return "0x" + value2;
    }
    if (options.allowMissingPrefix && typeof value2 === "string" && value2.substring(0, 2) !== "0x") {
      value2 = "0x" + value2;
    }
    if (isHexable(value2)) {
      return value2.toHexString();
    }
    if (isHexString(value2)) {
      if (value2.length % 2) {
        if (options.hexPad === "left") {
          value2 = "0x0" + value2.substring(2);
        } else if (options.hexPad === "right") {
          value2 += "0";
        } else {
          logger$2.throwArgumentError("hex data is odd-length", "value", value2);
        }
      }
      return value2.toLowerCase();
    }
    if (isBytes(value2)) {
      let result = "0x";
      for (let i2 = 0; i2 < value2.length; i2++) {
        let v = value2[i2];
        result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
      }
      return result;
    }
    return logger$2.throwArgumentError("invalid hexlify value", "value", value2);
  }
  function hexZeroPad(value2, length2) {
    if (typeof value2 !== "string") {
      value2 = hexlify(value2);
    } else if (!isHexString(value2)) {
      logger$2.throwArgumentError("invalid hex string", "value", value2);
    }
    if (value2.length > 2 * length2 + 2) {
      logger$2.throwArgumentError("value out of range", "value", arguments[1]);
    }
    while (value2.length < 2 * length2 + 2) {
      value2 = "0x0" + value2.substring(2);
    }
    return value2;
  }
  const version = "bignumber/5.7.0";
  var BN = _BN.BN;
  const logger$1 = new Logger(version);
  const _constructorGuard$1 = {};
  const MAX_SAFE = 9007199254740991;
  function isBigNumberish(value2) {
    return value2 != null && (BigNumber$1.isBigNumber(value2) || typeof value2 === "number" && value2 % 1 === 0 || typeof value2 === "string" && !!value2.match(/^-?[0-9]+$/) || isHexString(value2) || typeof value2 === "bigint" || isBytes(value2));
  }
  let _warnedToStringRadix = false;
  let BigNumber$1 = class BigNumber2 {
    constructor(constructorGuard, hex) {
      if (constructorGuard !== _constructorGuard$1) {
        logger$1.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new (BigNumber)"
        });
      }
      this._hex = hex;
      this._isBigNumber = true;
      Object.freeze(this);
    }
    fromTwos(value2) {
      return toBigNumber(toBN(this).fromTwos(value2));
    }
    toTwos(value2) {
      return toBigNumber(toBN(this).toTwos(value2));
    }
    abs() {
      if (this._hex[0] === "-") {
        return BigNumber2.from(this._hex.substring(1));
      }
      return this;
    }
    add(other) {
      return toBigNumber(toBN(this).add(toBN(other)));
    }
    sub(other) {
      return toBigNumber(toBN(this).sub(toBN(other)));
    }
    div(other) {
      const o = BigNumber2.from(other);
      if (o.isZero()) {
        throwFault$1("division-by-zero", "div");
      }
      return toBigNumber(toBN(this).div(toBN(other)));
    }
    mul(other) {
      return toBigNumber(toBN(this).mul(toBN(other)));
    }
    mod(other) {
      const value2 = toBN(other);
      if (value2.isNeg()) {
        throwFault$1("division-by-zero", "mod");
      }
      return toBigNumber(toBN(this).umod(value2));
    }
    pow(other) {
      const value2 = toBN(other);
      if (value2.isNeg()) {
        throwFault$1("negative-power", "pow");
      }
      return toBigNumber(toBN(this).pow(value2));
    }
    and(other) {
      const value2 = toBN(other);
      if (this.isNegative() || value2.isNeg()) {
        throwFault$1("unbound-bitwise-result", "and");
      }
      return toBigNumber(toBN(this).and(value2));
    }
    or(other) {
      const value2 = toBN(other);
      if (this.isNegative() || value2.isNeg()) {
        throwFault$1("unbound-bitwise-result", "or");
      }
      return toBigNumber(toBN(this).or(value2));
    }
    xor(other) {
      const value2 = toBN(other);
      if (this.isNegative() || value2.isNeg()) {
        throwFault$1("unbound-bitwise-result", "xor");
      }
      return toBigNumber(toBN(this).xor(value2));
    }
    mask(value2) {
      if (this.isNegative() || value2 < 0) {
        throwFault$1("negative-width", "mask");
      }
      return toBigNumber(toBN(this).maskn(value2));
    }
    shl(value2) {
      if (this.isNegative() || value2 < 0) {
        throwFault$1("negative-width", "shl");
      }
      return toBigNumber(toBN(this).shln(value2));
    }
    shr(value2) {
      if (this.isNegative() || value2 < 0) {
        throwFault$1("negative-width", "shr");
      }
      return toBigNumber(toBN(this).shrn(value2));
    }
    eq(other) {
      return toBN(this).eq(toBN(other));
    }
    lt(other) {
      return toBN(this).lt(toBN(other));
    }
    lte(other) {
      return toBN(this).lte(toBN(other));
    }
    gt(other) {
      return toBN(this).gt(toBN(other));
    }
    gte(other) {
      return toBN(this).gte(toBN(other));
    }
    isNegative() {
      return this._hex[0] === "-";
    }
    isZero() {
      return toBN(this).isZero();
    }
    toNumber() {
      try {
        return toBN(this).toNumber();
      } catch (error) {
        throwFault$1("overflow", "toNumber", this.toString());
      }
      return null;
    }
    toBigInt() {
      try {
        return BigInt(this.toString());
      } catch (e) {
      }
      return logger$1.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
        value: this.toString()
      });
    }
    toString() {
      if (arguments.length > 0) {
        if (arguments[0] === 10) {
          if (!_warnedToStringRadix) {
            _warnedToStringRadix = true;
            logger$1.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
          }
        } else if (arguments[0] === 16) {
          logger$1.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
        } else {
          logger$1.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
        }
      }
      return toBN(this).toString(10);
    }
    toHexString() {
      return this._hex;
    }
    toJSON(key) {
      return { type: "BigNumber", hex: this.toHexString() };
    }
    static from(value2) {
      if (value2 instanceof BigNumber2) {
        return value2;
      }
      if (typeof value2 === "string") {
        if (value2.match(/^-?0x[0-9a-f]+$/i)) {
          return new BigNumber2(_constructorGuard$1, toHex(value2));
        }
        if (value2.match(/^-?[0-9]+$/)) {
          return new BigNumber2(_constructorGuard$1, toHex(new BN(value2)));
        }
        return logger$1.throwArgumentError("invalid BigNumber string", "value", value2);
      }
      if (typeof value2 === "number") {
        if (value2 % 1) {
          throwFault$1("underflow", "BigNumber.from", value2);
        }
        if (value2 >= MAX_SAFE || value2 <= -MAX_SAFE) {
          throwFault$1("overflow", "BigNumber.from", value2);
        }
        return BigNumber2.from(String(value2));
      }
      const anyValue = value2;
      if (typeof anyValue === "bigint") {
        return BigNumber2.from(anyValue.toString());
      }
      if (isBytes(anyValue)) {
        return BigNumber2.from(hexlify(anyValue));
      }
      if (anyValue) {
        if (anyValue.toHexString) {
          const hex = anyValue.toHexString();
          if (typeof hex === "string") {
            return BigNumber2.from(hex);
          }
        } else {
          let hex = anyValue._hex;
          if (hex == null && anyValue.type === "BigNumber") {
            hex = anyValue.hex;
          }
          if (typeof hex === "string") {
            if (isHexString(hex) || hex[0] === "-" && isHexString(hex.substring(1))) {
              return BigNumber2.from(hex);
            }
          }
        }
      }
      return logger$1.throwArgumentError("invalid BigNumber value", "value", value2);
    }
    static isBigNumber(value2) {
      return !!(value2 && value2._isBigNumber);
    }
  };
  function toHex(value2) {
    if (typeof value2 !== "string") {
      return toHex(value2.toString(16));
    }
    if (value2[0] === "-") {
      value2 = value2.substring(1);
      if (value2[0] === "-") {
        logger$1.throwArgumentError("invalid hex", "value", value2);
      }
      value2 = toHex(value2);
      if (value2 === "0x00") {
        return value2;
      }
      return "-" + value2;
    }
    if (value2.substring(0, 2) !== "0x") {
      value2 = "0x" + value2;
    }
    if (value2 === "0x") {
      return "0x00";
    }
    if (value2.length % 2) {
      value2 = "0x0" + value2.substring(2);
    }
    while (value2.length > 4 && value2.substring(0, 4) === "0x00") {
      value2 = "0x" + value2.substring(4);
    }
    return value2;
  }
  function toBigNumber(value2) {
    return BigNumber$1.from(toHex(value2));
  }
  function toBN(value2) {
    const hex = BigNumber$1.from(value2).toHexString();
    if (hex[0] === "-") {
      return new BN("-" + hex.substring(3), 16);
    }
    return new BN(hex.substring(2), 16);
  }
  function throwFault$1(fault, operation, value2) {
    const params = { fault, operation };
    if (value2 != null) {
      params.value = value2;
    }
    return logger$1.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
  }
  function _base36To16(value2) {
    return new BN(value2, 36).toString(16);
  }
  function _base16To36(value2) {
    return new BN(value2, 16).toString(36);
  }
  const logger = new Logger(version);
  const _constructorGuard = {};
  const Zero = BigNumber$1.from(0);
  const NegativeOne = BigNumber$1.from(-1);
  function throwFault(message, fault, operation, value2) {
    const params = { fault, operation };
    if (value2 !== void 0) {
      params.value = value2;
    }
    return logger.throwError(message, Logger.errors.NUMERIC_FAULT, params);
  }
  let zeros = "0";
  while (zeros.length < 256) {
    zeros += zeros;
  }
  function getMultiplier(decimals) {
    if (typeof decimals !== "number") {
      try {
        decimals = BigNumber$1.from(decimals).toNumber();
      } catch (e) {
      }
    }
    if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
      return "1" + zeros.substring(0, decimals);
    }
    return logger.throwArgumentError("invalid decimal size", "decimals", decimals);
  }
  function formatFixed(value2, decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const multiplier = getMultiplier(decimals);
    value2 = BigNumber$1.from(value2);
    const negative = value2.lt(Zero);
    if (negative) {
      value2 = value2.mul(NegativeOne);
    }
    let fraction = value2.mod(multiplier).toString();
    while (fraction.length < multiplier.length - 1) {
      fraction = "0" + fraction;
    }
    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    const whole = value2.div(multiplier).toString();
    if (multiplier.length === 1) {
      value2 = whole;
    } else {
      value2 = whole + "." + fraction;
    }
    if (negative) {
      value2 = "-" + value2;
    }
    return value2;
  }
  function parseFixed(value2, decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const multiplier = getMultiplier(decimals);
    if (typeof value2 !== "string" || !value2.match(/^-?[0-9.]+$/)) {
      logger.throwArgumentError("invalid decimal value", "value", value2);
    }
    const negative = value2.substring(0, 1) === "-";
    if (negative) {
      value2 = value2.substring(1);
    }
    if (value2 === ".") {
      logger.throwArgumentError("missing value", "value", value2);
    }
    const comps = value2.split(".");
    if (comps.length > 2) {
      logger.throwArgumentError("too many decimal points", "value", value2);
    }
    let whole = comps[0], fraction = comps[1];
    if (!whole) {
      whole = "0";
    }
    if (!fraction) {
      fraction = "0";
    }
    while (fraction[fraction.length - 1] === "0") {
      fraction = fraction.substring(0, fraction.length - 1);
    }
    if (fraction.length > multiplier.length - 1) {
      throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
    }
    if (fraction === "") {
      fraction = "0";
    }
    while (fraction.length < multiplier.length - 1) {
      fraction += "0";
    }
    const wholeValue = BigNumber$1.from(whole);
    const fractionValue = BigNumber$1.from(fraction);
    let wei = wholeValue.mul(multiplier).add(fractionValue);
    if (negative) {
      wei = wei.mul(NegativeOne);
    }
    return wei;
  }
  class FixedFormat {
    constructor(constructorGuard, signed, width, decimals) {
      if (constructorGuard !== _constructorGuard) {
        logger.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new FixedFormat"
        });
      }
      this.signed = signed;
      this.width = width;
      this.decimals = decimals;
      this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
      this._multiplier = getMultiplier(decimals);
      Object.freeze(this);
    }
    static from(value2) {
      if (value2 instanceof FixedFormat) {
        return value2;
      }
      if (typeof value2 === "number") {
        value2 = `fixed128x${value2}`;
      }
      let signed = true;
      let width = 128;
      let decimals = 18;
      if (typeof value2 === "string") {
        if (value2 === "fixed")
          ;
        else if (value2 === "ufixed") {
          signed = false;
        } else {
          const match2 = value2.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
          if (!match2) {
            logger.throwArgumentError("invalid fixed format", "format", value2);
          }
          signed = match2[1] !== "u";
          width = parseInt(match2[2]);
          decimals = parseInt(match2[3]);
        }
      } else if (value2) {
        const check2 = (key, type2, defaultValue) => {
          if (value2[key] == null) {
            return defaultValue;
          }
          if (typeof value2[key] !== type2) {
            logger.throwArgumentError("invalid fixed format (" + key + " not " + type2 + ")", "format." + key, value2[key]);
          }
          return value2[key];
        };
        signed = check2("signed", "boolean", signed);
        width = check2("width", "number", width);
        decimals = check2("decimals", "number", decimals);
      }
      if (width % 8) {
        logger.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
      }
      if (decimals > 80) {
        logger.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
      }
      return new FixedFormat(_constructorGuard, signed, width, decimals);
    }
  }
  class FixedNumber {
    constructor(constructorGuard, hex, value2, format) {
      if (constructorGuard !== _constructorGuard) {
        logger.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new FixedFormat"
        });
      }
      this.format = format;
      this._hex = hex;
      this._value = value2;
      this._isFixedNumber = true;
      Object.freeze(this);
    }
    _checkFormat(other) {
      if (this.format.name !== other.format.name) {
        logger.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
      }
    }
    addUnsafe(other) {
      this._checkFormat(other);
      const a = parseFixed(this._value, this.format.decimals);
      const b = parseFixed(other._value, other.format.decimals);
      return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);
    }
    subUnsafe(other) {
      this._checkFormat(other);
      const a = parseFixed(this._value, this.format.decimals);
      const b = parseFixed(other._value, other.format.decimals);
      return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);
    }
    mulUnsafe(other) {
      this._checkFormat(other);
      const a = parseFixed(this._value, this.format.decimals);
      const b = parseFixed(other._value, other.format.decimals);
      return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
    }
    divUnsafe(other) {
      this._checkFormat(other);
      const a = parseFixed(this._value, this.format.decimals);
      const b = parseFixed(other._value, other.format.decimals);
      return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
    }
    floor() {
      const comps = this.toString().split(".");
      if (comps.length === 1) {
        comps.push("0");
      }
      let result = FixedNumber.from(comps[0], this.format);
      const hasFraction = !comps[1].match(/^(0*)$/);
      if (this.isNegative() && hasFraction) {
        result = result.subUnsafe(ONE.toFormat(result.format));
      }
      return result;
    }
    ceiling() {
      const comps = this.toString().split(".");
      if (comps.length === 1) {
        comps.push("0");
      }
      let result = FixedNumber.from(comps[0], this.format);
      const hasFraction = !comps[1].match(/^(0*)$/);
      if (!this.isNegative() && hasFraction) {
        result = result.addUnsafe(ONE.toFormat(result.format));
      }
      return result;
    }
    // @TODO: Support other rounding algorithms
    round(decimals) {
      if (decimals == null) {
        decimals = 0;
      }
      const comps = this.toString().split(".");
      if (comps.length === 1) {
        comps.push("0");
      }
      if (decimals < 0 || decimals > 80 || decimals % 1) {
        logger.throwArgumentError("invalid decimal count", "decimals", decimals);
      }
      if (comps[1].length <= decimals) {
        return this;
      }
      const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
      const bump = BUMP.toFormat(this.format);
      return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
    }
    isZero() {
      return this._value === "0.0" || this._value === "0";
    }
    isNegative() {
      return this._value[0] === "-";
    }
    toString() {
      return this._value;
    }
    toHexString(width) {
      if (width == null) {
        return this._hex;
      }
      if (width % 8) {
        logger.throwArgumentError("invalid byte width", "width", width);
      }
      const hex = BigNumber$1.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
      return hexZeroPad(hex, width / 8);
    }
    toUnsafeFloat() {
      return parseFloat(this.toString());
    }
    toFormat(format) {
      return FixedNumber.fromString(this._value, format);
    }
    static fromValue(value2, decimals, format) {
      if (format == null && decimals != null && !isBigNumberish(decimals)) {
        format = decimals;
        decimals = null;
      }
      if (decimals == null) {
        decimals = 0;
      }
      if (format == null) {
        format = "fixed";
      }
      return FixedNumber.fromString(formatFixed(value2, decimals), FixedFormat.from(format));
    }
    static fromString(value2, format) {
      if (format == null) {
        format = "fixed";
      }
      const fixedFormat = FixedFormat.from(format);
      const numeric = parseFixed(value2, fixedFormat.decimals);
      if (!fixedFormat.signed && numeric.lt(Zero)) {
        throwFault("unsigned value cannot be negative", "overflow", "value", value2);
      }
      let hex = null;
      if (fixedFormat.signed) {
        hex = numeric.toTwos(fixedFormat.width).toHexString();
      } else {
        hex = numeric.toHexString();
        hex = hexZeroPad(hex, fixedFormat.width / 8);
      }
      const decimal = formatFixed(numeric, fixedFormat.decimals);
      return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);
    }
    static fromBytes(value2, format) {
      if (format == null) {
        format = "fixed";
      }
      const fixedFormat = FixedFormat.from(format);
      if (arrayify(value2).length > fixedFormat.width / 8) {
        throw new Error("overflow");
      }
      let numeric = BigNumber$1.from(value2);
      if (fixedFormat.signed) {
        numeric = numeric.fromTwos(fixedFormat.width);
      }
      const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
      const decimal = formatFixed(numeric, fixedFormat.decimals);
      return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);
    }
    static from(value2, format) {
      if (typeof value2 === "string") {
        return FixedNumber.fromString(value2, format);
      }
      if (isBytes(value2)) {
        return FixedNumber.fromBytes(value2, format);
      }
      try {
        return FixedNumber.fromValue(value2, 0, format);
      } catch (error) {
        if (error.code !== Logger.errors.INVALID_ARGUMENT) {
          throw error;
        }
      }
      return logger.throwArgumentError("invalid FixedNumber value", "value", value2);
    }
    static isFixedNumber(value2) {
      return !!(value2 && value2._isFixedNumber);
    }
  }
  const ONE = FixedNumber.from(1);
  const BUMP = FixedNumber.from("0.5");
  const lib_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    BigNumber: BigNumber$1,
    FixedFormat,
    FixedNumber,
    _base16To36,
    _base36To16,
    formatFixed,
    parseFixed
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$4 = /* @__PURE__ */ getAugmentedNamespace(lib_esm);
  var __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o[k22] = m2[k2];
  });
  var __setModuleDefault$1 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k2 in mod2)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
          __createBinding$1(result, mod2, k2);
    }
    __setModuleDefault$1(result, mod2);
    return result;
  };
  var __importDefault$9 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(lib$3, "__esModule", { value: true });
  lib$3.TxBuilder = void 0;
  const TAG$1 = " | tx-builder | ";
  const log$1 = libExports();
  const core = __importStar$1(dist);
  const split_1 = __importDefault$9(split);
  const coinSelect = coinselect;
  let BigNumber = require$$4;
  function numberToHex(number2) {
    if (!Number.isInteger(number2)) {
      throw new Error("Input must be an integer.");
    }
    return "0x" + number2.toString(16);
  }
  let { xpubConvert: xpubConvert$1, bip32ToAddressNList, map: map$1, COIN_MAP_LONG: COIN_MAP_LONG$1, COIN_MAP_KEEPKEY_LONG: COIN_MAP_KEEPKEY_LONG$1, baseAmountToNative: baseAmountToNative$1, nativeToBaseAmount: nativeToBaseAmount$1 } = lib$7;
  const HD_RUNE_KEYPATH = "m/44'/931'/0'/0/0";
  const RUNE_CHAIN = "thorchain-mainnet-v1";
  const HD_ATOM_KEYPATH = "m/44'/118'/0'/0/0";
  const ATOM_CHAIN = "cosmoshub-4";
  const OSMO_CHAIN = "osmosis-1";
  let TxBuilder$1 = class TxBuilder {
    constructor(pioneer, config2) {
      this.pioneer = pioneer;
      this.init = async function(wallet2) {
      };
      this.lp = async function(lp) {
        let tag = TAG$1 + " | swap | ";
        try {
          log$1.debug(tag, "lp: ", lp);
          let unsignedTx;
          const expr = lp.protocol;
          switch (expr) {
            case "ethereum":
              throw Error("ethereum Not supported!");
              break;
            case "osmosis":
              const fee = "100";
              const gas = "1350000";
              const osmoAddress = lp.from;
              const ibcVoucherAtomOsmo = "ibc/27394FB092D2ECCD56123C74F36E4C1F926001CEADA9CA97EA622B25F41E5EB2";
              let sellAmount = lp.amountleg1;
              let buyAmount = lp.amountleg2;
              log$1.debug(tag, "{network:'OSMO',address:osmoAddress}: ", { network: "OSMO", address: osmoAddress });
              let masterInfo = await this.pioneer.GetAccountInfo({ network: "OSMO", address: osmoAddress });
              log$1.debug(tag, "masterInfo: ", masterInfo);
              masterInfo = masterInfo.data;
              log$1.debug(tag, "masterInfo: ", masterInfo);
              let sequence = masterInfo.result.value.sequence || 0;
              let account_number = masterInfo.result.value.account_number;
              sequence = parseInt(String(sequence));
              const tx1 = {
                memo: "",
                fee: {
                  amount: [
                    {
                      amount: fee.toString(),
                      denom: "uosmo"
                    }
                  ],
                  gas: gas.toString()
                },
                signatures: null,
                msg: [
                  {
                    "type": "osmosis/gamm/join-pool",
                    "value": {
                      "sender": osmoAddress,
                      "poolId": "1",
                      "shareOutAmount": "402238349184328773",
                      "tokenInMaxs": [
                        {
                          "denom": ibcVoucherAtomOsmo,
                          "amount": sellAmount
                        },
                        {
                          "denom": "uosmo",
                          "amount": buyAmount
                        }
                      ]
                    }
                  }
                ]
              };
              const osmoAddressNList = bip32ToAddressNList("m/44'/118'/0'/0/0");
              unsignedTx = {
                tx: tx1,
                addressNList: osmoAddressNList,
                chain_id: "osmosis-1",
                account_number,
                sequence
              };
              break;
            default:
              throw Error("unhandled!: " + expr);
          }
          log$1.debug(tag, "unsignedTx FINAL: ", unsignedTx);
          return unsignedTx;
        } catch (e) {
          log$1.error(tag, "e: ", e);
        }
      };
      this.swap = async function(tx) {
        let tag = TAG$1 + " | swap | ";
        try {
          log$1.debug(tag, "tx: ", tx);
          let unsignedTx;
          const expr = tx.type;
          switch (expr) {
            case "EVM":
              log$1.debug("EVM Tx type");
              let from2 = tx.from;
              let gas_limit = 8e4;
              let nonceRemote = await this.pioneer.GetNonce(from2);
              nonceRemote = nonceRemote.data;
              let gas_price = await this.pioneer.GetGasPrice();
              gas_price = gas_price.data;
              log$1.info(tag, "gas_price: ", gas_price);
              gas_price = parseInt(gas_price) + 1e4;
              gas_price = gas_price.toString();
              let nonce = nonceRemote;
              if (!(tx === null || tx === void 0 ? void 0 : tx.value))
                throw Error("Invalid EVM Tx missing value");
              let value2 = tx.value;
              if (!(tx === null || tx === void 0 ? void 0 : tx.to))
                throw Error("Invalid EVM Tx missing to");
              let to = tx.to;
              if (!(tx === null || tx === void 0 ? void 0 : tx.data))
                throw Error("Invalid EVM Tx missing data");
              let data2 = tx.data;
              let chainId;
              if (tx.network === "ETH" || tx.blockchain == "ethereum") {
                chainId = 1;
              } else if (tx.network === "AVAX" || tx.blockchain == "avalanche") {
                chainId = 43114;
              } else {
                throw Error("Network not supported! network: " + tx.network);
              }
              let ethTx = {
                // addressNList: support.bip32ToAddressNList(masterPathEth),
                "addressNList": [
                  2147483692,
                  2147483708,
                  2147483648,
                  0,
                  0
                ],
                nonce: numberToHex(nonce),
                gasPrice: numberToHex(gas_price),
                gasLimit: numberToHex(gas_limit),
                value: value2,
                to,
                data: data2,
                chainId
              };
              unsignedTx = ethTx;
              break;
            case "TRANSFER":
              if (!tx.from)
                throw Error("invalid TX missing from!");
              let blockchain = COIN_MAP_LONG$1[tx.asset.symbol];
              let transfer = {
                type: "transfer",
                blockchain,
                asset: tx.asset.symbol,
                toAddress: tx.recipientAddress,
                amount: nativeToBaseAmount$1(tx.asset.symbol, tx.amount),
                from: {
                  pubkey: tx.from
                },
                pubkey: tx.pubkey
              };
              if (tx.memo)
                transfer.memo = tx.memo;
              log$1.debug(tag, "input transfer: ", transfer);
              let transferTx = await this.transfer(transfer);
              log$1.debug(tag, "transferTx: ", transferTx);
              unsignedTx = transferTx;
              break;
            case "DEPOSIT":
              let deposit = {
                type: "deposit",
                blockchain: COIN_MAP_LONG$1[tx.asset.symbol],
                asset: tx.asset.symbol,
                toAddress: tx.recipientAddress,
                amount: nativeToBaseAmount$1(tx.asset.symbol, tx.amount),
                memo: tx.memo,
                from: {
                  pubkey: tx.from
                },
                pubkey: tx.pubkey
              };
              let depositTx = await this.deposit(deposit);
              log$1.debug(tag, "depositTx: ", depositTx);
              unsignedTx = depositTx;
              break;
            case "COSMOS":
              throw Error("TODO");
            default:
              throw Error("unhandled!: " + expr);
          }
          log$1.debug(tag, "unsignedTx FINAL: ", unsignedTx);
          return unsignedTx;
        } catch (e) {
          log$1.error(tag, "e: ", e);
        }
      };
      this.deposit = async function(deposit) {
        let tag = TAG$1 + " | deposit | ";
        try {
          let rawTx;
          log$1.info(tag, "deposit: ", deposit);
          const RUNE_BASE = 1e8;
          if (deposit.blockchain !== "thorchain")
            throw Error("Network not supported!" + deposit.blockchain);
          let amountNative = RUNE_BASE * parseFloat(deposit.amount);
          amountNative = parseInt(amountNative.toString());
          let addressFrom = deposit.addressFrom || deposit.from.pubkey;
          if (!addressFrom)
            throw Error("Invalid deposit! missing addressFrom!");
          log$1.debug(tag, "addressFrom: ", addressFrom);
          let masterInfo = await this.pioneer.GetAccountInfo({ network: "RUNE", address: addressFrom });
          masterInfo = masterInfo.data;
          log$1.debug(tag, "masterInfo: ", masterInfo);
          let sequence = masterInfo.result.value.sequence || 0;
          let account_number = masterInfo.result.value.account_number;
          sequence = parseInt(sequence);
          sequence = sequence.toString();
          let txType = "thorchain/MsgDeposit";
          let gas = "3500000";
          let fee = "2000000";
          if (!deposit.memo)
            throw Error("103: invalid swap! missing memo");
          let memo = deposit.memo;
          let unsigned = {
            "fee": {
              "amount": [
                {
                  "amount": fee,
                  "denom": "rune"
                }
              ],
              "gas": gas
            },
            "msg": [
              {
                "type": txType,
                "value": {
                  "coins": [
                    {
                      "amount": amountNative.toString(),
                      "asset": "THOR.RUNE"
                    }
                  ],
                  "memo": memo,
                  "signer": addressFrom
                }
              }
            ]
          };
          let chain_id = RUNE_CHAIN;
          if (!sequence)
            throw Error("112: Failed to get sequence");
          if (!account_number)
            account_number = 0;
          log$1.info(tag, "res: ", {
            addressNList: bip32ToAddressNList(HD_RUNE_KEYPATH),
            chain_id,
            account_number,
            sequence,
            tx: unsigned
          });
          log$1.info(tag, "******* signTx: ", JSON.stringify({
            addressNList: bip32ToAddressNList(HD_RUNE_KEYPATH),
            chain_id,
            account_number,
            sequence,
            tx: unsigned
          }));
          let runeTx = {
            addressNList: bip32ToAddressNList(HD_RUNE_KEYPATH),
            chain_id,
            account_number,
            sequence,
            tx: unsigned
          };
          rawTx = runeTx;
          return rawTx;
        } catch (e) {
          log$1.error(tag, "e: ", e);
        }
      };
      this.transfer = async function(tx) {
        let tag = TAG$1 + " | transfer | ";
        try {
          log$1.debug(tag, "tx: ", tx);
          let unsignedTx;
          let unsigned;
          let addressFrom;
          let addressTo;
          let masterInfo;
          let amountNative;
          let sequence;
          let account_number;
          let txType;
          let gas;
          let fee;
          let memo;
          let chain_id;
          const expr = tx.blockchain;
          switch (expr) {
            case "bitcoin":
            case "bitcoincash":
            case "litecoin":
            case "dogecoin":
              log$1.info(tag, "pubkey: ", tx.pubkey);
              log$1.info(tag, "tx.pubkey.symbol: ", tx.pubkey.symbol);
              let asset = COIN_MAP_LONG$1[tx.pubkey.symbol];
              if (!asset)
                throw Error("imable to get asset for network: " + tx.pubkey.symbol);
              let feeRateInfo = await this.pioneer.GetFeeInfo({ coin: tx.pubkey.symbol });
              feeRateInfo = feeRateInfo.data;
              if (feeRateInfo.fast && feeRateInfo.fast.satsPerKiloByte) {
                feeRateInfo = feeRateInfo.fast.satsPerKiloByte;
                feeRateInfo = feeRateInfo / 1e3;
              }
              if (!feeRateInfo)
                throw Error("Failed to get feeRateInfo!");
              log$1.debug(tag, "feeRateInfo: ", feeRateInfo);
              log$1.debug(tag, "tx.pubkey: ", tx.pubkey);
              if (!tx.pubkey.pubkey)
                throw Error("Failed to get pubkey!");
              if (tx.pubkey.pubkey.length < 10)
                throw Error("invalid pubkey!");
              log$1.info(tag, "tx.pubkey: ", tx.pubkey);
              let pubkey2 = tx.pubkey.pubkey;
              log$1.info(tag, "tx.pubkey.pubkey: ", tx.pubkey.pubkey);
              let unspentInputs = await this.pioneer.ListUnspent({ network: tx.pubkey.symbol, xpub: pubkey2 });
              unspentInputs = unspentInputs.data;
              log$1.debug(tag, "***** WTF unspentInputs: ", unspentInputs);
              let utxos = [];
              for (let i2 = 0; i2 < unspentInputs.length; i2++) {
                let input = unspentInputs[i2];
                if (!input.path)
                  throw Error("Invalid ListUnspent reponse! missing path!");
                let utxo = {
                  txId: input.txid,
                  vout: input.vout,
                  value: parseInt(input.value),
                  nonWitnessUtxo: buffer$1.Buffer.from(input.hex, "hex"),
                  hex: input.hex,
                  tx: input.tx,
                  path: input.path
                };
                utxos.push(utxo);
              }
              log$1.debug(tag, "utxos: ", utxos);
              if (utxos.length === 0) {
                throw Error("101 YOUR BROKE! no UTXO's found! pubkey: network:" + tx.pubkey.symbol + " pubkey" + pubkey2);
              }
              if (!tx.amount)
                throw Error("Invalid transfer Tx missing amount");
              let amountSat = parseInt(tx.amount * 1e8);
              log$1.debug(tag, "amountSat: ", amountSat);
              if (!tx.amount)
                throw Error("Invalid transfer Tx missing amount");
              let toAddress = tx.toAddress;
              if (!toAddress)
                throw Error("invalid tx missing toAddress");
              memo = null;
              if (tx.memo) {
                memo = tx.memo;
              }
              log$1.info(tag, "memo: ", memo);
              let selectedResults;
              let targets;
              log$1.info(tag, "tx.amount: ", tx.amount);
              if (tx.amount && typeof tx.amount === "string" && tx.amount === "MAX") {
                targets = [
                  {
                    address: toAddress
                  }
                ];
                log$1.debug(tag, "input coinSelect: ", { utxos, targets, feeRateInfo });
                selectedResults = (0, split_1.default)(utxos, targets, feeRateInfo);
                log$1.debug(tag, "result split algo: ", selectedResults);
                if (!selectedResults.inputs) {
                  throw Error("Fee exceeded total available inputs!");
                }
              } else {
                targets = [
                  {
                    address: toAddress,
                    value: amountSat
                  }
                ];
                if (!feeRateInfo)
                  throw Error("failed to get feeRateInfo!");
                log$1.debug(tag, "input coinSelect: ", { utxos, targets, feeRateInfo });
                selectedResults = coinSelect(utxos, targets, feeRateInfo);
                log$1.info(tag, "result coinselect algo: ", selectedResults);
                if (!selectedResults.inputs) {
                  throw Error("Fee exceeded total available inputs!");
                }
              }
              if (selectedResults.outputs.length == targets.length) {
                log$1.debug(tag, "No change address found!? checking");
              }
              let sumInputs = 0;
              for (let i2 = 0; i2 < selectedResults.inputs.length; i2++) {
                let amount = selectedResults.inputs[i2].value;
                sumInputs = sumInputs + amount;
              }
              let sumOut = 0;
              for (let i2 = 0; i2 < selectedResults.outputs.length; i2++) {
                let amount = selectedResults.outputs[i2].value;
                sumOut = sumOut + amount;
              }
              log$1.info(tag, "sumOut: ", sumOut);
              log$1.info(tag, "sumInputs: ", sumInputs);
              let feeVerify = sumInputs - sumOut;
              log$1.info(tag, "feeVerify: ", feeVerify);
              log$1.info(tag, "selectedResults.fee: ", selectedResults.fee);
              let inputs = [];
              for (let i2 = 0; i2 < selectedResults.inputs.length; i2++) {
                let inputInfo = selectedResults.inputs[i2];
                log$1.debug(tag, "inputInfo: ", inputInfo);
                if (!inputInfo.path)
                  throw Error("failed to get path for input!");
                let scriptType;
                if (tx.pubkey.symbol === "BTC") {
                  scriptType = "p2wpkh";
                } else if (tx.pubkey.symbol === "DOGE") {
                  log$1.info(tag, "DEBUG DOGE!");
                  scriptType = core.BTCInputScriptType.SpendAddress;
                } else {
                  scriptType = tx.pubkey.script_type;
                }
                log$1.info(tag, "inputInfo scriptType: ", scriptType);
                let input = {
                  addressNList: bip32ToAddressNList(inputInfo.path) || "",
                  scriptType,
                  //@TODO switch based on pubkey type
                  // scriptType:"p2wpkh",
                  // scriptType:"p2pkh",
                  // scriptType:core.BTCInputScriptType.SpendAddress,
                  // scriptType:core.BTCInputScriptType.SpendP2SHWitness,
                  // scriptType:core.BTCInputScriptType.SpendAddress,
                  // scriptType:core.BTCInputScriptType.SpendWitness,
                  amount: String(inputInfo.value),
                  vout: inputInfo.vout,
                  txid: inputInfo.txId,
                  // segwit:true,
                  // segwit:false,
                  hex: inputInfo.hex
                  // tx:inputInfo.tx
                };
                inputs.push(input);
              }
              log$1.debug(tag, "tx.pubkey: ", tx.pubkey);
              let changeAddress = tx.pubkey.address || tx.pubkey.master;
              if (!changeAddress)
                throw Error("Missing change address!!!");
              log$1.debug(tag, "*** changeAddress: ", changeAddress);
              const outputsFinal = [];
              log$1.debug(tag, "selectedResults.outputs: ", selectedResults.outputs);
              log$1.debug(tag, "outputsFinal: ", outputsFinal);
              for (let i2 = 0; i2 < selectedResults.outputs.length; i2++) {
                let outputInfo = selectedResults.outputs[i2];
                log$1.debug(tag, "outputInfo: ", outputInfo);
                if (outputInfo.address) {
                  if (tx.blockchain === "bitcoincash")
                    toAddress = "bitcoincash:" + toAddress;
                  let output2 = {
                    address: toAddress,
                    addressType: "spend",
                    // scriptType:core.BTCInputScriptType.SpendWitness,
                    amount: String(outputInfo.value)
                  };
                  outputsFinal.push(output2);
                } else {
                  if (!tx.pubkey.pathMaster)
                    throw Error("Invalid pubkey! missing pathMaster!");
                  log$1.info(tag, "pathMaster: ", tx.pubkey.pathMaster);
                  let scriptType;
                  if (tx.pubkey.symbol === "BTC") {
                    scriptType = core.BTCInputScriptType.SpendWitness;
                  } else if (tx.pubkey.symbol === "BCH") {
                    scriptType = "p2sh";
                  } else {
                    scriptType = core.BTCInputScriptType.SpendAddress;
                  }
                  log$1.info(tag, "scriptType: ", scriptType);
                  let output2 = {
                    // address:changeAddress,
                    //@TODO move this to last not used
                    //@TODO FOR THE LOVE GOD CHANGE THIS PER PUBKEY USED!
                    addressNList: bip32ToAddressNList(tx.pubkey.pathMaster),
                    // addressNList: bip32ToAddressNList("m/44'/0'/0'/0/0"),
                    // addressNList: bip32ToAddressNList("m/84'/0'/0'/0/0"),
                    addressType: "change",
                    // scriptType:'cashaddr',
                    scriptType,
                    // scriptType:core.BTCInputScriptType.SpendWitness,
                    amount: String(outputInfo.value),
                    isChange: true
                  };
                  outputsFinal.push(output2);
                }
              }
              log$1.debug(tag, "outputsFinal: ", outputsFinal);
              log$1.debug(tag, "outputsFinal: ", outputsFinal.length);
              log$1.debug(tag, "selectedResults.outputs.length: ", selectedResults.outputs.length);
              if (outputsFinal.length === selectedResults.outputs.length) {
                let hdwalletTxDescription = {
                  coin: COIN_MAP_KEEPKEY_LONG$1[tx.pubkey.symbol],
                  inputs,
                  outputs: outputsFinal
                  // version: 1,
                  // locktime: 0,
                };
                log$1.debug(tag, "hdwalletTxDescription: ", hdwalletTxDescription);
                if (memo) {
                  hdwalletTxDescription.opReturnData = memo;
                } else {
                  hdwalletTxDescription.opReturnData = "";
                }
                log$1.info(tag, "memo: ", memo);
                unsignedTx = hdwalletTxDescription;
                log$1.debug(tag, "unsignedTx pre: ", unsignedTx);
                log$1.debug(tag, "*** unsignedTx pre: ", JSON.stringify(unsignedTx));
              } else {
                throw Error("World makes no sense WTF");
              }
              break;
            case "avalanche":
            case "ethereum":
              log$1.info("EVM Tx type");
              log$1.info("tx: ", tx);
              log$1.info("tx.pubkey: ", tx.pubkey);
              let from2 = tx.pubkey.address || tx.pubkey.master;
              if (!from2)
                throw Error("Invalid pubkey! missing address(from)!");
              let gas_limit = 8e4;
              log$1.info(tag, "from: ", from2);
              let nonceRemote = await this.pioneer.GetNonce({ address: from2 });
              nonceRemote = nonceRemote.data;
              if (!nonceRemote)
                throw Error("unable to get nonce!");
              log$1.info(tag, "nonceRemote: ", nonceRemote);
              nonceRemote = parseInt(nonceRemote);
              let gas_price = await this.pioneer.GetGasPrice();
              gas_price = gas_price.data;
              log$1.info(tag, "gas_price: ", gas_price);
              gas_price = parseInt(gas_price);
              let nonce = nonceRemote;
              if (!nonce)
                throw Error("unable to get nonce!");
              log$1.info(tag, "nonce: ", nonce);
              let value2;
              let to;
              if (tx.asset !== "ETH") {
                to = tx.contract;
                log$1.info(tag, " Building ERC20 Tx");
                if (!tx.contract)
                  throw Error("Missing contract address!");
                if (!tx.amount)
                  throw Error("Missing amount!");
                let amount;
                if (tx.amount === "MAX") {
                  amount = tx.balance;
                } else {
                  amount = tx.amount;
                }
                let tokenData = await this.pioneer.GetTransferData({ toAddress: tx.toAddress, amount, contract: tx.contract });
                tokenData = tokenData.data;
                to = tx.contract;
                if (!tokenData)
                  throw Error("unable to get tokenData!");
                value2 = 0;
                log$1.info(tag, "tokenData: ", tokenData);
                tx.data = tokenData;
              } else {
                to = tx.toAddress;
                if (tx.amount === "MAX") {
                  let ethBalance = await this.pioneer.GetPubkeyBalance({ asset: "ETH", pubkey: from2 });
                  log$1.debug(tag, "ethBalance: ", ethBalance);
                  let ethBalanceBase = nativeToBaseAmount$1(ethBalance);
                  log$1.info(tag, "ethBalanceBase: ", ethBalanceBase);
                  let transfer_cost = 21001;
                  gas_limit = 21e3;
                  let txFee = new BigNumber(gas_price).times(transfer_cost);
                  log$1.info(tag, "txFee: ", txFee);
                  log$1.info(tag, "txFee: ", txFee.toString());
                  let amount = ethBalance.minus(txFee);
                  log$1.info(tag, "amount ALL: ", amount);
                  value2 = amount;
                } else {
                  value2 = baseAmountToNative$1("ETH", tx.amount);
                  if (!value2)
                    throw Error("unable to get value!");
                  log$1.debug(tag, "value: ", value2);
                }
              }
              if (!to)
                throw Error("unable to to address!");
              let chainId;
              if (tx.network === "ETH") {
                chainId = 1;
              } else if (tx.network === "AVAX") {
                chainId = 43114;
              } else {
                throw Error("Network not supported! network: " + tx.network);
              }
              log$1.info(tag, "gas_price: ", gas_price);
              log$1.info(tag, "gas_limit: ", gas_limit);
              let ethTx = {
                // addressNList: support.bip32ToAddressNList(masterPathEth),
                from: from2,
                "addressNList": [
                  2147483692,
                  2147483708,
                  2147483648,
                  0,
                  0
                ],
                data: tx.data || "",
                nonce: numberToHex(nonce),
                gasPrice: numberToHex(gas_price),
                gasLimit: numberToHex(gas_limit),
                value: numberToHex(value2),
                to,
                chainId: numberToHex(chainId)
              };
              log$1.info(tag, "ethTx: ", ethTx);
              let payload = ethTx;
              if (!payload.data)
                payload.data = "0x";
              let result = await this.pioneer.SmartInsight(payload);
              let insight = result.data;
              log$1.info(tag, "insight: ", insight);
              if (insight.recommended.gasPrice) {
                ethTx.gasPrice = insight.recommended.gasPrice;
              } else {
                delete ethTx.gasPrice;
              }
              if (insight.recommended.maxFeePerGas) {
                ethTx.maxFeePerGas = insight.recommended.maxFeePerGas;
              }
              if (insight.recommended.maxPriorityFeePerGas) {
                ethTx.maxPriorityFeePerGas = insight.recommended.maxPriorityFeePerGas;
              }
              unsignedTx = ethTx;
              log$1.info(tag, "unsignedTx: ", unsignedTx);
              break;
            case "thorchain":
              amountNative = baseAmountToNative$1(tx.asset, tx.amount);
              log$1.debug(tag, "amountNative: ", amountNative);
              log$1.info(tag, "tx: ", tx);
              addressFrom = tx.pubkey.address || tx.pubkey.master;
              if (!addressFrom)
                throw Error("Missing, addressFrom!");
              if (!tx.toAddress)
                throw Error("Missing, toAddress!");
              masterInfo = await this.pioneer.GetAccountInfo({ network: "RUNE", address: addressFrom });
              masterInfo = masterInfo.data;
              log$1.info(tag, "masterInfo: ", masterInfo.data);
              sequence = masterInfo.result.value.sequence || 0;
              account_number = masterInfo.result.value.account_number;
              sequence = parseInt(sequence);
              sequence = sequence.toString();
              log$1.info(tag, "sequence: ", sequence);
              txType = "thorchain/MsgSend";
              gas = "650000";
              fee = "0";
              let memoThorchain = tx.memo || "";
              unsigned = {
                "fee": {
                  "amount": [
                    {
                      "amount": fee,
                      "denom": "rune"
                    }
                  ],
                  "gas": gas
                },
                "memo": memoThorchain,
                "msg": [
                  {
                    "type": txType,
                    "value": {
                      "amount": [
                        {
                          "amount": amountNative.toString(),
                          "denom": "rune"
                        }
                      ],
                      "from_address": addressFrom,
                      "to_address": tx.toAddress
                    }
                  }
                ],
                sequence,
                account_number,
                "signatures": null
              };
              chain_id = RUNE_CHAIN;
              if (!sequence)
                throw Error("112: Failed to get sequence");
              if (!account_number)
                account_number = 0;
              let runeTx = {
                addressNList: bip32ToAddressNList(HD_RUNE_KEYPATH),
                chain_id,
                account_number,
                sequence,
                tx: unsigned
              };
              unsignedTx = runeTx;
              break;
            case "osmosis":
              addressFrom = tx.pubkey.address || tx.pubkey.master;
              if (!addressFrom)
                throw Error("Missing, addressFrom!");
              if (!tx.toAddress)
                throw Error("Missing, toAddress!");
              amountNative = baseAmountToNative$1(tx.asset, tx.amount);
              log$1.debug(tag, "amountNative: ", amountNative);
              log$1.debug(tag, "addressFrom: ", addressFrom);
              masterInfo = await this.pioneer.GetAccountInfo({ network: "OSMO", address: addressFrom });
              masterInfo = masterInfo.data;
              log$1.debug(tag, "masterInfo: ", masterInfo.data);
              sequence = masterInfo.result.value.sequence;
              account_number = masterInfo.result.value.account_number;
              sequence = parseInt(sequence);
              sequence = sequence.toString();
              txType = "cosmos-sdk/MsgSend";
              gas = "100000";
              fee = "1000";
              memo = tx.memo || "";
              unsigned = {
                "fee": {
                  "amount": [
                    {
                      "amount": fee,
                      "denom": "uosmo"
                    }
                  ],
                  "gas": gas
                },
                "memo": memo,
                "msg": [
                  {
                    "type": txType,
                    "value": {
                      "amount": [
                        {
                          "amount": amountNative.toString(),
                          "denom": "uosmo"
                        }
                      ],
                      "from_address": addressFrom,
                      "to_address": tx.toAddress
                    }
                  }
                ],
                "signatures": []
              };
              chain_id = OSMO_CHAIN;
              if (!sequence)
                throw Error("112: Failed to get sequence");
              if (!account_number)
                throw Error("113: Failed to get account_number");
              let osmoTx = {
                addressNList: bip32ToAddressNList(HD_ATOM_KEYPATH),
                chain_id,
                account_number,
                sequence,
                tx: unsigned
              };
              unsignedTx = osmoTx;
              break;
            case "cosmos":
              addressFrom = tx.pubkey.address || tx.pubkey.master;
              if (!addressFrom)
                throw Error("Missing, addressFrom!");
              if (!tx.toAddress)
                throw Error("Missing, toAddress!");
              amountNative = baseAmountToNative$1(tx.asset, tx.amount);
              log$1.debug(tag, "amountNative: ", amountNative);
              log$1.debug(tag, "addressFrom: ", addressFrom);
              masterInfo = await this.pioneer.GetAccountInfo({ network: "ATOM", address: addressFrom });
              masterInfo = masterInfo.data;
              log$1.debug(tag, "masterInfo: ", masterInfo.data);
              sequence = masterInfo.result.value.sequence;
              account_number = masterInfo.result.value.account_number;
              sequence = parseInt(sequence);
              sequence = sequence.toString();
              txType = "cosmos-sdk/MsgSend";
              gas = "100000";
              fee = "1000";
              memo = tx.memo || "";
              unsigned = {
                "fee": {
                  "amount": [
                    {
                      "amount": fee,
                      "denom": "uatom"
                    }
                  ],
                  "gas": gas
                },
                "memo": memo,
                "msg": [
                  {
                    "type": txType,
                    "value": {
                      "amount": [
                        {
                          "amount": amountNative.toString(),
                          "denom": "uatom"
                        }
                      ],
                      "from_address": addressFrom,
                      "to_address": tx.toAddress
                    }
                  }
                ],
                "signatures": []
              };
              chain_id = ATOM_CHAIN;
              if (!sequence)
                throw Error("112: Failed to get sequence");
              if (!account_number)
                throw Error("113: Failed to get account_number");
              let atomTx = {
                addressNList: bip32ToAddressNList(HD_ATOM_KEYPATH),
                chain_id,
                account_number,
                sequence,
                tx: unsigned
              };
              unsignedTx = atomTx;
              break;
            case "binance":
              addressFrom = tx.pubkey.address || tx.pubkey.master;
              log$1.info(tag, "addressFrom: ", addressFrom);
              if (!addressFrom)
                throw Error("Missing, addressFrom!");
              if (!tx.toAddress)
                throw Error("Missing, toAddress!");
              amountNative = baseAmountToNative$1(tx.asset, tx.amount);
              log$1.debug(tag, "amountNative: ", amountNative);
              log$1.debug(tag, "addressFrom: ", addressFrom);
              masterInfo = await this.pioneer.GetAccountInfo({ network: "BNB", address: addressFrom });
              masterInfo = masterInfo.data;
              log$1.info(tag, "masterInfo: ", masterInfo);
              sequence = masterInfo.sequence.toString();
              account_number = masterInfo.account_number.toString();
              if (account_number === "0")
                throw Error("Can NOT send! this account has never received any BNB! no account_number known!");
              log$1.info(tag, "sequence: ", sequence);
              log$1.info(tag, "account_number: ", account_number);
              if (!sequence)
                throw Error("Failed to get BNB sequence!");
              if (!account_number)
                throw Error("Failed to get BNB account_number!");
              memo = tx.memo || "";
              let bnbTx = {
                account_number,
                "chain_id": "Binance-Chain-Nile",
                "data": null,
                "memo": memo,
                "msgs": [
                  {
                    "inputs": [
                      {
                        "address": addressFrom,
                        "coins": [
                          {
                            "amount": amountNative,
                            "denom": "BNB"
                          }
                        ]
                      }
                    ],
                    "outputs": [
                      {
                        "address": tx.toAddress,
                        "coins": [
                          {
                            "amount": amountNative,
                            "denom": "BNB"
                          }
                        ]
                      }
                    ]
                  }
                ],
                "sequence": sequence,
                "source": "0"
              };
              unsignedTx = {
                addressNList: bip32ToAddressNList(`m/44'/714'/0'/0/0`),
                chain_id: "Binance-Chain-Nile",
                account_number,
                sequence,
                tx: bnbTx
              };
              break;
            default:
              throw Error("unhandled! transfer: " + expr);
          }
          log$1.debug(tag, "unsignedTx FINAL: ", unsignedTx);
          return unsignedTx;
        } catch (e) {
          log$1.error(tag, "e: ", e);
        }
      };
      this.buildTx = async function(tx) {
        let tag = TAG$1 + " | buildTx | ";
        try {
          let txUnsigned = await this.transfer(tx);
          log$1.debug(tag, "txUnsigned: final ", txUnsigned);
          if (!txUnsigned)
            throw Error("Failed to build unsignedTx!");
          return txUnsigned;
        } catch (e) {
          log$1.error(tag, "e: ", e);
        }
      };
    }
  };
  lib$3.TxBuilder = TxBuilder$1;
  var lib$1 = {};
  const require$$0 = /* @__PURE__ */ getAugmentedNamespace(events);
  var cjs$3 = { exports: {} };
  var url$1 = {};
  var cjs$2 = {};
  var socket$1 = {};
  var transports = {};
  var polling = {};
  var transport = {};
  var cjs$1 = {};
  var encodePacket_browser = {};
  var commons = {};
  Object.defineProperty(commons, "__esModule", { value: true });
  commons.ERROR_PACKET = commons.PACKET_TYPES_REVERSE = commons.PACKET_TYPES = void 0;
  const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
  commons.PACKET_TYPES = PACKET_TYPES;
  PACKET_TYPES["open"] = "0";
  PACKET_TYPES["close"] = "1";
  PACKET_TYPES["ping"] = "2";
  PACKET_TYPES["pong"] = "3";
  PACKET_TYPES["message"] = "4";
  PACKET_TYPES["upgrade"] = "5";
  PACKET_TYPES["noop"] = "6";
  const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
  commons.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;
  Object.keys(PACKET_TYPES).forEach((key) => {
    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
  });
  const ERROR_PACKET = { type: "error", data: "parser error" };
  commons.ERROR_PACKET = ERROR_PACKET;
  Object.defineProperty(encodePacket_browser, "__esModule", { value: true });
  encodePacket_browser.encodePacket = encodePacket_browser.encodePacketToBinary = void 0;
  const commons_js_1$1 = commons;
  const withNativeBlob$1 = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
  const withNativeArrayBuffer$2 = typeof ArrayBuffer === "function";
  const isView$1 = (obj) => {
    return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
  };
  const encodePacket = ({ type: type2, data: data2 }, supportsBinary, callback) => {
    if (withNativeBlob$1 && data2 instanceof Blob) {
      if (supportsBinary) {
        return callback(data2);
      } else {
        return encodeBlobAsBase64(data2, callback);
      }
    } else if (withNativeArrayBuffer$2 && (data2 instanceof ArrayBuffer || isView$1(data2))) {
      if (supportsBinary) {
        return callback(data2);
      } else {
        return encodeBlobAsBase64(new Blob([data2]), callback);
      }
    }
    return callback(commons_js_1$1.PACKET_TYPES[type2] + (data2 || ""));
  };
  encodePacket_browser.encodePacket = encodePacket;
  const encodeBlobAsBase64 = (data2, callback) => {
    const fileReader = new FileReader();
    fileReader.onload = function() {
      const content = fileReader.result.split(",")[1];
      callback("b" + (content || ""));
    };
    return fileReader.readAsDataURL(data2);
  };
  function toArray(data2) {
    if (data2 instanceof Uint8Array) {
      return data2;
    } else if (data2 instanceof ArrayBuffer) {
      return new Uint8Array(data2);
    } else {
      return new Uint8Array(data2.buffer, data2.byteOffset, data2.byteLength);
    }
  }
  let TEXT_ENCODER;
  function encodePacketToBinary(packet, callback) {
    if (withNativeBlob$1 && packet.data instanceof Blob) {
      return packet.data.arrayBuffer().then(toArray).then(callback);
    } else if (withNativeArrayBuffer$2 && (packet.data instanceof ArrayBuffer || isView$1(packet.data))) {
      return callback(toArray(packet.data));
    }
    encodePacket(packet, false, (encoded) => {
      if (!TEXT_ENCODER) {
        TEXT_ENCODER = new TextEncoder();
      }
      callback(TEXT_ENCODER.encode(encoded));
    });
  }
  encodePacket_browser.encodePacketToBinary = encodePacketToBinary;
  var decodePacket_browser = {};
  var base64Arraybuffer = {};
  Object.defineProperty(base64Arraybuffer, "__esModule", { value: true });
  base64Arraybuffer.decode = base64Arraybuffer.encode = void 0;
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  const lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
  for (let i2 = 0; i2 < chars.length; i2++) {
    lookup[chars.charCodeAt(i2)] = i2;
  }
  const encode$2 = (arraybuffer) => {
    let bytes2 = new Uint8Array(arraybuffer), i2, len2 = bytes2.length, base64 = "";
    for (i2 = 0; i2 < len2; i2 += 3) {
      base64 += chars[bytes2[i2] >> 2];
      base64 += chars[(bytes2[i2] & 3) << 4 | bytes2[i2 + 1] >> 4];
      base64 += chars[(bytes2[i2 + 1] & 15) << 2 | bytes2[i2 + 2] >> 6];
      base64 += chars[bytes2[i2 + 2] & 63];
    }
    if (len2 % 3 === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len2 % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }
    return base64;
  };
  base64Arraybuffer.encode = encode$2;
  const decode$2 = (base64) => {
    let bufferLength = base64.length * 0.75, len2 = base64.length, i2, p2 = 0, encoded1, encoded2, encoded3, encoded4;
    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }
    const arraybuffer = new ArrayBuffer(bufferLength), bytes2 = new Uint8Array(arraybuffer);
    for (i2 = 0; i2 < len2; i2 += 4) {
      encoded1 = lookup[base64.charCodeAt(i2)];
      encoded2 = lookup[base64.charCodeAt(i2 + 1)];
      encoded3 = lookup[base64.charCodeAt(i2 + 2)];
      encoded4 = lookup[base64.charCodeAt(i2 + 3)];
      bytes2[p2++] = encoded1 << 2 | encoded2 >> 4;
      bytes2[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
      bytes2[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return arraybuffer;
  };
  base64Arraybuffer.decode = decode$2;
  Object.defineProperty(decodePacket_browser, "__esModule", { value: true });
  decodePacket_browser.decodePacket = void 0;
  const commons_js_1 = commons;
  const base64_arraybuffer_js_1 = base64Arraybuffer;
  const withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";
  const decodePacket = (encodedPacket, binaryType) => {
    if (typeof encodedPacket !== "string") {
      return {
        type: "message",
        data: mapBinary(encodedPacket, binaryType)
      };
    }
    const type2 = encodedPacket.charAt(0);
    if (type2 === "b") {
      return {
        type: "message",
        data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
      };
    }
    const packetType = commons_js_1.PACKET_TYPES_REVERSE[type2];
    if (!packetType) {
      return commons_js_1.ERROR_PACKET;
    }
    return encodedPacket.length > 1 ? {
      type: commons_js_1.PACKET_TYPES_REVERSE[type2],
      data: encodedPacket.substring(1)
    } : {
      type: commons_js_1.PACKET_TYPES_REVERSE[type2]
    };
  };
  decodePacket_browser.decodePacket = decodePacket;
  const decodeBase64Packet = (data2, binaryType) => {
    if (withNativeArrayBuffer$1) {
      const decoded = (0, base64_arraybuffer_js_1.decode)(data2);
      return mapBinary(decoded, binaryType);
    } else {
      return { base64: true, data: data2 };
    }
  };
  const mapBinary = (data2, binaryType) => {
    switch (binaryType) {
      case "blob":
        if (data2 instanceof Blob) {
          return data2;
        } else {
          return new Blob([data2]);
        }
      case "arraybuffer":
      default:
        if (data2 instanceof ArrayBuffer) {
          return data2;
        } else {
          return data2.buffer;
        }
    }
  };
  (function(exports3) {
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.decodePayload = exports3.decodePacket = exports3.encodePayload = exports3.encodePacket = exports3.protocol = exports3.createPacketDecoderStream = exports3.createPacketEncoderStream = void 0;
    const encodePacket_js_1 = encodePacket_browser;
    Object.defineProperty(exports3, "encodePacket", { enumerable: true, get: function() {
      return encodePacket_js_1.encodePacket;
    } });
    const decodePacket_js_1 = decodePacket_browser;
    Object.defineProperty(exports3, "decodePacket", { enumerable: true, get: function() {
      return decodePacket_js_1.decodePacket;
    } });
    const commons_js_12 = commons;
    const SEPARATOR = String.fromCharCode(30);
    const encodePayload = (packets, callback) => {
      const length2 = packets.length;
      const encodedPackets = new Array(length2);
      let count2 = 0;
      packets.forEach((packet, i2) => {
        (0, encodePacket_js_1.encodePacket)(packet, false, (encodedPacket) => {
          encodedPackets[i2] = encodedPacket;
          if (++count2 === length2) {
            callback(encodedPackets.join(SEPARATOR));
          }
        });
      });
    };
    exports3.encodePayload = encodePayload;
    const decodePayload = (encodedPayload, binaryType) => {
      const encodedPackets = encodedPayload.split(SEPARATOR);
      const packets = [];
      for (let i2 = 0; i2 < encodedPackets.length; i2++) {
        const decodedPacket = (0, decodePacket_js_1.decodePacket)(encodedPackets[i2], binaryType);
        packets.push(decodedPacket);
        if (decodedPacket.type === "error") {
          break;
        }
      }
      return packets;
    };
    exports3.decodePayload = decodePayload;
    function createPacketEncoderStream() {
      return new TransformStream({
        transform(packet, controller) {
          (0, encodePacket_js_1.encodePacketToBinary)(packet, (encodedPacket) => {
            const payloadLength = encodedPacket.length;
            let header2;
            if (payloadLength < 126) {
              header2 = new Uint8Array(1);
              new DataView(header2.buffer).setUint8(0, payloadLength);
            } else if (payloadLength < 65536) {
              header2 = new Uint8Array(3);
              const view = new DataView(header2.buffer);
              view.setUint8(0, 126);
              view.setUint16(1, payloadLength);
            } else {
              header2 = new Uint8Array(9);
              const view = new DataView(header2.buffer);
              view.setUint8(0, 127);
              view.setBigUint64(1, BigInt(payloadLength));
            }
            if (packet.data && typeof packet.data !== "string") {
              header2[0] |= 128;
            }
            controller.enqueue(header2);
            controller.enqueue(encodedPacket);
          });
        }
      });
    }
    exports3.createPacketEncoderStream = createPacketEncoderStream;
    let TEXT_DECODER;
    function totalLength(chunks) {
      return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
    }
    function concatChunks(chunks, size) {
      if (chunks[0].length === size) {
        return chunks.shift();
      }
      const buffer2 = new Uint8Array(size);
      let j = 0;
      for (let i2 = 0; i2 < size; i2++) {
        buffer2[i2] = chunks[0][j++];
        if (j === chunks[0].length) {
          chunks.shift();
          j = 0;
        }
      }
      if (chunks.length && j < chunks[0].length) {
        chunks[0] = chunks[0].slice(j);
      }
      return buffer2;
    }
    function createPacketDecoderStream(maxPayload, binaryType) {
      if (!TEXT_DECODER) {
        TEXT_DECODER = new TextDecoder();
      }
      const chunks = [];
      let state2 = 0;
      let expectedLength = -1;
      let isBinary2 = false;
      return new TransformStream({
        transform(chunk, controller) {
          chunks.push(chunk);
          while (true) {
            if (state2 === 0) {
              if (totalLength(chunks) < 1) {
                break;
              }
              const header2 = concatChunks(chunks, 1);
              isBinary2 = (header2[0] & 128) === 128;
              expectedLength = header2[0] & 127;
              if (expectedLength < 126) {
                state2 = 3;
              } else if (expectedLength === 126) {
                state2 = 1;
              } else {
                state2 = 2;
              }
            } else if (state2 === 1) {
              if (totalLength(chunks) < 2) {
                break;
              }
              const headerArray = concatChunks(chunks, 2);
              expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
              state2 = 3;
            } else if (state2 === 2) {
              if (totalLength(chunks) < 8) {
                break;
              }
              const headerArray = concatChunks(chunks, 8);
              const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
              const n2 = view.getUint32(0);
              if (n2 > Math.pow(2, 53 - 32) - 1) {
                controller.enqueue(commons_js_12.ERROR_PACKET);
                break;
              }
              expectedLength = n2 * Math.pow(2, 32) + view.getUint32(4);
              state2 = 3;
            } else {
              if (totalLength(chunks) < expectedLength) {
                break;
              }
              const data2 = concatChunks(chunks, expectedLength);
              controller.enqueue((0, decodePacket_js_1.decodePacket)(isBinary2 ? data2 : TEXT_DECODER.decode(data2), binaryType));
              state2 = 0;
            }
            if (expectedLength === 0 || expectedLength > maxPayload) {
              controller.enqueue(commons_js_12.ERROR_PACKET);
              break;
            }
          }
        }
      });
    }
    exports3.createPacketDecoderStream = createPacketDecoderStream;
    exports3.protocol = 4;
  })(cjs$1);
  function Emitter(obj) {
    if (obj)
      return mixin(obj);
  }
  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }
    return obj;
  }
  Emitter.prototype.on = Emitter.prototype.addEventListener = function(event2, fn) {
    this._callbacks = this._callbacks || {};
    (this._callbacks["$" + event2] = this._callbacks["$" + event2] || []).push(fn);
    return this;
  };
  Emitter.prototype.once = function(event2, fn) {
    function on2() {
      this.off(event2, on2);
      fn.apply(this, arguments);
    }
    on2.fn = fn;
    this.on(event2, on2);
    return this;
  };
  Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event2, fn) {
    this._callbacks = this._callbacks || {};
    if (0 == arguments.length) {
      this._callbacks = {};
      return this;
    }
    var callbacks = this._callbacks["$" + event2];
    if (!callbacks)
      return this;
    if (1 == arguments.length) {
      delete this._callbacks["$" + event2];
      return this;
    }
    var cb;
    for (var i2 = 0; i2 < callbacks.length; i2++) {
      cb = callbacks[i2];
      if (cb === fn || cb.fn === fn) {
        callbacks.splice(i2, 1);
        break;
      }
    }
    if (callbacks.length === 0) {
      delete this._callbacks["$" + event2];
    }
    return this;
  };
  Emitter.prototype.emit = function(event2) {
    this._callbacks = this._callbacks || {};
    var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event2];
    for (var i2 = 1; i2 < arguments.length; i2++) {
      args[i2 - 1] = arguments[i2];
    }
    if (callbacks) {
      callbacks = callbacks.slice(0);
      for (var i2 = 0, len2 = callbacks.length; i2 < len2; ++i2) {
        callbacks[i2].apply(this, args);
      }
    }
    return this;
  };
  Emitter.prototype.emitReserved = Emitter.prototype.emit;
  Emitter.prototype.listeners = function(event2) {
    this._callbacks = this._callbacks || {};
    return this._callbacks["$" + event2] || [];
  };
  Emitter.prototype.hasListeners = function(event2) {
    return !!this.listeners(event2).length;
  };
  const componentEmitter = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    Emitter
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$5 = /* @__PURE__ */ getAugmentedNamespace(componentEmitter);
  var util = {};
  var globalThis_browser = {};
  Object.defineProperty(globalThis_browser, "__esModule", { value: true });
  globalThis_browser.globalThisShim = void 0;
  globalThis_browser.globalThisShim = (() => {
    if (typeof self !== "undefined") {
      return self;
    } else if (typeof window !== "undefined") {
      return window;
    } else {
      return Function("return this")();
    }
  })();
  Object.defineProperty(util, "__esModule", { value: true });
  util.byteLength = util.installTimerFunctions = util.pick = void 0;
  const globalThis_js_1$3 = globalThis_browser;
  function pick(obj, ...attr) {
    return attr.reduce((acc, k2) => {
      if (obj.hasOwnProperty(k2)) {
        acc[k2] = obj[k2];
      }
      return acc;
    }, {});
  }
  util.pick = pick;
  const NATIVE_SET_TIMEOUT = globalThis_js_1$3.globalThisShim.setTimeout;
  const NATIVE_CLEAR_TIMEOUT = globalThis_js_1$3.globalThisShim.clearTimeout;
  function installTimerFunctions(obj, opts) {
    if (opts.useNativeTimers) {
      obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis_js_1$3.globalThisShim);
      obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis_js_1$3.globalThisShim);
    } else {
      obj.setTimeoutFn = globalThis_js_1$3.globalThisShim.setTimeout.bind(globalThis_js_1$3.globalThisShim);
      obj.clearTimeoutFn = globalThis_js_1$3.globalThisShim.clearTimeout.bind(globalThis_js_1$3.globalThisShim);
    }
  }
  util.installTimerFunctions = installTimerFunctions;
  const BASE64_OVERHEAD = 1.33;
  function byteLength(obj) {
    if (typeof obj === "string") {
      return utf8Length(obj);
    }
    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
  }
  util.byteLength = byteLength;
  function utf8Length(str2) {
    let c = 0, length2 = 0;
    for (let i2 = 0, l2 = str2.length; i2 < l2; i2++) {
      c = str2.charCodeAt(i2);
      if (c < 128) {
        length2 += 1;
      } else if (c < 2048) {
        length2 += 2;
      } else if (c < 55296 || c >= 57344) {
        length2 += 3;
      } else {
        i2++;
        length2 += 4;
      }
    }
    return length2;
  }
  var browser = { exports: {} };
  var ms;
  var hasRequiredMs;
  function requireMs() {
    if (hasRequiredMs)
      return ms;
    hasRequiredMs = 1;
    var s = 1e3;
    var m2 = s * 60;
    var h = m2 * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    ms = function(val, options) {
      options = options || {};
      var type2 = typeof val;
      if (type2 === "string" && val.length > 0) {
        return parse2(val);
      } else if (type2 === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str2) {
      str2 = String(str2);
      if (str2.length > 100) {
        return;
      }
      var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str2
      );
      if (!match2) {
        return;
      }
      var n2 = parseFloat(match2[1]);
      var type2 = (match2[2] || "ms").toLowerCase();
      switch (type2) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y;
        case "weeks":
        case "week":
        case "w":
          return n2 * w;
        case "days":
        case "day":
        case "d":
          return n2 * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    function fmtShort(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d) {
        return Math.round(ms2 / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms2 / h) + "h";
      }
      if (msAbs >= m2) {
        return Math.round(ms2 / m2) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms2 / s) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d) {
        return plural(ms2, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms2, msAbs, h, "hour");
      }
      if (msAbs >= m2) {
        return plural(ms2, msAbs, m2, "minute");
      }
      if (msAbs >= s) {
        return plural(ms2, msAbs, s, "second");
      }
      return ms2 + " ms";
    }
    function plural(ms2, msAbs, n2, name) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms2 / n2) + " " + name + (isPlural ? "s" : "");
    }
    return ms;
  }
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace2) {
      let hash2 = 0;
      for (let i2 = 0; i2 < namespace2.length; i2++) {
        hash2 = (hash2 << 5) - hash2 + namespace2.charCodeAt(i2);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace2) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format) => {
          if (match2 === "%%") {
            return "%";
          }
          index2++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index2];
            match2 = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match2;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace2;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace2);
      debug2.extend = extend2;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace2);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend2(namespace2, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace2);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i2;
      const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len2 = split2.length;
      for (i2 = 0; i2 < len2; i2++) {
        if (!split2[i2]) {
          continue;
        }
        namespaces = split2[i2].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace2) => "-" + namespace2)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i2;
      let len2;
      for (i2 = 0, len2 = createDebug.skips.length; i2 < len2; i2++) {
        if (createDebug.skips[i2].test(name)) {
          return false;
        }
      }
      for (i2 = 0, len2 = createDebug.names.length; i2 < len2; i2++) {
        if (createDebug.names[i2].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  var common = setup;
  (function(module2, exports3) {
    exports3.formatArgs = formatArgs;
    exports3.save = save;
    exports3.load = load2;
    exports3.useColors = useColors;
    exports3.storage = localstorage();
    exports3.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports3.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match2) => {
        if (match2 === "%%") {
          return;
        }
        index2++;
        if (match2 === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports3.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports3.storage.setItem("debug", namespaces);
        } else {
          exports3.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load2() {
      let r;
      try {
        r = exports3.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process$2 !== "undefined" && "env" in process$2) {
        r = process$2.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = common(exports3);
    const { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  })(browser, browser.exports);
  var browserExports = browser.exports;
  var parseqs = {};
  Object.defineProperty(parseqs, "__esModule", { value: true });
  parseqs.decode = parseqs.encode = void 0;
  function encode$1(obj) {
    let str2 = "";
    for (let i2 in obj) {
      if (obj.hasOwnProperty(i2)) {
        if (str2.length)
          str2 += "&";
        str2 += encodeURIComponent(i2) + "=" + encodeURIComponent(obj[i2]);
      }
    }
    return str2;
  }
  parseqs.encode = encode$1;
  function decode$1(qs2) {
    let qry = {};
    let pairs2 = qs2.split("&");
    for (let i2 = 0, l2 = pairs2.length; i2 < l2; i2++) {
      let pair = pairs2[i2].split("=");
      qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
    }
    return qry;
  }
  parseqs.decode = decode$1;
  var __importDefault$8 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(transport, "__esModule", { value: true });
  transport.Transport = void 0;
  const engine_io_parser_1$4 = cjs$1;
  const component_emitter_1$4 = require$$5;
  const util_js_1$3 = util;
  const debug_1$7 = __importDefault$8(browserExports);
  const parseqs_js_1$1 = parseqs;
  const debug$7 = (0, debug_1$7.default)("engine.io-client:transport");
  class TransportError extends Error {
    constructor(reason, description, context2) {
      super(reason);
      this.description = description;
      this.context = context2;
      this.type = "TransportError";
    }
  }
  class Transport extends component_emitter_1$4.Emitter {
    /**
     * Transport abstract constructor.
     *
     * @param {Object} opts - options
     * @protected
     */
    constructor(opts) {
      super();
      this.writable = false;
      (0, util_js_1$3.installTimerFunctions)(this, opts);
      this.opts = opts;
      this.query = opts.query;
      this.socket = opts.socket;
    }
    /**
     * Emits an error.
     *
     * @param {String} reason
     * @param description
     * @param context - the error context
     * @return {Transport} for chaining
     * @protected
     */
    onError(reason, description, context2) {
      super.emitReserved("error", new TransportError(reason, description, context2));
      return this;
    }
    /**
     * Opens the transport.
     */
    open() {
      this.readyState = "opening";
      this.doOpen();
      return this;
    }
    /**
     * Closes the transport.
     */
    close() {
      if (this.readyState === "opening" || this.readyState === "open") {
        this.doClose();
        this.onClose();
      }
      return this;
    }
    /**
     * Sends multiple packets.
     *
     * @param {Array} packets
     */
    send(packets) {
      if (this.readyState === "open") {
        this.write(packets);
      } else {
        debug$7("transport is not open, discarding packets");
      }
    }
    /**
     * Called upon open
     *
     * @protected
     */
    onOpen() {
      this.readyState = "open";
      this.writable = true;
      super.emitReserved("open");
    }
    /**
     * Called with data.
     *
     * @param {String} data
     * @protected
     */
    onData(data2) {
      const packet = (0, engine_io_parser_1$4.decodePacket)(data2, this.socket.binaryType);
      this.onPacket(packet);
    }
    /**
     * Called with a decoded packet.
     *
     * @protected
     */
    onPacket(packet) {
      super.emitReserved("packet", packet);
    }
    /**
     * Called upon close.
     *
     * @protected
     */
    onClose(details) {
      this.readyState = "closed";
      super.emitReserved("close", details);
    }
    /**
     * Pauses the transport, in order not to lose packets during an upgrade.
     *
     * @param onPause
     */
    pause(onPause) {
    }
    createUri(schema2, query2 = {}) {
      return schema2 + "://" + this._hostname() + this._port() + this.opts.path + this._query(query2);
    }
    _hostname() {
      const hostname = this.opts.hostname;
      return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
    }
    _port() {
      if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
        return ":" + this.opts.port;
      } else {
        return "";
      }
    }
    _query(query2) {
      const encodedQuery = (0, parseqs_js_1$1.encode)(query2);
      return encodedQuery.length ? "?" + encodedQuery : "";
    }
  }
  transport.Transport = Transport;
  var yeast$1 = {};
  Object.defineProperty(yeast$1, "__esModule", { value: true });
  yeast$1.yeast = yeast$1.decode = yeast$1.encode = void 0;
  const alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map = {};
  let seed = 0, i = 0, prev;
  function encode(num) {
    let encoded = "";
    do {
      encoded = alphabet[num % length] + encoded;
      num = Math.floor(num / length);
    } while (num > 0);
    return encoded;
  }
  yeast$1.encode = encode;
  function decode(str2) {
    let decoded = 0;
    for (i = 0; i < str2.length; i++) {
      decoded = decoded * length + map[str2.charAt(i)];
    }
    return decoded;
  }
  yeast$1.decode = decode;
  function yeast() {
    const now = encode(+/* @__PURE__ */ new Date());
    if (now !== prev)
      return seed = 0, prev = now;
    return now + "." + encode(seed++);
  }
  yeast$1.yeast = yeast;
  for (; i < length; i++)
    map[alphabet[i]] = i;
  var xmlhttprequest_browser = {};
  var hasCors = {};
  Object.defineProperty(hasCors, "__esModule", { value: true });
  hasCors.hasCORS = void 0;
  let value = false;
  try {
    value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
  } catch (err) {
  }
  hasCors.hasCORS = value;
  Object.defineProperty(xmlhttprequest_browser, "__esModule", { value: true });
  xmlhttprequest_browser.createCookieJar = xmlhttprequest_browser.XHR = void 0;
  const has_cors_js_1 = hasCors;
  const globalThis_js_1$2 = globalThis_browser;
  function XHR(opts) {
    const xdomain = opts.xdomain;
    try {
      if ("undefined" !== typeof XMLHttpRequest && (!xdomain || has_cors_js_1.hasCORS)) {
        return new XMLHttpRequest();
      }
    } catch (e) {
    }
    if (!xdomain) {
      try {
        return new globalThis_js_1$2.globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
      } catch (e) {
      }
    }
  }
  xmlhttprequest_browser.XHR = XHR;
  function createCookieJar() {
  }
  xmlhttprequest_browser.createCookieJar = createCookieJar;
  var __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(polling, "__esModule", { value: true });
  polling.Request = polling.Polling = void 0;
  const transport_js_1$2 = transport;
  const debug_1$6 = __importDefault$7(browserExports);
  const yeast_js_1$1 = yeast$1;
  const engine_io_parser_1$3 = cjs$1;
  const xmlhttprequest_js_1 = xmlhttprequest_browser;
  const component_emitter_1$3 = require$$5;
  const util_js_1$2 = util;
  const globalThis_js_1$1 = globalThis_browser;
  const debug$6 = (0, debug_1$6.default)("engine.io-client:polling");
  function empty() {
  }
  const hasXHR2 = function() {
    const xhr = new xmlhttprequest_js_1.XHR({
      xdomain: false
    });
    return null != xhr.responseType;
  }();
  class Polling extends transport_js_1$2.Transport {
    /**
     * XHR Polling constructor.
     *
     * @param {Object} opts
     * @package
     */
    constructor(opts) {
      super(opts);
      this.polling = false;
      if (typeof location !== "undefined") {
        const isSSL = "https:" === location.protocol;
        let port = location.port;
        if (!port) {
          port = isSSL ? "443" : "80";
        }
        this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
      }
      const forceBase64 = opts && opts.forceBase64;
      this.supportsBinary = hasXHR2 && !forceBase64;
      if (this.opts.withCredentials) {
        this.cookieJar = (0, xmlhttprequest_js_1.createCookieJar)();
      }
    }
    get name() {
      return "polling";
    }
    /**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @protected
     */
    doOpen() {
      this.poll();
    }
    /**
     * Pauses polling.
     *
     * @param {Function} onPause - callback upon buffers are flushed and transport is paused
     * @package
     */
    pause(onPause) {
      this.readyState = "pausing";
      const pause = () => {
        debug$6("paused");
        this.readyState = "paused";
        onPause();
      };
      if (this.polling || !this.writable) {
        let total = 0;
        if (this.polling) {
          debug$6("we are currently polling - waiting to pause");
          total++;
          this.once("pollComplete", function() {
            debug$6("pre-pause polling complete");
            --total || pause();
          });
        }
        if (!this.writable) {
          debug$6("we are currently writing - waiting to pause");
          total++;
          this.once("drain", function() {
            debug$6("pre-pause writing complete");
            --total || pause();
          });
        }
      } else {
        pause();
      }
    }
    /**
     * Starts polling cycle.
     *
     * @private
     */
    poll() {
      debug$6("polling");
      this.polling = true;
      this.doPoll();
      this.emitReserved("poll");
    }
    /**
     * Overloads onData to detect payloads.
     *
     * @protected
     */
    onData(data2) {
      debug$6("polling got data %s", data2);
      const callback = (packet) => {
        if ("opening" === this.readyState && packet.type === "open") {
          this.onOpen();
        }
        if ("close" === packet.type) {
          this.onClose({ description: "transport closed by the server" });
          return false;
        }
        this.onPacket(packet);
      };
      (0, engine_io_parser_1$3.decodePayload)(data2, this.socket.binaryType).forEach(callback);
      if ("closed" !== this.readyState) {
        this.polling = false;
        this.emitReserved("pollComplete");
        if ("open" === this.readyState) {
          this.poll();
        } else {
          debug$6('ignoring poll - transport state "%s"', this.readyState);
        }
      }
    }
    /**
     * For polling, send a close packet.
     *
     * @protected
     */
    doClose() {
      const close = () => {
        debug$6("writing close packet");
        this.write([{ type: "close" }]);
      };
      if ("open" === this.readyState) {
        debug$6("transport open - closing");
        close();
      } else {
        debug$6("transport not open - deferring close");
        this.once("open", close);
      }
    }
    /**
     * Writes a packets payload.
     *
     * @param {Array} packets - data packets
     * @protected
     */
    write(packets) {
      this.writable = false;
      (0, engine_io_parser_1$3.encodePayload)(packets, (data2) => {
        this.doWrite(data2, () => {
          this.writable = true;
          this.emitReserved("drain");
        });
      });
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
    uri() {
      const schema2 = this.opts.secure ? "https" : "http";
      const query2 = this.query || {};
      if (false !== this.opts.timestampRequests) {
        query2[this.opts.timestampParam] = (0, yeast_js_1$1.yeast)();
      }
      if (!this.supportsBinary && !query2.sid) {
        query2.b64 = 1;
      }
      return this.createUri(schema2, query2);
    }
    /**
     * Creates a request.
     *
     * @param {String} method
     * @private
     */
    request(opts = {}) {
      Object.assign(opts, { xd: this.xd, cookieJar: this.cookieJar }, this.opts);
      return new Request(this.uri(), opts);
    }
    /**
     * Sends data.
     *
     * @param {String} data to send.
     * @param {Function} called upon flush.
     * @private
     */
    doWrite(data2, fn) {
      const req = this.request({
        method: "POST",
        data: data2
      });
      req.on("success", fn);
      req.on("error", (xhrStatus, context2) => {
        this.onError("xhr post error", xhrStatus, context2);
      });
    }
    /**
     * Starts a poll cycle.
     *
     * @private
     */
    doPoll() {
      debug$6("xhr poll");
      const req = this.request();
      req.on("data", this.onData.bind(this));
      req.on("error", (xhrStatus, context2) => {
        this.onError("xhr poll error", xhrStatus, context2);
      });
      this.pollXhr = req;
    }
  }
  polling.Polling = Polling;
  class Request extends component_emitter_1$3.Emitter {
    /**
     * Request constructor
     *
     * @param {Object} options
     * @package
     */
    constructor(uri, opts) {
      super();
      (0, util_js_1$2.installTimerFunctions)(this, opts);
      this.opts = opts;
      this.method = opts.method || "GET";
      this.uri = uri;
      this.data = void 0 !== opts.data ? opts.data : null;
      this.create();
    }
    /**
     * Creates the XHR object and sends the request.
     *
     * @private
     */
    create() {
      var _a3;
      const opts = (0, util_js_1$2.pick)(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
      opts.xdomain = !!this.opts.xd;
      const xhr = this.xhr = new xmlhttprequest_js_1.XHR(opts);
      try {
        debug$6("xhr open %s: %s", this.method, this.uri);
        xhr.open(this.method, this.uri, true);
        try {
          if (this.opts.extraHeaders) {
            xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
            for (let i2 in this.opts.extraHeaders) {
              if (this.opts.extraHeaders.hasOwnProperty(i2)) {
                xhr.setRequestHeader(i2, this.opts.extraHeaders[i2]);
              }
            }
          }
        } catch (e) {
        }
        if ("POST" === this.method) {
          try {
            xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
          } catch (e) {
          }
        }
        try {
          xhr.setRequestHeader("Accept", "*/*");
        } catch (e) {
        }
        (_a3 = this.opts.cookieJar) === null || _a3 === void 0 ? void 0 : _a3.addCookies(xhr);
        if ("withCredentials" in xhr) {
          xhr.withCredentials = this.opts.withCredentials;
        }
        if (this.opts.requestTimeout) {
          xhr.timeout = this.opts.requestTimeout;
        }
        xhr.onreadystatechange = () => {
          var _a4;
          if (xhr.readyState === 3) {
            (_a4 = this.opts.cookieJar) === null || _a4 === void 0 ? void 0 : _a4.parseCookies(xhr);
          }
          if (4 !== xhr.readyState)
            return;
          if (200 === xhr.status || 1223 === xhr.status) {
            this.onLoad();
          } else {
            this.setTimeoutFn(() => {
              this.onError(typeof xhr.status === "number" ? xhr.status : 0);
            }, 0);
          }
        };
        debug$6("xhr data %s", this.data);
        xhr.send(this.data);
      } catch (e) {
        this.setTimeoutFn(() => {
          this.onError(e);
        }, 0);
        return;
      }
      if (typeof document !== "undefined") {
        this.index = Request.requestsCount++;
        Request.requests[this.index] = this;
      }
    }
    /**
     * Called upon error.
     *
     * @private
     */
    onError(err) {
      this.emitReserved("error", err, this.xhr);
      this.cleanup(true);
    }
    /**
     * Cleans up house.
     *
     * @private
     */
    cleanup(fromError) {
      if ("undefined" === typeof this.xhr || null === this.xhr) {
        return;
      }
      this.xhr.onreadystatechange = empty;
      if (fromError) {
        try {
          this.xhr.abort();
        } catch (e) {
        }
      }
      if (typeof document !== "undefined") {
        delete Request.requests[this.index];
      }
      this.xhr = null;
    }
    /**
     * Called upon load.
     *
     * @private
     */
    onLoad() {
      const data2 = this.xhr.responseText;
      if (data2 !== null) {
        this.emitReserved("data", data2);
        this.emitReserved("success");
        this.cleanup();
      }
    }
    /**
     * Aborts the request.
     *
     * @package
     */
    abort() {
      this.cleanup();
    }
  }
  polling.Request = Request;
  Request.requestsCount = 0;
  Request.requests = {};
  if (typeof document !== "undefined") {
    if (typeof attachEvent === "function") {
      attachEvent("onunload", unloadHandler);
    } else if (typeof addEventListener === "function") {
      const terminationEvent = "onpagehide" in globalThis_js_1$1.globalThisShim ? "pagehide" : "unload";
      addEventListener(terminationEvent, unloadHandler, false);
    }
  }
  function unloadHandler() {
    for (let i2 in Request.requests) {
      if (Request.requests.hasOwnProperty(i2)) {
        Request.requests[i2].abort();
      }
    }
  }
  var websocket = {};
  var websocketConstructor_browser = {};
  Object.defineProperty(websocketConstructor_browser, "__esModule", { value: true });
  websocketConstructor_browser.defaultBinaryType = websocketConstructor_browser.usingBrowserWebSocket = websocketConstructor_browser.WebSocket = websocketConstructor_browser.nextTick = void 0;
  const globalThis_js_1 = globalThis_browser;
  websocketConstructor_browser.nextTick = (() => {
    const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
    if (isPromiseAvailable) {
      return (cb) => Promise.resolve().then(cb);
    } else {
      return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
    }
  })();
  websocketConstructor_browser.WebSocket = globalThis_js_1.globalThisShim.WebSocket || globalThis_js_1.globalThisShim.MozWebSocket;
  websocketConstructor_browser.usingBrowserWebSocket = true;
  websocketConstructor_browser.defaultBinaryType = "arraybuffer";
  var __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(websocket, "__esModule", { value: true });
  websocket.WS = void 0;
  const transport_js_1$1 = transport;
  const yeast_js_1 = yeast$1;
  const util_js_1$1 = util;
  const websocket_constructor_js_1$2 = websocketConstructor_browser;
  const debug_1$5 = __importDefault$6(browserExports);
  const engine_io_parser_1$2 = cjs$1;
  const debug$5 = (0, debug_1$5.default)("engine.io-client:websocket");
  const isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
  class WS extends transport_js_1$1.Transport {
    /**
     * WebSocket transport constructor.
     *
     * @param {Object} opts - connection options
     * @protected
     */
    constructor(opts) {
      super(opts);
      this.supportsBinary = !opts.forceBase64;
    }
    get name() {
      return "websocket";
    }
    doOpen() {
      if (!this.check()) {
        return;
      }
      const uri = this.uri();
      const protocols = this.opts.protocols;
      const opts = isReactNative ? {} : (0, util_js_1$1.pick)(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
      if (this.opts.extraHeaders) {
        opts.headers = this.opts.extraHeaders;
      }
      try {
        this.ws = websocket_constructor_js_1$2.usingBrowserWebSocket && !isReactNative ? protocols ? new websocket_constructor_js_1$2.WebSocket(uri, protocols) : new websocket_constructor_js_1$2.WebSocket(uri) : new websocket_constructor_js_1$2.WebSocket(uri, protocols, opts);
      } catch (err) {
        return this.emitReserved("error", err);
      }
      this.ws.binaryType = this.socket.binaryType;
      this.addEventListeners();
    }
    /**
     * Adds event listeners to the socket
     *
     * @private
     */
    addEventListeners() {
      this.ws.onopen = () => {
        if (this.opts.autoUnref) {
          this.ws._socket.unref();
        }
        this.onOpen();
      };
      this.ws.onclose = (closeEvent) => this.onClose({
        description: "websocket connection closed",
        context: closeEvent
      });
      this.ws.onmessage = (ev) => this.onData(ev.data);
      this.ws.onerror = (e) => this.onError("websocket error", e);
    }
    write(packets) {
      this.writable = false;
      for (let i2 = 0; i2 < packets.length; i2++) {
        const packet = packets[i2];
        const lastPacket = i2 === packets.length - 1;
        (0, engine_io_parser_1$2.encodePacket)(packet, this.supportsBinary, (data2) => {
          const opts = {};
          if (!websocket_constructor_js_1$2.usingBrowserWebSocket) {
            if (packet.options) {
              opts.compress = packet.options.compress;
            }
            if (this.opts.perMessageDeflate) {
              const len2 = (
                // @ts-ignore
                "string" === typeof data2 ? buffer$1.Buffer.byteLength(data2) : data2.length
              );
              if (len2 < this.opts.perMessageDeflate.threshold) {
                opts.compress = false;
              }
            }
          }
          try {
            if (websocket_constructor_js_1$2.usingBrowserWebSocket) {
              this.ws.send(data2);
            } else {
              this.ws.send(data2, opts);
            }
          } catch (e) {
            debug$5("websocket closed before onclose event");
          }
          if (lastPacket) {
            (0, websocket_constructor_js_1$2.nextTick)(() => {
              this.writable = true;
              this.emitReserved("drain");
            }, this.setTimeoutFn);
          }
        });
      }
    }
    doClose() {
      if (typeof this.ws !== "undefined") {
        this.ws.close();
        this.ws = null;
      }
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
    uri() {
      const schema2 = this.opts.secure ? "wss" : "ws";
      const query2 = this.query || {};
      if (this.opts.timestampRequests) {
        query2[this.opts.timestampParam] = (0, yeast_js_1.yeast)();
      }
      if (!this.supportsBinary) {
        query2.b64 = 1;
      }
      return this.createUri(schema2, query2);
    }
    /**
     * Feature detection for WebSocket.
     *
     * @return {Boolean} whether this transport is available.
     * @private
     */
    check() {
      return !!websocket_constructor_js_1$2.WebSocket;
    }
  }
  websocket.WS = WS;
  var webtransport = {};
  var __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(webtransport, "__esModule", { value: true });
  webtransport.WT = void 0;
  const transport_js_1 = transport;
  const websocket_constructor_js_1$1 = websocketConstructor_browser;
  const engine_io_parser_1$1 = cjs$1;
  const debug_1$4 = __importDefault$5(browserExports);
  const debug$4 = (0, debug_1$4.default)("engine.io-client:webtransport");
  class WT extends transport_js_1.Transport {
    get name() {
      return "webtransport";
    }
    doOpen() {
      if (typeof WebTransport !== "function") {
        return;
      }
      this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
      this.transport.closed.then(() => {
        debug$4("transport closed gracefully");
        this.onClose();
      }).catch((err) => {
        debug$4("transport closed due to %s", err);
        this.onError("webtransport error", err);
      });
      this.transport.ready.then(() => {
        this.transport.createBidirectionalStream().then((stream) => {
          const decoderStream = (0, engine_io_parser_1$1.createPacketDecoderStream)(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
          const reader = stream.readable.pipeThrough(decoderStream).getReader();
          const encoderStream = (0, engine_io_parser_1$1.createPacketEncoderStream)();
          encoderStream.readable.pipeTo(stream.writable);
          this.writer = encoderStream.writable.getWriter();
          const read = () => {
            reader.read().then(({ done, value: value2 }) => {
              if (done) {
                debug$4("session is closed");
                return;
              }
              debug$4("received chunk: %o", value2);
              this.onPacket(value2);
              read();
            }).catch((err) => {
              debug$4("an error occurred while reading: %s", err);
            });
          };
          read();
          const packet = { type: "open" };
          if (this.query.sid) {
            packet.data = `{"sid":"${this.query.sid}"}`;
          }
          this.writer.write(packet).then(() => this.onOpen());
        });
      });
    }
    write(packets) {
      this.writable = false;
      for (let i2 = 0; i2 < packets.length; i2++) {
        const packet = packets[i2];
        const lastPacket = i2 === packets.length - 1;
        this.writer.write(packet).then(() => {
          if (lastPacket) {
            (0, websocket_constructor_js_1$1.nextTick)(() => {
              this.writable = true;
              this.emitReserved("drain");
            }, this.setTimeoutFn);
          }
        });
      }
    }
    doClose() {
      var _a3;
      (_a3 = this.transport) === null || _a3 === void 0 ? void 0 : _a3.close();
    }
  }
  webtransport.WT = WT;
  Object.defineProperty(transports, "__esModule", { value: true });
  transports.transports = void 0;
  const polling_js_1 = polling;
  const websocket_js_1 = websocket;
  const webtransport_js_1 = webtransport;
  transports.transports = {
    websocket: websocket_js_1.WS,
    webtransport: webtransport_js_1.WT,
    polling: polling_js_1.Polling
  };
  var parseuri = {};
  Object.defineProperty(parseuri, "__esModule", { value: true });
  parseuri.parse = void 0;
  const re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
  const parts = [
    "source",
    "protocol",
    "authority",
    "userInfo",
    "user",
    "password",
    "host",
    "port",
    "relative",
    "path",
    "directory",
    "file",
    "query",
    "anchor"
  ];
  function parse(str2) {
    const src2 = str2, b = str2.indexOf("["), e = str2.indexOf("]");
    if (b != -1 && e != -1) {
      str2 = str2.substring(0, b) + str2.substring(b, e).replace(/:/g, ";") + str2.substring(e, str2.length);
    }
    let m2 = re.exec(str2 || ""), uri = {}, i2 = 14;
    while (i2--) {
      uri[parts[i2]] = m2[i2] || "";
    }
    if (b != -1 && e != -1) {
      uri.source = src2;
      uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
      uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
      uri.ipv6uri = true;
    }
    uri.pathNames = pathNames(uri, uri["path"]);
    uri.queryKey = queryKey(uri, uri["query"]);
    return uri;
  }
  parseuri.parse = parse;
  function pathNames(obj, path2) {
    const regx = /\/{2,9}/g, names = path2.replace(regx, "/").split("/");
    if (path2.slice(0, 1) == "/" || path2.length === 0) {
      names.splice(0, 1);
    }
    if (path2.slice(-1) == "/") {
      names.splice(names.length - 1, 1);
    }
    return names;
  }
  function queryKey(uri, query2) {
    const data2 = {};
    query2.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
      if ($1) {
        data2[$1] = $2;
      }
    });
    return data2;
  }
  var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(socket$1, "__esModule", { value: true });
  socket$1.Socket = void 0;
  const index_js_1 = transports;
  const util_js_1 = util;
  const parseqs_js_1 = parseqs;
  const parseuri_js_1 = parseuri;
  const debug_1$3 = __importDefault$4(browserExports);
  const component_emitter_1$2 = require$$5;
  const engine_io_parser_1 = cjs$1;
  const websocket_constructor_js_1 = websocketConstructor_browser;
  const debug$3 = (0, debug_1$3.default)("engine.io-client:socket");
  let Socket$1 = class Socket2 extends component_emitter_1$2.Emitter {
    /**
     * Socket constructor.
     *
     * @param {String|Object} uri - uri or options
     * @param {Object} opts - options
     */
    constructor(uri, opts = {}) {
      super();
      this.binaryType = websocket_constructor_js_1.defaultBinaryType;
      this.writeBuffer = [];
      if (uri && "object" === typeof uri) {
        opts = uri;
        uri = null;
      }
      if (uri) {
        uri = (0, parseuri_js_1.parse)(uri);
        opts.hostname = uri.host;
        opts.secure = uri.protocol === "https" || uri.protocol === "wss";
        opts.port = uri.port;
        if (uri.query)
          opts.query = uri.query;
      } else if (opts.host) {
        opts.hostname = (0, parseuri_js_1.parse)(opts.host).host;
      }
      (0, util_js_1.installTimerFunctions)(this, opts);
      this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
      if (opts.hostname && !opts.port) {
        opts.port = this.secure ? "443" : "80";
      }
      this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
      this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
      this.transports = opts.transports || [
        "polling",
        "websocket",
        "webtransport"
      ];
      this.writeBuffer = [];
      this.prevBufferLen = 0;
      this.opts = Object.assign({
        path: "/engine.io",
        agent: false,
        withCredentials: false,
        upgrade: true,
        timestampParam: "t",
        rememberUpgrade: false,
        addTrailingSlash: true,
        rejectUnauthorized: true,
        perMessageDeflate: {
          threshold: 1024
        },
        transportOptions: {},
        closeOnBeforeunload: false
      }, opts);
      this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
      if (typeof this.opts.query === "string") {
        this.opts.query = (0, parseqs_js_1.decode)(this.opts.query);
      }
      this.id = null;
      this.upgrades = null;
      this.pingInterval = null;
      this.pingTimeout = null;
      this.pingTimeoutTimer = null;
      if (typeof addEventListener === "function") {
        if (this.opts.closeOnBeforeunload) {
          this.beforeunloadEventListener = () => {
            if (this.transport) {
              this.transport.removeAllListeners();
              this.transport.close();
            }
          };
          addEventListener("beforeunload", this.beforeunloadEventListener, false);
        }
        if (this.hostname !== "localhost") {
          this.offlineEventListener = () => {
            this.onClose("transport close", {
              description: "network connection lost"
            });
          };
          addEventListener("offline", this.offlineEventListener, false);
        }
      }
      this.open();
    }
    /**
     * Creates transport of the given type.
     *
     * @param {String} name - transport name
     * @return {Transport}
     * @private
     */
    createTransport(name) {
      debug$3('creating transport "%s"', name);
      const query2 = Object.assign({}, this.opts.query);
      query2.EIO = engine_io_parser_1.protocol;
      query2.transport = name;
      if (this.id)
        query2.sid = this.id;
      const opts = Object.assign({}, this.opts, {
        query: query2,
        socket: this,
        hostname: this.hostname,
        secure: this.secure,
        port: this.port
      }, this.opts.transportOptions[name]);
      debug$3("options: %j", opts);
      return new index_js_1.transports[name](opts);
    }
    /**
     * Initializes transport to use and starts probe.
     *
     * @private
     */
    open() {
      let transport2;
      if (this.opts.rememberUpgrade && Socket2.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
        transport2 = "websocket";
      } else if (0 === this.transports.length) {
        this.setTimeoutFn(() => {
          this.emitReserved("error", "No transports available");
        }, 0);
        return;
      } else {
        transport2 = this.transports[0];
      }
      this.readyState = "opening";
      try {
        transport2 = this.createTransport(transport2);
      } catch (e) {
        debug$3("error while creating transport: %s", e);
        this.transports.shift();
        this.open();
        return;
      }
      transport2.open();
      this.setTransport(transport2);
    }
    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @private
     */
    setTransport(transport2) {
      debug$3("setting transport %s", transport2.name);
      if (this.transport) {
        debug$3("clearing existing transport %s", this.transport.name);
        this.transport.removeAllListeners();
      }
      this.transport = transport2;
      transport2.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (reason) => this.onClose("transport close", reason));
    }
    /**
     * Probes a transport.
     *
     * @param {String} name - transport name
     * @private
     */
    probe(name) {
      debug$3('probing transport "%s"', name);
      let transport2 = this.createTransport(name);
      let failed = false;
      Socket2.priorWebsocketSuccess = false;
      const onTransportOpen = () => {
        if (failed)
          return;
        debug$3('probe transport "%s" opened', name);
        transport2.send([{ type: "ping", data: "probe" }]);
        transport2.once("packet", (msg) => {
          if (failed)
            return;
          if ("pong" === msg.type && "probe" === msg.data) {
            debug$3('probe transport "%s" pong', name);
            this.upgrading = true;
            this.emitReserved("upgrading", transport2);
            if (!transport2)
              return;
            Socket2.priorWebsocketSuccess = "websocket" === transport2.name;
            debug$3('pausing current transport "%s"', this.transport.name);
            this.transport.pause(() => {
              if (failed)
                return;
              if ("closed" === this.readyState)
                return;
              debug$3("changing transport and sending upgrade packet");
              cleanup();
              this.setTransport(transport2);
              transport2.send([{ type: "upgrade" }]);
              this.emitReserved("upgrade", transport2);
              transport2 = null;
              this.upgrading = false;
              this.flush();
            });
          } else {
            debug$3('probe transport "%s" failed', name);
            const err = new Error("probe error");
            err.transport = transport2.name;
            this.emitReserved("upgradeError", err);
          }
        });
      };
      function freezeTransport() {
        if (failed)
          return;
        failed = true;
        cleanup();
        transport2.close();
        transport2 = null;
      }
      const onerror = (err) => {
        const error = new Error("probe error: " + err);
        error.transport = transport2.name;
        freezeTransport();
        debug$3('probe transport "%s" failed because of error: %s', name, err);
        this.emitReserved("upgradeError", error);
      };
      function onTransportClose() {
        onerror("transport closed");
      }
      function onclose() {
        onerror("socket closed");
      }
      function onupgrade(to) {
        if (transport2 && to.name !== transport2.name) {
          debug$3('"%s" works - aborting "%s"', to.name, transport2.name);
          freezeTransport();
        }
      }
      const cleanup = () => {
        transport2.removeListener("open", onTransportOpen);
        transport2.removeListener("error", onerror);
        transport2.removeListener("close", onTransportClose);
        this.off("close", onclose);
        this.off("upgrading", onupgrade);
      };
      transport2.once("open", onTransportOpen);
      transport2.once("error", onerror);
      transport2.once("close", onTransportClose);
      this.once("close", onclose);
      this.once("upgrading", onupgrade);
      if (this.upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
        this.setTimeoutFn(() => {
          if (!failed) {
            transport2.open();
          }
        }, 200);
      } else {
        transport2.open();
      }
    }
    /**
     * Called when connection is deemed open.
     *
     * @private
     */
    onOpen() {
      debug$3("socket open");
      this.readyState = "open";
      Socket2.priorWebsocketSuccess = "websocket" === this.transport.name;
      this.emitReserved("open");
      this.flush();
      if ("open" === this.readyState && this.opts.upgrade) {
        debug$3("starting upgrade probes");
        let i2 = 0;
        const l2 = this.upgrades.length;
        for (; i2 < l2; i2++) {
          this.probe(this.upgrades[i2]);
        }
      }
    }
    /**
     * Handles a packet.
     *
     * @private
     */
    onPacket(packet) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        debug$3('socket receive: type "%s", data "%s"', packet.type, packet.data);
        this.emitReserved("packet", packet);
        this.emitReserved("heartbeat");
        this.resetPingTimeout();
        switch (packet.type) {
          case "open":
            this.onHandshake(JSON.parse(packet.data));
            break;
          case "ping":
            this.sendPacket("pong");
            this.emitReserved("ping");
            this.emitReserved("pong");
            break;
          case "error":
            const err = new Error("server error");
            err.code = packet.data;
            this.onError(err);
            break;
          case "message":
            this.emitReserved("data", packet.data);
            this.emitReserved("message", packet.data);
            break;
        }
      } else {
        debug$3('packet received with socket readyState "%s"', this.readyState);
      }
    }
    /**
     * Called upon handshake completion.
     *
     * @param {Object} data - handshake obj
     * @private
     */
    onHandshake(data2) {
      this.emitReserved("handshake", data2);
      this.id = data2.sid;
      this.transport.query.sid = data2.sid;
      this.upgrades = this.filterUpgrades(data2.upgrades);
      this.pingInterval = data2.pingInterval;
      this.pingTimeout = data2.pingTimeout;
      this.maxPayload = data2.maxPayload;
      this.onOpen();
      if ("closed" === this.readyState)
        return;
      this.resetPingTimeout();
    }
    /**
     * Sets and resets ping timeout timer based on server pings.
     *
     * @private
     */
    resetPingTimeout() {
      this.clearTimeoutFn(this.pingTimeoutTimer);
      this.pingTimeoutTimer = this.setTimeoutFn(() => {
        this.onClose("ping timeout");
      }, this.pingInterval + this.pingTimeout);
      if (this.opts.autoUnref) {
        this.pingTimeoutTimer.unref();
      }
    }
    /**
     * Called on `drain` event
     *
     * @private
     */
    onDrain() {
      this.writeBuffer.splice(0, this.prevBufferLen);
      this.prevBufferLen = 0;
      if (0 === this.writeBuffer.length) {
        this.emitReserved("drain");
      } else {
        this.flush();
      }
    }
    /**
     * Flush write buffers.
     *
     * @private
     */
    flush() {
      if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
        const packets = this.getWritablePackets();
        debug$3("flushing %d packets in socket", packets.length);
        this.transport.send(packets);
        this.prevBufferLen = packets.length;
        this.emitReserved("flush");
      }
    }
    /**
     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
     * long-polling)
     *
     * @private
     */
    getWritablePackets() {
      const shouldCheckPayloadSize = this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
      if (!shouldCheckPayloadSize) {
        return this.writeBuffer;
      }
      let payloadSize = 1;
      for (let i2 = 0; i2 < this.writeBuffer.length; i2++) {
        const data2 = this.writeBuffer[i2].data;
        if (data2) {
          payloadSize += (0, util_js_1.byteLength)(data2);
        }
        if (i2 > 0 && payloadSize > this.maxPayload) {
          debug$3("only send %d out of %d packets", i2, this.writeBuffer.length);
          return this.writeBuffer.slice(0, i2);
        }
        payloadSize += 2;
      }
      debug$3("payload size is %d (max: %d)", payloadSize, this.maxPayload);
      return this.writeBuffer;
    }
    /**
     * Sends a message.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} callback function.
     * @return {Socket} for chaining.
     */
    write(msg, options, fn) {
      this.sendPacket("message", msg, options, fn);
      return this;
    }
    send(msg, options, fn) {
      this.sendPacket("message", msg, options, fn);
      return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} type: packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @private
     */
    sendPacket(type2, data2, options, fn) {
      if ("function" === typeof data2) {
        fn = data2;
        data2 = void 0;
      }
      if ("function" === typeof options) {
        fn = options;
        options = null;
      }
      if ("closing" === this.readyState || "closed" === this.readyState) {
        return;
      }
      options = options || {};
      options.compress = false !== options.compress;
      const packet = {
        type: type2,
        data: data2,
        options
      };
      this.emitReserved("packetCreate", packet);
      this.writeBuffer.push(packet);
      if (fn)
        this.once("flush", fn);
      this.flush();
    }
    /**
     * Closes the connection.
     */
    close() {
      const close = () => {
        this.onClose("forced close");
        debug$3("socket closing - telling transport to close");
        this.transport.close();
      };
      const cleanupAndClose = () => {
        this.off("upgrade", cleanupAndClose);
        this.off("upgradeError", cleanupAndClose);
        close();
      };
      const waitForUpgrade = () => {
        this.once("upgrade", cleanupAndClose);
        this.once("upgradeError", cleanupAndClose);
      };
      if ("opening" === this.readyState || "open" === this.readyState) {
        this.readyState = "closing";
        if (this.writeBuffer.length) {
          this.once("drain", () => {
            if (this.upgrading) {
              waitForUpgrade();
            } else {
              close();
            }
          });
        } else if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      }
      return this;
    }
    /**
     * Called upon transport error
     *
     * @private
     */
    onError(err) {
      debug$3("socket error %j", err);
      Socket2.priorWebsocketSuccess = false;
      this.emitReserved("error", err);
      this.onClose("transport error", err);
    }
    /**
     * Called upon transport close.
     *
     * @private
     */
    onClose(reason, description) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        debug$3('socket close with reason: "%s"', reason);
        this.clearTimeoutFn(this.pingTimeoutTimer);
        this.transport.removeAllListeners("close");
        this.transport.close();
        this.transport.removeAllListeners();
        if (typeof removeEventListener === "function") {
          removeEventListener("beforeunload", this.beforeunloadEventListener, false);
          removeEventListener("offline", this.offlineEventListener, false);
        }
        this.readyState = "closed";
        this.id = null;
        this.emitReserved("close", reason, description);
        this.writeBuffer = [];
        this.prevBufferLen = 0;
      }
    }
    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} upgrades - server upgrades
     * @private
     */
    filterUpgrades(upgrades) {
      const filteredUpgrades = [];
      let i2 = 0;
      const j = upgrades.length;
      for (; i2 < j; i2++) {
        if (~this.transports.indexOf(upgrades[i2]))
          filteredUpgrades.push(upgrades[i2]);
      }
      return filteredUpgrades;
    }
  };
  socket$1.Socket = Socket$1;
  Socket$1.protocol = engine_io_parser_1.protocol;
  (function(exports3) {
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.nextTick = exports3.parse = exports3.installTimerFunctions = exports3.transports = exports3.Transport = exports3.protocol = exports3.Socket = void 0;
    const socket_js_12 = socket$1;
    Object.defineProperty(exports3, "Socket", { enumerable: true, get: function() {
      return socket_js_12.Socket;
    } });
    exports3.protocol = socket_js_12.Socket.protocol;
    var transport_js_12 = transport;
    Object.defineProperty(exports3, "Transport", { enumerable: true, get: function() {
      return transport_js_12.Transport;
    } });
    var index_js_12 = transports;
    Object.defineProperty(exports3, "transports", { enumerable: true, get: function() {
      return index_js_12.transports;
    } });
    var util_js_12 = util;
    Object.defineProperty(exports3, "installTimerFunctions", { enumerable: true, get: function() {
      return util_js_12.installTimerFunctions;
    } });
    var parseuri_js_12 = parseuri;
    Object.defineProperty(exports3, "parse", { enumerable: true, get: function() {
      return parseuri_js_12.parse;
    } });
    var websocket_constructor_js_12 = websocketConstructor_browser;
    Object.defineProperty(exports3, "nextTick", { enumerable: true, get: function() {
      return websocket_constructor_js_12.nextTick;
    } });
  })(cjs$2);
  var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(url$1, "__esModule", { value: true });
  url$1.url = void 0;
  const engine_io_client_1$1 = cjs$2;
  const debug_1$2 = __importDefault$3(browserExports);
  const debug$2 = debug_1$2.default("socket.io-client:url");
  function url(uri, path2 = "", loc) {
    let obj = uri;
    loc = loc || typeof location !== "undefined" && location;
    if (null == uri)
      uri = loc.protocol + "//" + loc.host;
    if (typeof uri === "string") {
      if ("/" === uri.charAt(0)) {
        if ("/" === uri.charAt(1)) {
          uri = loc.protocol + uri;
        } else {
          uri = loc.host + uri;
        }
      }
      if (!/^(https?|wss?):\/\//.test(uri)) {
        debug$2("protocol-less url %s", uri);
        if ("undefined" !== typeof loc) {
          uri = loc.protocol + "//" + uri;
        } else {
          uri = "https://" + uri;
        }
      }
      debug$2("parse %s", uri);
      obj = engine_io_client_1$1.parse(uri);
    }
    if (!obj.port) {
      if (/^(http|ws)$/.test(obj.protocol)) {
        obj.port = "80";
      } else if (/^(http|ws)s$/.test(obj.protocol)) {
        obj.port = "443";
      }
    }
    obj.path = obj.path || "/";
    const ipv6 = obj.host.indexOf(":") !== -1;
    const host = ipv6 ? "[" + obj.host + "]" : obj.host;
    obj.id = obj.protocol + "://" + host + ":" + obj.port + path2;
    obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
    return obj;
  }
  url$1.url = url;
  var manager = {};
  var socket = {};
  var cjs = {};
  var binary = {};
  var isBinary$1 = {};
  Object.defineProperty(isBinary$1, "__esModule", { value: true });
  isBinary$1.hasBinary = isBinary$1.isBinary = void 0;
  const withNativeArrayBuffer = typeof ArrayBuffer === "function";
  const isView = (obj) => {
    return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
  };
  const toString = Object.prototype.toString;
  const withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
  const withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
  function isBinary(obj) {
    return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
  }
  isBinary$1.isBinary = isBinary;
  function hasBinary(obj, toJSON) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    if (Array.isArray(obj)) {
      for (let i2 = 0, l2 = obj.length; i2 < l2; i2++) {
        if (hasBinary(obj[i2])) {
          return true;
        }
      }
      return false;
    }
    if (isBinary(obj)) {
      return true;
    }
    if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
      return hasBinary(obj.toJSON(), true);
    }
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
        return true;
      }
    }
    return false;
  }
  isBinary$1.hasBinary = hasBinary;
  Object.defineProperty(binary, "__esModule", { value: true });
  binary.reconstructPacket = binary.deconstructPacket = void 0;
  const is_binary_js_1 = isBinary$1;
  function deconstructPacket(packet) {
    const buffers = [];
    const packetData = packet.data;
    const pack = packet;
    pack.data = _deconstructPacket(packetData, buffers);
    pack.attachments = buffers.length;
    return { packet: pack, buffers };
  }
  binary.deconstructPacket = deconstructPacket;
  function _deconstructPacket(data2, buffers) {
    if (!data2)
      return data2;
    if ((0, is_binary_js_1.isBinary)(data2)) {
      const placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data2);
      return placeholder;
    } else if (Array.isArray(data2)) {
      const newData = new Array(data2.length);
      for (let i2 = 0; i2 < data2.length; i2++) {
        newData[i2] = _deconstructPacket(data2[i2], buffers);
      }
      return newData;
    } else if (typeof data2 === "object" && !(data2 instanceof Date)) {
      const newData = {};
      for (const key in data2) {
        if (Object.prototype.hasOwnProperty.call(data2, key)) {
          newData[key] = _deconstructPacket(data2[key], buffers);
        }
      }
      return newData;
    }
    return data2;
  }
  function reconstructPacket(packet, buffers) {
    packet.data = _reconstructPacket(packet.data, buffers);
    delete packet.attachments;
    return packet;
  }
  binary.reconstructPacket = reconstructPacket;
  function _reconstructPacket(data2, buffers) {
    if (!data2)
      return data2;
    if (data2 && data2._placeholder === true) {
      const isIndexValid = typeof data2.num === "number" && data2.num >= 0 && data2.num < buffers.length;
      if (isIndexValid) {
        return buffers[data2.num];
      } else {
        throw new Error("illegal attachments");
      }
    } else if (Array.isArray(data2)) {
      for (let i2 = 0; i2 < data2.length; i2++) {
        data2[i2] = _reconstructPacket(data2[i2], buffers);
      }
    } else if (typeof data2 === "object") {
      for (const key in data2) {
        if (Object.prototype.hasOwnProperty.call(data2, key)) {
          data2[key] = _reconstructPacket(data2[key], buffers);
        }
      }
    }
    return data2;
  }
  (function(exports3) {
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.Decoder = exports3.Encoder = exports3.PacketType = exports3.protocol = void 0;
    const component_emitter_12 = require$$5;
    const binary_js_1 = binary;
    const is_binary_js_12 = isBinary$1;
    const debug_12 = browserExports;
    const debug2 = (0, debug_12.default)("socket.io-parser");
    const RESERVED_EVENTS2 = [
      "connect",
      "connect_error",
      "disconnect",
      "disconnecting",
      "newListener",
      "removeListener"
      // used by the Node.js EventEmitter
    ];
    exports3.protocol = 5;
    var PacketType;
    (function(PacketType2) {
      PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
      PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
      PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
      PacketType2[PacketType2["ACK"] = 3] = "ACK";
      PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
      PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
      PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
    })(PacketType = exports3.PacketType || (exports3.PacketType = {}));
    class Encoder {
      /**
       * Encoder constructor
       *
       * @param {function} replacer - custom replacer to pass down to JSON.parse
       */
      constructor(replacer) {
        this.replacer = replacer;
      }
      /**
       * Encode a packet as a single string if non-binary, or as a
       * buffer sequence, depending on packet type.
       *
       * @param {Object} obj - packet object
       */
      encode(obj) {
        debug2("encoding packet %j", obj);
        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
          if ((0, is_binary_js_12.hasBinary)(obj)) {
            return this.encodeAsBinary({
              type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
              nsp: obj.nsp,
              data: obj.data,
              id: obj.id
            });
          }
        }
        return [this.encodeAsString(obj)];
      }
      /**
       * Encode packet as string.
       */
      encodeAsString(obj) {
        let str2 = "" + obj.type;
        if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
          str2 += obj.attachments + "-";
        }
        if (obj.nsp && "/" !== obj.nsp) {
          str2 += obj.nsp + ",";
        }
        if (null != obj.id) {
          str2 += obj.id;
        }
        if (null != obj.data) {
          str2 += JSON.stringify(obj.data, this.replacer);
        }
        debug2("encoded %j as %s", obj, str2);
        return str2;
      }
      /**
       * Encode packet as 'buffer sequence' by removing blobs, and
       * deconstructing packet into object with placeholders and
       * a list of buffers.
       */
      encodeAsBinary(obj) {
        const deconstruction = (0, binary_js_1.deconstructPacket)(obj);
        const pack = this.encodeAsString(deconstruction.packet);
        const buffers = deconstruction.buffers;
        buffers.unshift(pack);
        return buffers;
      }
    }
    exports3.Encoder = Encoder;
    function isObject2(value2) {
      return Object.prototype.toString.call(value2) === "[object Object]";
    }
    class Decoder extends component_emitter_12.Emitter {
      /**
       * Decoder constructor
       *
       * @param {function} reviver - custom reviver to pass down to JSON.stringify
       */
      constructor(reviver) {
        super();
        this.reviver = reviver;
      }
      /**
       * Decodes an encoded packet string into packet JSON.
       *
       * @param {String} obj - encoded packet
       */
      add(obj) {
        let packet;
        if (typeof obj === "string") {
          if (this.reconstructor) {
            throw new Error("got plaintext data when reconstructing a packet");
          }
          packet = this.decodeString(obj);
          const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
          if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
            packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
            this.reconstructor = new BinaryReconstructor(packet);
            if (packet.attachments === 0) {
              super.emitReserved("decoded", packet);
            }
          } else {
            super.emitReserved("decoded", packet);
          }
        } else if ((0, is_binary_js_12.isBinary)(obj) || obj.base64) {
          if (!this.reconstructor) {
            throw new Error("got binary data when not reconstructing a packet");
          } else {
            packet = this.reconstructor.takeBinaryData(obj);
            if (packet) {
              this.reconstructor = null;
              super.emitReserved("decoded", packet);
            }
          }
        } else {
          throw new Error("Unknown type: " + obj);
        }
      }
      /**
       * Decode a packet String (JSON data)
       *
       * @param {String} str
       * @return {Object} packet
       */
      decodeString(str2) {
        let i2 = 0;
        const p2 = {
          type: Number(str2.charAt(0))
        };
        if (PacketType[p2.type] === void 0) {
          throw new Error("unknown packet type " + p2.type);
        }
        if (p2.type === PacketType.BINARY_EVENT || p2.type === PacketType.BINARY_ACK) {
          const start = i2 + 1;
          while (str2.charAt(++i2) !== "-" && i2 != str2.length) {
          }
          const buf = str2.substring(start, i2);
          if (buf != Number(buf) || str2.charAt(i2) !== "-") {
            throw new Error("Illegal attachments");
          }
          p2.attachments = Number(buf);
        }
        if ("/" === str2.charAt(i2 + 1)) {
          const start = i2 + 1;
          while (++i2) {
            const c = str2.charAt(i2);
            if ("," === c)
              break;
            if (i2 === str2.length)
              break;
          }
          p2.nsp = str2.substring(start, i2);
        } else {
          p2.nsp = "/";
        }
        const next = str2.charAt(i2 + 1);
        if ("" !== next && Number(next) == next) {
          const start = i2 + 1;
          while (++i2) {
            const c = str2.charAt(i2);
            if (null == c || Number(c) != c) {
              --i2;
              break;
            }
            if (i2 === str2.length)
              break;
          }
          p2.id = Number(str2.substring(start, i2 + 1));
        }
        if (str2.charAt(++i2)) {
          const payload = this.tryParse(str2.substr(i2));
          if (Decoder.isPayloadValid(p2.type, payload)) {
            p2.data = payload;
          } else {
            throw new Error("invalid payload");
          }
        }
        debug2("decoded %s as %j", str2, p2);
        return p2;
      }
      tryParse(str2) {
        try {
          return JSON.parse(str2, this.reviver);
        } catch (e) {
          return false;
        }
      }
      static isPayloadValid(type2, payload) {
        switch (type2) {
          case PacketType.CONNECT:
            return isObject2(payload);
          case PacketType.DISCONNECT:
            return payload === void 0;
          case PacketType.CONNECT_ERROR:
            return typeof payload === "string" || isObject2(payload);
          case PacketType.EVENT:
          case PacketType.BINARY_EVENT:
            return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS2.indexOf(payload[0]) === -1);
          case PacketType.ACK:
          case PacketType.BINARY_ACK:
            return Array.isArray(payload);
        }
      }
      /**
       * Deallocates a parser's resources
       */
      destroy() {
        if (this.reconstructor) {
          this.reconstructor.finishedReconstruction();
          this.reconstructor = null;
        }
      }
    }
    exports3.Decoder = Decoder;
    class BinaryReconstructor {
      constructor(packet) {
        this.packet = packet;
        this.buffers = [];
        this.reconPack = packet;
      }
      /**
       * Method to be called when binary data received from connection
       * after a BINARY_EVENT packet.
       *
       * @param {Buffer | ArrayBuffer} binData - the raw binary data received
       * @return {null | Object} returns null if more binary data is expected or
       *   a reconstructed packet object if all buffers have been received.
       */
      takeBinaryData(binData) {
        this.buffers.push(binData);
        if (this.buffers.length === this.reconPack.attachments) {
          const packet = (0, binary_js_1.reconstructPacket)(this.reconPack, this.buffers);
          this.finishedReconstruction();
          return packet;
        }
        return null;
      }
      /**
       * Cleans up binary packet reconstruction variables.
       */
      finishedReconstruction() {
        this.reconPack = null;
        this.buffers = [];
      }
    }
  })(cjs);
  var on$1 = {};
  Object.defineProperty(on$1, "__esModule", { value: true });
  on$1.on = void 0;
  function on(obj, ev, fn) {
    obj.on(ev, fn);
    return function subDestroy() {
      obj.off(ev, fn);
    };
  }
  on$1.on = on;
  var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(socket, "__esModule", { value: true });
  socket.Socket = void 0;
  const socket_io_parser_1 = cjs;
  const on_js_1$1 = on$1;
  const component_emitter_1$1 = require$$5;
  const debug_1$1 = __importDefault$2(browserExports);
  const debug$1 = debug_1$1.default("socket.io-client:socket");
  const RESERVED_EVENTS = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
    newListener: 1,
    removeListener: 1
  });
  class Socket extends component_emitter_1$1.Emitter {
    /**
     * `Socket` constructor.
     */
    constructor(io2, nsp, opts) {
      super();
      this.connected = false;
      this.recovered = false;
      this.receiveBuffer = [];
      this.sendBuffer = [];
      this._queue = [];
      this._queueSeq = 0;
      this.ids = 0;
      this.acks = {};
      this.flags = {};
      this.io = io2;
      this.nsp = nsp;
      if (opts && opts.auth) {
        this.auth = opts.auth;
      }
      this._opts = Object.assign({}, opts);
      if (this.io._autoConnect)
        this.open();
    }
    /**
     * Whether the socket is currently disconnected
     *
     * @example
     * const socket = io();
     *
     * socket.on("connect", () => {
     *   console.log(socket.disconnected); // false
     * });
     *
     * socket.on("disconnect", () => {
     *   console.log(socket.disconnected); // true
     * });
     */
    get disconnected() {
      return !this.connected;
    }
    /**
     * Subscribe to open, close and packet events
     *
     * @private
     */
    subEvents() {
      if (this.subs)
        return;
      const io2 = this.io;
      this.subs = [
        on_js_1$1.on(io2, "open", this.onopen.bind(this)),
        on_js_1$1.on(io2, "packet", this.onpacket.bind(this)),
        on_js_1$1.on(io2, "error", this.onerror.bind(this)),
        on_js_1$1.on(io2, "close", this.onclose.bind(this))
      ];
    }
    /**
     * Whether the Socket will try to reconnect when its Manager connects or reconnects.
     *
     * @example
     * const socket = io();
     *
     * console.log(socket.active); // true
     *
     * socket.on("disconnect", (reason) => {
     *   if (reason === "io server disconnect") {
     *     // the disconnection was initiated by the server, you need to manually reconnect
     *     console.log(socket.active); // false
     *   }
     *   // else the socket will automatically try to reconnect
     *   console.log(socket.active); // true
     * });
     */
    get active() {
      return !!this.subs;
    }
    /**
     * "Opens" the socket.
     *
     * @example
     * const socket = io({
     *   autoConnect: false
     * });
     *
     * socket.connect();
     */
    connect() {
      if (this.connected)
        return this;
      this.subEvents();
      if (!this.io["_reconnecting"])
        this.io.open();
      if ("open" === this.io._readyState)
        this.onopen();
      return this;
    }
    /**
     * Alias for {@link connect()}.
     */
    open() {
      return this.connect();
    }
    /**
     * Sends a `message` event.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * socket.send("hello");
     *
     * // this is equivalent to
     * socket.emit("message", "hello");
     *
     * @return self
     */
    send(...args) {
      args.unshift("message");
      this.emit.apply(this, args);
      return this;
    }
    /**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @example
     * socket.emit("hello", "world");
     *
     * // all serializable datastructures are supported (no need to call JSON.stringify)
     * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
     *
     * // with an acknowledgement from the server
     * socket.emit("hello", "world", (val) => {
     *   // ...
     * });
     *
     * @return self
     */
    emit(ev, ...args) {
      if (RESERVED_EVENTS.hasOwnProperty(ev)) {
        throw new Error('"' + ev.toString() + '" is a reserved event name');
      }
      args.unshift(ev);
      if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
        this._addToQueue(args);
        return this;
      }
      const packet = {
        type: socket_io_parser_1.PacketType.EVENT,
        data: args
      };
      packet.options = {};
      packet.options.compress = this.flags.compress !== false;
      if ("function" === typeof args[args.length - 1]) {
        const id2 = this.ids++;
        debug$1("emitting packet with ack id %d", id2);
        const ack = args.pop();
        this._registerAckCallback(id2, ack);
        packet.id = id2;
      }
      const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
      const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
      if (discardPacket) {
        debug$1("discard packet as the transport is not currently writable");
      } else if (this.connected) {
        this.notifyOutgoingListeners(packet);
        this.packet(packet);
      } else {
        this.sendBuffer.push(packet);
      }
      this.flags = {};
      return this;
    }
    /**
     * @private
     */
    _registerAckCallback(id2, ack) {
      var _a3;
      const timeout2 = (_a3 = this.flags.timeout) !== null && _a3 !== void 0 ? _a3 : this._opts.ackTimeout;
      if (timeout2 === void 0) {
        this.acks[id2] = ack;
        return;
      }
      const timer2 = this.io.setTimeoutFn(() => {
        delete this.acks[id2];
        for (let i2 = 0; i2 < this.sendBuffer.length; i2++) {
          if (this.sendBuffer[i2].id === id2) {
            debug$1("removing packet with ack id %d from the buffer", id2);
            this.sendBuffer.splice(i2, 1);
          }
        }
        debug$1("event with ack id %d has timed out after %d ms", id2, timeout2);
        ack.call(this, new Error("operation has timed out"));
      }, timeout2);
      this.acks[id2] = (...args) => {
        this.io.clearTimeoutFn(timer2);
        ack.apply(this, [null, ...args]);
      };
    }
    /**
     * Emits an event and waits for an acknowledgement
     *
     * @example
     * // without timeout
     * const response = await socket.emitWithAck("hello", "world");
     *
     * // with a specific timeout
     * try {
     *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
     * } catch (err) {
     *   // the server did not acknowledge the event in the given delay
     * }
     *
     * @return a Promise that will be fulfilled when the server acknowledges the event
     */
    emitWithAck(ev, ...args) {
      const withErr = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;
      return new Promise((resolve2, reject2) => {
        args.push((arg1, arg2) => {
          if (withErr) {
            return arg1 ? reject2(arg1) : resolve2(arg2);
          } else {
            return resolve2(arg1);
          }
        });
        this.emit(ev, ...args);
      });
    }
    /**
     * Add the packet to the queue.
     * @param args
     * @private
     */
    _addToQueue(args) {
      let ack;
      if (typeof args[args.length - 1] === "function") {
        ack = args.pop();
      }
      const packet = {
        id: this._queueSeq++,
        tryCount: 0,
        pending: false,
        args,
        flags: Object.assign({ fromQueue: true }, this.flags)
      };
      args.push((err, ...responseArgs) => {
        if (packet !== this._queue[0]) {
          return;
        }
        const hasError = err !== null;
        if (hasError) {
          if (packet.tryCount > this._opts.retries) {
            debug$1("packet [%d] is discarded after %d tries", packet.id, packet.tryCount);
            this._queue.shift();
            if (ack) {
              ack(err);
            }
          }
        } else {
          debug$1("packet [%d] was successfully sent", packet.id);
          this._queue.shift();
          if (ack) {
            ack(null, ...responseArgs);
          }
        }
        packet.pending = false;
        return this._drainQueue();
      });
      this._queue.push(packet);
      this._drainQueue();
    }
    /**
     * Send the first packet of the queue, and wait for an acknowledgement from the server.
     * @param force - whether to resend a packet that has not been acknowledged yet
     *
     * @private
     */
    _drainQueue(force = false) {
      debug$1("draining queue");
      if (!this.connected || this._queue.length === 0) {
        return;
      }
      const packet = this._queue[0];
      if (packet.pending && !force) {
        debug$1("packet [%d] has already been sent and is waiting for an ack", packet.id);
        return;
      }
      packet.pending = true;
      packet.tryCount++;
      debug$1("sending packet [%d] (try n%d)", packet.id, packet.tryCount);
      this.flags = packet.flags;
      this.emit.apply(this, packet.args);
    }
    /**
     * Sends a packet.
     *
     * @param packet
     * @private
     */
    packet(packet) {
      packet.nsp = this.nsp;
      this.io._packet(packet);
    }
    /**
     * Called upon engine `open`.
     *
     * @private
     */
    onopen() {
      debug$1("transport is open - connecting");
      if (typeof this.auth == "function") {
        this.auth((data2) => {
          this._sendConnectPacket(data2);
        });
      } else {
        this._sendConnectPacket(this.auth);
      }
    }
    /**
     * Sends a CONNECT packet to initiate the Socket.IO session.
     *
     * @param data
     * @private
     */
    _sendConnectPacket(data2) {
      this.packet({
        type: socket_io_parser_1.PacketType.CONNECT,
        data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data2) : data2
      });
    }
    /**
     * Called upon engine or manager `error`.
     *
     * @param err
     * @private
     */
    onerror(err) {
      if (!this.connected) {
        this.emitReserved("connect_error", err);
      }
    }
    /**
     * Called upon engine `close`.
     *
     * @param reason
     * @param description
     * @private
     */
    onclose(reason, description) {
      debug$1("close (%s)", reason);
      this.connected = false;
      delete this.id;
      this.emitReserved("disconnect", reason, description);
    }
    /**
     * Called with socket packet.
     *
     * @param packet
     * @private
     */
    onpacket(packet) {
      const sameNamespace = packet.nsp === this.nsp;
      if (!sameNamespace)
        return;
      switch (packet.type) {
        case socket_io_parser_1.PacketType.CONNECT:
          if (packet.data && packet.data.sid) {
            this.onconnect(packet.data.sid, packet.data.pid);
          } else {
            this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          }
          break;
        case socket_io_parser_1.PacketType.EVENT:
        case socket_io_parser_1.PacketType.BINARY_EVENT:
          this.onevent(packet);
          break;
        case socket_io_parser_1.PacketType.ACK:
        case socket_io_parser_1.PacketType.BINARY_ACK:
          this.onack(packet);
          break;
        case socket_io_parser_1.PacketType.DISCONNECT:
          this.ondisconnect();
          break;
        case socket_io_parser_1.PacketType.CONNECT_ERROR:
          this.destroy();
          const err = new Error(packet.data.message);
          err.data = packet.data.data;
          this.emitReserved("connect_error", err);
          break;
      }
    }
    /**
     * Called upon a server event.
     *
     * @param packet
     * @private
     */
    onevent(packet) {
      const args = packet.data || [];
      debug$1("emitting event %j", args);
      if (null != packet.id) {
        debug$1("attaching ack callback to event");
        args.push(this.ack(packet.id));
      }
      if (this.connected) {
        this.emitEvent(args);
      } else {
        this.receiveBuffer.push(Object.freeze(args));
      }
    }
    emitEvent(args) {
      if (this._anyListeners && this._anyListeners.length) {
        const listeners = this._anyListeners.slice();
        for (const listener of listeners) {
          listener.apply(this, args);
        }
      }
      super.emit.apply(this, args);
      if (this._pid && args.length && typeof args[args.length - 1] === "string") {
        this._lastOffset = args[args.length - 1];
      }
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @private
     */
    ack(id2) {
      const self2 = this;
      let sent = false;
      return function(...args) {
        if (sent)
          return;
        sent = true;
        debug$1("sending ack %j", args);
        self2.packet({
          type: socket_io_parser_1.PacketType.ACK,
          id: id2,
          data: args
        });
      };
    }
    /**
     * Called upon a server acknowlegement.
     *
     * @param packet
     * @private
     */
    onack(packet) {
      const ack = this.acks[packet.id];
      if ("function" === typeof ack) {
        debug$1("calling ack %s with %j", packet.id, packet.data);
        ack.apply(this, packet.data);
        delete this.acks[packet.id];
      } else {
        debug$1("bad ack %s", packet.id);
      }
    }
    /**
     * Called upon server connect.
     *
     * @private
     */
    onconnect(id2, pid) {
      debug$1("socket connected with id %s", id2);
      this.id = id2;
      this.recovered = pid && this._pid === pid;
      this._pid = pid;
      this.connected = true;
      this.emitBuffered();
      this.emitReserved("connect");
      this._drainQueue(true);
    }
    /**
     * Emit buffered events (received and emitted).
     *
     * @private
     */
    emitBuffered() {
      this.receiveBuffer.forEach((args) => this.emitEvent(args));
      this.receiveBuffer = [];
      this.sendBuffer.forEach((packet) => {
        this.notifyOutgoingListeners(packet);
        this.packet(packet);
      });
      this.sendBuffer = [];
    }
    /**
     * Called upon server disconnect.
     *
     * @private
     */
    ondisconnect() {
      debug$1("server disconnect (%s)", this.nsp);
      this.destroy();
      this.onclose("io server disconnect");
    }
    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @private
     */
    destroy() {
      if (this.subs) {
        this.subs.forEach((subDestroy) => subDestroy());
        this.subs = void 0;
      }
      this.io["_destroy"](this);
    }
    /**
     * Disconnects the socket manually. In that case, the socket will not try to reconnect.
     *
     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
     *
     * @example
     * const socket = io();
     *
     * socket.on("disconnect", (reason) => {
     *   // console.log(reason); prints "io client disconnect"
     * });
     *
     * socket.disconnect();
     *
     * @return self
     */
    disconnect() {
      if (this.connected) {
        debug$1("performing disconnect (%s)", this.nsp);
        this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });
      }
      this.destroy();
      if (this.connected) {
        this.onclose("io client disconnect");
      }
      return this;
    }
    /**
     * Alias for {@link disconnect()}.
     *
     * @return self
     */
    close() {
      return this.disconnect();
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * socket.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     */
    compress(compress) {
      this.flags.compress = compress;
      return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
     * ready to send messages.
     *
     * @example
     * socket.volatile.emit("hello"); // the server may or may not receive it
     *
     * @returns self
     */
    get volatile() {
      this.flags.volatile = true;
      return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
     * given number of milliseconds have elapsed without an acknowledgement from the server:
     *
     * @example
     * socket.timeout(5000).emit("my-event", (err) => {
     *   if (err) {
     *     // the server did not acknowledge the event in the given delay
     *   }
     * });
     *
     * @returns self
     */
    timeout(timeout2) {
      this.flags.timeout = timeout2;
      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * @example
     * socket.onAny((event, ...args) => {
     *   console.log(`got ${event}`);
     * });
     *
     * @param listener
     */
    onAny(listener) {
      this._anyListeners = this._anyListeners || [];
      this._anyListeners.push(listener);
      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @example
     * socket.prependAny((event, ...args) => {
     *   console.log(`got event ${event}`);
     * });
     *
     * @param listener
     */
    prependAny(listener) {
      this._anyListeners = this._anyListeners || [];
      this._anyListeners.unshift(listener);
      return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`got event ${event}`);
     * }
     *
     * socket.onAny(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAny(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAny();
     *
     * @param listener
     */
    offAny(listener) {
      if (!this._anyListeners) {
        return this;
      }
      if (listener) {
        const listeners = this._anyListeners;
        for (let i2 = 0; i2 < listeners.length; i2++) {
          if (listener === listeners[i2]) {
            listeners.splice(i2, 1);
            return this;
          }
        }
      } else {
        this._anyListeners = [];
      }
      return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAny() {
      return this._anyListeners || [];
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.onAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
    onAnyOutgoing(listener) {
      this._anyOutgoingListeners = this._anyOutgoingListeners || [];
      this._anyOutgoingListeners.push(listener);
      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.prependAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
    prependAnyOutgoing(listener) {
      this._anyOutgoingListeners = this._anyOutgoingListeners || [];
      this._anyOutgoingListeners.unshift(listener);
      return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`sent event ${event}`);
     * }
     *
     * socket.onAnyOutgoing(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAnyOutgoing(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAnyOutgoing();
     *
     * @param [listener] - the catch-all listener (optional)
     */
    offAnyOutgoing(listener) {
      if (!this._anyOutgoingListeners) {
        return this;
      }
      if (listener) {
        const listeners = this._anyOutgoingListeners;
        for (let i2 = 0; i2 < listeners.length; i2++) {
          if (listener === listeners[i2]) {
            listeners.splice(i2, 1);
            return this;
          }
        }
      } else {
        this._anyOutgoingListeners = [];
      }
      return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAnyOutgoing() {
      return this._anyOutgoingListeners || [];
    }
    /**
     * Notify the listeners for each packet sent
     *
     * @param packet
     *
     * @private
     */
    notifyOutgoingListeners(packet) {
      if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
        const listeners = this._anyOutgoingListeners.slice();
        for (const listener of listeners) {
          listener.apply(this, packet.data);
        }
      }
    }
  }
  socket.Socket = Socket;
  var backo2 = {};
  Object.defineProperty(backo2, "__esModule", { value: true });
  backo2.Backoff = void 0;
  function Backoff(opts) {
    opts = opts || {};
    this.ms = opts.min || 100;
    this.max = opts.max || 1e4;
    this.factor = opts.factor || 2;
    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
    this.attempts = 0;
  }
  backo2.Backoff = Backoff;
  Backoff.prototype.duration = function() {
    var ms2 = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
      var rand = Math.random();
      var deviation = Math.floor(rand * this.jitter * ms2);
      ms2 = (Math.floor(rand * 10) & 1) == 0 ? ms2 - deviation : ms2 + deviation;
    }
    return Math.min(ms2, this.max) | 0;
  };
  Backoff.prototype.reset = function() {
    this.attempts = 0;
  };
  Backoff.prototype.setMin = function(min2) {
    this.ms = min2;
  };
  Backoff.prototype.setMax = function(max2) {
    this.max = max2;
  };
  Backoff.prototype.setJitter = function(jitter) {
    this.jitter = jitter;
  };
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    Object.defineProperty(o, k22, { enumerable: true, get: function() {
      return m2[k2];
    } });
  } : function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o[k22] = m2[k2];
  });
  var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod2) {
    if (mod2 && mod2.__esModule)
      return mod2;
    var result = {};
    if (mod2 != null) {
      for (var k2 in mod2)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2))
          __createBinding(result, mod2, k2);
    }
    __setModuleDefault(result, mod2);
    return result;
  };
  var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(manager, "__esModule", { value: true });
  manager.Manager = void 0;
  const engine_io_client_1 = cjs$2;
  const socket_js_1 = socket;
  const parser = __importStar(cjs);
  const on_js_1 = on$1;
  const backo2_js_1 = backo2;
  const component_emitter_1 = require$$5;
  const debug_1 = __importDefault$1(browserExports);
  const debug = debug_1.default("socket.io-client:manager");
  class Manager extends component_emitter_1.Emitter {
    constructor(uri, opts) {
      var _a3;
      super();
      this.nsps = {};
      this.subs = [];
      if (uri && "object" === typeof uri) {
        opts = uri;
        uri = void 0;
      }
      opts = opts || {};
      opts.path = opts.path || "/socket.io";
      this.opts = opts;
      engine_io_client_1.installTimerFunctions(this, opts);
      this.reconnection(opts.reconnection !== false);
      this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
      this.reconnectionDelay(opts.reconnectionDelay || 1e3);
      this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
      this.randomizationFactor((_a3 = opts.randomizationFactor) !== null && _a3 !== void 0 ? _a3 : 0.5);
      this.backoff = new backo2_js_1.Backoff({
        min: this.reconnectionDelay(),
        max: this.reconnectionDelayMax(),
        jitter: this.randomizationFactor()
      });
      this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
      this._readyState = "closed";
      this.uri = uri;
      const _parser = opts.parser || parser;
      this.encoder = new _parser.Encoder();
      this.decoder = new _parser.Decoder();
      this._autoConnect = opts.autoConnect !== false;
      if (this._autoConnect)
        this.open();
    }
    reconnection(v) {
      if (!arguments.length)
        return this._reconnection;
      this._reconnection = !!v;
      return this;
    }
    reconnectionAttempts(v) {
      if (v === void 0)
        return this._reconnectionAttempts;
      this._reconnectionAttempts = v;
      return this;
    }
    reconnectionDelay(v) {
      var _a3;
      if (v === void 0)
        return this._reconnectionDelay;
      this._reconnectionDelay = v;
      (_a3 = this.backoff) === null || _a3 === void 0 ? void 0 : _a3.setMin(v);
      return this;
    }
    randomizationFactor(v) {
      var _a3;
      if (v === void 0)
        return this._randomizationFactor;
      this._randomizationFactor = v;
      (_a3 = this.backoff) === null || _a3 === void 0 ? void 0 : _a3.setJitter(v);
      return this;
    }
    reconnectionDelayMax(v) {
      var _a3;
      if (v === void 0)
        return this._reconnectionDelayMax;
      this._reconnectionDelayMax = v;
      (_a3 = this.backoff) === null || _a3 === void 0 ? void 0 : _a3.setMax(v);
      return this;
    }
    timeout(v) {
      if (!arguments.length)
        return this._timeout;
      this._timeout = v;
      return this;
    }
    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @private
     */
    maybeReconnectOnOpen() {
      if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
        this.reconnect();
      }
    }
    /**
     * Sets the current transport `socket`.
     *
     * @param {Function} fn - optional, callback
     * @return self
     * @public
     */
    open(fn) {
      debug("readyState %s", this._readyState);
      if (~this._readyState.indexOf("open"))
        return this;
      debug("opening %s", this.uri);
      this.engine = new engine_io_client_1.Socket(this.uri, this.opts);
      const socket2 = this.engine;
      const self2 = this;
      this._readyState = "opening";
      this.skipReconnect = false;
      const openSubDestroy = on_js_1.on(socket2, "open", function() {
        self2.onopen();
        fn && fn();
      });
      const onError = (err) => {
        debug("error");
        this.cleanup();
        this._readyState = "closed";
        this.emitReserved("error", err);
        if (fn) {
          fn(err);
        } else {
          this.maybeReconnectOnOpen();
        }
      };
      const errorSub = on_js_1.on(socket2, "error", onError);
      if (false !== this._timeout) {
        const timeout2 = this._timeout;
        debug("connect attempt will timeout after %d", timeout2);
        const timer2 = this.setTimeoutFn(() => {
          debug("connect attempt timed out after %d", timeout2);
          openSubDestroy();
          onError(new Error("timeout"));
          socket2.close();
        }, timeout2);
        if (this.opts.autoUnref) {
          timer2.unref();
        }
        this.subs.push(() => {
          this.clearTimeoutFn(timer2);
        });
      }
      this.subs.push(openSubDestroy);
      this.subs.push(errorSub);
      return this;
    }
    /**
     * Alias for open()
     *
     * @return self
     * @public
     */
    connect(fn) {
      return this.open(fn);
    }
    /**
     * Called upon transport open.
     *
     * @private
     */
    onopen() {
      debug("open");
      this.cleanup();
      this._readyState = "open";
      this.emitReserved("open");
      const socket2 = this.engine;
      this.subs.push(on_js_1.on(socket2, "ping", this.onping.bind(this)), on_js_1.on(socket2, "data", this.ondata.bind(this)), on_js_1.on(socket2, "error", this.onerror.bind(this)), on_js_1.on(socket2, "close", this.onclose.bind(this)), on_js_1.on(this.decoder, "decoded", this.ondecoded.bind(this)));
    }
    /**
     * Called upon a ping.
     *
     * @private
     */
    onping() {
      this.emitReserved("ping");
    }
    /**
     * Called with data.
     *
     * @private
     */
    ondata(data2) {
      try {
        this.decoder.add(data2);
      } catch (e) {
        this.onclose("parse error", e);
      }
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */
    ondecoded(packet) {
      engine_io_client_1.nextTick(() => {
        this.emitReserved("packet", packet);
      }, this.setTimeoutFn);
    }
    /**
     * Called upon socket error.
     *
     * @private
     */
    onerror(err) {
      debug("error", err);
      this.emitReserved("error", err);
    }
    /**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @public
     */
    socket(nsp, opts) {
      let socket2 = this.nsps[nsp];
      if (!socket2) {
        socket2 = new socket_js_1.Socket(this, nsp, opts);
        this.nsps[nsp] = socket2;
      } else if (this._autoConnect && !socket2.active) {
        socket2.connect();
      }
      return socket2;
    }
    /**
     * Called upon a socket close.
     *
     * @param socket
     * @private
     */
    _destroy(socket2) {
      const nsps = Object.keys(this.nsps);
      for (const nsp of nsps) {
        const socket3 = this.nsps[nsp];
        if (socket3.active) {
          debug("socket %s is still active, skipping close", nsp);
          return;
        }
      }
      this._close();
    }
    /**
     * Writes a packet.
     *
     * @param packet
     * @private
     */
    _packet(packet) {
      debug("writing packet %j", packet);
      const encodedPackets = this.encoder.encode(packet);
      for (let i2 = 0; i2 < encodedPackets.length; i2++) {
        this.engine.write(encodedPackets[i2], packet.options);
      }
    }
    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @private
     */
    cleanup() {
      debug("cleanup");
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs.length = 0;
      this.decoder.destroy();
    }
    /**
     * Close the current socket.
     *
     * @private
     */
    _close() {
      debug("disconnect");
      this.skipReconnect = true;
      this._reconnecting = false;
      this.onclose("forced close");
      if (this.engine)
        this.engine.close();
    }
    /**
     * Alias for close()
     *
     * @private
     */
    disconnect() {
      return this._close();
    }
    /**
     * Called upon engine close.
     *
     * @private
     */
    onclose(reason, description) {
      debug("closed due to %s", reason);
      this.cleanup();
      this.backoff.reset();
      this._readyState = "closed";
      this.emitReserved("close", reason, description);
      if (this._reconnection && !this.skipReconnect) {
        this.reconnect();
      }
    }
    /**
     * Attempt a reconnection.
     *
     * @private
     */
    reconnect() {
      if (this._reconnecting || this.skipReconnect)
        return this;
      const self2 = this;
      if (this.backoff.attempts >= this._reconnectionAttempts) {
        debug("reconnect failed");
        this.backoff.reset();
        this.emitReserved("reconnect_failed");
        this._reconnecting = false;
      } else {
        const delay2 = this.backoff.duration();
        debug("will wait %dms before reconnect attempt", delay2);
        this._reconnecting = true;
        const timer2 = this.setTimeoutFn(() => {
          if (self2.skipReconnect)
            return;
          debug("attempting reconnect");
          this.emitReserved("reconnect_attempt", self2.backoff.attempts);
          if (self2.skipReconnect)
            return;
          self2.open((err) => {
            if (err) {
              debug("reconnect attempt error");
              self2._reconnecting = false;
              self2.reconnect();
              this.emitReserved("reconnect_error", err);
            } else {
              debug("reconnect success");
              self2.onreconnect();
            }
          });
        }, delay2);
        if (this.opts.autoUnref) {
          timer2.unref();
        }
        this.subs.push(() => {
          this.clearTimeoutFn(timer2);
        });
      }
    }
    /**
     * Called upon successful reconnect.
     *
     * @private
     */
    onreconnect() {
      const attempt = this.backoff.attempts;
      this._reconnecting = false;
      this.backoff.reset();
      this.emitReserved("reconnect", attempt);
    }
  }
  manager.Manager = Manager;
  (function(module2, exports3) {
    var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.default = exports3.connect = exports3.io = exports3.Socket = exports3.Manager = exports3.protocol = void 0;
    const url_js_1 = url$1;
    const manager_js_1 = manager;
    Object.defineProperty(exports3, "Manager", { enumerable: true, get: function() {
      return manager_js_1.Manager;
    } });
    const socket_js_12 = socket;
    Object.defineProperty(exports3, "Socket", { enumerable: true, get: function() {
      return socket_js_12.Socket;
    } });
    const debug_12 = __importDefault2(browserExports);
    const debug2 = debug_12.default("socket.io-client");
    const cache = {};
    function lookup2(uri, opts) {
      if (typeof uri === "object") {
        opts = uri;
        uri = void 0;
      }
      opts = opts || {};
      const parsed = url_js_1.url(uri, opts.path || "/socket.io");
      const source = parsed.source;
      const id2 = parsed.id;
      const path2 = parsed.path;
      const sameNamespace = cache[id2] && path2 in cache[id2]["nsps"];
      const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
      let io2;
      if (newConnection) {
        debug2("ignoring socket cache for %s", source);
        io2 = new manager_js_1.Manager(source, opts);
      } else {
        if (!cache[id2]) {
          debug2("new io instance for %s", source);
          cache[id2] = new manager_js_1.Manager(source, opts);
        }
        io2 = cache[id2];
      }
      if (parsed.query && !opts.query) {
        opts.query = parsed.queryKey;
      }
      return io2.socket(parsed.path, opts);
    }
    exports3.io = lookup2;
    exports3.connect = lookup2;
    exports3.default = lookup2;
    Object.assign(lookup2, {
      Manager: manager_js_1.Manager,
      Socket: socket_js_12.Socket,
      io: lookup2,
      connect: lookup2
    });
    var socket_io_parser_12 = cjs;
    Object.defineProperty(exports3, "protocol", { enumerable: true, get: function() {
      return socket_io_parser_12.protocol;
    } });
    module2.exports = lookup2;
  })(cjs$3, cjs$3.exports);
  var cjsExports = cjs$3.exports;
  function Wait(interval2, beforeTime, afterTime, limit) {
    this.every(interval2, limit);
    this.before(beforeTime);
    this.after(afterTime | 0);
  }
  Wait.prototype = {
    before: function(time) {
      this.startTime = Date.now();
      this.expires = this.startTime + time;
      return this;
    },
    and: function(func) {
      this.routine = func;
      return this;
    },
    after: function(time) {
      this.afterTime = time;
      return this;
    },
    every: function(interval2, limit) {
      this.interval = interval2;
      if (limit != null)
        this.limit(limit);
      return this;
    },
    limit: function(limit) {
      limit = limit > 0 ? limit : Infinity;
      this.limit = limit;
      return this;
    },
    check: function(cond) {
      cond = cond || function() {
      };
      return this.before(0).until(cond);
    },
    forward: function() {
      return this.until(function() {
        return false;
      });
    },
    till: function(cond) {
      var self2 = this;
      return this.until(function() {
        var res;
        try {
          res = cond();
          return res === true;
        } catch (ex) {
          self2.limit = 0;
          throw ex;
        }
      });
    },
    until: function(cond) {
      var interval2 = this.interval, afterTime = this.afterTime, routine = this.routine, self2 = this;
      var timer2, called = 0;
      return new Promise(function(resolve2, reject2) {
        function f2() {
          var err, res;
          routine && routine(called);
          called++;
          try {
            res = cond();
          } catch (ex) {
            err = ex;
          } finally {
            if (Date.now() >= self2.expires || called >= self2.limit) {
              clearInterval(timer2);
              if (err !== void 0 || res === false) {
                reject2(err || new Error("check failed"));
              } else {
                resolve2(res);
              }
              return true;
            } else if (err === void 0 && res !== false) {
              clearInterval(timer2);
              resolve2(res);
              return true;
            }
            return false;
          }
        }
        setTimeout(function() {
          if (!f2()) {
            timer2 = setInterval(f2, interval2);
          }
        }, afterTime);
      });
    }
  };
  var waitPromise = {
    every: function(interval2, limit) {
      return new Wait(interval2, Infinity, 0, limit);
    },
    and: function(func) {
      return new Wait(100, Infinity, 0).and(func);
    },
    limit: function(limit) {
      return new Wait(100, Infinity, 0, limit);
    },
    before: function(time, limit) {
      return new Wait(100, time, 0, limit);
    },
    after: function(time) {
      return new Wait(100, Infinity, time);
    },
    sleep: function(time) {
      return new Wait(100, Infinity, time).check();
    },
    until: function(cond) {
      return new Wait(100, Infinity).until(cond);
    },
    forward: function() {
      return new Wait(100, Infinity).forward();
    },
    till: function(cond) {
      return new Wait(100, Infinity).till(cond);
    },
    check: function(cond) {
      return new Wait(100, 0).until(cond);
    }
  };
  var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve2) {
        resolve2(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve2, reject2) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject2(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject2(e);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f2, y, t2, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n2) {
      return function(v) {
        return step([n2, v]);
      };
    }
    function step(op) {
      if (f2)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _)
        try {
          if (f2 = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t2[1]) {
                _.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _.label < t2[2]) {
                _.label = t2[2];
                _.ops.push(op);
                break;
              }
              if (t2[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f2 = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  Object.defineProperty(lib$1, "__esModule", { value: true });
  lib$1.Events = void 0;
  var events_1 = require$$0;
  var io = cjsExports;
  var wait$1 = waitPromise;
  var sleep$1 = wait$1.sleep;
  var Events$1 = (
    /** @class */
    function() {
      function Events2(config2) {
        this.wss = config2.wss;
        this.isConnected = false;
        this.isTestnet = false;
        this.username = config2.username;
        this.queryKey = config2.queryKey;
        this.isPaired = false;
        this.events = new events_1.EventEmitter();
        this.init = function() {
          return __awaiter(this, void 0, void 0, function() {
            var e_1;
            var _this = this;
            return __generator(this, function(_a3) {
              switch (_a3.label) {
                case 0:
                  _a3.label = 1;
                case 1:
                  _a3.trys.push([1, 5, , 6]);
                  this.socket = io.connect(this.wss, {
                    reconnect: true,
                    rejectUnauthorized: false,
                    transports: ["websocket"]
                  });
                  this.socket.on("connect", function() {
                    _this.isConnected = true;
                    if (_this.username) {
                      _this.pair();
                    } else {
                      _this.subscribeToKey();
                    }
                  });
                  this.socket.on("subscribedToUsername", function(event2) {
                    _this.isPaired = true;
                    _this.username = event2.username;
                  });
                  this.socket.on("message", function(message) {
                    _this.events.emit("message", message);
                  });
                  this.socket.on("blocks", function(message) {
                    _this.events.emit("message", message);
                  });
                  this.socket.on("errorMessage", function(message) {
                    if (message.code && message.code === 6)
                      throw Error(" Failed to connect!");
                  });
                  this.socket.on("invocation", function(message) {
                    _this.events.emit("message", message);
                  });
                  _a3.label = 2;
                case 2:
                  if (!!this.isConnected)
                    return [3, 4];
                  return [4, sleep$1(300)];
                case 3:
                  _a3.sent();
                  return [3, 2];
                case 4:
                  return [2, true];
                case 5:
                  e_1 = _a3.sent();
                  console.error(e_1);
                  throw e_1;
                case 6:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        this.setUsername = function(username) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a3) {
              try {
                this.username = username;
              } catch (e) {
                console.error(e);
              }
              return [
                2
                /*return*/
              ];
            });
          });
        };
        this.subscribeToInvocation = function(invocationId) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a3) {
              try {
                this.socket.emit("join", {
                  invocationId
                });
                return [2, true];
              } catch (e) {
                console.error(e);
                throw e;
              }
              return [
                2
                /*return*/
              ];
            });
          });
        };
        this.subscribeToKey = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a3) {
              try {
                this.socket.emit("join", {
                  queryKey: config2.queryKey
                });
                return [2, true];
              } catch (e) {
                console.error(e);
                throw e;
              }
              return [
                2
                /*return*/
              ];
            });
          });
        };
        this.send = function(channel, event2) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a3) {
              try {
                this.socket.emit(channel, event2);
                return [2, true];
              } catch (e) {
                console.error(e);
                throw e;
              }
              return [
                2
                /*return*/
              ];
            });
          });
        };
        this.pair = function(username) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a3) {
              try {
                if (username)
                  this.username = username;
                if (!this.username)
                  throw Error("103: can not pair without username!");
                this.socket.emit("join", {
                  username: this.username,
                  queryKey: config2.queryKey
                });
                return [2, true];
              } catch (e) {
                console.error(e);
                throw e;
              }
              return [
                2
                /*return*/
              ];
            });
          });
        };
        this.disconnect = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a3) {
              try {
                return [2, this.socket.disconnect()];
              } catch (e) {
                console.error(e);
              }
              return [
                2
                /*return*/
              ];
            });
          });
        };
      }
      return Events2;
    }()
  );
  lib$1.Events = Events$1;
  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(lib$9, "__esModule", { value: true });
  var SDK_1 = lib$9.SDK = void 0;
  const TAG = " | Pioneer-sdk | ";
  const log = libExports();
  let { blockchains, getPaths, getPrecision, getExplorerUrl, getExplorerAddressUrl, getExplorerTxUrl, baseAmountToNative, nativeToBaseAmount, getNativeAssetForBlockchain, assetToBase, assetAmount, getSwapProtocals, xpubConvert, addressNListToBIP32, COIN_MAP, COIN_MAP_LONG, COIN_MAP_KEEPKEY_LONG, getRangoBlockchainName } = lib$7;
  const rango_sdk_1 = require$$2;
  const pioneer_client_1 = __importDefault(lib$6);
  let TxBuilder = lib$3;
  const Events = lib$1;
  let wait = waitPromise;
  let sleep = wait.sleep;
  let WALLET_ICONS = {
    "keepkey": "https://pioneers.dev/coins/keepkey.png",
    "native": "https://pioneers.dev/coins/pioneer.png",
    "metamask": "https://pioneers.dev/coins/metamask.png"
  };
  class SDK {
    constructor(spec, config2) {
      this.status = "preInit";
      this.apiVersion = "";
      this.initialized = false;
      this.blockchains = config2.blockchains || blockchains;
      this.wss = config2.wss || "wss://pioneers.dev";
      this.username = config2.username;
      this.queryKey = config2.queryKey;
      this.spec = config2.spec || "https://pioneers.dev/spec/swagger";
      this.rangoApiKey = config2.rangoApiKey || "02b14225-f62e-4e4f-863e-a8145e5befe5";
      this.paths = [...config2.paths, ...getPaths(this.blockchains)];
      this.pubkeys = [];
      this.markets = {};
      this.events = {};
      this.isSynced = false;
      this.isPaired = false;
      this.isConnected = false;
      this.context = "";
      this.publicAddress = "";
      this.contexts = [];
      this.invocations = [];
      this.balances = [];
      this.markets = {};
      this.assetContext = {
        name: "ethereum",
        type: "coin",
        caip: "eip155:1/slip44:60",
        tags: [
          "ethereum",
          "isAsset",
          "isNative",
          "KeepKeySupport",
          "DappSupport",
          "WalletConnectSupport"
        ],
        blockchain: "ethereum",
        symbol: "ETH",
        decimals: 18,
        image: "https://pioneers.dev/coins/ethereum.png",
        description: "Open source platform to write and distribute decentralized applications.",
        website: "https://ethereum.org/",
        explorer: "https://etherscan.io/",
        rank: 2
      };
      this.blockchainContext = {
        blockchain: "ethereum",
        caip: "eip155:1/slip44:60",
        chainId: 1,
        description: "more info here: https://ethereum.org This is a EVM network with chainId: 1 Follows EIP:155",
        explorer: "https://ethereum.org",
        faucets: [],
        feeAssetCaip: "eip155:1/slip44:60",
        feeAssetName: "ethereum",
        feeAssetRank: 2,
        feeAssetSymbol: "ETH",
        image: "https://pioneers.dev/coins/ethereum-mainnet.png",
        isCharted: false,
        name: "ethereum",
        network: "ETH",
        service: null,
        symbol: "ETH",
        tags: [
          "KeepKeySupport",
          "DappSupport",
          "WalletConnectSupport",
          "EVM",
          "EIP:155",
          "ethereum",
          "Ether",
          "ETH",
          1,
          null
        ],
        type: "EVM"
      };
      this.wallets = [];
      this.events = {};
      this.totalValueUsd = 0;
      this.ibcChannels = [];
      this.paymentStreams = [];
      this.nfts = [];
      this.init = async function() {
        let tag = TAG + " | init | ";
        try {
          if (!this.username)
            throw Error("username required!");
          if (!this.queryKey)
            throw Error("queryKey required!");
          if (!this.wss)
            throw Error("wss required!");
          let PioneerClient = new pioneer_client_1.default(config2.spec, config2);
          this.pioneer = await PioneerClient.init();
          if (!this.pioneer)
            throw Error("Fialed to init pioneer server!");
          this.rango = new rango_sdk_1.RangoClient(this.rangoApiKey);
          log.debug(tag, "TxBuilder.TxBuilder: ", TxBuilder);
          log.debug(tag, "TxBuilder.TxBuilder config: ", config2);
          this.txBuilder = new TxBuilder.TxBuilder(this.pioneer, config2);
          log.debug(tag, "txBuilder: ", this.txBuilder);
          let health = await this.pioneer.Health();
          if (!health.data.online)
            throw Error("Pioneer Server offline!");
          log.debug(tag, "pioneer health: ", health.data);
          let status = await this.pioneer.Status();
          log.debug(tag, "pioneer status: ", status.data);
          this.markets = status.data.rango;
          this.getInvocations();
          let userInfo = await this.pioneer.User();
          userInfo = userInfo.data;
          log.debug(tag, "1 userInfo: ", userInfo);
          if (userInfo) {
            if (userInfo.isSynced)
              this.isSynced = userInfo.isSynced;
            if (userInfo.wallets)
              this.pubkeys = userInfo.wallets;
            if (userInfo.pubkeys)
              this.pubkeys = userInfo.pubkeys;
            if (userInfo.context)
              this.context = userInfo.context;
            if (userInfo.balances)
              this.balances = userInfo.balances;
            if (userInfo.nfts)
              this.nfts = userInfo.nfts;
          }
          if (!userInfo || userInfo.error) {
            log.debug(tag, "user not registered! info: ", userInfo);
            log.debug("no wallet found, and no user found, registering empty user!");
            let register = {
              username: this.username,
              blockchains: this.blockchains,
              publicAddress: "none",
              context: "none",
              walletDescription: {
                context: "none",
                type: "none"
              },
              data: {
                pubkeys: []
              },
              queryKey: this.queryKey,
              auth: "lol",
              provider: "lol"
            };
            log.debug(tag, "register payload: ", register);
            let result = await this.pioneer.Register(register);
            log.debug(tag, "register result: ", result.data);
            if (result.data.context)
              this.balances = result.data.context;
            if (result.data.balances)
              this.balances = result.data.balances;
            if (result.data.isSynced)
              this.isSynced = result.data.isSynced;
            if (result.data.pubkeys)
              this.pubkeys = result.data.pubkeys;
          }
          if (!this.pioneer)
            throw Error("Failed to init pioneer server!");
          return this.pioneer;
        } catch (e) {
          log.error(tag, "e: ", e);
        }
      };
      this.getContextStringForWallet = async function(wallet2) {
        let tag = TAG + " | getContextStringForWallet | ";
        try {
          if (!wallet2)
            throw Error("wallet required to get context string!");
          let isNative = await (wallet2 === null || wallet2 === void 0 ? void 0 : wallet2._isNative);
          let isKeepKey = await (wallet2 === null || wallet2 === void 0 ? void 0 : wallet2._isKeepKey);
          let isMetaMask = await (wallet2 === null || wallet2 === void 0 ? void 0 : wallet2._isMetaMask);
          if (isNative)
            wallet2.type = "native";
          if (isKeepKey)
            wallet2.type = "keepkey";
          if (isMetaMask)
            wallet2.type = "metamask";
          if (!isNative && !isKeepKey && !isMetaMask) {
            log.debug(tag, "wallet: ", wallet2);
            throw Error("can not init: Unhandled Wallet type!");
          }
          log.debug(tag, "wallet type: ", wallet2.type);
          let ethAddress;
          if (wallet2.type === "metamask") {
            ethAddress = "metamask";
          } else {
            const addressInfo = {
              addressNList: [2147483692, 2147483708, 2147483648, 0, 0],
              coin: "Ethereum",
              scriptType: "ethereum",
              showDisplay: false
            };
            ethAddress = await wallet2.ethGetAddress(addressInfo);
            log.debug(tag, "ethAddress: ", ethAddress);
          }
          if (!ethAddress)
            throw Error("Failed to get eth address!");
          let context2 = ethAddress + ".wallet";
          return context2;
        } catch (e) {
          throw Error(e);
        }
      };
      this.setContext = async function(wallet2) {
        let tag = TAG + " | setContext | ";
        try {
          let context2 = await this.getContextStringForWallet(wallet2);
          log.debug(tag, "context: ", context2);
          const isContextExist = this.wallets.some((wallet3) => wallet3.context === context2);
          log.debug(tag, "isContextExist: ", isContextExist);
          if (isContextExist) {
            this.context = context2;
            this.wallet = wallet2;
            let blockchain = this.blockchainContext;
            log.debug(tag, "this.pubkeys: ", this.pubkeys);
            log.debug(tag, "blockchainContext: ", blockchain);
            log.debug(tag, "blockchain: ", blockchain.name);
            log.debug(tag, "context: ", context2);
            let pubkeysForContext = this.pubkeys.filter((item) => item.context === context2);
            log.debug(tag, "pubkeysForContext: ", pubkeysForContext);
            let pubkey2 = pubkeysForContext.find((item) => item.blockchain === blockchain.name && item.context === context2);
            log.debug(tag, "pubkey: ", pubkey2);
            if (pubkey2) {
              this.pubkeyContext = pubkey2;
              log.debug(tag, "pubkeyContext: ", this.pubkeyContext);
            } else {
              log.debug(tag, "pubkeys: ", this.pubkeys);
              log.debug(tag, "pubkeysForContext: ", pubkeysForContext);
              throw Error("unable to find (" + blockchain.name + ") pubkey for context! " + context2);
            }
            return { success: true };
          } else {
            throw Error("Wallet context not found paired! con not set context to unpaired wallet!" + context2);
          }
        } catch (e) {
          log.error(tag, e);
          throw e;
        }
      }, this.pairWallet = async function(wallet2) {
        let tag = TAG + " | pairWallet | ";
        try {
          log.debug(tag, "Pairing Wallet");
          if (!wallet2)
            throw Error("Must have wallet to pair!");
          if (!this.blockchains)
            throw Error("Must have blockchains to pair!");
          if (!this.username)
            throw Error("Must have username to pair!");
          let isNative = await (wallet2 === null || wallet2 === void 0 ? void 0 : wallet2._isNative);
          let isKeepKey = await (wallet2 === null || wallet2 === void 0 ? void 0 : wallet2._isKeepKey);
          let isMetaMask = await (wallet2 === null || wallet2 === void 0 ? void 0 : wallet2._isMetaMask);
          if (isNative)
            wallet2.type = "native";
          if (isKeepKey)
            wallet2.type = "keepkey";
          if (isMetaMask)
            wallet2.type = "metamask";
          if (!isNative && !isKeepKey && !isMetaMask) {
            log.debug(tag, "wallet: ", wallet2);
            throw Error("can not init: Unhandled Wallet type!");
          }
          log.debug(tag, "this.wallets: ", this.wallets);
          let context2 = await this.getContextStringForWallet(wallet2);
          log.debug(tag, "context: ", context2);
          if (!this.wallets.some((w) => w.context === context2)) {
            let walletInfo = {
              context: context2,
              type: wallet2.type,
              icon: WALLET_ICONS[wallet2.type],
              status: "connected",
              wallet: wallet2
            };
            this.wallets.push(walletInfo);
          }
          log.debug(tag, "this.wallets: ", this.wallets);
          let pubkeys = await this.getPubkeys(wallet2);
          if (!pubkeys)
            throw Error("Failed to get Pubkeys!");
          if (!pubkeys.pubkeys)
            throw Error("Failed to get Pubkeys!");
          log.debug("Pubkeys BEFORE pairing: ", this.pubkeys);
          for (let i2 = 0; i2 < pubkeys.pubkeys.length; i2++) {
            let pubkey2 = pubkeys.pubkeys[i2];
            this.pubkeys.push(pubkey2);
          }
          log.debug("Pubkeys AFTER pairing: ", this.pubkeys);
          await this.setContext(wallet2);
          this.isConnected = true;
          if (!this.username)
            throw Error("username not set!");
          let register = {
            username: this.username,
            blockchains: this.blockchains,
            context: pubkeys.context,
            publicAddress: pubkeys.publicAddress,
            walletDescription: {
              context: pubkeys.context,
              type: wallet2.type
            },
            data: {
              pubkeys: pubkeys.pubkeys
            },
            queryKey: this.queryKey,
            auth: "lol",
            provider: "lol"
          };
          log.debug(tag, "register payload: ", register);
          let result = await this.pioneer.Register(register);
          log.debug(tag, "register result: ", result);
          if (result.data.balances)
            this.balances = result.data.balances;
          if (result.data.nfts)
            this.nfts = result.data.nfts;
          return result;
        } catch (e) {
          log.error(tag, "e: ", e);
          log.error(tag, "e: ", JSON.stringify(e));
        }
      };
      this.disconnectWallet = async function(context2) {
        let tag = TAG + " | disconnectWallet | ";
        try {
          const walletIndex = this.wallets.findIndex((wallet2) => wallet2.context === context2);
          if (walletIndex !== -1) {
            this.wallets[walletIndex].status = "disconnected";
          } else {
            log.error(tag, "Wallet with the given context not found.");
          }
          return this.wallets;
        } catch (e) {
          log.error(tag, "e: ", e);
        }
      };
      this.refresh = async function() {
        let tag = TAG + " | refresh | ";
        try {
          let result = await this.pioneer.Refresh();
          await this.updateContext();
          return result.data;
        } catch (e) {
          log.error(tag, "e: ", e);
        }
      };
      this.setPubkeyContext = async function(pubkeyObj) {
        const tag = TAG + " | setPubkeyContext | ";
        try {
          const pubkeyToFind = pubkeyObj.pubkey;
          const pubkeyFound = this.pubkeys.find((item) => item.pubkey === pubkeyToFind);
          if (pubkeyFound) {
            this.pubkeyContext = pubkeyFound;
            return true;
          } else {
            return false;
          }
        } catch (e) {
          log.error(tag, "Error: ", e);
          throw e;
        }
      };
      this.setBlockchainContext = async function(blockchain) {
        let tag = TAG + " | setBlockchainContext | ";
        try {
          if (blockchain && this.blockchainContext && this.blockchainContext !== blockchain) {
            let result = await this.pioneer.SetBlockchainContext({ blockchain });
            log.debug(tag, "result: ", result);
            this.blockchainContext = blockchain;
            return result.data;
          } else {
            return { success: false, error: "already blockchain context=" + blockchain };
          }
        } catch (e) {
          log.error(tag, "e: ", e);
        }
      };
      this.setAssetContext = async function(asset) {
        let tag = TAG + " | setAssetContext | ";
        try {
          if (asset && this.assetContext && this.assetContext !== asset) {
            let result = await this.pioneer.SetAssetContext({ asset });
            log.debug(tag, "result: ", result.data);
            if (result && result.data && result.data.success) {
              log.debug(tag, "settingAssetContext: ", asset);
              if (asset === null || asset === void 0 ? void 0 : asset.blockchainCaip) {
                let blockchain = await this.pioneer.BlockchainByCaip({ caip: asset === null || asset === void 0 ? void 0 : asset.blockchainCaip });
                if (blockchain)
                  await this.setBlockchainContext(blockchain);
              }
              this.assetContext = asset;
              return result.data;
            } else {
              log.error(tag, "result: ", result);
              log.error(tag, "result.error: ", result.error);
              return { success: false, error: result };
            }
          } else {
            return { success: false, error: "already asset context=" + asset };
          }
        } catch (e) {
          log.error(tag, "e: ", e);
        }
      };
      this.getInvocation = async function(invocationId) {
        let tag = TAG + " | getInvocations | ";
        try {
          if (!invocationId)
            throw Error("invocationId required!");
          let result = await this.pioneer.Invocation(invocationId);
          return result.data;
        } catch (e) {
          log.error(tag, "e: ", e);
        }
      };
      this.getInvocations = async function() {
        let tag = TAG + " | getInvocations | ";
        try {
          let result = await this.pioneer.Invocations();
          this.invocations = result.data;
          return result.data;
        } catch (e) {
          log.error(tag, "e: ", e);
        }
      };
      this.deleteInvocation = async function(invocationId) {
        let tag = TAG + " | deleteInvocation | ";
        try {
          if (!invocationId)
            throw Error("invocationId required!");
          let result = await this.pioneer.DeleteInvocation("", { invocationId });
          return result.data;
        } catch (e) {
          log.error(tag, "e: ", e);
        }
      };
      this.startSocket = function() {
        let tag = TAG + " | startSocket | ";
        try {
          let configEvents = {
            queryKey: this.queryKey,
            wss: this.wss
          };
          if (this.username)
            configEvents.username = this.username;
          log.debug(tag, "configEvents: ", configEvents);
          this.events = new Events.Events(config2);
          this.events.init();
          if (this.username) {
            this.events.pair(this.username);
          }
          this.events.events.on("message", (event2) => {
            log.debug(tag, "message event! ", event2);
            this.isPaired = true;
            this.updateContext();
            this.events.pair(this.username);
            log.debug(tag, "EVENT type: ", event2.type);
          });
          this.events.events.on("pairings", (event2) => {
            log.debug(tag, "message event! ", event2);
            this.isPaired = true;
            this.username = event2.username;
            this.updateContext();
            this.events.pair(this.username);
            log.debug(tag, "EVENT type: ", event2.type);
          });
          this.events.events.on("context", (event2) => {
            log.debug(tag, "context set to " + event2.context);
            this.context = event2.context;
            this.updateContext();
          });
          this.events.events.on("pubkey", (event2) => {
            log.debug(tag, "pubkey event!", event2);
          });
          this.events.events.on("blocks", (event2) => {
            log.debug(tag, "blocks event!", event2);
          });
          this.events.events.on("balances", (event2) => {
            log.debug(tag, "balances event!", event2);
          });
          this.events.events.on("invocations", async (event2) => {
            switch (event2.type) {
              case "update":
                break;
              case "signRequest":
                log.debug("signRequest: ", event2.invocation.unsignedTx);
                break;
              default:
                log.debug(tag, "unhandled: ", event2.type);
            }
          });
          return this.events.events;
        } catch (e) {
          log.error(tag, "e: ", e);
        }
      };
      this.stopSocket = function() {
        let tag = TAG + " | stopSocket | ";
        try {
          this.events.disconnect();
          return this.events.events;
        } catch (e) {
          log.error(tag, "e: ", e);
        }
      };
      this.updateContext = async function() {
        let tag = TAG + " | updateContext | ";
        try {
          let userInfo = await this.pioneer.User();
          userInfo = userInfo.data;
          log.debug(tag, "userInfo: ", userInfo);
          if (!userInfo.pubkeys)
            userInfo.pubkeys = [];
          let pubkeyChains = [];
          for (let i2 = 0; i2 < userInfo.pubkeys.length; i2++) {
            let pubkey2 = userInfo.pubkeys[i2];
            pubkeyChains.push(pubkey2.blockchain);
          }
          pubkeyChains = [...new Set(pubkeyChains)];
          log.debug(tag, "pubkeyChains: ", pubkeyChains);
          log.debug(tag, "pubkeyChains: ", pubkeyChains.length);
          log.debug(tag, "blockchains: ", this.blockchains.length);
          log.debug(tag, "blockchains: ", this.blockchains);
          let missingBlockchains = pubkeyChains.filter((x2) => !this.blockchains.includes(x2)).concat(this.blockchains.filter((x2) => !pubkeyChains.includes(x2)));
          log.debug(tag, "missingBlockchains: ", missingBlockchains);
          if (userInfo.username)
            this.username = userInfo.username;
          if (userInfo.context)
            this.context = userInfo.context;
          if (userInfo.balances)
            this.balances = userInfo.balances;
          if (userInfo.totalValueUsd)
            this.totalValueUsd = parseFloat(userInfo.totalValueUsd);
          if (userInfo.assetContext)
            this.assetContext = userInfo.assetContext;
          return userInfo;
        } catch (e) {
          log.error(tag, "e: ", e);
        }
      };
      this.getPubkeys = async function(wallet2) {
        let tag = TAG + " | getPubkeys | ";
        try {
          let output2 = {};
          log.debug(tag, "checkpoint");
          let context2 = await this.getContextStringForWallet(wallet2);
          if (!wallet2)
            throw Error("can not get pubkeys! Wallet not sent!");
          if (!this.blockchains)
            throw Error("blockchains not set!");
          let paths2 = this.paths;
          log.debug(tag, "paths: ", paths2);
          if (!paths2 || paths2.length === 0)
            throw Error("Failed to get paths!");
          for (let i2 = 0; i2 < this.blockchains.length; i2++) {
            let blockchain = this.blockchains[i2];
            let symbol = getNativeAssetForBlockchain(blockchain);
            log.debug(tag, "symbol: ", symbol);
            let isFound = paths2.find((path2) => {
              return path2.blockchain === blockchain;
            });
            if (!isFound) {
              throw Error("Failed to find path for blockchain: " + blockchain);
            }
          }
          let pubkeys = [];
          let keyedWallet = {};
          let ethMaster = null;
          if (wallet2 === null || wallet2 === void 0 ? void 0 : wallet2._isNative) {
            log.debug(tag, "Is Native, format pubkeys");
            let pathsKeepkey = [];
            for (let i2 = 0; i2 < paths2.length; i2++) {
              let path2 = paths2[i2];
              let pathForKeepkey = {};
              pathForKeepkey.symbol = path2.symbol;
              pathForKeepkey.addressNList = path2.addressNList;
              pathForKeepkey.coin = "bitcoin";
              pathForKeepkey.script_type = "p2pkh";
              pathForKeepkey.scriptType = "p2pkh";
              pathForKeepkey.showDisplay = false;
              pathsKeepkey.push(pathForKeepkey);
            }
            log.debug("***** paths IN: ", pathsKeepkey.length);
            log.debug("***** paths IN: ", pathsKeepkey);
            for (let i2 = 0; i2 < this.blockchains.length; i2++) {
              let blockchain = this.blockchains[i2];
              log.debug(tag, "blockchain: ", blockchain);
              let isFound = paths2.find((path2) => {
                return path2.blockchain === blockchain;
              });
              if (!isFound) {
                throw Error("Failed to find path for blockchain: " + blockchain);
              }
            }
            log.debug("***** paths IN: ", pathsKeepkey);
            let result = await wallet2.getPublicKeys(pathsKeepkey);
            log.debug(tag, "result wallet.getPublicKeys: ", result);
            if (!result)
              throw Error("failed to get pubkeys!");
            for (let i2 = 0; i2 < result.length; i2++) {
              let pubkey2 = paths2[i2];
              log.debug(tag, "pubkey: ", pubkey2);
              let normalized = {};
              normalized.path = addressNListToBIP32(paths2[i2].addressNList);
              normalized.pathMaster = addressNListToBIP32(paths2[i2].addressNListMaster);
              log.debug(tag, "pubkey: ", pubkey2);
              normalized.source = "keepkey";
              if (pubkey2.type === "xpub") {
                normalized.type = "xpub";
                normalized.xpub = true;
                normalized.pubkey = result[i2].xpub;
                pubkey2.pubkey = result[i2].xpub;
              }
              if (pubkey2.type === "zpub") {
                normalized.type = "zpub";
                normalized.zpub = true;
                log.debug(tag, "xpub: ", result[i2].xpub);
                if (!result[i2].xpub)
                  throw Error("Missing xpub");
                log.debug(tag, "zpub: ", result[i2].xpub);
                normalized.pubkey = result[i2].xpub;
                pubkey2.pubkey = result[i2].xpub;
              }
              if (pubkey2.symbol === "ETH" || pubkey2.symbol === "AVAX" || pubkey2.symbol === "RUNE" || pubkey2.symbol === "BNB" || pubkey2.symbol === "ATOM" || pubkey2.symbol === "OSMO") {
                pubkey2.type = "address";
                pubkey2.pubkey = result[i2].xpub;
              }
              if (!pubkey2.type) {
                log.error(tag, "invalid pubkey: ", pubkey2);
                throw Error("invalid pubkey! missing type!");
              }
              normalized.type = pubkey2.type;
              normalized.note = pubkey2.note;
              normalized.symbol = pubkey2.symbol;
              normalized.blockchain = COIN_MAP_LONG[pubkey2.symbol];
              normalized.network = COIN_MAP_LONG[pubkey2.symbol];
              normalized.path = addressNListToBIP32(pubkey2.addressNList);
              normalized.pathMaster = addressNListToBIP32(pubkey2.addressNListMaster);
              let address2;
              log.debug(tag, "symbol: ", pubkey2.symbol);
              switch (pubkey2.symbol) {
                case "BTC":
                case "BCH":
                case "DOGE":
                case "DASH":
                case "LTC":
                  address2 = await wallet2.btcGetAddress({
                    addressNList: paths2[i2].addressNListMaster,
                    coin: COIN_MAP_KEEPKEY_LONG[pubkey2.symbol],
                    scriptType: paths2[i2].script_type,
                    showDisplay: false
                  });
                  log.debug(tag, "address: ", address2);
                  break;
                case "ETH":
                case "AVAX":
                case "MATIC":
                  address2 = await wallet2.ethGetAddress({
                    addressNList: paths2[i2].addressNListMaster,
                    coin: COIN_MAP_KEEPKEY_LONG[pubkey2.symbol],
                    scriptType: paths2[i2].script_type,
                    showDisplay: false
                  });
                  ethMaster = address2;
                  break;
                case "RUNE":
                  address2 = await wallet2.thorchainGetAddress({
                    addressNList: paths2[i2].addressNListMaster,
                    coin: COIN_MAP_KEEPKEY_LONG[pubkey2.symbol],
                    scriptType: paths2[i2].script_type,
                    showDisplay: false
                  });
                  break;
                case "ATOM":
                  address2 = await wallet2.cosmosGetAddress({
                    addressNList: paths2[i2].addressNListMaster,
                    coin: COIN_MAP_KEEPKEY_LONG[pubkey2.symbol],
                    scriptType: paths2[i2].script_type,
                    showDisplay: false
                  });
                  break;
                case "OSMO":
                  address2 = await wallet2.osmosisGetAddress({
                    addressNList: paths2[i2].addressNListMaster,
                    coin: COIN_MAP_KEEPKEY_LONG[pubkey2.symbol],
                    scriptType: paths2[i2].script_type,
                    showDisplay: false
                  });
                  break;
                case "BNB":
                  address2 = await wallet2.binanceGetAddress({
                    addressNList: paths2[i2].addressNListMaster,
                    coin: COIN_MAP_KEEPKEY_LONG[pubkey2.symbol],
                    scriptType: paths2[i2].script_type,
                    showDisplay: false
                  });
                  break;
                default:
                  throw Error("coin not yet implemented ! coin: " + pubkey2.symbol);
              }
              log.debug(tag, "address: ", address2);
              if (!address2) {
                log.error("Failed to get address for pubkey: ", pubkey2);
                throw Error("address master required for valid pubkey");
              }
              normalized.script_type = pubkey2.script_type;
              if (pubkey2.symbol === "ETH" || pubkey2.symbol === "RUNE" || pubkey2.symbol === "BNB" || pubkey2.symbol === "ATOM" || pubkey2.symbol === "OSMO" || pubkey2.symbol === "AVAX") {
                normalized.type = "address";
                normalized.pubkey = address2;
              }
              normalized.master = address2;
              normalized.address = address2;
              normalized.context = context2;
              pubkeys.push(normalized);
              this.pubkeys.push(normalized);
            }
            log.debug(tag, "pubkeys:", pubkeys);
            output2.pubkeys = pubkeys;
            if (pubkeys.length !== result.length) {
              log.error(tag, { pathsKeepkey });
              log.error(tag, { result });
              throw Error("Failed to Normalize pubkeys!");
            }
            log.debug(tag, "pubkeys: (normalized) ", pubkeys.length);
            log.debug(tag, "pubkeys: (normalized) ", pubkeys);
            for (let i2 = 0; i2 < pubkeys.length; i2++) {
              let pubkey2 = pubkeys[i2];
              if (!keyedWallet[pubkey2.symbol]) {
                keyedWallet[pubkey2.symbol] = pubkey2;
              } else {
                if (!keyedWallet["available"])
                  keyedWallet["available"] = [];
                keyedWallet["available"].push(pubkey2);
              }
            }
            for (let i2 = 0; i2 < this.blockchains.length; i2++) {
              let blockchain = this.blockchains[i2];
              let symbol = getNativeAssetForBlockchain(blockchain);
              log.debug(tag, "symbol: ", symbol);
              let isFound = pubkeys.find((path2) => {
                return path2.blockchain === blockchain;
              });
              if (!isFound) {
                throw Error("Failed to find pubkey for blockchain: " + blockchain);
              }
            }
          }
          if (wallet2 === null || wallet2 === void 0 ? void 0 : wallet2._isKeepKey) {
            log.debug(tag, "Is keepkey, format pubkeys");
            let pathsKeepkey = [];
            for (let i2 = 0; i2 < paths2.length; i2++) {
              let path2 = paths2[i2];
              let pathForKeepkey = {};
              pathForKeepkey.symbol = path2.symbol;
              pathForKeepkey.addressNList = path2.addressNList;
              pathForKeepkey.coin = "bitcoin";
              pathForKeepkey.script_type = "p2pkh";
              pathForKeepkey.scriptType = "p2pkh";
              pathForKeepkey.showDisplay = false;
              pathsKeepkey.push(pathForKeepkey);
            }
            log.debug("***** paths IN: ", pathsKeepkey.length);
            log.debug("***** paths IN: ", pathsKeepkey);
            for (let i2 = 0; i2 < this.blockchains.length; i2++) {
              let blockchain = this.blockchains[i2];
              log.debug(tag, "blockchain: ", blockchain);
              let isFound = paths2.find((path2) => {
                return path2.blockchain === blockchain;
              });
              if (!isFound) {
                throw Error("Failed to find path for blockchain: " + blockchain);
              }
            }
            let result = await wallet2.getPublicKeys(pathsKeepkey);
            log.debug(tag, "result wallet.getPublicKeys: ", result);
            log.debug(tag, "result wallet.getPublicKeys: ", result);
            if (!result)
              throw Error("failed to get pubkeys!");
            for (let i2 = 0; i2 < result.length; i2++) {
              let pubkey2 = paths2[i2];
              log.debug(tag, "pubkey: ", pubkey2);
              let normalized = {};
              normalized.path = addressNListToBIP32(paths2[i2].addressNList);
              normalized.pathMaster = addressNListToBIP32(paths2[i2].addressNListMaster);
              log.debug(tag, "pubkey: ", pubkey2);
              normalized.source = "keepkey";
              if (pubkey2.type === "xpub") {
                normalized.type = "xpub";
                normalized.xpub = true;
                normalized.pubkey = result[i2].xpub;
                pubkey2.pubkey = result[i2].xpub;
              }
              if (pubkey2.type === "zpub") {
                normalized.type = "zpub";
                normalized.zpub = true;
                log.debug(tag, "xpub: ", result[i2].xpub);
                if (!result[i2].xpub)
                  throw Error("Missing xpub");
                normalized.pubkey = result[i2].xpub;
                pubkey2.pubkey = result[i2].xpub;
              }
              if (pubkey2.symbol === "ETH" || pubkey2.symbol === "AVAX" || pubkey2.symbol === "RUNE" || pubkey2.symbol === "BNB" || pubkey2.symbol === "ATOM" || pubkey2.symbol === "OSMO") {
                pubkey2.pubkey = result[i2].xpub;
              }
              normalized.note = pubkey2.note;
              normalized.symbol = pubkey2.symbol;
              normalized.blockchain = COIN_MAP_LONG[pubkey2.symbol];
              normalized.network = COIN_MAP_LONG[pubkey2.symbol];
              normalized.path = addressNListToBIP32(pubkey2.addressNList);
              normalized.pathMaster = addressNListToBIP32(pubkey2.addressNListMaster);
              let address2;
              log.debug(tag, "symbol: ", pubkey2.symbol);
              switch (pubkey2.symbol) {
                case "BTC":
                case "BCH":
                case "DOGE":
                case "DASH":
                case "LTC":
                  address2 = await wallet2.btcGetAddress({
                    addressNList: paths2[i2].addressNListMaster,
                    coin: COIN_MAP_KEEPKEY_LONG[pubkey2.symbol],
                    scriptType: paths2[i2].script_type,
                    showDisplay: false
                  });
                  log.debug(tag, "address: ", address2);
                  break;
                case "ETH":
                case "AVAX":
                case "MATIC":
                  address2 = await wallet2.ethGetAddress({
                    addressNList: paths2[i2].addressNListMaster,
                    coin: COIN_MAP_KEEPKEY_LONG[pubkey2.symbol],
                    scriptType: paths2[i2].script_type,
                    showDisplay: false
                  });
                  ethMaster = address2;
                  break;
                case "RUNE":
                  address2 = await wallet2.thorchainGetAddress({
                    addressNList: paths2[i2].addressNListMaster,
                    coin: COIN_MAP_KEEPKEY_LONG[pubkey2.symbol],
                    scriptType: paths2[i2].script_type,
                    showDisplay: false
                  });
                  break;
                case "ATOM":
                  address2 = await wallet2.cosmosGetAddress({
                    addressNList: paths2[i2].addressNListMaster,
                    coin: COIN_MAP_KEEPKEY_LONG[pubkey2.symbol],
                    scriptType: paths2[i2].script_type,
                    showDisplay: false
                  });
                  break;
                case "OSMO":
                  address2 = await wallet2.osmosisGetAddress({
                    addressNList: paths2[i2].addressNListMaster,
                    coin: COIN_MAP_KEEPKEY_LONG[pubkey2.symbol],
                    scriptType: paths2[i2].script_type,
                    showDisplay: false
                  });
                  break;
                case "BNB":
                  address2 = await wallet2.binanceGetAddress({
                    addressNList: paths2[i2].addressNListMaster,
                    coin: COIN_MAP_KEEPKEY_LONG[pubkey2.symbol],
                    scriptType: paths2[i2].script_type,
                    showDisplay: false
                  });
                  break;
                default:
                  throw Error("coin not yet implemented ! coin: " + pubkey2.symbol);
              }
              log.debug(tag, "address: ", address2);
              if (!address2) {
                log.error("Failed to get address for pubkey: ", pubkey2);
                throw Error("address master required for valid pubkey");
              }
              normalized.script_type = pubkey2.script_type;
              if (pubkey2.symbol === "ETH" || pubkey2.symbol === "RUNE" || pubkey2.symbol === "BNB" || pubkey2.symbol === "ATOM" || pubkey2.symbol === "OSMO" || pubkey2.symbol === "AVAX") {
                normalized.type = "address";
                normalized.pubkey = address2;
              }
              normalized.master = address2;
              normalized.address = address2;
              normalized.context = context2;
              pubkeys.push(normalized);
              this.pubkeys.push(normalized);
            }
            log.debug(tag, "pubkeys:", pubkeys);
            output2.pubkeys = pubkeys;
            if (pubkeys.length !== result.length) {
              log.error(tag, { pathsKeepkey });
              log.error(tag, { result });
              throw Error("Failed to Normalize pubkeys!");
            }
            log.debug(tag, "pubkeys: (normalized) ", pubkeys.length);
            log.debug(tag, "pubkeys: (normalized) ", pubkeys);
            for (let i2 = 0; i2 < pubkeys.length; i2++) {
              let pubkey2 = pubkeys[i2];
              if (!keyedWallet[pubkey2.symbol]) {
                keyedWallet[pubkey2.symbol] = pubkey2;
              } else {
                if (!keyedWallet["available"])
                  keyedWallet["available"] = [];
                keyedWallet["available"].push(pubkey2);
              }
            }
            for (let i2 = 0; i2 < this.blockchains.length; i2++) {
              let blockchain = this.blockchains[i2];
              let symbol = getNativeAssetForBlockchain(blockchain);
              log.debug(tag, "symbol: ", symbol);
              let isFound = pubkeys.find((path2) => {
                return path2.blockchain === blockchain;
              });
              if (!isFound) {
                throw Error("Failed to find pubkey for blockchain: " + blockchain);
              }
            }
          }
          let masterEth = ethMaster || wallet2.ethAddress || await this.getAddress("ETH");
          let watchWallet = {
            "WALLET_ID": context2,
            "TYPE": "watch",
            "CREATED": (/* @__PURE__ */ new Date()).getTime(),
            "VERSION": "0.1.3",
            "BLOCKCHAINS: ": this.blockchains,
            "PUBKEYS": pubkeys,
            "WALLET_PUBLIC": keyedWallet,
            "PATHS": paths2
          };
          log.debug(tag, "writePathPub: ", watchWallet);
          output2.publicAddress = masterEth;
          output2.context = context2;
          output2.wallet = watchWallet;
          return output2;
        } catch (e) {
          log.error(tag, "e: ", e);
        }
      };
      this.getBalance = async function(asset, sync) {
        let tag = TAG + " | getBalance | ";
        try {
          let balances = this.balances.filter((e) => e.symbol === asset);
          log.debug(tag, "balances: ", balances);
          if (sync) {
          }
          return balances;
        } catch (e) {
          log.error(tag, "e: ", e);
          throw Error(e);
        }
      };
      this.getAddress = async function(asset) {
        let tag = TAG + " | getAddress | ";
        try {
          let pubkeys = this.pubkeys.filter((e) => e.symbol === asset);
          log.debug(tag, "pubkeys: ", pubkeys);
          let selected;
          let selectedBalance = 0;
          if (pubkeys.length === 1) {
            selected = pubkeys[0];
          } else if (pubkeys.length > 1) {
            for (let i2 = 0; i2 < pubkeys.length; i2++) {
              let pubkey2 = pubkeys[i2];
              let balance = this.balances.filter((e) => e.pubkey === pubkey2.pubkey)[0];
              log.debug(tag, "balance: ", balance);
              log.debug(tag, "balance: ", balance.balance);
              if (balance.balance > selectedBalance) {
                selectedBalance = balance.balance;
                selected = pubkey2;
              }
            }
          }
          return selected.address || selected.master;
        } catch (e) {
          log.error(tag, "e: ", e);
          throw Error(e);
        }
      };
      this.getPubkey = async function(asset, sync) {
        let tag = TAG + " | getPubkey | ";
        try {
          let output2;
          let pubkeys = this.pubkeys.filter((e) => e.symbol === asset);
          return pubkeys;
        } catch (e) {
          log.error(tag, "e: ", e);
          throw Error(e);
        }
      };
      this.updateInvocation = async function(updateBody) {
        let tag = TAG + " | updateInvocation | ";
        try {
          let output2 = await this.pioneer.UpdateInvocation(updateBody);
          return output2.data;
        } catch (e) {
          log.error(tag, "e: ", e);
        }
      };
      this.build = async function(tx) {
        let tag = TAG + " | build | ";
        try {
          if (!tx.type)
            throw Error("invalid buildTx payload!");
          let unsignedTx;
          let invocation;
          let result;
          switch (tx.type) {
            case "sendToAddress":
              log.debug("SendToAddress: ", tx);
              unsignedTx = await this.sendToAddress(tx.payload);
              log.debug(tag, "unsignedTx: ", unsignedTx);
              if (!unsignedTx)
                throw Error("Failed to build sendToAddress!");
              if (!tx.payload.blockchain)
                throw Error("Missing blockchain in sendToAddress payload!");
              invocation = {
                type: "sendToAddress",
                caip: tx.caip,
                context: tx.payload.context,
                network: tx.payload.blockchain,
                blockchain: tx.payload.blockchain,
                username: this.username,
                tx: tx.payload,
                unsignedTx
              };
              log.debug(tag, "Save sendToAddress invocation: ", invocation);
              log.debug(tag, "Save sendToAddress invocation: ", JSON.stringify(invocation));
              log.debug(tag, "result: ", result);
              break;
            case "swap":
              let quote2 = await this.swapQuote(tx.payload);
              log.debug(tag, "quote: ", quote2);
              let invocationId = quote2.invocationId;
              if (!quote2.success) {
                log.error(tag, "verbose error: ", JSON.stringify(quote2));
                log.error(tag, "verbose error: ", quote2);
                throw Error("Failed to Create quote! unable to find a swap route! try again later.");
              }
              log.debug(tag, "result: ", result);
              invocation = {
                type: "swap",
                network: tx.payload.network,
                context: tx.payload.context,
                username: this.username,
                swap: tx.payload,
                tx: quote2,
                invocationId
              };
              log.debug(tag, "invocation: ", invocation);
              log.debug(tag, "result: ", result);
              await sleep(3e3);
              unsignedTx = await this.buildSwap(invocationId, tx.payload);
              log.debug(tag, "pre lookup unsignedTx: ", unsignedTx);
              if (!unsignedTx)
                throw Error("Missing unsignedTx!");
              invocation = await this.getInvocation(invocationId);
              invocation.unsignedTx = unsignedTx;
              log.debug(tag, "***** unsignedTx: ", unsignedTx);
              await this.updateInvocation(invocation);
              let network = tx.payload.input.asset;
              if (!network)
                throw Error("missing input asset! invalid swap!");
              break;
            default:
              throw Error("Unhandled tx type! " + tx.type);
          }
          if (!unsignedTx)
            throw Error("failed to create unsigned tx!");
          if (!invocation)
            throw Error("failed to create invocation!");
          return invocation;
        } catch (e) {
          log.error(tag, "e: ", e);
          throw Error(e);
        }
      };
      this.sign = async function(invocation, wallet2) {
        let tag = TAG + " | sign | ";
        try {
          if (!wallet2)
            throw Error("Must pass wallet to sign!");
          log.debug(tag, "invocation: ", invocation);
          log.debug(tag, "*** invocation: ", JSON.stringify(invocation));
          let blockchain = invocation.blockchain;
          if (!invocation.unsignedTx)
            throw Error("Unable to sign tx! missing unsignedTx");
          let unsignedTx = invocation.unsignedTx;
          let txSigned;
          let broadcastString;
          let txid;
          let txFinal;
          let buffer2;
          let addressInfo = {
            addressNList: [2147483692, 2147483708, 2147483648, 0, 0],
            coin: "Ethereum",
            scriptType: "ethereum",
            showDisplay: false
          };
          let ethAddress = await wallet2.ethGetAddress(addressInfo);
          let walletContextGiven = ethAddress + ".wallet";
          log.debug(tag, "walletContextGiven: ", walletContextGiven);
          log.debug(tag, "invocation.context: ", invocation.context);
          if (walletContextGiven !== invocation.context)
            throw Error("Invalid context! wallet context does not match invocation context!");
          log.debug(tag, "*** unsignedTx HDwalletpayload: ", JSON.stringify(unsignedTx));
          switch (blockchain) {
            case "bitcoin":
            case "bitcoincash":
            case "dash":
            case "digibytes":
            case "litecoin":
            case "dogecoin":
              txSigned = await wallet2.btcSignTx(unsignedTx);
              break;
            case "avalanche":
            case "ethereum":
              log.debug("unsignedTx: ", unsignedTx);
              txSigned = await wallet2.ethSignTx(unsignedTx);
              break;
            case "thorchain":
              txSigned = await wallet2.thorchainSignTx(unsignedTx);
              log.debug(tag, "txSigned: ", txSigned);
              txSigned.signatures[0].sequence = unsignedTx.sequence.toString();
              broadcastString = {
                tx: txSigned,
                // sequence:txSigned.sequence,
                // account_number:txSigned.account_number,
                type: "cosmos-sdk/StdTx",
                mode: "sync"
              };
              txSigned.serialized = JSON.stringify(broadcastString);
              txSigned.serializedTx = JSON.stringify(broadcastString);
              break;
            case "binance":
              txSigned = await wallet2.binanceSignTx(unsignedTx);
              log.debug(tag, "txSigned: ", txSigned);
              txSigned.serialized = txSigned.serialized;
              break;
            case "osmosis":
              txSigned = await wallet2.osmosisSignTx(unsignedTx);
              log.debug(tag, "txSigned: ", txSigned);
              break;
            case "cosmos":
              txSigned = await wallet2.cosmosSignTx(unsignedTx);
              log.debug(tag, "txSigned: ", txSigned);
              break;
            default:
              throw Error("blockchain not supported! blockchain: " + blockchain);
          }
          log.debug(tag, "txSigned: ", txSigned);
          invocation.signedTx = txSigned;
          return invocation;
        } catch (e) {
          log.error(tag, "e: ", e);
          throw Error(e);
        }
      };
      this.broadcast = async function(invocation) {
        let tag = TAG + " | broadcast | ";
        try {
          if (!invocation.signedTx)
            throw Error("Can not broadcast before being signed!");
          if (!invocation.network)
            throw Error("invalid invocation missing network!");
          let broadcastPayload = invocation.signedTx.serialized || invocation.signedTx.serializedTx;
          if (!broadcastPayload)
            throw Error("can not find broadcastPayload!");
          let broadcastBodyTransfer = {
            //TODO align network with blockchain strings!
            network: invocation.network,
            serialized: broadcastPayload,
            txid: invocation.signedTx.txid || "unknown",
            invocationId: "notSet",
            noBroadcast: invocation.noBroadcast
          };
          log.debug(tag, "broadcastBodyTransfer: ", broadcastBodyTransfer);
          log.debug(tag, "broadcastBodyTransfer: ", JSON.stringify(broadcastBodyTransfer));
          let resultBroadcastTransfer = await this.pioneer.Broadcast(broadcastBodyTransfer);
          resultBroadcastTransfer = resultBroadcastTransfer.data;
          invocation.broadcast = resultBroadcastTransfer;
          return invocation;
        } catch (e) {
          log.error(tag, "e: ", e);
          throw Error(e);
        }
      };
      this.defi = async function(defi) {
        let tag = TAG + " | defi | ";
        try {
          return true;
        } catch (e) {
          log.error(tag, "e: ", e);
          throw Error(e);
        }
      };
      this.lpQuote = async function(lp) {
        let tag = TAG + " | lpQuote | ";
        try {
          if (!lp.leg1)
            throw Error("Invalid swap! missing input!");
          if (!lp.leg1.asset)
            throw Error("Invalid swap! missing input asset!");
          if (!lp.leg1.blockchain)
            throw Error("Invalid swap! missing input blockchain!");
          if (!lp.leg2)
            throw Error("Invalid swap! missing output!");
          if (!lp.leg2.asset)
            throw Error("Invalid swap! missing output asset!");
          if (!lp.leg2.blockchain)
            throw Error("Invalid swap! missing output blockchain!");
          if (!lp.amountLeg1 && !lp.amountLeg2)
            throw Error("Invalid swap! missing amountOut and amountIn!");
          if (!lp.pair)
            throw Error("Invalid swap! missing pair!");
          log.debug(tag, "lp: ", lp);
          log.debug(tag, "lp: ", { pair: lp.pair, amountIn: lp.amountIn });
          if (lp.leg1.blockchain === "osmosis") {
            lp.protocol = "osmosis";
            let swapQuote = await this.pioneer.QuoteSwap({ pair: lp.pair, amountIn: lp.amountLeg1 });
            swapQuote = swapQuote.data;
            log.debug(tag, "swapQuote: ", swapQuote);
            lp.amountLeg2 = swapQuote.buyAmount;
          } else {
            throw Error("not supported input!");
          }
          let invocation = {
            type: "lp",
            protocol: lp.protocol,
            network: COIN_MAP[lp.leg1.blockchain],
            context: this.context,
            username: this.username,
            lp
          };
          log.debug(tag, "invocation: ", invocation);
        } catch (e) {
          log.error(tag, "e: ", e);
          throw Error(e);
        }
      };
      this.buildLp = async function(invocationId) {
        let tag = TAG + " | buildLp | ";
        try {
          if (!invocationId)
            throw Error("Invalid swap! missing invocationId!");
          let invocation = await this.getInvocation(invocationId);
          log.debug(tag, "invocation: ", invocation);
          let lp = invocation.invocation.lp;
          if (!lp)
            throw Error("invalid invocation! missing lp object");
          if (!lp.leg1.asset)
            throw Error("invalid invocation! missing lp.leg1.symbol");
          let unsignedTx;
          if (lp.leg1.blockchain === "osmosis") {
            lp.from = await this.getAddress(lp.leg1.asset);
            unsignedTx = await this.txBuilder.lp(lp);
            log.debug(tag, "unsignedTx: ", unsignedTx);
            if (!unsignedTx)
              throw Error("failed to buildTx");
          } else {
            throw Error("not supported input!");
          }
          invocation.unsignedTx = unsignedTx;
          invocation.unsignedTxs = [];
          invocation.unsignedTxs.push(unsignedTx);
          await this.updateInvocation(invocation);
          return invocation;
        } catch (e) {
          log.error(tag, "e: ", e);
          throw Error(e);
        }
      };
      this.swapQuote = async function(swap) {
        let tag = TAG + " | swapQuote | ";
        try {
          if (!swap.input)
            throw Error("Invalid swap! missing input!");
          if (!swap.input.asset)
            throw Error("Invalid swap! missing input asset!");
          if (!swap.input.blockchain)
            throw Error("Invalid swap! missing input blockchain!");
          if (!swap.output)
            throw Error("Invalid swap! missing output!");
          if (!swap.output.asset)
            throw Error("Invalid swap! missing output asset!");
          if (!swap.output.blockchain)
            throw Error("Invalid swap! missing output blockchain!");
          if (!swap.amount)
            throw Error("Invalid swap! missing amount!");
          let inputAddress = await this.getAddress(swap.input.asset);
          if (!inputAddress)
            throw Error("failed to get address for input!");
          log.debug(tag, "inputAddress: ", inputAddress);
          log.debug(tag, "*** inputAddress: ", inputAddress);
          let outputAddress = await this.getAddress(swap.output.asset);
          if (!outputAddress)
            throw Error("failed to get address for output!");
          outputAddress = outputAddress.replace("bitcoincash:", "");
          inputAddress = inputAddress.replace("bitcoincash:", "");
          let inputBlockchainRango = getRangoBlockchainName(swap.input.blockchain);
          let outputBlockchainRango = getRangoBlockchainName(swap.output.blockchain);
          if (!inputBlockchainRango)
            throw Error("Failed to get rango name for blockchain! input: " + swap.input.blockchain);
          if (!outputBlockchainRango)
            throw Error("Failed to get rango name for blockchain! output: " + swap.output.blockchain);
          const connectedWallets = [
            { blockchain: inputBlockchainRango, addresses: [inputAddress] },
            { blockchain: outputBlockchainRango, addresses: [outputAddress] }
          ];
          const selectedWallets = {
            [inputBlockchainRango]: inputAddress,
            [outputBlockchainRango]: outputAddress
          };
          log.debug(tag, "connectedWallets: ", connectedWallets);
          log.debug(tag, "selectedWallets: ", selectedWallets);
          const from2 = { blockchain: inputBlockchainRango, symbol: swap.input.asset, address: null };
          const to = { blockchain: outputBlockchainRango, symbol: swap.output.asset, address: null };
          let body = {
            amount: swap.amount,
            affiliateRef: null,
            checkPrerequisites: true,
            connectedWallets,
            selectedWallets,
            from: from2,
            to
          };
          log.debug("rango body: ", body);
          log.debug("rango body: ", JSON.stringify(body));
          let bestRoute;
          let error;
          try {
            bestRoute = await this.rango.getBestRoute(body);
            log.debug("bestRoute: ", bestRoute);
          } catch (e) {
            log.debug(tag, "e: ", e);
            error = e;
          }
          let output2;
          if (bestRoute && bestRoute.result && bestRoute.result.outputAmount) {
            if (!bestRoute.requestId)
              throw Error("failed to make swap request!");
            if (!bestRoute.result.outputAmount)
              throw Error("failed to make quote!");
            let duration;
            output2 = {
              success: true,
              invocationId: bestRoute.requestId,
              amountIn: swap.amount,
              amountOut: bestRoute.result.outputAmount,
              input: swap.input,
              output: swap.output,
              swaps: bestRoute.result.swaps
            };
          } else {
            log.error(tag, "Failed to create quote!");
            output2 = {
              success: false,
              error,
              response: bestRoute,
              rangoBody: body
            };
          }
          return output2;
        } catch (e) {
          log.error(tag, "e: ", e);
          throw Error(e);
        }
      };
      this.buildSwap = async function(invocationId, swap) {
        let tag = TAG + " | buildSwap | ";
        try {
          if (!invocationId)
            throw Error("Invalid swap! missing invocationId!");
          if (!swap)
            throw Error("Invalid swap! missing swap!");
          const transactionResponse = await this.rango.createTransaction({
            requestId: invocationId,
            step: 1,
            userSettings: { "slippage": "1" },
            validations: { balance: true, fee: true }
          });
          log.debug("transactionResponse: ", transactionResponse);
          if (!transactionResponse.ok) {
            throw Error(transactionResponse.error);
          }
          let tx = transactionResponse.transaction;
          if (tx.blockChain) {
            tx.network = tx.blockChain;
          }
          let inputAsset = swap.input.asset;
          if (!inputAsset)
            throw Error("invalid invocation, missing swap input asset!");
          if (swap.replace)
            tx.replace = true;
          if (tx.type === "TRANSFER" && tx.method === "transfer") {
            log.debug("TRANSFER DETECTED! UTXO based");
            tx.pubkey = await this.getPubkey(inputAsset);
            if (!tx.pubkey)
              throw Error("failed to get pubkey!");
            tx.from = await this.getAddress(inputAsset);
            if (!tx.from)
              throw Error("failed to get from address!");
            tx.memo = transactionResponse.transaction.memo;
          } else if (tx.type === "TRANSFER" && tx.method === "deposit") {
            log.debug("DEPOSIT DETECTED! RUNE/contract based");
            tx.type = "DEPOSIT";
            tx.pubkey = await this.getPubkey(inputAsset);
            if (!tx.pubkey)
              throw Error("failed to get pubkey!");
            tx.from = await this.getAddress(inputAsset);
            if (!tx.from)
              throw Error("failed to get from address!");
            tx.memo = transactionResponse.transaction.memo;
          } else {
            log.debug("EVM DETECTED! evm based");
            tx.from = await this.getAddress(inputAsset);
            if (!tx.from)
              throw Error("failed to get from address!");
          }
          log.debug(tag, "buildSwap tx: ", tx);
          let unsignedTx = await this.txBuilder.swap(tx);
          log.debug(tag, "unsignedTx: ", unsignedTx);
          return unsignedTx;
        } catch (e) {
          log.error(tag, "e: ", e);
          throw Error(e);
        }
      };
      this.sendToAddress = async function(tx) {
        let tag = TAG + " | sendToAddress | ";
        try {
          if (!tx.asset)
            throw Error("Invalid tx! missing asset");
          log.debug(tag, "*** this.balances: ", this.balances);
          log.debug(tag, "*** this.balances: ", this.balances.filter((e) => e.asset === "BCH")[0]);
          log.debug(tag, "*** tx.asset: ", tx.asset);
          let balances = this.balances.filter((e) => e.asset === tx.asset)[0];
          log.debug(tag, "*** balances: ", balances);
          if (!balances)
            throw Error("No balance found for asset: " + tx.asset);
          if (balances.length === 0) {
            throw Error("No balance found for asset! asset" + tx.asset);
          } else if (balances.length === 1) {
            log.debug(tag, "assume from is only balance");
          } else if (balances.length > 1) {
            log.debug(tag, "select larges balance");
          }
          let transferTx = {
            type: "transfer",
            context: tx.context,
            blockchain: tx.blockchain,
            balance: tx.balance,
            contract: tx.contract,
            network: tx.network || tx.asset,
            asset: tx.asset,
            toAddress: tx.address,
            amount: tx.amount,
            memo: tx.memo || "",
            pubkey: await this.getPubkey(tx.network || tx.asset)
          };
          if (!transferTx.pubkey)
            throw Error("Failed to find pubkey!");
          if (!tx.address)
            tx.address = tx.pubkey.address;
          log.debug(tag, "transferTx: ", transferTx);
          let unsignedTx = await this.txBuilder.buildTx(transferTx);
          log.debug(tag, "unsignedTx: ", unsignedTx);
          log.debug(tag, "pre lookup unsignedTx: ", JSON.stringify(unsignedTx));
          return unsignedTx;
        } catch (e) {
          log.error(tag, "e: ", e);
        }
      };
    }
  }
  SDK_1 = lib$9.SDK = SDK;
  lib$9.default = SDK;
  const eventEmitter = new EventEmitter();
  var WalletActions = /* @__PURE__ */ ((WalletActions2) => {
    WalletActions2["SET_STATUS"] = "SET_STATUS";
    WalletActions2["SET_USERNAME"] = "SET_USERNAME";
    WalletActions2["OPEN_MODAL"] = "OPEN_MODAL";
    WalletActions2["SET_API"] = "SET_API";
    WalletActions2["SET_APP"] = "SET_APP";
    WalletActions2["SET_WALLETS"] = "SET_WALLETS";
    WalletActions2["SET_CONTEXT"] = "SET_CONTEXT";
    WalletActions2["SET_ASSET_CONTEXT"] = "SET_ASSET_CONTEXT";
    WalletActions2["SET_BLOCKCHAIN_CONTEXT"] = "SET_BLOCKCHAIN_CONTEXT";
    WalletActions2["SET_PUBKEY_CONTEXT"] = "SET_PUBKEY_CONTEXT";
    WalletActions2["SET_OUTBOUND_CONTEXT"] = "SET_OUTBOUND_CONTEXT";
    WalletActions2["SET_OUTBOUND_ASSET_CONTEXT"] = "SET_OUTBOUND_ASSET_CONTEXT";
    WalletActions2["SET_OUTBOUND_BLOCKCHAIN_CONTEXT"] = "SET_OUTBOUND_BLOCKCHAIN_CONTEXT";
    WalletActions2["SET_OUTBOUND_PUBKEY_CONTEXT"] = "SET_OUTBOUND_PUBKEY_CONTEXT";
    WalletActions2["SET_BALANCES"] = "SET_BALANCES";
    WalletActions2["SET_PUBKEYS"] = "SET_PUBKEYS";
    WalletActions2["ADD_WALLET"] = "ADD_WALLET";
    WalletActions2["RESET_STATE"] = "RESET_STATE";
    return WalletActions2;
  })(WalletActions || {});
  const initialState = {
    status: "disconnected",
    username: "",
    serviceKey: "",
    queryKey: "",
    context: "",
    assetContext: "",
    blockchainContext: "",
    pubkeyContext: "",
    outboundContext: null,
    outboundAssetContext: null,
    outboundBlockchainContext: null,
    outboundPubkeyContext: null,
    balances: [],
    pubkeys: [],
    wallets: [],
    walletDescriptions: [],
    totalValueUsd: 0,
    app: null,
    api: null
  };
  const reducer = (state2, action) => {
    switch (action.type) {
      case "SET_STATUS":
        eventEmitter.emit("SET_STATUS", action.payload);
        return { ...state2, status: action.payload };
      case "SET_USERNAME":
        return { ...state2, username: action.payload };
      case "OPEN_MODAL":
        return { ...state2, payload: action.payload };
      case "SET_API":
        return { ...state2, api: action.payload };
      case "SET_APP":
        return { ...state2, app: action.payload };
      case "SET_WALLETS":
        return { ...state2, wallets: action.payload };
      case "SET_CONTEXT":
        return { ...state2, context: action.payload };
      case "SET_ASSET_CONTEXT":
        return { ...state2, assetContext: action.payload };
      case "SET_BLOCKCHAIN_CONTEXT":
        return { ...state2, blockchainContext: action.payload };
      case "SET_PUBKEY_CONTEXT":
        return { ...state2, pubkeyContext: action.payload };
      case "SET_OUTBOUND_CONTEXT":
        return { ...state2, outboundContext: action.payload };
      case "SET_OUTBOUND_ASSET_CONTEXT":
        return { ...state2, outboundAssetContext: action.payload };
      case "SET_OUTBOUND_BLOCKCHAIN_CONTEXT":
        return { ...state2, outboundBlockchainContext: action.payload };
      case "SET_OUTBOUND_PUBKEY_CONTEXT":
        return { ...state2, outboundPubkeyContext: action.payload };
      case "SET_BALANCES":
        return { ...state2, balances: action.payload };
      case "SET_PUBKEYS":
        return { ...state2, pubkeys: action.payload };
      case "ADD_WALLET":
        return { ...state2, wallets: [...state2.wallets, action.payload] };
      case "RESET_STATE":
        return {
          ...state2,
          api: null,
          user: null,
          username: null,
          context: null,
          status: null
          // Add other state properties you want to reset here...
        };
      default:
        return state2;
    }
  };
  const PioneerContext = React$1.createContext(initialState);
  const PioneerProvider = ({ children }) => {
    const [state2, dispatch2] = React$1.useReducer(reducer, initialState);
    const connectWallet = async function(wallet2) {
      try {
        if (state2 && (state2 == null ? void 0 : state2.app)) {
          console.log("connectWallet: ", wallet2);
          const successPairWallet = await state2.app.pairWallet(wallet2);
          console.log("successPairWallet: ", successPairWallet);
          console.log("state.app.assetContext: ", state2.app.assetContext);
          console.log("state.app.blockchainContext: ", state2.app.blockchainContext);
          console.log("state.app.context: ", state2.app.context);
          if (state2 && state2.app) {
            dispatch2({
              type: "SET_CONTEXT",
              payload: state2.app.context
            });
            dispatch2({
              type: "SET_ASSET_CONTEXT",
              payload: state2.app.assetContext
            });
            dispatch2({
              type: "SET_BLOCKCHAIN_CONTEXT",
              payload: state2.app.blockchainContext
            });
            dispatch2({
              type: "SET_PUBKEY_CONTEXT",
              payload: state2.app.pubkeyContext
            });
          }
        }
      } catch (e) {
        console.error(e);
      }
    };
    const onStart = async function() {
      try {
        let queryKey2 = localStorage.getItem("queryKey");
        let username = localStorage.getItem("username");
        let keepkeyApiKey = localStorage.getItem("keepkeyApiKey");
        dispatch2({ type: "SET_USERNAME", payload: username });
        if (!queryKey2) {
          queryKey2 = `key:${v4()}`;
          localStorage.setItem("queryKey", queryKey2);
        }
        if (!username) {
          username = `user:${v4()}`;
          username = username.substring(0, 13);
          localStorage.setItem("username", username);
        }
        const blockchains2 = [
          "bitcoin",
          "ethereum",
          "thorchain",
          "bitcoincash",
          "litecoin",
          "binance",
          "cosmos",
          "dogecoin"
        ];
        const paths2 = [];
        console.log("VITE_PIONEER_URL_SPEC: ");
        const spec = (
          // @ts-ignore
          {}.VITE_PIONEER_URL_SPEC || "https://swaps.pro/spec/swagger.json"
        );
        console.log("spec: ", spec);
        const wss = "wss://pioneers.dev";
        const configPioneer = {
          blockchains: blockchains2,
          username,
          queryKey: queryKey2,
          keepkeyApiKey,
          spec,
          wss,
          paths: paths2,
          // @ts-ignore
          ethplorerApiKey: (
            // @ts-ignore
            "EK-xs8Hj-qG4HbLY-LoAu7"
          ),
          // @ts-ignore
          covalentApiKey: (
            // @ts-ignore
            "cqt_rQ6333MVWCVJFVX3DbCCGMVqRH4q"
          ),
          // @ts-ignore
          utxoApiKey: "B___s9XK926uwmQSGTDEcZB3vSAmt5t2",
          // @ts-ignore
          walletConnectProjectId: (
            // @ts-ignore
            "18224df5f72924a5f6b3569fbd56ae16"
          )
        };
        if (!configPioneer.utxoApiKey)
          throw Error("blockchair api key required!");
        const appInit = new SDK_1(spec, configPioneer);
        if (appInit.keepkeyApiKey !== keepkeyApiKey) {
          localStorage.setItem("keepkeyApiKey", appInit.keepkeyApiKey);
        }
        const api = await appInit.init();
        console.log("appInit.wallets: ", appInit.wallets);
        dispatch2({ type: "SET_API", payload: api });
        dispatch2({ type: "SET_APP", payload: appInit });
        const { events: events2 } = appInit;
        const walletActionsArray = Object.values(WalletActions);
        walletActionsArray.forEach((action) => {
          events2.on(action, (data2) => {
            dispatch2({
              type: action,
              payload: data2
            });
          });
        });
      } catch (e) {
        console.error(e);
      }
    };
    const value2 = React$1.useMemo(
      () => ({ state: state2, dispatch: dispatch2, connectWallet, onStart }),
      [connectWallet, state2]
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PioneerContext.Provider, { value: value2, children });
  };
  const usePioneer = () => React$1.useContext(PioneerContext);
  const config = {
    disableTransitionOnChange: false
  };
  const theme = react.extendTheme({
    initialColorMode: "dark",
    useSystemColorMode: false,
    fonts: {
      heading: "Plus Jakarta Sans, sans-serif",
      body: "Plus Jakarta Sans, sans-serif"
    },
    components: {
      // Button: {
      // }
    },
    config
  });
  /**
   * @remix-run/router v1.9.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
  function _extends$3() {
    _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$3.apply(this, arguments);
  }
  var Action;
  (function(Action2) {
    Action2["Pop"] = "POP";
    Action2["Push"] = "PUSH";
    Action2["Replace"] = "REPLACE";
  })(Action || (Action = {}));
  const PopStateEventType = "popstate";
  function createBrowserHistory(options) {
    if (options === void 0) {
      options = {};
    }
    function createBrowserLocation(window2, globalHistory) {
      let {
        pathname,
        search,
        hash: hash2
      } = window2.location;
      return createLocation(
        "",
        {
          pathname,
          search,
          hash: hash2
        },
        // state defaults to `null` because `window.history.state` does
        globalHistory.state && globalHistory.state.usr || null,
        globalHistory.state && globalHistory.state.key || "default"
      );
    }
    function createBrowserHref(window2, to) {
      return typeof to === "string" ? to : createPath(to);
    }
    return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
  }
  function invariant(value2, message) {
    if (value2 === false || value2 === null || typeof value2 === "undefined") {
      throw new Error(message);
    }
  }
  function warning(cond, message) {
    if (!cond) {
      if (typeof console !== "undefined")
        console.warn(message);
      try {
        throw new Error(message);
      } catch (e) {
      }
    }
  }
  function createKey() {
    return Math.random().toString(36).substr(2, 8);
  }
  function getHistoryState(location2, index2) {
    return {
      usr: location2.state,
      key: location2.key,
      idx: index2
    };
  }
  function createLocation(current, to, state2, key) {
    if (state2 === void 0) {
      state2 = null;
    }
    let location2 = _extends$3({
      pathname: typeof current === "string" ? current : current.pathname,
      search: "",
      hash: ""
    }, typeof to === "string" ? parsePath(to) : to, {
      state: state2,
      // TODO: This could be cleaned up.  push/replace should probably just take
      // full Locations now and avoid the need to run through this flow at all
      // But that's a pretty big refactor to the current test suite so going to
      // keep as is for the time being and just let any incoming keys take precedence
      key: to && to.key || key || createKey()
    });
    return location2;
  }
  function createPath(_ref) {
    let {
      pathname = "/",
      search = "",
      hash: hash2 = ""
    } = _ref;
    if (search && search !== "?")
      pathname += search.charAt(0) === "?" ? search : "?" + search;
    if (hash2 && hash2 !== "#")
      pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
    return pathname;
  }
  function parsePath(path2) {
    let parsedPath = {};
    if (path2) {
      let hashIndex = path2.indexOf("#");
      if (hashIndex >= 0) {
        parsedPath.hash = path2.substr(hashIndex);
        path2 = path2.substr(0, hashIndex);
      }
      let searchIndex = path2.indexOf("?");
      if (searchIndex >= 0) {
        parsedPath.search = path2.substr(searchIndex);
        path2 = path2.substr(0, searchIndex);
      }
      if (path2) {
        parsedPath.pathname = path2;
      }
    }
    return parsedPath;
  }
  function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
    if (options === void 0) {
      options = {};
    }
    let {
      window: window2 = document.defaultView,
      v5Compat = false
    } = options;
    let globalHistory = window2.history;
    let action = Action.Pop;
    let listener = null;
    let index2 = getIndex();
    if (index2 == null) {
      index2 = 0;
      globalHistory.replaceState(_extends$3({}, globalHistory.state, {
        idx: index2
      }), "");
    }
    function getIndex() {
      let state2 = globalHistory.state || {
        idx: null
      };
      return state2.idx;
    }
    function handlePop() {
      action = Action.Pop;
      let nextIndex = getIndex();
      let delta = nextIndex == null ? null : nextIndex - index2;
      index2 = nextIndex;
      if (listener) {
        listener({
          action,
          location: history.location,
          delta
        });
      }
    }
    function push2(to, state2) {
      action = Action.Push;
      let location2 = createLocation(history.location, to, state2);
      if (validateLocation)
        validateLocation(location2, to);
      index2 = getIndex() + 1;
      let historyState = getHistoryState(location2, index2);
      let url2 = history.createHref(location2);
      try {
        globalHistory.pushState(historyState, "", url2);
      } catch (error) {
        if (error instanceof DOMException && error.name === "DataCloneError") {
          throw error;
        }
        window2.location.assign(url2);
      }
      if (v5Compat && listener) {
        listener({
          action,
          location: history.location,
          delta: 1
        });
      }
    }
    function replace2(to, state2) {
      action = Action.Replace;
      let location2 = createLocation(history.location, to, state2);
      if (validateLocation)
        validateLocation(location2, to);
      index2 = getIndex();
      let historyState = getHistoryState(location2, index2);
      let url2 = history.createHref(location2);
      globalHistory.replaceState(historyState, "", url2);
      if (v5Compat && listener) {
        listener({
          action,
          location: history.location,
          delta: 0
        });
      }
    }
    function createURL(to) {
      let base2 = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
      let href = typeof to === "string" ? to : createPath(to);
      invariant(base2, "No window.location.(origin|href) available to create URL for href: " + href);
      return new URL(href, base2);
    }
    let history = {
      get action() {
        return action;
      },
      get location() {
        return getLocation(window2, globalHistory);
      },
      listen(fn) {
        if (listener) {
          throw new Error("A history only accepts one active listener");
        }
        window2.addEventListener(PopStateEventType, handlePop);
        listener = fn;
        return () => {
          window2.removeEventListener(PopStateEventType, handlePop);
          listener = null;
        };
      },
      createHref(to) {
        return createHref(window2, to);
      },
      createURL,
      encodeLocation(to) {
        let url2 = createURL(to);
        return {
          pathname: url2.pathname,
          search: url2.search,
          hash: url2.hash
        };
      },
      push: push2,
      replace: replace2,
      go(n2) {
        return globalHistory.go(n2);
      }
    };
    return history;
  }
  var ResultType;
  (function(ResultType2) {
    ResultType2["data"] = "data";
    ResultType2["deferred"] = "deferred";
    ResultType2["redirect"] = "redirect";
    ResultType2["error"] = "error";
  })(ResultType || (ResultType = {}));
  function matchRoutes(routes2, locationArg, basename) {
    if (basename === void 0) {
      basename = "/";
    }
    let location2 = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    let pathname = stripBasename(location2.pathname || "/", basename);
    if (pathname == null) {
      return null;
    }
    let branches = flattenRoutes(routes2);
    rankRouteBranches(branches);
    let matches = null;
    for (let i2 = 0; matches == null && i2 < branches.length; ++i2) {
      matches = matchRouteBranch(
        branches[i2],
        // Incoming pathnames are generally encoded from either window.location
        // or from router.navigate, but we want to match against the unencoded
        // paths in the route definitions.  Memory router locations won't be
        // encoded here but there also shouldn't be anything to decode so this
        // should be a safe operation.  This avoids needing matchRoutes to be
        // history-aware.
        safelyDecodeURI(pathname)
      );
    }
    return matches;
  }
  function flattenRoutes(routes2, branches, parentsMeta, parentPath) {
    if (branches === void 0) {
      branches = [];
    }
    if (parentsMeta === void 0) {
      parentsMeta = [];
    }
    if (parentPath === void 0) {
      parentPath = "";
    }
    let flattenRoute = (route, index2, relativePath2) => {
      let meta = {
        relativePath: relativePath2 === void 0 ? route.path || "" : relativePath2,
        caseSensitive: route.caseSensitive === true,
        childrenIndex: index2,
        route
      };
      if (meta.relativePath.startsWith("/")) {
        invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
        meta.relativePath = meta.relativePath.slice(parentPath.length);
      }
      let path2 = joinPaths([parentPath, meta.relativePath]);
      let routesMeta = parentsMeta.concat(meta);
      if (route.children && route.children.length > 0) {
        invariant(
          // Our types know better, but runtime JS may not!
          // @ts-expect-error
          route.index !== true,
          "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path2 + '".')
        );
        flattenRoutes(route.children, branches, routesMeta, path2);
      }
      if (route.path == null && !route.index) {
        return;
      }
      branches.push({
        path: path2,
        score: computeScore(path2, route.index),
        routesMeta
      });
    };
    routes2.forEach((route, index2) => {
      var _route$path;
      if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
        flattenRoute(route, index2);
      } else {
        for (let exploded of explodeOptionalSegments(route.path)) {
          flattenRoute(route, index2, exploded);
        }
      }
    });
    return branches;
  }
  function explodeOptionalSegments(path2) {
    let segments = path2.split("/");
    if (segments.length === 0)
      return [];
    let [first2, ...rest] = segments;
    let isOptional = first2.endsWith("?");
    let required = first2.replace(/\?$/, "");
    if (rest.length === 0) {
      return isOptional ? [required, ""] : [required];
    }
    let restExploded = explodeOptionalSegments(rest.join("/"));
    let result = [];
    result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
    if (isOptional) {
      result.push(...restExploded);
    }
    return result.map((exploded) => path2.startsWith("/") && exploded === "" ? "/" : exploded);
  }
  function rankRouteBranches(branches) {
    branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta) => meta.childrenIndex), b.routesMeta.map((meta) => meta.childrenIndex)));
  }
  const paramRe = /^:\w+$/;
  const dynamicSegmentValue = 3;
  const indexRouteValue = 2;
  const emptySegmentValue = 1;
  const staticSegmentValue = 10;
  const splatPenalty = -2;
  const isSplat = (s) => s === "*";
  function computeScore(path2, index2) {
    let segments = path2.split("/");
    let initialScore = segments.length;
    if (segments.some(isSplat)) {
      initialScore += splatPenalty;
    }
    if (index2) {
      initialScore += indexRouteValue;
    }
    return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
  }
  function compareIndexes(a, b) {
    let siblings = a.length === b.length && a.slice(0, -1).every((n2, i2) => n2 === b[i2]);
    return siblings ? (
      // If two routes are siblings, we should try to match the earlier sibling
      // first. This allows people to have fine-grained control over the matching
      // behavior by simply putting routes with identical paths in the order they
      // want them tried.
      a[a.length - 1] - b[b.length - 1]
    ) : (
      // Otherwise, it doesn't really make sense to rank non-siblings by index,
      // so they sort equally.
      0
    );
  }
  function matchRouteBranch(branch, pathname) {
    let {
      routesMeta
    } = branch;
    let matchedParams = {};
    let matchedPathname = "/";
    let matches = [];
    for (let i2 = 0; i2 < routesMeta.length; ++i2) {
      let meta = routesMeta[i2];
      let end = i2 === routesMeta.length - 1;
      let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
      let match2 = matchPath({
        path: meta.relativePath,
        caseSensitive: meta.caseSensitive,
        end
      }, remainingPathname);
      if (!match2)
        return null;
      Object.assign(matchedParams, match2.params);
      let route = meta.route;
      matches.push({
        // TODO: Can this as be avoided?
        params: matchedParams,
        pathname: joinPaths([matchedPathname, match2.pathname]),
        pathnameBase: normalizePathname(joinPaths([matchedPathname, match2.pathnameBase])),
        route
      });
      if (match2.pathnameBase !== "/") {
        matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
      }
    }
    return matches;
  }
  function matchPath(pattern, pathname) {
    if (typeof pattern === "string") {
      pattern = {
        path: pattern,
        caseSensitive: false,
        end: true
      };
    }
    let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
    let match2 = pathname.match(matcher);
    if (!match2)
      return null;
    let matchedPathname = match2[0];
    let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
    let captureGroups = match2.slice(1);
    let params = paramNames.reduce((memo, paramName, index2) => {
      if (paramName === "*") {
        let splatValue = captureGroups[index2] || "";
        pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
      }
      memo[paramName] = safelyDecodeURIComponent(captureGroups[index2] || "", paramName);
      return memo;
    }, {});
    return {
      params,
      pathname: matchedPathname,
      pathnameBase,
      pattern
    };
  }
  function compilePath(path2, caseSensitive, end) {
    if (caseSensitive === void 0) {
      caseSensitive = false;
    }
    if (end === void 0) {
      end = true;
    }
    warning(path2 === "*" || !path2.endsWith("*") || path2.endsWith("/*"), 'Route path "' + path2 + '" will be treated as if it were ' + ('"' + path2.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path2.replace(/\*$/, "/*") + '".'));
    let paramNames = [];
    let regexpSource = "^" + path2.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (_, paramName) => {
      paramNames.push(paramName);
      return "/([^\\/]+)";
    });
    if (path2.endsWith("*")) {
      paramNames.push("*");
      regexpSource += path2 === "*" || path2 === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
    } else if (end) {
      regexpSource += "\\/*$";
    } else if (path2 !== "" && path2 !== "/") {
      regexpSource += "(?:(?=\\/|$))";
    } else
      ;
    let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
    return [matcher, paramNames];
  }
  function safelyDecodeURI(value2) {
    try {
      return decodeURI(value2);
    } catch (error) {
      warning(false, 'The URL path "' + value2 + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
      return value2;
    }
  }
  function safelyDecodeURIComponent(value2, paramName) {
    try {
      return decodeURIComponent(value2);
    } catch (error) {
      warning(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value2 + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ")."));
      return value2;
    }
  }
  function stripBasename(pathname, basename) {
    if (basename === "/")
      return pathname;
    if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
      return null;
    }
    let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
    let nextChar = pathname.charAt(startIndex);
    if (nextChar && nextChar !== "/") {
      return null;
    }
    return pathname.slice(startIndex) || "/";
  }
  function resolvePath(to, fromPathname) {
    if (fromPathname === void 0) {
      fromPathname = "/";
    }
    let {
      pathname: toPathname,
      search = "",
      hash: hash2 = ""
    } = typeof to === "string" ? parsePath(to) : to;
    let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
    return {
      pathname,
      search: normalizeSearch(search),
      hash: normalizeHash(hash2)
    };
  }
  function resolvePathname(relativePath2, fromPathname) {
    let segments = fromPathname.replace(/\/+$/, "").split("/");
    let relativeSegments = relativePath2.split("/");
    relativeSegments.forEach((segment) => {
      if (segment === "..") {
        if (segments.length > 1)
          segments.pop();
      } else if (segment !== ".") {
        segments.push(segment);
      }
    });
    return segments.length > 1 ? segments.join("/") : "/";
  }
  function getInvalidPathError(char, field, dest, path2) {
    return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path2) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
  }
  function getPathContributingMatches(matches) {
    return matches.filter((match2, index2) => index2 === 0 || match2.route.path && match2.route.path.length > 0);
  }
  function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
    if (isPathRelative === void 0) {
      isPathRelative = false;
    }
    let to;
    if (typeof toArg === "string") {
      to = parsePath(toArg);
    } else {
      to = _extends$3({}, toArg);
      invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
      invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
      invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
    }
    let isEmptyPath = toArg === "" || to.pathname === "";
    let toPathname = isEmptyPath ? "/" : to.pathname;
    let from2;
    if (isPathRelative || toPathname == null) {
      from2 = locationPathname;
    } else {
      let routePathnameIndex = routePathnames.length - 1;
      if (toPathname.startsWith("..")) {
        let toSegments = toPathname.split("/");
        while (toSegments[0] === "..") {
          toSegments.shift();
          routePathnameIndex -= 1;
        }
        to.pathname = toSegments.join("/");
      }
      from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
    }
    let path2 = resolvePath(to, from2);
    let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
    let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
    if (!path2.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
      path2.pathname += "/";
    }
    return path2;
  }
  const joinPaths = (paths2) => paths2.join("/").replace(/\/\/+/g, "/");
  const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
  const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
  const normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
  function isRouteErrorResponse(error) {
    return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
  }
  const validMutationMethodsArr = ["post", "put", "patch", "delete"];
  new Set(validMutationMethodsArr);
  const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
  new Set(validRequestMethodsArr);
  /**
   * React Router v6.16.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
  function _extends$2() {
    _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$2.apply(this, arguments);
  }
  const DataRouterContext = /* @__PURE__ */ React__namespace.createContext(null);
  const DataRouterStateContext = /* @__PURE__ */ React__namespace.createContext(null);
  const NavigationContext = /* @__PURE__ */ React__namespace.createContext(null);
  const LocationContext = /* @__PURE__ */ React__namespace.createContext(null);
  const RouteContext = /* @__PURE__ */ React__namespace.createContext({
    outlet: null,
    matches: [],
    isDataRoute: false
  });
  const RouteErrorContext = /* @__PURE__ */ React__namespace.createContext(null);
  function useInRouterContext() {
    return React__namespace.useContext(LocationContext) != null;
  }
  function useLocation() {
    !useInRouterContext() ? invariant(false) : void 0;
    return React__namespace.useContext(LocationContext).location;
  }
  function useIsomorphicLayoutEffect(cb) {
    let isStatic = React__namespace.useContext(NavigationContext).static;
    if (!isStatic) {
      React__namespace.useLayoutEffect(cb);
    }
  }
  function useNavigate() {
    let {
      isDataRoute
    } = React__namespace.useContext(RouteContext);
    return isDataRoute ? useNavigateStable() : useNavigateUnstable();
  }
  function useNavigateUnstable() {
    !useInRouterContext() ? invariant(false) : void 0;
    let dataRouterContext = React__namespace.useContext(DataRouterContext);
    let {
      basename,
      navigator: navigator2
    } = React__namespace.useContext(NavigationContext);
    let {
      matches
    } = React__namespace.useContext(RouteContext);
    let {
      pathname: locationPathname
    } = useLocation();
    let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match2) => match2.pathnameBase));
    let activeRef = React__namespace.useRef(false);
    useIsomorphicLayoutEffect(() => {
      activeRef.current = true;
    });
    let navigate = React__namespace.useCallback(function(to, options) {
      if (options === void 0) {
        options = {};
      }
      if (!activeRef.current)
        return;
      if (typeof to === "number") {
        navigator2.go(to);
        return;
      }
      let path2 = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
      if (dataRouterContext == null && basename !== "/") {
        path2.pathname = path2.pathname === "/" ? basename : joinPaths([basename, path2.pathname]);
      }
      (!!options.replace ? navigator2.replace : navigator2.push)(path2, options.state, options);
    }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
    return navigate;
  }
  function useParams() {
    let {
      matches
    } = React__namespace.useContext(RouteContext);
    let routeMatch = matches[matches.length - 1];
    return routeMatch ? routeMatch.params : {};
  }
  function useRoutes(routes2, locationArg) {
    return useRoutesImpl(routes2, locationArg);
  }
  function useRoutesImpl(routes2, locationArg, dataRouterState) {
    !useInRouterContext() ? invariant(false) : void 0;
    let {
      navigator: navigator2
    } = React__namespace.useContext(NavigationContext);
    let {
      matches: parentMatches
    } = React__namespace.useContext(RouteContext);
    let routeMatch = parentMatches[parentMatches.length - 1];
    let parentParams = routeMatch ? routeMatch.params : {};
    routeMatch ? routeMatch.pathname : "/";
    let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
    routeMatch && routeMatch.route;
    let locationFromContext = useLocation();
    let location2;
    if (locationArg) {
      var _parsedLocationArg$pa;
      let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
      !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
      location2 = parsedLocationArg;
    } else {
      location2 = locationFromContext;
    }
    let pathname = location2.pathname || "/";
    let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
    let matches = matchRoutes(routes2, {
      pathname: remainingPathname
    });
    let renderedMatches = _renderMatches(matches && matches.map((match2) => Object.assign({}, match2, {
      params: Object.assign({}, parentParams, match2.params),
      pathname: joinPaths([
        parentPathnameBase,
        // Re-encode pathnames that were decoded inside matchRoutes
        navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathname).pathname : match2.pathname
      ]),
      pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([
        parentPathnameBase,
        // Re-encode pathnames that were decoded inside matchRoutes
        navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathnameBase).pathname : match2.pathnameBase
      ])
    })), parentMatches, dataRouterState);
    if (locationArg && renderedMatches) {
      return /* @__PURE__ */ React__namespace.createElement(LocationContext.Provider, {
        value: {
          location: _extends$2({
            pathname: "/",
            search: "",
            hash: "",
            state: null,
            key: "default"
          }, location2),
          navigationType: Action.Pop
        }
      }, renderedMatches);
    }
    return renderedMatches;
  }
  function DefaultErrorComponent() {
    let error = useRouteError();
    let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
    let stack = error instanceof Error ? error.stack : null;
    let lightgrey = "rgba(200,200,200, 0.5)";
    let preStyles = {
      padding: "0.5rem",
      backgroundColor: lightgrey
    };
    let devInfo = null;
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ React__namespace.createElement("h3", {
      style: {
        fontStyle: "italic"
      }
    }, message), stack ? /* @__PURE__ */ React__namespace.createElement("pre", {
      style: preStyles
    }, stack) : null, devInfo);
  }
  const defaultErrorElement = /* @__PURE__ */ React__namespace.createElement(DefaultErrorComponent, null);
  class RenderErrorBoundary extends React__namespace.Component {
    constructor(props) {
      super(props);
      this.state = {
        location: props.location,
        revalidation: props.revalidation,
        error: props.error
      };
    }
    static getDerivedStateFromError(error) {
      return {
        error
      };
    }
    static getDerivedStateFromProps(props, state2) {
      if (state2.location !== props.location || state2.revalidation !== "idle" && props.revalidation === "idle") {
        return {
          error: props.error,
          location: props.location,
          revalidation: props.revalidation
        };
      }
      return {
        error: props.error || state2.error,
        location: state2.location,
        revalidation: props.revalidation || state2.revalidation
      };
    }
    componentDidCatch(error, errorInfo) {
      console.error("React Router caught the following error during render", error, errorInfo);
    }
    render() {
      return this.state.error ? /* @__PURE__ */ React__namespace.createElement(RouteContext.Provider, {
        value: this.props.routeContext
      }, /* @__PURE__ */ React__namespace.createElement(RouteErrorContext.Provider, {
        value: this.state.error,
        children: this.props.component
      })) : this.props.children;
    }
  }
  function RenderedRoute(_ref) {
    let {
      routeContext,
      match: match2,
      children
    } = _ref;
    let dataRouterContext = React__namespace.useContext(DataRouterContext);
    if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match2.route.errorElement || match2.route.ErrorBoundary)) {
      dataRouterContext.staticContext._deepestRenderedBoundaryId = match2.route.id;
    }
    return /* @__PURE__ */ React__namespace.createElement(RouteContext.Provider, {
      value: routeContext
    }, children);
  }
  function _renderMatches(matches, parentMatches, dataRouterState) {
    var _dataRouterState2;
    if (parentMatches === void 0) {
      parentMatches = [];
    }
    if (dataRouterState === void 0) {
      dataRouterState = null;
    }
    if (matches == null) {
      var _dataRouterState;
      if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {
        matches = dataRouterState.matches;
      } else {
        return null;
      }
    }
    let renderedMatches = matches;
    let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;
    if (errors != null) {
      let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]));
      !(errorIndex >= 0) ? invariant(false) : void 0;
      renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
    }
    return renderedMatches.reduceRight((outlet, match2, index2) => {
      let error = match2.route.id ? errors == null ? void 0 : errors[match2.route.id] : null;
      let errorElement = null;
      if (dataRouterState) {
        errorElement = match2.route.errorElement || defaultErrorElement;
      }
      let matches2 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
      let getChildren = () => {
        let children;
        if (error) {
          children = errorElement;
        } else if (match2.route.Component) {
          children = /* @__PURE__ */ React__namespace.createElement(match2.route.Component, null);
        } else if (match2.route.element) {
          children = match2.route.element;
        } else {
          children = outlet;
        }
        return /* @__PURE__ */ React__namespace.createElement(RenderedRoute, {
          match: match2,
          routeContext: {
            outlet,
            matches: matches2,
            isDataRoute: dataRouterState != null
          },
          children
        });
      };
      return dataRouterState && (match2.route.ErrorBoundary || match2.route.errorElement || index2 === 0) ? /* @__PURE__ */ React__namespace.createElement(RenderErrorBoundary, {
        location: dataRouterState.location,
        revalidation: dataRouterState.revalidation,
        component: errorElement,
        error,
        children: getChildren(),
        routeContext: {
          outlet: null,
          matches: matches2,
          isDataRoute: true
        }
      }) : getChildren();
    }, null);
  }
  var DataRouterHook$1 = /* @__PURE__ */ function(DataRouterHook2) {
    DataRouterHook2["UseBlocker"] = "useBlocker";
    DataRouterHook2["UseRevalidator"] = "useRevalidator";
    DataRouterHook2["UseNavigateStable"] = "useNavigate";
    return DataRouterHook2;
  }(DataRouterHook$1 || {});
  var DataRouterStateHook$1 = /* @__PURE__ */ function(DataRouterStateHook2) {
    DataRouterStateHook2["UseBlocker"] = "useBlocker";
    DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
    DataRouterStateHook2["UseActionData"] = "useActionData";
    DataRouterStateHook2["UseRouteError"] = "useRouteError";
    DataRouterStateHook2["UseNavigation"] = "useNavigation";
    DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
    DataRouterStateHook2["UseMatches"] = "useMatches";
    DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
    DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
    DataRouterStateHook2["UseRouteId"] = "useRouteId";
    return DataRouterStateHook2;
  }(DataRouterStateHook$1 || {});
  function useDataRouterContext(hookName) {
    let ctx = React__namespace.useContext(DataRouterContext);
    !ctx ? invariant(false) : void 0;
    return ctx;
  }
  function useDataRouterState(hookName) {
    let state2 = React__namespace.useContext(DataRouterStateContext);
    !state2 ? invariant(false) : void 0;
    return state2;
  }
  function useRouteContext(hookName) {
    let route = React__namespace.useContext(RouteContext);
    !route ? invariant(false) : void 0;
    return route;
  }
  function useCurrentRouteId(hookName) {
    let route = useRouteContext();
    let thisRoute = route.matches[route.matches.length - 1];
    !thisRoute.route.id ? invariant(false) : void 0;
    return thisRoute.route.id;
  }
  function useRouteError() {
    var _state$errors;
    let error = React__namespace.useContext(RouteErrorContext);
    let state2 = useDataRouterState(DataRouterStateHook$1.UseRouteError);
    let routeId = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
    if (error) {
      return error;
    }
    return (_state$errors = state2.errors) == null ? void 0 : _state$errors[routeId];
  }
  function useNavigateStable() {
    let {
      router
    } = useDataRouterContext(DataRouterHook$1.UseNavigateStable);
    let id2 = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
    let activeRef = React__namespace.useRef(false);
    useIsomorphicLayoutEffect(() => {
      activeRef.current = true;
    });
    let navigate = React__namespace.useCallback(function(to, options) {
      if (options === void 0) {
        options = {};
      }
      if (!activeRef.current)
        return;
      if (typeof to === "number") {
        router.navigate(to);
      } else {
        router.navigate(to, _extends$2({
          fromRouteId: id2
        }, options));
      }
    }, [router, id2]);
    return navigate;
  }
  function Navigate(_ref4) {
    let {
      to,
      replace: replace2,
      state: state2,
      relative
    } = _ref4;
    !useInRouterContext() ? invariant(false) : void 0;
    let {
      matches
    } = React__namespace.useContext(RouteContext);
    let {
      pathname: locationPathname
    } = useLocation();
    let navigate = useNavigate();
    let path2 = resolveTo(to, getPathContributingMatches(matches).map((match2) => match2.pathnameBase), locationPathname, relative === "path");
    let jsonPath = JSON.stringify(path2);
    React__namespace.useEffect(() => navigate(JSON.parse(jsonPath), {
      replace: replace2,
      state: state2,
      relative
    }), [navigate, jsonPath, relative, replace2, state2]);
    return null;
  }
  function Route(_props) {
    invariant(false);
  }
  function Router(_ref5) {
    let {
      basename: basenameProp = "/",
      children = null,
      location: locationProp,
      navigationType = Action.Pop,
      navigator: navigator2,
      static: staticProp = false
    } = _ref5;
    !!useInRouterContext() ? invariant(false) : void 0;
    let basename = basenameProp.replace(/^\/*/, "/");
    let navigationContext = React__namespace.useMemo(() => ({
      basename,
      navigator: navigator2,
      static: staticProp
    }), [basename, navigator2, staticProp]);
    if (typeof locationProp === "string") {
      locationProp = parsePath(locationProp);
    }
    let {
      pathname = "/",
      search = "",
      hash: hash2 = "",
      state: state2 = null,
      key = "default"
    } = locationProp;
    let locationContext = React__namespace.useMemo(() => {
      let trailingPathname = stripBasename(pathname, basename);
      if (trailingPathname == null) {
        return null;
      }
      return {
        location: {
          pathname: trailingPathname,
          search,
          hash: hash2,
          state: state2,
          key
        },
        navigationType
      };
    }, [basename, pathname, search, hash2, state2, key, navigationType]);
    if (locationContext == null) {
      return null;
    }
    return /* @__PURE__ */ React__namespace.createElement(NavigationContext.Provider, {
      value: navigationContext
    }, /* @__PURE__ */ React__namespace.createElement(LocationContext.Provider, {
      children,
      value: locationContext
    }));
  }
  function Routes(_ref6) {
    let {
      children,
      location: location2
    } = _ref6;
    return useRoutes(createRoutesFromChildren(children), location2);
  }
  new Promise(() => {
  });
  function createRoutesFromChildren(children, parentPath) {
    if (parentPath === void 0) {
      parentPath = [];
    }
    let routes2 = [];
    React__namespace.Children.forEach(children, (element, index2) => {
      if (!/* @__PURE__ */ React__namespace.isValidElement(element)) {
        return;
      }
      let treePath = [...parentPath, index2];
      if (element.type === React__namespace.Fragment) {
        routes2.push.apply(routes2, createRoutesFromChildren(element.props.children, treePath));
        return;
      }
      !(element.type === Route) ? invariant(false) : void 0;
      !(!element.props.index || !element.props.children) ? invariant(false) : void 0;
      let route = {
        id: element.props.id || treePath.join("-"),
        caseSensitive: element.props.caseSensitive,
        element: element.props.element,
        Component: element.props.Component,
        index: element.props.index,
        path: element.props.path,
        loader: element.props.loader,
        action: element.props.action,
        errorElement: element.props.errorElement,
        ErrorBoundary: element.props.ErrorBoundary,
        hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
        shouldRevalidate: element.props.shouldRevalidate,
        handle: element.props.handle,
        lazy: element.props.lazy
      };
      if (element.props.children) {
        route.children = createRoutesFromChildren(element.props.children, treePath);
      }
      routes2.push(route);
    });
    return routes2;
  }
  /**
   * React Router DOM v6.16.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
  const START_TRANSITION = "startTransition";
  const startTransitionImpl = React__namespace[START_TRANSITION];
  function BrowserRouter(_ref) {
    let {
      basename,
      children,
      future,
      window: window2
    } = _ref;
    let historyRef = React__namespace.useRef();
    if (historyRef.current == null) {
      historyRef.current = createBrowserHistory({
        window: window2,
        v5Compat: true
      });
    }
    let history = historyRef.current;
    let [state2, setStateImpl] = React__namespace.useState({
      action: history.action,
      location: history.location
    });
    let {
      v7_startTransition
    } = future || {};
    let setState = React__namespace.useCallback((newState) => {
      v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
    }, [setStateImpl, v7_startTransition]);
    React__namespace.useLayoutEffect(() => history.listen(setState), [history, setState]);
    return /* @__PURE__ */ React__namespace.createElement(Router, {
      basename,
      children,
      location: state2.location,
      navigationType: state2.action,
      navigator: history
    });
  }
  var DataRouterHook;
  (function(DataRouterHook2) {
    DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
    DataRouterHook2["UseSubmit"] = "useSubmit";
    DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
    DataRouterHook2["UseFetcher"] = "useFetcher";
  })(DataRouterHook || (DataRouterHook = {}));
  var DataRouterStateHook;
  (function(DataRouterStateHook2) {
    DataRouterStateHook2["UseFetchers"] = "useFetchers";
    DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
  })(DataRouterStateHook || (DataRouterStateHook = {}));
  const Footer = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      react.Flex,
      {
        as: "footer",
        width: "full",
        align: "center",
        alignSelf: "flex-end",
        justifyContent: "center",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Text, { fontSize: "xs", children: [
          (/* @__PURE__ */ new Date()).getFullYear(),
          " -",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.Link, { href: "https://pioneers.dev", isExternal: true, children: "pioneers.dev" })
        ] })
      }
    );
  };
  const PROJECT_NAME = "Swaps.PRO";
  const HeaderNew = () => {
    var _a3, _b, _c;
    const navigate = useNavigate();
    const { state: state2, connectWallet } = usePioneer();
    const {
      // api,
      // app,
      context: context2
      // assetContext,
      // blockchainContext,
      // pubkeyContext,
      // modals,
    } = state2;
    const [showAll, setShowAll] = React$1.useState(false);
    const isConnectedInitial = ((_b = (_a3 = state2.app) == null ? void 0 : _a3.wallets) == null ? void 0 : _b.some((wallet2) => wallet2.isConnected)) ?? false;
    const [isOpen, setIsOpen] = React$1.useState(!isConnectedInitial);
    const handleOpen = () => setIsOpen(true);
    const handleClose = () => {
      var _a4, _b2;
      if ((_b2 = (_a4 = state2.app) == null ? void 0 : _a4.wallets) == null ? void 0 : _b2.some((wallet2) => wallet2.isConnected)) {
        setIsOpen(false);
      }
    };
    const handleLogoClick = () => {
      console.log("The logo was clicked!");
      navigate("/");
      window.location.reload();
    };
    React$1.useEffect(() => {
      var _a4, _b2;
      if ((_a4 = state2.app) == null ? void 0 : _a4.wallets) {
        console.log("app.wallets: ", state2.app.wallets);
        for (let i2 = 0; i2 < state2.app.wallets.length; i2++) {
          const wallet2 = state2.app.wallets[i2];
          if ((_b2 = wallet2 == null ? void 0 : wallet2.wallet) == null ? void 0 : _b2.isDetected) {
            console.log("wallet is available: ", wallet2.type);
          }
        }
      }
    }, [state2.app, (_c = state2.app) == null ? void 0 : _c.wallets]);
    React$1.useEffect(() => {
      if (context2) {
        console.log("context: ", context2);
        setIsOpen(false);
      }
    }, [context2]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      react.Flex,
      {
        alignItems: "center",
        alignSelf: "flex-start",
        as: "header",
        gridGap: 2,
        justifyContent: "space-between",
        p: 5,
        width: "full",
        children: [
          state2.app && state2.app.wallets && /* @__PURE__ */ jsxRuntimeExports.jsx(react.Drawer, { isOpen, onClose: handleClose, placement: "right", children: /* @__PURE__ */ jsxRuntimeExports.jsx(react.DrawerOverlay, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(react.DrawerContent, { bg: "black", border: "2px solid white", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(react.DrawerCloseButton, { onClick: () => setIsOpen(false) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(react.DrawerHeader, { children: "Wallets" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(react.DrawerBody, { children: [
              !context2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(react.Text, { children: "You must pair a wallet to continue" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(react.Text, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
                "context: ",
                JSON.stringify(context2)
              ] }) }),
              showAll ? state2.app.wallets.map((wallet2) => /* @__PURE__ */ jsxRuntimeExports.jsx(react.Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                react.Box,
                {
                  bg: "black",
                  borderRadius: "md",
                  boxShadow: "md",
                  maxW: "sm",
                  mt: 4,
                  onClick: () => connectWallet(wallet2.type),
                  opacity: wallet2.wallet.isDetected ? 1 : 0.5,
                  p: 4,
                  w: "full",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs(react.HStack, { spacing: 4, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(react.Avatar, { name: wallet2.type, src: wallet2.icon }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(react.VStack, { alignItems: "start", spacing: 1, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(react.Text, { fontWeight: "bold", children: wallet2.type }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(react.HStack, { spacing: 2, children: [
                        wallet2.wallet.isDetected ? /* @__PURE__ */ jsxRuntimeExports.jsx(react.Badge, { colorScheme: "green", children: "AVAILABLE" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(react.Badge, { colorScheme: "gray", children: "UNAVAILABLE" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(react.Badge, { colorScheme: wallet2.isConnected ? "green" : "red", children: wallet2.isConnected ? "CONNECTED" : "DISCONNECTED" })
                      ] })
                    ] })
                  ] })
                },
                wallet2.type
              ) }, wallet2.type)) : state2.app.wallets.filter((wallet2) => wallet2.wallet.isDetected).map((wallet2) => /* @__PURE__ */ jsxRuntimeExports.jsx(react.Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                react.Box,
                {
                  bg: "black",
                  borderRadius: "md",
                  boxShadow: "md",
                  maxW: "sm",
                  mt: 4,
                  onClick: () => connectWallet(wallet2.type),
                  opacity: wallet2.wallet.isDetected ? 1 : 0.5,
                  p: 4,
                  w: "full",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs(react.HStack, { spacing: 4, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(react.Avatar, { name: wallet2.type, src: wallet2.icon }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(react.VStack, { alignItems: "start", spacing: 1, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(react.Text, { fontWeight: "bold", children: wallet2.type }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(react.HStack, { spacing: 2, children: [
                        wallet2.wallet.isDetected ? /* @__PURE__ */ jsxRuntimeExports.jsx(react.Badge, { colorScheme: "green", children: "AVAILABLE" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(react.Badge, { colorScheme: "gray", children: "UNAVAILABLE" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(react.Badge, { colorScheme: wallet2.isConnected ? "green" : "red", children: wallet2.isConnected ? "CONNECTED" : "DISCONNECTED" })
                      ] })
                    ] })
                  ] })
                },
                wallet2.type
              ) }, wallet2.type)),
              /* @__PURE__ */ jsxRuntimeExports.jsx(react.Button, { mt: 4, onClick: () => setShowAll((prev2) => !prev2), size: "sm", children: showAll ? "Hide Options" : "Show All Options" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(react.DrawerFooter, {})
          ] }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(react.HStack, { alignItems: "center", onClick: handleLogoClick, spacing: 4, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(react.Avatar, { name: "logo" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(react.Text, { fontSize: "3xl", children: PROJECT_NAME })
          ] }),
          context2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(react.Button, { onClick: handleOpen, children: "Connected" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(react.Button, { onClick: handleOpen, children: "Connect" }) })
        ]
      }
    );
  };
  var propTypes = { exports: {} };
  var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
  var ReactPropTypesSecret = ReactPropTypesSecret_1;
  function emptyFunction() {
  }
  function emptyFunctionWithReset() {
  }
  emptyFunctionWithReset.resetWarningCache = emptyFunction;
  var factoryWithThrowingShims = function() {
    function shim(props, propName, componentName, location2, propFullName, secret2) {
      if (secret2 === ReactPropTypesSecret) {
        return;
      }
      var err = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      err.name = "Invariant Violation";
      throw err;
    }
    shim.isRequired = shim;
    function getShim() {
      return shim;
    }
    var ReactPropTypes = {
      array: shim,
      bigint: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,
      any: shim,
      arrayOf: getShim,
      element: shim,
      elementType: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  {
    propTypes.exports = factoryWithThrowingShims();
  }
  var propTypesExports = propTypes.exports;
  const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
  function _interopDefault$1(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  }
  var React = React$1;
  var React__default = _interopDefault$1(React);
  function _defineProperty(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
  function withSideEffect(reducePropsToState2, handleStateChangeOnClient, mapStateOnServer2) {
    if (typeof reducePropsToState2 !== "function") {
      throw new Error("Expected reducePropsToState to be a function.");
    }
    if (typeof handleStateChangeOnClient !== "function") {
      throw new Error("Expected handleStateChangeOnClient to be a function.");
    }
    if (typeof mapStateOnServer2 !== "undefined" && typeof mapStateOnServer2 !== "function") {
      throw new Error("Expected mapStateOnServer to either be undefined or a function.");
    }
    function getDisplayName(WrappedComponent) {
      return WrappedComponent.displayName || WrappedComponent.name || "Component";
    }
    return function wrap2(WrappedComponent) {
      if (typeof WrappedComponent !== "function") {
        throw new Error("Expected WrappedComponent to be a React component.");
      }
      var mountedInstances = [];
      var state2;
      function emitChange() {
        state2 = reducePropsToState2(mountedInstances.map(function(instance) {
          return instance.props;
        }));
        if (SideEffect.canUseDOM) {
          handleStateChangeOnClient(state2);
        } else if (mapStateOnServer2) {
          state2 = mapStateOnServer2(state2);
        }
      }
      var SideEffect = /* @__PURE__ */ function(_PureComponent) {
        _inheritsLoose(SideEffect2, _PureComponent);
        function SideEffect2() {
          return _PureComponent.apply(this, arguments) || this;
        }
        SideEffect2.peek = function peek() {
          return state2;
        };
        SideEffect2.rewind = function rewind() {
          if (SideEffect2.canUseDOM) {
            throw new Error("You may only call rewind() on the server. Call peek() to read the current state.");
          }
          var recordedState = state2;
          state2 = void 0;
          mountedInstances = [];
          return recordedState;
        };
        var _proto = SideEffect2.prototype;
        _proto.UNSAFE_componentWillMount = function UNSAFE_componentWillMount() {
          mountedInstances.push(this);
          emitChange();
        };
        _proto.componentDidUpdate = function componentDidUpdate() {
          emitChange();
        };
        _proto.componentWillUnmount = function componentWillUnmount() {
          var index2 = mountedInstances.indexOf(this);
          mountedInstances.splice(index2, 1);
          emitChange();
        };
        _proto.render = function render() {
          return React__default.createElement(WrappedComponent, this.props);
        };
        return SideEffect2;
      }(React.PureComponent);
      _defineProperty(SideEffect, "displayName", "SideEffect(" + getDisplayName(WrappedComponent) + ")");
      _defineProperty(SideEffect, "canUseDOM", canUseDOM);
      return SideEffect;
    };
  }
  var lib = withSideEffect;
  const withSideEffect$1 = /* @__PURE__ */ getDefaultExportFromCjs(lib);
  var hasElementType = typeof Element !== "undefined";
  var hasMap = typeof Map === "function";
  var hasSet = typeof Set === "function";
  var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
  function equal(a, b) {
    if (a === b)
      return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor)
        return false;
      var length2, i2, keys2;
      if (Array.isArray(a)) {
        length2 = a.length;
        if (length2 != b.length)
          return false;
        for (i2 = length2; i2-- !== 0; )
          if (!equal(a[i2], b[i2]))
            return false;
        return true;
      }
      var it;
      if (hasMap && a instanceof Map && b instanceof Map) {
        if (a.size !== b.size)
          return false;
        it = a.entries();
        while (!(i2 = it.next()).done)
          if (!b.has(i2.value[0]))
            return false;
        it = a.entries();
        while (!(i2 = it.next()).done)
          if (!equal(i2.value[1], b.get(i2.value[0])))
            return false;
        return true;
      }
      if (hasSet && a instanceof Set && b instanceof Set) {
        if (a.size !== b.size)
          return false;
        it = a.entries();
        while (!(i2 = it.next()).done)
          if (!b.has(i2.value[0]))
            return false;
        return true;
      }
      if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
        length2 = a.length;
        if (length2 != b.length)
          return false;
        for (i2 = length2; i2-- !== 0; )
          if (a[i2] !== b[i2])
            return false;
        return true;
      }
      if (a.constructor === RegExp)
        return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf === "function" && typeof b.valueOf === "function")
        return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString && typeof a.toString === "function" && typeof b.toString === "function")
        return a.toString() === b.toString();
      keys2 = Object.keys(a);
      length2 = keys2.length;
      if (length2 !== Object.keys(b).length)
        return false;
      for (i2 = length2; i2-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys2[i2]))
          return false;
      if (hasElementType && a instanceof Element)
        return false;
      for (i2 = length2; i2-- !== 0; ) {
        if ((keys2[i2] === "_owner" || keys2[i2] === "__v" || keys2[i2] === "__o") && a.$$typeof) {
          continue;
        }
        if (!equal(a[keys2[i2]], b[keys2[i2]]))
          return false;
      }
      return true;
    }
    return a !== a && b !== b;
  }
  var reactFastCompare = function isEqual2(a, b) {
    try {
      return equal(a, b);
    } catch (error) {
      if ((error.message || "").match(/stack|recursion/i)) {
        console.warn("react-fast-compare cannot handle circular refs");
        return false;
      }
      throw error;
    }
  };
  const isEqual = /* @__PURE__ */ getDefaultExportFromCjs(reactFastCompare);
  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;
  function toObject(val) {
    if (val === null || val === void 0) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
  }
  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }
      var test1 = new String("abc");
      test1[5] = "de";
      if (Object.getOwnPropertyNames(test1)[0] === "5") {
        return false;
      }
      var test2 = {};
      for (var i2 = 0; i2 < 10; i2++) {
        test2["_" + String.fromCharCode(i2)] = i2;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
        return test2[n2];
      });
      if (order2.join("") !== "0123456789") {
        return false;
      }
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
    var from2;
    var to = toObject(target);
    var symbols;
    for (var s = 1; s < arguments.length; s++) {
      from2 = Object(arguments[s]);
      for (var key in from2) {
        if (hasOwnProperty.call(from2, key)) {
          to[key] = from2[key];
        }
      }
      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from2);
        for (var i2 = 0; i2 < symbols.length; i2++) {
          if (propIsEnumerable.call(from2, symbols[i2])) {
            to[symbols[i2]] = from2[symbols[i2]];
          }
        }
      }
    }
    return to;
  };
  const objectAssign$1 = /* @__PURE__ */ getDefaultExportFromCjs(objectAssign);
  var ATTRIBUTE_NAMES = {
    BODY: "bodyAttributes",
    HTML: "htmlAttributes",
    TITLE: "titleAttributes"
  };
  var TAG_NAMES = {
    BASE: "base",
    BODY: "body",
    HEAD: "head",
    HTML: "html",
    LINK: "link",
    META: "meta",
    NOSCRIPT: "noscript",
    SCRIPT: "script",
    STYLE: "style",
    TITLE: "title"
  };
  Object.keys(TAG_NAMES).map(function(name) {
    return TAG_NAMES[name];
  });
  var TAG_PROPERTIES = {
    CHARSET: "charset",
    CSS_TEXT: "cssText",
    HREF: "href",
    HTTPEQUIV: "http-equiv",
    INNER_HTML: "innerHTML",
    ITEM_PROP: "itemprop",
    NAME: "name",
    PROPERTY: "property",
    REL: "rel",
    SRC: "src",
    TARGET: "target"
  };
  var REACT_TAG_MAP = {
    accesskey: "accessKey",
    charset: "charSet",
    class: "className",
    contenteditable: "contentEditable",
    contextmenu: "contextMenu",
    "http-equiv": "httpEquiv",
    itemprop: "itemProp",
    tabindex: "tabIndex"
  };
  var HELMET_PROPS = {
    DEFAULT_TITLE: "defaultTitle",
    DEFER: "defer",
    ENCODE_SPECIAL_CHARACTERS: "encodeSpecialCharacters",
    ON_CHANGE_CLIENT_STATE: "onChangeClientState",
    TITLE_TEMPLATE: "titleTemplate"
  };
  var HTML_TAG_MAP = Object.keys(REACT_TAG_MAP).reduce(function(obj, key) {
    obj[REACT_TAG_MAP[key]] = key;
    return obj;
  }, {});
  var SELF_CLOSING_TAGS = [TAG_NAMES.NOSCRIPT, TAG_NAMES.SCRIPT, TAG_NAMES.STYLE];
  var HELMET_ATTRIBUTE = "data-react-helmet";
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  var classCallCheck = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  var createClass = function() {
    function defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _extends$1 = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  var inherits = function(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass)
      Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
  var objectWithoutProperties = function(obj, keys2) {
    var target = {};
    for (var i2 in obj) {
      if (keys2.indexOf(i2) >= 0)
        continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i2))
        continue;
      target[i2] = obj[i2];
    }
    return target;
  };
  var possibleConstructorReturn = function(self2, call2) {
    if (!self2) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call2 && (typeof call2 === "object" || typeof call2 === "function") ? call2 : self2;
  };
  var encodeSpecialCharacters = function encodeSpecialCharacters2(str2) {
    var encode2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (encode2 === false) {
      return String(str2);
    }
    return String(str2).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
  };
  var getTitleFromPropsList = function getTitleFromPropsList2(propsList) {
    var innermostTitle = getInnermostProperty(propsList, TAG_NAMES.TITLE);
    var innermostTemplate = getInnermostProperty(propsList, HELMET_PROPS.TITLE_TEMPLATE);
    if (innermostTemplate && innermostTitle) {
      return innermostTemplate.replace(/%s/g, function() {
        return Array.isArray(innermostTitle) ? innermostTitle.join("") : innermostTitle;
      });
    }
    var innermostDefaultTitle = getInnermostProperty(propsList, HELMET_PROPS.DEFAULT_TITLE);
    return innermostTitle || innermostDefaultTitle || void 0;
  };
  var getOnChangeClientState = function getOnChangeClientState2(propsList) {
    return getInnermostProperty(propsList, HELMET_PROPS.ON_CHANGE_CLIENT_STATE) || function() {
    };
  };
  var getAttributesFromPropsList = function getAttributesFromPropsList2(tagType, propsList) {
    return propsList.filter(function(props) {
      return typeof props[tagType] !== "undefined";
    }).map(function(props) {
      return props[tagType];
    }).reduce(function(tagAttrs, current) {
      return _extends$1({}, tagAttrs, current);
    }, {});
  };
  var getBaseTagFromPropsList = function getBaseTagFromPropsList2(primaryAttributes, propsList) {
    return propsList.filter(function(props) {
      return typeof props[TAG_NAMES.BASE] !== "undefined";
    }).map(function(props) {
      return props[TAG_NAMES.BASE];
    }).reverse().reduce(function(innermostBaseTag, tag) {
      if (!innermostBaseTag.length) {
        var keys2 = Object.keys(tag);
        for (var i2 = 0; i2 < keys2.length; i2++) {
          var attributeKey = keys2[i2];
          var lowerCaseAttributeKey = attributeKey.toLowerCase();
          if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && tag[lowerCaseAttributeKey]) {
            return innermostBaseTag.concat(tag);
          }
        }
      }
      return innermostBaseTag;
    }, []);
  };
  var getTagsFromPropsList = function getTagsFromPropsList2(tagName, primaryAttributes, propsList) {
    var approvedSeenTags = {};
    return propsList.filter(function(props) {
      if (Array.isArray(props[tagName])) {
        return true;
      }
      if (typeof props[tagName] !== "undefined") {
        warn("Helmet: " + tagName + ' should be of type "Array". Instead found type "' + _typeof(props[tagName]) + '"');
      }
      return false;
    }).map(function(props) {
      return props[tagName];
    }).reverse().reduce(function(approvedTags, instanceTags) {
      var instanceSeenTags = {};
      instanceTags.filter(function(tag) {
        var primaryAttributeKey = void 0;
        var keys3 = Object.keys(tag);
        for (var i3 = 0; i3 < keys3.length; i3++) {
          var attributeKey2 = keys3[i3];
          var lowerCaseAttributeKey = attributeKey2.toLowerCase();
          if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && !(primaryAttributeKey === TAG_PROPERTIES.REL && tag[primaryAttributeKey].toLowerCase() === "canonical") && !(lowerCaseAttributeKey === TAG_PROPERTIES.REL && tag[lowerCaseAttributeKey].toLowerCase() === "stylesheet")) {
            primaryAttributeKey = lowerCaseAttributeKey;
          }
          if (primaryAttributes.indexOf(attributeKey2) !== -1 && (attributeKey2 === TAG_PROPERTIES.INNER_HTML || attributeKey2 === TAG_PROPERTIES.CSS_TEXT || attributeKey2 === TAG_PROPERTIES.ITEM_PROP)) {
            primaryAttributeKey = attributeKey2;
          }
        }
        if (!primaryAttributeKey || !tag[primaryAttributeKey]) {
          return false;
        }
        var value2 = tag[primaryAttributeKey].toLowerCase();
        if (!approvedSeenTags[primaryAttributeKey]) {
          approvedSeenTags[primaryAttributeKey] = {};
        }
        if (!instanceSeenTags[primaryAttributeKey]) {
          instanceSeenTags[primaryAttributeKey] = {};
        }
        if (!approvedSeenTags[primaryAttributeKey][value2]) {
          instanceSeenTags[primaryAttributeKey][value2] = true;
          return true;
        }
        return false;
      }).reverse().forEach(function(tag) {
        return approvedTags.push(tag);
      });
      var keys2 = Object.keys(instanceSeenTags);
      for (var i2 = 0; i2 < keys2.length; i2++) {
        var attributeKey = keys2[i2];
        var tagUnion = objectAssign$1({}, approvedSeenTags[attributeKey], instanceSeenTags[attributeKey]);
        approvedSeenTags[attributeKey] = tagUnion;
      }
      return approvedTags;
    }, []).reverse();
  };
  var getInnermostProperty = function getInnermostProperty2(propsList, property) {
    for (var i2 = propsList.length - 1; i2 >= 0; i2--) {
      var props = propsList[i2];
      if (props.hasOwnProperty(property)) {
        return props[property];
      }
    }
    return null;
  };
  var reducePropsToState = function reducePropsToState2(propsList) {
    return {
      baseTag: getBaseTagFromPropsList([TAG_PROPERTIES.HREF, TAG_PROPERTIES.TARGET], propsList),
      bodyAttributes: getAttributesFromPropsList(ATTRIBUTE_NAMES.BODY, propsList),
      defer: getInnermostProperty(propsList, HELMET_PROPS.DEFER),
      encode: getInnermostProperty(propsList, HELMET_PROPS.ENCODE_SPECIAL_CHARACTERS),
      htmlAttributes: getAttributesFromPropsList(ATTRIBUTE_NAMES.HTML, propsList),
      linkTags: getTagsFromPropsList(TAG_NAMES.LINK, [TAG_PROPERTIES.REL, TAG_PROPERTIES.HREF], propsList),
      metaTags: getTagsFromPropsList(TAG_NAMES.META, [TAG_PROPERTIES.NAME, TAG_PROPERTIES.CHARSET, TAG_PROPERTIES.HTTPEQUIV, TAG_PROPERTIES.PROPERTY, TAG_PROPERTIES.ITEM_PROP], propsList),
      noscriptTags: getTagsFromPropsList(TAG_NAMES.NOSCRIPT, [TAG_PROPERTIES.INNER_HTML], propsList),
      onChangeClientState: getOnChangeClientState(propsList),
      scriptTags: getTagsFromPropsList(TAG_NAMES.SCRIPT, [TAG_PROPERTIES.SRC, TAG_PROPERTIES.INNER_HTML], propsList),
      styleTags: getTagsFromPropsList(TAG_NAMES.STYLE, [TAG_PROPERTIES.CSS_TEXT], propsList),
      title: getTitleFromPropsList(propsList),
      titleAttributes: getAttributesFromPropsList(ATTRIBUTE_NAMES.TITLE, propsList)
    };
  };
  var rafPolyfill = function() {
    var clock = Date.now();
    return function(callback) {
      var currentTime = Date.now();
      if (currentTime - clock > 16) {
        clock = currentTime;
        callback(currentTime);
      } else {
        setTimeout(function() {
          rafPolyfill(callback);
        }, 0);
      }
    };
  }();
  var cafPolyfill = function cafPolyfill2(id2) {
    return clearTimeout(id2);
  };
  var requestAnimationFrame$1 = typeof window !== "undefined" ? window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || rafPolyfill : global$e.requestAnimationFrame || rafPolyfill;
  var cancelAnimationFrame$1 = typeof window !== "undefined" ? window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || cafPolyfill : global$e.cancelAnimationFrame || cafPolyfill;
  var warn = function warn2(msg) {
    return console && typeof console.warn === "function" && console.warn(msg);
  };
  var _helmetCallback = null;
  var handleClientStateChange = function handleClientStateChange2(newState) {
    if (_helmetCallback) {
      cancelAnimationFrame$1(_helmetCallback);
    }
    if (newState.defer) {
      _helmetCallback = requestAnimationFrame$1(function() {
        commitTagChanges(newState, function() {
          _helmetCallback = null;
        });
      });
    } else {
      commitTagChanges(newState);
      _helmetCallback = null;
    }
  };
  var commitTagChanges = function commitTagChanges2(newState, cb) {
    var baseTag = newState.baseTag, bodyAttributes = newState.bodyAttributes, htmlAttributes = newState.htmlAttributes, linkTags = newState.linkTags, metaTags = newState.metaTags, noscriptTags = newState.noscriptTags, onChangeClientState = newState.onChangeClientState, scriptTags = newState.scriptTags, styleTags = newState.styleTags, title = newState.title, titleAttributes = newState.titleAttributes;
    updateAttributes(TAG_NAMES.BODY, bodyAttributes);
    updateAttributes(TAG_NAMES.HTML, htmlAttributes);
    updateTitle(title, titleAttributes);
    var tagUpdates = {
      baseTag: updateTags(TAG_NAMES.BASE, baseTag),
      linkTags: updateTags(TAG_NAMES.LINK, linkTags),
      metaTags: updateTags(TAG_NAMES.META, metaTags),
      noscriptTags: updateTags(TAG_NAMES.NOSCRIPT, noscriptTags),
      scriptTags: updateTags(TAG_NAMES.SCRIPT, scriptTags),
      styleTags: updateTags(TAG_NAMES.STYLE, styleTags)
    };
    var addedTags = {};
    var removedTags = {};
    Object.keys(tagUpdates).forEach(function(tagType) {
      var _tagUpdates$tagType = tagUpdates[tagType], newTags = _tagUpdates$tagType.newTags, oldTags = _tagUpdates$tagType.oldTags;
      if (newTags.length) {
        addedTags[tagType] = newTags;
      }
      if (oldTags.length) {
        removedTags[tagType] = tagUpdates[tagType].oldTags;
      }
    });
    cb && cb();
    onChangeClientState(newState, addedTags, removedTags);
  };
  var flattenArray = function flattenArray2(possibleArray) {
    return Array.isArray(possibleArray) ? possibleArray.join("") : possibleArray;
  };
  var updateTitle = function updateTitle2(title, attributes) {
    if (typeof title !== "undefined" && document.title !== title) {
      document.title = flattenArray(title);
    }
    updateAttributes(TAG_NAMES.TITLE, attributes);
  };
  var updateAttributes = function updateAttributes2(tagName, attributes) {
    var elementTag = document.getElementsByTagName(tagName)[0];
    if (!elementTag) {
      return;
    }
    var helmetAttributeString = elementTag.getAttribute(HELMET_ATTRIBUTE);
    var helmetAttributes = helmetAttributeString ? helmetAttributeString.split(",") : [];
    var attributesToRemove = [].concat(helmetAttributes);
    var attributeKeys = Object.keys(attributes);
    for (var i2 = 0; i2 < attributeKeys.length; i2++) {
      var attribute = attributeKeys[i2];
      var value2 = attributes[attribute] || "";
      if (elementTag.getAttribute(attribute) !== value2) {
        elementTag.setAttribute(attribute, value2);
      }
      if (helmetAttributes.indexOf(attribute) === -1) {
        helmetAttributes.push(attribute);
      }
      var indexToSave = attributesToRemove.indexOf(attribute);
      if (indexToSave !== -1) {
        attributesToRemove.splice(indexToSave, 1);
      }
    }
    for (var _i = attributesToRemove.length - 1; _i >= 0; _i--) {
      elementTag.removeAttribute(attributesToRemove[_i]);
    }
    if (helmetAttributes.length === attributesToRemove.length) {
      elementTag.removeAttribute(HELMET_ATTRIBUTE);
    } else if (elementTag.getAttribute(HELMET_ATTRIBUTE) !== attributeKeys.join(",")) {
      elementTag.setAttribute(HELMET_ATTRIBUTE, attributeKeys.join(","));
    }
  };
  var updateTags = function updateTags2(type2, tags2) {
    var headElement = document.head || document.querySelector(TAG_NAMES.HEAD);
    var tagNodes = headElement.querySelectorAll(type2 + "[" + HELMET_ATTRIBUTE + "]");
    var oldTags = Array.prototype.slice.call(tagNodes);
    var newTags = [];
    var indexToDelete = void 0;
    if (tags2 && tags2.length) {
      tags2.forEach(function(tag) {
        var newElement = document.createElement(type2);
        for (var attribute in tag) {
          if (tag.hasOwnProperty(attribute)) {
            if (attribute === TAG_PROPERTIES.INNER_HTML) {
              newElement.innerHTML = tag.innerHTML;
            } else if (attribute === TAG_PROPERTIES.CSS_TEXT) {
              if (newElement.styleSheet) {
                newElement.styleSheet.cssText = tag.cssText;
              } else {
                newElement.appendChild(document.createTextNode(tag.cssText));
              }
            } else {
              var value2 = typeof tag[attribute] === "undefined" ? "" : tag[attribute];
              newElement.setAttribute(attribute, value2);
            }
          }
        }
        newElement.setAttribute(HELMET_ATTRIBUTE, "true");
        if (oldTags.some(function(existingTag, index2) {
          indexToDelete = index2;
          return newElement.isEqualNode(existingTag);
        })) {
          oldTags.splice(indexToDelete, 1);
        } else {
          newTags.push(newElement);
        }
      });
    }
    oldTags.forEach(function(tag) {
      return tag.parentNode.removeChild(tag);
    });
    newTags.forEach(function(tag) {
      return headElement.appendChild(tag);
    });
    return {
      oldTags,
      newTags
    };
  };
  var generateElementAttributesAsString = function generateElementAttributesAsString2(attributes) {
    return Object.keys(attributes).reduce(function(str2, key) {
      var attr = typeof attributes[key] !== "undefined" ? key + '="' + attributes[key] + '"' : "" + key;
      return str2 ? str2 + " " + attr : attr;
    }, "");
  };
  var generateTitleAsString = function generateTitleAsString2(type2, title, attributes, encode2) {
    var attributeString = generateElementAttributesAsString(attributes);
    var flattenedTitle = flattenArray(title);
    return attributeString ? "<" + type2 + " " + HELMET_ATTRIBUTE + '="true" ' + attributeString + ">" + encodeSpecialCharacters(flattenedTitle, encode2) + "</" + type2 + ">" : "<" + type2 + " " + HELMET_ATTRIBUTE + '="true">' + encodeSpecialCharacters(flattenedTitle, encode2) + "</" + type2 + ">";
  };
  var generateTagsAsString = function generateTagsAsString2(type2, tags2, encode2) {
    return tags2.reduce(function(str2, tag) {
      var attributeHtml = Object.keys(tag).filter(function(attribute) {
        return !(attribute === TAG_PROPERTIES.INNER_HTML || attribute === TAG_PROPERTIES.CSS_TEXT);
      }).reduce(function(string, attribute) {
        var attr = typeof tag[attribute] === "undefined" ? attribute : attribute + '="' + encodeSpecialCharacters(tag[attribute], encode2) + '"';
        return string ? string + " " + attr : attr;
      }, "");
      var tagContent = tag.innerHTML || tag.cssText || "";
      var isSelfClosing = SELF_CLOSING_TAGS.indexOf(type2) === -1;
      return str2 + "<" + type2 + " " + HELMET_ATTRIBUTE + '="true" ' + attributeHtml + (isSelfClosing ? "/>" : ">" + tagContent + "</" + type2 + ">");
    }, "");
  };
  var convertElementAttributestoReactProps = function convertElementAttributestoReactProps2(attributes) {
    var initProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Object.keys(attributes).reduce(function(obj, key) {
      obj[REACT_TAG_MAP[key] || key] = attributes[key];
      return obj;
    }, initProps);
  };
  var convertReactPropstoHtmlAttributes = function convertReactPropstoHtmlAttributes2(props) {
    var initAttributes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Object.keys(props).reduce(function(obj, key) {
      obj[HTML_TAG_MAP[key] || key] = props[key];
      return obj;
    }, initAttributes);
  };
  var generateTitleAsReactComponent = function generateTitleAsReactComponent2(type2, title, attributes) {
    var _initProps;
    var initProps = (_initProps = {
      key: title
    }, _initProps[HELMET_ATTRIBUTE] = true, _initProps);
    var props = convertElementAttributestoReactProps(attributes, initProps);
    return [React$1.createElement(TAG_NAMES.TITLE, props, title)];
  };
  var generateTagsAsReactComponent = function generateTagsAsReactComponent2(type2, tags2) {
    return tags2.map(function(tag, i2) {
      var _mappedTag;
      var mappedTag = (_mappedTag = {
        key: i2
      }, _mappedTag[HELMET_ATTRIBUTE] = true, _mappedTag);
      Object.keys(tag).forEach(function(attribute) {
        var mappedAttribute = REACT_TAG_MAP[attribute] || attribute;
        if (mappedAttribute === TAG_PROPERTIES.INNER_HTML || mappedAttribute === TAG_PROPERTIES.CSS_TEXT) {
          var content = tag.innerHTML || tag.cssText;
          mappedTag.dangerouslySetInnerHTML = { __html: content };
        } else {
          mappedTag[mappedAttribute] = tag[attribute];
        }
      });
      return React$1.createElement(type2, mappedTag);
    });
  };
  var getMethodsForTag = function getMethodsForTag2(type2, tags2, encode2) {
    switch (type2) {
      case TAG_NAMES.TITLE:
        return {
          toComponent: function toComponent() {
            return generateTitleAsReactComponent(type2, tags2.title, tags2.titleAttributes);
          },
          toString: function toString2() {
            return generateTitleAsString(type2, tags2.title, tags2.titleAttributes, encode2);
          }
        };
      case ATTRIBUTE_NAMES.BODY:
      case ATTRIBUTE_NAMES.HTML:
        return {
          toComponent: function toComponent() {
            return convertElementAttributestoReactProps(tags2);
          },
          toString: function toString2() {
            return generateElementAttributesAsString(tags2);
          }
        };
      default:
        return {
          toComponent: function toComponent() {
            return generateTagsAsReactComponent(type2, tags2);
          },
          toString: function toString2() {
            return generateTagsAsString(type2, tags2, encode2);
          }
        };
    }
  };
  var mapStateOnServer = function mapStateOnServer2(_ref) {
    var baseTag = _ref.baseTag, bodyAttributes = _ref.bodyAttributes, encode2 = _ref.encode, htmlAttributes = _ref.htmlAttributes, linkTags = _ref.linkTags, metaTags = _ref.metaTags, noscriptTags = _ref.noscriptTags, scriptTags = _ref.scriptTags, styleTags = _ref.styleTags, _ref$title = _ref.title, title = _ref$title === void 0 ? "" : _ref$title, titleAttributes = _ref.titleAttributes;
    return {
      base: getMethodsForTag(TAG_NAMES.BASE, baseTag, encode2),
      bodyAttributes: getMethodsForTag(ATTRIBUTE_NAMES.BODY, bodyAttributes, encode2),
      htmlAttributes: getMethodsForTag(ATTRIBUTE_NAMES.HTML, htmlAttributes, encode2),
      link: getMethodsForTag(TAG_NAMES.LINK, linkTags, encode2),
      meta: getMethodsForTag(TAG_NAMES.META, metaTags, encode2),
      noscript: getMethodsForTag(TAG_NAMES.NOSCRIPT, noscriptTags, encode2),
      script: getMethodsForTag(TAG_NAMES.SCRIPT, scriptTags, encode2),
      style: getMethodsForTag(TAG_NAMES.STYLE, styleTags, encode2),
      title: getMethodsForTag(TAG_NAMES.TITLE, { title, titleAttributes }, encode2)
    };
  };
  var Helmet = function Helmet2(Component) {
    var _class2, _temp;
    return _temp = _class2 = function(_React$Component) {
      inherits(HelmetWrapper, _React$Component);
      function HelmetWrapper() {
        classCallCheck(this, HelmetWrapper);
        return possibleConstructorReturn(this, _React$Component.apply(this, arguments));
      }
      HelmetWrapper.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
        return !isEqual(this.props, nextProps);
      };
      HelmetWrapper.prototype.mapNestedChildrenToProps = function mapNestedChildrenToProps(child, nestedChildren) {
        if (!nestedChildren) {
          return null;
        }
        switch (child.type) {
          case TAG_NAMES.SCRIPT:
          case TAG_NAMES.NOSCRIPT:
            return {
              innerHTML: nestedChildren
            };
          case TAG_NAMES.STYLE:
            return {
              cssText: nestedChildren
            };
        }
        throw new Error("<" + child.type + " /> elements are self-closing and can not contain children. Refer to our API for more information.");
      };
      HelmetWrapper.prototype.flattenArrayTypeChildren = function flattenArrayTypeChildren(_ref) {
        var _babelHelpers$extends;
        var child = _ref.child, arrayTypeChildren = _ref.arrayTypeChildren, newChildProps = _ref.newChildProps, nestedChildren = _ref.nestedChildren;
        return _extends$1({}, arrayTypeChildren, (_babelHelpers$extends = {}, _babelHelpers$extends[child.type] = [].concat(arrayTypeChildren[child.type] || [], [_extends$1({}, newChildProps, this.mapNestedChildrenToProps(child, nestedChildren))]), _babelHelpers$extends));
      };
      HelmetWrapper.prototype.mapObjectTypeChildren = function mapObjectTypeChildren(_ref2) {
        var _babelHelpers$extends2, _babelHelpers$extends3;
        var child = _ref2.child, newProps = _ref2.newProps, newChildProps = _ref2.newChildProps, nestedChildren = _ref2.nestedChildren;
        switch (child.type) {
          case TAG_NAMES.TITLE:
            return _extends$1({}, newProps, (_babelHelpers$extends2 = {}, _babelHelpers$extends2[child.type] = nestedChildren, _babelHelpers$extends2.titleAttributes = _extends$1({}, newChildProps), _babelHelpers$extends2));
          case TAG_NAMES.BODY:
            return _extends$1({}, newProps, {
              bodyAttributes: _extends$1({}, newChildProps)
            });
          case TAG_NAMES.HTML:
            return _extends$1({}, newProps, {
              htmlAttributes: _extends$1({}, newChildProps)
            });
        }
        return _extends$1({}, newProps, (_babelHelpers$extends3 = {}, _babelHelpers$extends3[child.type] = _extends$1({}, newChildProps), _babelHelpers$extends3));
      };
      HelmetWrapper.prototype.mapArrayTypeChildrenToProps = function mapArrayTypeChildrenToProps(arrayTypeChildren, newProps) {
        var newFlattenedProps = _extends$1({}, newProps);
        Object.keys(arrayTypeChildren).forEach(function(arrayChildName) {
          var _babelHelpers$extends4;
          newFlattenedProps = _extends$1({}, newFlattenedProps, (_babelHelpers$extends4 = {}, _babelHelpers$extends4[arrayChildName] = arrayTypeChildren[arrayChildName], _babelHelpers$extends4));
        });
        return newFlattenedProps;
      };
      HelmetWrapper.prototype.warnOnInvalidChildren = function warnOnInvalidChildren(child, nestedChildren) {
        return true;
      };
      HelmetWrapper.prototype.mapChildrenToProps = function mapChildrenToProps(children, newProps) {
        var _this2 = this;
        var arrayTypeChildren = {};
        React$1.Children.forEach(children, function(child) {
          if (!child || !child.props) {
            return;
          }
          var _child$props = child.props, nestedChildren = _child$props.children, childProps = objectWithoutProperties(_child$props, ["children"]);
          var newChildProps = convertReactPropstoHtmlAttributes(childProps);
          _this2.warnOnInvalidChildren(child, nestedChildren);
          switch (child.type) {
            case TAG_NAMES.LINK:
            case TAG_NAMES.META:
            case TAG_NAMES.NOSCRIPT:
            case TAG_NAMES.SCRIPT:
            case TAG_NAMES.STYLE:
              arrayTypeChildren = _this2.flattenArrayTypeChildren({
                child,
                arrayTypeChildren,
                newChildProps,
                nestedChildren
              });
              break;
            default:
              newProps = _this2.mapObjectTypeChildren({
                child,
                newProps,
                newChildProps,
                nestedChildren
              });
              break;
          }
        });
        newProps = this.mapArrayTypeChildrenToProps(arrayTypeChildren, newProps);
        return newProps;
      };
      HelmetWrapper.prototype.render = function render() {
        var _props = this.props, children = _props.children, props = objectWithoutProperties(_props, ["children"]);
        var newProps = _extends$1({}, props);
        if (children) {
          newProps = this.mapChildrenToProps(children, newProps);
        }
        return React$1.createElement(Component, newProps);
      };
      createClass(HelmetWrapper, null, [{
        key: "canUseDOM",
        // Component.peek comes from react-side-effect:
        // For testing, you may use a static peek() method available on the returned component.
        // It lets you get the current state without resetting the mounted instance stack.
        // Dont use it for anything other than testing.
        /**
         * @param {Object} base: {"target": "_blank", "href": "http://mysite.com/"}
         * @param {Object} bodyAttributes: {"className": "root"}
         * @param {String} defaultTitle: "Default Title"
         * @param {Boolean} defer: true
         * @param {Boolean} encodeSpecialCharacters: true
         * @param {Object} htmlAttributes: {"lang": "en", "amp": undefined}
         * @param {Array} link: [{"rel": "canonical", "href": "http://mysite.com/example"}]
         * @param {Array} meta: [{"name": "description", "content": "Test description"}]
         * @param {Array} noscript: [{"innerHTML": "<img src='http://mysite.com/js/test.js'"}]
         * @param {Function} onChangeClientState: "(newState) => console.log(newState)"
         * @param {Array} script: [{"type": "text/javascript", "src": "http://mysite.com/js/test.js"}]
         * @param {Array} style: [{"type": "text/css", "cssText": "div { display: block; color: blue; }"}]
         * @param {String} title: "Title"
         * @param {Object} titleAttributes: {"itemprop": "name"}
         * @param {String} titleTemplate: "MySite.com - %s"
         */
        set: function set$$1(canUseDOM2) {
          Component.canUseDOM = canUseDOM2;
        }
      }]);
      return HelmetWrapper;
    }(React$1.Component), _class2.propTypes = {
      base: PropTypes.object,
      bodyAttributes: PropTypes.object,
      children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]),
      defaultTitle: PropTypes.string,
      defer: PropTypes.bool,
      encodeSpecialCharacters: PropTypes.bool,
      htmlAttributes: PropTypes.object,
      link: PropTypes.arrayOf(PropTypes.object),
      meta: PropTypes.arrayOf(PropTypes.object),
      noscript: PropTypes.arrayOf(PropTypes.object),
      onChangeClientState: PropTypes.func,
      script: PropTypes.arrayOf(PropTypes.object),
      style: PropTypes.arrayOf(PropTypes.object),
      title: PropTypes.string,
      titleAttributes: PropTypes.object,
      titleTemplate: PropTypes.string
    }, _class2.defaultProps = {
      defer: true,
      encodeSpecialCharacters: true
    }, _class2.peek = Component.peek, _class2.rewind = function() {
      var mappedState = Component.rewind();
      if (!mappedState) {
        mappedState = mapStateOnServer({
          baseTag: [],
          bodyAttributes: {},
          encodeSpecialCharacters: true,
          htmlAttributes: {},
          linkTags: [],
          metaTags: [],
          noscriptTags: [],
          scriptTags: [],
          styleTags: [],
          title: "",
          titleAttributes: {}
        });
      }
      return mappedState;
    }, _temp;
  };
  var NullComponent = function NullComponent2() {
    return null;
  };
  var HelmetSideEffects = withSideEffect$1(reducePropsToState, handleClientStateChange, mapStateOnServer)(NullComponent);
  var HelmetExport = Helmet(HelmetSideEffects);
  HelmetExport.renderStatic = HelmetExport.rewind;
  const APP_NAME = "Pioneer Template";
  const Meta = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(HelmetExport, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: APP_NAME }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { name: "description", content: "Pioneer Template" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { name: "application-name", content: APP_NAME }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { name: "apple-mobile-web-app-capable", content: "yes" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { name: "apple-mobile-web-app-status-bar-style", content: "default" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { name: "apple-mobile-web-app-title", content: APP_NAME }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { name: "format-detection", content: "telephone=no" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { name: "mobile-web-app-capable", content: "yes" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { name: "theme-color", content: "#228B22" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("link", { rel: "shortcut icon", href: "/assets/favicon.svg" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("link", { rel: "manifest", href: "/manifest.json" })
    ] });
  };
  const Layout = ({ children }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(HeaderNew, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Box, { margin: "0 auto", maxWidth: 800, transition: "0.5s ease-out", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Meta, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Flex, { wrap: "wrap", margin: "8", minHeight: "90vh", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.Box, { width: "full", as: "main", marginY: 22, children }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Footer, {})
        ] })
      ] })
    ] });
  };
  const RequireAuth = ({
    children,
    redirectTo = "/login"
  }) => {
    const isAuthenticated = true;
    return isAuthenticated ? children : /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: redirectTo });
  };
  const Page404 = () => {
    const navigate = useNavigate();
    const handleBackToHome = () => navigate("/");
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Grid, { gap: 4, textAlign: "center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(react.Heading, { children: "Page not Found" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Box, { maxWidth: [280, 400], marginX: "auto", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(react.Image, { width: 400, src: "/assets/404 Error-rafiki.svg" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(react.Link, { fontSize: "xs", href: "https://stories.freepik.com/web", isExternal: true, children: "Illustration by Freepik Stories" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Box, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(react.Text, { children: "It's Okay!" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(react.Button, { onClick: handleBackToHome, children: "Let's Head Back" })
      ] })
    ] });
  };
  const Home$1 = React$1.lazy(() => Promise.resolve().then(() => index));
  const routes = [
    {
      path: "/",
      element: /* @__PURE__ */ jsxRuntimeExports.jsx(Home$1, {})
    }
  ];
  const privateRoutes = [];
  const Routings = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(React$1.Suspense, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
      routes.map((routeProps) => /* @__PURE__ */ React$1.createElement(Route, { ...routeProps, key: routeProps.path })),
      privateRoutes.map(({ element, ...privateRouteProps }) => /* @__PURE__ */ React$1.createElement(
        Route,
        {
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(
            RequireAuth,
            {
              redirectTo: `/login?redirectTo=${privateRouteProps.path}`,
              children: element
            }
          ),
          ...privateRouteProps,
          key: `privateRoute-${privateRouteProps.path}`
        }
      )),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "*", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Page404, {}) })
    ] }) });
  };
  const ForceDarkMode = ({ children }) => {
    const { setColorMode } = react.useColorMode();
    React$1.useEffect(() => {
      setColorMode("dark");
    }, [setColorMode]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  };
  const App = () => /* @__PURE__ */ jsxRuntimeExports.jsx(PioneerProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(react.ChakraProvider, { theme, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ForceDarkMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Layout, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Routings, {}) }) }) }) }) });
  const root = client.createRoot(
    document.getElementById("root")
  );
  root.render(
    /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(react.ColorModeScript, { initialColorMode: (_a2 = theme.config) == null ? void 0 : _a2.initialColorMode }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(App, {})
    ] })
  );
  function useTheme() {
    const theme2 = React$1.useContext(
      react$1.ThemeContext
    );
    if (!theme2) {
      throw Error(
        "useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`"
      );
    }
    return theme2;
  }
  var ColorModeContext = React$1.createContext({});
  ColorModeContext.displayName = "ColorModeContext";
  function useColorMode() {
    const context2 = React$1.useContext(ColorModeContext);
    if (context2 === void 0) {
      throw new Error("useColorMode must be used within a ColorModeProvider");
    }
    return context2;
  }
  function useChakra() {
    const colorModeResult = useColorMode();
    const theme2 = useTheme();
    return { ...colorModeResult, theme: theme2 };
  }
  var cx = (...classNames) => classNames.filter(Boolean).join(" ");
  function isObject(value2) {
    const type2 = typeof value2;
    return value2 != null && (type2 === "object" || type2 === "function") && !Array.isArray(value2);
  }
  function runIfFn$1(valueOrFn, ...args) {
    return isFunction$1(valueOrFn) ? valueOrFn(...args) : valueOrFn;
  }
  var isFunction$1 = (value2) => typeof value2 === "function";
  var lodash_mergewith = { exports: {} };
  lodash_mergewith.exports;
  (function(module2, exports3) {
    var LARGE_ARRAY_SIZE2 = 200;
    var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    var argsTag2 = "[object Arguments]", arrayTag2 = "[object Array]", asyncTag2 = "[object AsyncFunction]", boolTag2 = "[object Boolean]", dateTag2 = "[object Date]", errorTag2 = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag2 = "[object Map]", numberTag2 = "[object Number]", nullTag2 = "[object Null]", objectTag2 = "[object Object]", proxyTag2 = "[object Proxy]", regexpTag2 = "[object RegExp]", setTag2 = "[object Set]", stringTag2 = "[object String]", undefinedTag2 = "[object Undefined]", weakMapTag2 = "[object WeakMap]";
    var arrayBufferTag2 = "[object ArrayBuffer]", dataViewTag2 = "[object DataView]", float32Tag2 = "[object Float32Array]", float64Tag2 = "[object Float64Array]", int8Tag2 = "[object Int8Array]", int16Tag2 = "[object Int16Array]", int32Tag2 = "[object Int32Array]", uint8Tag2 = "[object Uint8Array]", uint8ClampedTag2 = "[object Uint8ClampedArray]", uint16Tag2 = "[object Uint16Array]", uint32Tag2 = "[object Uint32Array]";
    var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
    var reIsUint2 = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags2 = {};
    typedArrayTags2[float32Tag2] = typedArrayTags2[float64Tag2] = typedArrayTags2[int8Tag2] = typedArrayTags2[int16Tag2] = typedArrayTags2[int32Tag2] = typedArrayTags2[uint8Tag2] = typedArrayTags2[uint8ClampedTag2] = typedArrayTags2[uint16Tag2] = typedArrayTags2[uint32Tag2] = true;
    typedArrayTags2[argsTag2] = typedArrayTags2[arrayTag2] = typedArrayTags2[arrayBufferTag2] = typedArrayTags2[boolTag2] = typedArrayTags2[dataViewTag2] = typedArrayTags2[dateTag2] = typedArrayTags2[errorTag2] = typedArrayTags2[funcTag2] = typedArrayTags2[mapTag2] = typedArrayTags2[numberTag2] = typedArrayTags2[objectTag2] = typedArrayTags2[regexpTag2] = typedArrayTags2[setTag2] = typedArrayTags2[stringTag2] = typedArrayTags2[weakMapTag2] = false;
    var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
    var freeExports = exports3 && !exports3.nodeType && exports3;
    var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal2.process;
    var nodeUtil2 = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray2 = nodeUtil2 && nodeUtil2.isTypedArray;
    function apply2(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes2(n2, iteratee) {
      var index2 = -1, result = Array(n2);
      while (++index2 < n2) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseUnary2(func) {
      return function(value2) {
        return func(value2);
      };
    }
    function getValue2(object, key) {
      return object == null ? void 0 : object[key];
    }
    function overArg2(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    var arrayProto2 = Array.prototype, funcProto2 = Function.prototype, objectProto2 = Object.prototype;
    var coreJsData2 = root2["__core-js_shared__"];
    var funcToString2 = funcProto2.toString;
    var hasOwnProperty2 = objectProto2.hasOwnProperty;
    var maskSrcKey2 = function() {
      var uid2 = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    var nativeObjectToString2 = objectProto2.toString;
    var objectCtorString = funcToString2.call(Object);
    var reIsNative2 = RegExp(
      "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array2 = root2.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0, getPrototype = overArg2(Object.getPrototypeOf, Object), objectCreate2 = Object.create, propertyIsEnumerable2 = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice, symToStringTag2 = Symbol2 ? Symbol2.toStringTag : void 0;
    var defineProperty2 = function() {
      try {
        var func = getNative2(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeMax = Math.max, nativeNow = Date.now;
    var Map2 = getNative2(root2, "Map"), nativeCreate2 = getNative2(Object, "create");
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject2(proto)) {
          return {};
        }
        if (objectCreate2) {
          return objectCreate2(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function Hash2(entries) {
      var index2 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear2() {
      this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
      this.size = 0;
    }
    function hashDelete2(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet2(key) {
      var data2 = this.__data__;
      if (nativeCreate2) {
        var result = data2[key];
        return result === HASH_UNDEFINED2 ? void 0 : result;
      }
      return hasOwnProperty2.call(data2, key) ? data2[key] : void 0;
    }
    function hashHas2(key) {
      var data2 = this.__data__;
      return nativeCreate2 ? data2[key] !== void 0 : hasOwnProperty2.call(data2, key);
    }
    function hashSet2(key, value2) {
      var data2 = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data2[key] = nativeCreate2 && value2 === void 0 ? HASH_UNDEFINED2 : value2;
      return this;
    }
    Hash2.prototype.clear = hashClear2;
    Hash2.prototype["delete"] = hashDelete2;
    Hash2.prototype.get = hashGet2;
    Hash2.prototype.has = hashHas2;
    Hash2.prototype.set = hashSet2;
    function ListCache2(entries) {
      var index2 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear2() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete2(key) {
      var data2 = this.__data__, index2 = assocIndexOf2(data2, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data2.length - 1;
      if (index2 == lastIndex) {
        data2.pop();
      } else {
        splice2.call(data2, index2, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet2(key) {
      var data2 = this.__data__, index2 = assocIndexOf2(data2, key);
      return index2 < 0 ? void 0 : data2[index2][1];
    }
    function listCacheHas2(key) {
      return assocIndexOf2(this.__data__, key) > -1;
    }
    function listCacheSet2(key, value2) {
      var data2 = this.__data__, index2 = assocIndexOf2(data2, key);
      if (index2 < 0) {
        ++this.size;
        data2.push([key, value2]);
      } else {
        data2[index2][1] = value2;
      }
      return this;
    }
    ListCache2.prototype.clear = listCacheClear2;
    ListCache2.prototype["delete"] = listCacheDelete2;
    ListCache2.prototype.get = listCacheGet2;
    ListCache2.prototype.has = listCacheHas2;
    ListCache2.prototype.set = listCacheSet2;
    function MapCache2(entries) {
      var index2 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear2() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash2(),
        "map": new (Map2 || ListCache2)(),
        "string": new Hash2()
      };
    }
    function mapCacheDelete2(key) {
      var result = getMapData2(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet2(key) {
      return getMapData2(this, key).get(key);
    }
    function mapCacheHas2(key) {
      return getMapData2(this, key).has(key);
    }
    function mapCacheSet2(key, value2) {
      var data2 = getMapData2(this, key), size = data2.size;
      data2.set(key, value2);
      this.size += data2.size == size ? 0 : 1;
      return this;
    }
    MapCache2.prototype.clear = mapCacheClear2;
    MapCache2.prototype["delete"] = mapCacheDelete2;
    MapCache2.prototype.get = mapCacheGet2;
    MapCache2.prototype.has = mapCacheHas2;
    MapCache2.prototype.set = mapCacheSet2;
    function Stack2(entries) {
      var data2 = this.__data__ = new ListCache2(entries);
      this.size = data2.size;
    }
    function stackClear2() {
      this.__data__ = new ListCache2();
      this.size = 0;
    }
    function stackDelete2(key) {
      var data2 = this.__data__, result = data2["delete"](key);
      this.size = data2.size;
      return result;
    }
    function stackGet2(key) {
      return this.__data__.get(key);
    }
    function stackHas2(key) {
      return this.__data__.has(key);
    }
    function stackSet2(key, value2) {
      var data2 = this.__data__;
      if (data2 instanceof ListCache2) {
        var pairs2 = data2.__data__;
        if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE2 - 1) {
          pairs2.push([key, value2]);
          this.size = ++data2.size;
          return this;
        }
        data2 = this.__data__ = new MapCache2(pairs2);
      }
      data2.set(key, value2);
      this.size = data2.size;
      return this;
    }
    Stack2.prototype.clear = stackClear2;
    Stack2.prototype["delete"] = stackDelete2;
    Stack2.prototype.get = stackGet2;
    Stack2.prototype.has = stackHas2;
    Stack2.prototype.set = stackSet2;
    function arrayLikeKeys2(value2, inherited) {
      var isArr = isArray2(value2), isArg = !isArr && isArguments2(value2), isBuff = !isArr && !isArg && isBuffer2(value2), isType = !isArr && !isArg && !isBuff && isTypedArray2(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes2(value2.length, String) : [], length2 = result.length;
      for (var key in value2) {
        if ((inherited || hasOwnProperty2.call(value2, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex2(key, length2)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignMergeValue(object, key, value2) {
      if (value2 !== void 0 && !eq2(object[key], value2) || value2 === void 0 && !(key in object)) {
        baseAssignValue(object, key, value2);
      }
    }
    function assignValue(object, key, value2) {
      var objValue = object[key];
      if (!(hasOwnProperty2.call(object, key) && eq2(objValue, value2)) || value2 === void 0 && !(key in object)) {
        baseAssignValue(object, key, value2);
      }
    }
    function assocIndexOf2(array, key) {
      var length2 = array.length;
      while (length2--) {
        if (eq2(array[length2][0], key)) {
          return length2;
        }
      }
      return -1;
    }
    function baseAssignValue(object, key, value2) {
      if (key == "__proto__" && defineProperty2) {
        defineProperty2(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value2,
          "writable": true
        });
      } else {
        object[key] = value2;
      }
    }
    var baseFor = createBaseFor();
    function baseGetTag2(value2) {
      if (value2 == null) {
        return value2 === void 0 ? undefinedTag2 : nullTag2;
      }
      return symToStringTag2 && symToStringTag2 in Object(value2) ? getRawTag2(value2) : objectToString2(value2);
    }
    function baseIsArguments2(value2) {
      return isObjectLike2(value2) && baseGetTag2(value2) == argsTag2;
    }
    function baseIsNative2(value2) {
      if (!isObject2(value2) || isMasked2(value2)) {
        return false;
      }
      var pattern = isFunction2(value2) ? reIsNative2 : reIsHostCtor2;
      return pattern.test(toSource2(value2));
    }
    function baseIsTypedArray2(value2) {
      return isObjectLike2(value2) && isLength2(value2.length) && !!typedArrayTags2[baseGetTag2(value2)];
    }
    function baseKeysIn(object) {
      if (!isObject2(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype2(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack2());
        if (isObject2(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray2(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject2(srcValue) || isArguments2(srcValue)) {
          newValue = objValue;
          if (isArguments2(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject2(objValue) || isFunction2(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity2), func + "");
    }
    var baseSetToString = !defineProperty2 ? identity2 : function(func, string) {
      return defineProperty2(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    function cloneBuffer(buffer2, isDeep) {
      if (isDeep) {
        return buffer2.slice();
      }
      var length2 = buffer2.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer2.constructor(length2);
      buffer2.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index2 = -1, length2 = source.length;
      array || (array = Array(length2));
      while (++index2 < length2) {
        array[index2] = source[index2];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index2 = -1, length2 = props.length;
      while (++index2 < length2) {
        var key = props[index2];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard = length2 > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length2 < 3 ? void 0 : customizer;
          length2 = 1;
        }
        object = Object(object);
        while (++index2 < length2) {
          var source = sources[index2];
          if (source) {
            assigner(object, source, index2, customizer);
          }
        }
        return object;
      });
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index2 = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
        while (length2--) {
          var key = props[fromRight ? length2 : ++index2];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function getMapData2(map2, key) {
      var data2 = map2.__data__;
      return isKeyable2(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
    }
    function getNative2(object, key) {
      var value2 = getValue2(object, key);
      return baseIsNative2(value2) ? value2 : void 0;
    }
    function getRawTag2(value2) {
      var isOwn = hasOwnProperty2.call(value2, symToStringTag2), tag = value2[symToStringTag2];
      try {
        value2[symToStringTag2] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString2.call(value2);
      if (unmasked) {
        if (isOwn) {
          value2[symToStringTag2] = tag;
        } else {
          delete value2[symToStringTag2];
        }
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate(getPrototype(object)) : {};
    }
    function isIndex2(value2, length2) {
      var type2 = typeof value2;
      length2 = length2 == null ? MAX_SAFE_INTEGER2 : length2;
      return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint2.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length2);
    }
    function isIterateeCall(value2, index2, object) {
      if (!isObject2(object)) {
        return false;
      }
      var type2 = typeof index2;
      if (type2 == "number" ? isArrayLike2(object) && isIndex2(index2, object.length) : type2 == "string" && index2 in object) {
        return eq2(object[index2], value2);
      }
      return false;
    }
    function isKeyable2(value2) {
      var type2 = typeof value2;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value2 !== "__proto__" : value2 === null;
    }
    function isMasked2(func) {
      return !!maskSrcKey2 && maskSrcKey2 in func;
    }
    function isPrototype2(value2) {
      var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
      return value2 === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function objectToString2(value2) {
      return nativeObjectToString2.call(value2);
    }
    function overRest(func, start, transform2) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index2 = -1, length2 = nativeMax(args.length - start, 0), array = Array(length2);
        while (++index2 < length2) {
          array[index2] = args[start + index2];
        }
        index2 = -1;
        var otherArgs = Array(start + 1);
        while (++index2 < start) {
          otherArgs[index2] = args[index2];
        }
        otherArgs[start] = transform2(array);
        return apply2(func, this, otherArgs);
      };
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    var setToString = shortOut(baseSetToString);
    function shortOut(func) {
      var count2 = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count2 >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count2 = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function toSource2(func) {
      if (func != null) {
        try {
          return funcToString2.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq2(value2, other) {
      return value2 === other || value2 !== value2 && other !== other;
    }
    var isArguments2 = baseIsArguments2(function() {
      return arguments;
    }()) ? baseIsArguments2 : function(value2) {
      return isObjectLike2(value2) && hasOwnProperty2.call(value2, "callee") && !propertyIsEnumerable2.call(value2, "callee");
    };
    var isArray2 = Array.isArray;
    function isArrayLike2(value2) {
      return value2 != null && isLength2(value2.length) && !isFunction2(value2);
    }
    function isArrayLikeObject(value2) {
      return isObjectLike2(value2) && isArrayLike2(value2);
    }
    var isBuffer2 = nativeIsBuffer || stubFalse2;
    function isFunction2(value2) {
      if (!isObject2(value2)) {
        return false;
      }
      var tag = baseGetTag2(value2);
      return tag == funcTag2 || tag == genTag2 || tag == asyncTag2 || tag == proxyTag2;
    }
    function isLength2(value2) {
      return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER2;
    }
    function isObject2(value2) {
      var type2 = typeof value2;
      return value2 != null && (type2 == "object" || type2 == "function");
    }
    function isObjectLike2(value2) {
      return value2 != null && typeof value2 == "object";
    }
    function isPlainObject2(value2) {
      if (!isObjectLike2(value2) || baseGetTag2(value2) != objectTag2) {
        return false;
      }
      var proto = getPrototype(value2);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString;
    }
    var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
    function toPlainObject(value2) {
      return copyObject(value2, keysIn(value2));
    }
    function keysIn(object) {
      return isArrayLike2(object) ? arrayLikeKeys2(object, true) : baseKeysIn(object);
    }
    var mergeWith2 = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });
    function constant(value2) {
      return function() {
        return value2;
      };
    }
    function identity2(value2) {
      return value2;
    }
    function stubFalse2() {
      return false;
    }
    module2.exports = mergeWith2;
  })(lodash_mergewith, lodash_mergewith.exports);
  var lodash_mergewithExports = lodash_mergewith.exports;
  const mergeWith = /* @__PURE__ */ getDefaultExportFromCjs(lodash_mergewithExports);
  var isImportant = (value2) => /!(important)?$/.test(value2);
  var withoutImportant = (value2) => typeof value2 === "string" ? value2.replace(/!(important)?$/, "").trim() : value2;
  var tokenToCSSVar = (scale, value2) => (theme2) => {
    const valueStr = String(value2);
    const important = isImportant(valueStr);
    const valueWithoutImportant = withoutImportant(valueStr);
    const key = scale ? `${scale}.${valueWithoutImportant}` : valueWithoutImportant;
    let transformed = isObject(theme2.__cssMap) && key in theme2.__cssMap ? theme2.__cssMap[key].varRef : value2;
    transformed = withoutImportant(transformed);
    return important ? `${transformed} !important` : transformed;
  };
  function createTransform(options) {
    const { scale, transform: transform2, compose: compose2 } = options;
    const fn = (value2, theme2) => {
      var _a3;
      const _value = tokenToCSSVar(scale, value2)(theme2);
      let result = (_a3 = transform2 == null ? void 0 : transform2(_value, theme2)) != null ? _a3 : _value;
      if (compose2) {
        result = compose2(result, theme2);
      }
      return result;
    };
    return fn;
  }
  var pipe = (...fns) => (v) => fns.reduce((a, b) => b(a), v);
  function toConfig(scale, transform2) {
    return (property) => {
      const result = { property, scale };
      result.transform = createTransform({
        scale,
        transform: transform2
      });
      return result;
    };
  }
  var getRtl = ({ rtl, ltr }) => (theme2) => theme2.direction === "rtl" ? rtl : ltr;
  function logical(options) {
    const { property, scale, transform: transform2 } = options;
    return {
      scale,
      property: getRtl(property),
      transform: scale ? createTransform({
        scale,
        compose: transform2
      }) : transform2
    };
  }
  var transformTemplate = [
    "rotate(var(--chakra-rotate, 0))",
    "scaleX(var(--chakra-scale-x, 1))",
    "scaleY(var(--chakra-scale-y, 1))",
    "skewX(var(--chakra-skew-x, 0))",
    "skewY(var(--chakra-skew-y, 0))"
  ];
  function getTransformTemplate() {
    return [
      "translateX(var(--chakra-translate-x, 0))",
      "translateY(var(--chakra-translate-y, 0))",
      ...transformTemplate
    ].join(" ");
  }
  function getTransformGpuTemplate() {
    return [
      "translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)",
      ...transformTemplate
    ].join(" ");
  }
  var filterTemplate = {
    "--chakra-blur": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-invert": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-sepia": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-drop-shadow": "var(--chakra-empty,/*!*/ /*!*/)",
    filter: [
      "var(--chakra-blur)",
      "var(--chakra-brightness)",
      "var(--chakra-contrast)",
      "var(--chakra-grayscale)",
      "var(--chakra-hue-rotate)",
      "var(--chakra-invert)",
      "var(--chakra-saturate)",
      "var(--chakra-sepia)",
      "var(--chakra-drop-shadow)"
    ].join(" ")
  };
  var backdropFilterTemplate = {
    backdropFilter: [
      "var(--chakra-backdrop-blur)",
      "var(--chakra-backdrop-brightness)",
      "var(--chakra-backdrop-contrast)",
      "var(--chakra-backdrop-grayscale)",
      "var(--chakra-backdrop-hue-rotate)",
      "var(--chakra-backdrop-invert)",
      "var(--chakra-backdrop-opacity)",
      "var(--chakra-backdrop-saturate)",
      "var(--chakra-backdrop-sepia)"
    ].join(" "),
    "--chakra-backdrop-blur": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-invert": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-opacity": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-backdrop-sepia": "var(--chakra-empty,/*!*/ /*!*/)"
  };
  function getRingTemplate(value2) {
    return {
      "--chakra-ring-offset-shadow": `var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)`,
      "--chakra-ring-shadow": `var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)`,
      "--chakra-ring-width": value2,
      boxShadow: [
        `var(--chakra-ring-offset-shadow)`,
        `var(--chakra-ring-shadow)`,
        `var(--chakra-shadow, 0 0 #0000)`
      ].join(", ")
    };
  }
  var flexDirectionTemplate = {
    "row-reverse": {
      space: "--chakra-space-x-reverse",
      divide: "--chakra-divide-x-reverse"
    },
    "column-reverse": {
      space: "--chakra-space-y-reverse",
      divide: "--chakra-divide-y-reverse"
    }
  };
  var directionMap = {
    "to-t": "to top",
    "to-tr": "to top right",
    "to-r": "to right",
    "to-br": "to bottom right",
    "to-b": "to bottom",
    "to-bl": "to bottom left",
    "to-l": "to left",
    "to-tl": "to top left"
  };
  var valueSet = new Set(Object.values(directionMap));
  var globalSet = /* @__PURE__ */ new Set([
    "none",
    "-moz-initial",
    "inherit",
    "initial",
    "revert",
    "unset"
  ]);
  var trimSpace = (str2) => str2.trim();
  function parseGradient(value2, theme2) {
    if (value2 == null || globalSet.has(value2))
      return value2;
    const prevent = isCSSFunction(value2) || globalSet.has(value2);
    if (!prevent)
      return `url('${value2}')`;
    const regex = /(^[a-z-A-Z]+)\((.*)\)/g;
    const results = regex.exec(value2);
    const type2 = results == null ? void 0 : results[1];
    const values2 = results == null ? void 0 : results[2];
    if (!type2 || !values2)
      return value2;
    const _type = type2.includes("-gradient") ? type2 : `${type2}-gradient`;
    const [maybeDirection, ...stops] = values2.split(",").map(trimSpace).filter(Boolean);
    if ((stops == null ? void 0 : stops.length) === 0)
      return value2;
    const direction = maybeDirection in directionMap ? directionMap[maybeDirection] : maybeDirection;
    stops.unshift(direction);
    const _values = stops.map((stop) => {
      if (valueSet.has(stop))
        return stop;
      const firstStop = stop.indexOf(" ");
      const [_color, _stop] = firstStop !== -1 ? [stop.substr(0, firstStop), stop.substr(firstStop + 1)] : [stop];
      const _stopOrFunc = isCSSFunction(_stop) ? _stop : _stop && _stop.split(" ");
      const key = `colors.${_color}`;
      const color2 = key in theme2.__cssMap ? theme2.__cssMap[key].varRef : _color;
      return _stopOrFunc ? [
        color2,
        ...Array.isArray(_stopOrFunc) ? _stopOrFunc : [_stopOrFunc]
      ].join(" ") : color2;
    });
    return `${_type}(${_values.join(", ")})`;
  }
  var isCSSFunction = (value2) => {
    return typeof value2 === "string" && value2.includes("(") && value2.includes(")");
  };
  var gradientTransform = (value2, theme2) => parseGradient(value2, theme2 != null ? theme2 : {});
  function isCssVar(value2) {
    return /^var\(--.+\)$/.test(value2);
  }
  var analyzeCSSValue = (value2) => {
    const num = parseFloat(value2.toString());
    const unit = value2.toString().replace(String(num), "");
    return { unitless: !unit, value: num, unit };
  };
  var wrap = (str2) => (value2) => `${str2}(${value2})`;
  var transformFunctions = {
    filter(value2) {
      return value2 !== "auto" ? value2 : filterTemplate;
    },
    backdropFilter(value2) {
      return value2 !== "auto" ? value2 : backdropFilterTemplate;
    },
    ring(value2) {
      return getRingTemplate(transformFunctions.px(value2));
    },
    bgClip(value2) {
      return value2 === "text" ? { color: "transparent", backgroundClip: "text" } : { backgroundClip: value2 };
    },
    transform(value2) {
      if (value2 === "auto")
        return getTransformTemplate();
      if (value2 === "auto-gpu")
        return getTransformGpuTemplate();
      return value2;
    },
    vh(value2) {
      return value2 === "$100vh" ? "var(--chakra-vh)" : value2;
    },
    px(value2) {
      if (value2 == null)
        return value2;
      const { unitless } = analyzeCSSValue(value2);
      return unitless || typeof value2 === "number" ? `${value2}px` : value2;
    },
    fraction(value2) {
      return !(typeof value2 === "number") || value2 > 1 ? value2 : `${value2 * 100}%`;
    },
    float(value2, theme2) {
      const map2 = { left: "right", right: "left" };
      return theme2.direction === "rtl" ? map2[value2] : value2;
    },
    degree(value2) {
      if (isCssVar(value2) || value2 == null)
        return value2;
      const unitless = typeof value2 === "string" && !value2.endsWith("deg");
      return typeof value2 === "number" || unitless ? `${value2}deg` : value2;
    },
    gradient: gradientTransform,
    blur: wrap("blur"),
    opacity: wrap("opacity"),
    brightness: wrap("brightness"),
    contrast: wrap("contrast"),
    dropShadow: wrap("drop-shadow"),
    grayscale: wrap("grayscale"),
    hueRotate: wrap("hue-rotate"),
    invert: wrap("invert"),
    saturate: wrap("saturate"),
    sepia: wrap("sepia"),
    bgImage(value2) {
      if (value2 == null)
        return value2;
      const prevent = isCSSFunction(value2) || globalSet.has(value2);
      return !prevent ? `url(${value2})` : value2;
    },
    outline(value2) {
      const isNoneOrZero = String(value2) === "0" || String(value2) === "none";
      return value2 !== null && isNoneOrZero ? { outline: "2px solid transparent", outlineOffset: "2px" } : { outline: value2 };
    },
    flexDirection(value2) {
      var _a3;
      const { space: space2, divide: divide2 } = (_a3 = flexDirectionTemplate[value2]) != null ? _a3 : {};
      const result = { flexDirection: value2 };
      if (space2)
        result[space2] = 1;
      if (divide2)
        result[divide2] = 1;
      return result;
    }
  };
  var t = {
    borderWidths: toConfig("borderWidths"),
    borderStyles: toConfig("borderStyles"),
    colors: toConfig("colors"),
    borders: toConfig("borders"),
    gradients: toConfig("gradients", transformFunctions.gradient),
    radii: toConfig("radii", transformFunctions.px),
    space: toConfig("space", pipe(transformFunctions.vh, transformFunctions.px)),
    spaceT: toConfig("space", pipe(transformFunctions.vh, transformFunctions.px)),
    degreeT(property) {
      return { property, transform: transformFunctions.degree };
    },
    prop(property, scale, transform2) {
      return {
        property,
        scale,
        ...scale && {
          transform: createTransform({ scale, transform: transform2 })
        }
      };
    },
    propT(property, transform2) {
      return { property, transform: transform2 };
    },
    sizes: toConfig("sizes", pipe(transformFunctions.vh, transformFunctions.px)),
    sizesT: toConfig("sizes", pipe(transformFunctions.vh, transformFunctions.fraction)),
    shadows: toConfig("shadows"),
    logical,
    blur: toConfig("blur", transformFunctions.blur)
  };
  var background = {
    background: t.colors("background"),
    backgroundColor: t.colors("backgroundColor"),
    backgroundImage: t.gradients("backgroundImage"),
    backgroundSize: true,
    backgroundPosition: true,
    backgroundRepeat: true,
    backgroundAttachment: true,
    backgroundClip: { transform: transformFunctions.bgClip },
    bgSize: t.prop("backgroundSize"),
    bgPosition: t.prop("backgroundPosition"),
    bg: t.colors("background"),
    bgColor: t.colors("backgroundColor"),
    bgPos: t.prop("backgroundPosition"),
    bgRepeat: t.prop("backgroundRepeat"),
    bgAttachment: t.prop("backgroundAttachment"),
    bgGradient: t.gradients("backgroundImage"),
    bgClip: { transform: transformFunctions.bgClip }
  };
  Object.assign(background, {
    bgImage: background.backgroundImage,
    bgImg: background.backgroundImage
  });
  var border = {
    border: t.borders("border"),
    borderWidth: t.borderWidths("borderWidth"),
    borderStyle: t.borderStyles("borderStyle"),
    borderColor: t.colors("borderColor"),
    borderRadius: t.radii("borderRadius"),
    borderTop: t.borders("borderTop"),
    borderBlockStart: t.borders("borderBlockStart"),
    borderTopLeftRadius: t.radii("borderTopLeftRadius"),
    borderStartStartRadius: t.logical({
      scale: "radii",
      property: {
        ltr: "borderTopLeftRadius",
        rtl: "borderTopRightRadius"
      }
    }),
    borderEndStartRadius: t.logical({
      scale: "radii",
      property: {
        ltr: "borderBottomLeftRadius",
        rtl: "borderBottomRightRadius"
      }
    }),
    borderTopRightRadius: t.radii("borderTopRightRadius"),
    borderStartEndRadius: t.logical({
      scale: "radii",
      property: {
        ltr: "borderTopRightRadius",
        rtl: "borderTopLeftRadius"
      }
    }),
    borderEndEndRadius: t.logical({
      scale: "radii",
      property: {
        ltr: "borderBottomRightRadius",
        rtl: "borderBottomLeftRadius"
      }
    }),
    borderRight: t.borders("borderRight"),
    borderInlineEnd: t.borders("borderInlineEnd"),
    borderBottom: t.borders("borderBottom"),
    borderBlockEnd: t.borders("borderBlockEnd"),
    borderBottomLeftRadius: t.radii("borderBottomLeftRadius"),
    borderBottomRightRadius: t.radii("borderBottomRightRadius"),
    borderLeft: t.borders("borderLeft"),
    borderInlineStart: {
      property: "borderInlineStart",
      scale: "borders"
    },
    borderInlineStartRadius: t.logical({
      scale: "radii",
      property: {
        ltr: ["borderTopLeftRadius", "borderBottomLeftRadius"],
        rtl: ["borderTopRightRadius", "borderBottomRightRadius"]
      }
    }),
    borderInlineEndRadius: t.logical({
      scale: "radii",
      property: {
        ltr: ["borderTopRightRadius", "borderBottomRightRadius"],
        rtl: ["borderTopLeftRadius", "borderBottomLeftRadius"]
      }
    }),
    borderX: t.borders(["borderLeft", "borderRight"]),
    borderInline: t.borders("borderInline"),
    borderY: t.borders(["borderTop", "borderBottom"]),
    borderBlock: t.borders("borderBlock"),
    borderTopWidth: t.borderWidths("borderTopWidth"),
    borderBlockStartWidth: t.borderWidths("borderBlockStartWidth"),
    borderTopColor: t.colors("borderTopColor"),
    borderBlockStartColor: t.colors("borderBlockStartColor"),
    borderTopStyle: t.borderStyles("borderTopStyle"),
    borderBlockStartStyle: t.borderStyles("borderBlockStartStyle"),
    borderBottomWidth: t.borderWidths("borderBottomWidth"),
    borderBlockEndWidth: t.borderWidths("borderBlockEndWidth"),
    borderBottomColor: t.colors("borderBottomColor"),
    borderBlockEndColor: t.colors("borderBlockEndColor"),
    borderBottomStyle: t.borderStyles("borderBottomStyle"),
    borderBlockEndStyle: t.borderStyles("borderBlockEndStyle"),
    borderLeftWidth: t.borderWidths("borderLeftWidth"),
    borderInlineStartWidth: t.borderWidths("borderInlineStartWidth"),
    borderLeftColor: t.colors("borderLeftColor"),
    borderInlineStartColor: t.colors("borderInlineStartColor"),
    borderLeftStyle: t.borderStyles("borderLeftStyle"),
    borderInlineStartStyle: t.borderStyles("borderInlineStartStyle"),
    borderRightWidth: t.borderWidths("borderRightWidth"),
    borderInlineEndWidth: t.borderWidths("borderInlineEndWidth"),
    borderRightColor: t.colors("borderRightColor"),
    borderInlineEndColor: t.colors("borderInlineEndColor"),
    borderRightStyle: t.borderStyles("borderRightStyle"),
    borderInlineEndStyle: t.borderStyles("borderInlineEndStyle"),
    borderTopRadius: t.radii(["borderTopLeftRadius", "borderTopRightRadius"]),
    borderBottomRadius: t.radii([
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]),
    borderLeftRadius: t.radii(["borderTopLeftRadius", "borderBottomLeftRadius"]),
    borderRightRadius: t.radii([
      "borderTopRightRadius",
      "borderBottomRightRadius"
    ])
  };
  Object.assign(border, {
    rounded: border.borderRadius,
    roundedTop: border.borderTopRadius,
    roundedTopLeft: border.borderTopLeftRadius,
    roundedTopRight: border.borderTopRightRadius,
    roundedTopStart: border.borderStartStartRadius,
    roundedTopEnd: border.borderStartEndRadius,
    roundedBottom: border.borderBottomRadius,
    roundedBottomLeft: border.borderBottomLeftRadius,
    roundedBottomRight: border.borderBottomRightRadius,
    roundedBottomStart: border.borderEndStartRadius,
    roundedBottomEnd: border.borderEndEndRadius,
    roundedLeft: border.borderLeftRadius,
    roundedRight: border.borderRightRadius,
    roundedStart: border.borderInlineStartRadius,
    roundedEnd: border.borderInlineEndRadius,
    borderStart: border.borderInlineStart,
    borderEnd: border.borderInlineEnd,
    borderTopStartRadius: border.borderStartStartRadius,
    borderTopEndRadius: border.borderStartEndRadius,
    borderBottomStartRadius: border.borderEndStartRadius,
    borderBottomEndRadius: border.borderEndEndRadius,
    borderStartRadius: border.borderInlineStartRadius,
    borderEndRadius: border.borderInlineEndRadius,
    borderStartWidth: border.borderInlineStartWidth,
    borderEndWidth: border.borderInlineEndWidth,
    borderStartColor: border.borderInlineStartColor,
    borderEndColor: border.borderInlineEndColor,
    borderStartStyle: border.borderInlineStartStyle,
    borderEndStyle: border.borderInlineEndStyle
  });
  var color = {
    color: t.colors("color"),
    textColor: t.colors("color"),
    fill: t.colors("fill"),
    stroke: t.colors("stroke")
  };
  var effect = {
    boxShadow: t.shadows("boxShadow"),
    mixBlendMode: true,
    blendMode: t.prop("mixBlendMode"),
    backgroundBlendMode: true,
    bgBlendMode: t.prop("backgroundBlendMode"),
    opacity: true
  };
  Object.assign(effect, {
    shadow: effect.boxShadow
  });
  var filter = {
    filter: { transform: transformFunctions.filter },
    blur: t.blur("--chakra-blur"),
    brightness: t.propT("--chakra-brightness", transformFunctions.brightness),
    contrast: t.propT("--chakra-contrast", transformFunctions.contrast),
    hueRotate: t.degreeT("--chakra-hue-rotate"),
    invert: t.propT("--chakra-invert", transformFunctions.invert),
    saturate: t.propT("--chakra-saturate", transformFunctions.saturate),
    dropShadow: t.propT("--chakra-drop-shadow", transformFunctions.dropShadow),
    backdropFilter: { transform: transformFunctions.backdropFilter },
    backdropBlur: t.blur("--chakra-backdrop-blur"),
    backdropBrightness: t.propT(
      "--chakra-backdrop-brightness",
      transformFunctions.brightness
    ),
    backdropContrast: t.propT("--chakra-backdrop-contrast", transformFunctions.contrast),
    backdropHueRotate: t.degreeT("--chakra-backdrop-hue-rotate"),
    backdropInvert: t.propT("--chakra-backdrop-invert", transformFunctions.invert),
    backdropSaturate: t.propT("--chakra-backdrop-saturate", transformFunctions.saturate)
  };
  var flexbox = {
    alignItems: true,
    alignContent: true,
    justifyItems: true,
    justifyContent: true,
    flexWrap: true,
    flexDirection: { transform: transformFunctions.flexDirection },
    flex: true,
    flexFlow: true,
    flexGrow: true,
    flexShrink: true,
    flexBasis: t.sizes("flexBasis"),
    justifySelf: true,
    alignSelf: true,
    order: true,
    placeItems: true,
    placeContent: true,
    placeSelf: true,
    gap: t.space("gap"),
    rowGap: t.space("rowGap"),
    columnGap: t.space("columnGap")
  };
  Object.assign(flexbox, {
    flexDir: flexbox.flexDirection
  });
  var grid = {
    gridGap: t.space("gridGap"),
    gridColumnGap: t.space("gridColumnGap"),
    gridRowGap: t.space("gridRowGap"),
    gridColumn: true,
    gridRow: true,
    gridAutoFlow: true,
    gridAutoColumns: true,
    gridColumnStart: true,
    gridColumnEnd: true,
    gridRowStart: true,
    gridRowEnd: true,
    gridAutoRows: true,
    gridTemplate: true,
    gridTemplateColumns: true,
    gridTemplateRows: true,
    gridTemplateAreas: true,
    gridArea: true
  };
  var interactivity = {
    appearance: true,
    cursor: true,
    resize: true,
    userSelect: true,
    pointerEvents: true,
    outline: { transform: transformFunctions.outline },
    outlineOffset: true,
    outlineColor: t.colors("outlineColor")
  };
  var layout = {
    width: t.sizesT("width"),
    inlineSize: t.sizesT("inlineSize"),
    height: t.sizes("height"),
    blockSize: t.sizes("blockSize"),
    boxSize: t.sizes(["width", "height"]),
    minWidth: t.sizes("minWidth"),
    minInlineSize: t.sizes("minInlineSize"),
    minHeight: t.sizes("minHeight"),
    minBlockSize: t.sizes("minBlockSize"),
    maxWidth: t.sizes("maxWidth"),
    maxInlineSize: t.sizes("maxInlineSize"),
    maxHeight: t.sizes("maxHeight"),
    maxBlockSize: t.sizes("maxBlockSize"),
    overflow: true,
    overflowX: true,
    overflowY: true,
    overscrollBehavior: true,
    overscrollBehaviorX: true,
    overscrollBehaviorY: true,
    display: true,
    aspectRatio: true,
    hideFrom: {
      scale: "breakpoints",
      transform: (value2, theme2) => {
        var _a3, _b, _c;
        const breakpoint = (_c = (_b = (_a3 = theme2.__breakpoints) == null ? void 0 : _a3.get(value2)) == null ? void 0 : _b.minW) != null ? _c : value2;
        const mq = `@media screen and (min-width: ${breakpoint})`;
        return { [mq]: { display: "none" } };
      }
    },
    hideBelow: {
      scale: "breakpoints",
      transform: (value2, theme2) => {
        var _a3, _b, _c;
        const breakpoint = (_c = (_b = (_a3 = theme2.__breakpoints) == null ? void 0 : _a3.get(value2)) == null ? void 0 : _b._minW) != null ? _c : value2;
        const mq = `@media screen and (max-width: ${breakpoint})`;
        return { [mq]: { display: "none" } };
      }
    },
    verticalAlign: true,
    boxSizing: true,
    boxDecorationBreak: true,
    float: t.propT("float", transformFunctions.float),
    objectFit: true,
    objectPosition: true,
    visibility: true,
    isolation: true
  };
  Object.assign(layout, {
    w: layout.width,
    h: layout.height,
    minW: layout.minWidth,
    maxW: layout.maxWidth,
    minH: layout.minHeight,
    maxH: layout.maxHeight,
    overscroll: layout.overscrollBehavior,
    overscrollX: layout.overscrollBehaviorX,
    overscrollY: layout.overscrollBehaviorY
  });
  var list = {
    listStyleType: true,
    listStylePosition: true,
    listStylePos: t.prop("listStylePosition"),
    listStyleImage: true,
    listStyleImg: t.prop("listStyleImage")
  };
  function get$1(obj, path2, fallback, index2) {
    const key = typeof path2 === "string" ? path2.split(".") : [path2];
    for (index2 = 0; index2 < key.length; index2 += 1) {
      if (!obj)
        break;
      obj = obj[key[index2]];
    }
    return obj === void 0 ? fallback : obj;
  }
  var memoize$2 = (fn) => {
    const cache = /* @__PURE__ */ new WeakMap();
    const memoizedFn = (obj, path2, fallback, index2) => {
      if (typeof obj === "undefined") {
        return fn(obj, path2, fallback);
      }
      if (!cache.has(obj)) {
        cache.set(obj, /* @__PURE__ */ new Map());
      }
      const map2 = cache.get(obj);
      if (map2.has(path2)) {
        return map2.get(path2);
      }
      const value2 = fn(obj, path2, fallback, index2);
      map2.set(path2, value2);
      return value2;
    };
    return memoizedFn;
  };
  var memoizedGet$1 = memoize$2(get$1);
  var srOnly = {
    border: "0px",
    clip: "rect(0, 0, 0, 0)",
    width: "1px",
    height: "1px",
    margin: "-1px",
    padding: "0px",
    overflow: "hidden",
    whiteSpace: "nowrap",
    position: "absolute"
  };
  var srFocusable = {
    position: "static",
    width: "auto",
    height: "auto",
    clip: "auto",
    padding: "0",
    margin: "0",
    overflow: "visible",
    whiteSpace: "normal"
  };
  var getWithPriority = (theme2, key, styles) => {
    const result = {};
    const obj = memoizedGet$1(theme2, key, {});
    for (const prop2 in obj) {
      const isInStyles = prop2 in styles && styles[prop2] != null;
      if (!isInStyles)
        result[prop2] = obj[prop2];
    }
    return result;
  };
  var others = {
    srOnly: {
      transform(value2) {
        if (value2 === true)
          return srOnly;
        if (value2 === "focusable")
          return srFocusable;
        return {};
      }
    },
    layerStyle: {
      processResult: true,
      transform: (value2, theme2, styles) => getWithPriority(theme2, `layerStyles.${value2}`, styles)
    },
    textStyle: {
      processResult: true,
      transform: (value2, theme2, styles) => getWithPriority(theme2, `textStyles.${value2}`, styles)
    },
    apply: {
      processResult: true,
      transform: (value2, theme2, styles) => getWithPriority(theme2, value2, styles)
    }
  };
  var position = {
    position: true,
    pos: t.prop("position"),
    zIndex: t.prop("zIndex", "zIndices"),
    inset: t.spaceT("inset"),
    insetX: t.spaceT(["left", "right"]),
    insetInline: t.spaceT("insetInline"),
    insetY: t.spaceT(["top", "bottom"]),
    insetBlock: t.spaceT("insetBlock"),
    top: t.spaceT("top"),
    insetBlockStart: t.spaceT("insetBlockStart"),
    bottom: t.spaceT("bottom"),
    insetBlockEnd: t.spaceT("insetBlockEnd"),
    left: t.spaceT("left"),
    insetInlineStart: t.logical({
      scale: "space",
      property: { ltr: "left", rtl: "right" }
    }),
    right: t.spaceT("right"),
    insetInlineEnd: t.logical({
      scale: "space",
      property: { ltr: "right", rtl: "left" }
    })
  };
  Object.assign(position, {
    insetStart: position.insetInlineStart,
    insetEnd: position.insetInlineEnd
  });
  var ring = {
    ring: { transform: transformFunctions.ring },
    ringColor: t.colors("--chakra-ring-color"),
    ringOffset: t.prop("--chakra-ring-offset-width"),
    ringOffsetColor: t.colors("--chakra-ring-offset-color"),
    ringInset: t.prop("--chakra-ring-inset")
  };
  var space = {
    margin: t.spaceT("margin"),
    marginTop: t.spaceT("marginTop"),
    marginBlockStart: t.spaceT("marginBlockStart"),
    marginRight: t.spaceT("marginRight"),
    marginInlineEnd: t.spaceT("marginInlineEnd"),
    marginBottom: t.spaceT("marginBottom"),
    marginBlockEnd: t.spaceT("marginBlockEnd"),
    marginLeft: t.spaceT("marginLeft"),
    marginInlineStart: t.spaceT("marginInlineStart"),
    marginX: t.spaceT(["marginInlineStart", "marginInlineEnd"]),
    marginInline: t.spaceT("marginInline"),
    marginY: t.spaceT(["marginTop", "marginBottom"]),
    marginBlock: t.spaceT("marginBlock"),
    padding: t.space("padding"),
    paddingTop: t.space("paddingTop"),
    paddingBlockStart: t.space("paddingBlockStart"),
    paddingRight: t.space("paddingRight"),
    paddingBottom: t.space("paddingBottom"),
    paddingBlockEnd: t.space("paddingBlockEnd"),
    paddingLeft: t.space("paddingLeft"),
    paddingInlineStart: t.space("paddingInlineStart"),
    paddingInlineEnd: t.space("paddingInlineEnd"),
    paddingX: t.space(["paddingInlineStart", "paddingInlineEnd"]),
    paddingInline: t.space("paddingInline"),
    paddingY: t.space(["paddingTop", "paddingBottom"]),
    paddingBlock: t.space("paddingBlock")
  };
  Object.assign(space, {
    m: space.margin,
    mt: space.marginTop,
    mr: space.marginRight,
    me: space.marginInlineEnd,
    marginEnd: space.marginInlineEnd,
    mb: space.marginBottom,
    ml: space.marginLeft,
    ms: space.marginInlineStart,
    marginStart: space.marginInlineStart,
    mx: space.marginX,
    my: space.marginY,
    p: space.padding,
    pt: space.paddingTop,
    py: space.paddingY,
    px: space.paddingX,
    pb: space.paddingBottom,
    pl: space.paddingLeft,
    ps: space.paddingInlineStart,
    paddingStart: space.paddingInlineStart,
    pr: space.paddingRight,
    pe: space.paddingInlineEnd,
    paddingEnd: space.paddingInlineEnd
  });
  var textDecoration = {
    textDecorationColor: t.colors("textDecorationColor"),
    textDecoration: true,
    textDecor: { property: "textDecoration" },
    textDecorationLine: true,
    textDecorationStyle: true,
    textDecorationThickness: true,
    textUnderlineOffset: true,
    textShadow: t.shadows("textShadow")
  };
  var transform = {
    clipPath: true,
    transform: t.propT("transform", transformFunctions.transform),
    transformOrigin: true,
    translateX: t.spaceT("--chakra-translate-x"),
    translateY: t.spaceT("--chakra-translate-y"),
    skewX: t.degreeT("--chakra-skew-x"),
    skewY: t.degreeT("--chakra-skew-y"),
    scaleX: t.prop("--chakra-scale-x"),
    scaleY: t.prop("--chakra-scale-y"),
    scale: t.prop(["--chakra-scale-x", "--chakra-scale-y"]),
    rotate: t.degreeT("--chakra-rotate")
  };
  var transition = {
    transition: true,
    transitionDelay: true,
    animation: true,
    willChange: true,
    transitionDuration: t.prop("transitionDuration", "transition.duration"),
    transitionProperty: t.prop("transitionProperty", "transition.property"),
    transitionTimingFunction: t.prop(
      "transitionTimingFunction",
      "transition.easing"
    )
  };
  var typography = {
    fontFamily: t.prop("fontFamily", "fonts"),
    fontSize: t.prop("fontSize", "fontSizes", transformFunctions.px),
    fontWeight: t.prop("fontWeight", "fontWeights"),
    lineHeight: t.prop("lineHeight", "lineHeights"),
    letterSpacing: t.prop("letterSpacing", "letterSpacings"),
    textAlign: true,
    fontStyle: true,
    textIndent: true,
    wordBreak: true,
    overflowWrap: true,
    textOverflow: true,
    textTransform: true,
    whiteSpace: true,
    isTruncated: {
      transform(value2) {
        if (value2 === true) {
          return {
            overflow: "hidden",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap"
          };
        }
      }
    },
    noOfLines: {
      static: {
        overflow: "hidden",
        textOverflow: "ellipsis",
        display: "-webkit-box",
        WebkitBoxOrient: "vertical",
        WebkitLineClamp: "var(--chakra-line-clamp)"
      },
      property: "--chakra-line-clamp"
    }
  };
  var scroll = {
    scrollBehavior: true,
    scrollSnapAlign: true,
    scrollSnapStop: true,
    scrollSnapType: true,
    scrollMargin: t.spaceT("scrollMargin"),
    scrollMarginTop: t.spaceT("scrollMarginTop"),
    scrollMarginBottom: t.spaceT("scrollMarginBottom"),
    scrollMarginLeft: t.spaceT("scrollMarginLeft"),
    scrollMarginRight: t.spaceT("scrollMarginRight"),
    scrollMarginX: t.spaceT(["scrollMarginLeft", "scrollMarginRight"]),
    scrollMarginY: t.spaceT(["scrollMarginTop", "scrollMarginBottom"]),
    scrollPadding: t.spaceT("scrollPadding"),
    scrollPaddingTop: t.spaceT("scrollPaddingTop"),
    scrollPaddingBottom: t.spaceT("scrollPaddingBottom"),
    scrollPaddingLeft: t.spaceT("scrollPaddingLeft"),
    scrollPaddingRight: t.spaceT("scrollPaddingRight"),
    scrollPaddingX: t.spaceT(["scrollPaddingLeft", "scrollPaddingRight"]),
    scrollPaddingY: t.spaceT(["scrollPaddingTop", "scrollPaddingBottom"])
  };
  function resolveReference(operand) {
    if (isObject(operand) && operand.reference) {
      return operand.reference;
    }
    return String(operand);
  }
  var toExpression = (operator, ...operands) => operands.map(resolveReference).join(` ${operator} `).replace(/calc/g, "");
  var add = (...operands) => `calc(${toExpression("+", ...operands)})`;
  var subtract = (...operands) => `calc(${toExpression("-", ...operands)})`;
  var multiply = (...operands) => `calc(${toExpression("*", ...operands)})`;
  var divide = (...operands) => `calc(${toExpression("/", ...operands)})`;
  var negate = (x2) => {
    const value2 = resolveReference(x2);
    if (value2 != null && !Number.isNaN(parseFloat(value2))) {
      return String(value2).startsWith("-") ? String(value2).slice(1) : `-${value2}`;
    }
    return multiply(value2, -1);
  };
  var calc = Object.assign(
    (x2) => ({
      add: (...operands) => calc(add(x2, ...operands)),
      subtract: (...operands) => calc(subtract(x2, ...operands)),
      multiply: (...operands) => calc(multiply(x2, ...operands)),
      divide: (...operands) => calc(divide(x2, ...operands)),
      negate: () => calc(negate(x2)),
      toString: () => x2.toString()
    }),
    {
      add,
      subtract,
      multiply,
      divide,
      negate
    }
  );
  function analyzeCSSValue2(value2) {
    const num = parseFloat(value2.toString());
    const unit = value2.toString().replace(String(num), "");
    return { unitless: !unit, value: num, unit };
  }
  function px(value2) {
    if (value2 == null)
      return value2;
    const { unitless } = analyzeCSSValue2(value2);
    return unitless || typeof value2 === "number" ? `${value2}px` : value2;
  }
  function toMediaQueryString(min2, max2) {
    const query2 = ["@media screen"];
    if (min2)
      query2.push("and", `(min-width: ${px(min2)})`);
    if (max2)
      query2.push("and", `(max-width: ${px(max2)})`);
    return query2.join(" ");
  }
  var state = {
    hover: (str2, post) => `${str2}:hover ${post}, ${str2}[data-hover] ${post}`,
    focus: (str2, post) => `${str2}:focus ${post}, ${str2}[data-focus] ${post}`,
    focusVisible: (str2, post) => `${str2}:focus-visible ${post}`,
    focusWithin: (str2, post) => `${str2}:focus-within ${post}`,
    active: (str2, post) => `${str2}:active ${post}, ${str2}[data-active] ${post}`,
    disabled: (str2, post) => `${str2}:disabled ${post}, ${str2}[data-disabled] ${post}`,
    invalid: (str2, post) => `${str2}:invalid ${post}, ${str2}[data-invalid] ${post}`,
    checked: (str2, post) => `${str2}:checked ${post}, ${str2}[data-checked] ${post}`,
    indeterminate: (str2, post) => `${str2}:indeterminate ${post}, ${str2}[aria-checked=mixed] ${post}, ${str2}[data-indeterminate] ${post}`,
    readOnly: (str2, post) => `${str2}:read-only ${post}, ${str2}[readonly] ${post}, ${str2}[data-read-only] ${post}`,
    expanded: (str2, post) => `${str2}:read-only ${post}, ${str2}[aria-expanded=true] ${post}, ${str2}[data-expanded] ${post}`,
    placeholderShown: (str2, post) => `${str2}:placeholder-shown ${post}`
  };
  var toGroup = (fn) => merge((v) => fn(v, "&"), "[role=group]", "[data-group]", ".group");
  var toPeer = (fn) => merge((v) => fn(v, "~ &"), "[data-peer]", ".peer");
  var merge = (fn, ...selectors) => selectors.map(fn).join(", ");
  var pseudoSelectors = {
    _hover: "&:hover, &[data-hover]",
    _active: "&:active, &[data-active]",
    _focus: "&:focus, &[data-focus]",
    _highlighted: "&[data-highlighted]",
    _focusWithin: "&:focus-within",
    _focusVisible: "&:focus-visible, &[data-focus-visible]",
    _disabled: "&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]",
    _readOnly: "&[aria-readonly=true], &[readonly], &[data-readonly]",
    _before: "&::before",
    _after: "&::after",
    _empty: "&:empty",
    _expanded: "&[aria-expanded=true], &[data-expanded]",
    _checked: "&[aria-checked=true], &[data-checked]",
    _grabbed: "&[aria-grabbed=true], &[data-grabbed]",
    _pressed: "&[aria-pressed=true], &[data-pressed]",
    _invalid: "&[aria-invalid=true], &[data-invalid]",
    _valid: "&[data-valid], &[data-state=valid]",
    _loading: "&[data-loading], &[aria-busy=true]",
    _selected: "&[aria-selected=true], &[data-selected]",
    _hidden: "&[hidden], &[data-hidden]",
    _autofill: "&:-webkit-autofill",
    _even: "&:nth-of-type(even)",
    _odd: "&:nth-of-type(odd)",
    _first: "&:first-of-type",
    _firstLetter: "&::first-letter",
    _last: "&:last-of-type",
    _notFirst: "&:not(:first-of-type)",
    _notLast: "&:not(:last-of-type)",
    _visited: "&:visited",
    _activeLink: "&[aria-current=page]",
    _activeStep: "&[aria-current=step]",
    _indeterminate: "&:indeterminate, &[aria-checked=mixed], &[data-indeterminate]",
    _groupHover: toGroup(state.hover),
    _peerHover: toPeer(state.hover),
    _groupFocus: toGroup(state.focus),
    _peerFocus: toPeer(state.focus),
    _groupFocusVisible: toGroup(state.focusVisible),
    _peerFocusVisible: toPeer(state.focusVisible),
    _groupActive: toGroup(state.active),
    _peerActive: toPeer(state.active),
    _groupDisabled: toGroup(state.disabled),
    _peerDisabled: toPeer(state.disabled),
    _groupInvalid: toGroup(state.invalid),
    _peerInvalid: toPeer(state.invalid),
    _groupChecked: toGroup(state.checked),
    _peerChecked: toPeer(state.checked),
    _groupFocusWithin: toGroup(state.focusWithin),
    _peerFocusWithin: toPeer(state.focusWithin),
    _peerPlaceholderShown: toPeer(state.placeholderShown),
    _placeholder: "&::placeholder",
    _placeholderShown: "&:placeholder-shown",
    _fullScreen: "&:fullscreen",
    _selection: "&::selection",
    _rtl: "[dir=rtl] &, &[dir=rtl]",
    _ltr: "[dir=ltr] &, &[dir=ltr]",
    _mediaDark: "@media (prefers-color-scheme: dark)",
    _mediaReduceMotion: "@media (prefers-reduced-motion: reduce)",
    _dark: ".chakra-ui-dark &:not([data-theme]),[data-theme=dark] &:not([data-theme]),&[data-theme=dark]",
    _light: ".chakra-ui-light &:not([data-theme]),[data-theme=light] &:not([data-theme]),&[data-theme=light]",
    _horizontal: "&[data-orientation=horizontal]",
    _vertical: "&[data-orientation=vertical]"
  };
  var pseudoPropNames = Object.keys(
    pseudoSelectors
  );
  var systemProps = mergeWith(
    {},
    background,
    border,
    color,
    flexbox,
    layout,
    filter,
    ring,
    interactivity,
    grid,
    others,
    position,
    effect,
    space,
    scroll,
    typography,
    textDecoration,
    transform,
    list,
    transition
  );
  Object.assign({}, space, layout, flexbox, grid, position);
  var propNames = [...Object.keys(systemProps), ...pseudoPropNames];
  var styleProps = { ...systemProps, ...pseudoSelectors };
  var isStyleProp = (prop2) => prop2 in styleProps;
  var expandResponsive = (styles) => (theme2) => {
    if (!theme2.__breakpoints)
      return styles;
    const { isResponsive, toArrayValue, media: medias } = theme2.__breakpoints;
    const computedStyles = {};
    for (const key in styles) {
      let value2 = runIfFn$1(styles[key], theme2);
      if (value2 == null)
        continue;
      value2 = isObject(value2) && isResponsive(value2) ? toArrayValue(value2) : value2;
      if (!Array.isArray(value2)) {
        computedStyles[key] = value2;
        continue;
      }
      const queries = value2.slice(0, medias.length).length;
      for (let index2 = 0; index2 < queries; index2 += 1) {
        const media = medias == null ? void 0 : medias[index2];
        if (!media) {
          computedStyles[key] = value2[index2];
          continue;
        }
        computedStyles[media] = computedStyles[media] || {};
        if (value2[index2] == null) {
          continue;
        }
        computedStyles[media][key] = value2[index2];
      }
    }
    return computedStyles;
  };
  function splitByComma(value2) {
    const chunks = [];
    let chunk = "";
    let inParens = false;
    for (let i2 = 0; i2 < value2.length; i2++) {
      const char = value2[i2];
      if (char === "(") {
        inParens = true;
        chunk += char;
      } else if (char === ")") {
        inParens = false;
        chunk += char;
      } else if (char === "," && !inParens) {
        chunks.push(chunk);
        chunk = "";
      } else {
        chunk += char;
      }
    }
    chunk = chunk.trim();
    if (chunk) {
      chunks.push(chunk);
    }
    return chunks;
  }
  function isCssVar2(value2) {
    return /^var\(--.+\)$/.test(value2);
  }
  var isCSSVariableTokenValue = (key, value2) => key.startsWith("--") && typeof value2 === "string" && !isCssVar2(value2);
  var resolveTokenValue = (theme2, value2) => {
    var _a3, _b;
    if (value2 == null)
      return value2;
    const getVar = (val) => {
      var _a22, _b2;
      return (_b2 = (_a22 = theme2.__cssMap) == null ? void 0 : _a22[val]) == null ? void 0 : _b2.varRef;
    };
    const getValue2 = (val) => {
      var _a22;
      return (_a22 = getVar(val)) != null ? _a22 : val;
    };
    const [tokenValue, fallbackValue] = splitByComma(value2);
    value2 = (_b = (_a3 = getVar(tokenValue)) != null ? _a3 : getValue2(fallbackValue)) != null ? _b : getValue2(value2);
    return value2;
  };
  function getCss(options) {
    const { configs = {}, pseudos = {}, theme: theme2 } = options;
    const css2 = (stylesOrFn, nested = false) => {
      var _a3, _b, _c;
      const _styles = runIfFn$1(stylesOrFn, theme2);
      const styles = expandResponsive(_styles)(theme2);
      let computedStyles = {};
      for (let key in styles) {
        const valueOrFn = styles[key];
        let value2 = runIfFn$1(valueOrFn, theme2);
        if (key in pseudos) {
          key = pseudos[key];
        }
        if (isCSSVariableTokenValue(key, value2)) {
          value2 = resolveTokenValue(theme2, value2);
        }
        let config2 = configs[key];
        if (config2 === true) {
          config2 = { property: key };
        }
        if (isObject(value2)) {
          computedStyles[key] = (_a3 = computedStyles[key]) != null ? _a3 : {};
          computedStyles[key] = mergeWith(
            {},
            computedStyles[key],
            css2(value2, true)
          );
          continue;
        }
        let rawValue = (_c = (_b = config2 == null ? void 0 : config2.transform) == null ? void 0 : _b.call(config2, value2, theme2, _styles)) != null ? _c : value2;
        rawValue = (config2 == null ? void 0 : config2.processResult) ? css2(rawValue, true) : rawValue;
        const configProperty = runIfFn$1(config2 == null ? void 0 : config2.property, theme2);
        if (!nested && (config2 == null ? void 0 : config2.static)) {
          const staticStyles = runIfFn$1(config2.static, theme2);
          computedStyles = mergeWith({}, computedStyles, staticStyles);
        }
        if (configProperty && Array.isArray(configProperty)) {
          for (const property of configProperty) {
            computedStyles[property] = rawValue;
          }
          continue;
        }
        if (configProperty) {
          if (configProperty === "&" && isObject(rawValue)) {
            computedStyles = mergeWith({}, computedStyles, rawValue);
          } else {
            computedStyles[configProperty] = rawValue;
          }
          continue;
        }
        if (isObject(rawValue)) {
          computedStyles = mergeWith({}, computedStyles, rawValue);
          continue;
        }
        computedStyles[key] = rawValue;
      }
      return computedStyles;
    };
    return css2;
  }
  var css = (styles) => (theme2) => {
    const cssFn = getCss({
      theme: theme2,
      pseudos: pseudoSelectors,
      configs: systemProps
    });
    return cssFn(styles);
  };
  function normalize2(value2, toArray2) {
    if (Array.isArray(value2))
      return value2;
    if (isObject(value2))
      return toArray2(value2);
    if (value2 != null)
      return [value2];
  }
  function getNextIndex(values2, i2) {
    for (let j = i2 + 1; j < values2.length; j++) {
      if (values2[j] != null)
        return j;
    }
    return -1;
  }
  function createResolver(theme2) {
    const breakpointUtil = theme2.__breakpoints;
    return function resolver(config2, prop2, value2, props) {
      var _a3, _b;
      if (!breakpointUtil)
        return;
      const result = {};
      const normalized = normalize2(value2, breakpointUtil.toArrayValue);
      if (!normalized)
        return result;
      const len2 = normalized.length;
      const isSingle = len2 === 1;
      const isMultipart = !!config2.parts;
      for (let i2 = 0; i2 < len2; i2++) {
        const key = breakpointUtil.details[i2];
        const nextKey = breakpointUtil.details[getNextIndex(normalized, i2)];
        const query2 = toMediaQueryString(key.minW, nextKey == null ? void 0 : nextKey._minW);
        const styles = runIfFn$1((_a3 = config2[prop2]) == null ? void 0 : _a3[normalized[i2]], props);
        if (!styles)
          continue;
        if (isMultipart) {
          (_b = config2.parts) == null ? void 0 : _b.forEach((part) => {
            mergeWith(result, {
              [part]: isSingle ? styles[part] : { [query2]: styles[part] }
            });
          });
          continue;
        }
        if (!isMultipart) {
          if (isSingle)
            mergeWith(result, styles);
          else
            result[query2] = styles;
          continue;
        }
        result[query2] = styles;
      }
      return result;
    };
  }
  function resolveStyleConfig(config2) {
    return (props) => {
      var _a3;
      const { variant, size, theme: theme2 } = props;
      const recipe = createResolver(theme2);
      return mergeWith(
        {},
        runIfFn$1((_a3 = config2.baseStyle) != null ? _a3 : {}, props),
        recipe(config2, "sizes", size, props),
        recipe(config2, "variants", variant, props)
      );
    };
  }
  function omit(object, keys2) {
    const result = {};
    Object.keys(object).forEach((key) => {
      if (keys2.includes(key))
        return;
      result[key] = object[key];
    });
    return result;
  }
  function get(obj, path2, fallback, index2) {
    const key = typeof path2 === "string" ? path2.split(".") : [path2];
    for (index2 = 0; index2 < key.length; index2 += 1) {
      if (!obj)
        break;
      obj = obj[key[index2]];
    }
    return obj === void 0 ? fallback : obj;
  }
  var memoize$1 = (fn) => {
    const cache = /* @__PURE__ */ new WeakMap();
    const memoizedFn = (obj, path2, fallback, index2) => {
      if (typeof obj === "undefined") {
        return fn(obj, path2, fallback);
      }
      if (!cache.has(obj)) {
        cache.set(obj, /* @__PURE__ */ new Map());
      }
      const map2 = cache.get(obj);
      if (map2.has(path2)) {
        return map2.get(path2);
      }
      const value2 = fn(obj, path2, fallback, index2);
      map2.set(path2, value2);
      return value2;
    };
    return memoizedFn;
  };
  var memoizedGet = memoize$1(get);
  function objectFilter(object, fn) {
    const result = {};
    Object.keys(object).forEach((key) => {
      const value2 = object[key];
      const shouldPass = fn(value2, key, object);
      if (shouldPass) {
        result[key] = value2;
      }
    });
    return result;
  }
  var filterUndefined = (object) => objectFilter(object, (val) => val !== null && val !== void 0);
  function isFunction(value2) {
    return typeof value2 === "function";
  }
  function runIfFn(valueOrFn, ...args) {
    return isFunction(valueOrFn) ? valueOrFn(...args) : valueOrFn;
  }
  function useStyleConfigImpl(themeKey, props = {}) {
    var _a3;
    const { styleConfig: styleConfigProp, ...rest } = props;
    const { theme: theme2, colorMode } = useChakra();
    const themeStyleConfig = themeKey ? memoizedGet(theme2, `components.${themeKey}`) : void 0;
    const styleConfig = styleConfigProp || themeStyleConfig;
    const mergedProps = mergeWith(
      { theme: theme2, colorMode },
      (_a3 = styleConfig == null ? void 0 : styleConfig.defaultProps) != null ? _a3 : {},
      filterUndefined(omit(rest, ["children"]))
    );
    const stylesRef = React$1.useRef({});
    if (styleConfig) {
      const getStyles = resolveStyleConfig(styleConfig);
      const styles = getStyles(mergedProps);
      const isStyleEqual = isEqual(stylesRef.current, styles);
      if (!isStyleEqual) {
        stylesRef.current = styles;
      }
    }
    return stylesRef.current;
  }
  function useStyleConfig(themeKey, props = {}) {
    return useStyleConfigImpl(themeKey, props);
  }
  var allPropNames = /* @__PURE__ */ new Set([
    ...propNames,
    "textStyle",
    "layerStyle",
    "apply",
    "noOfLines",
    "focusBorderColor",
    "errorBorderColor",
    "as",
    "__css",
    "css",
    "sx"
  ]);
  var validHTMLProps = /* @__PURE__ */ new Set([
    "htmlWidth",
    "htmlHeight",
    "htmlSize",
    "htmlTranslate"
  ]);
  function shouldForwardProp(prop2) {
    return validHTMLProps.has(prop2) || !allPropNames.has(prop2);
  }
  function assignAfter(target, ...sources) {
    if (target == null) {
      throw new TypeError("Cannot convert undefined or null to object");
    }
    const result = { ...target };
    for (const nextSource of sources) {
      if (nextSource == null)
        continue;
      for (const nextKey in nextSource) {
        if (!Object.prototype.hasOwnProperty.call(nextSource, nextKey))
          continue;
        if (nextKey in result)
          delete result[nextKey];
        result[nextKey] = nextSource[nextKey];
      }
    }
    return result;
  }
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function memoize(fn) {
    var cache = /* @__PURE__ */ Object.create(null);
    return function(arg) {
      if (cache[arg] === void 0)
        cache[arg] = fn(arg);
      return cache[arg];
    };
  }
  var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
  var isPropValid = /* @__PURE__ */ memoize(
    function(prop2) {
      return reactPropsRegex.test(prop2) || prop2.charCodeAt(0) === 111 && prop2.charCodeAt(1) === 110 && prop2.charCodeAt(2) < 91;
    }
    /* Z+1 */
  );
  var isBrowser = true;
  function getRegisteredStyles(registered, registeredStyles, classNames) {
    var rawClassName = "";
    classNames.split(" ").forEach(function(className) {
      if (registered[className] !== void 0) {
        registeredStyles.push(registered[className] + ";");
      } else {
        rawClassName += className + " ";
      }
    });
    return rawClassName;
  }
  var registerStyles = function registerStyles2(cache, serialized, isStringTag) {
    var className = cache.key + "-" + serialized.name;
    if (
      // we only need to add the styles to the registered cache if the
      // class name could be used further down
      // the tree but if it's a string tag, we know it won't
      // so we don't have to add it to registered cache.
      // this improves memory usage since we can avoid storing the whole style string
      (isStringTag === false || // we need to always store it if we're in compat mode and
      // in node since emotion-server relies on whether a style is in
      // the registered cache to know whether a style is global or not
      // also, note that this check will be dead code eliminated in the browser
      isBrowser === false) && cache.registered[className] === void 0
    ) {
      cache.registered[className] = serialized.styles;
    }
  };
  var insertStyles = function insertStyles2(cache, serialized, isStringTag) {
    registerStyles(cache, serialized, isStringTag);
    var className = cache.key + "-" + serialized.name;
    if (cache.inserted[serialized.name] === void 0) {
      var current = serialized;
      do {
        cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
        current = current.next;
      } while (current !== void 0);
    }
  };
  function murmur2(str2) {
    var h = 0;
    var k2, i2 = 0, len2 = str2.length;
    for (; len2 >= 4; ++i2, len2 -= 4) {
      k2 = str2.charCodeAt(i2) & 255 | (str2.charCodeAt(++i2) & 255) << 8 | (str2.charCodeAt(++i2) & 255) << 16 | (str2.charCodeAt(++i2) & 255) << 24;
      k2 = /* Math.imul(k, m): */
      (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
      k2 ^= /* k >>> r: */
      k2 >>> 24;
      h = /* Math.imul(k, m): */
      (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    }
    switch (len2) {
      case 3:
        h ^= (str2.charCodeAt(i2 + 2) & 255) << 16;
      case 2:
        h ^= (str2.charCodeAt(i2 + 1) & 255) << 8;
      case 1:
        h ^= str2.charCodeAt(i2) & 255;
        h = /* Math.imul(h, m): */
        (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    }
    h ^= h >>> 13;
    h = /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    return ((h ^ h >>> 15) >>> 0).toString(36);
  }
  var unitlessKeys = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };
  var hyphenateRegex = /[A-Z]|^ms/g;
  var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
  var isCustomProperty = function isCustomProperty2(property) {
    return property.charCodeAt(1) === 45;
  };
  var isProcessableValue = function isProcessableValue2(value2) {
    return value2 != null && typeof value2 !== "boolean";
  };
  var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
    return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
  });
  var processStyleValue = function processStyleValue2(key, value2) {
    switch (key) {
      case "animation":
      case "animationName": {
        if (typeof value2 === "string") {
          return value2.replace(animationRegex, function(match2, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
    }
    if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value2 === "number" && value2 !== 0) {
      return value2 + "px";
    }
    return value2;
  };
  var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
  function handleInterpolation(mergedProps, registered, interpolation) {
    if (interpolation == null) {
      return "";
    }
    if (interpolation.__emotion_styles !== void 0) {
      return interpolation;
    }
    switch (typeof interpolation) {
      case "boolean": {
        return "";
      }
      case "object": {
        if (interpolation.anim === 1) {
          cursor = {
            name: interpolation.name,
            styles: interpolation.styles,
            next: cursor
          };
          return interpolation.name;
        }
        if (interpolation.styles !== void 0) {
          var next = interpolation.next;
          if (next !== void 0) {
            while (next !== void 0) {
              cursor = {
                name: next.name,
                styles: next.styles,
                next: cursor
              };
              next = next.next;
            }
          }
          var styles = interpolation.styles + ";";
          return styles;
        }
        return createStringFromObject(mergedProps, registered, interpolation);
      }
      case "function": {
        if (mergedProps !== void 0) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        }
        break;
      }
    }
    if (registered == null) {
      return interpolation;
    }
    var cached = registered[interpolation];
    return cached !== void 0 ? cached : interpolation;
  }
  function createStringFromObject(mergedProps, registered, obj) {
    var string = "";
    if (Array.isArray(obj)) {
      for (var i2 = 0; i2 < obj.length; i2++) {
        string += handleInterpolation(mergedProps, registered, obj[i2]) + ";";
      }
    } else {
      for (var _key in obj) {
        var value2 = obj[_key];
        if (typeof value2 !== "object") {
          if (registered != null && registered[value2] !== void 0) {
            string += _key + "{" + registered[value2] + "}";
          } else if (isProcessableValue(value2)) {
            string += processStyleName(_key) + ":" + processStyleValue(_key, value2) + ";";
          }
        } else {
          if (_key === "NO_COMPONENT_SELECTOR" && false) {
            throw new Error(noComponentSelectorMessage);
          }
          if (Array.isArray(value2) && typeof value2[0] === "string" && (registered == null || registered[value2[0]] === void 0)) {
            for (var _i = 0; _i < value2.length; _i++) {
              if (isProcessableValue(value2[_i])) {
                string += processStyleName(_key) + ":" + processStyleValue(_key, value2[_i]) + ";";
              }
            }
          } else {
            var interpolated = handleInterpolation(mergedProps, registered, value2);
            switch (_key) {
              case "animation":
              case "animationName": {
                string += processStyleName(_key) + ":" + interpolated + ";";
                break;
              }
              default: {
                string += _key + "{" + interpolated + "}";
              }
            }
          }
        }
      }
    }
    return string;
  }
  var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
  var cursor;
  var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
    if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
      return args[0];
    }
    var stringMode = true;
    var styles = "";
    cursor = void 0;
    var strings = args[0];
    if (strings == null || strings.raw === void 0) {
      stringMode = false;
      styles += handleInterpolation(mergedProps, registered, strings);
    } else {
      styles += strings[0];
    }
    for (var i2 = 1; i2 < args.length; i2++) {
      styles += handleInterpolation(mergedProps, registered, args[i2]);
      if (stringMode) {
        styles += strings[i2];
      }
    }
    labelPattern.lastIndex = 0;
    var identifierName = "";
    var match2;
    while ((match2 = labelPattern.exec(styles)) !== null) {
      identifierName += "-" + // $FlowFixMe we know it's not null
      match2[1];
    }
    var name = murmur2(styles) + identifierName;
    return {
      name,
      styles,
      next: cursor
    };
  };
  var syncFallback = function syncFallback2(create2) {
    return create2();
  };
  var useInsertionEffect = React__namespace["useInsertionEffect"] ? React__namespace["useInsertionEffect"] : false;
  var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
  var testOmitPropsOnStringTag = isPropValid;
  var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
    return key !== "theme";
  };
  var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
    return typeof tag === "string" && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
  };
  var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
    var shouldForwardProp2;
    if (options) {
      var optionsShouldForwardProp = options.shouldForwardProp;
      shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
        return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
      } : optionsShouldForwardProp;
    }
    if (typeof shouldForwardProp2 !== "function" && isReal) {
      shouldForwardProp2 = tag.__emotion_forwardProp;
    }
    return shouldForwardProp2;
  };
  var Insertion = function Insertion2(_ref) {
    var cache = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
    registerStyles(cache, serialized, isStringTag);
    useInsertionEffectAlwaysWithSyncFallback(function() {
      return insertStyles(cache, serialized, isStringTag);
    });
    return null;
  };
  var createStyled = function createStyled2(tag, options) {
    var isReal = tag.__emotion_real === tag;
    var baseTag = isReal && tag.__emotion_base || tag;
    var identifierName;
    var targetClassName;
    if (options !== void 0) {
      identifierName = options.label;
      targetClassName = options.target;
    }
    var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
    var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
    var shouldUseAs = !defaultShouldForwardProp("as");
    return function() {
      var args = arguments;
      var styles = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
      if (identifierName !== void 0) {
        styles.push("label:" + identifierName + ";");
      }
      if (args[0] == null || args[0].raw === void 0) {
        styles.push.apply(styles, args);
      } else {
        styles.push(args[0][0]);
        var len2 = args.length;
        var i2 = 1;
        for (; i2 < len2; i2++) {
          styles.push(args[i2], args[0][i2]);
        }
      }
      var Styled = react$1.withEmotionCache(function(props, cache, ref) {
        var FinalTag = shouldUseAs && props.as || baseTag;
        var className = "";
        var classInterpolations = [];
        var mergedProps = props;
        if (props.theme == null) {
          mergedProps = {};
          for (var key in props) {
            mergedProps[key] = props[key];
          }
          mergedProps.theme = React__namespace.useContext(react$1.ThemeContext);
        }
        if (typeof props.className === "string") {
          className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
        } else if (props.className != null) {
          className = props.className + " ";
        }
        var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);
        className += cache.key + "-" + serialized.name;
        if (targetClassName !== void 0) {
          className += " " + targetClassName;
        }
        var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
        var newProps = {};
        for (var _key in props) {
          if (shouldUseAs && _key === "as")
            continue;
          if (
            // $FlowFixMe
            finalShouldForwardProp(_key)
          ) {
            newProps[_key] = props[_key];
          }
        }
        newProps.className = className;
        newProps.ref = ref;
        return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(Insertion, {
          cache,
          serialized,
          isStringTag: typeof FinalTag === "string"
        }), /* @__PURE__ */ React__namespace.createElement(FinalTag, newProps));
      });
      Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
      Styled.defaultProps = tag.defaultProps;
      Styled.__emotion_real = Styled;
      Styled.__emotion_base = baseTag;
      Styled.__emotion_styles = styles;
      Styled.__emotion_forwardProp = shouldForwardProp2;
      Object.defineProperty(Styled, "toString", {
        value: function value2() {
          if (targetClassName === void 0 && false) {
            return "NO_COMPONENT_SELECTOR";
          }
          return "." + targetClassName;
        }
      });
      Styled.withComponent = function(nextTag, nextOptions) {
        return createStyled2(nextTag, _extends({}, options, nextOptions, {
          shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
        })).apply(void 0, styles);
      };
      return Styled;
    };
  };
  var tags = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    // SVG
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan"
  ];
  var newStyled = createStyled.bind();
  tags.forEach(function(tagName) {
    newStyled[tagName] = newStyled(tagName);
  });
  var _a;
  var emotion_styled = (_a = newStyled.default) != null ? _a : newStyled;
  var toCSSObject = ({ baseStyle }) => (props) => {
    const { theme: theme2, css: cssProp, __css, sx, ...rest } = props;
    const styleProps2 = objectFilter(rest, (_, prop2) => isStyleProp(prop2));
    const finalBaseStyle = runIfFn(baseStyle, props);
    const finalStyles = assignAfter(
      {},
      __css,
      finalBaseStyle,
      filterUndefined(styleProps2),
      sx
    );
    const computedCSS = css(finalStyles)(props.theme);
    return cssProp ? [computedCSS, cssProp] : computedCSS;
  };
  function styled(component, options) {
    const { baseStyle, ...styledOptions } = options != null ? options : {};
    if (!styledOptions.shouldForwardProp) {
      styledOptions.shouldForwardProp = shouldForwardProp;
    }
    const styleObject = toCSSObject({ baseStyle });
    const Component = emotion_styled(
      component,
      styledOptions
    )(styleObject);
    const chakraComponent = React$1.forwardRef(function ChakraComponent(props, ref) {
      const { colorMode, forced } = useColorMode();
      return React$1.createElement(Component, {
        ref,
        "data-theme": forced ? colorMode : void 0,
        ...props
      });
    });
    return chakraComponent;
  }
  function factory() {
    const cache = /* @__PURE__ */ new Map();
    return new Proxy(styled, {
      /**
       * @example
       * const Div = chakra("div")
       * const WithChakra = chakra(AnotherComponent)
       */
      apply(target, thisArg, argArray) {
        return styled(...argArray);
      },
      /**
       * @example
       * <chakra.div />
       */
      get(_, element) {
        if (!cache.has(element)) {
          cache.set(element, styled(element));
        }
        return cache.get(element);
      }
    });
  }
  var chakra = factory();
  function forwardRef(component) {
    return React$1.forwardRef(component);
  }
  var fallbackIcon = {
    path: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { stroke: "currentColor", strokeWidth: "1.5", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          strokeLinecap: "round",
          fill: "none",
          d: "M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          fill: "currentColor",
          strokeLinecap: "round",
          d: "M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { fill: "none", strokeMiterlimit: "10", cx: "12", cy: "12", r: "11.25" })
    ] }),
    viewBox: "0 0 24 24"
  };
  var Icon = forwardRef((props, ref) => {
    const {
      as: element,
      viewBox,
      color: color2 = "currentColor",
      focusable = false,
      children,
      className,
      __css,
      ...rest
    } = props;
    const _className = cx("chakra-icon", className);
    const customStyles = useStyleConfig("Icon", props);
    const styles = {
      w: "1em",
      h: "1em",
      display: "inline-block",
      lineHeight: "1em",
      flexShrink: 0,
      color: color2,
      ...__css,
      ...customStyles
    };
    const shared2 = {
      ref,
      focusable,
      className: _className,
      __css: styles
    };
    const _viewBox = viewBox != null ? viewBox : fallbackIcon.viewBox;
    if (element && typeof element !== "string") {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.svg, { as: element, ...shared2, ...rest });
    }
    const _path = children != null ? children : fallbackIcon.path;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(chakra.svg, { verticalAlign: "middle", viewBox: _viewBox, ...shared2, ...rest, children: _path });
  });
  Icon.displayName = "Icon";
  function createIcon(options) {
    const {
      viewBox = "0 0 24 24",
      d: pathDefinition,
      displayName,
      defaultProps = {}
    } = options;
    const path2 = React$1.Children.toArray(options.path);
    const Comp = forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { ref, viewBox, ...defaultProps, ...props, children: path2.length ? path2 : /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "currentColor", d: pathDefinition }) }));
    Comp.displayName = displayName;
    return Comp;
  }
  var Search2Icon = createIcon({
    d: "M23.414,20.591l-4.645-4.645a10.256,10.256,0,1,0-2.828,2.829l4.645,4.644a2.025,2.025,0,0,0,2.828,0A2,2,0,0,0,23.414,20.591ZM10.25,3.005A7.25,7.25,0,1,1,3,10.255,7.258,7.258,0,0,1,10.25,3.005Z",
    displayName: "Search2Icon"
  });
  function AssetSelect({ onClose, onlyOwned }) {
    const { state: state2, dispatch: dispatch2 } = usePioneer();
    const { api, app, user, balances } = state2;
    const [searchQuery, setSearchQuery] = React$1.useState("");
    const [currentPage, setCurrentPage] = React$1.useState([]);
    const [currentPageIndex, setCurrentPageIndex] = React$1.useState(0);
    const [showOwnedAssets, setShowOwnedAssets] = React$1.useState(false);
    const [timeOut, setTimeOut] = React$1.useState(null);
    const itemsPerPage = 6;
    const handleSelectClick = async (asset) => {
      try {
        const changeAssetContext = await app.setAssetContext(asset);
        onClose();
      } catch (e) {
        console.error(e);
      }
    };
    const onSearch = async function(searchQuery2) {
      try {
        if (!api) {
          alert("Failed to init API!");
          return;
        }
        const search = {
          limit: itemsPerPage,
          skip: currentPageIndex * itemsPerPage,
          // Use currentPageIndex for pagination
          collection: "assets",
          searchQuery: searchQuery2,
          searchFields: ["name", "symbol"]
        };
        const info = await api.SearchAtlas(search);
        const currentPageData = info.data.results;
        setCurrentPage(currentPageData);
        setTotalAssets(info.data.total);
      } catch (e) {
        console.error(e);
      }
    };
    const fetchPage = async (pageIndex) => {
      try {
        if (!api) {
          alert("Failed to init API!");
          return;
        }
        console.log("balances: ", balances);
        if (balances) {
          setShowOwnedAssets(true);
          setCurrentPage(balances);
          console.log("balances: ", app.balances);
        }
      } catch (e) {
        console.error(e);
      }
    };
    React$1.useEffect(() => {
      fetchPage();
    }, [currentPageIndex, showOwnedAssets, balances]);
    const [totalAssets, setTotalAssets] = React$1.useState(0);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Stack, { spacing: 4, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(react.InputGroup, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(react.InputLeftElement, { pointerEvents: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Search2Icon, { color: "gray.300" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          react.Input,
          {
            placeholder: "Bitcoin...",
            type: "text",
            value: searchQuery,
            onChange: (e) => {
              setSearchQuery(e.target.value);
              if (timeOut) {
                clearTimeout(timeOut);
              }
              setTimeOut(
                // @ts-ignore
                setTimeout(() => {
                  setCurrentPageIndex(0);
                  onSearch(e.target.value);
                }, 1e3)
              );
            }
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Box, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Text, { fontSize: "2xl", children: [
          "Total Assets: ",
          totalAssets
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          react.Checkbox,
          {
            isChecked: showOwnedAssets,
            onChange: () => setShowOwnedAssets(!showOwnedAssets),
            children: "Show only owned assets"
          }
        ),
        currentPage.map((asset, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.HStack, { spacing: 4, alignItems: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Box, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
              "name: ",
              asset.asset.name
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
              "chain: ",
              asset.asset.chain
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
              "symbol: ",
              asset.asset.symbol
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
              "balance: ",
              asset.assetAmount.toString()
            ] })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.HStack, { mt: 2, spacing: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            react.Button,
            {
              size: "sm",
              variant: "outline",
              onClick: () => handleSelectClick(asset),
              children: "Select"
            }
          ) })
        ] }, index2))
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(react.HStack, { mt: 4, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          react.Button,
          {
            isDisabled: currentPageIndex === 0,
            onClick: () => setCurrentPageIndex(currentPageIndex - 1),
            children: "Previous Page"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          react.Button,
          {
            isDisabled: currentPage.length < itemsPerPage,
            onClick: () => setCurrentPageIndex(currentPageIndex + 1),
            children: "Next Page"
          }
        )
      ] })
    ] });
  }
  function OutputSelect({ onClose, onlyOwned }) {
    const { state: state2, dispatch: dispatch2 } = usePioneer();
    const { api, app, user, balances } = state2;
    const [searchQuery, setSearchQuery] = React$1.useState("");
    const [currentPage, setCurrentPage] = React$1.useState([]);
    const [currentPageIndex, setCurrentPageIndex] = React$1.useState(0);
    const [showOwnedAssets, setShowOwnedAssets] = React$1.useState(false);
    const [timeOut, setTimeOut] = React$1.useState(null);
    const itemsPerPage = 6;
    const handleSelectClick = async (asset) => {
      try {
        const result = await app.setOutboundAssetContext(asset);
        console.log("result: ", result);
        onClose();
      } catch (e) {
        console.error(e);
      }
    };
    const onSearch = async function(searchQuery2) {
      try {
        if (!api) {
          alert("Failed to init API!");
          return;
        }
        const search = {
          limit: itemsPerPage,
          skip: currentPageIndex * itemsPerPage,
          // Use currentPageIndex for pagination
          collection: "assets",
          searchQuery: searchQuery2,
          searchFields: ["name", "symbol"]
        };
        const info = await api.SearchAtlas(search);
        const currentPageData = info.data.results;
        setCurrentPage(currentPageData);
        setTotalAssets(info.data.total);
      } catch (e) {
        console.error(e);
      }
    };
    const fetchPage = async (pageIndex) => {
      try {
        if (!api) {
          alert("Failed to init API!");
          return;
        }
        console.log("balances: ", balances);
        if (balances) {
          setShowOwnedAssets(true);
          setCurrentPage(balances);
          console.log("balances: ", app.balances);
        }
      } catch (e) {
        console.error(e);
      }
    };
    React$1.useEffect(() => {
      fetchPage();
    }, [currentPageIndex, showOwnedAssets, balances]);
    const [totalAssets, setTotalAssets] = React$1.useState(0);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Stack, { spacing: 4, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(react.InputGroup, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(react.InputLeftElement, { pointerEvents: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Search2Icon, { color: "gray.300" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          react.Input,
          {
            placeholder: "Bitcoin...",
            type: "text",
            value: searchQuery,
            onChange: (e) => {
              setSearchQuery(e.target.value);
              if (timeOut) {
                clearTimeout(timeOut);
              }
              setTimeOut(
                // @ts-ignore
                setTimeout(() => {
                  setCurrentPageIndex(0);
                  onSearch(e.target.value);
                }, 1e3)
              );
            }
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Box, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Text, { fontSize: "2xl", children: [
          "Total Assets: ",
          totalAssets
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          react.Checkbox,
          {
            isChecked: showOwnedAssets,
            onChange: () => setShowOwnedAssets(!showOwnedAssets),
            children: "Show only owned assets"
          }
        ),
        currentPage.map((asset, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.HStack, { spacing: 4, alignItems: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Box, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
              "name: ",
              asset.asset.name
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
              "chain: ",
              asset.asset.chain
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
              "symbol: ",
              asset.asset.symbol
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
              "balance: ",
              asset.assetAmount.toString()
            ] })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.HStack, { mt: 2, spacing: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            react.Button,
            {
              size: "sm",
              variant: "outline",
              onClick: () => handleSelectClick(asset),
              children: "Select"
            }
          ) })
        ] }, index2))
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(react.HStack, { mt: 4, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          react.Button,
          {
            isDisabled: currentPageIndex === 0,
            onClick: () => setCurrentPageIndex(currentPageIndex - 1),
            children: "Previous Page"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          react.Button,
          {
            isDisabled: currentPage.length < itemsPerPage,
            onClick: () => setCurrentPageIndex(currentPageIndex + 1),
            children: "Next Page"
          }
        )
      ] })
    ] });
  }
  const MiddleEllipsis = ({ text }) => {
    const maxLength = 20;
    const ellipsis = "...";
    if (!text || text.length <= maxLength) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: text });
    }
    const frontPart = text.slice(0, 7);
    const backPart = text.slice(-10);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
      frontPart,
      ellipsis,
      backPart
    ] });
  };
  function BlockchainSelect({ onClose }) {
    const { state: state2, dispatch: dispatch2 } = usePioneer();
    const { api, app, user } = state2;
    const [searchQuery, setSearchQuery] = React$1.useState("");
    const [currentPage, setCurrentPage] = React$1.useState([]);
    const [currentPageIndex, setCurrentPageIndex] = React$1.useState(0);
    const [showOwnedAssets, setShowOwnedAssets] = React$1.useState(false);
    const [timeOut, setTimeOut] = React$1.useState(null);
    const itemsPerPage = 6;
    const handleSelectClick = async (asset) => {
      try {
        const changeAssetContext = await app.setAssetContext(asset);
        onClose();
      } catch (e) {
        console.error(e);
      }
    };
    const onSearch = async function(searchQuery2) {
      try {
        if (!api) {
          alert("Failed to init API!");
          return;
        }
        const search = {
          limit: itemsPerPage,
          skip: currentPageIndex * itemsPerPage,
          // Use currentPageIndex for pagination
          collection: "blockchains",
          searchQuery: searchQuery2,
          searchFields: ["name", "symbol"]
        };
        const info = await api.SearchAtlas(search);
        const currentPageData = info.data.results;
        setCurrentPage(currentPageData);
        setTotalBlockchains(info.data.total);
      } catch (e) {
        console.error(e);
      }
    };
    const fetchPage = async (pageIndex) => {
      try {
        if (!api) {
          alert("Failed to init API!");
          return;
        }
        const search = {
          limit: itemsPerPage,
          skip: pageIndex * itemsPerPage,
          collection: "blockchains",
          ownedBy: showOwnedAssets ? user.id : void 0
        };
        const info = await api.SearchAtlas(search);
        const currentPageData = info.data.results;
        setCurrentPage(currentPageData);
        setTotalBlockchains(info.data.total);
      } catch (e) {
        console.error(e);
      }
    };
    React$1.useEffect(() => {
      fetchPage(currentPageIndex);
    }, [currentPageIndex, showOwnedAssets]);
    const [totalBlockchains, setTotalBlockchains] = React$1.useState(0);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Stack, { spacing: 4, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(react.InputGroup, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(react.InputLeftElement, { pointerEvents: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Search2Icon, { color: "gray.300" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          react.Input,
          {
            placeholder: "Bitcoin...",
            type: "text",
            value: searchQuery,
            onChange: (e) => {
              setSearchQuery(e.target.value);
              if (timeOut) {
                clearTimeout(timeOut);
              }
              setTimeOut(
                // @ts-ignore
                setTimeout(() => {
                  setCurrentPageIndex(0);
                  onSearch(e.target.value);
                }, 1e3)
              );
            }
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Box, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Text, { fontSize: "2xl", children: [
          "Total Chains: ",
          totalBlockchains
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          react.Checkbox,
          {
            isChecked: showOwnedAssets,
            onChange: () => setShowOwnedAssets(!showOwnedAssets),
            children: "Show only blockchains you have assets on"
          }
        ),
        currentPage.map((blockchain, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(react.HStack, { spacing: 4, alignItems: "center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(react.Avatar, { src: blockchain == null ? void 0 : blockchain.image }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Box, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
                "blockchain: ",
                /* @__PURE__ */ jsxRuntimeExports.jsx(MiddleEllipsis, { text: blockchain == null ? void 0 : blockchain.caip })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
                "name: ",
                blockchain.name
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.HStack, { mt: 2, spacing: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            react.Button,
            {
              size: "sm",
              variant: "outline",
              onClick: () => handleSelectClick(blockchain),
              children: "Select"
            }
          ) })
        ] }, index2))
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(react.HStack, { mt: 4, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          react.Button,
          {
            isDisabled: currentPageIndex === 0,
            onClick: () => setCurrentPageIndex(currentPageIndex - 1),
            children: "Previous Page"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          react.Button,
          {
            isDisabled: currentPage.length < itemsPerPage,
            onClick: () => setCurrentPageIndex(currentPageIndex + 1),
            children: "Next Page"
          }
        )
      ] })
    ] });
  }
  function WalletSelect({ onClose }) {
    const { state: state2, dispatch: dispatch2 } = usePioneer();
    const { api, app, user } = state2;
    const [context2, setContext] = React$1.useState(null);
    const [walletType, setWalletType] = React$1.useState("");
    const [pubkeyContext, setPubkeyContext] = React$1.useState("");
    const handleSelectClick = async (wallet2) => {
      var _a3, _b;
      try {
        const matchedWallet = app.wallets.find(
          (w) => w.context === wallet2.context
        );
        if (matchedWallet) {
          setWalletType(matchedWallet.type);
          const context22 = await app.setContext(matchedWallet.wallet.context);
          console.log("result change: ", context22);
          setContext(app.context);
          const pubkeyContext2 = ((_a3 = app == null ? void 0 : app.pubkeyContext) == null ? void 0 : _a3.master) || ((_b = app == null ? void 0 : app.pubkeyContext) == null ? void 0 : _b.pubkey);
          setPubkeyContext(pubkeyContext2);
          dispatch2({ type: "SET_CONTEXT", payload: app.context });
          dispatch2({ type: "SET_PUBKEY_CONTEXT", payload: app.pubkeyContext });
          onClose();
        } else {
        }
      } catch (e) {
        console.error(e);
      }
    };
    const onRender = async () => {
      try {
        dispatch2({ type: "SET_CONTEXT", payload: context2 });
        setContext(app == null ? void 0 : app.context);
      } catch (e) {
        console.error(e);
      }
    };
    React$1.useEffect(() => {
      onRender();
    }, [app, app == null ? void 0 : app.context, app == null ? void 0 : app.wallets]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(react.Stack, { spacing: 4, children: /* @__PURE__ */ jsxRuntimeExports.jsx(react.Box, { children: app == null ? void 0 : app.wallets.map((wallet2, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Box, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(react.HStack, { spacing: 4, alignItems: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Box, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
          "type: ",
          wallet2.type
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
          "context: ",
          wallet2.context
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(react.HStack, { mt: 2, spacing: 2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        react.Button,
        {
          size: "sm",
          variant: "outline",
          onClick: () => handleSelectClick(wallet2),
          children: "Select"
        }
      ) })
    ] }, index2)) }) });
  }
  const Basic = () => {
    var _a3;
    const { state: state2 } = usePioneer();
    const {
      api,
      app,
      context: context2,
      assetContext,
      blockchainContext,
      pubkeyContext,
      modals
    } = state2;
    const [address2, setAddress] = React$1.useState("");
    React$1.useState("");
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(react.TableContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Table, { variant: "simple", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(react.Thead, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Tr, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(react.Th, { children: "Context" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(react.Th, { children: "Value" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Tbody, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Tr, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.Td, { children: "Wallet Context" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.Td, { children: context2 })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Tr, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.Td, { children: "Asset Context" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.Td, { children: (_a3 = assetContext == null ? void 0 : assetContext.asset) == null ? void 0 : _a3.name })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Tr, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.Td, { children: "Blockchain Context" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.Td, { children: blockchainContext == null ? void 0 : blockchainContext.name })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Tr, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.Td, { children: "Address for context" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.Td, { children: address2 })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Tr, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.Td, { children: "Outbound asset context" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.Td, { children: address2 }),
          " "
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(react.Tfoot, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Tr, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(react.Th, { children: "Context" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(react.Th, { children: "Value" })
      ] }) })
    ] }) }) });
  };
  const Balances = ({ openModal }) => {
    const { state: state2 } = usePioneer();
    const {
      api,
      app,
      balances,
      context: context2,
      assetContext,
      blockchainContext,
      pubkeyContext,
      modals
    } = state2;
    React$1.useState("");
    React$1.useState("");
    const [balancesLocal, setBalancesLocal] = React$1.useState([]);
    React$1.useEffect(() => {
      console.log("balances: ", balances);
      if (balances) {
        setBalancesLocal(balances);
      }
    }, [balances]);
    if (balancesLocal.length == 0) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(react.Spinner, {});
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(react.Stack, { spacing: 4, children: balancesLocal.map((balance, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Card, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(react.CardHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(react.Heading, { size: "md", children: balance.asset.name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(react.CardBody, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Stack, { divider: /* @__PURE__ */ jsxRuntimeExports.jsx(react.StackDivider, {}), spacing: "4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.Heading, { size: "xs", textTransform: "uppercase", children: "Chain" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.Text, { pt: "2", fontSize: "sm", children: balance.asset.chain })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Box, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.Heading, { size: "xs", textTransform: "uppercase", children: "Amount" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.Text, { pt: "2", fontSize: "sm", children: balance.assetAmount.toString() })
        ] })
      ] }) })
    ] }, index2)) });
  };
  const Transfer = ({ openModal }) => {
    var _a3, _b, _c, _d, _e;
    const toast = react.useToast();
    const { state: state2 } = usePioneer();
    const {
      api,
      app,
      context: context2,
      assetContext,
      blockchainContext,
      pubkeyContext,
      modals,
      balances
    } = state2;
    const [isSubmitting, setIsSubmitting] = React$1.useState(false);
    React$1.useState("");
    const [inputAmount, setInputAmount] = React$1.useState("");
    const [sendAmount, setSendAmount] = React$1.useState();
    const [recipient, setRecipient] = React$1.useState("");
    const handleInputChange = (value2) => {
      setInputAmount(value2);
      if (!assetContext)
        return;
    };
    const handleSend = React$1.useCallback(async () => {
      if (!assetContext || !inputAmount || !app || !app.swapKit || !sendAmount)
        return;
      if (!recipient) {
        toast({
          title: "Error",
          description: "Must select a recipient",
          status: "error",
          duration: 3e3,
          isClosable: true
        });
        return;
      }
    }, [
      assetContext,
      inputAmount,
      app,
      app == null ? void 0 : app.swapKit,
      recipient,
      sendAmount,
      toast
    ]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(react.VStack, { spacing: 5, align: "start", p: 6, borderRadius: "md", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(react.Heading, { as: "h1", size: "lg", children: "Send Crypto!" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Text, { children: [
        "Asset: ",
        ((_a3 = assetContext == null ? void 0 : assetContext.asset) == null ? void 0 : _a3.name) || "N/A"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Text, { children: [
        "Chain: ",
        ((_b = assetContext == null ? void 0 : assetContext.asset) == null ? void 0 : _b.chain) || "N/A"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Text, { children: [
        "Symbol: ",
        ((_c = assetContext == null ? void 0 : assetContext.asset) == null ? void 0 : _c.symbol) || "N/A"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(react.Button, { onClick: () => openModal("Select Asset"), isDisabled: !balances, children: "Select Asset" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Grid, { templateColumns: "repeat(2, 1fr)", gap: 6, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(react.FormControl, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.FormLabel, { children: "Recipient:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            react.Input,
            {
              onChange: (e) => setRecipient(e.target.value),
              placeholder: "Address",
              value: recipient
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(react.FormControl, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.FormLabel, { children: "Input Amount:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            react.Input,
            {
              onChange: (e) => handleInputChange(e.target.value),
              placeholder: "0.0",
              value: inputAmount
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Text, { children: [
        "Available Balance: ",
        ((_d = assetContext == null ? void 0 : assetContext.assetAmount) == null ? void 0 : _d.toString()) || "N/A",
        " (",
        ((_e = assetContext == null ? void 0 : assetContext.asset) == null ? void 0 : _e.symbol) || "N/A",
        ")"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(react.Button, { mt: 4, isLoading: isSubmitting, onClick: handleSend, w: "full", children: isSubmitting ? /* @__PURE__ */ jsxRuntimeExports.jsx(react.Spinner, { size: "xs" }) : "Send" })
    ] });
  };
  const Home = () => {
    const { state: state2, onStart } = usePioneer();
    let { txid } = useParams();
    const {
      api,
      app,
      context: context2,
      assetContext,
      blockchainContext,
      pubkeyContext,
      modals
    } = state2;
    const [address2, setAddress] = React$1.useState("");
    const [modalType, setModalType] = React$1.useState("");
    const { isOpen, onOpen, onClose } = react.useDisclosure();
    const [txHash, setTxhash] = React$1.useState(null);
    const [step, setStep] = React$1.useState(0);
    React$1.useEffect(() => {
      if (txid) {
        setTxhash(txid);
        setStep(2);
      }
      onStart();
    }, []);
    React$1.useEffect(() => {
      console.log("2 pubkeyContext: ", pubkeyContext);
      if (pubkeyContext)
        setAddress(
          (pubkeyContext == null ? void 0 : pubkeyContext.master) || (pubkeyContext == null ? void 0 : pubkeyContext.pubkey) || pubkeyContext
        );
    }, [pubkeyContext]);
    const openModal = (type2) => {
      setModalType(type2);
      onOpen();
    };
    const refresh = async () => {
      console.log("2 pubkeyContext: ", pubkeyContext);
      console.log("2 balances: ", app.balances);
      if (pubkeyContext)
        setAddress(
          (pubkeyContext == null ? void 0 : pubkeyContext.master) || (pubkeyContext == null ? void 0 : pubkeyContext.pubkey) || pubkeyContext
        );
      console.log("pubkeyContext: ", pubkeyContext);
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Modal, { isOpen, onClose: () => onClose(), size: "xl", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(react.ModalOverlay, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(react.ModalContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.ModalHeader, { children: modalType }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.ModalCloseButton, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(react.ModalBody, { children: [
            modalType === "Select wallet" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(WalletSelect, { onClose }) }),
            modalType === "Select Asset" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AssetSelect, { onClose, onlyOwned: true }) }),
            modalType === "Select Blockchain" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(BlockchainSelect, { onClose }) }),
            modalType === "View Address" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              JSON.stringify(pubkeyContext),
              " address: ",
              address2
            ] }),
            modalType === "Select Outbound" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(OutputSelect, { onClose, onlyOwned: false }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.ModalFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(react.Button, { colorScheme: "blue", onClick: onClose, children: "Close" }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(react.Tabs, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(react.TabList, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.Tab, { children: "Context" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.Tab, { children: "balances" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.Tab, { children: "Transfer" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.Tab, { children: "Swaps" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.Tab, { children: "Earn" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.Tab, { children: "Borrow" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(react.TabPanels, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.TabPanel, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Basic, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.TabPanel, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Balances, { openModal }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.TabPanel, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Transfer, { openModal }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.TabPanel, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.TabPanel, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "Earn" }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(react.TabPanel, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "Borrow" }) }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(react.Button, { onClick: refresh, children: "refresh" })
    ] });
  };
  const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: Home
  }, Symbol.toStringTag, { value: "Module" }));
  exports2.PioneerProvider = PioneerProvider;
  exports2.usePioneer = usePioneer;
  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
});
