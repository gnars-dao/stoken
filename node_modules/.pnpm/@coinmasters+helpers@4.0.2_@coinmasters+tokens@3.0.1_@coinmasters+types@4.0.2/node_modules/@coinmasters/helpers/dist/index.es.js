var bt = Object.defineProperty;
var yt = (r, t, e) => t in r ? bt(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e;
var f = (r, t, e) => (yt(r, typeof t != "symbol" ? t + "" : t, e), e), wt = (r, t, e) => {
  if (!t.has(r))
    throw TypeError("Cannot " + e);
};
var $ = (r, t, e) => {
  if (t.has(r))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(r) : t.set(r, e);
};
var m = (r, t, e) => (wt(r, t, "access private method"), e);
import { FeeOption as L, BaseDecimal as d, Chain as o, EVMChainList as At, ChainToRPC as vt, MemoType as g } from "@coinmasters/types";
const Tt = "0x313ce567", it = async ({ chain: r, to: t }) => {
  try {
    const { result: e } = await Zt.post(vt[r], {
      headers: {
        accept: "*/*",
        "content-type": "application/json",
        "cache-control": "no-cache"
      },
      body: JSON.stringify({
        id: 44,
        jsonrpc: "2.0",
        method: "eth_call",
        params: [{ to: t.toLowerCase(), data: Tt }, "latest"]
      })
    });
    return parseInt(BigInt(e).toString());
  } catch (e) {
    return console.error(e), d[r];
  }
}, $t = async (r) => {
  if (r === o.Ethereum)
    return d.ETH;
  const [, t] = r.split("-");
  return t != null && t.startsWith("0x") ? it({ chain: o.Ethereum, to: t }) : d.ETH;
}, Rt = async (r) => {
  const [, t] = r.split("-");
  return t != null && t.startsWith("0x") ? it({ chain: o.Avalanche, to: t.toLowerCase() }) : d.AVAX;
}, St = async (r) => r === o.BinanceSmartChain ? d.BSC : d.BSC, Ct = async ({ chain: r, symbol: t }) => {
  switch (r) {
    case o.Ethereum:
      return $t(t);
    case o.Avalanche:
      return Rt(t);
    case o.BinanceSmartChain:
      return St(t);
    default:
      return d[r];
  }
}, ie = {
  [L.Average]: 1.2,
  [L.Fast]: 1.5,
  [L.Fastest]: 2
}, ot = ({ chain: r, symbol: t }) => {
  switch (r) {
    case o.Bitcoin:
    case o.BitcoinCash:
    case o.Dash:
    case o.Digibyte:
    case o.Digibyte:
    case o.Zcash:
    case o.Ripple:
    case o.Litecoin:
    case o.Dogecoin:
    case o.Binance:
    case o.Ethereum:
    case o.Avalanche:
      return t === r;
    case o.Arbitrum:
    case o.Optimism:
      return t === "ETH";
    case o.Maya:
      return t === "CACAO";
    case o.Kujira:
      return t === "KUJI";
    case o.Cosmos:
      return t === "ATOM";
    case o.Polygon:
      return t === "MATIC";
    case o.BinanceSmartChain:
      return t === "BNB";
    case o.THORChain:
      return t === "RUNE";
  }
}, It = (r) => {
  switch (r) {
    case "ETH.THOR":
      return { identifier: "ETH.THOR-0xa5f2211b9b8170f694421f2046281775e8468044", decimal: 18 };
    case "ETH.vTHOR":
      return { identifier: "ETH.vTHOR-0x815c23eca83261b6ec689b60cc4a58b54bc24d8d", decimal: 18 };
    case o.Cosmos:
      return { identifier: "GAIA.ATOM", decimal: d[r] };
    case o.THORChain:
      return { identifier: "THOR.RUNE", decimal: d[r] };
    case o.BinanceSmartChain:
      return { identifier: "BSC.BNB", decimal: d[r] };
    case o.Maya:
      return { identifier: "MAYA.CACAO", decimal: d.MAYA };
    case "MAYA.MAYA":
      return { identifier: "MAYA.MAYA", decimal: 4 };
    case o.Kujira:
    case o.Arbitrum:
    case o.Optimism:
    case o.BitcoinCash:
    case o.Litecoin:
    case o.Dogecoin:
    case o.Binance:
    case o.Avalanche:
    case o.Polygon:
    case o.Bitcoin:
    case o.Ethereum:
      return { identifier: `${r}.${r}`, decimal: d[r] };
  }
}, Ot = ({ chain: r, symbol: t }) => {
  if (t.includes("/"))
    return "Synth";
  switch (r) {
    case o.Bitcoin:
    case o.BitcoinCash:
    case o.Dogecoin:
    case o.Litecoin:
    case o.Maya:
    case o.THORChain:
      return "Native";
    case o.Cosmos:
      return t === "ATOM" ? "Native" : o.Cosmos;
    case o.Kujira:
      return t === o.Kujira ? "Native" : o.Kujira;
    case o.Binance:
      return t === o.Binance ? "Native" : "BEP2";
    case o.BinanceSmartChain:
      return t === o.Binance ? "Native" : "BEP20";
    case o.Ethereum:
      return t === o.Ethereum ? "Native" : "ERC20";
    case o.Avalanche:
      return t === o.Avalanche ? "Native" : o.Avalanche;
    case o.Polygon:
      return t === o.Polygon ? "Native" : "POLYGON";
    case o.Arbitrum:
      return [o.Ethereum, o.Arbitrum].includes(t) ? "Native" : "ARBITRUM";
    case o.Optimism:
      return [o.Ethereum, o.Optimism].includes(t) ? "Native" : "OPTIMISM";
  }
}, oe = (r) => {
  var a;
  const [t, ...e] = r.split("."), s = r.includes("/"), n = e.join("."), i = (a = n == null ? void 0 : n.split("-")) == null ? void 0 : a[0];
  return { chain: t, symbol: n, ticker: i, synth: s };
}, Et = new RegExp(
  /(.)\1{6}|\.ORG|\.NET|\.FINANCE|\.COM|WWW|HTTP|\\\\|\/\/|[\s$%:[\]]/,
  "gmi"
), Mt = (r) => {
  const [t, e] = r.split(".");
  if (!At.includes(t))
    return !0;
  const [, s] = e.split("-");
  return ot({ chain: t, symbol: e }) || !!s;
}, ae = (r) => r.filter((t) => {
  const e = `${t.chain}.${t.symbol}`;
  return !Et.test(e) && Mt(e) && t.value !== "0";
}), Bt = ({
  liquidityUnits: r,
  poolUnits: t,
  runeDepth: e
}) => {
  const s = p(r), n = p(t), i = p(e), a = s.mul(i), c = n.mul(n).mul(2), u = n.mul(s).mul(2), h = s.mul(s), l = n.mul(n).mul(n);
  return a.mul(c.sub(u).add(h)).div(l);
}, xt = ({
  liquidityUnits: r,
  poolUnits: t,
  assetDepth: e
}) => {
  const s = p(r), n = p(t), i = p(e), a = s.mul(i), c = n.mul(n).mul(2), u = n.mul(s).mul(2), h = s.mul(s), l = a.mul(c.sub(u).add(h)), _ = n.mul(n).mul(n);
  return l.div(_);
}, ce = ({
  percent: r,
  runeDepth: t,
  liquidityUnits: e,
  poolUnits: s
}) => Bt({ runeDepth: t, liquidityUnits: e, poolUnits: s }).mul(r), ue = ({
  percent: r,
  assetDepth: t,
  liquidityUnits: e,
  poolUnits: s
}) => xt({ assetDepth: t, liquidityUnits: e, poolUnits: s }).mul(r), p = (r) => b.fromBigInt(BigInt(r), d.THOR), qt = ({
  liquidityUnits: r,
  poolUnits: t,
  runeDepth: e,
  assetDepth: s
}) => ({
  assetAmount: p(s).mul(r).div(t),
  runeAmount: p(e).mul(r).div(t)
}), le = ({
  liquidityUnits: r,
  poolUnits: t,
  runeDepth: e,
  assetDepth: s,
  percent: n
}) => Object.fromEntries(
  Object.entries(qt({ liquidityUnits: r, poolUnits: t, runeDepth: e, assetDepth: s })).map(
    ([i, a]) => [i, a.mul(n)]
  )
), he = ({
  runeDepth: r,
  poolUnits: t,
  assetDepth: e,
  liquidityUnits: s,
  runeAmount: n,
  assetAmount: i
}) => {
  const a = new b({ value: r, decimal: 8 }), c = new b({ value: e, decimal: 8 }), u = new b({ value: t, decimal: 8 }), h = new b({ value: n, decimal: 8 }), l = new b({ value: i, decimal: 8 }), _ = h.mul(c), T = l.mul(a), j = h.mul(l), pt = a.mul(c), ft = u.mul(_.add(T.add(j.mul(2)))), _t = _.add(T.add(pt.mul(2))), Q = ft.div(_t), H = p(s).add(Q);
  if (Q.getBaseValue("number") === 0)
    return H.div(u).getBaseValue("number");
  const gt = u.add(H);
  return H.div(gt).getBaseValue("number");
}, de = ({
  runeAmount: r,
  assetAmount: t,
  runeDepth: e,
  assetDepth: s
}) => {
  if (r === "0" || t === "0" || e === "0" || s === "0")
    return 0;
  const n = p(e), i = p(s), a = p(t), c = p(r), u = a.mul(n).sub(i.mul(c)), h = i.mul(c).add(n.mul(i));
  return Math.abs(u.div(h).getBaseValue("number"));
}, kt = ({
  symbol: r,
  ticker: t,
  chain: e
}) => e === "ETH" && t !== "ETH" ? `${t}-${r.slice(-3)}` : r, me = (r, t) => {
  switch (r) {
    case g.LEAVE:
    case g.BOND: {
      const { address: e } = t;
      return `${r}:${e}`;
    }
    case g.UNBOND: {
      const { address: e, unbondAmount: s } = t;
      return `${r}:${e}:${s * 10 ** 8}`;
    }
    case g.THORNAME_REGISTER: {
      const { name: e, chain: s, address: n, owner: i } = t;
      return `${r}:${e}:${s}:${n}${i ? `:${i}` : ""}`;
    }
    case g.DEPOSIT: {
      const { chain: e, symbol: s, address: n, singleSide: i } = t;
      return i ? `${r}:${e}/${s}::t:0` : `${r}:${e}.${s}:${n || ""}:t:0`;
    }
    case g.WITHDRAW: {
      const { chain: e, ticker: s, symbol: n, basisPoints: i, targetAssetString: a, singleSide: c } = t, u = !c && a ? `:${a}` : "", h = kt({ chain: e, symbol: n, ticker: s });
      return `${r}:${e}${c ? "/" : "."}${h}:${i}${u}`;
    }
    case g.OPEN_LOAN:
    case g.CLOSE_LOAN: {
      const { asset: e, address: s } = t;
      return `${r}:${e}:${s}`;
    }
    default:
      return "";
  }
}, pe = (r) => {
  if (r < 0)
    throw new Error("Invalid number of year");
  return 10 + r;
}, fe = (r) => {
  if (r.length > 30)
    return !1;
  const t = /^[a-zA-Z0-9+_-]+$/g;
  return !!r.match(t);
}, _e = ([r, t, e, s, n]) => `${r}'/${t}'/${e}'/${s}${typeof n != "number" ? "" : `/${n}`}`;
class X extends Error {
  constructor(t, e, s) {
    const n = t.status || t.status === 0 ? t.status : "", i = t.statusText || "", a = `${n} ${i}`.trim(), c = a ? `status code ${a}` : "an unknown error";
    super(`Request failed with ${c}`), Object.defineProperty(this, "response", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "request", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "options", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "HTTPError", this.response = t, this.request = e, this.options = s;
  }
}
class at extends Error {
  constructor(t) {
    super("Request timed out"), Object.defineProperty(this, "request", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "TimeoutError", this.request = t;
  }
}
const q = (r) => r !== null && typeof r == "object", B = (...r) => {
  for (const t of r)
    if ((!q(t) || Array.isArray(t)) && t !== void 0)
      throw new TypeError("The `options` argument must be an object");
  return J({}, ...r);
}, ct = (r = {}, t = {}) => {
  const e = new globalThis.Headers(r), s = t instanceof globalThis.Headers, n = new globalThis.Headers(t);
  for (const [i, a] of n.entries())
    s && a === "undefined" || a === void 0 ? e.delete(i) : e.set(i, a);
  return e;
}, J = (...r) => {
  let t = {}, e = {};
  for (const s of r)
    if (Array.isArray(s))
      Array.isArray(t) || (t = []), t = [...t, ...s];
    else if (q(s)) {
      for (let [n, i] of Object.entries(s))
        q(i) && n in t && (i = J(t[n], i)), t = { ...t, [n]: i };
      q(s.headers) && (e = ct(e, s.headers), t.headers = e);
    }
  return t;
}, Vt = (() => {
  let r = !1, t = !1;
  const e = typeof globalThis.ReadableStream == "function", s = typeof globalThis.Request == "function";
  return e && s && (t = new globalThis.Request("https://empty.invalid", {
    body: new globalThis.ReadableStream(),
    method: "POST",
    // @ts-expect-error - Types are outdated.
    get duplex() {
      return r = !0, "half";
    }
  }).headers.has("Content-Type")), r && !t;
})(), Pt = typeof globalThis.AbortController == "function", Nt = typeof globalThis.ReadableStream == "function", jt = typeof globalThis.FormData == "function", ut = ["get", "post", "put", "patch", "head", "delete"], Ht = {
  json: "application/json",
  text: "text/*",
  formData: "multipart/form-data",
  arrayBuffer: "*/*",
  blob: "*/*"
}, D = 2147483647, lt = Symbol("stop"), Lt = {
  json: !0,
  parseJson: !0,
  searchParams: !0,
  prefixUrl: !0,
  retry: !0,
  timeout: !0,
  hooks: !0,
  throwHttpErrors: !0,
  onDownloadProgress: !0,
  fetch: !0
}, Dt = {
  method: !0,
  headers: !0,
  body: !0,
  mode: !0,
  credentials: !0,
  cache: !0,
  redirect: !0,
  referrer: !0,
  referrerPolicy: !0,
  integrity: !0,
  keepalive: !0,
  signal: !0,
  window: !0,
  dispatcher: !0,
  duplex: !0
}, Ut = (r) => ut.includes(r) ? r.toUpperCase() : r, Ft = ["get", "put", "head", "delete", "options", "trace"], Wt = [408, 413, 429, 500, 502, 503, 504], ht = [413, 429, 503], Z = {
  limit: 2,
  methods: Ft,
  statusCodes: Wt,
  afterStatusCodes: ht,
  maxRetryAfter: Number.POSITIVE_INFINITY,
  backoffLimit: Number.POSITIVE_INFINITY,
  delay: (r) => 0.3 * 2 ** (r - 1) * 1e3
}, Gt = (r = {}) => {
  if (typeof r == "number")
    return {
      ...Z,
      limit: r
    };
  if (r.methods && !Array.isArray(r.methods))
    throw new Error("retry.methods must be an array");
  if (r.statusCodes && !Array.isArray(r.statusCodes))
    throw new Error("retry.statusCodes must be an array");
  return {
    ...Z,
    ...r,
    afterStatusCodes: ht
  };
};
async function Yt(r, t, e, s) {
  return new Promise((n, i) => {
    const a = setTimeout(() => {
      e && e.abort(), i(new at(r));
    }, s.timeout);
    s.fetch(r, t).then(n).catch(i).then(() => {
      clearTimeout(a);
    });
  });
}
async function zt(r, { signal: t }) {
  return new Promise((e, s) => {
    t && (t.throwIfAborted(), t.addEventListener("abort", n, { once: !0 }));
    function n() {
      clearTimeout(i), s(t.reason);
    }
    const i = setTimeout(() => {
      t == null || t.removeEventListener("abort", n), e();
    }, r);
  });
}
const Jt = (r, t) => {
  const e = {};
  for (const s in t)
    !(s in Dt) && !(s in Lt) && !(s in r) && (e[s] = t[s]);
  return e;
};
class V {
  static create(t, e) {
    const s = new V(t, e), n = async () => {
      if (typeof s._options.timeout == "number" && s._options.timeout > D)
        throw new RangeError(`The \`timeout\` option cannot be greater than ${D}`);
      await Promise.resolve();
      let c = await s._fetch();
      for (const u of s._options.hooks.afterResponse) {
        const h = await u(s.request, s._options, s._decorateResponse(c.clone()));
        h instanceof globalThis.Response && (c = h);
      }
      if (s._decorateResponse(c), !c.ok && s._options.throwHttpErrors) {
        let u = new X(c, s.request, s._options);
        for (const h of s._options.hooks.beforeError)
          u = await h(u);
        throw u;
      }
      if (s._options.onDownloadProgress) {
        if (typeof s._options.onDownloadProgress != "function")
          throw new TypeError("The `onDownloadProgress` option must be a function");
        if (!Nt)
          throw new Error("Streams are not supported in your environment. `ReadableStream` is missing.");
        return s._stream(c.clone(), s._options.onDownloadProgress);
      }
      return c;
    }, a = s._options.retry.methods.includes(s.request.method.toLowerCase()) ? s._retry(n) : n();
    for (const [c, u] of Object.entries(Ht))
      a[c] = async () => {
        s.request.headers.set("accept", s.request.headers.get("accept") || u);
        const l = (await a).clone();
        if (c === "json") {
          if (l.status === 204 || (await l.clone().arrayBuffer()).byteLength === 0)
            return "";
          if (e.parseJson)
            return e.parseJson(await l.text());
        }
        return l[c]();
      };
    return a;
  }
  // eslint-disable-next-line complexity
  constructor(t, e = {}) {
    if (Object.defineProperty(this, "request", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "abortController", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_retryCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_input", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_options", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._input = t, this._options = {
      // TODO: credentials can be removed when the spec change is implemented in all browsers. Context: https://www.chromestatus.com/feature/4539473312350208
      credentials: this._input.credentials || "same-origin",
      ...e,
      headers: ct(this._input.headers, e.headers),
      hooks: J({
        beforeRequest: [],
        beforeRetry: [],
        beforeError: [],
        afterResponse: []
      }, e.hooks),
      method: Ut(e.method ?? this._input.method),
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      prefixUrl: String(e.prefixUrl || ""),
      retry: Gt(e.retry),
      throwHttpErrors: e.throwHttpErrors !== !1,
      timeout: e.timeout ?? 1e4,
      fetch: e.fetch ?? globalThis.fetch.bind(globalThis)
    }, typeof this._input != "string" && !(this._input instanceof URL || this._input instanceof globalThis.Request))
      throw new TypeError("`input` must be a string, URL, or Request");
    if (this._options.prefixUrl && typeof this._input == "string") {
      if (this._input.startsWith("/"))
        throw new Error("`input` must not begin with a slash when using `prefixUrl`");
      this._options.prefixUrl.endsWith("/") || (this._options.prefixUrl += "/"), this._input = this._options.prefixUrl + this._input;
    }
    if (Pt) {
      if (this.abortController = new globalThis.AbortController(), this._options.signal) {
        const s = this._options.signal;
        this._options.signal.addEventListener("abort", () => {
          this.abortController.abort(s.reason);
        });
      }
      this._options.signal = this.abortController.signal;
    }
    if (Vt && (this._options.duplex = "half"), this.request = new globalThis.Request(this._input, this._options), this._options.searchParams) {
      const n = "?" + (typeof this._options.searchParams == "string" ? this._options.searchParams.replace(/^\?/, "") : new URLSearchParams(this._options.searchParams).toString()), i = this.request.url.replace(/(?:\?.*?)?(?=#|$)/, n);
      (jt && this._options.body instanceof globalThis.FormData || this._options.body instanceof URLSearchParams) && !(this._options.headers && this._options.headers["content-type"]) && this.request.headers.delete("content-type"), this.request = new globalThis.Request(new globalThis.Request(i, { ...this.request }), this._options);
    }
    this._options.json !== void 0 && (this._options.body = JSON.stringify(this._options.json), this.request.headers.set("content-type", this._options.headers.get("content-type") ?? "application/json"), this.request = new globalThis.Request(this.request, { body: this._options.body }));
  }
  _calculateRetryDelay(t) {
    if (this._retryCount++, this._retryCount < this._options.retry.limit && !(t instanceof at)) {
      if (t instanceof X) {
        if (!this._options.retry.statusCodes.includes(t.response.status))
          return 0;
        const s = t.response.headers.get("Retry-After");
        if (s && this._options.retry.afterStatusCodes.includes(t.response.status)) {
          let n = Number(s);
          return Number.isNaN(n) ? n = Date.parse(s) - Date.now() : n *= 1e3, this._options.retry.maxRetryAfter !== void 0 && n > this._options.retry.maxRetryAfter ? 0 : n;
        }
        if (t.response.status === 413)
          return 0;
      }
      const e = this._options.retry.delay(this._retryCount);
      return Math.min(this._options.retry.backoffLimit, e);
    }
    return 0;
  }
  _decorateResponse(t) {
    return this._options.parseJson && (t.json = async () => this._options.parseJson(await t.text())), t;
  }
  async _retry(t) {
    try {
      return await t();
    } catch (e) {
      const s = Math.min(this._calculateRetryDelay(e), D);
      if (s !== 0 && this._retryCount > 0) {
        await zt(s, { signal: this._options.signal });
        for (const n of this._options.hooks.beforeRetry)
          if (await n({
            request: this.request,
            options: this._options,
            error: e,
            retryCount: this._retryCount
          }) === lt)
            return;
        return this._retry(t);
      }
      throw e;
    }
  }
  async _fetch() {
    for (const e of this._options.hooks.beforeRequest) {
      const s = await e(this.request, this._options);
      if (s instanceof Request) {
        this.request = s;
        break;
      }
      if (s instanceof Response)
        return s;
    }
    const t = Jt(this.request, this._options);
    return this._options.timeout === !1 ? this._options.fetch(this.request.clone(), t) : Yt(this.request.clone(), t, this.abortController, this._options);
  }
  /* istanbul ignore next */
  _stream(t, e) {
    const s = Number(t.headers.get("content-length")) || 0;
    let n = 0;
    return t.status === 204 ? (e && e({ percent: 1, totalBytes: s, transferredBytes: n }, new Uint8Array()), new globalThis.Response(null, {
      status: t.status,
      statusText: t.statusText,
      headers: t.headers
    })) : new globalThis.Response(new globalThis.ReadableStream({
      async start(i) {
        const a = t.body.getReader();
        e && e({ percent: 0, transferredBytes: 0, totalBytes: s }, new Uint8Array());
        async function c() {
          const { done: u, value: h } = await a.read();
          if (u) {
            i.close();
            return;
          }
          if (e) {
            n += h.byteLength;
            const l = s === 0 ? 0 : n / s;
            e({ percent: l, transferredBytes: n, totalBytes: s }, h);
          }
          i.enqueue(h), await c();
        }
        await c();
      }
    }), {
      status: t.status,
      statusText: t.statusText,
      headers: t.headers
    });
  }
}
/*! MIT License Â© Sindre Sorhus */
const U = (r) => {
  const t = (e, s) => V.create(e, B(r, s));
  for (const e of ut)
    t[e] = (s, n) => V.create(s, B(r, n, { method: e }));
  return t.create = (e) => U(B(e)), t.extend = (e) => U(B(r, e)), t.stop = lt, t;
}, Kt = U(), Qt = Kt, Xt = typeof window < "u" ? {} : { referrer: "https://sk.thorswap.net", referer: "https://sk.thorswap.net" }, tt = Qt.create({ headers: Xt }), Zt = {
  get: (r, t) => tt.get(r, t).json(),
  post: (r, t) => tt.post(r, t).json()
}, et = Object.values(o), te = (r = "") => {
  const t = r.toUpperCase(), [e] = t.split(".");
  if (et.includes(e))
    return !0;
  const [s] = t.split("/");
  if (et.includes(s))
    return !0;
  throw new Error(
    `Invalid identifier: ${r}. Expected format: <Chain>.<Ticker> or <Chain>.<Ticker>-<ContractAddress>`
  );
}, I = 8, w = (r) => 10n ** BigInt(r), S = (r) => Math.log10(parseFloat(r.toString()));
function P({
  value: r,
  bigIntDecimal: t = I,
  decimal: e = I
}) {
  const s = r < 0n;
  let n = r.toString().substring(s ? 1 : 0);
  const i = e - (n.length - 1);
  i > 0 && (n = "0".repeat(i) + n);
  const a = n.length - e;
  let c = n.slice(-e);
  return parseInt(c[t]) >= 5 ? c = `${c.substring(0, t - 1)}${(parseInt(c[t - 1]) + 1).toString()}` : c = c.substring(0, t), `${s ? "-" : ""}${n.slice(0, a)}.${c}`.replace(
    /\.?0*$/,
    ""
  );
}
var v, C, y, R, N, dt, E, F, M, W;
const K = class K {
  constructor(t) {
    $(this, v);
    $(this, y);
    $(this, N);
    $(this, E);
    $(this, M);
    f(this, "decimalMultiplier", 10n ** 8n);
    f(this, "bigIntValue", 0n);
    f(this, "decimal");
    const e = G(t), s = typeof t == "object";
    this.decimal = s ? t.decimal : void 0, this.decimalMultiplier = s && "decimalMultiplier" in t ? t.decimalMultiplier : w(Math.max(st(x(e)), this.decimal || 0)), m(this, N, dt).call(this, e);
  }
  static fromBigInt(t, e) {
    return new K({
      decimal: e,
      value: P({ value: t, bigIntDecimal: e, decimal: e })
    });
  }
  static shiftDecimals({
    value: t,
    from: e,
    to: s
  }) {
    return this.fromBigInt(
      t.getBaseValue("bigint") * w(s) / w(e),
      s
    );
  }
  set(t) {
    return new this.constructor({ decimal: this.decimal, value: t, identifier: this.toString() });
  }
  add(...t) {
    return m(this, v, C).call(this, "add", ...t);
  }
  sub(...t) {
    return m(this, v, C).call(this, "sub", ...t);
  }
  mul(...t) {
    return m(this, v, C).call(this, "mul", ...t);
  }
  div(...t) {
    return m(this, v, C).call(this, "div", ...t);
  }
  gt(t) {
    return m(this, y, R).call(this, "gt", t);
  }
  gte(t) {
    return m(this, y, R).call(this, "gte", t);
  }
  lt(t) {
    return m(this, y, R).call(this, "lt", t);
  }
  lte(t) {
    return m(this, y, R).call(this, "lte", t);
  }
  eqValue(t) {
    return m(this, y, R).call(this, "eqValue", t);
  }
  // @ts-expect-error False positive
  getValue(t) {
    const e = this.formatBigIntToSafeValue(
      this.bigIntValue,
      this.decimal || S(this.decimalMultiplier)
    );
    switch (t) {
      case "number":
        return Number(e);
      case "string":
        return e;
      case "bigint":
        return this.bigIntValue * 10n ** BigInt(this.decimal || 8n) / this.decimalMultiplier;
    }
  }
  // @ts-expect-error
  getBaseValue(t) {
    const e = this.decimalMultiplier / w(this.decimal || d.THOR), s = this.bigIntValue / e;
    switch (t) {
      case "number":
        return Number(s);
      case "string":
        return s.toString();
      case "bigint":
        return s;
    }
  }
  getBigIntValue(t, e) {
    if (!e && typeof t == "object")
      return t.bigIntValue;
    const s = G(t), n = x(s);
    return n === "0" || n === "undefined" ? 0n : m(this, M, W).call(this, n, e);
  }
  toSignificant(t = 6) {
    const [e, s] = this.getValue("string").split("."), n = e || "", i = s || "";
    if ((parseInt(n) ? n.length + i.length : i.length) <= t)
      return this.getValue("string");
    if (n.length >= t)
      return n.slice(0, t).padEnd(n.length, "0");
    if (parseInt(n))
      return `${n}.${i.slice(0, t - n.length)}`.padEnd(
        t - n.length,
        "0"
      );
    const c = parseInt(i), u = `${c}`.slice(0, t);
    return `0.${u.padStart(
      i.length - `${c}`.length + u.length,
      "0"
    )}`;
  }
  toFixed(t = 6) {
    const [e, s] = this.getValue("string").split("."), n = e || "", i = s || "";
    if (parseInt(n))
      return `${n}.${i.slice(0, t)}`.padEnd(t, "0");
    const a = parseInt(i), c = `${a}`.slice(0, t);
    return `0.${c.padStart(
      i.length - `${a}`.length + c.length,
      "0"
    )}`;
  }
  toAbbreviation(t = 2) {
    const e = this.getValue("number"), s = ["", "K", "M", "B", "T", "Q", "Qi", "S"], n = Math.floor(Math.log10(Math.abs(e)) / 3), i = s[n];
    if (!i)
      return this.getValue("string");
    const a = 10 ** (n * 3);
    return `${(e / a).toFixed(t)}${i}`;
  }
  toCurrency(t = "$", {
    currencyPosition: e = "start",
    decimal: s = 2,
    decimalSeparator: n = ".",
    thousandSeparator: i = ","
  } = {}) {
    const a = this.getValue("number"), [c, u = ""] = a.toFixed(6).split("."), h = c.replace(/\B(?=(\d{3})+(?!\d))/g, i), l = !c && !u ? "0.00" : c === "0" ? `${parseFloat(`0.${u}`)}`.replace(".", n) : `${h}${parseInt(u) ? `${n}${u.slice(0, s)}` : ""}`;
    return `${e === "start" ? t : ""}${l}${e === "end" ? t : ""}`;
  }
  formatBigIntToSafeValue(t, e) {
    const s = e || this.decimal || I, n = Math.max(
      s,
      S(this.decimalMultiplier)
    ), i = t < 0n, a = t.toString().substring(i ? 1 : 0), c = n - (a.length - 1), u = c > 0 ? "0".repeat(c) + a : a, h = u.length - n;
    let l = u.slice(-n);
    return parseInt(l[s]) >= 5 ? l = `${l.substring(0, s - 1)}${(parseInt(l[s - 1]) + 1).toString()}` : l = l.substring(0, s), `${i ? "-" : ""}${u.slice(
      0,
      h
    )}.${l}`.replace(/\.?0*$/, "");
  }
};
v = new WeakSet(), C = function(t, ...e) {
  const s = m(this, E, F).call(this, this, ...e), n = Math.max(s, S(this.decimalMultiplier)), i = w(n), a = e.reduce(
    (u, h) => {
      const l = this.getBigIntValue(h, n);
      switch (t) {
        case "add":
          return u + l;
        case "sub":
          return u - l;
        case "mul":
          return u * l / i;
        case "div": {
          if (l === 0n)
            throw new RangeError("Division by zero");
          return u * i / l;
        }
        default:
          return u;
      }
    },
    //normalize is to precision multiplier base
    this.bigIntValue * i / this.decimalMultiplier
  ), c = P({
    bigIntDecimal: n,
    decimal: n,
    value: a
  });
  return new this.constructor({
    decimalMultiplier: w(n),
    decimal: this.decimal,
    value: c,
    identifier: this.toString()
  });
}, y = new WeakSet(), R = function(t, ...e) {
  const s = m(this, E, F).call(this, this, ...e), n = this.getBigIntValue(e[0], s), i = this.getBigIntValue(this, s);
  switch (t) {
    case "gt":
      return i > n;
    case "gte":
      return i >= n;
    case "lt":
      return i < n;
    case "lte":
      return i <= n;
    case "eqValue":
      return i === n;
  }
}, N = new WeakSet(), dt = function(t) {
  const e = x(t) || "0";
  this.bigIntValue = m(this, M, W).call(this, e);
}, E = new WeakSet(), F = function(...t) {
  const e = t.map((s) => typeof s == "object" ? s.decimal || S(s.decimalMultiplier) : st(x(s))).filter(Boolean);
  return Math.max(...e, I);
}, M = new WeakSet(), W = function(t, e) {
  const s = e ? w(e) : this.decimalMultiplier, n = S(s), [i = "", a = ""] = t.split(".");
  return BigInt(`${i}${a.padEnd(n, "0")}`);
};
let O = K;
const ee = Intl.NumberFormat("fullwide", {
  useGrouping: !1,
  maximumFractionDigits: 20
});
function x(r) {
  const e = `${typeof r == "number" ? ee.format(r) : G(r)}`.replaceAll(",", ".").split(".");
  return e.length > 1 ? `${e.slice(0, -1).join("")}.${e.at(-1)}` : e[0];
}
function st(r) {
  var e;
  const t = ((e = r.split(".")[1]) == null ? void 0 : e.length) || 0;
  return Math.max(t, I);
}
function G(r) {
  return typeof r == "object" ? "getValue" in r ? r.getValue("string") : r.value : r;
}
const k = (r, t) => typeof r == "bigint" ? P({ value: r, bigIntDecimal: t, decimal: t }) : r;
let Y;
const rt = (r) => {
  if (!Y)
    throw new Error("Static assets not loaded, call await AssetValue.loadStaticAssets() first");
  return Y.get(r.toUpperCase()) || { decimal: d.THOR, identifier: "" };
}, nt = async (r, t = 0) => {
  te(r);
  const e = await Ct(z(r)), s = k(t, e);
  return new A({ decimal: e, value: s, identifier: r });
};
class A extends O {
  constructor(e) {
    const s = "identifier" in e ? e.identifier : `${e.chain}.${e.symbol}`;
    super(
      e.value instanceof O ? e.value : { decimal: e.decimal, value: e.value }
    );
    f(this, "address");
    f(this, "chain");
    f(this, "isGasAsset", !1);
    f(this, "isSynthetic", !1);
    f(this, "symbol");
    f(this, "tax");
    f(this, "ticker");
    f(this, "type");
    const n = z(s);
    this.type = Ot(n), this.chain = n.chain, this.ticker = n.ticker, this.symbol = n.symbol, this.address = n.address, this.isSynthetic = n.isSynthetic, this.isGasAsset = n.isGasAsset, this.tax = e.tax;
  }
  toString(e = !1) {
    const s = this.isSynthetic ? this.symbol : this.ticker;
    return e ? (
      // ETH/THOR-0xa5f2211b9b8170f694421f2046281775e8468044 | USDT
      s
    ) : (
      // THOR.ETH/ETH | ETH.USDT-0x1234567890
      `${this.chain}.${this.symbol}`
    );
  }
  toUrl() {
    return this.isSynthetic ? `${this.chain}.${this.symbol.replace("/", ".")}` : this.toString();
  }
  eq({ chain: e, symbol: s }) {
    return this.chain === e && this.symbol === s;
  }
  static async fromString(e, s = 0) {
    return nt(e, s);
  }
  static fromStringSync(e, s = 0) {
    const { isSynthetic: n } = z(e), {
      tax: i,
      decimal: a,
      identifier: c
    } = rt(e), u = k(s, a);
    return c ? new A({ tax: i, decimal: a, identifier: c, value: u }) : n ? new A({ tax: i, decimal: 8, identifier: e, value: u }) : void 0;
  }
  static async fromIdentifier(e, s = 0) {
    return nt(e, s);
  }
  static fromIdentifierSync(e, s = 0) {
    const { decimal: n, identifier: i } = rt(e), a = k(s, n);
    return new A({ decimal: n, identifier: i, value: a });
  }
  static fromChainOrSignature(e, s = 0) {
    const { decimal: n, identifier: i } = It(e), a = k(s, n);
    return new A({ value: a, decimal: n, identifier: i });
  }
  static async loadStaticAssets() {
    return new Promise(
      async (e, s) => {
        try {
          const {
            // Omit ThorchainList from import to avoid decimals conflict (TC uses 8 for all)
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            ThorchainList: n,
            NativeList: i,
            ...a
          } = await import("@coinmasters/tokens");
          Y = [i, ...Object.values(a)].reduce(
            (u, { tokens: h }) => (h.forEach(({ identifier: l, chain: _, ...T }) => {
              const j = "decimals" in T ? T.decimals : d[_];
              u.set(l, { identifier: l, decimal: j });
            }), u),
            /* @__PURE__ */ new Map()
          ), e({ ok: !0 });
        } catch (n) {
          console.error(n), s({
            ok: !1,
            error: n,
            message: "Couldn't load static assets. Ensure you have installed @coinmasters/tokens package"
          });
        }
      }
    );
  }
}
const ge = (r) => {
  const t = A.fromChainOrSignature(r);
  switch (r) {
    case o.Bitcoin:
    case o.Litecoin:
    case o.BitcoinCash:
      return t.set(10001e-8);
    case o.Dogecoin:
      return t.set(1.00000001);
    case o.Avalanche:
    case o.Ethereum:
      return t.set(1e-8);
    case o.THORChain:
    case o.Maya:
      return t.set(0);
    default:
      return t.set(1e-8);
  }
}, z = (r) => {
  const t = r.slice(0, 14).includes("/"), [e, s] = r.split(".").pop().split("/"), n = r.includes(".") && !t ? r : `${o.THORChain}.${s}`, [i, a] = n.split("."), [c, u] = (t ? s : a).split("-");
  return {
    address: u == null ? void 0 : u.toLowerCase(),
    chain: i,
    isGasAsset: ot({ chain: i, symbol: a }),
    isSynthetic: t,
    symbol: (t ? `${e}/` : "") + (u ? `${c}-${(u == null ? void 0 : u.toLowerCase()) ?? ""}` : a),
    ticker: c
  };
}, se = {
  /**
   * Core
   */
  core_wallet_connection_not_found: 10001,
  core_estimated_max_spendable_chain_not_supported: 10002,
  core_extend_error: 10003,
  core_inbound_data_not_found: 10004,
  core_approve_asset_address_or_from_not_found: 10005,
  core_chain_halted: 10099,
  /**
   * Core - Wallet Connection
   */
  core_wallet_xdefi_not_installed: 10101,
  core_wallet_evmwallet_not_installed: 10102,
  core_wallet_walletconnect_not_installed: 10103,
  core_wallet_keystore_not_installed: 10104,
  core_wallet_ledger_not_installed: 10105,
  core_wallet_trezor_not_installed: 10106,
  core_wallet_keplr_not_installed: 10107,
  core_wallet_okx_not_installed: 10108,
  core_wallet_keepkey_not_installed: 10109,
  /**
   * Core - Swap
   */
  core_swap_invalid_params: 10200,
  core_swap_route_not_complete: 10201,
  core_swap_asset_not_recognized: 10202,
  core_swap_contract_not_found: 10203,
  core_swap_route_transaction_not_found: 10204,
  core_swap_contract_not_supported: 10205,
  core_swap_transaction_error: 10206,
  core_swap_quote_mode_not_supported: 10207,
  /**
   * Core - Transaction
   */
  core_transaction_deposit_error: 10301,
  core_transaction_create_liquidity_rune_error: 10302,
  core_transaction_create_liquidity_asset_error: 10303,
  core_transaction_create_liquidity_invalid_params: 10304,
  core_transaction_add_liquidity_invalid_params: 10305,
  core_transaction_add_liquidity_no_rune_address: 10306,
  core_transaction_add_liquidity_rune_error: 10307,
  core_transaction_add_liquidity_asset_error: 10308,
  core_transaction_withdraw_error: 10309,
  core_transaction_deposit_to_pool_error: 10310,
  core_transaction_deposit_insufficient_funds_error: 10311,
  core_transaction_deposit_gas_error: 10312,
  core_transaction_invalid_sender_address: 10313,
  core_transaction_deposit_server_error: 10313,
  /**
   * Wallets
   */
  wallet_ledger_connection_error: 20001,
  /**
   * Helpers
   */
  helpers_number_different_decimals: 99101
};
class mt extends Error {
  constructor(t, e) {
    console.error(e, { stack: e == null ? void 0 : e.stack, message: e == null ? void 0 : e.message }), super(t, { cause: { code: se[t], message: t } }), Object.setPrototypeOf(this, mt.prototype);
  }
}
class b extends O {
  eq(t) {
    return this.eqValue(t);
  }
  static fromBigInt(t, e) {
    return new b({
      decimal: e,
      value: P({ value: t, bigIntDecimal: e, decimal: e })
    });
  }
}
export {
  A as AssetValue,
  O as BigIntArithmetics,
  Zt as RequestClient,
  mt as SwapKitError,
  b as SwapKitNumber,
  oe as assetFromString,
  _e as derivationPathToString,
  ae as filterAssets,
  P as formatBigIntToSafeValue,
  ie as gasFeeMultiplier,
  Ot as getAssetType,
  xt as getAsymmetricAssetShare,
  ue as getAsymmetricAssetWithdrawAmount,
  Bt as getAsymmetricRuneShare,
  ce as getAsymmetricRuneWithdrawAmount,
  It as getCommonAssetInfo,
  Ct as getDecimal,
  he as getEstimatedPoolShare,
  de as getLiquiditySlippage,
  me as getMemoFor,
  ge as getMinAmountByChain,
  qt as getSymmetricPoolShare,
  le as getSymmetricWithdraw,
  pe as getTHORNameCost,
  ot as isGasAsset,
  fe as validateTHORName
};
