import { Chain } from '@coinmasters/types';
import type { CoinGeckoList } from '@coinmasters/tokens';
import { FeeOption } from '@coinmasters/types';
import type { MayaList } from '@coinmasters/tokens';
import { MemoType } from '@coinmasters/types';
import type { Options } from 'ky';
import type { PancakeswapETHList } from '@coinmasters/tokens';
import type { PancakeswapList } from '@coinmasters/tokens';
import type { PangolinList } from '@coinmasters/tokens';
import type { PioneerList } from '@coinmasters/tokens';
import type { StargateARBList } from '@coinmasters/tokens';
import type { SushiswapList } from '@coinmasters/tokens';
import type { ThorchainList } from '@coinmasters/tokens';
import type { TraderjoeList } from '@coinmasters/tokens';
import type { UniswapList } from '@coinmasters/tokens';
import type { WoofiList } from '@coinmasters/tokens';

declare type AllowedNumberTypes = 'bigint' | 'number' | 'string';

export declare const assetFromString: (assetString: string) => {
    chain: Chain;
    symbol: string;
    ticker: string;
    synth: boolean;
};

export declare class AssetValue extends BigIntArithmetics {
    address?: string;
    chain: Chain;
    isGasAsset: boolean;
    isSynthetic: boolean;
    symbol: string;
    tax?: TokenTax;
    ticker: string;
    type: ReturnType<typeof getAssetType>;
    constructor(params: AssetValueParams);
    toString(short?: boolean): string;
    toUrl(): string;
    eq({ chain, symbol }: {
        chain: Chain;
        symbol: string;
    }): boolean;
    static fromString(assetString: string, value?: NumberPrimitives): Promise<AssetValue>;
    static fromStringSync(assetString: string, value?: NumberPrimitives): AssetValue | undefined;
    static fromIdentifier(assetString: `${Chain}.${string}` | `${Chain}/${string}` | `${Chain}.${string}-${string}`, value?: NumberPrimitives): Promise<AssetValue>;
    static fromIdentifierSync(identifier: TokenNames, value?: NumberPrimitives): AssetValue;
    static fromChainOrSignature(assetString: CommonAssetString, value?: NumberPrimitives): AssetValue;
    static loadStaticAssets(): Promise<{
        ok: true;
    } | {
        ok: false;
        message: string;
        error: any;
    }>;
}

declare type AssetValueParams = {
    decimal: number;
    value: SwapKitValueType;
    tax?: TokenTax;
} & ({
    chain: Chain;
    symbol: string;
} | {
    identifier: string;
});

export declare class BigIntArithmetics {

    decimalMultiplier: bigint;
    bigIntValue: bigint;
    decimal?: number;
    static fromBigInt(value: bigint, decimal?: number): BigIntArithmetics;
    static shiftDecimals({ value, from, to, }: {
        value: InstanceType<typeof SwapKitNumber>;
        from: number;
        to: number;
    }): BigIntArithmetics;
    constructor(params: SKBigIntParams);
    set(value: SKBigIntParams): this;
    add(...args: InitialisationValueType[]): this;
    sub(...args: InitialisationValueType[]): this;
    mul(...args: InitialisationValueType[]): this;
    div(...args: InitialisationValueType[]): this;
    gt(value: InitialisationValueType): boolean;
    gte(value: InitialisationValueType): boolean;
    lt(value: InitialisationValueType): boolean;
    lte(value: InitialisationValueType): boolean;
    eqValue(value: InitialisationValueType): boolean;
    getValue<T extends AllowedNumberTypes>(type: T): NumberPrimitivesType[T];
    getBaseValue<T extends AllowedNumberTypes>(type: T): NumberPrimitivesType[T];
    getBigIntValue(value: InitialisationValueType, decimal?: number): bigint;
    toSignificant(significantDigits?: number): string;
    toFixed(fixedDigits?: number): string;
    toAbbreviation(digits?: number): string;
    toCurrency(currency?: string, { currencyPosition, decimal, decimalSeparator, thousandSeparator, }?: {
        currencyPosition?: string | undefined;
        decimal?: number | undefined;
        decimalSeparator?: string | undefined;
        thousandSeparator?: string | undefined;
    }): string;
    formatBigIntToSafeValue(value: bigint, decimal?: number): string;
}

export declare type CommonAssetString = 'MAYA.MAYA' | 'ETH.THOR' | 'ETH.vTHOR' | Chain;

export declare const derivationPathToString: ([network, chainId, account, change, index]: number[]) => string;

declare const errorMessages: {
    /**
     * Core
     */
    readonly core_wallet_connection_not_found: 10001;
    readonly core_estimated_max_spendable_chain_not_supported: 10002;
    readonly core_extend_error: 10003;
    readonly core_inbound_data_not_found: 10004;
    readonly core_approve_asset_address_or_from_not_found: 10005;
    readonly core_chain_halted: 10099;
    /**
     * Core - Wallet Connection
     */
    readonly core_wallet_xdefi_not_installed: 10101;
    readonly core_wallet_evmwallet_not_installed: 10102;
    readonly core_wallet_walletconnect_not_installed: 10103;
    readonly core_wallet_keystore_not_installed: 10104;
    readonly core_wallet_ledger_not_installed: 10105;
    readonly core_wallet_trezor_not_installed: 10106;
    readonly core_wallet_keplr_not_installed: 10107;
    readonly core_wallet_okx_not_installed: 10108;
    readonly core_wallet_keepkey_not_installed: 10109;
    /**
     * Core - Swap
     */
    readonly core_swap_invalid_params: 10200;
    readonly core_swap_route_not_complete: 10201;
    readonly core_swap_asset_not_recognized: 10202;
    readonly core_swap_contract_not_found: 10203;
    readonly core_swap_route_transaction_not_found: 10204;
    readonly core_swap_contract_not_supported: 10205;
    readonly core_swap_transaction_error: 10206;
    readonly core_swap_quote_mode_not_supported: 10207;
    /**
     * Core - Transaction
     */
    readonly core_transaction_deposit_error: 10301;
    readonly core_transaction_create_liquidity_rune_error: 10302;
    readonly core_transaction_create_liquidity_asset_error: 10303;
    readonly core_transaction_create_liquidity_invalid_params: 10304;
    readonly core_transaction_add_liquidity_invalid_params: 10305;
    readonly core_transaction_add_liquidity_no_rune_address: 10306;
    readonly core_transaction_add_liquidity_rune_error: 10307;
    readonly core_transaction_add_liquidity_asset_error: 10308;
    readonly core_transaction_withdraw_error: 10309;
    readonly core_transaction_deposit_to_pool_error: 10310;
    readonly core_transaction_deposit_insufficient_funds_error: 10311;
    readonly core_transaction_deposit_gas_error: 10312;
    readonly core_transaction_invalid_sender_address: 10313;
    readonly core_transaction_deposit_server_error: 10313;
    /**
     * Wallets
     */
    readonly wallet_ledger_connection_error: 20001;
    /**
     * Helpers
     */
    readonly helpers_number_different_decimals: 99101;
};

export declare const filterAssets: (tokens: {
    value: string;
    decimal: number;
    chain: Chain;
    symbol: string;
}[]) => {
    value: string;
    decimal: number;
    chain: Chain;
    symbol: string;
}[];

export declare function formatBigIntToSafeValue({ value, bigIntDecimal, decimal, }: {
    value: bigint;
    bigIntDecimal?: number;
    decimal?: number;
}): string;

export declare const gasFeeMultiplier: Record<FeeOption, number>;

export declare const getAssetType: ({ chain, symbol }: {
    chain: Chain;
    symbol: string;
}) => Chain.Avalanche | Chain.Cosmos | Chain.Kujira | "Synth" | "Native" | "BEP2" | "BEP20" | "ERC20" | "POLYGON" | "ARBITRUM" | "OPTIMISM" | undefined;

export declare const getAsymmetricAssetShare: ({ liquidityUnits, poolUnits, assetDepth, }: ShareParams<{
    assetDepth: string;
}>) => SwapKitNumber;

export declare const getAsymmetricAssetWithdrawAmount: ({ percent, assetDepth, liquidityUnits, poolUnits, }: ShareParams<{
    percent: number;
    assetDepth: string;
}>) => SwapKitNumber;

/**
 *  Ref: https://gitlab.com/thorchain/thornode/-/issues/657
 *  share = (s * A * (2 * T^2 - 2 * T * s + s^2))/T^3
 *  s = stakeUnits for member (after factoring in withdrawBasisPoints)
 *  T = totalPoolUnits for pool
 *  A = assetDepth to be withdrawn
 *
 *  Formula:
 *  share = (s * A * (2 * T^2 - 2 * T * s + s^2))/T^3
 *  (part1 * (part2 - part3 + part4)) / part5
 */
export declare const getAsymmetricRuneShare: ({ liquidityUnits, poolUnits, runeDepth, }: ShareParams<{
    runeDepth: string;
}>) => SwapKitNumber;

export declare const getAsymmetricRuneWithdrawAmount: ({ percent, runeDepth, liquidityUnits, poolUnits, }: ShareParams<{
    percent: number;
    runeDepth: string;
}>) => SwapKitNumber;

export declare const getCommonAssetInfo: (assetString: CommonAssetString) => {
    identifier: string;
    decimal: number;
};

export declare const getDecimal: ({ chain, symbol }: {
    chain: Chain;
    symbol: string;
}) => Promise<any>;

export declare const getEstimatedPoolShare: ({ runeDepth, poolUnits, assetDepth, liquidityUnits, runeAmount, assetAmount, }: ShareParams<{
    runeAmount: string;
    assetAmount: string;
    runeDepth: string;
    assetDepth: string;
}>) => number;

export declare const getLiquiditySlippage: ({ runeAmount, assetAmount, runeDepth, assetDepth, }: PoolParams) => number;

export declare const getMemoFor: <T extends MemoType>(memoType: T, options: MemoOptions<T>) => string;

export declare const getMinAmountByChain: (chain: Chain) => AssetValue;

export declare const getSymmetricPoolShare: ({ liquidityUnits, poolUnits, runeDepth, assetDepth, }: ShareParams<{
    runeDepth: string;
    assetDepth: string;
}>) => {
    assetAmount: SwapKitNumber;
    runeAmount: SwapKitNumber;
};

export declare const getSymmetricWithdraw: ({ liquidityUnits, poolUnits, runeDepth, assetDepth, percent, }: ShareParams<{
    runeDepth: string;
    assetDepth: string;
    percent: number;
}>) => {
    [k: string]: SwapKitNumber;
};

export declare const getTHORNameCost: (year: number) => number;

declare type InitialisationValueType = NumberPrimitives | BigIntArithmetics | SwapKitNumber;

export declare const isGasAsset: ({ chain, symbol }: {
    chain: Chain;
    symbol: string;
}) => boolean | undefined;

export declare type Keys = keyof typeof errorMessages;

export declare type MemoOptions<T extends MemoType> = {
    [MemoType.BOND]: WithAddress;
    [MemoType.LEAVE]: WithAddress;
    [MemoType.CLOSE_LOAN]: WithAddress<{
        asset: string;
        minAmount?: string;
    }>;
    [MemoType.OPEN_LOAN]: WithAddress<{
        asset: string;
        minAmount?: string;
    }>;
    [MemoType.UNBOND]: WithAddress<{
        unbondAmount: number;
    }>;
    [MemoType.DEPOSIT]: WithChain<{
        symbol: string;
        address?: string;
        singleSide?: boolean;
    }>;
    [MemoType.WITHDRAW]: WithChain<{
        ticker: string;
        symbol: string;
        basisPoints: number;
        targetAssetString?: string;
        singleSide?: boolean;
    }>;
    [MemoType.THORNAME_REGISTER]: Omit<ThornameRegisterParam, 'preferredAsset' | 'expiryBlock'>;
}[T];

export declare type NumberPrimitives = bigint | number | string;

declare type NumberPrimitivesType = {
    bigint: bigint;
    number: number;
    string: string;
};

declare type PoolParams<T = {}> = T & {
    runeAmount: string;
    assetAmount: string;
    runeDepth: string;
    assetDepth: string;
};

export declare const RequestClient: {
    get: <T>(url: string | URL | Request, options?: Options) => Promise<T>;
    post: <T_1>(url: string | URL | Request, options?: Options) => Promise<T_1>;
};

declare type ShareParams<T = {}> = T & {
    liquidityUnits: string;
    poolUnits: string;
};

declare type SKBigIntParams = InitialisationValueType | {
    decimal?: number;
    value: number | string;
};

export declare class SwapKitError extends Error {
    constructor(errorKey: Keys, sourceError?: any);
}

export declare class SwapKitNumber extends BigIntArithmetics {
    eq(value: SwapKitValueType): boolean;
    static fromBigInt(value: bigint, decimal?: number): SwapKitNumber;
}

export declare type SwapKitValueType = BigIntArithmetics | string | number;

declare type TCTokenNames = (typeof ThorchainList)['tokens'][number]['identifier'];

export declare type ThornameRegisterParam = {
    name: string;
    chain: string;
    address: string;
    owner?: string;
    preferredAsset?: string;
    expiryBlock?: string;
};

declare type TokenNames = TCTokenNames | (typeof CoinGeckoList)['tokens'][number]['identifier'] | (typeof MayaList)['tokens'][number]['identifier'] | (typeof PancakeswapETHList)['tokens'][number]['identifier'] | (typeof PancakeswapList)['tokens'][number]['identifier'] | (typeof PangolinList)['tokens'][number]['identifier'] | (typeof StargateARBList)['tokens'][number]['identifier'] | (typeof SushiswapList)['tokens'][number]['identifier'] | (typeof TraderjoeList)['tokens'][number]['identifier'] | (typeof WoofiList)['tokens'][number]['identifier'] | (typeof UniswapList)['tokens'][number]['identifier'] | (typeof PioneerList)['tokens'][number]['identifier'];

declare type TokenTax = {
    buy: number;
    sell: number;
};

export declare const validateTHORName: (name: string) => boolean;

declare type WithAddress<T = {}> = T & {
    address: string;
};

declare type WithChain<T = {}> = T & {
    chain: Chain;
};

export { }
