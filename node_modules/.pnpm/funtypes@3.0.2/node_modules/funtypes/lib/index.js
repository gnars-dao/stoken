"use strict";
function isParsedValueRuntype(e) {
  return "tag" in e && "parsed" === e.tag;
}
function ParsedValue(e, t) {
  return (
    assertRuntype(e),
    create(
      "parsed",
      {
        p: (r, n, s) =>
          ((e, t, r) => {
            if (!e.success) return e;
            if (!e.cycle) {
              const n = t(e.value);
              return (n.success && r && innerGuard(r, n.value, createGuardVisitedState())) || n;
            }
            return innerMapValidationPlaceholder(
              Array.isArray(e.placeholder) ? [...e.placeholder] : { ...e.placeholder },
              () => e.unwrap(),
              t,
              r,
            );
          })(s(e, r), e => t.parse(e), t.test),
        t(r, n) {
          return t.test
            ? n(t.test, r)
            : failure((t.name || `ParsedValue<${show(e)}>`) + " does not support Runtype.test");
        },
        s(r, n, s) {
          if (!t.serialize)
            return failure(
              (t.name || `ParsedValue<${show(e)}>`) + " does not support Runtype.serialize",
            );
          const a = t.test ? innerGuard(t.test, r, createGuardVisitedState()) : void 0;
          if (a) return a;
          const o = t.serialize(r);
          return o.success ? s(e, o.value) : o;
        },
      },
      {
        underlying: e,
        config: t,
        show() {
          return t.name || `ParsedValue<${show(e, !1)}>`;
        },
      },
    )
  );
}
function assertRuntype(...e) {
  for (const r of e) if (!r || !r[t]) throw new Error("Expected Runtype but got " + showValue(r));
}
function create(e, r, n) {
  function safeParse(e) {
    return innerValidate(s, e, createVisitedState());
  }
  function safeSerialize(e) {
    return innerSerialize(s, e, createVisitedState());
  }
  const s = {
    ...n,
    tag: e,
    assert(e) {
      const t = innerGuard(s, e, createGuardVisitedState());
      if (t) throw new ValidationError(t);
    },
    parse(e) {
      const t = safeParse(e);
      if (!t.success) throw new ValidationError(t);
      return t.value;
    },
    safeParse,
    test: e => void 0 === innerGuard(s, e, createGuardVisitedState()),
    serialize(e) {
      const t = safeSerialize(e);
      if (!t.success) throw new ValidationError(t);
      return t.value;
    },
    safeSerialize,
    Or: e => Union(s, e),
    And: e => Intersect(s, e),
    withConstraint: (e, t) => Constraint(s, e, t),
    withGuard: (e, t) => Constraint(s, e, t),
    withBrand: e => Brand(e, s),
    withParser: e => ParsedValue(s, e),
    toString: () => `Runtype<${show(s)}>`,
    [t]: "function" == typeof r ? { p: r } : r,
  };
  return s;
}
function createValidationPlaceholder(e, t) {
  return innerMapValidationPlaceholder(e, () => t(e) || success(e));
}
function innerMapValidationPlaceholder(e, t, r, n) {
  let s,
    a = !1;
  const o = {
    success: !0,
    cycle: !0,
    placeholder: e,
    unwrap() {
      if (s) return (a = !0), s;
      s = success(e);
      const i = t(),
        l = i.success && r ? r(i.value) : i;
      if (!l.success) return (s = l);
      if (a) {
        const e = ((e, t) =>
            e === t
              ? success(t)
              : Array.isArray(e) && Array.isArray(t)
              ? (e.splice(0, e.length, ...t), success(e))
              : e &&
                "object" == typeof e &&
                !Array.isArray(e) &&
                t &&
                "object" == typeof t &&
                !Array.isArray(t)
              ? (Object.assign(e, t), success(e))
              : failure(
                  `Cannot convert a value of type "${
                    Array.isArray(e) ? "Array" : typeof e
                  }" into a value of type "${
                    null === t ? "null" : Array.isArray(t) ? "Array" : typeof t
                  }" when it contains cycles.`,
                ))(s.value, l.value),
          t = e.success && n && innerGuard(n, e.value, createGuardVisitedState());
        s = t || e;
      } else {
        const e = n && innerGuard(n, l.value, createGuardVisitedState());
        s = e || l;
      }
      return s.success && (o.placeholder = s.value), s;
    },
  };
  return o;
}
function createVisitedState() {
  return new Map();
}
function createGuardVisitedState() {
  return new Map();
}
function innerValidate(e, t, r) {
  const n = innerValidateToPlaceholder(e, t, r);
  return n.cycle ? n.unwrap() : n;
}
function innerValidateToPlaceholder(e, r, n) {
  var s;
  const a = n,
    o = e[t],
    i = null === (s = a.get(e)) || void 0 === s ? void 0 : s.get(r);
  if (void 0 !== i) return i;
  const l = o.p(
    r,
    (e, t) => innerValidate(e, t, n),
    (e, t) => innerValidateToPlaceholder(e, t, n),
  );
  return l.cycle ? (a.set(e, (a.get(e) || new Map()).set(r, l)), l) : l;
}
function innerSerialize(e, t, r) {
  const n = innerSerializeToPlaceholder(e, t, r);
  return n.cycle ? n.unwrap() : n;
}
function innerSerializeToPlaceholder(e, r, n) {
  var s;
  const a = n,
    o = e[t],
    i = null === (s = a.get(e)) || void 0 === s ? void 0 : s.get(r);
  if (void 0 !== i) return i;
  let l = (o.s || o.p)(
    r,
    (e, t) => innerSerialize(e, t, n),
    (e, t) => innerSerializeToPlaceholder(e, t, n),
  );
  return l.cycle ? (a.set(e, (a.get(e) || new Map()).set(r, l)), l) : l;
}
function innerGuard(e, r, n) {
  var s;
  const a = n,
    o = e[t];
  if (r && ("object" == typeof r || "function" == typeof r)) {
    if (null === (s = a.get(e)) || void 0 === s ? void 0 : s.has(r)) return;
    a.set(e, (a.get(e) || new Set()).add(r));
  }
  if (o.t) return o.t(r, (e, t) => innerGuard(e, t, n));
  let i = o.p(
    r,
    (e, t) => innerGuard(e, t, n) || success(t),
    (e, t) => innerGuard(e, t, n) || success(t),
  );
  return i.cycle && (i = i.unwrap()), i.success ? void 0 : i;
}
function showValue(e, r = 3, n = 30) {
  switch (typeof e) {
    case "bigint":
    case "boolean":
    case "number":
      return "" + e;
    case "string":
      return JSON.stringify(e);
    case "object":
      if (null === e) return "null";
      if (Array.isArray(e)) {
        if (0 === r || 0 === n) return "[Array]";
        {
          let t = "[",
            s = 0;
          for (s = 0; s < e.length && n > t.length; s++)
            0 !== s && (t += ", "), (t += showValue(e[s], r - 1, n - t.length));
          return s < e.length && (t += " ... "), (t += "]"), t;
        }
      }
      if ((e => "object" == typeof e && null != e && t in e)(e)) return e.toString();
      if (0 === r) return "{Object}";
      {
        const t = Object.entries(e);
        let s = "{",
          a = 0;
        for (a = 0; a < t.length && n > s.length; a++) {
          0 !== a && (s += ", ");
          const [e, o] = t[a];
          s += `${/\s/.test(e) ? JSON.stringify(e) : e}: ${showValue(o, r - 1, n - s.length)}`;
        }
        return a < t.length && (s += " ... "), (s += "}"), s;
      }
    case "function":
    case "symbol":
    case "undefined":
    default:
      return typeof e;
  }
}
function success(e) {
  return { success: !0, value: e };
}
function failure(e, t = {}) {
  return { success: !1, message: e, ...t };
}
function expected(e, t, r = {}) {
  return failure(`Expected ${"string" == typeof e ? e : show(e)}, but was ${showValue(t)}`, r);
}
function unableToAssign(e, t, ...r) {
  return [`Unable to assign ${showValue(e)} to ${show(t)}`, ...r.map(toFullError)];
}
function andError([e, ...t]) {
  return [`And ${e[0].toLocaleLowerCase()}${e.substr(1)}`, ...t];
}
function typesAreNotCompatible(e, ...t) {
  return [`The types of ${e} are not compatible`, ...t.map(toFullError)];
}
function toFullError(e) {
  return "string" == typeof e ? [e] : Array.isArray(e) ? e : toFullError(e.fullError || e.message);
}
function showError(e) {
  return e.fullError ? showFullError(e.fullError) : e.key ? `${e.message} in ${e.key}` : e.message;
}
function showFullError([e, ...t], r = "") {
  return [`${r}${e}`, ...t.map(e => showFullError(e, r + "  "))].join("\n");
}
function InternalArr(e, t) {
  assertRuntype(e);
  const r = create(
    "array",
    (t, n) =>
      Array.isArray(t)
        ? createValidationPlaceholder([...t], s => {
            let a,
              o = void 0;
            for (let i = 0; i < t.length; i++) {
              const l = n(e, t[i]);
              l.success
                ? (s[i] = l.value)
                : (o || (o = unableToAssign(t, r)),
                  o.push(typesAreNotCompatible(`[${i}]`, l)),
                  (a =
                    a ||
                    failure(l.message, {
                      key: l.key ? `[${i}].${l.key}` : `[${i}]`,
                      fullError: o,
                    })));
            }
            return a;
          })
        : expected("an Array", t),
    {
      isReadonly: t,
      element: e,
      show() {
        return `${t ? "readonly " : ""}${show(e, !0)}[]`;
      },
    },
  );
  return t || (r.asReadonly = () => InternalArr(e, !0)), r;
}
function Constraint(e, t, r) {
  assertRuntype(e);
  const n = create(
    "constraint",
    (s, a) => {
      const o = r && r.name,
        i = a(e, s);
      if (!i.success) return i;
      const l = t(i.value);
      if (!l || "string" == typeof l) {
        const e = "string" == typeof l ? l : `${showValue(s)} failed ${o || "constraint"} check`;
        return failure(e, { fullError: unableToAssign(s, n, e) });
      }
      return success(i.value);
    },
    {
      underlying: e,
      constraint: t,
      name: r && r.name,
      args: r && r.args,
      show(t) {
        return (r && r.name) || `WithConstraint<${show(e, t)}>`;
      },
    },
  );
  return n;
}
function Intersect(...e) {
  return (
    assertRuntype(...e),
    create(
      "intersect",
      (t, r) => {
        if (Array.isArray(t))
          return createValidationPlaceholder([...t], t => {
            for (const n of e) {
              let e = r(n, t);
              if (!e.success) return e;
              if (!Array.isArray(e.value))
                return failure(
                  `The validator ${show(
                    n,
                  )} attempted to convert the type of this value from an array to something else. That conversion is not valid as the child of an intersect`,
                );
              t.splice(0, t.length, ...e.value);
            }
          });
        if (t && "object" == typeof t)
          return createValidationPlaceholder({}, n => {
            for (const s of e) {
              let e = r(s, t);
              if (!e.success) return e;
              if (!e.value || "object" != typeof e.value)
                return failure(
                  `The validator ${show(
                    s,
                  )} attempted to convert the type of this value from an object to something else. That conversion is not valid as the child of an intersect`,
                );
              Object.assign(n, e.value);
            }
          });
        let n = t;
        for (const t of e) {
          let e = r(t, n);
          if (!e.success) return e;
          n = e.value;
        }
        return success(n);
      },
      {
        intersectees: e,
        show(t) {
          return parenthesize("" + e.map(e => show(e, !0)).join(" & "), t);
        },
      },
    )
  );
}
function lazyValue(e) {
  let t;
  return () => t || (t = e());
}
function isLiteralRuntype(e) {
  return "tag" in e && "literal" === e.tag;
}
function Literal(e) {
  return create(
    "literal",
    t =>
      t === e
        ? success(t)
        : failure(
            `Expected literal ${showValue(e)}, but was ${showValue(t)}${
              typeof t != typeof e ? ` (i.e. a ${typeof t})` : ""
            }`,
          ),
    {
      value: e,
      show() {
        return showValue(e);
      },
    },
  );
}
function hasKey(e, t) {
  return "object" == typeof t && e in t;
}
function isObjectRuntype(e) {
  return "tag" in e && "object" === e.tag;
}
function InternalObject(e, t, r) {
  assertRuntype(...Object.values(e));
  const n = create(
    "object",
    (r, s) =>
      null == r || "object" != typeof r
        ? expected(n, r)
        : Array.isArray(r)
        ? failure(`Expected ${show(n)}, but was an Array`)
        : createValidationPlaceholder({}, a => {
            let o,
              i = void 0;
            for (const l in e)
              if (!t || (hasKey(l, r) && void 0 !== r[l])) {
                const u = t || hasKey(l, r) ? r[l] : void 0;
                let c = s(e[l], u);
                c.success
                  ? (a[l] = c.value)
                  : (i || (i = unableToAssign(r, n)),
                    i.push(typesAreNotCompatible(`"${l}"`, c)),
                    (o =
                      o || failure(c.message, { key: c.key ? `${l}.${c.key}` : l, fullError: i })));
              }
            return o;
          }),
    {
      isPartial: t,
      isReadonly: r,
      fields: e,
      asPartial: () => InternalObject(n.fields, !0, n.isReadonly),
      asReadonly: () => InternalObject(n.fields, n.isPartial, !0),
      pick(...n) {
        const s = {};
        for (const t of n) s[t] = e[t];
        return InternalObject(s, t, r);
      },
      omit(...n) {
        const s = { ...e };
        for (const e of n) e in s && delete s[e];
        return InternalObject(s, t, r);
      },
      show() {
        const n = Object.keys(e);
        return n.length
          ? `{ ${n
              .map(n => `${r ? "readonly " : ""}${n}${t ? "?" : ""}: ${show(e[n], !1)};`)
              .join(" ")} }`
          : "{}";
      },
    },
  );
  return n;
}
function createPrimative(e) {
  return create(
    e,
    t =>
      typeof t === e
        ? success(t)
        : failure(
            `Expected ${e}, but was ${(e =>
              `${showValue(e)}${"string" == typeof e ? " (i.e. a string literal)" : ""}`)(t)}`,
          ),
    {},
  );
}
function getExpectedBaseType(e) {
  switch (e.tag) {
    case "string":
      return "string";
    case "number":
      return "number";
    case "literal":
      return typeof e.value;
    case "union":
      const t = e.alternatives.map(getExpectedBaseType);
      return t.reduce((e, t) => (e === t ? e : "mixed"), t[0]);
    case "constraint":
      return getExpectedBaseType(e.underlying);
  }
}
function isTupleRuntype(e) {
  return "tag" in e && "tuple" === e.tag;
}
function Brand(e, t) {
  return (
    assertRuntype(t),
    create("brand", (e, r, n) => n(t, e), {
      brand: e,
      entity: t,
      show(e) {
        return show(t, e);
      },
    })
  );
}
function resolveUnderlyingType(e, t) {
  return (e => "tag" in e && "lazy" === e.tag)(e)
    ? resolveUnderlyingType(e.underlying(), t)
    : (e => "tag" in e && "brand" === e.tag)(e)
    ? resolveUnderlyingType(e.entity, t)
    : (e => "tag" in e && "constraint" === e.tag)(e) || ("p" === t && isParsedValueRuntype(e))
    ? resolveUnderlyingType(e.underlying, t)
    : "t" === t && isParsedValueRuntype(e)
    ? e.config.test
      ? resolveUnderlyingType(e.config.test, t)
      : a
    : "s" === t && isParsedValueRuntype(e)
    ? e.config.serialize
      ? e.config.test
        ? resolveUnderlyingType(e.config.test, t)
        : e
      : a
    : e;
}
function Union(...e) {
  function validateWithKey(e, t) {
    return (n, s) => {
      if (!n || "object" != typeof n) return expected(r, n);
      const a = t.get(n[e]);
      if (a) {
        const t = s(a, n);
        return t.success
          ? t
          : failure(t.message, {
              key: `<${0 === e ? "[0]" : e}: ${showValue(n[e])}>${t.key ? "." + t.key : ""}`,
              fullError: unableToAssign(n, r, t),
            });
      }
      {
        const s = expected(
          Array.from(t.keys())
            .map(e => ("string" == typeof e ? `'${e}'` : e))
            .join(" | "),
          n[e],
          { key: 0 === e ? "[0]" : e },
        );
        return (
          (s.fullError = unableToAssign(
            n,
            r,
            typesAreNotCompatible(0 === e ? "[0]" : `"${e}"`, s.message),
          )),
          s
        );
      }
    };
  }
  assertRuntype(...e);
  const validatorOf = t => {
      const n = e.filter(e => "never" !== resolveUnderlyingType(e, t).tag);
      if (n.length) {
        const e = n.map(e => resolveUnderlyingType(e, t)),
          r = e.filter(isObjectRuntype);
        if (r.length === n.length) {
          const e = {};
          for (let s = 0; s < n.length; s++)
            for (const a in r[s].fields) {
              const o = resolveUnderlyingType(r[s].fields[a], t);
              isLiteralRuntype(o) &&
                (e[a] || (e[a] = new Map()), e[a].has(o.value) || e[a].set(o.value, n[s]));
            }
          for (const t of ["type", "kind", "tag", ...Object.keys(e)])
            if (t in e && e[t].size === n.length) return validateWithKey(t, e[t]);
        }
        const s = e.filter(isTupleRuntype);
        if (s.length === n.length) {
          const e = new Map();
          for (let r = 0; r < n.length; r++) {
            const a = resolveUnderlyingType(s[r].components[0], t);
            isLiteralRuntype(a) && (e.has(a.value) || e.set(a.value, n[r]));
          }
          if (e.size === n.length) return validateWithKey(0, e);
        }
      }
      return (t, n) => {
        let s,
          a,
          o,
          i = 0;
        for (const l of e) {
          const e = n(l, t);
          if (e.success) return e;
          o
            ? o.push(andError(e.fullError || unableToAssign(t, l, e)))
            : (o = unableToAssign(t, r, e.fullError || unableToAssign(t, l, e))),
            e.key && (i++, (s = e), (a = l));
        }
        return s && a && 1 === i
          ? failure(s.message, { key: `<${show(a)}>.${s.key}`, fullError: o })
          : expected(r, t, { fullError: o });
      };
    },
    t = lazyValue(() => ({ p: validatorOf("p"), s: validatorOf("s"), t: validatorOf("t") })),
    r = create(
      "union",
      {
        p: (e, r) => t().p(e, r),
        s: (e, r) => t().s(e, r),
        t(e, r) {
          const n = t().s(e, (e, t) => r(e, t) || success(t));
          return n.success ? void 0 : n;
        },
      },
      {
        alternatives: e,
        match: (...t) => n => {
          const s = createVisitedState();
          for (let r = 0; r < e.length; r++) {
            const a = innerValidate(e[r], n, s);
            if (a.success) return t[r](a.value);
          }
          r.assert(n);
        },
        show(t) {
          return parenthesize("" + e.map(e => show(e, !0)).join(" | "), t);
        },
      },
    );
  return r;
}
Object.defineProperty(exports, "__esModule", { value: !0 });
const parenthesize = (e, t) => (t ? `(${e})` : e),
  e = new Set(),
  show = (t, r = !1) => {
    if (e.has(t) && "lazy" !== t.tag) return parenthesize("CIRCULAR " + t.tag, r);
    if (t.show) {
      e.add(t);
      try {
        return t.show(r);
      } finally {
        e.delete(t);
      }
    }
    return t.tag;
  },
  t = "__internal_runtype_methods__";
class ValidationError extends Error {
  constructor(e) {
    super(showError(e)),
      (this.name = "ValidationError"),
      (this.shortMessage = e.message),
      (this.key = e.key),
      (this.fullError = e.fullError);
  }
}
const r = create("unknown", e => success(e), {}),
  n = Literal(void 0),
  s = Literal(null),
  a = create("never", e => expected("nothing", e), {}),
  o = createPrimative("boolean"),
  i = createPrimative("function"),
  l = createPrimative("number"),
  u = createPrimative("string"),
  c = createPrimative("symbol");
(exports.Array = e => InternalArr(e, !1)),
  (exports.AsyncContract = (e, t) => ({
    enforce: r => (...n) => {
      if (n.length < e.length)
        return Promise.reject(
          new ValidationError({
            message: `Expected ${e.length} arguments but only received ${n.length}`,
          }),
        );
      const s = createVisitedState();
      for (let t = 0; t < e.length; t++) {
        const r = innerValidate(e[t], n[t], s);
        if (!r.success) return Promise.reject(new ValidationError(r));
        n[t] = r.value;
      }
      const a = r(...n);
      return a instanceof Promise
        ? a.then(e => {
            const r = innerGuard(t, e, createGuardVisitedState());
            if (r) throw new ValidationError(r);
            return e;
          })
        : Promise.reject(
            new ValidationError({
              message: "Expected function to return a promise, but instead got " + a,
            }),
          );
    },
  })),
  (exports.Boolean = o),
  (exports.Brand = Brand),
  (exports.Constraint = Constraint),
  (exports.Contract = (e, t) => ({
    enforce: r => (...n) => {
      if (n.length < e.length)
        throw new ValidationError({
          message: `Expected ${e.length} arguments but only received ${n.length}`,
        });
      const s = createVisitedState();
      for (let t = 0; t < e.length; t++) {
        const r = innerValidate(e[t], n[t], s);
        if (!r.success) throw new ValidationError(r);
        n[t] = r.value;
      }
      const a = r(...n),
        o = innerGuard(t, a, createGuardVisitedState());
      if (o) throw new ValidationError(o);
      return a;
    },
  })),
  (exports.Enum = (e, t) => {
    const r = Object.values(t),
      n = new Set(r.some(e => "number" == typeof e) ? r.filter(e => "number" == typeof e) : r);
    return create("enum", t => (n.has(t) ? success(t) : expected(e, t)), {
      enumObject: t,
      show: () => e,
    });
  }),
  (exports.Function = i),
  (exports.Guard = (e, t) => r.withGuard(e, t)),
  (exports.InstanceOf = e =>
    create("instanceof", t => (t instanceof e ? success(t) : expected("" + e.name, t)), {
      ctor: e,
      show() {
        return `InstanceOf<${e.name}>`;
      },
    })),
  (exports.Intersect = Intersect),
  (exports.Lazy = e => {
    const t = lazyValue(e);
    return create("lazy", (e, r, n) => n(t(), e), {
      underlying: t,
      show(e) {
        return show(t(), e);
      },
    });
  }),
  (exports.Literal = Literal),
  (exports.Never = a),
  (exports.Null = s),
  (exports.Number = l),
  (exports.Object = e => InternalObject(e, !1, !1)),
  (exports.ParsedValue = ParsedValue),
  (exports.Partial = e => InternalObject(e, !0, !1)),
  (exports.ReadonlyArray = e => InternalArr(e, !0)),
  (exports.Record = (e, t) => {
    assertRuntype(e, t);
    const r = lazyValue(() => getExpectedBaseType(e)),
      n = create(
        "record",
        (s, a) =>
          null == s || "object" != typeof s
            ? expected(n, s)
            : Object.getPrototypeOf(s) !== Object.prototype
            ? Array.isArray(s)
              ? failure("Expected Record, but was Array")
              : failure(`Expected ${show(n)}, but was ${Object.getPrototypeOf(s)}`)
            : createValidationPlaceholder({}, n => {
                for (const o in s) {
                  let i = null;
                  if ("number" === r()) {
                    if (isNaN(+o)) return expected("record key to be a number", o);
                    i = a(e, +o);
                  } else
                    "string" === r()
                      ? (i = a(e, o))
                      : ((i = a(e, o)), i.success || isNaN(+o) || (i = a(e, +o)));
                  if (!i.success) return expected("record key to be " + show(e), o);
                  const l = a(t, s[o]);
                  if (!l.success) return failure(l.message, { key: l.key ? `${o}.${l.key}` : o });
                  n[i.value] = l.value;
                }
              }),
        {
          key: e,
          value: t,
          show() {
            return `{ [_: ${show(e, !1)}]: ${show(t, !1)} }`;
          },
        },
      );
    return n;
  }),
  (exports.String = u),
  (exports.Symbol = c),
  (exports.Tuple = (...e) => {
    assertRuntype(...e);
    const t = create(
      "tuple",
      (r, n) =>
        Array.isArray(r)
          ? r.length !== e.length
            ? expected("an array of length " + e.length, r.length)
            : createValidationPlaceholder([...r], s => {
                let a,
                  o = void 0;
                for (let i = 0; i < e.length; i++) {
                  let l = n(e[i], r[i]);
                  l.success
                    ? (s[i] = l.value)
                    : (o || (o = unableToAssign(r, t)),
                      o.push(typesAreNotCompatible(`[${i}]`, l)),
                      (a =
                        a ||
                        failure(l.message, {
                          key: l.key ? `[${i}].${l.key}` : `[${i}]`,
                          fullError: o,
                        })));
                }
                return a;
              })
          : expected("tuple to be an array", r),
      {
        components: e,
        show() {
          return `[${e.map(e => show(e, !1)).join(", ")}]`;
        },
      },
    );
    return t;
  }),
  (exports.Undefined = n),
  (exports.Union = Union),
  (exports.Unknown = r),
  (exports.ValidationError = ValidationError),
  (exports.assertType = (e, t) => {
    e.assert(t);
  }),
  (exports.showError = showError),
  (exports.showType = show),
  (exports.showValue = showValue);
