function isParsedValueRuntype(e) {
  return "tag" in e && "parsed" === e.tag;
}
function ParsedValue(e, t) {
  return (
    assertRuntype(e),
    create(
      "parsed",
      {
        p: (r, n, a) =>
          ((e, t, r) => {
            if (!e.success) return e;
            if (!e.cycle) {
              const n = t(e.value);
              return (n.success && r && innerGuard(r, n.value, createGuardVisitedState())) || n;
            }
            return innerMapValidationPlaceholder(
              Array.isArray(e.placeholder) ? [...e.placeholder] : { ...e.placeholder },
              () => e.unwrap(),
              t,
              r,
            );
          })(a(e, r), e => t.parse(e), t.test),
        t(r, n) {
          return t.test
            ? n(t.test, r)
            : failure((t.name || `ParsedValue<${show(e)}>`) + " does not support Runtype.test");
        },
        s(r, n, a) {
          if (!t.serialize)
            return failure(
              (t.name || `ParsedValue<${show(e)}>`) + " does not support Runtype.serialize",
            );
          const s = t.test ? innerGuard(t.test, r, createGuardVisitedState()) : void 0;
          if (s) return s;
          const i = t.serialize(r);
          return i.success ? a(e, i.value) : i;
        },
      },
      {
        underlying: e,
        config: t,
        show() {
          return t.name || `ParsedValue<${show(e, !1)}>`;
        },
      },
    )
  );
}
function assertRuntype(...e) {
  for (const r of e) if (!r || !r[t]) throw new Error("Expected Runtype but got " + showValue(r));
}
function create(e, r, n) {
  function safeParse(e) {
    return innerValidate(a, e, createVisitedState());
  }
  function safeSerialize(e) {
    return innerSerialize(a, e, createVisitedState());
  }
  const a = {
    ...n,
    tag: e,
    assert(e) {
      const t = innerGuard(a, e, createGuardVisitedState());
      if (t) throw new ValidationError(t);
    },
    parse(e) {
      const t = safeParse(e);
      if (!t.success) throw new ValidationError(t);
      return t.value;
    },
    safeParse,
    test: e => void 0 === innerGuard(a, e, createGuardVisitedState()),
    serialize(e) {
      const t = safeSerialize(e);
      if (!t.success) throw new ValidationError(t);
      return t.value;
    },
    safeSerialize,
    Or: e => Union(a, e),
    And: e => Intersect(a, e),
    withConstraint: (e, t) => Constraint(a, e, t),
    withGuard: (e, t) => Constraint(a, e, t),
    withBrand: e => Brand(e, a),
    withParser: e => ParsedValue(a, e),
    toString: () => `Runtype<${show(a)}>`,
    [t]: "function" == typeof r ? { p: r } : r,
  };
  return a;
}
function createValidationPlaceholder(e, t) {
  return innerMapValidationPlaceholder(e, () => t(e) || success(e));
}
function innerMapValidationPlaceholder(e, t, r, n) {
  let a,
    s = !1;
  const i = {
    success: !0,
    cycle: !0,
    placeholder: e,
    unwrap() {
      if (a) return (s = !0), a;
      a = success(e);
      const o = t(),
        u = o.success && r ? r(o.value) : o;
      if (!u.success) return (a = u);
      if (s) {
        const e = ((e, t) =>
            e === t
              ? success(t)
              : Array.isArray(e) && Array.isArray(t)
              ? (e.splice(0, e.length, ...t), success(e))
              : e &&
                "object" == typeof e &&
                !Array.isArray(e) &&
                t &&
                "object" == typeof t &&
                !Array.isArray(t)
              ? (Object.assign(e, t), success(e))
              : failure(
                  `Cannot convert a value of type "${
                    Array.isArray(e) ? "Array" : typeof e
                  }" into a value of type "${
                    null === t ? "null" : Array.isArray(t) ? "Array" : typeof t
                  }" when it contains cycles.`,
                ))(a.value, u.value),
          t = e.success && n && innerGuard(n, e.value, createGuardVisitedState());
        a = t || e;
      } else {
        const e = n && innerGuard(n, u.value, createGuardVisitedState());
        a = e || u;
      }
      return a.success && (i.placeholder = a.value), a;
    },
  };
  return i;
}
function createVisitedState() {
  return new Map();
}
function createGuardVisitedState() {
  return new Map();
}
function innerValidate(e, t, r) {
  const n = innerValidateToPlaceholder(e, t, r);
  return n.cycle ? n.unwrap() : n;
}
function innerValidateToPlaceholder(e, r, n) {
  var a;
  const s = n,
    i = e[t],
    o = null === (a = s.get(e)) || void 0 === a ? void 0 : a.get(r);
  if (void 0 !== o) return o;
  const u = i.p(
    r,
    (e, t) => innerValidate(e, t, n),
    (e, t) => innerValidateToPlaceholder(e, t, n),
  );
  return u.cycle ? (s.set(e, (s.get(e) || new Map()).set(r, u)), u) : u;
}
function innerSerialize(e, t, r) {
  const n = innerSerializeToPlaceholder(e, t, r);
  return n.cycle ? n.unwrap() : n;
}
function innerSerializeToPlaceholder(e, r, n) {
  var a;
  const s = n,
    i = e[t],
    o = null === (a = s.get(e)) || void 0 === a ? void 0 : a.get(r);
  if (void 0 !== o) return o;
  let u = (i.s || i.p)(
    r,
    (e, t) => innerSerialize(e, t, n),
    (e, t) => innerSerializeToPlaceholder(e, t, n),
  );
  return u.cycle ? (s.set(e, (s.get(e) || new Map()).set(r, u)), u) : u;
}
function innerGuard(e, r, n) {
  var a;
  const s = n,
    i = e[t];
  if (r && ("object" == typeof r || "function" == typeof r)) {
    if (null === (a = s.get(e)) || void 0 === a ? void 0 : a.has(r)) return;
    s.set(e, (s.get(e) || new Set()).add(r));
  }
  if (i.t) return i.t(r, (e, t) => innerGuard(e, t, n));
  let o = i.p(
    r,
    (e, t) => innerGuard(e, t, n) || success(t),
    (e, t) => innerGuard(e, t, n) || success(t),
  );
  return o.cycle && (o = o.unwrap()), o.success ? void 0 : o;
}
function showValue(e, r = 3, n = 30) {
  switch (typeof e) {
    case "bigint":
    case "boolean":
    case "number":
      return "" + e;
    case "string":
      return JSON.stringify(e);
    case "object":
      if (null === e) return "null";
      if (Array.isArray(e)) {
        if (0 === r || 0 === n) return "[Array]";
        {
          let t = "[",
            a = 0;
          for (a = 0; a < e.length && n > t.length; a++)
            0 !== a && (t += ", "), (t += showValue(e[a], r - 1, n - t.length));
          return a < e.length && (t += " ... "), (t += "]"), t;
        }
      }
      if ((e => "object" == typeof e && null != e && t in e)(e)) return e.toString();
      if (0 === r) return "{Object}";
      {
        const t = Object.entries(e);
        let a = "{",
          s = 0;
        for (s = 0; s < t.length && n > a.length; s++) {
          0 !== s && (a += ", ");
          const [e, i] = t[s];
          a += `${/\s/.test(e) ? JSON.stringify(e) : e}: ${showValue(i, r - 1, n - a.length)}`;
        }
        return s < t.length && (a += " ... "), (a += "}"), a;
      }
    case "function":
    case "symbol":
    case "undefined":
    default:
      return typeof e;
  }
}
function success(e) {
  return { success: !0, value: e };
}
function failure(e, t = {}) {
  return { success: !1, message: e, ...t };
}
function expected(e, t, r = {}) {
  return failure(`Expected ${"string" == typeof e ? e : show(e)}, but was ${showValue(t)}`, r);
}
function unableToAssign(e, t, ...r) {
  return [`Unable to assign ${showValue(e)} to ${show(t)}`, ...r.map(toFullError)];
}
function andError([e, ...t]) {
  return [`And ${e[0].toLocaleLowerCase()}${e.substr(1)}`, ...t];
}
function typesAreNotCompatible(e, ...t) {
  return [`The types of ${e} are not compatible`, ...t.map(toFullError)];
}
function toFullError(e) {
  return "string" == typeof e ? [e] : Array.isArray(e) ? e : toFullError(e.fullError || e.message);
}
function showError(e) {
  return e.fullError ? showFullError(e.fullError) : e.key ? `${e.message} in ${e.key}` : e.message;
}
function showFullError([e, ...t], r = "") {
  return [`${r}${e}`, ...t.map(e => showFullError(e, r + "  "))].join("\n");
}
function AsyncContract(e, t) {
  return {
    enforce: r => (...n) => {
      if (n.length < e.length)
        return Promise.reject(
          new ValidationError({
            message: `Expected ${e.length} arguments but only received ${n.length}`,
          }),
        );
      const a = createVisitedState();
      for (let t = 0; t < e.length; t++) {
        const r = innerValidate(e[t], n[t], a);
        if (!r.success) return Promise.reject(new ValidationError(r));
        n[t] = r.value;
      }
      const s = r(...n);
      return s instanceof Promise
        ? s.then(e => {
            const r = innerGuard(t, e, createGuardVisitedState());
            if (r) throw new ValidationError(r);
            return e;
          })
        : Promise.reject(
            new ValidationError({
              message: "Expected function to return a promise, but instead got " + s,
            }),
          );
    },
  };
}
function Contract(e, t) {
  return {
    enforce: r => (...n) => {
      if (n.length < e.length)
        throw new ValidationError({
          message: `Expected ${e.length} arguments but only received ${n.length}`,
        });
      const a = createVisitedState();
      for (let t = 0; t < e.length; t++) {
        const r = innerValidate(e[t], n[t], a);
        if (!r.success) throw new ValidationError(r);
        n[t] = r.value;
      }
      const s = r(...n),
        i = innerGuard(t, s, createGuardVisitedState());
      if (i) throw new ValidationError(i);
      return s;
    },
  };
}
function assertType(e, t) {
  e.assert(t);
}
function InternalArr(e, t) {
  assertRuntype(e);
  const r = create(
    "array",
    (t, n) =>
      Array.isArray(t)
        ? createValidationPlaceholder([...t], a => {
            let s,
              i = void 0;
            for (let o = 0; o < t.length; o++) {
              const u = n(e, t[o]);
              u.success
                ? (a[o] = u.value)
                : (i || (i = unableToAssign(t, r)),
                  i.push(typesAreNotCompatible(`[${o}]`, u)),
                  (s =
                    s ||
                    failure(u.message, {
                      key: u.key ? `[${o}].${u.key}` : `[${o}]`,
                      fullError: i,
                    })));
            }
            return s;
          })
        : expected("an Array", t),
    {
      isReadonly: t,
      element: e,
      show() {
        return `${t ? "readonly " : ""}${show(e, !0)}[]`;
      },
    },
  );
  return t || (r.asReadonly = () => InternalArr(e, !0)), r;
}
function Arr(e) {
  return InternalArr(e, !1);
}
function ReadonlyArray(e) {
  return InternalArr(e, !0);
}
function Constraint(e, t, r) {
  assertRuntype(e);
  const n = create(
    "constraint",
    (a, s) => {
      const i = r && r.name,
        o = s(e, a);
      if (!o.success) return o;
      const u = t(o.value);
      if (!u || "string" == typeof u) {
        const e = "string" == typeof u ? u : `${showValue(a)} failed ${i || "constraint"} check`;
        return failure(e, { fullError: unableToAssign(a, n, e) });
      }
      return success(o.value);
    },
    {
      underlying: e,
      constraint: t,
      name: r && r.name,
      args: r && r.args,
      show(t) {
        return (r && r.name) || `WithConstraint<${show(e, t)}>`;
      },
    },
  );
  return n;
}
function Enum(e, t) {
  const r = Object.values(t),
    n = new Set(r.some(e => "number" == typeof e) ? r.filter(e => "number" == typeof e) : r);
  return create("enum", t => (n.has(t) ? success(t) : expected(e, t)), {
    enumObject: t,
    show: () => e,
  });
}
function InstanceOf(e) {
  return create("instanceof", t => (t instanceof e ? success(t) : expected("" + e.name, t)), {
    ctor: e,
    show() {
      return `InstanceOf<${e.name}>`;
    },
  });
}
function Intersect(...e) {
  return (
    assertRuntype(...e),
    create(
      "intersect",
      (t, r) => {
        if (Array.isArray(t))
          return createValidationPlaceholder([...t], t => {
            for (const n of e) {
              let e = r(n, t);
              if (!e.success) return e;
              if (!Array.isArray(e.value))
                return failure(
                  `The validator ${show(
                    n,
                  )} attempted to convert the type of this value from an array to something else. That conversion is not valid as the child of an intersect`,
                );
              t.splice(0, t.length, ...e.value);
            }
          });
        if (t && "object" == typeof t)
          return createValidationPlaceholder({}, n => {
            for (const a of e) {
              let e = r(a, t);
              if (!e.success) return e;
              if (!e.value || "object" != typeof e.value)
                return failure(
                  `The validator ${show(
                    a,
                  )} attempted to convert the type of this value from an object to something else. That conversion is not valid as the child of an intersect`,
                );
              Object.assign(n, e.value);
            }
          });
        let n = t;
        for (const t of e) {
          let e = r(t, n);
          if (!e.success) return e;
          n = e.value;
        }
        return success(n);
      },
      {
        intersectees: e,
        show(t) {
          return parenthesize("" + e.map(e => show(e, !0)).join(" & "), t);
        },
      },
    )
  );
}
function lazyValue(e) {
  let t;
  return () => t || (t = e());
}
function Lazy(e) {
  const t = lazyValue(e);
  return create("lazy", (e, r, n) => n(t(), e), {
    underlying: t,
    show(e) {
      return show(t(), e);
    },
  });
}
function isLiteralRuntype(e) {
  return "tag" in e && "literal" === e.tag;
}
function Literal(e) {
  return create(
    "literal",
    t =>
      t === e
        ? success(t)
        : failure(
            `Expected literal ${showValue(e)}, but was ${showValue(t)}${
              typeof t != typeof e ? ` (i.e. a ${typeof t})` : ""
            }`,
          ),
    {
      value: e,
      show() {
        return showValue(e);
      },
    },
  );
}
function hasKey(e, t) {
  return "object" == typeof t && e in t;
}
function isObjectRuntype(e) {
  return "tag" in e && "object" === e.tag;
}
function InternalObject(e, t, r) {
  assertRuntype(...Object.values(e));
  const n = create(
    "object",
    (r, a) =>
      null == r || "object" != typeof r
        ? expected(n, r)
        : Array.isArray(r)
        ? failure(`Expected ${show(n)}, but was an Array`)
        : createValidationPlaceholder({}, s => {
            let i,
              o = void 0;
            for (const u in e)
              if (!t || (hasKey(u, r) && void 0 !== r[u])) {
                const l = t || hasKey(u, r) ? r[u] : void 0;
                let c = a(e[u], l);
                c.success
                  ? (s[u] = c.value)
                  : (o || (o = unableToAssign(r, n)),
                    o.push(typesAreNotCompatible(`"${u}"`, c)),
                    (i =
                      i || failure(c.message, { key: c.key ? `${u}.${c.key}` : u, fullError: o })));
              }
            return i;
          }),
    {
      isPartial: t,
      isReadonly: r,
      fields: e,
      asPartial: () => InternalObject(n.fields, !0, n.isReadonly),
      asReadonly: () => InternalObject(n.fields, n.isPartial, !0),
      pick(...n) {
        const a = {};
        for (const t of n) a[t] = e[t];
        return InternalObject(a, t, r);
      },
      omit(...n) {
        const a = { ...e };
        for (const e of n) e in a && delete a[e];
        return InternalObject(a, t, r);
      },
      show() {
        const n = Object.keys(e);
        return n.length
          ? `{ ${n
              .map(n => `${r ? "readonly " : ""}${n}${t ? "?" : ""}: ${show(e[n], !1)};`)
              .join(" ")} }`
          : "{}";
      },
    },
  );
  return n;
}
function Obj(e) {
  return InternalObject(e, !1, !1);
}
function Partial(e) {
  return InternalObject(e, !0, !1);
}
function createPrimative(e) {
  return create(
    e,
    t =>
      typeof t === e
        ? success(t)
        : failure(
            `Expected ${e}, but was ${(e =>
              `${showValue(e)}${"string" == typeof e ? " (i.e. a string literal)" : ""}`)(t)}`,
          ),
    {},
  );
}
function getExpectedBaseType(e) {
  switch (e.tag) {
    case "string":
      return "string";
    case "number":
      return "number";
    case "literal":
      return typeof e.value;
    case "union":
      const t = e.alternatives.map(getExpectedBaseType);
      return t.reduce((e, t) => (e === t ? e : "mixed"), t[0]);
    case "constraint":
      return getExpectedBaseType(e.underlying);
  }
}
function Record(e, t) {
  assertRuntype(e, t);
  const r = lazyValue(() => getExpectedBaseType(e)),
    n = create(
      "record",
      (a, s) =>
        null == a || "object" != typeof a
          ? expected(n, a)
          : Object.getPrototypeOf(a) !== Object.prototype
          ? Array.isArray(a)
            ? failure("Expected Record, but was Array")
            : failure(`Expected ${show(n)}, but was ${Object.getPrototypeOf(a)}`)
          : createValidationPlaceholder({}, n => {
              for (const i in a) {
                let o = null;
                if ("number" === r()) {
                  if (isNaN(+i)) return expected("record key to be a number", i);
                  o = s(e, +i);
                } else
                  "string" === r()
                    ? (o = s(e, i))
                    : ((o = s(e, i)), o.success || isNaN(+i) || (o = s(e, +i)));
                if (!o.success) return expected("record key to be " + show(e), i);
                const u = s(t, a[i]);
                if (!u.success) return failure(u.message, { key: u.key ? `${i}.${u.key}` : i });
                n[o.value] = u.value;
              }
            }),
      {
        key: e,
        value: t,
        show() {
          return `{ [_: ${show(e, !1)}]: ${show(t, !1)} }`;
        },
      },
    );
  return n;
}
function isTupleRuntype(e) {
  return "tag" in e && "tuple" === e.tag;
}
function Tuple(...e) {
  assertRuntype(...e);
  const t = create(
    "tuple",
    (r, n) =>
      Array.isArray(r)
        ? r.length !== e.length
          ? expected("an array of length " + e.length, r.length)
          : createValidationPlaceholder([...r], a => {
              let s,
                i = void 0;
              for (let o = 0; o < e.length; o++) {
                let u = n(e[o], r[o]);
                u.success
                  ? (a[o] = u.value)
                  : (i || (i = unableToAssign(r, t)),
                    i.push(typesAreNotCompatible(`[${o}]`, u)),
                    (s =
                      s ||
                      failure(u.message, {
                        key: u.key ? `[${o}].${u.key}` : `[${o}]`,
                        fullError: i,
                      })));
              }
              return s;
            })
        : expected("tuple to be an array", r),
    {
      components: e,
      show() {
        return `[${e.map(e => show(e, !1)).join(", ")}]`;
      },
    },
  );
  return t;
}
function Brand(e, t) {
  return (
    assertRuntype(t),
    create("brand", (e, r, n) => n(t, e), {
      brand: e,
      entity: t,
      show(e) {
        return show(t, e);
      },
    })
  );
}
function resolveUnderlyingType(e, t) {
  return (e => "tag" in e && "lazy" === e.tag)(e)
    ? resolveUnderlyingType(e.underlying(), t)
    : (e => "tag" in e && "brand" === e.tag)(e)
    ? resolveUnderlyingType(e.entity, t)
    : (e => "tag" in e && "constraint" === e.tag)(e) || ("p" === t && isParsedValueRuntype(e))
    ? resolveUnderlyingType(e.underlying, t)
    : "t" === t && isParsedValueRuntype(e)
    ? e.config.test
      ? resolveUnderlyingType(e.config.test, t)
      : s
    : "s" === t && isParsedValueRuntype(e)
    ? e.config.serialize
      ? e.config.test
        ? resolveUnderlyingType(e.config.test, t)
        : e
      : s
    : e;
}
function Union(...e) {
  function validateWithKey(e, t) {
    return (n, a) => {
      if (!n || "object" != typeof n) return expected(r, n);
      const s = t.get(n[e]);
      if (s) {
        const t = a(s, n);
        return t.success
          ? t
          : failure(t.message, {
              key: `<${0 === e ? "[0]" : e}: ${showValue(n[e])}>${t.key ? "." + t.key : ""}`,
              fullError: unableToAssign(n, r, t),
            });
      }
      {
        const a = expected(
          Array.from(t.keys())
            .map(e => ("string" == typeof e ? `'${e}'` : e))
            .join(" | "),
          n[e],
          { key: 0 === e ? "[0]" : e },
        );
        return (
          (a.fullError = unableToAssign(
            n,
            r,
            typesAreNotCompatible(0 === e ? "[0]" : `"${e}"`, a.message),
          )),
          a
        );
      }
    };
  }
  assertRuntype(...e);
  const validatorOf = t => {
      const n = e.filter(e => "never" !== resolveUnderlyingType(e, t).tag);
      if (n.length) {
        const e = n.map(e => resolveUnderlyingType(e, t)),
          r = e.filter(isObjectRuntype);
        if (r.length === n.length) {
          const e = {};
          for (let a = 0; a < n.length; a++)
            for (const s in r[a].fields) {
              const i = resolveUnderlyingType(r[a].fields[s], t);
              isLiteralRuntype(i) &&
                (e[s] || (e[s] = new Map()), e[s].has(i.value) || e[s].set(i.value, n[a]));
            }
          for (const t of ["type", "kind", "tag", ...Object.keys(e)])
            if (t in e && e[t].size === n.length) return validateWithKey(t, e[t]);
        }
        const a = e.filter(isTupleRuntype);
        if (a.length === n.length) {
          const e = new Map();
          for (let r = 0; r < n.length; r++) {
            const s = resolveUnderlyingType(a[r].components[0], t);
            isLiteralRuntype(s) && (e.has(s.value) || e.set(s.value, n[r]));
          }
          if (e.size === n.length) return validateWithKey(0, e);
        }
      }
      return (t, n) => {
        let a,
          s,
          i,
          o = 0;
        for (const u of e) {
          const e = n(u, t);
          if (e.success) return e;
          i
            ? i.push(andError(e.fullError || unableToAssign(t, u, e)))
            : (i = unableToAssign(t, r, e.fullError || unableToAssign(t, u, e))),
            e.key && (o++, (a = e), (s = u));
        }
        return a && s && 1 === o
          ? failure(a.message, { key: `<${show(s)}>.${a.key}`, fullError: i })
          : expected(r, t, { fullError: i });
      };
    },
    t = lazyValue(() => ({ p: validatorOf("p"), s: validatorOf("s"), t: validatorOf("t") })),
    r = create(
      "union",
      {
        p: (e, r) => t().p(e, r),
        s: (e, r) => t().s(e, r),
        t(e, r) {
          const n = t().s(e, (e, t) => r(e, t) || success(t));
          return n.success ? void 0 : n;
        },
      },
      {
        alternatives: e,
        match: (...t) => n => {
          const a = createVisitedState();
          for (let r = 0; r < e.length; r++) {
            const s = innerValidate(e[r], n, a);
            if (s.success) return t[r](s.value);
          }
          r.assert(n);
        },
        show(t) {
          return parenthesize("" + e.map(e => show(e, !0)).join(" | "), t);
        },
      },
    );
  return r;
}
const parenthesize = (e, t) => (t ? `(${e})` : e),
  e = new Set(),
  show = (t, r = !1) => {
    if (e.has(t) && "lazy" !== t.tag) return parenthesize("CIRCULAR " + t.tag, r);
    if (t.show) {
      e.add(t);
      try {
        return t.show(r);
      } finally {
        e.delete(t);
      }
    }
    return t.tag;
  },
  t = "__internal_runtype_methods__";
class ValidationError extends Error {
  constructor(e) {
    super(showError(e)),
      (this.name = "ValidationError"),
      (this.shortMessage = e.message),
      (this.key = e.key),
      (this.fullError = e.fullError);
  }
}
const r = create("unknown", e => success(e), {}),
  Guard = (e, t) => r.withGuard(e, t),
  n = Literal(void 0),
  a = Literal(null),
  s = create("never", e => expected("nothing", e), {}),
  i = createPrimative("boolean"),
  o = createPrimative("function"),
  u = createPrimative("number"),
  l = createPrimative("string"),
  c = createPrimative("symbol");
export {
  Arr as Array,
  AsyncContract,
  i as Boolean,
  Brand,
  Constraint,
  Contract,
  Enum,
  o as Function,
  Guard,
  InstanceOf,
  Intersect,
  Lazy,
  Literal,
  s as Never,
  a as Null,
  u as Number,
  Obj as Object,
  ParsedValue,
  Partial,
  ReadonlyArray,
  Record,
  l as String,
  c as Symbol,
  Tuple,
  n as Undefined,
  Union,
  r as Unknown,
  ValidationError,
  assertType,
  showError,
  show as showType,
  showValue,
};
