import M from "events";
import { TransportError as h, TransportStatusError as y, StatusCodes as b, TransportRaceCondition as k, TransportInterfaceNotAvailable as I, DisconnectedDeviceDuringOperation as A, TransportWebUSBGestureRequired as S, TransportOpenUserCancelled as U, DisconnectedDevice as N } from "./index-d8a5e2ef.js";
import { ledgerUSBVendorId as _, identifyUSBProductId as E } from "./index-ffbdc3aa.js";
import { l as x } from "./index-07dc1c7e.js";
import "./index-66f1fb88.js";
import "@cosmjs/encoding";
import "@cosmjs/math";
import "@cosmjs/proto-signing";
import "@cosmjs/stargate";
import "long";
import "@ethersproject/bignumber";
import "@ethersproject/abstract-signer";
import "bn.js";
import "bchaddrjs";
import "bitcoinjs-lib";
import "@scure/base";
import "crypto";
import "buffer";
import "util";
import "crypto-js";
import "elliptic";
import "coininfo";
import "base64-js";
import "./index-3e2f6604.js";
var p = globalThis && globalThis.__awaiter || function(u, e, n, t) {
  function r(o) {
    return o instanceof n ? o : new n(function(i) {
      i(o);
    });
  }
  return new (n || (n = Promise))(function(o, i) {
    function s(c) {
      try {
        d(t.next(c));
      } catch (l) {
        i(l);
      }
    }
    function a(c) {
      try {
        d(t.throw(c));
      } catch (l) {
        i(l);
      }
    }
    function d(c) {
      c.done ? o(c.value) : r(c.value).then(s, a);
    }
    d((t = t.apply(u, e || [])).next());
  });
};
class g {
  constructor() {
    this.exchangeTimeout = 3e4, this.unresponsiveTimeout = 15e3, this.deviceModel = null, this._events = new M(), this.send = (e, n, t, r, o = Buffer.alloc(0), i = [b.OK]) => p(this, void 0, void 0, function* () {
      if (o.length >= 256)
        throw new h("data.length exceed 256 bytes limit. Got: " + o.length, "DataLengthTooBig");
      const s = yield this.exchange(Buffer.concat([Buffer.from([e, n, t, r]), Buffer.from([o.length]), o])), a = s.readUInt16BE(s.length - 2);
      if (!i.some((d) => d === a))
        throw new y(a);
      return s;
    }), this.exchangeAtomicImpl = (e) => p(this, void 0, void 0, function* () {
      if (this.exchangeBusyPromise)
        throw new k("An action was already pending on the Ledger device. Please deny or reconnect.");
      let n;
      const t = new Promise((i) => {
        n = i;
      });
      this.exchangeBusyPromise = t;
      let r = !1;
      const o = setTimeout(() => {
        r = !0, this.emit("unresponsive");
      }, this.unresponsiveTimeout);
      try {
        const i = yield e();
        return r && this.emit("responsive"), i;
      } finally {
        clearTimeout(o), n && n(), this.exchangeBusyPromise = null;
      }
    }), this._appAPIlock = null;
  }
  /**
   * Send data to the device using a low level API.
   * It's recommended to use the "send" method for a higher level API.
   * @param {Buffer} apdu - The data to send.
   * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.
   */
  exchange(e) {
    throw new Error("exchange not implemented");
  }
  /**
   * Send apdus in batch to the device using a low level API.
   * The default implementation is to call exchange for each apdu.
   * @param {Array<Buffer>} apdus - array of apdus to send.
   * @param {Observer<Buffer>} observer - an observer that will receive the response of each apdu.
   * @returns {Subscription} A Subscription object on which you can call ".unsubscribe()" to stop sending apdus.
   */
  exchangeBulk(e, n) {
    let t = !1;
    const r = () => {
      t = !0;
    };
    return (() => p(this, void 0, void 0, function* () {
      if (!t)
        for (const i of e) {
          const s = yield this.exchange(i);
          if (t)
            return;
          const a = s.readUInt16BE(s.length - 2);
          if (a !== b.OK)
            throw new y(a);
          n.next(s);
        }
    }))().then(() => !t && n.complete(), (i) => !t && n.error(i)), { unsubscribe: r };
  }
  /**
   * Set the "scramble key" for the next data exchanges with the device.
   * Each app can have a different scramble key and it is set internally during instantiation.
   * @param {string} key - The scramble key to set.
   * @deprecated This method is no longer needed for modern transports and should be migrated away from.
   */
  setScrambleKey(e) {
  }
  /**
   * Close the connection with the device.
   * @returns {Promise<void>} A promise that resolves when the transport is closed.
   */
  close() {
    return Promise.resolve();
  }
  /**
   * Listen for an event on the transport instance.
   * Transport implementations may have specific events. Common events include:
   * "disconnect" : triggered when the transport is disconnected.
   * @param {string} eventName - The name of the event to listen for.
   * @param {(...args: Array<any>) => any} cb - The callback function to be invoked when the event occurs.
   */
  on(e, n) {
    this._events.on(e, n);
  }
  /**
   * Stop listening to an event on an instance of transport.
   */
  off(e, n) {
    this._events.removeListener(e, n);
  }
  emit(e, ...n) {
    this._events.emit(e, ...n);
  }
  /**
   * Enable or not logs of the binary exchange
   */
  setDebugMode() {
    console.warn("setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.");
  }
  /**
   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)
   */
  setExchangeTimeout(e) {
    this.exchangeTimeout = e;
  }
  /**
   * Define the delay before emitting "unresponsive" on an exchange that does not respond
   */
  setExchangeUnresponsiveTimeout(e) {
    this.unresponsiveTimeout = e;
  }
  /**
   * create() allows to open the first descriptor available or
   * throw if there is none or if timeout is reached.
   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)
   * @example
  TransportFoo.create().then(transport => ...)
   */
  static create(e = 3e3, n) {
    return new Promise((t, r) => {
      let o = !1;
      const i = this.listen({
        next: (a) => {
          o = !0, i && i.unsubscribe(), s && clearTimeout(s), this.open(a.descriptor, e).then(t, r);
        },
        error: (a) => {
          s && clearTimeout(s), r(a);
        },
        complete: () => {
          s && clearTimeout(s), o || r(new h(this.ErrorMessage_NoDeviceFound, "NoDeviceFound"));
        }
      }), s = n ? setTimeout(() => {
        i.unsubscribe(), r(new h(this.ErrorMessage_ListenTimeout, "ListenTimeout"));
      }, n) : null;
    });
  }
  decorateAppAPIMethods(e, n, t) {
    for (const r of n)
      e[r] = this.decorateAppAPIMethod(r, e[r], e, t);
  }
  decorateAppAPIMethod(e, n, t, r) {
    return (...o) => p(this, void 0, void 0, function* () {
      const { _appAPIlock: i } = this;
      if (i)
        return Promise.reject(new h("Ledger Device is busy (lock " + i + ")", "TransportLocked"));
      try {
        return this._appAPIlock = e, this.setScrambleKey(r), yield n.apply(t, o);
      } finally {
        this._appAPIlock = null;
      }
    });
  }
}
g.ErrorMessage_ListenTimeout = "No Ledger device found (timeout)";
g.ErrorMessage_NoDeviceFound = "No Ledger device found";
const B = 5;
function P(u) {
  const e = Buffer.alloc(2);
  return e.writeUInt16BE(u, 0), e;
}
const q = {
  data: Buffer.alloc(0),
  dataLength: 0,
  sequence: 0
}, R = (u, e) => ({
  makeBlocks(n) {
    let t = Buffer.concat([P(n.length), n]);
    const r = e - 5, o = Math.ceil(t.length / r);
    t = Buffer.concat([
      t,
      Buffer.alloc(o * r - t.length + 1).fill(0)
    ]);
    const i = [];
    for (let s = 0; s < o; s++) {
      const a = Buffer.alloc(5);
      a.writeUInt16BE(u, 0), a.writeUInt8(B, 2), a.writeUInt16BE(s, 3);
      const d = t.slice(s * r, (s + 1) * r);
      i.push(Buffer.concat([a, d]));
    }
    return i;
  },
  reduceResponse(n, t) {
    let { data: r, dataLength: o, sequence: i } = n || q;
    if (t.readUInt16BE(0) !== u)
      throw new h("Invalid channel", "InvalidChannel");
    if (t.readUInt8(2) !== B)
      throw new h("Invalid tag", "InvalidTag");
    if (t.readUInt16BE(3) !== i)
      throw new h("Invalid sequence", "InvalidSequence");
    n || (o = t.readUInt16BE(5)), i++;
    const s = t.slice(n ? 5 : 7);
    return r = Buffer.concat([r, s]), r.length > o && (r = r.slice(0, o)), {
      data: r,
      dataLength: o,
      sequence: i
    };
  },
  getReducedResult(n) {
    if (n && n.dataLength === n.data.length)
      return n.data;
  }
});
var v = globalThis && globalThis.__awaiter || function(u, e, n, t) {
  function r(o) {
    return o instanceof n ? o : new n(function(i) {
      i(o);
    });
  }
  return new (n || (n = Promise))(function(o, i) {
    function s(c) {
      try {
        d(t.next(c));
      } catch (l) {
        i(l);
      }
    }
    function a(c) {
      try {
        d(t.throw(c));
      } catch (l) {
        i(l);
      }
    }
    function d(c) {
      c.done ? o(c.value) : r(c.value).then(s, a);
    }
    d((t = t.apply(u, e || [])).next());
  });
};
const C = [
  {
    vendorId: _
  }
];
function L() {
  return v(this, void 0, void 0, function* () {
    return yield navigator.usb.requestDevice({
      filters: C
    });
  });
}
function w() {
  return v(this, void 0, void 0, function* () {
    return (yield navigator.usb.getDevices()).filter((e) => e.vendorId === _);
  });
}
function O() {
  return v(this, void 0, void 0, function* () {
    const u = yield w();
    return u.length > 0 ? u[0] : L();
  });
}
const K = () => Promise.resolve(!!navigator && !!navigator.usb && typeof navigator.usb.getDevices == "function");
var f = globalThis && globalThis.__awaiter || function(u, e, n, t) {
  function r(o) {
    return o instanceof n ? o : new n(function(i) {
      i(o);
    });
  }
  return new (n || (n = Promise))(function(o, i) {
    function s(c) {
      try {
        d(t.next(c));
      } catch (l) {
        i(l);
      }
    }
    function a(c) {
      try {
        d(t.throw(c));
      } catch (l) {
        i(l);
      }
    }
    function d(c) {
      c.done ? o(c.value) : r(c.value).then(s, a);
    }
    d((t = t.apply(u, e || [])).next());
  });
};
const F = 1, T = 3;
class m extends g {
  constructor(e, n) {
    super(), this.channel = Math.floor(Math.random() * 65535), this.packetSize = 64, this._disconnectEmitted = !1, this._emitDisconnect = (t) => {
      this._disconnectEmitted || (this._disconnectEmitted = !0, this.emit("disconnect", t));
    }, this.device = e, this.interfaceNumber = n, this.deviceModel = E(e.productId);
  }
  /**
   * Similar to create() except it will always display the device permission (even if some devices are already accepted).
   */
  static request() {
    return f(this, void 0, void 0, function* () {
      const e = yield L();
      return m.open(e);
    });
  }
  /**
   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).
   */
  static openConnected() {
    return f(this, void 0, void 0, function* () {
      const e = yield w();
      return e.length === 0 ? null : m.open(e[0]);
    });
  }
  /**
   * Create a Ledger transport with a USBDevice
   */
  static open(e) {
    return f(this, void 0, void 0, function* () {
      yield e.open(), e.configuration === null && (yield e.selectConfiguration(F)), yield D(e);
      const n = e.configurations[0].interfaces.find(({ alternates: i }) => i.some((s) => s.interfaceClass === 255));
      if (!n)
        throw new I("No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.");
      const t = n.interfaceNumber;
      try {
        yield e.claimInterface(t);
      } catch (i) {
        throw yield e.close(), new I(i.message);
      }
      const r = new m(e, t), o = (i) => {
        e === i.device && (navigator.usb.removeEventListener("disconnect", o), r._emitDisconnect(new N()));
      };
      return navigator.usb.addEventListener("disconnect", o), r;
    });
  }
  /**
   * Release the transport device
   */
  close() {
    return f(this, void 0, void 0, function* () {
      yield this.exchangeBusyPromise, yield this.device.releaseInterface(this.interfaceNumber), yield D(this.device), yield this.device.close();
    });
  }
  /**
   * Exchange with the device using APDU protocol.
   * @param apdu
   * @returns a promise of apdu response
   */
  exchange(e) {
    return f(this, void 0, void 0, function* () {
      return yield this.exchangeAtomicImpl(() => f(this, void 0, void 0, function* () {
        const { channel: t, packetSize: r } = this;
        x("apdu", "=> " + e.toString("hex"));
        const o = R(t, r), i = o.makeBlocks(e);
        for (let d = 0; d < i.length; d++)
          yield this.device.transferOut(T, i[d]);
        let s, a;
        for (; !(s = o.getReducedResult(a)); ) {
          const d = yield this.device.transferIn(T, r), c = Buffer.from(d.data.buffer);
          a = o.reduceResponse(a, c);
        }
        return x("apdu", "<= " + s.toString("hex")), s;
      })).catch((t) => {
        throw t && t.message && t.message.includes("disconnected") ? (this._emitDisconnect(t), new A(t.message)) : t;
      });
    });
  }
  setScrambleKey() {
  }
}
m.isSupported = K;
m.list = w;
m.listen = (u) => {
  let e = !1;
  O().then((t) => {
    if (!e) {
      const r = E(t.productId);
      u.next({
        type: "add",
        descriptor: t,
        deviceModel: r
      }), u.complete();
    }
  }, (t) => {
    window.DOMException && t instanceof window.DOMException && t.code === 18 ? u.error(new S(t.message)) : u.error(new U(t.message));
  });
  function n() {
    e = !0;
  }
  return {
    unsubscribe: n
  };
};
function D(u) {
  return f(this, void 0, void 0, function* () {
    try {
      yield u.reset();
    } catch (e) {
      console.warn(e);
    }
  });
}
export {
  m as default
};
