import { b as Ar } from "./index-fb244210.js";
import { s as ne, i as ce, h as Hi, g as st, r as Wi, a as ti, R as ri } from "./index-66f1fb88.js";
import ji from "string_decoder";
import { crypto as Se } from "bitcoinjs-lib";
import { l as zi } from "./index-3e2f6604.js";
import Yi from "bn.js";
import Zi from "elliptic";
import { l as ni } from "./index-07dc1c7e.js";
import { i as ii } from "./browser-4b2a9578.js";
import "@cosmjs/encoding";
import "@cosmjs/math";
import "@cosmjs/proto-signing";
import "@cosmjs/stargate";
import "long";
import "@ethersproject/bignumber";
import "@ethersproject/abstract-signer";
import "bchaddrjs";
import "@scure/base";
import "crypto";
import "buffer";
import "events";
import "util";
import "crypto-js";
import "coininfo";
import "base64-js";
var Qi = ce, si = Hi, Ji = ne.Buffer, es = new Array(16);
function At() {
  si.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
Qi(At, si);
At.prototype._update = function() {
  for (var t = es, r = 0; r < 16; ++r)
    t[r] = this._block.readInt32LE(r * 4);
  var e = this._a, i = this._b, s = this._c, n = this._d;
  e = Y(e, i, s, n, t[0], 3614090360, 7), n = Y(n, e, i, s, t[1], 3905402710, 12), s = Y(s, n, e, i, t[2], 606105819, 17), i = Y(i, s, n, e, t[3], 3250441966, 22), e = Y(e, i, s, n, t[4], 4118548399, 7), n = Y(n, e, i, s, t[5], 1200080426, 12), s = Y(s, n, e, i, t[6], 2821735955, 17), i = Y(i, s, n, e, t[7], 4249261313, 22), e = Y(e, i, s, n, t[8], 1770035416, 7), n = Y(n, e, i, s, t[9], 2336552879, 12), s = Y(s, n, e, i, t[10], 4294925233, 17), i = Y(i, s, n, e, t[11], 2304563134, 22), e = Y(e, i, s, n, t[12], 1804603682, 7), n = Y(n, e, i, s, t[13], 4254626195, 12), s = Y(s, n, e, i, t[14], 2792965006, 17), i = Y(i, s, n, e, t[15], 1236535329, 22), e = Z(e, i, s, n, t[1], 4129170786, 5), n = Z(n, e, i, s, t[6], 3225465664, 9), s = Z(s, n, e, i, t[11], 643717713, 14), i = Z(i, s, n, e, t[0], 3921069994, 20), e = Z(e, i, s, n, t[5], 3593408605, 5), n = Z(n, e, i, s, t[10], 38016083, 9), s = Z(s, n, e, i, t[15], 3634488961, 14), i = Z(i, s, n, e, t[4], 3889429448, 20), e = Z(e, i, s, n, t[9], 568446438, 5), n = Z(n, e, i, s, t[14], 3275163606, 9), s = Z(s, n, e, i, t[3], 4107603335, 14), i = Z(i, s, n, e, t[8], 1163531501, 20), e = Z(e, i, s, n, t[13], 2850285829, 5), n = Z(n, e, i, s, t[2], 4243563512, 9), s = Z(s, n, e, i, t[7], 1735328473, 14), i = Z(i, s, n, e, t[12], 2368359562, 20), e = Q(e, i, s, n, t[5], 4294588738, 4), n = Q(n, e, i, s, t[8], 2272392833, 11), s = Q(s, n, e, i, t[11], 1839030562, 16), i = Q(i, s, n, e, t[14], 4259657740, 23), e = Q(e, i, s, n, t[1], 2763975236, 4), n = Q(n, e, i, s, t[4], 1272893353, 11), s = Q(s, n, e, i, t[7], 4139469664, 16), i = Q(i, s, n, e, t[10], 3200236656, 23), e = Q(e, i, s, n, t[13], 681279174, 4), n = Q(n, e, i, s, t[0], 3936430074, 11), s = Q(s, n, e, i, t[3], 3572445317, 16), i = Q(i, s, n, e, t[6], 76029189, 23), e = Q(e, i, s, n, t[9], 3654602809, 4), n = Q(n, e, i, s, t[12], 3873151461, 11), s = Q(s, n, e, i, t[15], 530742520, 16), i = Q(i, s, n, e, t[2], 3299628645, 23), e = J(e, i, s, n, t[0], 4096336452, 6), n = J(n, e, i, s, t[7], 1126891415, 10), s = J(s, n, e, i, t[14], 2878612391, 15), i = J(i, s, n, e, t[5], 4237533241, 21), e = J(e, i, s, n, t[12], 1700485571, 6), n = J(n, e, i, s, t[3], 2399980690, 10), s = J(s, n, e, i, t[10], 4293915773, 15), i = J(i, s, n, e, t[1], 2240044497, 21), e = J(e, i, s, n, t[8], 1873313359, 6), n = J(n, e, i, s, t[15], 4264355552, 10), s = J(s, n, e, i, t[6], 2734768916, 15), i = J(i, s, n, e, t[13], 1309151649, 21), e = J(e, i, s, n, t[4], 4149444226, 6), n = J(n, e, i, s, t[11], 3174756917, 10), s = J(s, n, e, i, t[2], 718787259, 15), i = J(i, s, n, e, t[9], 3951481745, 21), this._a = this._a + e | 0, this._b = this._b + i | 0, this._c = this._c + s | 0, this._d = this._d + n | 0;
};
At.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var t = Ji.allocUnsafe(16);
  return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t;
};
function Ot(t, r) {
  return t << r | t >>> 32 - r;
}
function Y(t, r, e, i, s, n, o) {
  return Ot(t + (r & e | ~r & i) + s + n | 0, o) + r | 0;
}
function Z(t, r, e, i, s, n, o) {
  return Ot(t + (r & i | e & ~i) + s + n | 0, o) + r | 0;
}
function Q(t, r, e, i, s, n, o) {
  return Ot(t + (r ^ e ^ i) + s + n | 0, o) + r | 0;
}
function J(t, r, e, i, s, n, o) {
  return Ot(t + (e ^ (r | ~i)) + s + n | 0, o) + r | 0;
}
var ai = At, oi = { exports: {} }, ui = ne.Buffer;
function Nt(t, r) {
  this._block = ui.alloc(t), this._finalSize = r, this._blockSize = t, this._len = 0;
}
Nt.prototype.update = function(t, r) {
  typeof t == "string" && (r = r || "utf8", t = ui.from(t, r));
  for (var e = this._block, i = this._blockSize, s = t.length, n = this._len, o = 0; o < s; ) {
    for (var u = n % i, c = Math.min(s - o, i - u), a = 0; a < c; a++)
      e[u + a] = t[o + a];
    n += c, o += c, n % i === 0 && this._update(e);
  }
  return this._len += s, this;
};
Nt.prototype.digest = function(t) {
  var r = this._len % this._blockSize;
  this._block[r] = 128, this._block.fill(0, r + 1), r >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var e = this._len * 8;
  if (e <= 4294967295)
    this._block.writeUInt32BE(e, this._blockSize - 4);
  else {
    var i = (e & 4294967295) >>> 0, s = (e - i) / 4294967296;
    this._block.writeUInt32BE(s, this._blockSize - 8), this._block.writeUInt32BE(i, this._blockSize - 4);
  }
  this._update(this._block);
  var n = this._hash();
  return t ? n.toString(t) : n;
};
Nt.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var He = Nt, ts = ce, fi = He, rs = ne.Buffer, ns = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], is = new Array(80);
function at() {
  this.init(), this._w = is, fi.call(this, 64, 56);
}
ts(at, fi);
at.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function ss(t) {
  return t << 5 | t >>> 27;
}
function as(t) {
  return t << 30 | t >>> 2;
}
function os(t, r, e, i) {
  return t === 0 ? r & e | ~r & i : t === 2 ? r & e | r & i | e & i : r ^ e ^ i;
}
at.prototype._update = function(t) {
  for (var r = this._w, e = this._a | 0, i = this._b | 0, s = this._c | 0, n = this._d | 0, o = this._e | 0, u = 0; u < 16; ++u)
    r[u] = t.readInt32BE(u * 4);
  for (; u < 80; ++u)
    r[u] = r[u - 3] ^ r[u - 8] ^ r[u - 14] ^ r[u - 16];
  for (var c = 0; c < 80; ++c) {
    var a = ~~(c / 20), f = ss(e) + os(a, i, s, n) + o + r[c] + ns[a] | 0;
    o = n, n = s, s = as(i), i = e, e = f;
  }
  this._a = e + this._a | 0, this._b = i + this._b | 0, this._c = s + this._c | 0, this._d = n + this._d | 0, this._e = o + this._e | 0;
};
at.prototype._hash = function() {
  var t = rs.allocUnsafe(20);
  return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
};
var us = at, fs = ce, ci = He, cs = ne.Buffer, ls = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], hs = new Array(80);
function ot() {
  this.init(), this._w = hs, ci.call(this, 64, 56);
}
fs(ot, ci);
ot.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function ps(t) {
  return t << 1 | t >>> 31;
}
function ds(t) {
  return t << 5 | t >>> 27;
}
function vs(t) {
  return t << 30 | t >>> 2;
}
function gs(t, r, e, i) {
  return t === 0 ? r & e | ~r & i : t === 2 ? r & e | r & i | e & i : r ^ e ^ i;
}
ot.prototype._update = function(t) {
  for (var r = this._w, e = this._a | 0, i = this._b | 0, s = this._c | 0, n = this._d | 0, o = this._e | 0, u = 0; u < 16; ++u)
    r[u] = t.readInt32BE(u * 4);
  for (; u < 80; ++u)
    r[u] = ps(r[u - 3] ^ r[u - 8] ^ r[u - 14] ^ r[u - 16]);
  for (var c = 0; c < 80; ++c) {
    var a = ~~(c / 20), f = ds(e) + gs(a, i, s, n) + o + r[c] + ls[a] | 0;
    o = n, n = s, s = vs(i), i = e, e = f;
  }
  this._a = e + this._a | 0, this._b = i + this._b | 0, this._c = s + this._c | 0, this._d = n + this._d | 0, this._e = o + this._e | 0;
};
ot.prototype._hash = function() {
  var t = cs.allocUnsafe(20);
  return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
};
var ws = ot, xs = ce, li = He, Es = ne.Buffer, ys = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], _s = new Array(64);
function ut() {
  this.init(), this._w = _s, li.call(this, 64, 56);
}
xs(ut, li);
ut.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function ms(t, r, e) {
  return e ^ t & (r ^ e);
}
function bs(t, r, e) {
  return t & r | e & (t | r);
}
function Is(t) {
  return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10);
}
function Ts(t) {
  return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7);
}
function Ss(t) {
  return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3;
}
function Bs(t) {
  return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10;
}
ut.prototype._update = function(t) {
  for (var r = this._w, e = this._a | 0, i = this._b | 0, s = this._c | 0, n = this._d | 0, o = this._e | 0, u = this._f | 0, c = this._g | 0, a = this._h | 0, f = 0; f < 16; ++f)
    r[f] = t.readInt32BE(f * 4);
  for (; f < 64; ++f)
    r[f] = Bs(r[f - 2]) + r[f - 7] + Ss(r[f - 15]) + r[f - 16] | 0;
  for (var l = 0; l < 64; ++l) {
    var v = a + Ts(o) + ms(o, u, c) + ys[l] + r[l] | 0, h = Is(e) + bs(e, i, s) | 0;
    a = c, c = u, u = o, o = n + v | 0, n = s, s = i, i = e, e = v + h | 0;
  }
  this._a = e + this._a | 0, this._b = i + this._b | 0, this._c = s + this._c | 0, this._d = n + this._d | 0, this._e = o + this._e | 0, this._f = u + this._f | 0, this._g = c + this._g | 0, this._h = a + this._h | 0;
};
ut.prototype._hash = function() {
  var t = Es.allocUnsafe(32);
  return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t;
};
var hi = ut, $s = ce, Rs = hi, As = He, Os = ne.Buffer, Ns = new Array(64);
function Pt() {
  this.init(), this._w = Ns, As.call(this, 64, 56);
}
$s(Pt, Rs);
Pt.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
Pt.prototype._hash = function() {
  var t = Os.allocUnsafe(28);
  return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t;
};
var Ps = Pt, Ls = ce, pi = He, Cs = ne.Buffer, nn = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
], Ds = new Array(160);
function ft() {
  this.init(), this._w = Ds, pi.call(this, 128, 112);
}
Ls(ft, pi);
ft.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function sn(t, r, e) {
  return e ^ t & (r ^ e);
}
function an(t, r, e) {
  return t & r | e & (t | r);
}
function on(t, r) {
  return (t >>> 28 | r << 4) ^ (r >>> 2 | t << 30) ^ (r >>> 7 | t << 25);
}
function un(t, r) {
  return (t >>> 14 | r << 18) ^ (t >>> 18 | r << 14) ^ (r >>> 9 | t << 23);
}
function Us(t, r) {
  return (t >>> 1 | r << 31) ^ (t >>> 8 | r << 24) ^ t >>> 7;
}
function ks(t, r) {
  return (t >>> 1 | r << 31) ^ (t >>> 8 | r << 24) ^ (t >>> 7 | r << 25);
}
function Ms(t, r) {
  return (t >>> 19 | r << 13) ^ (r >>> 29 | t << 3) ^ t >>> 6;
}
function Gs(t, r) {
  return (t >>> 19 | r << 13) ^ (r >>> 29 | t << 3) ^ (t >>> 6 | r << 26);
}
function W(t, r) {
  return t >>> 0 < r >>> 0 ? 1 : 0;
}
ft.prototype._update = function(t) {
  for (var r = this._w, e = this._ah | 0, i = this._bh | 0, s = this._ch | 0, n = this._dh | 0, o = this._eh | 0, u = this._fh | 0, c = this._gh | 0, a = this._hh | 0, f = this._al | 0, l = this._bl | 0, v = this._cl | 0, h = this._dl | 0, w = this._el | 0, b = this._fl | 0, x = this._gl | 0, B = this._hl | 0, p = 0; p < 32; p += 2)
    r[p] = t.readInt32BE(p * 4), r[p + 1] = t.readInt32BE(p * 4 + 4);
  for (; p < 160; p += 2) {
    var $ = r[p - 30], R = r[p - 15 * 2 + 1], P = Us($, R), I = ks(R, $);
    $ = r[p - 2 * 2], R = r[p - 2 * 2 + 1];
    var U = Ms($, R), L = Gs(R, $), X = r[p - 7 * 2], A = r[p - 7 * 2 + 1], k = r[p - 16 * 2], N = r[p - 16 * 2 + 1], d = I + A | 0, g = P + X + W(d, I) | 0;
    d = d + L | 0, g = g + U + W(d, L) | 0, d = d + N | 0, g = g + k + W(d, N) | 0, r[p] = g, r[p + 1] = d;
  }
  for (var _ = 0; _ < 160; _ += 2) {
    g = r[_], d = r[_ + 1];
    var T = an(e, i, s), E = an(f, l, v), y = on(e, f), O = on(f, e), S = un(o, w), m = un(w, o), D = nn[_], K = nn[_ + 1], G = sn(o, u, c), H = sn(w, b, x), q = B + m | 0, ee = a + S + W(q, B) | 0;
    q = q + H | 0, ee = ee + G + W(q, H) | 0, q = q + K | 0, ee = ee + D + W(q, K) | 0, q = q + d | 0, ee = ee + g + W(q, d) | 0;
    var de = O + E | 0, ge = y + T + W(de, O) | 0;
    a = c, B = x, c = u, x = b, u = o, b = w, w = h + q | 0, o = n + ee + W(w, h) | 0, n = s, h = v, s = i, v = l, i = e, l = f, f = q + de | 0, e = ee + ge + W(f, q) | 0;
  }
  this._al = this._al + f | 0, this._bl = this._bl + l | 0, this._cl = this._cl + v | 0, this._dl = this._dl + h | 0, this._el = this._el + w | 0, this._fl = this._fl + b | 0, this._gl = this._gl + x | 0, this._hl = this._hl + B | 0, this._ah = this._ah + e + W(this._al, f) | 0, this._bh = this._bh + i + W(this._bl, l) | 0, this._ch = this._ch + s + W(this._cl, v) | 0, this._dh = this._dh + n + W(this._dl, h) | 0, this._eh = this._eh + o + W(this._el, w) | 0, this._fh = this._fh + u + W(this._fl, b) | 0, this._gh = this._gh + c + W(this._gl, x) | 0, this._hh = this._hh + a + W(this._hl, B) | 0;
};
ft.prototype._hash = function() {
  var t = Cs.allocUnsafe(64);
  function r(e, i, s) {
    t.writeInt32BE(e, s), t.writeInt32BE(i, s + 4);
  }
  return r(this._ah, this._al, 0), r(this._bh, this._bl, 8), r(this._ch, this._cl, 16), r(this._dh, this._dl, 24), r(this._eh, this._el, 32), r(this._fh, this._fl, 40), r(this._gh, this._gl, 48), r(this._hh, this._hl, 56), t;
};
var di = ft, Fs = ce, Vs = di, Ks = He, qs = ne.Buffer, Xs = new Array(160);
function Lt() {
  this.init(), this._w = Xs, Ks.call(this, 128, 112);
}
Fs(Lt, Vs);
Lt.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
Lt.prototype._hash = function() {
  var t = qs.allocUnsafe(48);
  function r(e, i, s) {
    t.writeInt32BE(e, s), t.writeInt32BE(i, s + 4);
  }
  return r(this._ah, this._al, 0), r(this._bh, this._bl, 8), r(this._ch, this._cl, 16), r(this._dh, this._dl, 24), r(this._eh, this._el, 32), r(this._fh, this._fl, 40), t;
};
var Hs = Lt, Ae = oi.exports = function(r) {
  r = r.toLowerCase();
  var e = Ae[r];
  if (!e)
    throw new Error(r + " is not supported (we accept pull requests)");
  return new e();
};
Ae.sha = us;
Ae.sha1 = ws;
Ae.sha224 = Ps;
Ae.sha256 = hi;
Ae.sha384 = Hs;
Ae.sha512 = di;
var Or = oi.exports;
const mt = /* @__PURE__ */ st(Or);
var vi = ne.Buffer, gi = Wi.Transform, Ws = ji.StringDecoder, js = ce;
function le(t) {
  gi.call(this), this.hashMode = typeof t == "string", this.hashMode ? this[t] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
}
js(le, gi);
le.prototype.update = function(t, r, e) {
  typeof t == "string" && (t = vi.from(t, r));
  var i = this._update(t);
  return this.hashMode ? this : (e && (i = this._toString(i, e)), i);
};
le.prototype.setAutoPadding = function() {
};
le.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
le.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
le.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
le.prototype._transform = function(t, r, e) {
  var i;
  try {
    this.hashMode ? this._update(t) : this.push(this._update(t));
  } catch (s) {
    i = s;
  } finally {
    e(i);
  }
};
le.prototype._flush = function(t) {
  var r;
  try {
    this.push(this.__final());
  } catch (e) {
    r = e;
  }
  t(r);
};
le.prototype._finalOrDigest = function(t) {
  var r = this.__final() || vi.alloc(0);
  return t && (r = this._toString(r, t, !0)), r;
};
le.prototype._toString = function(t, r, e) {
  if (this._decoder || (this._decoder = new Ws(r), this._encoding = r), this._encoding !== r)
    throw new Error("can't switch encodings");
  var i = this._decoder.write(t);
  return e && (i += this._decoder.end()), i;
};
var Nr = le, zs = ce, Ys = ai, Zs = ti, Qs = Or, wi = Nr;
function Ct(t) {
  wi.call(this, "digest"), this._hash = t;
}
zs(Ct, wi);
Ct.prototype._update = function(t) {
  this._hash.update(t);
};
Ct.prototype._final = function() {
  return this._hash.digest();
};
var Js = function(r) {
  return r = r.toLowerCase(), r === "md5" ? new Ys() : r === "rmd160" || r === "ripemd160" ? new Zs() : new Ct(Qs(r));
}, wt = ne.Buffer;
function ea(t) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), e = 0; e < r.length; e++)
    r[e] = 255;
  for (var i = 0; i < t.length; i++) {
    var s = t.charAt(i), n = s.charCodeAt(0);
    if (r[n] !== 255)
      throw new TypeError(s + " is ambiguous");
    r[n] = i;
  }
  var o = t.length, u = t.charAt(0), c = Math.log(o) / Math.log(256), a = Math.log(256) / Math.log(o);
  function f(h) {
    if ((Array.isArray(h) || h instanceof Uint8Array) && (h = wt.from(h)), !wt.isBuffer(h))
      throw new TypeError("Expected Buffer");
    if (h.length === 0)
      return "";
    for (var w = 0, b = 0, x = 0, B = h.length; x !== B && h[x] === 0; )
      x++, w++;
    for (var p = (B - x) * a + 1 >>> 0, $ = new Uint8Array(p); x !== B; ) {
      for (var R = h[x], P = 0, I = p - 1; (R !== 0 || P < b) && I !== -1; I--, P++)
        R += 256 * $[I] >>> 0, $[I] = R % o >>> 0, R = R / o >>> 0;
      if (R !== 0)
        throw new Error("Non-zero carry");
      b = P, x++;
    }
    for (var U = p - b; U !== p && $[U] === 0; )
      U++;
    for (var L = u.repeat(w); U < p; ++U)
      L += t.charAt($[U]);
    return L;
  }
  function l(h) {
    if (typeof h != "string")
      throw new TypeError("Expected String");
    if (h.length === 0)
      return wt.alloc(0);
    for (var w = 0, b = 0, x = 0; h[w] === u; )
      b++, w++;
    for (var B = (h.length - w) * c + 1 >>> 0, p = new Uint8Array(B); h[w]; ) {
      var $ = r[h.charCodeAt(w)];
      if ($ === 255)
        return;
      for (var R = 0, P = B - 1; ($ !== 0 || R < x) && P !== -1; P--, R++)
        $ += o * p[P] >>> 0, p[P] = $ % 256 >>> 0, $ = $ / 256 >>> 0;
      if ($ !== 0)
        throw new Error("Non-zero carry");
      x = R, w++;
    }
    for (var I = B - x; I !== B && p[I] === 0; )
      I++;
    var U = wt.allocUnsafe(b + (B - I));
    U.fill(0, 0, b);
    for (var L = b; I !== B; )
      U[L++] = p[I++];
    return U;
  }
  function v(h) {
    var w = l(h);
    if (w)
      return w;
    throw new Error("Non-base" + o + " character");
  }
  return {
    encode: f,
    decodeUnsafe: l,
    decode: v
  };
}
var ta = ea, ra = ta, na = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", xi = ra(na);
const ia = /* @__PURE__ */ st(xi);
var er = xi, sa = ne.Buffer, aa = function(t) {
  function r(n) {
    var o = t(n);
    return er.encode(sa.concat([
      n,
      o
    ], n.length + 4));
  }
  function e(n) {
    var o = n.slice(0, -4), u = n.slice(-4), c = t(o);
    if (!(u[0] ^ c[0] | u[1] ^ c[1] | u[2] ^ c[2] | u[3] ^ c[3]))
      return o;
  }
  function i(n) {
    var o = er.decodeUnsafe(n);
    if (o)
      return e(o);
  }
  function s(n) {
    var o = er.decode(n), u = e(o);
    if (!u)
      throw new Error("Invalid checksum");
    return u;
  }
  return {
    encode: r,
    decode: s,
    decodeUnsafe: i
  };
}, fn = Js, oa = aa;
function ua(t) {
  var r = fn("sha256").update(t).digest();
  return fn("sha256").update(r).digest();
}
var fa = oa(ua);
const Ei = /* @__PURE__ */ st(fa);
function yi(t) {
  var r = Buffer.alloc(1 + t.length * 4);
  return r[0] = t.length, t.forEach(function(e, i) {
    r.writeUInt32BE(e, 1 + 4 * i);
  }), r;
}
function Pr(t) {
  var r = t ? xe(t) : [];
  return yi(r);
}
function Lr(t) {
  return Ar.fromPathArray(t).toString();
}
function xe(t) {
  return Ar.fromString(t).toPathArray();
}
function cn(t) {
  var r = Ei.decode(t);
  return r.slice(r.length - 33);
}
function ln(t) {
  var r = Ei.decode(t);
  return {
    chaincode: r.slice(13, 13 + 32),
    pubkey: r.slice(r.length - 33),
    version: r.readUInt32BE(0)
  };
}
function ca(t) {
  for (var r = t.length - 1; r >= 0; r--)
    if (t[r] >= 2147483648)
      return t.slice(0, r + 1);
  return [];
}
var dr = { exports: {} };
const la = "2.0.0", ha = 256, pa = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, da = 16, va = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var Dt = {
  MAX_LENGTH: ha,
  MAX_SAFE_COMPONENT_LENGTH: da,
  MAX_SAFE_INTEGER: pa,
  RELEASE_TYPES: va,
  SEMVER_SPEC_VERSION: la,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const ga = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...t) => console.error("SEMVER", ...t) : () => {
};
var Ut = ga;
(function(t, r) {
  const { MAX_SAFE_COMPONENT_LENGTH: e } = Dt, i = Ut;
  r = t.exports = {};
  const s = r.re = [], n = r.safeRe = [], o = r.src = [], u = r.t = {};
  let c = 0;
  const a = (f, l, v) => {
    const h = l.split("\\s*").join("\\s{0,1}").split("\\s+").join("\\s"), w = c++;
    i(f, w, l), u[f] = w, o[w] = l, s[w] = new RegExp(l, v ? "g" : void 0), n[w] = new RegExp(h, v ? "g" : void 0);
  };
  a("NUMERICIDENTIFIER", "0|[1-9]\\d*"), a("NUMERICIDENTIFIERLOOSE", "[0-9]+"), a("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), a("MAINVERSION", `(${o[u.NUMERICIDENTIFIER]})\\.(${o[u.NUMERICIDENTIFIER]})\\.(${o[u.NUMERICIDENTIFIER]})`), a("MAINVERSIONLOOSE", `(${o[u.NUMERICIDENTIFIERLOOSE]})\\.(${o[u.NUMERICIDENTIFIERLOOSE]})\\.(${o[u.NUMERICIDENTIFIERLOOSE]})`), a("PRERELEASEIDENTIFIER", `(?:${o[u.NUMERICIDENTIFIER]}|${o[u.NONNUMERICIDENTIFIER]})`), a("PRERELEASEIDENTIFIERLOOSE", `(?:${o[u.NUMERICIDENTIFIERLOOSE]}|${o[u.NONNUMERICIDENTIFIER]})`), a("PRERELEASE", `(?:-(${o[u.PRERELEASEIDENTIFIER]}(?:\\.${o[u.PRERELEASEIDENTIFIER]})*))`), a("PRERELEASELOOSE", `(?:-?(${o[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${o[u.PRERELEASEIDENTIFIERLOOSE]})*))`), a("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), a("BUILD", `(?:\\+(${o[u.BUILDIDENTIFIER]}(?:\\.${o[u.BUILDIDENTIFIER]})*))`), a("FULLPLAIN", `v?${o[u.MAINVERSION]}${o[u.PRERELEASE]}?${o[u.BUILD]}?`), a("FULL", `^${o[u.FULLPLAIN]}$`), a("LOOSEPLAIN", `[v=\\s]*${o[u.MAINVERSIONLOOSE]}${o[u.PRERELEASELOOSE]}?${o[u.BUILD]}?`), a("LOOSE", `^${o[u.LOOSEPLAIN]}$`), a("GTLT", "((?:<|>)?=?)"), a("XRANGEIDENTIFIERLOOSE", `${o[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), a("XRANGEIDENTIFIER", `${o[u.NUMERICIDENTIFIER]}|x|X|\\*`), a("XRANGEPLAIN", `[v=\\s]*(${o[u.XRANGEIDENTIFIER]})(?:\\.(${o[u.XRANGEIDENTIFIER]})(?:\\.(${o[u.XRANGEIDENTIFIER]})(?:${o[u.PRERELEASE]})?${o[u.BUILD]}?)?)?`), a("XRANGEPLAINLOOSE", `[v=\\s]*(${o[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${o[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${o[u.XRANGEIDENTIFIERLOOSE]})(?:${o[u.PRERELEASELOOSE]})?${o[u.BUILD]}?)?)?`), a("XRANGE", `^${o[u.GTLT]}\\s*${o[u.XRANGEPLAIN]}$`), a("XRANGELOOSE", `^${o[u.GTLT]}\\s*${o[u.XRANGEPLAINLOOSE]}$`), a("COERCE", `(^|[^\\d])(\\d{1,${e}})(?:\\.(\\d{1,${e}}))?(?:\\.(\\d{1,${e}}))?(?:$|[^\\d])`), a("COERCERTL", o[u.COERCE], !0), a("LONETILDE", "(?:~>?)"), a("TILDETRIM", `(\\s*)${o[u.LONETILDE]}\\s+`, !0), r.tildeTrimReplace = "$1~", a("TILDE", `^${o[u.LONETILDE]}${o[u.XRANGEPLAIN]}$`), a("TILDELOOSE", `^${o[u.LONETILDE]}${o[u.XRANGEPLAINLOOSE]}$`), a("LONECARET", "(?:\\^)"), a("CARETTRIM", `(\\s*)${o[u.LONECARET]}\\s+`, !0), r.caretTrimReplace = "$1^", a("CARET", `^${o[u.LONECARET]}${o[u.XRANGEPLAIN]}$`), a("CARETLOOSE", `^${o[u.LONECARET]}${o[u.XRANGEPLAINLOOSE]}$`), a("COMPARATORLOOSE", `^${o[u.GTLT]}\\s*(${o[u.LOOSEPLAIN]})$|^$`), a("COMPARATOR", `^${o[u.GTLT]}\\s*(${o[u.FULLPLAIN]})$|^$`), a("COMPARATORTRIM", `(\\s*)${o[u.GTLT]}\\s*(${o[u.LOOSEPLAIN]}|${o[u.XRANGEPLAIN]})`, !0), r.comparatorTrimReplace = "$1$2$3", a("HYPHENRANGE", `^\\s*(${o[u.XRANGEPLAIN]})\\s+-\\s+(${o[u.XRANGEPLAIN]})\\s*$`), a("HYPHENRANGELOOSE", `^\\s*(${o[u.XRANGEPLAINLOOSE]})\\s+-\\s+(${o[u.XRANGEPLAINLOOSE]})\\s*$`), a("STAR", "(<|>)?=?\\s*\\*"), a("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), a("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(dr, dr.exports);
var ct = dr.exports;
const wa = Object.freeze({ loose: !0 }), xa = Object.freeze({}), Ea = (t) => t ? typeof t != "object" ? wa : t : xa;
var Cr = Ea;
const hn = /^[0-9]+$/, _i = (t, r) => {
  const e = hn.test(t), i = hn.test(r);
  return e && i && (t = +t, r = +r), t === r ? 0 : e && !i ? -1 : i && !e ? 1 : t < r ? -1 : 1;
}, ya = (t, r) => _i(r, t);
var mi = {
  compareIdentifiers: _i,
  rcompareIdentifiers: ya
};
const xt = Ut, { MAX_LENGTH: pn, MAX_SAFE_INTEGER: Et } = Dt, { safeRe: dn, t: vn } = ct, _a = Cr, { compareIdentifiers: Le } = mi;
let ma = class ve {
  constructor(r, e) {
    if (e = _a(e), r instanceof ve) {
      if (r.loose === !!e.loose && r.includePrerelease === !!e.includePrerelease)
        return r;
      r = r.version;
    } else if (typeof r != "string")
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof r}".`);
    if (r.length > pn)
      throw new TypeError(
        `version is longer than ${pn} characters`
      );
    xt("SemVer", r, e), this.options = e, this.loose = !!e.loose, this.includePrerelease = !!e.includePrerelease;
    const i = r.trim().match(e.loose ? dn[vn.LOOSE] : dn[vn.FULL]);
    if (!i)
      throw new TypeError(`Invalid Version: ${r}`);
    if (this.raw = r, this.major = +i[1], this.minor = +i[2], this.patch = +i[3], this.major > Et || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > Et || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > Et || this.patch < 0)
      throw new TypeError("Invalid patch version");
    i[4] ? this.prerelease = i[4].split(".").map((s) => {
      if (/^[0-9]+$/.test(s)) {
        const n = +s;
        if (n >= 0 && n < Et)
          return n;
      }
      return s;
    }) : this.prerelease = [], this.build = i[5] ? i[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(r) {
    if (xt("SemVer.compare", this.version, this.options, r), !(r instanceof ve)) {
      if (typeof r == "string" && r === this.version)
        return 0;
      r = new ve(r, this.options);
    }
    return r.version === this.version ? 0 : this.compareMain(r) || this.comparePre(r);
  }
  compareMain(r) {
    return r instanceof ve || (r = new ve(r, this.options)), Le(this.major, r.major) || Le(this.minor, r.minor) || Le(this.patch, r.patch);
  }
  comparePre(r) {
    if (r instanceof ve || (r = new ve(r, this.options)), this.prerelease.length && !r.prerelease.length)
      return -1;
    if (!this.prerelease.length && r.prerelease.length)
      return 1;
    if (!this.prerelease.length && !r.prerelease.length)
      return 0;
    let e = 0;
    do {
      const i = this.prerelease[e], s = r.prerelease[e];
      if (xt("prerelease compare", e, i, s), i === void 0 && s === void 0)
        return 0;
      if (s === void 0)
        return 1;
      if (i === void 0)
        return -1;
      if (i === s)
        continue;
      return Le(i, s);
    } while (++e);
  }
  compareBuild(r) {
    r instanceof ve || (r = new ve(r, this.options));
    let e = 0;
    do {
      const i = this.build[e], s = r.build[e];
      if (xt("prerelease compare", e, i, s), i === void 0 && s === void 0)
        return 0;
      if (s === void 0)
        return 1;
      if (i === void 0)
        return -1;
      if (i === s)
        continue;
      return Le(i, s);
    } while (++e);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(r, e, i) {
    switch (r) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", e, i);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", e, i);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", e, i), this.inc("pre", e, i);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", e, i), this.inc("pre", e, i);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre": {
        const s = Number(i) ? 1 : 0;
        if (!e && i === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (this.prerelease.length === 0)
          this.prerelease = [s];
        else {
          let n = this.prerelease.length;
          for (; --n >= 0; )
            typeof this.prerelease[n] == "number" && (this.prerelease[n]++, n = -2);
          if (n === -1) {
            if (e === this.prerelease.join(".") && i === !1)
              throw new Error("invalid increment argument: identifier already exists");
            this.prerelease.push(s);
          }
        }
        if (e) {
          let n = [e, s];
          i === !1 && (n = [e]), Le(this.prerelease[0], e) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = n) : this.prerelease = n;
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${r}`);
    }
    return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
  }
};
var te = ma;
const gn = te, ba = (t, r, e = !1) => {
  if (t instanceof gn)
    return t;
  try {
    return new gn(t, r);
  } catch (i) {
    if (!e)
      return null;
    throw i;
  }
};
var We = ba;
const Ia = We, Ta = (t, r) => {
  const e = Ia(t, r);
  return e ? e.version : null;
};
var Sa = Ta;
const Ba = We, $a = (t, r) => {
  const e = Ba(t.trim().replace(/^[=v]+/, ""), r);
  return e ? e.version : null;
};
var Ra = $a;
const wn = te, Aa = (t, r, e, i, s) => {
  typeof e == "string" && (s = i, i = e, e = void 0);
  try {
    return new wn(
      t instanceof wn ? t.version : t,
      e
    ).inc(r, i, s).version;
  } catch {
    return null;
  }
};
var Oa = Aa;
const xn = We, Na = (t, r) => {
  const e = xn(t, null, !0), i = xn(r, null, !0), s = e.compare(i);
  if (s === 0)
    return null;
  const n = s > 0, o = n ? e : i, u = n ? i : e, c = !!o.prerelease.length;
  if (!!u.prerelease.length && !c)
    return !u.patch && !u.minor ? "major" : o.patch ? "patch" : o.minor ? "minor" : "major";
  const f = c ? "pre" : "";
  return e.major !== i.major ? f + "major" : e.minor !== i.minor ? f + "minor" : e.patch !== i.patch ? f + "patch" : "prerelease";
};
var Pa = Na;
const La = te, Ca = (t, r) => new La(t, r).major;
var Da = Ca;
const Ua = te, ka = (t, r) => new Ua(t, r).minor;
var Ma = ka;
const Ga = te, Fa = (t, r) => new Ga(t, r).patch;
var Va = Fa;
const Ka = We, qa = (t, r) => {
  const e = Ka(t, r);
  return e && e.prerelease.length ? e.prerelease : null;
};
var Xa = qa;
const En = te, Ha = (t, r, e) => new En(t, e).compare(new En(r, e));
var he = Ha;
const Wa = he, ja = (t, r, e) => Wa(r, t, e);
var za = ja;
const Ya = he, Za = (t, r) => Ya(t, r, !0);
var Qa = Za;
const yn = te, Ja = (t, r, e) => {
  const i = new yn(t, e), s = new yn(r, e);
  return i.compare(s) || i.compareBuild(s);
};
var Dr = Ja;
const eo = Dr, to = (t, r) => t.sort((e, i) => eo(e, i, r));
var ro = to;
const no = Dr, io = (t, r) => t.sort((e, i) => no(i, e, r));
var so = io;
const ao = he, oo = (t, r, e) => ao(t, r, e) > 0;
var kt = oo;
const uo = he, fo = (t, r, e) => uo(t, r, e) < 0;
var Ur = fo;
const co = he, lo = (t, r, e) => co(t, r, e) === 0;
var bi = lo;
const ho = he, po = (t, r, e) => ho(t, r, e) !== 0;
var Ii = po;
const vo = he, go = (t, r, e) => vo(t, r, e) >= 0;
var kr = go;
const wo = he, xo = (t, r, e) => wo(t, r, e) <= 0;
var Mr = xo;
const Eo = bi, yo = Ii, _o = kt, mo = kr, bo = Ur, Io = Mr, To = (t, r, e, i) => {
  switch (r) {
    case "===":
      return typeof t == "object" && (t = t.version), typeof e == "object" && (e = e.version), t === e;
    case "!==":
      return typeof t == "object" && (t = t.version), typeof e == "object" && (e = e.version), t !== e;
    case "":
    case "=":
    case "==":
      return Eo(t, e, i);
    case "!=":
      return yo(t, e, i);
    case ">":
      return _o(t, e, i);
    case ">=":
      return mo(t, e, i);
    case "<":
      return bo(t, e, i);
    case "<=":
      return Io(t, e, i);
    default:
      throw new TypeError(`Invalid operator: ${r}`);
  }
};
var Ti = To;
const So = te, Bo = We, { safeRe: yt, t: _t } = ct, $o = (t, r) => {
  if (t instanceof So)
    return t;
  if (typeof t == "number" && (t = String(t)), typeof t != "string")
    return null;
  r = r || {};
  let e = null;
  if (!r.rtl)
    e = t.match(yt[_t.COERCE]);
  else {
    let i;
    for (; (i = yt[_t.COERCERTL].exec(t)) && (!e || e.index + e[0].length !== t.length); )
      (!e || i.index + i[0].length !== e.index + e[0].length) && (e = i), yt[_t.COERCERTL].lastIndex = i.index + i[1].length + i[2].length;
    yt[_t.COERCERTL].lastIndex = -1;
  }
  return e === null ? null : Bo(`${e[2]}.${e[3] || "0"}.${e[4] || "0"}`, r);
};
var Ro = $o, tr, _n;
function pe() {
  if (_n)
    return tr;
  _n = 1;
  class t {
    constructor(g, _) {
      if (_ = i(_), g instanceof t)
        return g.loose === !!_.loose && g.includePrerelease === !!_.includePrerelease ? g : new t(g.raw, _);
      if (g instanceof s)
        return this.raw = g.value, this.set = [[g]], this.format(), this;
      if (this.options = _, this.loose = !!_.loose, this.includePrerelease = !!_.includePrerelease, this.raw = g.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map((T) => this.parseRange(T)).filter((T) => T.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const T = this.set[0];
        if (this.set = this.set.filter((E) => !w(E[0])), this.set.length === 0)
          this.set = [T];
        else if (this.set.length > 1) {
          for (const E of this.set)
            if (E.length === 1 && b(E[0])) {
              this.set = [E];
              break;
            }
        }
      }
      this.format();
    }
    format() {
      return this.range = this.set.map((g) => g.join(" ").trim()).join("||").trim(), this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(g) {
      const T = ((this.options.includePrerelease && v) | (this.options.loose && h)) + ":" + g, E = e.get(T);
      if (E)
        return E;
      const y = this.options.loose, O = y ? u[c.HYPHENRANGELOOSE] : u[c.HYPHENRANGE];
      g = g.replace(O, k(this.options.includePrerelease)), n("hyphen replace", g), g = g.replace(u[c.COMPARATORTRIM], a), n("comparator trim", g), g = g.replace(u[c.TILDETRIM], f), g = g.replace(u[c.CARETTRIM], l);
      let S = g.split(" ").map((G) => B(G, this.options)).join(" ").split(/\s+/).map((G) => A(G, this.options));
      y && (S = S.filter((G) => (n("loose invalid filter", G, this.options), !!G.match(u[c.COMPARATORLOOSE])))), n("range list", S);
      const m = /* @__PURE__ */ new Map(), D = S.map((G) => new s(G, this.options));
      for (const G of D) {
        if (w(G))
          return [G];
        m.set(G.value, G);
      }
      m.size > 1 && m.has("") && m.delete("");
      const K = [...m.values()];
      return e.set(T, K), K;
    }
    intersects(g, _) {
      if (!(g instanceof t))
        throw new TypeError("a Range is required");
      return this.set.some((T) => x(T, _) && g.set.some((E) => x(E, _) && T.every((y) => E.every((O) => y.intersects(O, _)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(g) {
      if (!g)
        return !1;
      if (typeof g == "string")
        try {
          g = new o(g, this.options);
        } catch {
          return !1;
        }
      for (let _ = 0; _ < this.set.length; _++)
        if (N(this.set[_], g, this.options))
          return !0;
      return !1;
    }
  }
  tr = t;
  const r = zi, e = new r({ max: 1e3 }), i = Cr, s = Mt(), n = Ut, o = te, {
    safeRe: u,
    t: c,
    comparatorTrimReplace: a,
    tildeTrimReplace: f,
    caretTrimReplace: l
  } = ct, { FLAG_INCLUDE_PRERELEASE: v, FLAG_LOOSE: h } = Dt, w = (d) => d.value === "<0.0.0-0", b = (d) => d.value === "", x = (d, g) => {
    let _ = !0;
    const T = d.slice();
    let E = T.pop();
    for (; _ && T.length; )
      _ = T.every((y) => E.intersects(y, g)), E = T.pop();
    return _;
  }, B = (d, g) => (n("comp", d, g), d = P(d, g), n("caret", d), d = $(d, g), n("tildes", d), d = U(d, g), n("xrange", d), d = X(d, g), n("stars", d), d), p = (d) => !d || d.toLowerCase() === "x" || d === "*", $ = (d, g) => d.trim().split(/\s+/).map((_) => R(_, g)).join(" "), R = (d, g) => {
    const _ = g.loose ? u[c.TILDELOOSE] : u[c.TILDE];
    return d.replace(_, (T, E, y, O, S) => {
      n("tilde", d, T, E, y, O, S);
      let m;
      return p(E) ? m = "" : p(y) ? m = `>=${E}.0.0 <${+E + 1}.0.0-0` : p(O) ? m = `>=${E}.${y}.0 <${E}.${+y + 1}.0-0` : S ? (n("replaceTilde pr", S), m = `>=${E}.${y}.${O}-${S} <${E}.${+y + 1}.0-0`) : m = `>=${E}.${y}.${O} <${E}.${+y + 1}.0-0`, n("tilde return", m), m;
    });
  }, P = (d, g) => d.trim().split(/\s+/).map((_) => I(_, g)).join(" "), I = (d, g) => {
    n("caret", d, g);
    const _ = g.loose ? u[c.CARETLOOSE] : u[c.CARET], T = g.includePrerelease ? "-0" : "";
    return d.replace(_, (E, y, O, S, m) => {
      n("caret", d, E, y, O, S, m);
      let D;
      return p(y) ? D = "" : p(O) ? D = `>=${y}.0.0${T} <${+y + 1}.0.0-0` : p(S) ? y === "0" ? D = `>=${y}.${O}.0${T} <${y}.${+O + 1}.0-0` : D = `>=${y}.${O}.0${T} <${+y + 1}.0.0-0` : m ? (n("replaceCaret pr", m), y === "0" ? O === "0" ? D = `>=${y}.${O}.${S}-${m} <${y}.${O}.${+S + 1}-0` : D = `>=${y}.${O}.${S}-${m} <${y}.${+O + 1}.0-0` : D = `>=${y}.${O}.${S}-${m} <${+y + 1}.0.0-0`) : (n("no pr"), y === "0" ? O === "0" ? D = `>=${y}.${O}.${S}${T} <${y}.${O}.${+S + 1}-0` : D = `>=${y}.${O}.${S}${T} <${y}.${+O + 1}.0-0` : D = `>=${y}.${O}.${S} <${+y + 1}.0.0-0`), n("caret return", D), D;
    });
  }, U = (d, g) => (n("replaceXRanges", d, g), d.split(/\s+/).map((_) => L(_, g)).join(" ")), L = (d, g) => {
    d = d.trim();
    const _ = g.loose ? u[c.XRANGELOOSE] : u[c.XRANGE];
    return d.replace(_, (T, E, y, O, S, m) => {
      n("xRange", d, T, E, y, O, S, m);
      const D = p(y), K = D || p(O), G = K || p(S), H = G;
      return E === "=" && H && (E = ""), m = g.includePrerelease ? "-0" : "", D ? E === ">" || E === "<" ? T = "<0.0.0-0" : T = "*" : E && H ? (K && (O = 0), S = 0, E === ">" ? (E = ">=", K ? (y = +y + 1, O = 0, S = 0) : (O = +O + 1, S = 0)) : E === "<=" && (E = "<", K ? y = +y + 1 : O = +O + 1), E === "<" && (m = "-0"), T = `${E + y}.${O}.${S}${m}`) : K ? T = `>=${y}.0.0${m} <${+y + 1}.0.0-0` : G && (T = `>=${y}.${O}.0${m} <${y}.${+O + 1}.0-0`), n("xRange return", T), T;
    });
  }, X = (d, g) => (n("replaceStars", d, g), d.trim().replace(u[c.STAR], "")), A = (d, g) => (n("replaceGTE0", d, g), d.trim().replace(u[g.includePrerelease ? c.GTE0PRE : c.GTE0], "")), k = (d) => (g, _, T, E, y, O, S, m, D, K, G, H, q) => (p(T) ? _ = "" : p(E) ? _ = `>=${T}.0.0${d ? "-0" : ""}` : p(y) ? _ = `>=${T}.${E}.0${d ? "-0" : ""}` : O ? _ = `>=${_}` : _ = `>=${_}${d ? "-0" : ""}`, p(D) ? m = "" : p(K) ? m = `<${+D + 1}.0.0-0` : p(G) ? m = `<${D}.${+K + 1}.0-0` : H ? m = `<=${D}.${K}.${G}-${H}` : d ? m = `<${D}.${K}.${+G + 1}-0` : m = `<=${m}`, `${_} ${m}`.trim()), N = (d, g, _) => {
    for (let T = 0; T < d.length; T++)
      if (!d[T].test(g))
        return !1;
    if (g.prerelease.length && !_.includePrerelease) {
      for (let T = 0; T < d.length; T++)
        if (n(d[T].semver), d[T].semver !== s.ANY && d[T].semver.prerelease.length > 0) {
          const E = d[T].semver;
          if (E.major === g.major && E.minor === g.minor && E.patch === g.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return tr;
}
var rr, mn;
function Mt() {
  if (mn)
    return rr;
  mn = 1;
  const t = Symbol("SemVer ANY");
  class r {
    static get ANY() {
      return t;
    }
    constructor(f, l) {
      if (l = e(l), f instanceof r) {
        if (f.loose === !!l.loose)
          return f;
        f = f.value;
      }
      f = f.trim().split(/\s+/).join(" "), o("comparator", f, l), this.options = l, this.loose = !!l.loose, this.parse(f), this.semver === t ? this.value = "" : this.value = this.operator + this.semver.version, o("comp", this);
    }
    parse(f) {
      const l = this.options.loose ? i[s.COMPARATORLOOSE] : i[s.COMPARATOR], v = f.match(l);
      if (!v)
        throw new TypeError(`Invalid comparator: ${f}`);
      this.operator = v[1] !== void 0 ? v[1] : "", this.operator === "=" && (this.operator = ""), v[2] ? this.semver = new u(v[2], this.options.loose) : this.semver = t;
    }
    toString() {
      return this.value;
    }
    test(f) {
      if (o("Comparator.test", f, this.options.loose), this.semver === t || f === t)
        return !0;
      if (typeof f == "string")
        try {
          f = new u(f, this.options);
        } catch {
          return !1;
        }
      return n(f, this.operator, this.semver, this.options);
    }
    intersects(f, l) {
      if (!(f instanceof r))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new c(f.value, l).test(this.value) : f.operator === "" ? f.value === "" ? !0 : new c(this.value, l).test(f.semver) : (l = e(l), l.includePrerelease && (this.value === "<0.0.0-0" || f.value === "<0.0.0-0") || !l.includePrerelease && (this.value.startsWith("<0.0.0") || f.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && f.operator.startsWith(">") || this.operator.startsWith("<") && f.operator.startsWith("<") || this.semver.version === f.semver.version && this.operator.includes("=") && f.operator.includes("=") || n(this.semver, "<", f.semver, l) && this.operator.startsWith(">") && f.operator.startsWith("<") || n(this.semver, ">", f.semver, l) && this.operator.startsWith("<") && f.operator.startsWith(">")));
    }
  }
  rr = r;
  const e = Cr, { safeRe: i, t: s } = ct, n = Ti, o = Ut, u = te, c = pe();
  return rr;
}
const Ao = pe(), Oo = (t, r, e) => {
  try {
    r = new Ao(r, e);
  } catch {
    return !1;
  }
  return r.test(t);
};
var Gt = Oo;
const No = pe(), Po = (t, r) => new No(t, r).set.map((e) => e.map((i) => i.value).join(" ").trim().split(" "));
var Lo = Po;
const Co = te, Do = pe(), Uo = (t, r, e) => {
  let i = null, s = null, n = null;
  try {
    n = new Do(r, e);
  } catch {
    return null;
  }
  return t.forEach((o) => {
    n.test(o) && (!i || s.compare(o) === -1) && (i = o, s = new Co(i, e));
  }), i;
};
var ko = Uo;
const Mo = te, Go = pe(), Fo = (t, r, e) => {
  let i = null, s = null, n = null;
  try {
    n = new Go(r, e);
  } catch {
    return null;
  }
  return t.forEach((o) => {
    n.test(o) && (!i || s.compare(o) === 1) && (i = o, s = new Mo(i, e));
  }), i;
};
var Vo = Fo;
const nr = te, Ko = pe(), bn = kt, qo = (t, r) => {
  t = new Ko(t, r);
  let e = new nr("0.0.0");
  if (t.test(e) || (e = new nr("0.0.0-0"), t.test(e)))
    return e;
  e = null;
  for (let i = 0; i < t.set.length; ++i) {
    const s = t.set[i];
    let n = null;
    s.forEach((o) => {
      const u = new nr(o.semver.version);
      switch (o.operator) {
        case ">":
          u.prerelease.length === 0 ? u.patch++ : u.prerelease.push(0), u.raw = u.format();
        case "":
        case ">=":
          (!n || bn(u, n)) && (n = u);
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${o.operator}`);
      }
    }), n && (!e || bn(e, n)) && (e = n);
  }
  return e && t.test(e) ? e : null;
};
var Xo = qo;
const Ho = pe(), Wo = (t, r) => {
  try {
    return new Ho(t, r).range || "*";
  } catch {
    return null;
  }
};
var jo = Wo;
const zo = te, Si = Mt(), { ANY: Yo } = Si, Zo = pe(), Qo = Gt, In = kt, Tn = Ur, Jo = Mr, eu = kr, tu = (t, r, e, i) => {
  t = new zo(t, i), r = new Zo(r, i);
  let s, n, o, u, c;
  switch (e) {
    case ">":
      s = In, n = Jo, o = Tn, u = ">", c = ">=";
      break;
    case "<":
      s = Tn, n = eu, o = In, u = "<", c = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (Qo(t, r, i))
    return !1;
  for (let a = 0; a < r.set.length; ++a) {
    const f = r.set[a];
    let l = null, v = null;
    if (f.forEach((h) => {
      h.semver === Yo && (h = new Si(">=0.0.0")), l = l || h, v = v || h, s(h.semver, l.semver, i) ? l = h : o(h.semver, v.semver, i) && (v = h);
    }), l.operator === u || l.operator === c || (!v.operator || v.operator === u) && n(t, v.semver))
      return !1;
    if (v.operator === c && o(t, v.semver))
      return !1;
  }
  return !0;
};
var Gr = tu;
const ru = Gr, nu = (t, r, e) => ru(t, r, ">", e);
var iu = nu;
const su = Gr, au = (t, r, e) => su(t, r, "<", e);
var ou = au;
const Sn = pe(), uu = (t, r, e) => (t = new Sn(t, e), r = new Sn(r, e), t.intersects(r, e));
var fu = uu;
const cu = Gt, lu = he;
var hu = (t, r, e) => {
  const i = [];
  let s = null, n = null;
  const o = t.sort((f, l) => lu(f, l, e));
  for (const f of o)
    cu(f, r, e) ? (n = f, s || (s = f)) : (n && i.push([s, n]), n = null, s = null);
  s && i.push([s, null]);
  const u = [];
  for (const [f, l] of i)
    f === l ? u.push(f) : !l && f === o[0] ? u.push("*") : l ? f === o[0] ? u.push(`<=${l}`) : u.push(`${f} - ${l}`) : u.push(`>=${f}`);
  const c = u.join(" || "), a = typeof r.raw == "string" ? r.raw : String(r);
  return c.length < a.length ? c : r;
};
const Bn = pe(), Fr = Mt(), { ANY: ir } = Fr, Ye = Gt, Vr = he, pu = (t, r, e = {}) => {
  if (t === r)
    return !0;
  t = new Bn(t, e), r = new Bn(r, e);
  let i = !1;
  e:
    for (const s of t.set) {
      for (const n of r.set) {
        const o = vu(s, n, e);
        if (i = i || o !== null, o)
          continue e;
      }
      if (i)
        return !1;
    }
  return !0;
}, du = [new Fr(">=0.0.0-0")], $n = [new Fr(">=0.0.0")], vu = (t, r, e) => {
  if (t === r)
    return !0;
  if (t.length === 1 && t[0].semver === ir) {
    if (r.length === 1 && r[0].semver === ir)
      return !0;
    e.includePrerelease ? t = du : t = $n;
  }
  if (r.length === 1 && r[0].semver === ir) {
    if (e.includePrerelease)
      return !0;
    r = $n;
  }
  const i = /* @__PURE__ */ new Set();
  let s, n;
  for (const h of t)
    h.operator === ">" || h.operator === ">=" ? s = Rn(s, h, e) : h.operator === "<" || h.operator === "<=" ? n = An(n, h, e) : i.add(h.semver);
  if (i.size > 1)
    return null;
  let o;
  if (s && n) {
    if (o = Vr(s.semver, n.semver, e), o > 0)
      return null;
    if (o === 0 && (s.operator !== ">=" || n.operator !== "<="))
      return null;
  }
  for (const h of i) {
    if (s && !Ye(h, String(s), e) || n && !Ye(h, String(n), e))
      return null;
    for (const w of r)
      if (!Ye(h, String(w), e))
        return !1;
    return !0;
  }
  let u, c, a, f, l = n && !e.includePrerelease && n.semver.prerelease.length ? n.semver : !1, v = s && !e.includePrerelease && s.semver.prerelease.length ? s.semver : !1;
  l && l.prerelease.length === 1 && n.operator === "<" && l.prerelease[0] === 0 && (l = !1);
  for (const h of r) {
    if (f = f || h.operator === ">" || h.operator === ">=", a = a || h.operator === "<" || h.operator === "<=", s) {
      if (v && h.semver.prerelease && h.semver.prerelease.length && h.semver.major === v.major && h.semver.minor === v.minor && h.semver.patch === v.patch && (v = !1), h.operator === ">" || h.operator === ">=") {
        if (u = Rn(s, h, e), u === h && u !== s)
          return !1;
      } else if (s.operator === ">=" && !Ye(s.semver, String(h), e))
        return !1;
    }
    if (n) {
      if (l && h.semver.prerelease && h.semver.prerelease.length && h.semver.major === l.major && h.semver.minor === l.minor && h.semver.patch === l.patch && (l = !1), h.operator === "<" || h.operator === "<=") {
        if (c = An(n, h, e), c === h && c !== n)
          return !1;
      } else if (n.operator === "<=" && !Ye(n.semver, String(h), e))
        return !1;
    }
    if (!h.operator && (n || s) && o !== 0)
      return !1;
  }
  return !(s && a && !n && o !== 0 || n && f && !s && o !== 0 || v || l);
}, Rn = (t, r, e) => {
  if (!t)
    return r;
  const i = Vr(t.semver, r.semver, e);
  return i > 0 ? t : i < 0 || r.operator === ">" && t.operator === ">=" ? r : t;
}, An = (t, r, e) => {
  if (!t)
    return r;
  const i = Vr(t.semver, r.semver, e);
  return i < 0 ? t : i > 0 || r.operator === "<" && t.operator === "<=" ? r : t;
};
var gu = pu;
const sr = ct, On = Dt, wu = te, Nn = mi, xu = We, Eu = Sa, yu = Ra, _u = Oa, mu = Pa, bu = Da, Iu = Ma, Tu = Va, Su = Xa, Bu = he, $u = za, Ru = Qa, Au = Dr, Ou = ro, Nu = so, Pu = kt, Lu = Ur, Cu = bi, Du = Ii, Uu = kr, ku = Mr, Mu = Ti, Gu = Ro, Fu = Mt(), Vu = pe(), Ku = Gt, qu = Lo, Xu = ko, Hu = Vo, Wu = Xo, ju = jo, zu = Gr, Yu = iu, Zu = ou, Qu = fu, Ju = hu, ef = gu;
var tf = {
  parse: xu,
  valid: Eu,
  clean: yu,
  inc: _u,
  diff: mu,
  major: bu,
  minor: Iu,
  patch: Tu,
  prerelease: Su,
  compare: Bu,
  rcompare: $u,
  compareLoose: Ru,
  compareBuild: Au,
  sort: Ou,
  rsort: Nu,
  gt: Pu,
  lt: Lu,
  eq: Cu,
  neq: Du,
  gte: Uu,
  lte: ku,
  cmp: Mu,
  coerce: Gu,
  Comparator: Fu,
  Range: Vu,
  satisfies: Ku,
  toComparators: qu,
  maxSatisfying: Xu,
  minSatisfying: Hu,
  minVersion: Wu,
  validRange: ju,
  outside: zu,
  gtr: Yu,
  ltr: Zu,
  intersects: Qu,
  simplifyRange: Ju,
  subset: ef,
  SemVer: wu,
  re: sr.re,
  src: sr.src,
  tokens: sr.t,
  SEMVER_SPEC_VERSION: On.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: On.RELEASE_TYPES,
  compareIdentifiers: Nn.compareIdentifiers,
  rcompareIdentifiers: Nn.rcompareIdentifiers
};
const Bi = /* @__PURE__ */ st(tf);
var rf = ce, Ie = ne.Buffer, $i = Nr, nf = Ie.alloc(128), Ce = 64;
function Ft(t, r) {
  $i.call(this, "digest"), typeof r == "string" && (r = Ie.from(r)), this._alg = t, this._key = r, r.length > Ce ? r = t(r) : r.length < Ce && (r = Ie.concat([r, nf], Ce));
  for (var e = this._ipad = Ie.allocUnsafe(Ce), i = this._opad = Ie.allocUnsafe(Ce), s = 0; s < Ce; s++)
    e[s] = r[s] ^ 54, i[s] = r[s] ^ 92;
  this._hash = [e];
}
rf(Ft, $i);
Ft.prototype._update = function(t) {
  this._hash.push(t);
};
Ft.prototype._final = function() {
  var t = this._alg(Ie.concat(this._hash));
  return this._alg(Ie.concat([this._opad, t]));
};
var sf = Ft, af = ai, of = function(t) {
  return new af().update(t).digest();
}, uf = ce, ff = sf, Ri = Nr, et = ne.Buffer, cf = of, vr = ti, gr = Or, lf = et.alloc(128);
function nt(t, r) {
  Ri.call(this, "digest"), typeof r == "string" && (r = et.from(r));
  var e = t === "sha512" || t === "sha384" ? 128 : 64;
  if (this._alg = t, this._key = r, r.length > e) {
    var i = t === "rmd160" ? new vr() : gr(t);
    r = i.update(r).digest();
  } else
    r.length < e && (r = et.concat([r, lf], e));
  for (var s = this._ipad = et.allocUnsafe(e), n = this._opad = et.allocUnsafe(e), o = 0; o < e; o++)
    s[o] = r[o] ^ 54, n[o] = r[o] ^ 92;
  this._hash = t === "rmd160" ? new vr() : gr(t), this._hash.update(s);
}
uf(nt, Ri);
nt.prototype._update = function(t) {
  this._hash.update(t);
};
nt.prototype._final = function() {
  var t = this._hash.digest(), r = this._alg === "rmd160" ? new vr() : gr(this._alg);
  return r.update(this._opad).update(t).digest();
};
var hf = function(r, e) {
  return r = r.toLowerCase(), r === "rmd160" || r === "ripemd160" ? new nt("rmd160", e) : r === "md5" ? new ff(cf, e) : new nt(r, e);
};
const we = hf, pf = Buffer.alloc(1, 1), Pn = Buffer.alloc(1, 0);
function df(t, r, e, i, s) {
  let n = Buffer.alloc(32, 0), o = Buffer.alloc(32, 1);
  n = we("sha256", n).update(o).update(Pn).update(r).update(t).update(s || "").digest(), o = we("sha256", n).update(o).digest(), n = we("sha256", n).update(o).update(pf).update(r).update(t).update(s || "").digest(), o = we("sha256", n).update(o).digest(), o = we("sha256", n).update(o).digest();
  let u = o;
  for (; !i(u) || !e(u); )
    n = we("sha256", n).update(o).update(Pn).digest(), o = we("sha256", n).update(o).digest(), o = we("sha256", n).update(o).digest(), u = o;
  return u;
}
var vf = df;
const gf = Yi, wf = Zi.ec, Kr = new wf("secp256k1"), xf = vf, bt = Buffer.alloc(32, 0), It = Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", "hex"), Ln = Buffer.from("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f", "hex"), fe = Kr.curve.n, Ai = fe.shrn(1), Vt = Kr.curve.g, Kt = "Expected Private", Be = "Expected Point", qt = "Expected Tweak", Oi = "Expected Hash", Ef = "Expected Signature", yf = "Expected Extra Data (32 bytes)";
function it(t) {
  return Buffer.isBuffer(t) && t.length === 32;
}
function Xt(t) {
  return it(t) ? t.compare(It) < 0 : !1;
}
function Ee(t) {
  if (!Buffer.isBuffer(t) || t.length < 33)
    return !1;
  const r = t[0], e = t.slice(1, 33);
  if (e.compare(bt) === 0 || e.compare(Ln) >= 0)
    return !1;
  if ((r === 2 || r === 3) && t.length === 33) {
    try {
      $e(t);
    } catch {
      return !1;
    }
    return !0;
  }
  const i = t.slice(33);
  return i.compare(bt) === 0 || i.compare(Ln) >= 0 ? !1 : r === 4 && t.length === 65;
}
function Ni(t) {
  return t[0] !== 4;
}
function _f(t) {
  return Ee(t) ? Ni(t) : !1;
}
function ye(t) {
  return it(t) ? t.compare(bt) > 0 && // > 0
  t.compare(It) < 0 : !1;
}
function mf(t) {
  const r = t.slice(0, 32), e = t.slice(32, 64);
  return Buffer.isBuffer(t) && t.length === 64 && r.compare(It) < 0 && e.compare(It) < 0;
}
function lt(t, r) {
  return t === void 0 && r !== void 0 ? Ni(r) : t === void 0 ? !0 : t;
}
function ie(t) {
  return new gf(t);
}
function Tt(t) {
  return t.toArrayLike(Buffer, "be", 32);
}
function $e(t) {
  return Kr.curve.decodePoint(t);
}
function Ve(t, r) {
  return Buffer.from(t._encode(r));
}
function bf(t, r, e) {
  if (!Ee(t))
    throw new TypeError(Be);
  if (!Ee(r))
    throw new TypeError(Be);
  const i = $e(t), s = $e(r), n = i.add(s);
  if (n.isInfinity())
    return null;
  const o = lt(e, t);
  return Ve(n, o);
}
function If(t, r, e) {
  if (!Ee(t))
    throw new TypeError(Be);
  if (!Xt(r))
    throw new TypeError(qt);
  const i = lt(e, t), s = $e(t);
  if (r.compare(bt) === 0)
    return Ve(s, i);
  const n = ie(r), o = Vt.mul(n), u = s.add(o);
  return u.isInfinity() ? null : Ve(u, i);
}
function Tf(t, r) {
  if (!Ee(t))
    throw new TypeError(Be);
  const e = $e(t);
  if (e.isInfinity())
    throw new TypeError(Be);
  const i = lt(r, t);
  return Ve(e, i);
}
function Sf(t, r) {
  if (!ye(t))
    throw new TypeError(Kt);
  const e = ie(t), i = Vt.mul(e);
  if (i.isInfinity())
    return null;
  const s = lt(r);
  return Ve(i, s);
}
function Bf(t, r, e) {
  if (!Ee(t))
    throw new TypeError(Be);
  if (!Xt(r))
    throw new TypeError(qt);
  const i = lt(e, t), s = $e(t), n = ie(r), o = s.mul(n);
  return o.isInfinity() ? null : Ve(o, i);
}
function $f(t, r) {
  if (!ye(t))
    throw new TypeError(Kt);
  if (!Xt(r))
    throw new TypeError(qt);
  const e = ie(t), i = ie(r), s = Tt(e.add(i).umod(fe));
  return ye(s) ? s : null;
}
function Rf(t, r) {
  if (!ye(t))
    throw new TypeError(Kt);
  if (!Xt(r))
    throw new TypeError(qt);
  const e = ie(t), i = ie(r), s = Tt(e.sub(i).umod(fe));
  return ye(s) ? s : null;
}
function Af(t, r) {
  return Pi(t, r);
}
function Of(t, r, e) {
  return Pi(t, r, e);
}
function Pi(t, r, e) {
  if (!it(t))
    throw new TypeError(Oi);
  if (!ye(r))
    throw new TypeError(Kt);
  if (e !== void 0 && !it(e))
    throw new TypeError(yf);
  const i = ie(r), s = ie(t);
  let n, o;
  xf(t, r, function(a) {
    const f = ie(a), l = Vt.mul(f);
    return !(l.isInfinity() || (n = l.x.umod(fe), n.isZero() === 0) || (o = f.invm(fe).mul(s.add(i.mul(n))).umod(fe), o.isZero() === 0));
  }, ye, e), o.cmp(Ai) > 0 && (o = fe.sub(o));
  const c = Buffer.allocUnsafe(64);
  return Tt(n).copy(c, 0), Tt(o).copy(c, 32), c;
}
function Nf(t, r, e, i) {
  if (!it(t))
    throw new TypeError(Oi);
  if (!Ee(r))
    throw new TypeError(Be);
  if (!mf(e))
    throw new TypeError(Ef);
  const s = $e(r), n = ie(e.slice(0, 32)), o = ie(e.slice(32, 64));
  if (i && o.cmp(Ai) > 0 || n.gtn(0) <= 0 || o.gtn(0) <= 0)
    return !1;
  const u = ie(t), c = o.invm(fe), a = u.mul(c).umod(fe), f = n.mul(c).umod(fe), l = Vt.mulAdd(a, s, f);
  return l.isInfinity() ? !1 : l.x.umod(fe).eq(n);
}
var Li = {
  isPoint: Ee,
  isPointCompressed: _f,
  isPrivate: ye,
  pointAdd: bf,
  pointAddScalar: If,
  pointCompress: Tf,
  pointFromScalar: Sf,
  pointMultiply: Bf,
  privateAdd: $f,
  privateSub: Rf,
  sign: Af,
  signWithEntropy: Of,
  verify: Nf
}, wr = ne.Buffer, Pf = 9007199254740991;
function qr(t) {
  if (t < 0 || t > Pf || t % 1 !== 0)
    throw new RangeError("value out of range");
}
function tt(t, r, e) {
  if (qr(t), r || (r = wr.allocUnsafe(Ci(t))), !wr.isBuffer(r))
    throw new TypeError("buffer must be a Buffer instance");
  return e || (e = 0), t < 253 ? (r.writeUInt8(t, e), tt.bytes = 1) : t <= 65535 ? (r.writeUInt8(253, e), r.writeUInt16LE(t, e + 1), tt.bytes = 3) : t <= 4294967295 ? (r.writeUInt8(254, e), r.writeUInt32LE(t, e + 1), tt.bytes = 5) : (r.writeUInt8(255, e), r.writeUInt32LE(t >>> 0, e + 1), r.writeUInt32LE(t / 4294967296 | 0, e + 5), tt.bytes = 9), r;
}
function rt(t, r) {
  if (!wr.isBuffer(t))
    throw new TypeError("buffer must be a Buffer instance");
  r || (r = 0);
  var e = t.readUInt8(r);
  if (e < 253)
    return rt.bytes = 1, e;
  if (e === 253)
    return rt.bytes = 3, t.readUInt16LE(r + 1);
  if (e === 254)
    return rt.bytes = 5, t.readUInt32LE(r + 1);
  rt.bytes = 9;
  var i = t.readUInt32LE(r + 1), s = t.readUInt32LE(r + 5), n = s * 4294967296 + i;
  return qr(n), n;
}
function Ci(t) {
  return qr(t), t < 253 ? 1 : t <= 65535 ? 3 : t <= 4294967295 ? 5 : 9;
}
var Lf = { encode: tt, decode: rt, encodingLength: Ci };
const xr = /* @__PURE__ */ st(Lf);
function Di(t) {
  if (t > Number.MAX_SAFE_INTEGER)
    throw new Error("Can't convert numbers > MAX_SAFE_INT");
  for (var r = Buffer.alloc(8, 0), e = 0; e < r.length; e++) {
    var i = t & 255;
    r[e] = i, t = (t - i) / 256;
  }
  return r;
}
function Ui(t) {
  var r = 0;
  if (t.length != 8)
    throw new Error("Expected Bufffer of lenght 8");
  if (t[7] != 0)
    throw new Error("Can't encode numbers > MAX_SAFE_INT");
  if (t[6] > 31)
    throw new Error("Can't encode numbers > MAX_SAFE_INT");
  for (var e = t.length - 1; e >= 0; e--)
    r = r * 256 + t[e];
  return r;
}
var z = (
  /** @class */
  function() {
    function t() {
      this.bufs = [];
    }
    return t.prototype.write = function(r, e) {
      var i = Buffer.alloc(r);
      e(i), this.bufs.push(i);
    }, t.prototype.writeUInt8 = function(r) {
      this.write(1, function(e) {
        return e.writeUInt8(r, 0);
      });
    }, t.prototype.writeInt32 = function(r) {
      this.write(4, function(e) {
        return e.writeInt32LE(r, 0);
      });
    }, t.prototype.writeUInt32 = function(r) {
      this.write(4, function(e) {
        return e.writeUInt32LE(r, 0);
      });
    }, t.prototype.writeUInt64 = function(r) {
      var e = Di(r);
      this.writeSlice(e);
    }, t.prototype.writeVarInt = function(r) {
      this.bufs.push(xr.encode(r));
    }, t.prototype.writeSlice = function(r) {
      this.bufs.push(Buffer.from(r));
    }, t.prototype.writeVarSlice = function(r) {
      this.writeVarInt(r.length), this.writeSlice(r);
    }, t.prototype.buffer = function() {
      return Buffer.concat(this.bufs);
    }, t;
  }()
), Te = (
  /** @class */
  function() {
    function t(r, e) {
      e === void 0 && (e = 0), this.buffer = r, this.offset = e;
    }
    return t.prototype.available = function() {
      return this.buffer.length - this.offset;
    }, t.prototype.readUInt8 = function() {
      var r = this.buffer.readUInt8(this.offset);
      return this.offset++, r;
    }, t.prototype.readInt32 = function() {
      var r = this.buffer.readInt32LE(this.offset);
      return this.offset += 4, r;
    }, t.prototype.readUInt32 = function() {
      var r = this.buffer.readUInt32LE(this.offset);
      return this.offset += 4, r;
    }, t.prototype.readUInt64 = function() {
      var r = this.readSlice(8), e = Ui(r);
      return e;
    }, t.prototype.readVarInt = function() {
      var r = xr.decode(this.buffer, this.offset);
      return this.offset += xr.decode.bytes, r;
    }, t.prototype.readSlice = function(r) {
      if (this.buffer.length < this.offset + r)
        throw new Error("Cannot read slice out of bounds");
      var e = this.buffer.slice(this.offset, this.offset + r);
      return this.offset += r, e;
    }, t.prototype.readVarSlice = function() {
      return this.readSlice(this.readVarInt());
    }, t.prototype.readVector = function() {
      for (var r = this.readVarInt(), e = [], i = 0; i < r; i++)
        e.push(this.readVarSlice());
      return e;
    }, t;
  }()
), _e = 50, Cf = 1, ki = 0, St = 4294967295, Xr = 1, Mi = 118, Hr = 169, Ht = 20, Df = 135, Gi = 136, Fi = 172;
function Ke(t) {
  return new ri().update(mt("sha256").update(t).digest()).digest();
}
var ht = globalThis && globalThis.__extends || function() {
  var t = function(r, e) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, s) {
      i.__proto__ = s;
    } || function(i, s) {
      for (var n in s)
        Object.prototype.hasOwnProperty.call(s, n) && (i[n] = s[n]);
    }, t(r, e);
  };
  return function(r, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    t(r, e);
    function i() {
      this.constructor = r;
    }
    r.prototype = e === null ? Object.create(e) : (i.prototype = e.prototype, new i());
  };
}(), Uf = (
  /** @class */
  function() {
    function t(r, e) {
      this.psbt = r, this.masterFp = e;
    }
    return t;
  }()
), Wt = (
  /** @class */
  function(t) {
    ht(r, t);
    function r() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return r.prototype.spendingCondition = function(e) {
      if (e.length != 1)
        throw new Error("Expected single key, got " + e.length);
      return this.singleKeyCondition(e[0]);
    }, r.prototype.setInput = function(e, i, s, n, o) {
      if (n.length != 1)
        throw new Error("Expected single key, got " + n.length);
      if (o.length != 1)
        throw new Error("Expected single path, got " + o.length);
      this.setSingleKeyInput(e, i, s, n[0], o[0]);
    }, r.prototype.setOwnOutput = function(e, i, s, n) {
      if (s.length != 1)
        throw new Error("Expected single key, got " + s.length);
      if (n.length != 1)
        throw new Error("Expected single path, got " + n.length);
      this.setSingleKeyOutput(e, i, s[0], n[0]);
    }, r;
  }(Uf)
), kf = (
  /** @class */
  function(t) {
    ht(r, t);
    function r() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return r.prototype.singleKeyCondition = function(e) {
      var i = new z(), s = Ke(e);
      return i.writeSlice(Buffer.from([Mi, Hr, Ht])), i.writeSlice(s), i.writeSlice(Buffer.from([Gi, Fi])), { scriptPubKey: i.buffer() };
    }, r.prototype.setSingleKeyInput = function(e, i, s, n, o) {
      if (!i)
        throw new Error("Full input base transaction required");
      this.psbt.setInputNonWitnessUtxo(e, i), this.psbt.setInputBip32Derivation(e, n, this.masterFp, o);
    }, r.prototype.setSingleKeyOutput = function(e, i, s, n) {
      this.psbt.setOutputBip32Derivation(e, s, this.masterFp, n);
    }, r.prototype.getDescriptorTemplate = function() {
      return "pkh(@0)";
    }, r;
  }(Wt)
), Mf = (
  /** @class */
  function(t) {
    ht(r, t);
    function r() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return r.prototype.singleKeyCondition = function(e) {
      var i = e.slice(1), s = new z(), n = this.getTaprootOutputKey(i);
      return s.writeSlice(Buffer.from([81, 32])), s.writeSlice(n), { scriptPubKey: s.buffer() };
    }, r.prototype.setSingleKeyInput = function(e, i, s, n, o) {
      var u = n.slice(1);
      this.psbt.setInputTapBip32Derivation(e, u, [], this.masterFp, o), this.psbt.setInputWitnessUtxo(e, s.amount, s.cond.scriptPubKey);
    }, r.prototype.setSingleKeyOutput = function(e, i, s, n) {
      var o = s.slice(1);
      this.psbt.setOutputTapBip32Derivation(e, o, [], this.masterFp, n);
    }, r.prototype.getDescriptorTemplate = function() {
      return "tr(@0)";
    }, r.prototype.hashTapTweak = function(e) {
      var i = Se.sha256(Buffer.from("TapTweak", "utf-8"));
      return Se.sha256(Buffer.concat([i, i, e]));
    }, r.prototype.getTaprootOutputKey = function(e) {
      if (e.length != 32)
        throw new Error("Expected 32 byte pubkey. Got " + e.length);
      var i = Buffer.concat([
        Buffer.from([2]),
        e
      ]), s = this.hashTapTweak(e), n = Buffer.from(Li.pointAddScalar(i, s)), o = n.slice(1);
      return o;
    }, r;
  }(Wt)
), Gf = (
  /** @class */
  function(t) {
    ht(r, t);
    function r() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return r.prototype.singleKeyCondition = function(e) {
      var i = new z(), s = this.createRedeemScript(e), n = Ke(s);
      return i.writeSlice(Buffer.from([Hr, Ht])), i.writeSlice(n), i.writeUInt8(Df), { scriptPubKey: i.buffer(), redeemScript: s };
    }, r.prototype.setSingleKeyInput = function(e, i, s, n, o) {
      if (!i)
        throw new Error("Full input base transaction required");
      this.psbt.setInputNonWitnessUtxo(e, i), this.psbt.setInputBip32Derivation(e, n, this.masterFp, o);
      var u = s.cond.redeemScript, c = this.createRedeemScript(n);
      if (u && !c.equals(u))
        throw new Error("User-supplied redeemScript ".concat(u.toString("hex"), ` doesn't
       match expected `).concat(c.toString("hex"), " for input ").concat(e));
      this.psbt.setInputRedeemScript(e, c), this.psbt.setInputWitnessUtxo(e, s.amount, s.cond.scriptPubKey);
    }, r.prototype.setSingleKeyOutput = function(e, i, s, n) {
      this.psbt.setOutputRedeemScript(e, i.redeemScript), this.psbt.setOutputBip32Derivation(e, s, this.masterFp, n);
    }, r.prototype.getDescriptorTemplate = function() {
      return "sh(wpkh(@0))";
    }, r.prototype.createRedeemScript = function(e) {
      var i = Ke(e);
      return Buffer.concat([Buffer.from("0014", "hex"), i]);
    }, r;
  }(Wt)
), Ff = (
  /** @class */
  function(t) {
    ht(r, t);
    function r() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return r.prototype.singleKeyCondition = function(e) {
      var i = new z(), s = Ke(e);
      return i.writeSlice(Buffer.from([0, Ht])), i.writeSlice(s), { scriptPubKey: i.buffer() };
    }, r.prototype.setSingleKeyInput = function(e, i, s, n, o) {
      if (!i)
        throw new Error("Full input base transaction required");
      this.psbt.setInputNonWitnessUtxo(e, i), this.psbt.setInputBip32Derivation(e, n, this.masterFp, o), this.psbt.setInputWitnessUtxo(e, s.amount, s.cond.scriptPubKey);
    }, r.prototype.setSingleKeyOutput = function(e, i, s, n) {
      this.psbt.setOutputBip32Derivation(e, s, this.masterFp, n);
    }, r.prototype.getDescriptorTemplate = function() {
      return "wpkh(@0)";
    }, r;
  }(Wt)
), Cn = globalThis && globalThis.__read || function(t, r) {
  var e = typeof Symbol == "function" && t[Symbol.iterator];
  if (!e)
    return t;
  var i = e.call(t), s, n = [], o;
  try {
    for (; (r === void 0 || r-- > 0) && !(s = i.next()).done; )
      n.push(s.value);
  } catch (u) {
    o = { error: u };
  } finally {
    try {
      s && !s.done && (e = i.return) && e.call(i);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return n;
}, Dn = globalThis && globalThis.__spreadArray || function(t, r, e) {
  if (e || arguments.length === 2)
    for (var i = 0, s = r.length, n; i < s; i++)
      (n || !(i in r)) && (n || (n = Array.prototype.slice.call(r, 0, i)), n[i] = r[i]);
  return t.concat(n || Array.prototype.slice.call(r));
}, qe = (
  /** @class */
  function() {
    function t(r, e) {
      e === void 0 && (e = Se.sha256), this.leaves = r, this.h = e;
      var i = this.calculateRoot(r);
      this.rootNode = i.root, this.leafNodes = i.leaves;
    }
    return t.prototype.getRoot = function() {
      return this.rootNode.hash;
    }, t.prototype.size = function() {
      return this.leaves.length;
    }, t.prototype.getLeaves = function() {
      return this.leaves;
    }, t.prototype.getLeafHash = function(r) {
      return this.leafNodes[r].hash;
    }, t.prototype.getProof = function(r) {
      if (r >= this.leaves.length)
        throw Error("Index out of bounds");
      return Er(this.leafNodes[r]);
    }, t.prototype.calculateRoot = function(r) {
      var e = r.length;
      if (e == 0)
        return {
          root: new ar(void 0, void 0, Buffer.alloc(32, 0)),
          leaves: []
        };
      if (e == 1) {
        var i = new ar(void 0, void 0, r[0]);
        return { root: i, leaves: [i] };
      }
      var s = Kf(e), n = this.calculateRoot(r.slice(0, s)), o = this.calculateRoot(r.slice(s)), u = n.root, c = o.root, a = this.hashNode(u.hash, c.hash), f = new ar(u, c, a);
      return u.parent = f, c.parent = f, { root: f, leaves: n.leaves.concat(o.leaves) };
    }, t.prototype.hashNode = function(r, e) {
      return this.h(Buffer.concat([Buffer.from([1]), r, e]));
    }, t;
  }()
);
function Xe(t, r) {
  return r === void 0 && (r = Se.sha256), Vf(Buffer.from([0]), t, r);
}
function Vf(t, r, e) {
  return e(Buffer.concat([t, r]));
}
var ar = (
  /** @class */
  function() {
    function t(r, e, i) {
      this.leftChild = r, this.rightChild = e, this.hash = i;
    }
    return t.prototype.isLeaf = function() {
      return this.leftChild == null;
    }, t;
  }()
);
function Er(t) {
  if (!t.parent)
    return [];
  if (t.parent.leftChild == t) {
    if (!t.parent.rightChild)
      throw new Error("Expected right child to exist");
    return Dn([t.parent.rightChild.hash], Cn(Er(t.parent)), !1);
  } else {
    if (!t.parent.leftChild)
      throw new Error("Expected left child to exist");
    return Dn([t.parent.leftChild.hash], Cn(Er(t.parent)), !1);
  }
}
function Kf(t) {
  if (t < 2)
    throw Error("Expected n >= 2");
  return qf(t) ? t / 2 : 1 << Math.floor(Math.log2(t));
}
function qf(t) {
  return (t & t - 1) == 0;
}
var Un = (
  /** @class */
  function() {
    function t(r, e) {
      this.descriptorTemplate = r, this.keys = [e];
    }
    return t.prototype.getWalletId = function() {
      return Se.sha256(this.serialize());
    }, t.prototype.serialize = function() {
      var r = this.keys.map(function(s) {
        return Buffer.from(s, "ascii");
      }), e = new qe(r.map(function(s) {
        return Xe(s);
      })), i = new z();
      return i.writeUInt8(1), i.writeUInt8(0), i.writeVarSlice(Buffer.from(this.descriptorTemplate, "ascii")), i.writeVarInt(this.keys.length), i.writeSlice(e.getRoot()), i.buffer();
    }, t;
  }()
);
function kn(t, r, e) {
  var i = Lr(r);
  return "[".concat(t.toString("hex")).concat(i.substring(1), "]").concat(e, "/**");
}
function Xf(t) {
  var r, e, i = new z();
  i.writeUInt32(t.getGlobalTxVersion());
  var s = !!t.getInputWitnessUtxo(0);
  s && i.writeSlice(Buffer.from([0, 1]));
  var n = t.getGlobalInputCount();
  i.writeVarInt(n);
  for (var o = new z(), u = 0; u < n; u++)
    i.writeSlice(t.getInputPreviousTxid(u)), i.writeUInt32(t.getInputOutputIndex(u)), i.writeVarSlice((r = t.getInputFinalScriptsig(u)) !== null && r !== void 0 ? r : Buffer.from([])), i.writeUInt32(t.getInputSequence(u)), s && o.writeSlice(t.getInputFinalScriptwitness(u));
  var c = t.getGlobalOutputCount();
  i.writeVarInt(c);
  for (var u = 0; u < c; u++)
    i.writeUInt64(t.getOutputAmount(u)), i.writeVarSlice(t.getOutputScript(u));
  return i.writeSlice(o.buffer()), i.writeUInt32((e = t.getGlobalFallbackLocktime()) !== null && e !== void 0 ? e : 0), i.buffer();
}
var Hf = globalThis && globalThis.__extends || function() {
  var t = function(r, e) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, s) {
      i.__proto__ = s;
    } || function(i, s) {
      for (var n in s)
        Object.prototype.hasOwnProperty.call(s, n) && (i[n] = s[n]);
    }, t(r, e);
  };
  return function(r, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    t(r, e);
    function i() {
      this.constructor = r;
    }
    r.prototype = e === null ? Object.create(e) : (i.prototype = e.prototype, new i());
  };
}(), yr = globalThis && globalThis.__assign || function() {
  return yr = Object.assign || function(t) {
    for (var r, e = 1, i = arguments.length; e < i; e++) {
      r = arguments[e];
      for (var s in r)
        Object.prototype.hasOwnProperty.call(r, s) && (t[s] = r[s]);
    }
    return t;
  }, yr.apply(this, arguments);
}, re;
(function(t) {
  t[t.TX_VERSION = 2] = "TX_VERSION", t[t.FALLBACK_LOCKTIME = 3] = "FALLBACK_LOCKTIME", t[t.INPUT_COUNT = 4] = "INPUT_COUNT", t[t.OUTPUT_COUNT = 5] = "OUTPUT_COUNT", t[t.TX_MODIFIABLE = 6] = "TX_MODIFIABLE", t[t.VERSION = 251] = "VERSION";
})(re || (re = {}));
var M;
(function(t) {
  t[t.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", t[t.WITNESS_UTXO = 1] = "WITNESS_UTXO", t[t.PARTIAL_SIG = 2] = "PARTIAL_SIG", t[t.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", t[t.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", t[t.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", t[t.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", t[t.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", t[t.PREVIOUS_TXID = 14] = "PREVIOUS_TXID", t[t.OUTPUT_INDEX = 15] = "OUTPUT_INDEX", t[t.SEQUENCE = 16] = "SEQUENCE", t[t.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", t[t.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION";
})(M || (M = {}));
var ue;
(function(t) {
  t[t.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", t[t.BIP_32_DERIVATION = 2] = "BIP_32_DERIVATION", t[t.AMOUNT = 3] = "AMOUNT", t[t.SCRIPT = 4] = "SCRIPT", t[t.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
})(ue || (ue = {}));
var Wf = Buffer.from([112, 115, 98, 116, 255]), jf = (
  /** @class */
  function(t) {
    Hf(r, t);
    function r() {
      return t !== null && t.apply(this, arguments) || this;
    }
    return r;
  }(Error)
), Vi = (
  /** @class */
  function() {
    function t() {
      this.globalMap = /* @__PURE__ */ new Map(), this.inputMaps = [], this.outputMaps = [];
    }
    return t.prototype.setGlobalTxVersion = function(r) {
      this.setGlobal(re.TX_VERSION, De(r));
    }, t.prototype.getGlobalTxVersion = function() {
      return this.getGlobal(re.TX_VERSION).readUInt32LE(0);
    }, t.prototype.setGlobalFallbackLocktime = function(r) {
      this.setGlobal(re.FALLBACK_LOCKTIME, De(r));
    }, t.prototype.getGlobalFallbackLocktime = function() {
      var r;
      return (r = this.getGlobalOptional(re.FALLBACK_LOCKTIME)) === null || r === void 0 ? void 0 : r.readUInt32LE(0);
    }, t.prototype.setGlobalInputCount = function(r) {
      this.setGlobal(re.INPUT_COUNT, Mn(r));
    }, t.prototype.getGlobalInputCount = function() {
      return Gn(this.getGlobal(re.INPUT_COUNT));
    }, t.prototype.setGlobalOutputCount = function(r) {
      this.setGlobal(re.OUTPUT_COUNT, Mn(r));
    }, t.prototype.getGlobalOutputCount = function() {
      return Gn(this.getGlobal(re.OUTPUT_COUNT));
    }, t.prototype.setGlobalTxModifiable = function(r) {
      this.setGlobal(re.TX_MODIFIABLE, r);
    }, t.prototype.getGlobalTxModifiable = function() {
      return this.getGlobalOptional(re.TX_MODIFIABLE);
    }, t.prototype.setGlobalPsbtVersion = function(r) {
      this.setGlobal(re.VERSION, De(r));
    }, t.prototype.getGlobalPsbtVersion = function() {
      return this.getGlobal(re.VERSION).readUInt32LE(0);
    }, t.prototype.setInputNonWitnessUtxo = function(r, e) {
      this.setInput(r, M.NON_WITNESS_UTXO, V(), e);
    }, t.prototype.getInputNonWitnessUtxo = function(r) {
      return this.getInputOptional(r, M.NON_WITNESS_UTXO, V());
    }, t.prototype.setInputWitnessUtxo = function(r, e, i) {
      var s = new z();
      s.writeSlice(e), s.writeVarSlice(i), this.setInput(r, M.WITNESS_UTXO, V(), s.buffer());
    }, t.prototype.getInputWitnessUtxo = function(r) {
      var e = this.getInputOptional(r, M.WITNESS_UTXO, V());
      if (e) {
        var i = new Te(e);
        return { amount: i.readSlice(8), scriptPubKey: i.readVarSlice() };
      }
    }, t.prototype.setInputPartialSig = function(r, e, i) {
      this.setInput(r, M.PARTIAL_SIG, e, i);
    }, t.prototype.getInputPartialSig = function(r, e) {
      return this.getInputOptional(r, M.PARTIAL_SIG, e);
    }, t.prototype.setInputSighashType = function(r, e) {
      this.setInput(r, M.SIGHASH_TYPE, V(), De(e));
    }, t.prototype.getInputSighashType = function(r) {
      var e = this.getInputOptional(r, M.SIGHASH_TYPE, V());
      if (e)
        return e.readUInt32LE(0);
    }, t.prototype.setInputRedeemScript = function(r, e) {
      this.setInput(r, M.REDEEM_SCRIPT, V(), e);
    }, t.prototype.getInputRedeemScript = function(r) {
      return this.getInputOptional(r, M.REDEEM_SCRIPT, V());
    }, t.prototype.setInputBip32Derivation = function(r, e, i, s) {
      if (e.length != 33)
        throw new Error("Invalid pubkey length: " + e.length);
      this.setInput(r, M.BIP32_DERIVATION, e, this.encodeBip32Derivation(i, s));
    }, t.prototype.getInputBip32Derivation = function(r, e) {
      var i = this.getInputOptional(r, M.BIP32_DERIVATION, e);
      if (i)
        return this.decodeBip32Derivation(i);
    }, t.prototype.setInputFinalScriptsig = function(r, e) {
      this.setInput(r, M.FINAL_SCRIPTSIG, V(), e);
    }, t.prototype.getInputFinalScriptsig = function(r) {
      return this.getInputOptional(r, M.FINAL_SCRIPTSIG, V());
    }, t.prototype.setInputFinalScriptwitness = function(r, e) {
      this.setInput(r, M.FINAL_SCRIPTWITNESS, V(), e);
    }, t.prototype.getInputFinalScriptwitness = function(r) {
      return this.getInput(r, M.FINAL_SCRIPTWITNESS, V());
    }, t.prototype.setInputPreviousTxId = function(r, e) {
      this.setInput(r, M.PREVIOUS_TXID, V(), e);
    }, t.prototype.getInputPreviousTxid = function(r) {
      return this.getInput(r, M.PREVIOUS_TXID, V());
    }, t.prototype.setInputOutputIndex = function(r, e) {
      this.setInput(r, M.OUTPUT_INDEX, V(), De(e));
    }, t.prototype.getInputOutputIndex = function(r) {
      return this.getInput(r, M.OUTPUT_INDEX, V()).readUInt32LE(0);
    }, t.prototype.setInputSequence = function(r, e) {
      this.setInput(r, M.SEQUENCE, V(), De(e));
    }, t.prototype.getInputSequence = function(r) {
      var e, i;
      return (i = (e = this.getInputOptional(r, M.SEQUENCE, V())) === null || e === void 0 ? void 0 : e.readUInt32LE(0)) !== null && i !== void 0 ? i : 4294967295;
    }, t.prototype.setInputTapKeySig = function(r, e) {
      this.setInput(r, M.TAP_KEY_SIG, V(), e);
    }, t.prototype.getInputTapKeySig = function(r) {
      return this.getInputOptional(r, M.TAP_KEY_SIG, V());
    }, t.prototype.setInputTapBip32Derivation = function(r, e, i, s, n) {
      if (e.length != 32)
        throw new Error("Invalid pubkey length: " + e.length);
      var o = this.encodeTapBip32Derivation(i, s, n);
      this.setInput(r, M.TAP_BIP32_DERIVATION, e, o);
    }, t.prototype.getInputTapBip32Derivation = function(r, e) {
      var i = this.getInput(r, M.TAP_BIP32_DERIVATION, e);
      return this.decodeTapBip32Derivation(i);
    }, t.prototype.getInputKeyDatas = function(r, e) {
      return this.getKeyDatas(this.inputMaps[r], e);
    }, t.prototype.setOutputRedeemScript = function(r, e) {
      this.setOutput(r, ue.REDEEM_SCRIPT, V(), e);
    }, t.prototype.getOutputRedeemScript = function(r) {
      return this.getOutput(r, ue.REDEEM_SCRIPT, V());
    }, t.prototype.setOutputBip32Derivation = function(r, e, i, s) {
      this.setOutput(r, ue.BIP_32_DERIVATION, e, this.encodeBip32Derivation(i, s));
    }, t.prototype.getOutputBip32Derivation = function(r, e) {
      var i = this.getOutput(r, ue.BIP_32_DERIVATION, e);
      return this.decodeBip32Derivation(i);
    }, t.prototype.setOutputAmount = function(r, e) {
      this.setOutput(r, ue.AMOUNT, V(), Zf(e));
    }, t.prototype.getOutputAmount = function(r) {
      var e = this.getOutput(r, ue.AMOUNT, V());
      return Ui(e);
    }, t.prototype.setOutputScript = function(r, e) {
      this.setOutput(r, ue.SCRIPT, V(), e);
    }, t.prototype.getOutputScript = function(r) {
      return this.getOutput(r, ue.SCRIPT, V());
    }, t.prototype.setOutputTapBip32Derivation = function(r, e, i, s, n) {
      var o = this.encodeTapBip32Derivation(i, s, n);
      this.setOutput(r, ue.TAP_BIP32_DERIVATION, e, o);
    }, t.prototype.getOutputTapBip32Derivation = function(r, e) {
      var i = this.getOutput(r, ue.TAP_BIP32_DERIVATION, e);
      return this.decodeTapBip32Derivation(i);
    }, t.prototype.deleteInputEntries = function(r, e) {
      var i = this, s = this.inputMaps[r];
      s.forEach(function(n, o, u) {
        i.isKeyType(o, e) && u.delete(o);
      });
    }, t.prototype.copy = function(r) {
      this.copyMap(this.globalMap, r.globalMap), this.copyMaps(this.inputMaps, r.inputMaps), this.copyMaps(this.outputMaps, r.outputMaps);
    }, t.prototype.copyMaps = function(r, e) {
      var i = this;
      r.forEach(function(s, n) {
        var o = /* @__PURE__ */ new Map();
        i.copyMap(s, o), e[n] = o;
      });
    }, t.prototype.copyMap = function(r, e) {
      r.forEach(function(i, s) {
        return e.set(s, Buffer.from(i));
      });
    }, t.prototype.serialize = function() {
      var r = new z();
      return r.writeSlice(Buffer.from([112, 115, 98, 116, 255])), or(r, this.globalMap), this.inputMaps.forEach(function(e) {
        or(r, e);
      }), this.outputMaps.forEach(function(e) {
        or(r, e);
      }), r.buffer();
    }, t.prototype.deserialize = function(r) {
      var e = new Te(r);
      if (!e.readSlice(5).equals(Wf))
        throw new Error("Invalid magic bytes");
      for (; this.readKeyPair(this.globalMap, e); )
        ;
      for (var i = 0; i < this.getGlobalInputCount(); i++)
        for (this.inputMaps[i] = /* @__PURE__ */ new Map(); this.readKeyPair(this.inputMaps[i], e); )
          ;
      for (var i = 0; i < this.getGlobalOutputCount(); i++)
        for (this.outputMaps[i] = /* @__PURE__ */ new Map(); this.readKeyPair(this.outputMaps[i], e); )
          ;
    }, t.prototype.readKeyPair = function(r, e) {
      var i = e.readVarInt();
      if (i == 0)
        return !1;
      var s = e.readUInt8(), n = e.readSlice(i - 1), o = e.readVarSlice();
      return ur(r, s, n, o), !0;
    }, t.prototype.getKeyDatas = function(r, e) {
      var i = this, s = [];
      return r.forEach(function(n, o) {
        i.isKeyType(o, [e]) && s.push(Buffer.from(o.substring(2), "hex"));
      }), s;
    }, t.prototype.isKeyType = function(r, e) {
      var i = Buffer.from(r.substring(0, 2), "hex").readUInt8(0);
      return e.some(function(s) {
        return s == i;
      });
    }, t.prototype.setGlobal = function(r, e) {
      var i = new jt(r, Buffer.from([]));
      this.globalMap.set(i.toString(), e);
    }, t.prototype.getGlobal = function(r) {
      return Ze(this.globalMap, r, V(), !1);
    }, t.prototype.getGlobalOptional = function(r) {
      return Ze(this.globalMap, r, V(), !0);
    }, t.prototype.setInput = function(r, e, i, s) {
      ur(this.getMap(r, this.inputMaps), e, i, s);
    }, t.prototype.getInput = function(r, e, i) {
      return Ze(this.inputMaps[r], e, i, !1);
    }, t.prototype.getInputOptional = function(r, e, i) {
      return Ze(this.inputMaps[r], e, i, !0);
    }, t.prototype.setOutput = function(r, e, i, s) {
      ur(this.getMap(r, this.outputMaps), e, i, s);
    }, t.prototype.getOutput = function(r, e, i) {
      return Ze(this.outputMaps[r], e, i, !1);
    }, t.prototype.getMap = function(r, e) {
      return e[r] ? e[r] : e[r] = /* @__PURE__ */ new Map();
    }, t.prototype.encodeBip32Derivation = function(r, e) {
      var i = new z();
      return this.writeBip32Derivation(i, r, e), i.buffer();
    }, t.prototype.decodeBip32Derivation = function(r) {
      var e = new Te(r);
      return this.readBip32Derivation(e);
    }, t.prototype.writeBip32Derivation = function(r, e, i) {
      r.writeSlice(e), i.forEach(function(s) {
        r.writeUInt32(s);
      });
    }, t.prototype.readBip32Derivation = function(r) {
      for (var e = r.readSlice(4), i = []; r.offset < r.buffer.length; )
        i.push(r.readUInt32());
      return { masterFingerprint: e, path: i };
    }, t.prototype.encodeTapBip32Derivation = function(r, e, i) {
      var s = new z();
      return s.writeVarInt(r.length), r.forEach(function(n) {
        s.writeSlice(n);
      }), this.writeBip32Derivation(s, e, i), s.buffer();
    }, t.prototype.decodeTapBip32Derivation = function(r) {
      for (var e = new Te(r), i = e.readVarInt(), s = [], n = 0; n < i; n++)
        s.push(e.readSlice(32));
      var o = this.readBip32Derivation(e);
      return yr({ hashes: s }, o);
    }, t;
  }()
);
function Ze(t, r, e, i) {
  if (!t)
    throw Error("No such map");
  var s = new jt(r, e), n = t.get(s.toString());
  if (!n) {
    if (i)
      return;
    throw new jf(s.toString());
  }
  return Buffer.from(n);
}
var jt = (
  /** @class */
  function() {
    function t(r, e) {
      this.keyType = r, this.keyData = e;
    }
    return t.prototype.toString = function() {
      var r = new z();
      return this.toBuffer(r), r.buffer().toString("hex");
    }, t.prototype.serialize = function(r) {
      r.writeVarInt(1 + this.keyData.length), this.toBuffer(r);
    }, t.prototype.toBuffer = function(r) {
      r.writeUInt8(this.keyType), r.writeSlice(this.keyData);
    }, t;
  }()
), zf = (
  /** @class */
  function() {
    function t(r, e) {
      this.key = r, this.value = e;
    }
    return t.prototype.serialize = function(r) {
      this.key.serialize(r), r.writeVarSlice(this.value);
    }, t;
  }()
);
function Yf(t) {
  return new jt(t.readUInt8(0), t.slice(1));
}
function or(t, r) {
  for (var e in r.keys) {
    var i = r.get(e), s = new zf(Yf(Buffer.from(e, "hex")), i);
    s.serialize(t);
  }
  t.writeUInt8(0);
}
function V() {
  return Buffer.from([]);
}
function ur(t, r, e, i) {
  var s = new jt(r, e);
  t.set(s.toString(), i);
}
function De(t) {
  var r = Buffer.alloc(4);
  return r.writeUInt32LE(t, 0), r;
}
function Zf(t) {
  return Di(t);
}
function Mn(t) {
  var r = new z();
  return r.writeVarInt(t), r.buffer();
}
function Gn(t) {
  return new Te(t).readVarInt();
}
function Qf(t) {
  for (var r = t.getGlobalInputCount(), e = 0; e < r; e++) {
    var i = t.getInputKeyDatas(e, M.PARTIAL_SIG), s = t.getInputTapKeySig(e);
    if (i.length == 0 && !s)
      throw Error("No signature for input ".concat(e, " present"));
    if (i.length > 0) {
      if (i.length > 1)
        throw Error("Expected exactly one signature, got ".concat(i.length));
      if (s)
        throw Error("Both taproot and non-taproot signatures present.");
      var n = !!t.getInputWitnessUtxo(e), o = t.getInputRedeemScript(e), u = !!o, c = t.getInputPartialSig(e, i[0]);
      if (!c)
        throw new Error("Expected partial signature for input " + e);
      if (n) {
        var a = new z();
        if (a.writeVarInt(2), a.writeVarInt(c.length), a.writeSlice(c), a.writeVarInt(i[0].length), a.writeSlice(i[0]), t.setInputFinalScriptwitness(e, a.buffer()), u) {
          if (!o || o.length == 0)
            throw new Error("Expected non-empty redeemscript. Can't finalize intput " + e);
          var f = new z();
          f.writeUInt8(o.length), f.writeSlice(o), t.setInputFinalScriptsig(e, f.buffer());
        }
      } else {
        var l = new z();
        Fn(l, c), Fn(l, i[0]), t.setInputFinalScriptsig(e, l.buffer());
      }
    } else {
      var c = t.getInputTapKeySig(e);
      if (!c)
        throw Error("No taproot signature found");
      if (c.length != 64 && c.length != 65)
        throw Error("Unexpected length of schnorr signature.");
      var a = new z();
      a.writeVarInt(1), a.writeVarSlice(c), t.setInputFinalScriptwitness(e, a.buffer());
    }
    Jf(t, e);
  }
}
function Jf(t, r) {
  var e = [
    M.BIP32_DERIVATION,
    M.PARTIAL_SIG,
    M.TAP_BIP32_DERIVATION,
    M.TAP_KEY_SIG
  ], i = !!t.getInputWitnessUtxo(r), s = !!t.getInputNonWitnessUtxo(r);
  i && s && e.push(M.NON_WITNESS_UTXO), t.deleteInputEntries(r, e);
}
function Fn(t, r) {
  if (r.length <= 75)
    t.writeUInt8(r.length);
  else if (r.length <= 256)
    t.writeUInt8(76), t.writeUInt8(r.length);
  else if (r.length <= 256 * 256) {
    t.writeUInt8(77);
    var e = Buffer.alloc(2);
    e.writeUInt16LE(r.length, 0), t.writeSlice(e);
  }
  t.writeSlice(r);
}
function Ue(t, r) {
  if (t[r] < 253)
    return [t[r], 1];
  if (t[r] === 253)
    return [(t[r + 2] << 8) + t[r + 1], 3];
  if (t[r] === 254)
    return [
      (t[r + 4] << 24) + (t[r + 3] << 16) + (t[r + 2] << 8) + t[r + 1],
      5
    ];
  throw new Error("getVarint called with unexpected parameters");
}
function j(t) {
  if (t < 253) {
    var r = Buffer.alloc(1);
    return r[0] = t, r;
  }
  if (t <= 65535) {
    var e = Buffer.alloc(3);
    return e[0] = 253, e[1] = t & 255, e[2] = t >> 8 & 255, e;
  }
  var i = Buffer.alloc(5);
  return i[0] = 254, i[1] = t & 255, i[2] = t >> 8 & 255, i[3] = t >> 16 & 255, i[4] = t >> 24 & 255, i;
}
function Ki(t) {
  var r = t.outputs, e = Buffer.alloc(0);
  return typeof r < "u" && (e = Buffer.concat([e, j(r.length)]), r.forEach(function(i) {
    e = Buffer.concat([
      e,
      i.amount,
      j(i.script.length),
      i.script
    ]);
  })), e;
}
function Wr(t, r, e, i) {
  i === void 0 && (i = []);
  var s = i.includes("decred"), n = i.includes("zcash"), o = i.includes("bech32"), u = Buffer.alloc(0), c = typeof t.witness < "u" && !r;
  t.inputs.forEach(function(f) {
    u = s || o ? Buffer.concat([
      u,
      f.prevout,
      Buffer.from([0]),
      f.sequence
    ]) : Buffer.concat([
      u,
      f.prevout,
      j(f.script.length),
      f.script,
      f.sequence
    ]);
  });
  var a = Ki(t);
  return typeof t.outputs < "u" && typeof t.locktime < "u" && (a = Buffer.concat([
    a,
    c && t.witness || Buffer.alloc(0),
    t.locktime,
    t.nExpiryHeight || Buffer.alloc(0),
    t.extraData || Buffer.alloc(0)
  ])), n ? Buffer.concat([
    t.version,
    t.nVersionGroupId || Buffer.alloc(0),
    Buffer.from([180, 208, 214, 194]),
    t.locktime || Buffer.from([0, 0, 0, 0]),
    t.nExpiryHeight || Buffer.from([0, 0, 0, 0]),
    c ? Buffer.from("0001", "hex") : Buffer.alloc(0),
    j(t.inputs.length),
    u,
    a
  ]) : Buffer.concat([
    t.version,
    e || Buffer.alloc(0),
    t.nVersionGroupId || Buffer.alloc(0),
    c ? Buffer.from("0001", "hex") : Buffer.alloc(0),
    j(t.inputs.length),
    u,
    a
  ]);
}
var me = globalThis && globalThis.__awaiter || function(t, r, e, i) {
  function s(n) {
    return n instanceof e ? n : new e(function(o) {
      o(n);
    });
  }
  return new (e || (e = Promise))(function(n, o) {
    function u(f) {
      try {
        a(i.next(f));
      } catch (l) {
        o(l);
      }
    }
    function c(f) {
      try {
        a(i.throw(f));
      } catch (l) {
        o(l);
      }
    }
    function a(f) {
      f.done ? n(f.value) : s(f.value).then(u, c);
    }
    a((i = i.apply(t, r || [])).next());
  });
}, be = globalThis && globalThis.__generator || function(t, r) {
  var e = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, s, n, o;
  return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function u(a) {
    return function(f) {
      return c([a, f]);
    };
  }
  function c(a) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; e; )
      try {
        if (i = 1, s && (n = a[0] & 2 ? s.return : a[0] ? s.throw || ((n = s.return) && n.call(s), 0) : s.next) && !(n = n.call(s, a[1])).done)
          return n;
        switch (s = 0, n && (a = [a[0] & 2, n.value]), a[0]) {
          case 0:
          case 1:
            n = a;
            break;
          case 4:
            return e.label++, { value: a[1], done: !1 };
          case 5:
            e.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = e.ops.pop(), e.trys.pop();
            continue;
          default:
            if (n = e.trys, !(n = n.length > 0 && n[n.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              e = 0;
              continue;
            }
            if (a[0] === 3 && (!n || a[1] > n[0] && a[1] < n[3])) {
              e.label = a[1];
              break;
            }
            if (a[0] === 6 && e.label < n[1]) {
              e.label = n[1], n = a;
              break;
            }
            if (n && e.label < n[2]) {
              e.label = n[2], e.ops.push(a);
              break;
            }
            n[2] && e.ops.pop(), e.trys.pop();
            continue;
        }
        a = r.call(t, e);
      } catch (f) {
        a = [6, f], s = 0;
      } finally {
        i = n = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
}, ec = ["Bitcoin", "Bitcoin Test"];
function tc(t) {
  return ec.includes(t.name) && Bi.major(t.version) >= 2;
}
var Vn = (
  /** @class */
  function() {
    function t(r) {
      this.client = r;
    }
    return t.prototype.getWalletXpub = function(r) {
      var e = r.path, i = r.xpubVersion;
      return me(this, void 0, void 0, function() {
        var s, n, o;
        return be(this, function(u) {
          switch (u.label) {
            case 0:
              return s = xe(e), [4, this.client.getExtendedPubkey(!1, s)];
            case 1:
              if (n = u.sent(), o = ln(n), o.version != i)
                throw new Error("Expected xpub version ".concat(i, " doesn't match the xpub version from the device ").concat(o.version));
              return [2, n];
          }
        });
      });
    }, t.prototype.getWalletPublicKey = function(r, e) {
      var i, s;
      return me(this, void 0, void 0, function() {
        var n, o, u, c, a, f;
        return be(this, function(l) {
          switch (l.label) {
            case 0:
              return n = xe(r), [4, this.client.getExtendedPubkey(!1, n)];
            case 1:
              return o = l.sent(), u = (i = e == null ? void 0 : e.verify) !== null && i !== void 0 ? i : !1, [4, this.getWalletAddress(n, rc((s = e == null ? void 0 : e.format) !== null && s !== void 0 ? s : "legacy"), u)];
            case 2:
              return c = l.sent(), a = ln(o), f = Buffer.from(Li.pointCompress(a.pubkey, !1)), [2, {
                publicKey: f.toString("hex"),
                bitcoinAddress: c,
                chainCode: a.chaincode.toString("hex")
              }];
          }
        });
      });
    }, t.prototype.getWalletAddress = function(r, e, i) {
      return me(this, void 0, void 0, function() {
        var s, n, o, u, c;
        return be(this, function(a) {
          switch (a.label) {
            case 0:
              return s = ca(r), s.length + 2 != r.length ? [2, ""] : [4, this.client.getExtendedPubkey(!1, s)];
            case 1:
              return n = a.sent(), [4, this.client.getMasterFingerprint()];
            case 2:
              return o = a.sent(), u = new Un(e, kn(o, s, n)), c = r.slice(-2, r.length), [2, this.client.getWalletAddress(u, Buffer.alloc(32, 0), c[0], c[1], i)];
          }
        });
      });
    }, t.prototype.createPaymentTransactionNew = function(r) {
      return me(this, void 0, void 0, function() {
        var e, i, s, n, o, u, c, a, x, f, l, v, h, w, b, x, B, p, $, R, P, I, U, L, X, A;
        return be(this, function(k) {
          switch (k.label) {
            case 0:
              if (e = r.inputs.length, e == 0)
                throw Error("No inputs");
              return i = new Vi(), [4, this.client.getMasterFingerprint()];
            case 1:
              s = k.sent(), n = nc(r, i, s), r.lockTime != null && i.setGlobalFallbackLocktime(r.lockTime), i.setGlobalInputCount(e), i.setGlobalPsbtVersion(2), i.setGlobalTxVersion(2), o = 0, u = function() {
                r.onDeviceStreaming && r.onDeviceStreaming({
                  total: 2 * e,
                  index: o,
                  progress: ++o / (2 * e)
                });
              }, c = "", a = [], x = 0, k.label = 2;
            case 2:
              return x < e ? (u(), f = xe(r.associatedKeysets[x]), c != "" ? [3, 4] : (a = f.slice(0, -2), [4, this.client.getExtendedPubkey(!1, a)])) : [3, 7];
            case 3:
              c = k.sent(), k.label = 4;
            case 4:
              return [4, this.setInput(i, x, r.inputs[x], f, n, s, r.sigHashType)];
            case 5:
              k.sent(), k.label = 6;
            case 6:
              return x++, [3, 2];
            case 7:
              return l = Buffer.from(r.outputScriptHex, "hex"), v = new Te(l), h = v.readVarInt(), i.setGlobalOutputCount(h), [4, this.outputScriptAt(a, n, r.changePath)];
            case 8:
              for (w = k.sent(), b = !w, x = 0; x < h; x++)
                B = Number(v.readUInt64()), p = v.readVarSlice(), i.setOutputAmount(x, B), i.setOutputScript(x, p), $ = w && p.equals(w == null ? void 0 : w.cond.scriptPubKey), $ && (b = !0, R = xe(r.changePath), P = w.pubkey, n.setOwnOutput(x, w.cond, [P], [R]));
              if (!b)
                throw new Error("Change script not found among outputs! " + (w == null ? void 0 : w.cond.scriptPubKey.toString("hex")));
              return I = kn(s, a, c), U = new Un(n.getDescriptorTemplate(), I), r.onDeviceSignatureRequested && r.onDeviceSignatureRequested(), L = !1, X = function() {
                L || (L = !0, r.onDeviceSignatureGranted && r.onDeviceSignatureGranted()), u();
              }, [4, this.signPsbt(i, U, X)];
            case 9:
              return k.sent(), Qf(i), A = Xf(i), [2, A.toString("hex")];
          }
        });
      });
    }, t.prototype.outputScriptAt = function(r, e, i) {
      return me(this, void 0, void 0, function() {
        var s, n, o, u, c;
        return be(this, function(a) {
          switch (a.label) {
            case 0:
              if (!i)
                return [2, void 0];
              for (s = xe(i), n = 0; n < r.length; n++)
                if (r[n] != s[n])
                  throw new Error("Path ".concat(i, " not in account ").concat(Lr(r)));
              return [4, this.client.getExtendedPubkey(!1, s)];
            case 1:
              return o = a.sent(), u = cn(o), c = e.spendingCondition([u]), [2, { cond: c, pubkey: u }];
          }
        });
      });
    }, t.prototype.setInput = function(r, e, i, s, n, o, u) {
      return me(this, void 0, void 0, function() {
        var c, a, f, l, v, h, w, b, x, B, p;
        return be(this, function($) {
          switch ($.label) {
            case 0:
              return c = i[0], a = i[1], f = i[2] ? Buffer.from(i[2], "hex") : void 0, l = i[3], l != null && r.setInputSequence(e, l), u != null && r.setInputSighashType(e, u), v = Wr(c, !0), h = Se.hash256(v), [4, this.client.getExtendedPubkey(!1, s)];
            case 1:
              if (w = $.sent(), b = cn(w), !c.outputs)
                throw Error("Missing outputs array in transaction to sign");
              return x = c.outputs[a], B = {
                scriptPubKey: x.script,
                redeemScript: f
              }, p = { cond: B, amount: x.amount }, n.setInput(e, v, p, [b], [s]), r.setInputPreviousTxId(e, h), r.setInputOutputIndex(e, a), [
                2
                /*return*/
              ];
          }
        });
      });
    }, t.prototype.signPsbt = function(r, e, i) {
      return me(this, void 0, void 0, function() {
        var s;
        return be(this, function(n) {
          switch (n.label) {
            case 0:
              return [4, this.client.signPsbt(r, e, Buffer.alloc(32, 0), i)];
            case 1:
              return s = n.sent(), s.forEach(function(o, u) {
                var c = r.getInputKeyDatas(u, M.BIP32_DERIVATION), a;
                if (c.length != 1) {
                  if (a = r.getInputKeyDatas(u, M.TAP_BIP32_DERIVATION), a.length == 0)
                    throw Error("Missing pubkey derivation for input ".concat(u));
                  r.setInputTapKeySig(u, o);
                } else
                  a = c[0], r.setInputPartialSig(u, a, o);
              }), [
                2
                /*return*/
              ];
          }
        });
      });
    }, t;
  }()
);
function rc(t) {
  if (t == "legacy")
    return "pkh(@0)";
  if (t == "p2sh")
    return "sh(wpkh(@0))";
  if (t == "bech32")
    return "wpkh(@0)";
  if (t == "bech32m")
    return "tr(@0)";
  throw new Error("Unsupported address format " + t);
}
function nc(t, r, e) {
  return t.additionals.includes("bech32m") ? new Mf(r, e) : t.additionals.includes("bech32") ? new Ff(r, e) : t.segwit ? new Gf(r, e) : new kf(r, e);
}
var _r = globalThis && globalThis.__assign || function() {
  return _r = Object.assign || function(t) {
    for (var r, e = 1, i = arguments.length; e < i; e++) {
      r = arguments[e];
      for (var s in r)
        Object.prototype.hasOwnProperty.call(r, s) && (t[s] = r[s]);
    }
    return t;
  }, _r.apply(this, arguments);
}, ic = globalThis && globalThis.__awaiter || function(t, r, e, i) {
  function s(n) {
    return n instanceof e ? n : new e(function(o) {
      o(n);
    });
  }
  return new (e || (e = Promise))(function(n, o) {
    function u(f) {
      try {
        a(i.next(f));
      } catch (l) {
        o(l);
      }
    }
    function c(f) {
      try {
        a(i.throw(f));
      } catch (l) {
        o(l);
      }
    }
    function a(f) {
      f.done ? n(f.value) : s(f.value).then(u, c);
    }
    a((i = i.apply(t, r || [])).next());
  });
}, sc = globalThis && globalThis.__generator || function(t, r) {
  var e = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, s, n, o;
  return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function u(a) {
    return function(f) {
      return c([a, f]);
    };
  }
  function c(a) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; e; )
      try {
        if (i = 1, s && (n = a[0] & 2 ? s.return : a[0] ? s.throw || ((n = s.return) && n.call(s), 0) : s.next) && !(n = n.call(s, a[1])).done)
          return n;
        switch (s = 0, n && (a = [a[0] & 2, n.value]), a[0]) {
          case 0:
          case 1:
            n = a;
            break;
          case 4:
            return e.label++, { value: a[1], done: !1 };
          case 5:
            e.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = e.ops.pop(), e.trys.pop();
            continue;
          default:
            if (n = e.trys, !(n = n.length > 0 && n[n.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              e = 0;
              continue;
            }
            if (a[0] === 3 && (!n || a[1] > n[0] && a[1] < n[3])) {
              e.label = a[1];
              break;
            }
            if (a[0] === 6 && e.label < n[1]) {
              e.label = n[1], n = a;
              break;
            }
            if (n && e.label < n[2]) {
              e.label = n[2], e.ops.push(a);
              break;
            }
            n[2] && e.ops.pop(), e.trys.pop();
            continue;
        }
        a = r.call(t, e);
      } catch (f) {
        a = [6, f], s = 0;
      } finally {
        i = n = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
}, Kn = {
  legacy: 0,
  p2sh: 1,
  bech32: 2,
  cashaddr: 3
};
function mr(t, r) {
  return ic(this, void 0, void 0, function() {
    var e, i, s, n, o, u, c, a, f, l, v, h, w;
    return sc(this, function(b) {
      switch (b.label) {
        case 0:
          if (e = _r({ verify: !1, format: "legacy" }, r), i = e.path, s = e.verify, n = e.format, !(n in Kn))
            throw new Error("btc.getWalletPublicKey invalid format=" + n);
          return o = Pr(i), u = s ? 1 : 0, c = Kn[n], [4, t.send(224, 64, u, c, o)];
        case 1:
          return a = b.sent(), f = a[0], l = a[1 + f], v = a.slice(1, 1 + f).toString("hex"), h = a.slice(1 + f + 1, 1 + f + 1 + l).toString("ascii"), w = a.slice(1 + f + 1 + l, 1 + f + 1 + l + 32).toString("hex"), [2, {
            publicKey: v,
            bitcoinAddress: h,
            chainCode: w
          }];
      }
    });
  });
}
var br = globalThis && globalThis.__awaiter || function(t, r, e, i) {
  function s(n) {
    return n instanceof e ? n : new e(function(o) {
      o(n);
    });
  }
  return new (e || (e = Promise))(function(n, o) {
    function u(f) {
      try {
        a(i.next(f));
      } catch (l) {
        o(l);
      }
    }
    function c(f) {
      try {
        a(i.throw(f));
      } catch (l) {
        o(l);
      }
    }
    function a(f) {
      f.done ? n(f.value) : s(f.value).then(u, c);
    }
    a((i = i.apply(t, r || [])).next());
  });
}, Ir = globalThis && globalThis.__generator || function(t, r) {
  var e = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, s, n, o;
  return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function u(a) {
    return function(f) {
      return c([a, f]);
    };
  }
  function c(a) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; e; )
      try {
        if (i = 1, s && (n = a[0] & 2 ? s.return : a[0] ? s.throw || ((n = s.return) && n.call(s), 0) : s.next) && !(n = n.call(s, a[1])).done)
          return n;
        switch (s = 0, n && (a = [a[0] & 2, n.value]), a[0]) {
          case 0:
          case 1:
            n = a;
            break;
          case 4:
            return e.label++, { value: a[1], done: !1 };
          case 5:
            e.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = e.ops.pop(), e.trys.pop();
            continue;
          default:
            if (n = e.trys, !(n = n.length > 0 && n[n.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              e = 0;
              continue;
            }
            if (a[0] === 3 && (!n || a[1] > n[0] && a[1] < n[3])) {
              e.label = a[1];
              break;
            }
            if (a[0] === 6 && e.label < n[1]) {
              e.label = n[1], n = a;
              break;
            }
            if (n && e.label < n[2]) {
              e.label = n[2], e.ops.push(a);
              break;
            }
            n[2] && e.ops.pop(), e.trys.pop();
            continue;
        }
        a = r.call(t, e);
      } catch (f) {
        a = [6, f], s = 0;
      } finally {
        i = n = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
}, fr = globalThis && globalThis.__values || function(t) {
  var r = typeof Symbol == "function" && Symbol.iterator, e = r && t[r], i = 0;
  if (e)
    return e.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && i >= t.length && (t = void 0), { value: t && t[i++], done: !t };
      }
    };
  throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function ke(t, r, e) {
  return br(this, void 0, void 0, function() {
    var i, s, n, o, u;
    return Ir(this, function(c) {
      switch (c.label) {
        case 0:
          return s = !1, typeof e == "number" ? (s = !0, n = Buffer.alloc(4), n.writeUInt32BE(e, 0), i = Buffer.concat([n, r], r.length + 4)) : i = r, [4, t.send(224, 66, s ? 0 : 128, 0, i)];
        case 1:
          return o = c.sent(), u = o.slice(0, o.length - 2).toString("hex"), [2, u];
      }
    });
  });
}
function jr(t, r, e, i) {
  return i === void 0 && (i = []), br(this, void 0, void 0, function() {
    var s, n, o, u, c, a, f, l, v, h, w, b, x, B, p, A, $, R, P, I, A, U, L, X, A, k, N, d, g, _, T = this;
    return Ir(this, function(E) {
      switch (E.label) {
        case 0:
          if (s = e.version, n = e.inputs, o = e.outputs, u = e.locktime, c = e.nExpiryHeight, a = e.extraData, !o || !u)
            throw new Error("getTrustedInput: locktime & outputs is expected");
          return f = i.includes("decred"), l = i.includes("stealthcoin"), v = function(y, O) {
            return br(T, void 0, void 0, function() {
              var S, m, D, K, G, H, q, ee, de, ge, je;
              return Ir(this, function(se) {
                switch (se.label) {
                  case 0:
                    for (S = O || Buffer.alloc(0), m = [], D = 0; D !== y.length; )
                      K = y.length - D > _e ? _e : y.length - D, D + K !== y.length ? m.push(y.slice(D, D + K)) : m.push(Buffer.concat([y.slice(D, D + K), S])), D += K;
                    y.length === 0 && m.push(S), se.label = 1;
                  case 1:
                    se.trys.push([1, 6, 7, 8]), H = fr(m), q = H.next(), se.label = 2;
                  case 2:
                    return q.done ? [3, 5] : (ee = q.value, [4, ke(t, ee)]);
                  case 3:
                    G = se.sent(), se.label = 4;
                  case 4:
                    return q = H.next(), [3, 2];
                  case 5:
                    return [3, 8];
                  case 6:
                    return de = se.sent(), ge = { error: de }, [3, 8];
                  case 7:
                    try {
                      q && !q.done && (je = H.return) && je.call(H);
                    } finally {
                      if (ge)
                        throw ge.error;
                    }
                    return [
                      7
                      /*endfinally*/
                    ];
                  case 8:
                    return [2, G];
                }
              });
            });
          }, h = function(y) {
            return ke(t, y);
          }, [4, ke(t, Buffer.concat([
            e.version,
            e.timestamp || Buffer.alloc(0),
            e.nVersionGroupId || Buffer.alloc(0),
            j(n.length)
          ]), r)];
        case 1:
          E.sent(), E.label = 2;
        case 2:
          E.trys.push([2, 8, 9, 10]), w = fr(n), b = w.next(), E.label = 3;
        case 3:
          return b.done ? [3, 7] : (x = b.value, B = l && Buffer.compare(s, Buffer.from([2, 0, 0, 0])) === 0, p = f ? x.tree || Buffer.from([0]) : Buffer.alloc(0), A = Buffer.concat([
            x.prevout,
            p,
            B ? Buffer.from([0]) : j(x.script.length)
          ]), [4, ke(t, A)]);
        case 4:
          return E.sent(), [4, f ? h(Buffer.concat([x.script, x.sequence])) : B ? h(x.sequence) : v(x.script, x.sequence)];
        case 5:
          E.sent(), E.label = 6;
        case 6:
          return b = w.next(), [3, 3];
        case 7:
          return [3, 10];
        case 8:
          return $ = E.sent(), N = { error: $ }, [3, 10];
        case 9:
          try {
            b && !b.done && (d = w.return) && d.call(w);
          } finally {
            if (N)
              throw N.error;
          }
          return [
            7
            /*endfinally*/
          ];
        case 10:
          return [4, ke(t, j(o.length))];
        case 11:
          E.sent(), E.label = 12;
        case 12:
          E.trys.push([12, 17, 18, 19]), R = fr(o), P = R.next(), E.label = 13;
        case 13:
          return P.done ? [3, 16] : (I = P.value, A = Buffer.concat([
            I.amount,
            f ? Buffer.from([0, 0]) : Buffer.alloc(0),
            j(I.script.length),
            I.script
          ]), [4, ke(t, A)]);
        case 14:
          E.sent(), E.label = 15;
        case 15:
          return P = R.next(), [3, 13];
        case 16:
          return [3, 19];
        case 17:
          return U = E.sent(), g = { error: U }, [3, 19];
        case 18:
          try {
            P && !P.done && (_ = R.return) && _.call(R);
          } finally {
            if (g)
              throw g.error;
          }
          return [
            7
            /*endfinally*/
          ];
        case 19:
          return L = [], c && c.length > 0 && L.push(c), a && a.length > 0 && L.push(a), L.length && (A = Buffer.concat(L), X = f ? A : Buffer.concat([j(A.length), A])), [4, v(Buffer.concat([u, X || Buffer.alloc(0)]))];
        case 20:
          return k = E.sent(), ii(k, "missing result in processScriptBlocks"), [2, k];
      }
    });
  });
}
var ac = globalThis && globalThis.__awaiter || function(t, r, e, i) {
  function s(n) {
    return n instanceof e ? n : new e(function(o) {
      o(n);
    });
  }
  return new (e || (e = Promise))(function(n, o) {
    function u(f) {
      try {
        a(i.next(f));
      } catch (l) {
        o(l);
      }
    }
    function c(f) {
      try {
        a(i.throw(f));
      } catch (l) {
        o(l);
      }
    }
    function a(f) {
      f.done ? n(f.value) : s(f.value).then(u, c);
    }
    a((i = i.apply(t, r || [])).next());
  });
}, oc = globalThis && globalThis.__generator || function(t, r) {
  var e = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, s, n, o;
  return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function u(a) {
    return function(f) {
      return c([a, f]);
    };
  }
  function c(a) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; e; )
      try {
        if (i = 1, s && (n = a[0] & 2 ? s.return : a[0] ? s.throw || ((n = s.return) && n.call(s), 0) : s.next) && !(n = n.call(s, a[1])).done)
          return n;
        switch (s = 0, n && (a = [a[0] & 2, n.value]), a[0]) {
          case 0:
          case 1:
            n = a;
            break;
          case 4:
            return e.label++, { value: a[1], done: !1 };
          case 5:
            e.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = e.ops.pop(), e.trys.pop();
            continue;
          default:
            if (n = e.trys, !(n = n.length > 0 && n[n.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              e = 0;
              continue;
            }
            if (a[0] === 3 && (!n || a[1] > n[0] && a[1] < n[3])) {
              e.label = a[1];
              break;
            }
            if (a[0] === 6 && e.label < n[1]) {
              e.label = n[1], n = a;
              break;
            }
            if (n && e.label < n[2]) {
              e.label = n[2], e.ops.push(a);
              break;
            }
            n[2] && e.ops.pop(), e.trys.pop();
            continue;
        }
        a = r.call(t, e);
      } catch (f) {
        a = [6, f], s = 0;
      } finally {
        i = n = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
}, qn = globalThis && globalThis.__values || function(t) {
  var r = typeof Symbol == "function" && Symbol.iterator, e = r && t[r], i = 0;
  if (e)
    return e.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && i >= t.length && (t = void 0), { value: t && t[i++], done: !t };
      }
    };
  throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function cr(t, r, e, i, s, n, o) {
  s === void 0 && (s = !1), n === void 0 && (n = !1), o === void 0 && (o = []);
  var u = o.includes("cashaddr") ? 3 : s ? o.includes("sapling") ? 5 : n ? 4 : 2 : 0;
  return t.send(224, 68, e ? 0 : 128, r ? u : 128, i);
}
function Bt(t, r, e, i, s, n, o, u) {
  return s === void 0 && (s = !1), n === void 0 && (n = !1), o === void 0 && (o = []), u === void 0 && (u = !1), ac(this, void 0, void 0, function() {
    var c, a, f, l, v, h, w, b, x, B, p, $, R, P, I, U, L, X, A, k;
    return oc(this, function(N) {
      switch (N.label) {
        case 0:
          return c = Buffer.concat([
            e.version,
            e.timestamp || Buffer.alloc(0),
            e.nVersionGroupId || Buffer.alloc(0),
            j(e.inputs.length)
          ]), [4, cr(t, r, !0, c, s, n, o)];
        case 1:
          N.sent(), a = 0, f = o.includes("decred"), N.label = 2;
        case 2:
          N.trys.push([2, 15, 16, 17]), l = qn(e.inputs), v = l.next(), N.label = 3;
        case 3:
          return v.done ? [3, 14] : (h = v.value, w = void 0, b = i[a].value, s ? u && i[a].trustedInput ? w = Buffer.from([1, b.length]) : w = Buffer.from([2]) : i[a].trustedInput ? w = Buffer.from([1, i[a].value.length]) : w = Buffer.from([0]), c = Buffer.concat([
            w,
            b,
            f ? Buffer.from([0]) : Buffer.alloc(0),
            j(h.script.length)
          ]), [4, cr(t, r, !1, c, s, n, o)]);
        case 4:
          if (N.sent(), x = [], B = 0, h.script.length === 0)
            x.push(h.sequence);
          else
            for (; B !== h.script.length; )
              p = h.script.length - B > _e ? _e : h.script.length - B, B + p !== h.script.length ? x.push(h.script.slice(B, B + p)) : x.push(Buffer.concat([
                h.script.slice(B, B + p),
                h.sequence
              ])), B += p;
          N.label = 5;
        case 5:
          N.trys.push([5, 10, 11, 12]), $ = (A = void 0, qn(x)), R = $.next(), N.label = 6;
        case 6:
          return R.done ? [3, 9] : (P = R.value, [4, cr(t, r, !1, P, s, n, o)]);
        case 7:
          N.sent(), N.label = 8;
        case 8:
          return R = $.next(), [3, 6];
        case 9:
          return [3, 12];
        case 10:
          return I = N.sent(), A = { error: I }, [3, 12];
        case 11:
          try {
            R && !R.done && (k = $.return) && k.call($);
          } finally {
            if (A)
              throw A.error;
          }
          return [
            7
            /*endfinally*/
          ];
        case 12:
          a++, N.label = 13;
        case 13:
          return v = l.next(), [3, 3];
        case 14:
          return [3, 17];
        case 15:
          return U = N.sent(), L = { error: U }, [3, 17];
        case 16:
          try {
            v && !v.done && (X = l.return) && X.call(l);
          } finally {
            if (L)
              throw L.error;
          }
          return [
            7
            /*endfinally*/
          ];
        case 17:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function zr(t, r, e, i) {
  if (i === void 0 && (i = []), !e)
    throw new Error("getTrustedInputBIP143: missing tx");
  var s = i.includes("decred");
  if (s)
    throw new Error("Decred does not implement BIP143");
  var n = mt("sha256").update(mt("sha256").update(Wr(e, !0)).digest()).digest(), o = Buffer.alloc(4);
  o.writeUInt32LE(r, 0);
  var u = e.outputs, c = e.locktime;
  if (!u || !c)
    throw new Error("getTrustedInputBIP143: locktime & outputs is expected");
  if (!u[r])
    throw new Error("getTrustedInputBIP143: wrong index");
  return n = Buffer.concat([n, o, u[r].amount]), n.toString("hex");
}
function uc(t) {
  var r = t[64] & 1 ? 3 : 2, e = Buffer.alloc(1);
  return e[0] = r, Buffer.concat([e, t.slice(1, 1 + 32)]);
}
function Tr(t, r, e, i, s, n) {
  n === void 0 && (n = []);
  var o = n.includes("decred"), u = Pr(r), c = Buffer.alloc(4);
  c.writeUInt32BE(e, 0);
  var a = o ? Buffer.concat([
    u,
    c,
    s || Buffer.from([0, 0, 0, 0]),
    Buffer.from([i])
  ]) : Buffer.concat([
    u,
    Buffer.from([0]),
    c,
    Buffer.from([i])
  ]);
  return s && !o && (a = Buffer.concat([a, s])), t.send(224, 72, 0, 0, a).then(function(f) {
    return f.length > 0 ? (f[0] = 48, f.slice(0, f.length - 2)) : f;
  });
}
var fc = globalThis && globalThis.__awaiter || function(t, r, e, i) {
  function s(n) {
    return n instanceof e ? n : new e(function(o) {
      o(n);
    });
  }
  return new (e || (e = Promise))(function(n, o) {
    function u(f) {
      try {
        a(i.next(f));
      } catch (l) {
        o(l);
      }
    }
    function c(f) {
      try {
        a(i.throw(f));
      } catch (l) {
        o(l);
      }
    }
    function a(f) {
      f.done ? n(f.value) : s(f.value).then(u, c);
    }
    a((i = i.apply(t, r || [])).next());
  });
}, cc = globalThis && globalThis.__generator || function(t, r) {
  var e = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, s, n, o;
  return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function u(a) {
    return function(f) {
      return c([a, f]);
    };
  }
  function c(a) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; e; )
      try {
        if (i = 1, s && (n = a[0] & 2 ? s.return : a[0] ? s.throw || ((n = s.return) && n.call(s), 0) : s.next) && !(n = n.call(s, a[1])).done)
          return n;
        switch (s = 0, n && (a = [a[0] & 2, n.value]), a[0]) {
          case 0:
          case 1:
            n = a;
            break;
          case 4:
            return e.label++, { value: a[1], done: !1 };
          case 5:
            e.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = e.ops.pop(), e.trys.pop();
            continue;
          default:
            if (n = e.trys, !(n = n.length > 0 && n[n.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              e = 0;
              continue;
            }
            if (a[0] === 3 && (!n || a[1] > n[0] && a[1] < n[3])) {
              e.label = a[1];
              break;
            }
            if (a[0] === 6 && e.label < n[1]) {
              e.label = n[1], n = a;
              break;
            }
            if (n && e.label < n[2]) {
              e.label = n[2], e.ops.push(a);
              break;
            }
            n[2] && e.ops.pop(), e.trys.pop();
            continue;
        }
        a = r.call(t, e);
      } catch (f) {
        a = [6, f], s = 0;
      } finally {
        i = n = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
};
function Xn(t, r) {
  var e = Pr(r);
  return t.send(224, 74, 255, 0, e);
}
function $t(t, r, e) {
  return e === void 0 && (e = []), fc(this, void 0, void 0, function() {
    var i, s, n, o, u, c;
    return cc(this, function(a) {
      switch (a.label) {
        case 0:
          if (i = 0, s = 128, n = e.includes("decred"), n)
            return [2, t.send(224, 74, s, 0, r)];
          a.label = 1;
        case 1:
          return i < r.length ? (o = i + _e >= r.length ? r.length - i : _e, u = i + o === r.length ? 128 : 0, c = r.slice(i, i + o), [4, t.send(224, 74, u, 0, c)]) : [3, 3];
        case 2:
          return a.sent(), i += o, [3, 1];
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
var lc = globalThis && globalThis.__awaiter || function(t, r, e, i) {
  function s(n) {
    return n instanceof e ? n : new e(function(o) {
      o(n);
    });
  }
  return new (e || (e = Promise))(function(n, o) {
    function u(f) {
      try {
        a(i.next(f));
      } catch (l) {
        o(l);
      }
    }
    function c(f) {
      try {
        a(i.throw(f));
      } catch (l) {
        o(l);
      }
    }
    function a(f) {
      f.done ? n(f.value) : s(f.value).then(u, c);
    }
    a((i = i.apply(t, r || [])).next());
  });
}, hc = globalThis && globalThis.__generator || function(t, r) {
  var e = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, s, n, o;
  return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function u(a) {
    return function(f) {
      return c([a, f]);
    };
  }
  function c(a) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; e; )
      try {
        if (i = 1, s && (n = a[0] & 2 ? s.return : a[0] ? s.throw || ((n = s.return) && n.call(s), 0) : s.next) && !(n = n.call(s, a[1])).done)
          return n;
        switch (s = 0, n && (a = [a[0] & 2, n.value]), a[0]) {
          case 0:
          case 1:
            n = a;
            break;
          case 4:
            return e.label++, { value: a[1], done: !1 };
          case 5:
            e.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = e.ops.pop(), e.trys.pop();
            continue;
          default:
            if (n = e.trys, !(n = n.length > 0 && n[n.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              e = 0;
              continue;
            }
            if (a[0] === 3 && (!n || a[1] > n[0] && a[1] < n[3])) {
              e.label = a[1];
              break;
            }
            if (a[0] === 6 && e.label < n[1]) {
              e.label = n[1], n = a;
              break;
            }
            if (n && e.label < n[2]) {
              e.label = n[2], e.ops.push(a);
              break;
            }
            n[2] && e.ops.pop(), e.trys.pop();
            continue;
        }
        a = r.call(t, e);
      } catch (f) {
        a = [6, f], s = 0;
      } finally {
        i = n = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
}, qi = function(t) {
  return lc(void 0, void 0, void 0, function() {
    var r, e, i, s, n, o, u, c, a;
    return hc(this, function(f) {
      switch (f.label) {
        case 0:
          return [4, t.send(176, 1, 0, 0)];
        case 1:
          return r = f.sent(), e = 0, i = r[e++], ii(i === 1, "getAppAndVersion: format not supported"), s = r[e++], n = r.slice(e, e += s).toString("ascii"), o = r[e++], u = r.slice(e, e += o).toString("ascii"), c = r[e++], a = r.slice(e, e += c), [2, {
            name: n,
            version: u,
            flags: a
          }];
      }
    });
  });
};
function pc(t) {
  var r = t.version, e = t.name;
  return e === "Decred" ? !1 : e === "Exchange" ? !0 : Bi.gte(r, "1.4.0");
}
var Me = globalThis && globalThis.__assign || function() {
  return Me = Object.assign || function(t) {
    for (var r, e = 1, i = arguments.length; e < i; e++) {
      r = arguments[e];
      for (var s in r)
        Object.prototype.hasOwnProperty.call(r, s) && (t[s] = r[s]);
    }
    return t;
  }, Me.apply(this, arguments);
}, dc = globalThis && globalThis.__awaiter || function(t, r, e, i) {
  function s(n) {
    return n instanceof e ? n : new e(function(o) {
      o(n);
    });
  }
  return new (e || (e = Promise))(function(n, o) {
    function u(f) {
      try {
        a(i.next(f));
      } catch (l) {
        o(l);
      }
    }
    function c(f) {
      try {
        a(i.throw(f));
      } catch (l) {
        o(l);
      }
    }
    function a(f) {
      f.done ? n(f.value) : s(f.value).then(u, c);
    }
    a((i = i.apply(t, r || [])).next());
  });
}, vc = globalThis && globalThis.__generator || function(t, r) {
  var e = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, s, n, o;
  return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function u(a) {
    return function(f) {
      return c([a, f]);
    };
  }
  function c(a) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; e; )
      try {
        if (i = 1, s && (n = a[0] & 2 ? s.return : a[0] ? s.throw || ((n = s.return) && n.call(s), 0) : s.next) && !(n = n.call(s, a[1])).done)
          return n;
        switch (s = 0, n && (a = [a[0] & 2, n.value]), a[0]) {
          case 0:
          case 1:
            n = a;
            break;
          case 4:
            return e.label++, { value: a[1], done: !1 };
          case 5:
            e.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = e.ops.pop(), e.trys.pop();
            continue;
          default:
            if (n = e.trys, !(n = n.length > 0 && n[n.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              e = 0;
              continue;
            }
            if (a[0] === 3 && (!n || a[1] > n[0] && a[1] < n[3])) {
              e.label = a[1];
              break;
            }
            if (a[0] === 6 && e.label < n[1]) {
              e.label = n[1], n = a;
              break;
            }
            if (n && e.label < n[2]) {
              e.label = n[2], e.ops.push(a);
              break;
            }
            n[2] && e.ops.pop(), e.trys.pop();
            continue;
        }
        a = r.call(t, e);
      } catch (f) {
        a = [6, f], s = 0;
      } finally {
        i = n = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
}, gc = globalThis && globalThis.__values || function(t) {
  var r = typeof Symbol == "function" && Symbol.iterator, e = r && t[r], i = 0;
  if (e)
    return e.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && i >= t.length && (t = void 0), { value: t && t[i++], done: !t };
      }
    };
  throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, wc = {
  lockTime: ki,
  sigHashType: Xr,
  segwit: !1,
  additionals: [],
  onDeviceStreaming: function(t) {
  },
  onDeviceSignatureGranted: function() {
  },
  onDeviceSignatureRequested: function() {
  }
};
function xc(t, r) {
  return dc(this, void 0, void 0, function() {
    var e, i, s, n, o, u, c, a, f, l, v, h, w, b, x, B, p, $, R, P, I, U, L, X, A, k, N, d, g, _, T, E, y, O, S, m, D, K, G, H, ae, q, ee, de, ge, je, se, C, Yr, C, C, ae, zt, ze, Zr, Qr, C, Yt, Zt, Qt, oe, vt, C, Jr, gt, Jt, en;
    return vc(this, function(F) {
      switch (F.label) {
        case 0:
          if (e = Me(Me({}, wc), r), i = e.inputs, s = e.associatedKeysets, n = e.changePath, o = e.outputScriptHex, u = e.lockTime, c = e.sigHashType, a = e.segwit, f = e.initialTimestamp, l = e.additionals, v = e.expiryHeight, h = e.onDeviceStreaming, w = e.onDeviceSignatureGranted, b = e.onDeviceSignatureRequested, x = e.useTrustedInputForSegwit, x !== void 0)
            return [3, 4];
          F.label = 1;
        case 1:
          return F.trys.push([1, 3, , 4]), [4, qi(t)];
        case 2:
          return B = F.sent(), x = pc(B), [3, 4];
        case 3:
          if (p = F.sent(), p.statusCode === 27904)
            x = !1;
          else
            throw p;
          return [3, 4];
        case 4:
          $ = function(Oe, Ne) {
            var Pe = i.length;
            if (!(Pe < 3)) {
              var tn = Pe * Oe + Ne, rn = 2 * Pe, Xi = tn / rn;
              h({
                progress: Xi,
                total: rn,
                index: tn
              });
            }
          }, R = l.includes("decred"), P = l.includes("zcash"), I = l.includes("stealthcoin"), U = Date.now(), L = l.includes("sapling"), X = a && l.includes("bech32"), A = a || !!l && (l.includes("abc") || l.includes("gold") || l.includes("bip143")) || !!v && !R, k = Buffer.alloc(4), k.writeUInt32LE(u, 0), N = Buffer.alloc(0), d = Buffer.alloc(0), g = Buffer.alloc(4), v && !R ? g.writeUInt32LE(P ? 2147483653 : L ? 2147483652 : 2147483651, 0) : I ? g.writeUInt32LE(2, 0) : g.writeUInt32LE(1, 0), _ = [], T = [], E = [], y = [], O = !0, S = !1, m = {
            inputs: [],
            version: g,
            timestamp: Buffer.alloc(0)
          }, D = A && !x ? zr : jr, K = Buffer.from(o, "hex"), $(0, 0), F.label = 5;
        case 5:
          F.trys.push([5, 11, 12, 13]), G = gc(i), H = G.next(), F.label = 6;
        case 6:
          return H.done ? [3, 10] : (ae = H.value, S ? [3, 8] : [4, D(t, ae[1], ae[0], l)]);
        case 7:
          q = F.sent(), ni("hw", "got trustedInput=" + q), ee = Buffer.alloc(4), ee.writeUInt32LE(ae.length >= 4 && typeof ae[3] == "number" ? ae[3] : St, 0), _.push({
            trustedInput: !0,
            value: Buffer.from(q, "hex"),
            sequence: ee
          }), F.label = 8;
        case 8:
          de = ae[0].outputs, ge = ae[1], de && ge <= de.length - 1 && T.push(de[ge]), v && !R ? (m.nVersionGroupId = Buffer.from(
            // nVersionGroupId is 0x26A7270A for zcash from https://z.cash/upgrade/nu5/
            P ? [10, 39, 167, 38] : L ? [133, 32, 47, 137] : [112, 130, 196, 3]
          ), m.nExpiryHeight = v, m.extraData = Buffer.from(L ? [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] : [0])) : R && (m.nExpiryHeight = v), F.label = 9;
        case 9:
          return H = G.next(), [3, 6];
        case 10:
          return [3, 13];
        case 11:
          return je = F.sent(), Jt = { error: je }, [3, 13];
        case 12:
          try {
            H && !H.done && (en = G.return) && en.call(G);
          } finally {
            if (Jt)
              throw Jt.error;
          }
          return [
            7
            /*endfinally*/
          ];
        case 13:
          if (m.inputs = i.map(function(Oe, Ne) {
            var Pe = Buffer.alloc(4);
            return Pe.writeUInt32LE(Oe.length >= 4 && typeof Oe[3] == "number" ? Oe[3] : St, 0), {
              script: P ? T[Ne].script : N,
              prevout: d,
              sequence: Pe
            };
          }), S)
            return [3, 18];
          se = [], C = 0, F.label = 14;
        case 14:
          return C < i.length ? [4, mr(t, {
            path: s[C]
          })] : [3, 17];
        case 15:
          Yr = F.sent(), $(0, C + 1), se.push(Yr), F.label = 16;
        case 16:
          return C++, [3, 14];
        case 17:
          for (C = 0; C < se.length; C++)
            y.push(uc(Buffer.from(se[C].publicKey, "hex")));
          F.label = 18;
        case 18:
          return f !== void 0 && (m.timestamp = Buffer.alloc(4), m.timestamp.writeUInt32LE(Math.floor(f + (Date.now() - U) / 1e3), 0)), b(), A ? [4, Bt(t, !0, m, _, !0, !!v, l, x)] : [3, 23];
        case 19:
          return F.sent(), !S && n ? [4, Xn(t, n)] : [3, 21];
        case 20:
          F.sent(), F.label = 21;
        case 21:
          return [4, $t(t, K)];
        case 22:
          F.sent(), F.label = 23;
        case 23:
          return v && !R ? [4, Tr(t, "", u, Xr, v)] : [3, 25];
        case 24:
          F.sent(), F.label = 25;
        case 25:
          C = 0, F.label = 26;
        case 26:
          return C < i.length ? (ae = i[C], zt = i[C].length >= 3 && typeof ae[2] == "string" ? Buffer.from(ae[2], "hex") : a ? Buffer.concat([
            Buffer.from([Mi, Hr, Ht]),
            Ke(y[C]),
            Buffer.from([Gi, Fi])
          ]) : T[C].script, ze = Object.assign({}, m), Zr = A ? [_[C]] : _, A ? ze.inputs = [Me(Me({}, ze.inputs[C]), { script: zt })] : ze.inputs[C].script = zt, [4, Bt(t, !A && O, ze, Zr, A, !!v && !R, l, x)]) : [3, 34];
        case 27:
          return F.sent(), A ? [3, 31] : !S && n ? [4, Xn(t, n)] : [3, 29];
        case 28:
          F.sent(), F.label = 29;
        case 29:
          return [4, $t(t, K, l)];
        case 30:
          F.sent(), F.label = 31;
        case 31:
          return O && (w(), $(1, 0)), [4, Tr(t, s[C], u, c, v, l)];
        case 32:
          Qr = F.sent(), $(1, C + 1), E.push(Qr), m.inputs[C].script = N, O && (O = !1), F.label = 33;
        case 33:
          return C++, [3, 26];
        case 34:
          for (C = 0; C < i.length; C++)
            a ? (m.witness = Buffer.alloc(0), X || (m.inputs[C].script = Buffer.concat([
              Buffer.from("160014", "hex"),
              Ke(y[C])
            ]))) : (Yt = Buffer.alloc(1), Zt = Buffer.alloc(1), Yt[0] = E[C].length, Zt[0] = y[C].length, m.inputs[C].script = Buffer.concat([
              Yt,
              E[C],
              Zt,
              y[C]
            ])), Qt = A && !x ? 0 : 4, m.inputs[C].prevout = _[C].value.slice(Qt, Qt + 36);
          if (m.locktime = k, oe = Buffer.concat([
            Wr(m, !1, m.timestamp, l),
            K
          ]), a && !R) {
            for (vt = Buffer.alloc(0), C = 0; C < i.length; C++)
              Jr = Buffer.concat([
                Buffer.from("02", "hex"),
                Buffer.from([E[C].length]),
                E[C],
                Buffer.from([y[C].length]),
                y[C]
              ]), vt = Buffer.concat([vt, Jr]);
            oe = Buffer.concat([oe, vt]);
          }
          return P || (oe = Buffer.concat([oe, k]), v && (oe = Buffer.concat([
            oe,
            m.nExpiryHeight || Buffer.alloc(0),
            m.extraData || Buffer.alloc(0)
          ]))), R && (gt = Buffer.from([m.inputs.length]), i.forEach(function(Oe, Ne) {
            gt = Buffer.concat([
              gt,
              Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]),
              Buffer.from([0, 0, 0, 0]),
              Buffer.from([255, 255, 255, 255]),
              Buffer.from([m.inputs[Ne].script.length]),
              m.inputs[Ne].script
            ]);
          }), oe = Buffer.concat([oe, gt])), P && (oe = Buffer.concat([oe, Buffer.from([0, 0, 0])])), [2, oe.toString("hex")];
      }
    });
  });
}
var Ec = globalThis && globalThis.__awaiter || function(t, r, e, i) {
  function s(n) {
    return n instanceof e ? n : new e(function(o) {
      o(n);
    });
  }
  return new (e || (e = Promise))(function(n, o) {
    function u(f) {
      try {
        a(i.next(f));
      } catch (l) {
        o(l);
      }
    }
    function c(f) {
      try {
        a(i.throw(f));
      } catch (l) {
        o(l);
      }
    }
    function a(f) {
      f.done ? n(f.value) : s(f.value).then(u, c);
    }
    a((i = i.apply(t, r || [])).next());
  });
}, Hn = globalThis && globalThis.__generator || function(t, r) {
  var e = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, s, n, o;
  return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function u(a) {
    return function(f) {
      return c([a, f]);
    };
  }
  function c(a) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; e; )
      try {
        if (i = 1, s && (n = a[0] & 2 ? s.return : a[0] ? s.throw || ((n = s.return) && n.call(s), 0) : s.next) && !(n = n.call(s, a[1])).done)
          return n;
        switch (s = 0, n && (a = [a[0] & 2, n.value]), a[0]) {
          case 0:
          case 1:
            n = a;
            break;
          case 4:
            return e.label++, { value: a[1], done: !1 };
          case 5:
            e.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = e.ops.pop(), e.trys.pop();
            continue;
          default:
            if (n = e.trys, !(n = n.length > 0 && n[n.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              e = 0;
              continue;
            }
            if (a[0] === 3 && (!n || a[1] > n[0] && a[1] < n[3])) {
              e.label = a[1];
              break;
            }
            if (a[0] === 6 && e.label < n[1]) {
              e.label = n[1], n = a;
              break;
            }
            if (n && e.label < n[2]) {
              e.label = n[2], e.ops.push(a);
              break;
            }
            n[2] && e.ops.pop(), e.trys.pop();
            continue;
        }
        a = r.call(t, e);
      } catch (f) {
        a = [6, f], s = 0;
      } finally {
        i = n = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
};
function yc(t, r) {
  var e = r.path, i = r.messageHex;
  return Ec(this, void 0, void 0, function() {
    var s, n, o, u, c, a, f, l;
    return Hn(this, function(v) {
      switch (v.label) {
        case 0:
          s = Ar.fromString(e).toPathArray(), n = Buffer.from(i, "hex"), o = 0, u = function() {
            var h, w, b;
            return Hn(this, function(x) {
              switch (x.label) {
                case 0:
                  return h = o === 0 ? _e - 1 - s.length * 4 - 4 : _e, w = o + h > n.length ? n.length - o : h, b = Buffer.alloc(o === 0 ? 1 + s.length * 4 + 2 + w : w), o === 0 ? (b[0] = s.length, s.forEach(function(B, p) {
                    b.writeUInt32BE(B, 1 + 4 * p);
                  }), b.writeUInt16BE(n.length, 1 + 4 * s.length), n.copy(b, 1 + 4 * s.length + 2, o, o + w)) : n.copy(b, 0, o, o + w), [4, t.send(224, 78, 0, o === 0 ? 1 : 128, b)];
                case 1:
                  return x.sent(), o += w, [
                    2
                    /*return*/
                  ];
              }
            });
          }, v.label = 1;
        case 1:
          return o === n.length ? [3, 3] : [5, u()];
        case 2:
          return v.sent(), [3, 1];
        case 3:
          return [4, t.send(224, 78, 128, 0, Buffer.from([0]))];
        case 4:
          return c = v.sent(), a = c[0] - 48, f = c.slice(4, 4 + c[3]), f[0] === 0 && (f = f.slice(1)), f = f.toString("hex"), o = 4 + c[3] + 2, l = c.slice(o, o + c[o - 1]), l[0] === 0 && (l = l.slice(1)), l = l.toString("hex"), [2, {
            v: a,
            r: f,
            s: l
          }];
      }
    });
  });
}
var Ge = globalThis && globalThis.__assign || function() {
  return Ge = Object.assign || function(t) {
    for (var r, e = 1, i = arguments.length; e < i; e++) {
      r = arguments[e];
      for (var s in r)
        Object.prototype.hasOwnProperty.call(r, s) && (t[s] = r[s]);
    }
    return t;
  }, Ge.apply(this, arguments);
}, _c = globalThis && globalThis.__awaiter || function(t, r, e, i) {
  function s(n) {
    return n instanceof e ? n : new e(function(o) {
      o(n);
    });
  }
  return new (e || (e = Promise))(function(n, o) {
    function u(f) {
      try {
        a(i.next(f));
      } catch (l) {
        o(l);
      }
    }
    function c(f) {
      try {
        a(i.throw(f));
      } catch (l) {
        o(l);
      }
    }
    function a(f) {
      f.done ? n(f.value) : s(f.value).then(u, c);
    }
    a((i = i.apply(t, r || [])).next());
  });
}, mc = globalThis && globalThis.__generator || function(t, r) {
  var e = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, s, n, o;
  return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function u(a) {
    return function(f) {
      return c([a, f]);
    };
  }
  function c(a) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; e; )
      try {
        if (i = 1, s && (n = a[0] & 2 ? s.return : a[0] ? s.throw || ((n = s.return) && n.call(s), 0) : s.next) && !(n = n.call(s, a[1])).done)
          return n;
        switch (s = 0, n && (a = [a[0] & 2, n.value]), a[0]) {
          case 0:
          case 1:
            n = a;
            break;
          case 4:
            return e.label++, { value: a[1], done: !1 };
          case 5:
            e.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = e.ops.pop(), e.trys.pop();
            continue;
          default:
            if (n = e.trys, !(n = n.length > 0 && n[n.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              e = 0;
              continue;
            }
            if (a[0] === 3 && (!n || a[1] > n[0] && a[1] < n[3])) {
              e.label = a[1];
              break;
            }
            if (a[0] === 6 && e.label < n[1]) {
              e.label = n[1], n = a;
              break;
            }
            if (n && e.label < n[2]) {
              e.label = n[2], e.ops.push(a);
              break;
            }
            n[2] && e.ops.pop(), e.trys.pop();
            continue;
        }
        a = r.call(t, e);
      } catch (f) {
        a = [6, f], s = 0;
      } finally {
        i = n = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
}, bc = globalThis && globalThis.__values || function(t) {
  var r = typeof Symbol == "function" && Symbol.iterator, e = r && t[r], i = 0;
  if (e)
    return e.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && i >= t.length && (t = void 0), { value: t && t[i++], done: !t };
      }
    };
  throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, Ic = {
  lockTime: ki,
  sigHashType: Xr,
  segwit: !1,
  transactionVersion: Cf
};
function Tc(t, r) {
  return _c(this, void 0, void 0, function() {
    var e, i, s, n, o, u, c, a, f, l, v, h, w, b, x, B, p, $, R, P, I, d, U, k, L, X, A, N, k, N, d, g, _, T, E, y, O;
    return mc(this, function(S) {
      switch (S.label) {
        case 0:
          e = Ge(Ge({}, Ic), r), i = e.inputs, s = e.associatedKeysets, n = e.outputScriptHex, o = e.lockTime, u = e.sigHashType, c = e.segwit, a = e.transactionVersion, f = Buffer.alloc(0), l = Buffer.alloc(0), v = Buffer.alloc(4), v.writeUInt32LE(a, 0), h = [], w = [], b = [], x = !0, B = !1, p = {
            inputs: [],
            version: v
          }, $ = c ? zr : jr, R = Buffer.from(n, "hex"), S.label = 1;
        case 1:
          S.trys.push([1, 7, 8, 9]), P = bc(i), I = P.next(), S.label = 2;
        case 2:
          return I.done ? [3, 6] : (d = I.value, B ? [3, 4] : [4, $(t, d[1], d[0])]);
        case 3:
          U = S.sent(), k = Buffer.alloc(4), k.writeUInt32LE(d.length >= 4 && typeof d[3] == "number" ? d[3] : St, 0), h.push({
            trustedInput: !1,
            value: c ? Buffer.from(U, "hex") : Buffer.from(U, "hex").slice(4, 4 + 36),
            sequence: k
          }), S.label = 4;
        case 4:
          L = d[0].outputs, X = d[1], L && X <= L.length - 1 && w.push(L[X]), S.label = 5;
        case 5:
          return I = P.next(), [3, 2];
        case 6:
          return [3, 9];
        case 7:
          return A = S.sent(), y = { error: A }, [3, 9];
        case 8:
          try {
            I && !I.done && (O = P.return) && O.call(P);
          } finally {
            if (y)
              throw y.error;
          }
          return [
            7
            /*endfinally*/
          ];
        case 9:
          for (N = 0; N < i.length; N++)
            k = Buffer.alloc(4), k.writeUInt32LE(i[N].length >= 4 && typeof i[N][3] == "number" ? i[N][3] : St, 0), p.inputs.push({
              script: f,
              prevout: l,
              sequence: k
            });
          return c ? [4, Bt(t, !0, p, h, !0)] : [3, 12];
        case 10:
          return S.sent(), [4, $t(t, R)];
        case 11:
          S.sent(), S.label = 12;
        case 12:
          N = 0, S.label = 13;
        case 13:
          return N < i.length ? (d = i[N], g = i[N].length >= 3 && typeof d[2] == "string" ? Buffer.from(d[2], "hex") : w[N].script, _ = Object.assign({}, p), T = c ? [h[N]] : h, c ? _.inputs = [Ge(Ge({}, _.inputs[N]), { script: g })] : _.inputs[N].script = g, [4, Bt(t, !c && x, _, T, c)]) : [3, 19];
        case 14:
          return S.sent(), c ? [3, 16] : [4, $t(t, R)];
        case 15:
          S.sent(), S.label = 16;
        case 16:
          return [4, Tr(t, s[N], o, u)];
        case 17:
          E = S.sent(), b.push(c ? E.toString("hex") : E.slice(0, E.length - 1).toString("hex")), p.inputs[N].script = f, x && (x = !1), S.label = 18;
        case 18:
          return N++, [3, 13];
        case 19:
          return [2, b];
      }
    });
  });
}
var Rt = globalThis && globalThis.__assign || function() {
  return Rt = Object.assign || function(t) {
    for (var r, e = 1, i = arguments.length; e < i; e++) {
      r = arguments[e];
      for (var s in r)
        Object.prototype.hasOwnProperty.call(r, s) && (t[s] = r[s]);
    }
    return t;
  }, Rt.apply(this, arguments);
}, Wn = globalThis && globalThis.__awaiter || function(t, r, e, i) {
  function s(n) {
    return n instanceof e ? n : new e(function(o) {
      o(n);
    });
  }
  return new (e || (e = Promise))(function(n, o) {
    function u(f) {
      try {
        a(i.next(f));
      } catch (l) {
        o(l);
      }
    }
    function c(f) {
      try {
        a(i.throw(f));
      } catch (l) {
        o(l);
      }
    }
    function a(f) {
      f.done ? n(f.value) : s(f.value).then(u, c);
    }
    a((i = i.apply(t, r || [])).next());
  });
}, jn = globalThis && globalThis.__generator || function(t, r) {
  var e = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, s, n, o;
  return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function u(a) {
    return function(f) {
      return c([a, f]);
    };
  }
  function c(a) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; e; )
      try {
        if (i = 1, s && (n = a[0] & 2 ? s.return : a[0] ? s.throw || ((n = s.return) && n.call(s), 0) : s.next) && !(n = n.call(s, a[1])).done)
          return n;
        switch (s = 0, n && (a = [a[0] & 2, n.value]), a[0]) {
          case 0:
          case 1:
            n = a;
            break;
          case 4:
            return e.label++, { value: a[1], done: !1 };
          case 5:
            e.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = e.ops.pop(), e.trys.pop();
            continue;
          default:
            if (n = e.trys, !(n = n.length > 0 && n[n.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              e = 0;
              continue;
            }
            if (a[0] === 3 && (!n || a[1] > n[0] && a[1] < n[3])) {
              e.label = a[1];
              break;
            }
            if (a[0] === 6 && e.label < n[1]) {
              e.label = n[1], n = a;
              break;
            }
            if (n && e.label < n[2]) {
              e.label = n[2], e.ops.push(a);
              break;
            }
            n[2] && e.ops.pop(), e.trys.pop();
            continue;
        }
        a = r.call(t, e);
      } catch (f) {
        a = [6, f], s = 0;
      } finally {
        i = n = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
}, Sc = (
  /** @class */
  function() {
    function t(r) {
      this.transport = r, this.derivationsCache = {};
    }
    return t.prototype.derivatePath = function(r) {
      return Wn(this, void 0, void 0, function() {
        var e;
        return jn(this, function(i) {
          switch (i.label) {
            case 0:
              return this.derivationsCache[r] ? [2, this.derivationsCache[r]] : [4, mr(this.transport, {
                path: r
              })];
            case 1:
              return e = i.sent(), this.derivationsCache[r] = e, [2, e];
          }
        });
      });
    }, t.prototype.getWalletXpub = function(r) {
      var e = r.path, i = r.xpubVersion;
      return Wn(this, void 0, void 0, function() {
        var s, n, o, u, c, a;
        return jn(this, function(f) {
          switch (f.label) {
            case 0:
              return s = xe(e), n = s.slice(0, -1), [4, this.derivatePath(Lr(n))];
            case 1:
              return o = f.sent(), [4, this.derivatePath(e)];
            case 2:
              return u = f.sent(), c = Bc(Yn(Buffer.from(o.publicKey, "hex"))), a = $c(i, s.length, c, s[s.length - 1], Buffer.from(u.chainCode, "hex"), Yn(Buffer.from(u.publicKey, "hex"))), [2, a];
          }
        });
      });
    }, t.prototype.getWalletPublicKey = function(r, e) {
      if ((e == null ? void 0 : e.format) === "bech32m")
        throw new Error("Unsupported address format bech32m");
      return mr(this.transport, Rt(Rt({}, e), { path: r }));
    }, t.prototype.signMessageNew = function(r, e) {
      return yc(this.transport, {
        path: r,
        messageHex: e
      });
    }, t.prototype.createPaymentTransactionNew = function(r) {
      return arguments.length > 1 && console.warn("@ledgerhq/hw-app-btc: createPaymentTransactionNew multi argument signature is deprecated. please switch to named parameters."), xc(this.transport, r);
    }, t.prototype.signP2SHTransaction = function(r) {
      return arguments.length > 1 && console.warn("@ledgerhq/hw-app-btc: signP2SHTransaction multi argument signature is deprecated. please switch to named parameters."), Tc(this.transport, r);
    }, t;
  }()
);
function Bc(t) {
  return Oc(t).slice(0, 4);
}
function zn(t) {
  var r = Buffer.allocUnsafe(4);
  return r.writeUInt32BE(t, 0), r;
}
var Yn = function(t) {
  return Buffer.concat([
    Buffer.from([2 + (t[64] & 1)]),
    t.slice(1, 33)
  ]);
};
function $c(t, r, e, i, s, n) {
  var o = zn(i);
  o[0] |= 128;
  var u = Buffer.concat([
    zn(t),
    Buffer.from([r]),
    e,
    o,
    s,
    n
  ]), c = Rc(u).slice(0, 4);
  return ia.encode(Buffer.concat([u, c]));
}
function Sr(t) {
  return mt("sha256").update(t).digest();
}
function Rc(t) {
  return Sr(Sr(t));
}
function Ac(t) {
  return new ri().update(t).digest();
}
function Oc(t) {
  return Ac(Sr(t));
}
var Nc = (
  /** @class */
  function() {
    function t(r, e) {
      if (r.length != e.length)
        throw new Error("keys and values should have the same length");
      for (var i = 0; i < r.length - 1; i++)
        if (r[i].toString("hex") >= r[i + 1].toString("hex"))
          throw new Error("keys must be in strictly increasing order");
      this.keys = r, this.keysTree = new qe(r.map(function(s) {
        return Xe(s);
      })), this.values = e, this.valuesTree = new qe(e.map(function(s) {
        return Xe(s);
      }));
    }
    return t.prototype.commitment = function() {
      return Buffer.concat([
        j(this.keys.length),
        this.keysTree.getRoot(),
        this.valuesTree.getRoot()
      ]);
    }, t;
  }()
), Pc = globalThis && globalThis.__extends || function() {
  var t = function(r, e) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, s) {
      i.__proto__ = s;
    } || function(i, s) {
      for (var n in s)
        Object.prototype.hasOwnProperty.call(s, n) && (i[n] = s[n]);
    }, t(r, e);
  };
  return function(r, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    t(r, e);
    function i() {
      this.constructor = r;
    }
    r.prototype = e === null ? Object.create(e) : (i.prototype = e.prototype, new i());
  };
}(), lr = globalThis && globalThis.__read || function(t, r) {
  var e = typeof Symbol == "function" && t[Symbol.iterator];
  if (!e)
    return t;
  var i = e.call(t), s, n = [], o;
  try {
    for (; (r === void 0 || r-- > 0) && !(s = i.next()).done; )
      n.push(s.value);
  } catch (u) {
    o = { error: u };
  } finally {
    try {
      s && !s.done && (e = i.return) && e.call(i);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return n;
}, hr = globalThis && globalThis.__spreadArray || function(t, r, e) {
  if (e || arguments.length === 2)
    for (var i = 0, s = r.length, n; i < s; i++)
      (n || !(i in r)) && (n || (n = Array.prototype.slice.call(r, 0, i)), n[i] = r[i]);
  return t.concat(n || Array.prototype.slice.call(r));
}, Lc = (
  /** @class */
  function(t) {
    Pc(r, t);
    function r(e) {
      var i = t.call(this) || this;
      i.inputMerkleMaps = [], i.outputMerkleMaps = [], e.copy(i), i.globalMerkleMap = r.createMerkleMap(i.globalMap);
      for (var s = 0; s < i.getGlobalInputCount(); s++)
        i.inputMerkleMaps.push(r.createMerkleMap(i.inputMaps[s]));
      i.inputMapCommitments = hr([], lr(i.inputMerkleMaps.values()), !1).map(function(n) {
        return n.commitment();
      });
      for (var s = 0; s < i.getGlobalOutputCount(); s++)
        i.outputMerkleMaps.push(r.createMerkleMap(i.outputMaps[s]));
      return i.outputMapCommitments = hr([], lr(i.outputMerkleMaps.values()), !1).map(function(n) {
        return n.commitment();
      }), i;
    }
    return r.prototype.getGlobalSize = function() {
      return this.globalMap.size;
    }, r.prototype.getGlobalKeysValuesRoot = function() {
      return this.globalMerkleMap.commitment();
    }, r.createMerkleMap = function(e) {
      var i = hr([], lr(e.keys()), !1).sort(), s = i.map(function(u) {
        var c = e.get(u);
        if (!c)
          throw new Error("No value for key " + u);
        return c;
      }), n = i.map(function(u) {
        return Buffer.from(u, "hex");
      }), o = new Nc(n, s);
      return o;
    }, r;
  }(Vi)
), pt = globalThis && globalThis.__extends || function() {
  var t = function(r, e) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, s) {
      i.__proto__ = s;
    } || function(i, s) {
      for (var n in s)
        Object.prototype.hasOwnProperty.call(s, n) && (i[n] = s[n]);
    }, t(r, e);
  };
  return function(r, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
    t(r, e);
    function i() {
      this.constructor = r;
    }
    r.prototype = e === null ? Object.create(e) : (i.prototype = e.prototype, new i());
  };
}(), Br = globalThis && globalThis.__read || function(t, r) {
  var e = typeof Symbol == "function" && t[Symbol.iterator];
  if (!e)
    return t;
  var i = e.call(t), s, n = [], o;
  try {
    for (; (r === void 0 || r-- > 0) && !(s = i.next()).done; )
      n.push(s.value);
  } catch (u) {
    o = { error: u };
  } finally {
    try {
      s && !s.done && (e = i.return) && e.call(i);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return n;
}, $r = globalThis && globalThis.__spreadArray || function(t, r, e) {
  if (e || arguments.length === 2)
    for (var i = 0, s = r.length, n; i < s; i++)
      (n || !(i in r)) && (n || (n = Array.prototype.slice.call(r, 0, i)), n[i] = r[i]);
  return t.concat(n || Array.prototype.slice.call(r));
}, Zn = globalThis && globalThis.__values || function(t) {
  var r = typeof Symbol == "function" && Symbol.iterator, e = r && t[r], i = 0;
  if (e)
    return e.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && i >= t.length && (t = void 0), { value: t && t[i++], done: !t };
      }
    };
  throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, Re;
(function(t) {
  t[t.YIELD = 16] = "YIELD", t[t.GET_PREIMAGE = 64] = "GET_PREIMAGE", t[t.GET_MERKLE_LEAF_PROOF = 65] = "GET_MERKLE_LEAF_PROOF", t[t.GET_MERKLE_LEAF_INDEX = 66] = "GET_MERKLE_LEAF_INDEX", t[t.GET_MORE_ELEMENTS = 160] = "GET_MORE_ELEMENTS";
})(Re || (Re = {}));
var dt = (
  /** @class */
  function() {
    function t() {
    }
    return t;
  }()
), Cc = (
  /** @class */
  function(t) {
    pt(r, t);
    function r(e, i) {
      var s = t.call(this) || this;
      return s.progressCallback = i, s.code = Re.YIELD, s.results = e, s;
    }
    return r.prototype.execute = function(e) {
      return this.results.push(Buffer.from(e.subarray(1))), this.progressCallback(), Buffer.from("");
    }, r;
  }(dt)
), Dc = (
  /** @class */
  function(t) {
    pt(r, t);
    function r(e, i) {
      var s = t.call(this) || this;
      return s.code = Re.GET_PREIMAGE, s.known_preimages = e, s.queue = i, s;
    }
    return r.prototype.execute = function(e) {
      var i = Buffer.from(e.subarray(1));
      if (i.length != 1 + 32)
        throw new Error("Invalid request, unexpected trailing data");
      if (i[0] != 0)
        throw new Error("Unsupported request, the first byte should be 0");
      for (var s = Buffer.alloc(32), n = 0; n < 32; n++)
        s[n] = i[1 + n];
      var o = s.toString("hex"), u = this.known_preimages.get(o);
      if (u != null) {
        var c = j(u.length), a = 255 - c.length - 1, f = Math.min(a, u.length);
        if (f < u.length)
          for (var n = f; n < u.length; n++)
            this.queue.push(Buffer.from([u[n]]));
        return Buffer.concat([
          c,
          Buffer.from([f]),
          Buffer.from(u.subarray(0, f))
        ]);
      }
      throw Error("Requested unknown preimage for: ".concat(o));
    }, r;
  }(dt)
), Uc = (
  /** @class */
  function(t) {
    pt(r, t);
    function r(e, i) {
      var s = t.call(this) || this;
      return s.code = Re.GET_MERKLE_LEAF_PROOF, s.known_trees = e, s.queue = i, s;
    }
    return r.prototype.execute = function(e) {
      var i, s = Buffer.from(e.subarray(1));
      if (s.length < 32 + 1 + 1)
        throw new Error("Invalid request, expected at least 34 bytes");
      var n = new Te(s), o = n.readSlice(32), u = o.toString("hex"), c, a;
      try {
        c = n.readVarInt(), a = n.readVarInt();
      } catch {
        throw new Error("Invalid request, couldn't parse tree_size or leaf_index");
      }
      var f = this.known_trees.get(u);
      if (!f)
        throw Error("Requested Merkle leaf proof for unknown tree: ".concat(u));
      if (a >= c || f.size() != c)
        throw Error("Invalid index or tree size.");
      if (this.queue.length != 0)
        throw Error("This command should not execute when the queue is not empty.");
      var l = f.getProof(a), v = Math.min(Math.floor((255 - 32 - 1 - 1) / 32), l.length), h = l.length - v;
      return h > 0 && (i = this.queue).push.apply(i, $r([], Br(l.slice(-h)), !1)), Buffer.concat($r([
        f.getLeafHash(a),
        Buffer.from([l.length]),
        Buffer.from([v])
      ], Br(l.slice(0, v)), !1));
    }, r;
  }(dt)
), kc = (
  /** @class */
  function(t) {
    pt(r, t);
    function r(e) {
      var i = t.call(this) || this;
      return i.code = Re.GET_MERKLE_LEAF_INDEX, i.known_trees = e, i;
    }
    return r.prototype.execute = function(e) {
      var i = Buffer.from(e.subarray(1));
      if (i.length != 32 + 32)
        throw new Error("Invalid request, unexpected trailing data");
      for (var s = Buffer.alloc(32), n = 0; n < 32; n++)
        s[n] = i.readUInt8(n);
      for (var o = s.toString("hex"), u = Buffer.alloc(32), n = 0; n < 32; n++)
        u[n] = i.readUInt8(32 + n);
      var c = u.toString("hex"), a = this.known_trees.get(o);
      if (!a)
        throw Error("Requested Merkle leaf index for unknown root: ".concat(o));
      for (var f = 0, l = 0, n = 0; n < a.size(); n++)
        if (a.getLeafHash(n).toString("hex") == c) {
          l = 1, f = n;
          break;
        }
      return Buffer.concat([Buffer.from([l]), j(f)]);
    }, r;
  }(dt)
), Mc = (
  /** @class */
  function(t) {
    pt(r, t);
    function r(e) {
      var i = t.call(this) || this;
      return i.code = Re.GET_MORE_ELEMENTS, i.queue = e, i;
    }
    return r.prototype.execute = function(e) {
      if (e.length != 1)
        throw new Error("Invalid request, unexpected trailing data");
      if (this.queue.length === 0)
        throw new Error("No elements to get");
      var i = this.queue[0].length;
      if (this.queue.some(function(u) {
        return u.length != i;
      }))
        throw new Error("The queue contains elements with different byte length, which is not expected");
      var s = Math.floor(253 / i), n = Math.min(s, this.queue.length), o = this.queue.splice(0, n);
      return Buffer.concat($r([
        Buffer.from([n]),
        Buffer.from([i])
      ], Br(o), !1));
    }, r;
  }(dt)
), Qn = (
  /** @class */
  function() {
    function t(r) {
      var e, i;
      this.roots = /* @__PURE__ */ new Map(), this.preimages = /* @__PURE__ */ new Map(), this.yielded = [], this.queue = [], this.commands = /* @__PURE__ */ new Map();
      var s = [
        new Cc(this.yielded, r),
        new Dc(this.preimages, this.queue),
        new kc(this.roots),
        new Uc(this.roots, this.queue),
        new Mc(this.queue)
      ];
      try {
        for (var n = Zn(s), o = n.next(); !o.done; o = n.next()) {
          var u = o.value;
          if (this.commands.has(u.code))
            throw new Error("Multiple commands with code ".concat(u.code));
          this.commands.set(u.code, u);
        }
      } catch (c) {
        e = { error: c };
      } finally {
        try {
          o && !o.done && (i = n.return) && i.call(n);
        } finally {
          if (e)
            throw e.error;
        }
      }
    }
    return t.prototype.getYielded = function() {
      return this.yielded;
    }, t.prototype.addKnownPreimage = function(r) {
      this.preimages.set(Se.sha256(r).toString("hex"), r);
    }, t.prototype.addKnownList = function(r) {
      var e, i;
      try {
        for (var s = Zn(r), n = s.next(); !n.done; n = s.next()) {
          var o = n.value, u = Buffer.concat([Buffer.from([0]), o]);
          this.addKnownPreimage(u);
        }
      } catch (a) {
        e = { error: a };
      } finally {
        try {
          n && !n.done && (i = s.return) && i.call(s);
        } finally {
          if (e)
            throw e.error;
        }
      }
      var c = new qe(r.map(function(a) {
        return Xe(a);
      }));
      this.roots.set(c.getRoot().toString("hex"), c);
    }, t.prototype.addKnownMapping = function(r) {
      this.addKnownList(r.keys), this.addKnownList(r.values);
    }, t.prototype.execute = function(r) {
      if (r.length == 0)
        throw new Error("Unexpected empty command");
      var e = r[0], i = this.commands.get(e);
      if (!i)
        throw new Error("Unexpected command code ".concat(e));
      return i.execute(r);
    }, t;
  }()
), Qe = globalThis && globalThis.__awaiter || function(t, r, e, i) {
  function s(n) {
    return n instanceof e ? n : new e(function(o) {
      o(n);
    });
  }
  return new (e || (e = Promise))(function(n, o) {
    function u(f) {
      try {
        a(i.next(f));
      } catch (l) {
        o(l);
      }
    }
    function c(f) {
      try {
        a(i.throw(f));
      } catch (l) {
        o(l);
      }
    }
    function a(f) {
      f.done ? n(f.value) : s(f.value).then(u, c);
    }
    a((i = i.apply(t, r || [])).next());
  });
}, Je = globalThis && globalThis.__generator || function(t, r) {
  var e = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, s, n, o;
  return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function u(a) {
    return function(f) {
      return c([a, f]);
    };
  }
  function c(a) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; e; )
      try {
        if (i = 1, s && (n = a[0] & 2 ? s.return : a[0] ? s.throw || ((n = s.return) && n.call(s), 0) : s.next) && !(n = n.call(s, a[1])).done)
          return n;
        switch (s = 0, n && (a = [a[0] & 2, n.value]), a[0]) {
          case 0:
          case 1:
            n = a;
            break;
          case 4:
            return e.label++, { value: a[1], done: !1 };
          case 5:
            e.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = e.ops.pop(), e.trys.pop();
            continue;
          default:
            if (n = e.trys, !(n = n.length > 0 && n[n.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              e = 0;
              continue;
            }
            if (a[0] === 3 && (!n || a[1] > n[0] && a[1] < n[3])) {
              e.label = a[1];
              break;
            }
            if (a[0] === 6 && e.label < n[1]) {
              e.label = n[1], n = a;
              break;
            }
            if (n && e.label < n[2]) {
              e.label = n[2], e.ops.push(a);
              break;
            }
            n[2] && e.ops.pop(), e.trys.pop();
            continue;
        }
        a = r.call(t, e);
      } catch (f) {
        a = [6, f], s = 0;
      } finally {
        i = n = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
}, pr = globalThis && globalThis.__values || function(t) {
  var r = typeof Symbol == "function" && Symbol.iterator, e = r && t[r], i = 0;
  if (e)
    return e.call(t);
  if (t && typeof t.length == "number")
    return {
      next: function() {
        return t && i >= t.length && (t = void 0), { value: t && t[i++], done: !t };
      }
    };
  throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, Gc = 225, Fc = 248, Fe;
(function(t) {
  t[t.GET_PUBKEY = 0] = "GET_PUBKEY", t[t.REGISTER_WALLET = 2] = "REGISTER_WALLET", t[t.GET_WALLET_ADDRESS = 3] = "GET_WALLET_ADDRESS", t[t.SIGN_PSBT = 4] = "SIGN_PSBT", t[t.GET_MASTER_FINGERPRINT = 5] = "GET_MASTER_FINGERPRINT";
})(Fe || (Fe = {}));
var Rr;
(function(t) {
  t[t.CONTINUE_INTERRUPTED = 1] = "CONTINUE_INTERRUPTED";
})(Rr || (Rr = {}));
var Vc = (
  /** @class */
  function() {
    function t(r) {
      this.transport = r;
    }
    return t.prototype.makeRequest = function(r, e, i) {
      return Qe(this, void 0, void 0, function() {
        var s, n, o;
        return Je(this, function(u) {
          switch (u.label) {
            case 0:
              return [4, this.transport.send(Gc, r, 0, 0, e, [36864, 57344])];
            case 1:
              s = u.sent(), u.label = 2;
            case 2:
              if (s.readUInt16BE(s.length - 2) !== 57344)
                return [3, 4];
              if (!i)
                throw new Error("Unexpected SW_INTERRUPTED_EXECUTION");
              return n = s.slice(0, -2), o = i.execute(n), [4, this.transport.send(Fc, Rr.CONTINUE_INTERRUPTED, 0, 0, o, [36864, 57344])];
            case 3:
              return s = u.sent(), [3, 2];
            case 4:
              return [2, s.slice(0, -2)];
          }
        });
      });
    }, t.prototype.getExtendedPubkey = function(r, e) {
      return Qe(this, void 0, void 0, function() {
        var i;
        return Je(this, function(s) {
          switch (s.label) {
            case 0:
              if (e.length > 6)
                throw new Error("Path too long. At most 6 levels allowed.");
              return [4, this.makeRequest(Fe.GET_PUBKEY, Buffer.concat([
                Buffer.from(r ? [1] : [0]),
                yi(e)
              ]))];
            case 1:
              return i = s.sent(), [2, i.toString("ascii")];
          }
        });
      });
    }, t.prototype.getWalletAddress = function(r, e, i, s, n) {
      return Qe(this, void 0, void 0, function() {
        var o, u, c;
        return Je(this, function(a) {
          switch (a.label) {
            case 0:
              if (i !== 0 && i !== 1)
                throw new Error("Change can only be 0 or 1");
              if (s < 0 || !Number.isInteger(s))
                throw new Error("Invalid address index");
              if (e != null && e.length != 32)
                throw new Error("Invalid HMAC length");
              return o = new Qn(function() {
              }), o.addKnownList(r.keys.map(function(f) {
                return Buffer.from(f, "ascii");
              })), o.addKnownPreimage(r.serialize()), u = Buffer.alloc(4), u.writeUInt32BE(s, 0), [4, this.makeRequest(Fe.GET_WALLET_ADDRESS, Buffer.concat([
                Buffer.from(n ? [1] : [0]),
                r.getWalletId(),
                e || Buffer.alloc(32, 0),
                Buffer.from([i]),
                u
              ]), o)];
            case 1:
              return c = a.sent(), [2, c.toString("ascii")];
          }
        });
      });
    }, t.prototype.signPsbt = function(r, e, i, s) {
      return Qe(this, void 0, void 0, function() {
        var n, o, u, c, l, a, f, l, v, h, w, b, x, B, p, $, R, P, I, U, L;
        return Je(this, function(X) {
          switch (X.label) {
            case 0:
              if (n = new Lc(r), i != null && i.length != 32)
                throw new Error("Invalid HMAC length");
              o = new Qn(s), o.addKnownList(e.keys.map(function(A) {
                return Buffer.from(A, "ascii");
              })), o.addKnownPreimage(e.serialize()), o.addKnownMapping(n.globalMerkleMap);
              try {
                for (u = pr(n.inputMerkleMaps), c = u.next(); !c.done; c = u.next())
                  l = c.value, o.addKnownMapping(l);
              } catch (A) {
                $ = { error: A };
              } finally {
                try {
                  c && !c.done && (R = u.return) && R.call(u);
                } finally {
                  if ($)
                    throw $.error;
                }
              }
              try {
                for (a = pr(n.outputMerkleMaps), f = a.next(); !f.done; f = a.next())
                  l = f.value, o.addKnownMapping(l);
              } catch (A) {
                P = { error: A };
              } finally {
                try {
                  f && !f.done && (I = a.return) && I.call(a);
                } finally {
                  if (P)
                    throw P.error;
                }
              }
              return o.addKnownList(n.inputMapCommitments), v = new qe(n.inputMapCommitments.map(function(A) {
                return Xe(A);
              })).getRoot(), o.addKnownList(n.outputMapCommitments), h = new qe(n.outputMapCommitments.map(function(A) {
                return Xe(A);
              })).getRoot(), [4, this.makeRequest(Fe.SIGN_PSBT, Buffer.concat([
                n.getGlobalKeysValuesRoot(),
                j(n.getGlobalInputCount()),
                v,
                j(n.getGlobalOutputCount()),
                h,
                e.getWalletId(),
                i || Buffer.alloc(32, 0)
              ]), o)];
            case 1:
              X.sent(), w = o.getYielded(), b = /* @__PURE__ */ new Map();
              try {
                for (x = pr(w), B = x.next(); !B.done; B = x.next())
                  p = B.value, b.set(p[0], p.slice(1));
              } catch (A) {
                U = { error: A };
              } finally {
                try {
                  B && !B.done && (L = x.return) && L.call(x);
                } finally {
                  if (U)
                    throw U.error;
                }
              }
              return [2, b];
          }
        });
      });
    }, t.prototype.getMasterFingerprint = function() {
      return Qe(this, void 0, void 0, function() {
        return Je(this, function(r) {
          return [2, this.makeRequest(Fe.GET_MASTER_FINGERPRINT, Buffer.from([]))];
        });
      });
    }, t;
  }()
);
function Kc(t) {
  var r = "TX";
  return r += " version " + t.version.toString("hex"), t.locktime && (r += " locktime " + t.locktime.toString("hex")), t.witness && (r += " witness " + t.witness.toString("hex")), t.timestamp && (r += " timestamp " + t.timestamp.toString("hex")), t.nVersionGroupId && (r += " nVersionGroupId " + t.nVersionGroupId.toString("hex")), t.nExpiryHeight && (r += " nExpiryHeight " + t.nExpiryHeight.toString("hex")), t.extraData && (r += " extraData " + t.extraData.toString("hex")), t.inputs.forEach(function(e, i) {
    var s = e.prevout, n = e.script, o = e.sequence;
    r += `
input `.concat(i, ":"), r += " prevout ".concat(s.toString("hex")), r += " script ".concat(n.toString("hex")), r += " sequence ".concat(o.toString("hex"));
  }), (t.outputs || []).forEach(function(e, i) {
    var s = e.amount, n = e.script;
    r += `
output `.concat(i, ":"), r += " amount ".concat(s.toString("hex")), r += " script ".concat(n.toString("hex"));
  }), r;
}
function qc(t, r, e, i, s) {
  r === void 0 && (r = !1), e === void 0 && (e = !1), i === void 0 && (i = !1), s === void 0 && (s = []);
  var n = [], o = [], u = !1, c = 0, a = Buffer.alloc(0), f = Buffer.alloc(0), l = Buffer.alloc(0), v = Buffer.alloc(0), h, w, b = s.includes("decred"), x = s.includes("zencash"), B = s.includes("zcash"), p = Buffer.from(t, "hex"), $ = p.slice(c, c + 4), R = $.equals(Buffer.from([3, 0, 0, 128])) || $.equals(Buffer.from([4, 0, 0, 128])) || $.equals(Buffer.from([5, 0, 0, 128])), P = B && $.equals(Buffer.from([5, 0, 0, 128]));
  c += 4, !e && r && p[c] === 0 && p[c + 1] !== 0 && !x && (c += 2, u = !0), e && (a = p.slice(c, 4 + c), c += 4), R && (l = p.slice(c, 4 + c), c += 4), P && (w = p.slice(c + 4, c + 8), f = p.slice(c + 8, c + 12), c += 12);
  var I = Ue(p, c), U = I[0];
  c += I[1];
  for (var L = 0; L < U; L++) {
    var X = p.slice(c, c + 36);
    c += 36;
    var A = Buffer.alloc(0), k = Buffer.alloc(0);
    b ? (k = p.slice(c, c + 1), c += 1) : (I = Ue(p, c), c += I[1], A = p.slice(c, c + I[0]), c += I[0]);
    var N = p.slice(c, c + 4);
    c += 4, n.push({
      prevout: X,
      script: A,
      sequence: N,
      tree: k
    });
  }
  I = Ue(p, c);
  var d = I[0];
  c += I[1];
  for (var L = 0; L < d; L++) {
    var g = p.slice(c, c + 8);
    c += 8, b && (c += 2), I = Ue(p, c), c += I[1];
    var A = p.slice(c, c + I[0]);
    c += I[0], o.push({
      amount: g,
      script: A
    });
  }
  if (u ? (h = p.slice(c, -4), w = p.slice(p.length - 4)) : P || (w = p.slice(c, c + 4)), c += 4, (R || b) && !P && (f = p.slice(c, c + 4), c += 4), i && (v = p.slice(c)), b) {
    if (I = Ue(p, c), c += I[1], I[0] !== U)
      throw new Error("splitTransaction: incoherent number of witnesses");
    for (var L = 0; L < U; L++) {
      c += 8, c += 4, c += 4, I = Ue(p, c), c += I[1];
      var A = p.slice(c, c + I[0]);
      c += I[0], n[L].script = A;
    }
  }
  var _ = {
    version: $,
    inputs: n,
    outputs: o,
    locktime: w,
    witness: h,
    timestamp: a,
    nVersionGroupId: l,
    nExpiryHeight: f,
    extraData: v
  };
  return ni("btc", "splitTransaction ".concat(t, `:
`).concat(Kc(_))), _;
}
var Jn = globalThis && globalThis.__awaiter || function(t, r, e, i) {
  function s(n) {
    return n instanceof e ? n : new e(function(o) {
      o(n);
    });
  }
  return new (e || (e = Promise))(function(n, o) {
    function u(f) {
      try {
        a(i.next(f));
      } catch (l) {
        o(l);
      }
    }
    function c(f) {
      try {
        a(i.throw(f));
      } catch (l) {
        o(l);
      }
    }
    function a(f) {
      f.done ? n(f.value) : s(f.value).then(u, c);
    }
    a((i = i.apply(t, r || [])).next());
  });
}, ei = globalThis && globalThis.__generator || function(t, r) {
  var e = { label: 0, sent: function() {
    if (n[0] & 1)
      throw n[1];
    return n[1];
  }, trys: [], ops: [] }, i, s, n, o;
  return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function u(a) {
    return function(f) {
      return c([a, f]);
    };
  }
  function c(a) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; e; )
      try {
        if (i = 1, s && (n = a[0] & 2 ? s.return : a[0] ? s.throw || ((n = s.return) && n.call(s), 0) : s.next) && !(n = n.call(s, a[1])).done)
          return n;
        switch (s = 0, n && (a = [a[0] & 2, n.value]), a[0]) {
          case 0:
          case 1:
            n = a;
            break;
          case 4:
            return e.label++, { value: a[1], done: !1 };
          case 5:
            e.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = e.ops.pop(), e.trys.pop();
            continue;
          default:
            if (n = e.trys, !(n = n.length > 0 && n[n.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              e = 0;
              continue;
            }
            if (a[0] === 3 && (!n || a[1] > n[0] && a[1] < n[3])) {
              e.label = a[1];
              break;
            }
            if (a[0] === 6 && e.label < n[1]) {
              e.label = n[1], n = a;
              break;
            }
            if (n && e.label < n[2]) {
              e.label = n[2], e.ops.push(a);
              break;
            }
            n[2] && e.ops.pop(), e.trys.pop();
            continue;
        }
        a = r.call(t, e);
      } catch (f) {
        a = [6, f], s = 0;
      } finally {
        i = n = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
}, wl = (
  /** @class */
  function() {
    function t(r, e) {
      e === void 0 && (e = "BTC"), this._lazyImpl = null, this.transport = r, r.decorateAppAPIMethods(this, [
        "getWalletXpub",
        "getWalletPublicKey",
        "signP2SHTransaction",
        "signMessageNew",
        "createPaymentTransactionNew",
        "getTrustedInput",
        "getTrustedInputBIP143"
      ], e);
    }
    return t.prototype.getWalletXpub = function(r) {
      return this.getCorrectImpl().then(function(e) {
        return e.getWalletXpub(r);
      });
    }, t.prototype.getWalletPublicKey = function(r, e) {
      var i = this, s;
      return arguments.length > 2 || typeof e == "boolean" ? (console.warn("btc.getWalletPublicKey deprecated signature used. Please switch to getWalletPublicKey(path, { format, verify })"), s = {
        verify: !!e,
        // eslint-disable-next-line prefer-rest-params
        format: arguments[2] ? "p2sh" : "legacy"
      }) : s = e || {}, this.getCorrectImpl().then(function(n) {
        return n instanceof Vn && s.format != "bech32m" && (!s.verify || s.verify == !1) && !Xc(r) ? (console.warn(`WARNING: Using deprecated device protocol to get the public key because
        
        * a non-standard path is requested, and
        * verify flag is false
        
        The new protocol only allows export of non-standard paths if the 
        verify flag is true. Standard paths are (currently):

        M/44'/(1|0)'/X'
        M/49'/(1|0)'/X'
        M/84'/(1|0)'/X'
        M/86'/(1|0)'/X'
        M/48'/(1|0)'/X'/Y'

        followed by "", "(0|1)", or "(0|1)/b", where a and b are 
        non-hardened. For example, the following paths are standard
        
        M/48'/1'/99'/7'
        M/86'/1'/99'/0
        M/48'/0'/99'/7'/1/17

        The following paths are non-standard

        M/48'/0'/99'           // Not deepest hardened path
        M/48'/0'/99'/7'/1/17/2 // Too many non-hardened derivation steps
        M/199'/0'/1'/0/88      // Not a known purpose 199
        M/86'/1'/99'/2         // Change path item must be 0 or 1

        This compatibility safeguard will be removed in the future.
        Please consider calling Btc.getWalletXpub() instead.`), i.old().getWalletPublicKey(r, s)) : n.getWalletPublicKey(r, s);
      });
    }, t.prototype.signMessageNew = function(r, e) {
      return this.old().signMessageNew(r, e);
    }, t.prototype.createPaymentTransactionNew = function(r) {
      return arguments.length > 1 && console.warn("@ledgerhq/hw-app-btc: createPaymentTransactionNew multi argument signature is deprecated. please switch to named parameters."), this.getCorrectImpl().then(function(e) {
        return e.createPaymentTransactionNew(r);
      });
    }, t.prototype.signP2SHTransaction = function(r) {
      return this.old().signP2SHTransaction(r);
    }, t.prototype.splitTransaction = function(r, e, i, s, n) {
      return e === void 0 && (e = !1), i === void 0 && (i = !1), s === void 0 && (s = !1), n === void 0 && (n = []), qc(r, e, i, s, n);
    }, t.prototype.serializeTransactionOutputs = function(r) {
      return Ki(r);
    }, t.prototype.getTrustedInput = function(r, e, i) {
      return i === void 0 && (i = []), jr(this.transport, r, e, i);
    }, t.prototype.getTrustedInputBIP143 = function(r, e, i) {
      return i === void 0 && (i = []), zr(this.transport, r, e, i);
    }, t.prototype.getCorrectImpl = function() {
      return Jn(this, void 0, void 0, function() {
        var r, e;
        return ei(this, function(i) {
          switch (i.label) {
            case 0:
              return r = this._lazyImpl, r ? [2, r] : [4, this.inferCorrectImpl()];
            case 1:
              return e = i.sent(), this._lazyImpl = e, [2, e];
          }
        });
      });
    }, t.prototype.inferCorrectImpl = function() {
      return Jn(this, void 0, void 0, function() {
        var r, e;
        return ei(this, function(i) {
          switch (i.label) {
            case 0:
              return [4, qi(this.transport)];
            case 1:
              return r = i.sent(), e = tc(r), e ? [2, this.new()] : [2, this.old()];
          }
        });
      });
    }, t.prototype.old = function() {
      return new Sc(this.transport);
    }, t.prototype.new = function() {
      return new Vn(new Vc(this.transport));
    }, t;
  }()
);
function Xc(t) {
  var r = 2147483648, e = xe(t), i = function(o) {
    return o >= r;
  }, s = function(o) {
    return !o || o < r;
  }, n = function(o) {
    return !o || o == 0 || o == 1;
  };
  return !!(e.length >= 3 && e.length <= 5 && [44 + r, 49 + r, 84 + r, 86 + r].some(function(o) {
    return o == e[0];
  }) && [0 + r, 1 + r].some(function(o) {
    return o == e[1];
  }) && i(e[2]) && n(e[3]) && s(e[4]) || e.length >= 4 && e.length <= 6 && 48 + r == e[0] && [0 + r, 1 + r].some(function(o) {
    return o == e[1];
  }) && i(e[2]) && i(e[3]) && n(e[4]) && s(e[5]));
}
export {
  wl as default
};
