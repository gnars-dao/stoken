import { g as Je } from "./index-66f1fb88.js";
import { l as Qe } from "./index-3e2f6604.js";
import "@cosmjs/encoding";
import "@cosmjs/math";
import "@cosmjs/proto-signing";
import "@cosmjs/stargate";
import "long";
import "@ethersproject/bignumber";
import "@ethersproject/abstract-signer";
import "bn.js";
import "bchaddrjs";
import "bitcoinjs-lib";
import "@scure/base";
import "crypto";
import "buffer";
import "events";
import "util";
import "crypto-js";
import "elliptic";
import "coininfo";
import "base64-js";
var te = { exports: {} };
const er = "2.0.0", Ue = 256, rr = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, tr = 16, sr = Ue - 6, nr = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var z = {
  MAX_LENGTH: Ue,
  MAX_SAFE_COMPONENT_LENGTH: tr,
  MAX_SAFE_BUILD_LENGTH: sr,
  MAX_SAFE_INTEGER: rr,
  RELEASE_TYPES: nr,
  SEMVER_SPEC_VERSION: er,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const ir = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...t) => console.error("SEMVER", ...t) : () => {
};
var q = ir;
(function(t, e) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: r,
    MAX_SAFE_BUILD_LENGTH: s,
    MAX_LENGTH: o
  } = z, i = q;
  e = t.exports = {};
  const d = e.re = [], p = e.safeRe = [], n = e.src = [], a = e.t = {};
  let l = 0;
  const E = "[a-zA-Z0-9-]", v = [
    ["\\s", 1],
    ["\\d", o],
    [E, s]
  ], h = (G) => {
    for (const [y, x] of v)
      G = G.split(`${y}*`).join(`${y}{0,${x}}`).split(`${y}+`).join(`${y}{1,${x}}`);
    return G;
  }, R = (G, y, x) => {
    const A = h(y), U = l++;
    i(G, U, y), a[G] = U, n[U] = y, d[U] = new RegExp(y, x ? "g" : void 0), p[U] = new RegExp(A, x ? "g" : void 0);
  };
  R("NUMERICIDENTIFIER", "0|[1-9]\\d*"), R("NUMERICIDENTIFIERLOOSE", "\\d+"), R("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${E}*`), R("MAINVERSION", `(${n[a.NUMERICIDENTIFIER]})\\.(${n[a.NUMERICIDENTIFIER]})\\.(${n[a.NUMERICIDENTIFIER]})`), R("MAINVERSIONLOOSE", `(${n[a.NUMERICIDENTIFIERLOOSE]})\\.(${n[a.NUMERICIDENTIFIERLOOSE]})\\.(${n[a.NUMERICIDENTIFIERLOOSE]})`), R("PRERELEASEIDENTIFIER", `(?:${n[a.NUMERICIDENTIFIER]}|${n[a.NONNUMERICIDENTIFIER]})`), R("PRERELEASEIDENTIFIERLOOSE", `(?:${n[a.NUMERICIDENTIFIERLOOSE]}|${n[a.NONNUMERICIDENTIFIER]})`), R("PRERELEASE", `(?:-(${n[a.PRERELEASEIDENTIFIER]}(?:\\.${n[a.PRERELEASEIDENTIFIER]})*))`), R("PRERELEASELOOSE", `(?:-?(${n[a.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${n[a.PRERELEASEIDENTIFIERLOOSE]})*))`), R("BUILDIDENTIFIER", `${E}+`), R("BUILD", `(?:\\+(${n[a.BUILDIDENTIFIER]}(?:\\.${n[a.BUILDIDENTIFIER]})*))`), R("FULLPLAIN", `v?${n[a.MAINVERSION]}${n[a.PRERELEASE]}?${n[a.BUILD]}?`), R("FULL", `^${n[a.FULLPLAIN]}$`), R("LOOSEPLAIN", `[v=\\s]*${n[a.MAINVERSIONLOOSE]}${n[a.PRERELEASELOOSE]}?${n[a.BUILD]}?`), R("LOOSE", `^${n[a.LOOSEPLAIN]}$`), R("GTLT", "((?:<|>)?=?)"), R("XRANGEIDENTIFIERLOOSE", `${n[a.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), R("XRANGEIDENTIFIER", `${n[a.NUMERICIDENTIFIER]}|x|X|\\*`), R("XRANGEPLAIN", `[v=\\s]*(${n[a.XRANGEIDENTIFIER]})(?:\\.(${n[a.XRANGEIDENTIFIER]})(?:\\.(${n[a.XRANGEIDENTIFIER]})(?:${n[a.PRERELEASE]})?${n[a.BUILD]}?)?)?`), R("XRANGEPLAINLOOSE", `[v=\\s]*(${n[a.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[a.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[a.XRANGEIDENTIFIERLOOSE]})(?:${n[a.PRERELEASELOOSE]})?${n[a.BUILD]}?)?)?`), R("XRANGE", `^${n[a.GTLT]}\\s*${n[a.XRANGEPLAIN]}$`), R("XRANGELOOSE", `^${n[a.GTLT]}\\s*${n[a.XRANGEPLAINLOOSE]}$`), R("COERCE", `(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?(?:$|[^\\d])`), R("COERCERTL", n[a.COERCE], !0), R("LONETILDE", "(?:~>?)"), R("TILDETRIM", `(\\s*)${n[a.LONETILDE]}\\s+`, !0), e.tildeTrimReplace = "$1~", R("TILDE", `^${n[a.LONETILDE]}${n[a.XRANGEPLAIN]}$`), R("TILDELOOSE", `^${n[a.LONETILDE]}${n[a.XRANGEPLAINLOOSE]}$`), R("LONECARET", "(?:\\^)"), R("CARETTRIM", `(\\s*)${n[a.LONECARET]}\\s+`, !0), e.caretTrimReplace = "$1^", R("CARET", `^${n[a.LONECARET]}${n[a.XRANGEPLAIN]}$`), R("CARETLOOSE", `^${n[a.LONECARET]}${n[a.XRANGEPLAINLOOSE]}$`), R("COMPARATORLOOSE", `^${n[a.GTLT]}\\s*(${n[a.LOOSEPLAIN]})$|^$`), R("COMPARATOR", `^${n[a.GTLT]}\\s*(${n[a.FULLPLAIN]})$|^$`), R("COMPARATORTRIM", `(\\s*)${n[a.GTLT]}\\s*(${n[a.LOOSEPLAIN]}|${n[a.XRANGEPLAIN]})`, !0), e.comparatorTrimReplace = "$1$2$3", R("HYPHENRANGE", `^\\s*(${n[a.XRANGEPLAIN]})\\s+-\\s+(${n[a.XRANGEPLAIN]})\\s*$`), R("HYPHENRANGELOOSE", `^\\s*(${n[a.XRANGEPLAINLOOSE]})\\s+-\\s+(${n[a.XRANGEPLAINLOOSE]})\\s*$`), R("STAR", "(<|>)?=?\\s*\\*"), R("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), R("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(te, te.exports);
var b = te.exports;
const or = Object.freeze({ loose: !0 }), ar = Object.freeze({}), cr = (t) => t ? typeof t != "object" ? or : t : ar;
var ne = cr;
const Ee = /^[0-9]+$/, je = (t, e) => {
  const r = Ee.test(t), s = Ee.test(e);
  return r && s && (t = +t, e = +e), t === e ? 0 : r && !s ? -1 : s && !r ? 1 : t < e ? -1 : 1;
}, lr = (t, e) => je(e, t);
var Xe = {
  compareIdentifiers: je,
  rcompareIdentifiers: lr
};
const k = q, { MAX_LENGTH: he, MAX_SAFE_INTEGER: M } = z, { safeRe: $e, t: pe } = b, ur = ne, { compareIdentifiers: j } = Xe;
let fr = class D {
  constructor(e, r) {
    if (r = ur(r), e instanceof D) {
      if (e.loose === !!r.loose && e.includePrerelease === !!r.includePrerelease)
        return e;
      e = e.version;
    } else if (typeof e != "string")
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof e}".`);
    if (e.length > he)
      throw new TypeError(
        `version is longer than ${he} characters`
      );
    k("SemVer", e, r), this.options = r, this.loose = !!r.loose, this.includePrerelease = !!r.includePrerelease;
    const s = e.trim().match(r.loose ? $e[pe.LOOSE] : $e[pe.FULL]);
    if (!s)
      throw new TypeError(`Invalid Version: ${e}`);
    if (this.raw = e, this.major = +s[1], this.minor = +s[2], this.patch = +s[3], this.major > M || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > M || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > M || this.patch < 0)
      throw new TypeError("Invalid patch version");
    s[4] ? this.prerelease = s[4].split(".").map((o) => {
      if (/^[0-9]+$/.test(o)) {
        const i = +o;
        if (i >= 0 && i < M)
          return i;
      }
      return o;
    }) : this.prerelease = [], this.build = s[5] ? s[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(e) {
    if (k("SemVer.compare", this.version, this.options, e), !(e instanceof D)) {
      if (typeof e == "string" && e === this.version)
        return 0;
      e = new D(e, this.options);
    }
    return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e);
  }
  compareMain(e) {
    return e instanceof D || (e = new D(e, this.options)), j(this.major, e.major) || j(this.minor, e.minor) || j(this.patch, e.patch);
  }
  comparePre(e) {
    if (e instanceof D || (e = new D(e, this.options)), this.prerelease.length && !e.prerelease.length)
      return -1;
    if (!this.prerelease.length && e.prerelease.length)
      return 1;
    if (!this.prerelease.length && !e.prerelease.length)
      return 0;
    let r = 0;
    do {
      const s = this.prerelease[r], o = e.prerelease[r];
      if (k("prerelease compare", r, s, o), s === void 0 && o === void 0)
        return 0;
      if (o === void 0)
        return 1;
      if (s === void 0)
        return -1;
      if (s === o)
        continue;
      return j(s, o);
    } while (++r);
  }
  compareBuild(e) {
    e instanceof D || (e = new D(e, this.options));
    let r = 0;
    do {
      const s = this.build[r], o = e.build[r];
      if (k("prerelease compare", r, s, o), s === void 0 && o === void 0)
        return 0;
      if (o === void 0)
        return 1;
      if (s === void 0)
        return -1;
      if (s === o)
        continue;
      return j(s, o);
    } while (++r);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(e, r, s) {
    switch (e) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", r, s);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", r, s);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", r, s), this.inc("pre", r, s);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", r, s), this.inc("pre", r, s);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre": {
        const o = Number(s) ? 1 : 0;
        if (!r && s === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (this.prerelease.length === 0)
          this.prerelease = [o];
        else {
          let i = this.prerelease.length;
          for (; --i >= 0; )
            typeof this.prerelease[i] == "number" && (this.prerelease[i]++, i = -2);
          if (i === -1) {
            if (r === this.prerelease.join(".") && s === !1)
              throw new Error("invalid increment argument: identifier already exists");
            this.prerelease.push(o);
          }
        }
        if (r) {
          let i = [r, o];
          s === !1 && (i = [r]), j(this.prerelease[0], r) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = i) : this.prerelease = i;
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${e}`);
    }
    return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
  }
};
var w = fr;
const me = w, Er = (t, e, r = !1) => {
  if (t instanceof me)
    return t;
  try {
    return new me(t, e);
  } catch (s) {
    if (!r)
      return null;
    throw s;
  }
};
var X = Er;
const hr = X, $r = (t, e) => {
  const r = hr(t, e);
  return r ? r.version : null;
};
var pr = $r;
const mr = X, Rr = (t, e) => {
  const r = mr(t.trim().replace(/^[=v]+/, ""), e);
  return r ? r.version : null;
};
var Ir = Rr;
const Re = w, dr = (t, e, r, s, o) => {
  typeof r == "string" && (o = s, s = r, r = void 0);
  try {
    return new Re(
      t instanceof Re ? t.version : t,
      r
    ).inc(e, s, o).version;
  } catch {
    return null;
  }
};
var Nr = dr;
const Ie = X, Sr = (t, e) => {
  const r = Ie(t, null, !0), s = Ie(e, null, !0), o = r.compare(s);
  if (o === 0)
    return null;
  const i = o > 0, d = i ? r : s, p = i ? s : r, n = !!d.prerelease.length;
  if (!!p.prerelease.length && !n)
    return !p.patch && !p.minor ? "major" : d.patch ? "patch" : d.minor ? "minor" : "major";
  const l = n ? "pre" : "";
  return r.major !== s.major ? l + "major" : r.minor !== s.minor ? l + "minor" : r.patch !== s.patch ? l + "patch" : "prerelease";
};
var Lr = Sr;
const vr = w, Or = (t, e) => new vr(t, e).major;
var Tr = Or;
const Ar = w, gr = (t, e) => new Ar(t, e).minor;
var wr = gr;
const Pr = w, yr = (t, e) => new Pr(t, e).patch;
var Cr = yr;
const _r = X, Dr = (t, e) => {
  const r = _r(t, e);
  return r && r.prerelease.length ? r.prerelease : null;
};
var Gr = Dr;
const de = w, xr = (t, e, r) => new de(t, r).compare(new de(e, r));
var C = xr;
const Ur = C, jr = (t, e, r) => Ur(e, t, r);
var Xr = jr;
const Fr = C, Vr = (t, e) => Fr(t, e, !0);
var br = Vr;
const Ne = w, kr = (t, e, r) => {
  const s = new Ne(t, r), o = new Ne(e, r);
  return s.compare(o) || s.compareBuild(o);
};
var ie = kr;
const Mr = ie, Hr = (t, e) => t.sort((r, s) => Mr(r, s, e));
var Br = Hr;
const zr = ie, qr = (t, e) => t.sort((r, s) => zr(s, r, e));
var Yr = qr;
const Wr = C, Zr = (t, e, r) => Wr(t, e, r) > 0;
var Y = Zr;
const Kr = C, Jr = (t, e, r) => Kr(t, e, r) < 0;
var oe = Jr;
const Qr = C, et = (t, e, r) => Qr(t, e, r) === 0;
var Fe = et;
const rt = C, tt = (t, e, r) => rt(t, e, r) !== 0;
var Ve = tt;
const st = C, nt = (t, e, r) => st(t, e, r) >= 0;
var ae = nt;
const it = C, ot = (t, e, r) => it(t, e, r) <= 0;
var ce = ot;
const at = Fe, ct = Ve, lt = Y, ut = ae, ft = oe, Et = ce, ht = (t, e, r, s) => {
  switch (e) {
    case "===":
      return typeof t == "object" && (t = t.version), typeof r == "object" && (r = r.version), t === r;
    case "!==":
      return typeof t == "object" && (t = t.version), typeof r == "object" && (r = r.version), t !== r;
    case "":
    case "=":
    case "==":
      return at(t, r, s);
    case "!=":
      return ct(t, r, s);
    case ">":
      return lt(t, r, s);
    case ">=":
      return ut(t, r, s);
    case "<":
      return ft(t, r, s);
    case "<=":
      return Et(t, r, s);
    default:
      throw new TypeError(`Invalid operator: ${e}`);
  }
};
var be = ht;
const $t = w, pt = X, { safeRe: H, t: B } = b, mt = (t, e) => {
  if (t instanceof $t)
    return t;
  if (typeof t == "number" && (t = String(t)), typeof t != "string")
    return null;
  e = e || {};
  let r = null;
  if (!e.rtl)
    r = t.match(H[B.COERCE]);
  else {
    let s;
    for (; (s = H[B.COERCERTL].exec(t)) && (!r || r.index + r[0].length !== t.length); )
      (!r || s.index + s[0].length !== r.index + r[0].length) && (r = s), H[B.COERCERTL].lastIndex = s.index + s[1].length + s[2].length;
    H[B.COERCERTL].lastIndex = -1;
  }
  return r === null ? null : pt(`${r[2]}.${r[3] || "0"}.${r[4] || "0"}`, e);
};
var Rt = mt, K, Se;
function _() {
  if (Se)
    return K;
  Se = 1;
  class t {
    constructor(c, I) {
      if (I = s(I), c instanceof t)
        return c.loose === !!I.loose && c.includePrerelease === !!I.includePrerelease ? c : new t(c.raw, I);
      if (c instanceof o)
        return this.raw = c.value, this.set = [[c]], this.format(), this;
      if (this.options = I, this.loose = !!I.loose, this.includePrerelease = !!I.includePrerelease, this.raw = c.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map(($) => this.parseRange($.trim())).filter(($) => $.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const $ = this.set[0];
        if (this.set = this.set.filter((m) => !R(m[0])), this.set.length === 0)
          this.set = [$];
        else if (this.set.length > 1) {
          for (const m of this.set)
            if (m.length === 1 && G(m[0])) {
              this.set = [m];
              break;
            }
        }
      }
      this.format();
    }
    format() {
      return this.range = this.set.map((c) => c.join(" ").trim()).join("||").trim(), this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(c) {
      const $ = ((this.options.includePrerelease && v) | (this.options.loose && h)) + ":" + c, m = r.get($);
      if (m)
        return m;
      const f = this.options.loose, N = f ? p[n.HYPHENRANGELOOSE] : p[n.HYPHENRANGE];
      c = c.replace(N, Ze(this.options.includePrerelease)), i("hyphen replace", c), c = c.replace(p[n.COMPARATORTRIM], a), i("comparator trim", c), c = c.replace(p[n.TILDETRIM], l), i("tilde trim", c), c = c.replace(p[n.CARETTRIM], E), i("caret trim", c);
      let L = c.split(" ").map((T) => x(T, this.options)).join(" ").split(/\s+/).map((T) => We(T, this.options));
      f && (L = L.filter((T) => (i("loose invalid filter", T, this.options), !!T.match(p[n.COMPARATORLOOSE])))), i("range list", L);
      const S = /* @__PURE__ */ new Map(), O = L.map((T) => new o(T, this.options));
      for (const T of O) {
        if (R(T))
          return [T];
        S.set(T.value, T);
      }
      S.size > 1 && S.has("") && S.delete("");
      const P = [...S.values()];
      return r.set($, P), P;
    }
    intersects(c, I) {
      if (!(c instanceof t))
        throw new TypeError("a Range is required");
      return this.set.some(($) => y($, I) && c.set.some((m) => y(m, I) && $.every((f) => m.every((N) => f.intersects(N, I)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(c) {
      if (!c)
        return !1;
      if (typeof c == "string")
        try {
          c = new d(c, this.options);
        } catch {
          return !1;
        }
      for (let I = 0; I < this.set.length; I++)
        if (Ke(this.set[I], c, this.options))
          return !0;
      return !1;
    }
  }
  K = t;
  const e = Qe, r = new e({ max: 1e3 }), s = ne, o = W(), i = q, d = w, {
    safeRe: p,
    t: n,
    comparatorTrimReplace: a,
    tildeTrimReplace: l,
    caretTrimReplace: E
  } = b, { FLAG_INCLUDE_PRERELEASE: v, FLAG_LOOSE: h } = z, R = (u) => u.value === "<0.0.0-0", G = (u) => u.value === "", y = (u, c) => {
    let I = !0;
    const $ = u.slice();
    let m = $.pop();
    for (; I && $.length; )
      I = $.every((f) => m.intersects(f, c)), m = $.pop();
    return I;
  }, x = (u, c) => (i("comp", u, c), u = He(u, c), i("caret", u), u = U(u, c), i("tildes", u), u = ze(u, c), i("xrange", u), u = Ye(u, c), i("stars", u), u), A = (u) => !u || u.toLowerCase() === "x" || u === "*", U = (u, c) => u.trim().split(/\s+/).map((I) => Me(I, c)).join(" "), Me = (u, c) => {
    const I = c.loose ? p[n.TILDELOOSE] : p[n.TILDE];
    return u.replace(I, ($, m, f, N, L) => {
      i("tilde", u, $, m, f, N, L);
      let S;
      return A(m) ? S = "" : A(f) ? S = `>=${m}.0.0 <${+m + 1}.0.0-0` : A(N) ? S = `>=${m}.${f}.0 <${m}.${+f + 1}.0-0` : L ? (i("replaceTilde pr", L), S = `>=${m}.${f}.${N}-${L} <${m}.${+f + 1}.0-0`) : S = `>=${m}.${f}.${N} <${m}.${+f + 1}.0-0`, i("tilde return", S), S;
    });
  }, He = (u, c) => u.trim().split(/\s+/).map((I) => Be(I, c)).join(" "), Be = (u, c) => {
    i("caret", u, c);
    const I = c.loose ? p[n.CARETLOOSE] : p[n.CARET], $ = c.includePrerelease ? "-0" : "";
    return u.replace(I, (m, f, N, L, S) => {
      i("caret", u, m, f, N, L, S);
      let O;
      return A(f) ? O = "" : A(N) ? O = `>=${f}.0.0${$} <${+f + 1}.0.0-0` : A(L) ? f === "0" ? O = `>=${f}.${N}.0${$} <${f}.${+N + 1}.0-0` : O = `>=${f}.${N}.0${$} <${+f + 1}.0.0-0` : S ? (i("replaceCaret pr", S), f === "0" ? N === "0" ? O = `>=${f}.${N}.${L}-${S} <${f}.${N}.${+L + 1}-0` : O = `>=${f}.${N}.${L}-${S} <${f}.${+N + 1}.0-0` : O = `>=${f}.${N}.${L}-${S} <${+f + 1}.0.0-0`) : (i("no pr"), f === "0" ? N === "0" ? O = `>=${f}.${N}.${L}${$} <${f}.${N}.${+L + 1}-0` : O = `>=${f}.${N}.${L}${$} <${f}.${+N + 1}.0-0` : O = `>=${f}.${N}.${L} <${+f + 1}.0.0-0`), i("caret return", O), O;
    });
  }, ze = (u, c) => (i("replaceXRanges", u, c), u.split(/\s+/).map((I) => qe(I, c)).join(" ")), qe = (u, c) => {
    u = u.trim();
    const I = c.loose ? p[n.XRANGELOOSE] : p[n.XRANGE];
    return u.replace(I, ($, m, f, N, L, S) => {
      i("xRange", u, $, m, f, N, L, S);
      const O = A(f), P = O || A(N), T = P || A(L), F = T;
      return m === "=" && F && (m = ""), S = c.includePrerelease ? "-0" : "", O ? m === ">" || m === "<" ? $ = "<0.0.0-0" : $ = "*" : m && F ? (P && (N = 0), L = 0, m === ">" ? (m = ">=", P ? (f = +f + 1, N = 0, L = 0) : (N = +N + 1, L = 0)) : m === "<=" && (m = "<", P ? f = +f + 1 : N = +N + 1), m === "<" && (S = "-0"), $ = `${m + f}.${N}.${L}${S}`) : P ? $ = `>=${f}.0.0${S} <${+f + 1}.0.0-0` : T && ($ = `>=${f}.${N}.0${S} <${f}.${+N + 1}.0-0`), i("xRange return", $), $;
    });
  }, Ye = (u, c) => (i("replaceStars", u, c), u.trim().replace(p[n.STAR], "")), We = (u, c) => (i("replaceGTE0", u, c), u.trim().replace(p[c.includePrerelease ? n.GTE0PRE : n.GTE0], "")), Ze = (u) => (c, I, $, m, f, N, L, S, O, P, T, F, Bs) => (A($) ? I = "" : A(m) ? I = `>=${$}.0.0${u ? "-0" : ""}` : A(f) ? I = `>=${$}.${m}.0${u ? "-0" : ""}` : N ? I = `>=${I}` : I = `>=${I}${u ? "-0" : ""}`, A(O) ? S = "" : A(P) ? S = `<${+O + 1}.0.0-0` : A(T) ? S = `<${O}.${+P + 1}.0-0` : F ? S = `<=${O}.${P}.${T}-${F}` : u ? S = `<${O}.${P}.${+T + 1}-0` : S = `<=${S}`, `${I} ${S}`.trim()), Ke = (u, c, I) => {
    for (let $ = 0; $ < u.length; $++)
      if (!u[$].test(c))
        return !1;
    if (c.prerelease.length && !I.includePrerelease) {
      for (let $ = 0; $ < u.length; $++)
        if (i(u[$].semver), u[$].semver !== o.ANY && u[$].semver.prerelease.length > 0) {
          const m = u[$].semver;
          if (m.major === c.major && m.minor === c.minor && m.patch === c.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return K;
}
var J, Le;
function W() {
  if (Le)
    return J;
  Le = 1;
  const t = Symbol("SemVer ANY");
  class e {
    static get ANY() {
      return t;
    }
    constructor(l, E) {
      if (E = r(E), l instanceof e) {
        if (l.loose === !!E.loose)
          return l;
        l = l.value;
      }
      l = l.trim().split(/\s+/).join(" "), d("comparator", l, E), this.options = E, this.loose = !!E.loose, this.parse(l), this.semver === t ? this.value = "" : this.value = this.operator + this.semver.version, d("comp", this);
    }
    parse(l) {
      const E = this.options.loose ? s[o.COMPARATORLOOSE] : s[o.COMPARATOR], v = l.match(E);
      if (!v)
        throw new TypeError(`Invalid comparator: ${l}`);
      this.operator = v[1] !== void 0 ? v[1] : "", this.operator === "=" && (this.operator = ""), v[2] ? this.semver = new p(v[2], this.options.loose) : this.semver = t;
    }
    toString() {
      return this.value;
    }
    test(l) {
      if (d("Comparator.test", l, this.options.loose), this.semver === t || l === t)
        return !0;
      if (typeof l == "string")
        try {
          l = new p(l, this.options);
        } catch {
          return !1;
        }
      return i(l, this.operator, this.semver, this.options);
    }
    intersects(l, E) {
      if (!(l instanceof e))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new n(l.value, E).test(this.value) : l.operator === "" ? l.value === "" ? !0 : new n(this.value, E).test(l.semver) : (E = r(E), E.includePrerelease && (this.value === "<0.0.0-0" || l.value === "<0.0.0-0") || !E.includePrerelease && (this.value.startsWith("<0.0.0") || l.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && l.operator.startsWith(">") || this.operator.startsWith("<") && l.operator.startsWith("<") || this.semver.version === l.semver.version && this.operator.includes("=") && l.operator.includes("=") || i(this.semver, "<", l.semver, E) && this.operator.startsWith(">") && l.operator.startsWith("<") || i(this.semver, ">", l.semver, E) && this.operator.startsWith("<") && l.operator.startsWith(">")));
    }
  }
  J = e;
  const r = ne, { safeRe: s, t: o } = b, i = be, d = q, p = w, n = _();
  return J;
}
const It = _(), dt = (t, e, r) => {
  try {
    e = new It(e, r);
  } catch {
    return !1;
  }
  return e.test(t);
};
var Z = dt;
const Nt = _(), St = (t, e) => new Nt(t, e).set.map((r) => r.map((s) => s.value).join(" ").trim().split(" "));
var Lt = St;
const vt = w, Ot = _(), Tt = (t, e, r) => {
  let s = null, o = null, i = null;
  try {
    i = new Ot(e, r);
  } catch {
    return null;
  }
  return t.forEach((d) => {
    i.test(d) && (!s || o.compare(d) === -1) && (s = d, o = new vt(s, r));
  }), s;
};
var At = Tt;
const gt = w, wt = _(), Pt = (t, e, r) => {
  let s = null, o = null, i = null;
  try {
    i = new wt(e, r);
  } catch {
    return null;
  }
  return t.forEach((d) => {
    i.test(d) && (!s || o.compare(d) === 1) && (s = d, o = new gt(s, r));
  }), s;
};
var yt = Pt;
const Q = w, Ct = _(), ve = Y, _t = (t, e) => {
  t = new Ct(t, e);
  let r = new Q("0.0.0");
  if (t.test(r) || (r = new Q("0.0.0-0"), t.test(r)))
    return r;
  r = null;
  for (let s = 0; s < t.set.length; ++s) {
    const o = t.set[s];
    let i = null;
    o.forEach((d) => {
      const p = new Q(d.semver.version);
      switch (d.operator) {
        case ">":
          p.prerelease.length === 0 ? p.patch++ : p.prerelease.push(0), p.raw = p.format();
        case "":
        case ">=":
          (!i || ve(p, i)) && (i = p);
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${d.operator}`);
      }
    }), i && (!r || ve(r, i)) && (r = i);
  }
  return r && t.test(r) ? r : null;
};
var Dt = _t;
const Gt = _(), xt = (t, e) => {
  try {
    return new Gt(t, e).range || "*";
  } catch {
    return null;
  }
};
var Ut = xt;
const jt = w, ke = W(), { ANY: Xt } = ke, Ft = _(), Vt = Z, Oe = Y, Te = oe, bt = ce, kt = ae, Mt = (t, e, r, s) => {
  t = new jt(t, s), e = new Ft(e, s);
  let o, i, d, p, n;
  switch (r) {
    case ">":
      o = Oe, i = bt, d = Te, p = ">", n = ">=";
      break;
    case "<":
      o = Te, i = kt, d = Oe, p = "<", n = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (Vt(t, e, s))
    return !1;
  for (let a = 0; a < e.set.length; ++a) {
    const l = e.set[a];
    let E = null, v = null;
    if (l.forEach((h) => {
      h.semver === Xt && (h = new ke(">=0.0.0")), E = E || h, v = v || h, o(h.semver, E.semver, s) ? E = h : d(h.semver, v.semver, s) && (v = h);
    }), E.operator === p || E.operator === n || (!v.operator || v.operator === p) && i(t, v.semver))
      return !1;
    if (v.operator === n && d(t, v.semver))
      return !1;
  }
  return !0;
};
var le = Mt;
const Ht = le, Bt = (t, e, r) => Ht(t, e, ">", r);
var zt = Bt;
const qt = le, Yt = (t, e, r) => qt(t, e, "<", r);
var Wt = Yt;
const Ae = _(), Zt = (t, e, r) => (t = new Ae(t, r), e = new Ae(e, r), t.intersects(e, r));
var Kt = Zt;
const Jt = Z, Qt = C;
var es = (t, e, r) => {
  const s = [];
  let o = null, i = null;
  const d = t.sort((l, E) => Qt(l, E, r));
  for (const l of d)
    Jt(l, e, r) ? (i = l, o || (o = l)) : (i && s.push([o, i]), i = null, o = null);
  o && s.push([o, null]);
  const p = [];
  for (const [l, E] of s)
    l === E ? p.push(l) : !E && l === d[0] ? p.push("*") : E ? l === d[0] ? p.push(`<=${E}`) : p.push(`${l} - ${E}`) : p.push(`>=${l}`);
  const n = p.join(" || "), a = typeof e.raw == "string" ? e.raw : String(e);
  return n.length < a.length ? n : e;
};
const ge = _(), ue = W(), { ANY: ee } = ue, V = Z, fe = C, rs = (t, e, r = {}) => {
  if (t === e)
    return !0;
  t = new ge(t, r), e = new ge(e, r);
  let s = !1;
  e:
    for (const o of t.set) {
      for (const i of e.set) {
        const d = ss(o, i, r);
        if (s = s || d !== null, d)
          continue e;
      }
      if (s)
        return !1;
    }
  return !0;
}, ts = [new ue(">=0.0.0-0")], we = [new ue(">=0.0.0")], ss = (t, e, r) => {
  if (t === e)
    return !0;
  if (t.length === 1 && t[0].semver === ee) {
    if (e.length === 1 && e[0].semver === ee)
      return !0;
    r.includePrerelease ? t = ts : t = we;
  }
  if (e.length === 1 && e[0].semver === ee) {
    if (r.includePrerelease)
      return !0;
    e = we;
  }
  const s = /* @__PURE__ */ new Set();
  let o, i;
  for (const h of t)
    h.operator === ">" || h.operator === ">=" ? o = Pe(o, h, r) : h.operator === "<" || h.operator === "<=" ? i = ye(i, h, r) : s.add(h.semver);
  if (s.size > 1)
    return null;
  let d;
  if (o && i) {
    if (d = fe(o.semver, i.semver, r), d > 0)
      return null;
    if (d === 0 && (o.operator !== ">=" || i.operator !== "<="))
      return null;
  }
  for (const h of s) {
    if (o && !V(h, String(o), r) || i && !V(h, String(i), r))
      return null;
    for (const R of e)
      if (!V(h, String(R), r))
        return !1;
    return !0;
  }
  let p, n, a, l, E = i && !r.includePrerelease && i.semver.prerelease.length ? i.semver : !1, v = o && !r.includePrerelease && o.semver.prerelease.length ? o.semver : !1;
  E && E.prerelease.length === 1 && i.operator === "<" && E.prerelease[0] === 0 && (E = !1);
  for (const h of e) {
    if (l = l || h.operator === ">" || h.operator === ">=", a = a || h.operator === "<" || h.operator === "<=", o) {
      if (v && h.semver.prerelease && h.semver.prerelease.length && h.semver.major === v.major && h.semver.minor === v.minor && h.semver.patch === v.patch && (v = !1), h.operator === ">" || h.operator === ">=") {
        if (p = Pe(o, h, r), p === h && p !== o)
          return !1;
      } else if (o.operator === ">=" && !V(o.semver, String(h), r))
        return !1;
    }
    if (i) {
      if (E && h.semver.prerelease && h.semver.prerelease.length && h.semver.major === E.major && h.semver.minor === E.minor && h.semver.patch === E.patch && (E = !1), h.operator === "<" || h.operator === "<=") {
        if (n = ye(i, h, r), n === h && n !== i)
          return !1;
      } else if (i.operator === "<=" && !V(i.semver, String(h), r))
        return !1;
    }
    if (!h.operator && (i || o) && d !== 0)
      return !1;
  }
  return !(o && a && !i && d !== 0 || i && l && !o && d !== 0 || v || E);
}, Pe = (t, e, r) => {
  if (!t)
    return e;
  const s = fe(t.semver, e.semver, r);
  return s > 0 ? t : s < 0 || e.operator === ">" && t.operator === ">=" ? e : t;
}, ye = (t, e, r) => {
  if (!t)
    return e;
  const s = fe(t.semver, e.semver, r);
  return s < 0 ? t : s > 0 || e.operator === "<" && t.operator === "<=" ? e : t;
};
var ns = rs;
const re = b, Ce = z, is = w, _e = Xe, os = X, as = pr, cs = Ir, ls = Nr, us = Lr, fs = Tr, Es = wr, hs = Cr, $s = Gr, ps = C, ms = Xr, Rs = br, Is = ie, ds = Br, Ns = Yr, Ss = Y, Ls = oe, vs = Fe, Os = Ve, Ts = ae, As = ce, gs = be, ws = Rt, Ps = W(), ys = _(), Cs = Z, _s = Lt, Ds = At, Gs = yt, xs = Dt, Us = Ut, js = le, Xs = zt, Fs = Wt, Vs = Kt, bs = es, ks = ns;
var Ms = {
  parse: os,
  valid: as,
  clean: cs,
  inc: ls,
  diff: us,
  major: fs,
  minor: Es,
  patch: hs,
  prerelease: $s,
  compare: ps,
  rcompare: ms,
  compareLoose: Rs,
  compareBuild: Is,
  sort: ds,
  rsort: Ns,
  gt: Ss,
  lt: Ls,
  eq: vs,
  neq: Os,
  gte: Ts,
  lte: As,
  cmp: gs,
  coerce: ws,
  Comparator: Ps,
  Range: ys,
  satisfies: Cs,
  toComparators: _s,
  maxSatisfying: Ds,
  minSatisfying: Gs,
  minVersion: xs,
  validRange: Us,
  outside: js,
  gtr: Xs,
  ltr: Fs,
  intersects: Vs,
  simplifyRange: bs,
  subset: ks,
  SemVer: is,
  re: re.re,
  src: re.src,
  tokens: re.t,
  SEMVER_SPEC_VERSION: Ce.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: Ce.RELEASE_TYPES,
  compareIdentifiers: _e.compareIdentifiers,
  rcompareIdentifiers: _e.rcompareIdentifiers
};
const De = /* @__PURE__ */ Je(Ms);
var g;
(function(t) {
  t.blue = "blue", t.nanoS = "nanoS", t.nanoSP = "nanoSP", t.nanoX = "nanoX", t.stax = "stax";
})(g || (g = {}));
const se = {
  [g.blue]: {
    id: g.blue,
    productName: "Ledger Blue",
    productIdMM: 0,
    legacyUsbProductId: 0,
    usbOnly: !0,
    memorySize: 480 * 1024,
    masks: [822083584, 822149120],
    getBlockSize: (t) => 4 * 1024
  },
  [g.nanoS]: {
    id: g.nanoS,
    productName: "Ledger Nano S",
    productIdMM: 16,
    legacyUsbProductId: 1,
    usbOnly: !0,
    memorySize: 320 * 1024,
    masks: [823132160],
    getBlockSize: (t) => {
      var e;
      return De.lt((e = De.coerce(t)) !== null && e !== void 0 ? e : "", "2.0.0") ? 4 * 1024 : 2 * 1024;
    }
  },
  [g.nanoSP]: {
    id: g.nanoSP,
    productName: "Ledger Nano S Plus",
    productIdMM: 80,
    legacyUsbProductId: 5,
    usbOnly: !0,
    memorySize: 1536 * 1024,
    masks: [856686592],
    getBlockSize: (t) => 32
  },
  [g.nanoX]: {
    id: g.nanoX,
    productName: "Ledger Nano X",
    productIdMM: 64,
    legacyUsbProductId: 4,
    usbOnly: !1,
    memorySize: 2 * 1024 * 1024,
    masks: [855638016],
    getBlockSize: (t) => 4 * 1024,
    bluetoothSpec: [
      {
        serviceUuid: "13d63400-2c97-0004-0000-4c6564676572",
        notifyUuid: "13d63400-2c97-0004-0001-4c6564676572",
        writeUuid: "13d63400-2c97-0004-0002-4c6564676572",
        writeCmdUuid: "13d63400-2c97-0004-0003-4c6564676572"
      }
    ]
  },
  [g.stax]: {
    id: g.stax,
    productName: "Ledger Stax",
    productIdMM: 96,
    legacyUsbProductId: 6,
    usbOnly: !1,
    memorySize: 1536 * 1024,
    masks: [857735168],
    getBlockSize: (t) => 32,
    bluetoothSpec: [
      {
        serviceUuid: "13d63400-2c97-6004-0000-4c6564676572",
        notifyUuid: "13d63400-2c97-6004-0001-4c6564676572",
        writeUuid: "13d63400-2c97-6004-0002-4c6564676572",
        writeCmdUuid: "13d63400-2c97-6004-0003-4c6564676572"
      }
    ]
  }
};
g.blue, g.nanoS, g.nanoSP, g.nanoX, g.stax;
const Ge = Object.values(se), $n = 11415, pn = (t) => {
  const e = Ge.find((o) => o.legacyUsbProductId === t);
  if (e)
    return e;
  const r = t >> 8;
  return Ge.find((o) => o.productIdMM === r);
}, Hs = [], xe = {};
for (const t in se) {
  const e = se[t], { bluetoothSpec: r } = e;
  if (r)
    for (let s = 0; s < r.length; s++) {
      const o = r[s];
      Hs.push(o.serviceUuid), xe[o.serviceUuid] = xe[o.serviceUuid.replace(/-/g, "")] = Object.assign({ deviceModel: e }, o);
    }
}
export {
  g as DeviceModelId,
  pn as identifyUSBProductId,
  $n as ledgerUSBVendorId
};
