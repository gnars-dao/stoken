import { b as m } from "./index-fb244210.js";
import { UserRefusedOnDevice as _ } from "./index-d8a5e2ef.js";
import "./index-66f1fb88.js";
import "@cosmjs/encoding";
import "@cosmjs/math";
import "@cosmjs/proto-signing";
import "@cosmjs/stargate";
import "long";
import "@ethersproject/bignumber";
import "@ethersproject/abstract-signer";
import "bn.js";
import "bchaddrjs";
import "bitcoinjs-lib";
import "@scure/base";
import "crypto";
import "buffer";
import "events";
import "util";
import "crypto-js";
import "elliptic";
import "coininfo";
import "base64-js";
var g = globalThis && globalThis.__awaiter || function(h, t, n, f) {
  function l(e) {
    return e instanceof n ? e : new n(function(r) {
      r(e);
    });
  }
  return new (n || (n = Promise))(function(e, r) {
    function s(c) {
      try {
        o(f.next(c));
      } catch (u) {
        r(u);
      }
    }
    function i(c) {
      try {
        o(f.throw(c));
      } catch (u) {
        r(u);
      }
    }
    function o(c) {
      c.done ? e(c.value) : l(c.value).then(s, i);
    }
    o((f = f.apply(h, t || [])).next());
  });
};
const p = 250, a = 85, P = "CSM", A = 0, E = 2, w = 4, I = 0, S = 1, x = 2, d = 36864, C = 27014;
class q {
  constructor(t, n = P) {
    this.transport = t, t.decorateAppAPIMethods(this, ["getAddress", "sign", "getAppConfiguration"], n);
  }
  // FIXME: understand what is going on with the return type here
  getAppConfiguration() {
    return this.transport.send(a, A, 0, 0).then((t) => ({
      test_mode: t[0] !== 0,
      version: "" + t[1] + "." + t[2] + "." + t[3],
      device_locked: t[4] === 1,
      major: t[1]
    }));
  }
  serializePath(t) {
    const n = Buffer.alloc(20);
    return n.writeUInt32LE((2147483648 | t[0]) >>> 0, 0), n.writeUInt32LE((2147483648 | t[1]) >>> 0, 4), n.writeUInt32LE((2147483648 | t[2]) >>> 0, 8), n.writeUInt32LE(t[3], 12), n.writeUInt32LE(t[4], 16), n;
  }
  serializeHRP(t) {
    if (t == null || t.length === 0 || t.length > 83)
      throw new Error("Invalid HRP");
    const n = Buffer.alloc(1 + t.length);
    return n.writeUInt8(t.length, 0), n.write(t, 1), n;
  }
  /**
   * get Cosmos address for a given BIP 32 path.
   * @param path a path in BIP 32 format
   * @param hrp usually cosmos
   * @option boolDisplay optionally enable or not the display
   * @return an object with a publicKey, address and (optionally) chainCode
   * @example
   * cosmos.getAddress("44'/60'/0'/0/0", "cosmos").then(o => o.address)
   */
  getAddress(t, n, f) {
    const l = m.fromString(t).toPathArray(), e = this.serializePath(l), r = Buffer.concat([this.serializeHRP(n), e]);
    return this.transport.send(a, w, f ? 1 : 0, 0, r, [d]).then((s) => {
      const i = Buffer.from(s.slice(33, -2)).toString(), o = Buffer.from(s.slice(0, 33)).toString("hex");
      return {
        address: i,
        publicKey: o
      };
    });
  }
  foreach(t, n) {
    function f(l, e, r) {
      return l >= e.length ? r : n(e[l], l).then(function(s) {
        return r.push(s), f(l + 1, e, r);
      });
    }
    return Promise.resolve().then(() => f(0, t, []));
  }
  sign(t, n) {
    return g(this, void 0, void 0, function* () {
      const f = m.fromString(t).toPathArray(), l = this.serializePath(f), e = [];
      e.push(l);
      const r = Buffer.from(n);
      for (let i = 0; i < r.length; i += p) {
        let o = i + p;
        i > r.length && (o = r.length), e.push(r.slice(i, o));
      }
      let s = {};
      return this.foreach(e, (i, o) => this.transport.send(a, E, o === 0 ? I : o + 1 === e.length ? x : S, 0, i, [d, C]).then((c) => s = c)).then(() => {
        const i = s.slice(-2), o = i[0] * 256 + i[1];
        let c = null;
        if (s.length > 2 && (c = s.slice(0, s.length - 2)), o === 27014)
          throw new _();
        return {
          signature: c,
          return_code: o
        };
      });
    });
  }
}
export {
  q as default
};
