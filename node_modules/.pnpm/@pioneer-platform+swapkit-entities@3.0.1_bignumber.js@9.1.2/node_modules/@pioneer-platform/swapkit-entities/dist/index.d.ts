import { BigNumber } from 'bignumber.js';
import { Chain } from '@pioneer-platform/types';
import { MemoType } from '@pioneer-platform/types';

export declare class Amount {
    readonly assetAmount: BigNumber;
    readonly baseAmount: BigNumber;
    readonly decimal: number;
    static fromMidgard(amount?: BigNumber.Value): Amount;
    static fromBaseAmount(amount: BigNumber.Value, decimal: number): Amount;
    static fromAssetAmount(amount: BigNumber.Value, decimal: number): Amount;
    static fromNormalAmount(amount?: BigNumber.Value): Amount;
    static sorter(a: Amount, b: Amount): number;
    constructor(amount: BigNumber.Value, type: AmountType | undefined, decimal: number);
    add(amount: Amount): Amount;
    sub(amount: Amount): Amount;
    mul(value: BigNumber.Value | Amount): Amount;
    div(value: BigNumber.Value | Amount): Amount;
    gte(amount: Amount | BigNumber.Value): boolean;
    gt(amount: Amount | BigNumber.Value): boolean;
    lte(amount: Amount | BigNumber.Value): boolean;
    lt(amount: Amount | BigNumber.Value): boolean;
    eq(amount: Amount | BigNumber.Value): boolean;
    toSignificant(significantDigits?: number, maxDecimals?: number, format?: BigNumber.Format, rounding?: Rounding): string;
    toFixedDecimal(decimalPlaces?: number, format?: BigNumber.Format, rounding?: Rounding): string;
    toFixed(decimalPlaces?: number, format?: BigNumber.Format, rounding?: Rounding): string;
    toAbbreviate(decimalPlaces?: number): string;
    toMidgard(): Amount;
    private toSignificantBigNumber;
}

export declare enum AmountType {
    BASE_AMOUNT = 0,
    ASSET_AMOUNT = 1
}

export declare class AssetAmount extends Amount {
    readonly asset: AssetEntity;
    readonly amount: Amount;
    constructor(asset: AssetEntity, amount: Amount);
    add(amount: AssetAmount): AssetAmount;
    sub(amount: AssetAmount): AssetAmount;
    mul(value: BigNumber.Value | Amount): AssetAmount;
    div(value: BigNumber.Value | Amount): AssetAmount;
    toCurrencyFormat({ significantDigits, format, rounding, }?: {
        significantDigits?: number;
        format?: BigNumber.Format;
        rounding?: Rounding;
    }, isPrefix?: boolean): string;
    totalPriceIn(quoteAsset: AssetEntity, pools: Pool[]): Price;
}

/**
 * L1 asset format:
 * - CHAIN.SYMBOL (Raw string, URL)
 * Synth asset format: CHAIN/SYMBOL
 * - CHAIN/SYMBOL (Raw string)
 * - THOR.CHAIN.SYMBOL (URL)
 */
export declare class AssetEntity {
    readonly chain: Chain;
    readonly symbol: string;
    readonly ticker: string;
    readonly type: string;
    readonly network: string;
    readonly name: string;
    decimal: number;
    isSynth: boolean;
    L1Chain: Chain;
    static fromAssetString(asset?: string): AssetEntity | null;
    /**
     *
     * @param urlEncodedAsset asset string from url
     * @returns btc.btc -> btc.btc, thor.btc.btc -> btc/btc
     */
    static decodeFromURL: (urlEncodedAsset: string) => AssetEntity | null;
    constructor(chain: Chain, symbol: string, isSynth?: boolean, ticker?: string);
    setDecimal: (decimal?: number) => void;
    getAssetObj(): {
        chain: Chain;
        symbol: string;
        ticker: string;
    };
    /**
     * convert asset entity to string
     * @returns L1 asset -> btc.btc, Synth asset -> btc/btc
     */
    toString(): string;
    toURLEncoded(): string;
    eq(asset: AssetEntity): boolean;
    shallowEq(asset: AssetEntity): boolean;
    isRUNE(): boolean;
    identifier(): string;
    toSynth(): AssetEntity;
}

export declare const BN_FORMAT: BigNumber.Format;

export declare const EMPTY_FORMAT: BigNumber.Format;

export declare const formatBigNumber: (bn: BigNumber, decimalPlaces?: number, rounding?: Rounding) => string;

export declare const getAssetShare: ({ liquidityUnits, poolUnits, assetDepth, }: ShareParams<{
    assetDepth: string;
}>) => Amount;

export declare const getAssetType: (chain: Chain, ticker: string, isSynth?: boolean) => "Synth" | "Native" | "GAIA" | "BEP2" | "BEP20" | "ERC20" | "AVAX" | "POLYGON" | "ARBITRUM" | "OPTIMISM";

export declare const getAsymmetricAssetShare: ({ liquidityUnits, poolUnits, assetDepth, }: ShareParams<{
    assetDepth: string;
}>) => Amount;

export declare const getAsymmetricAssetWithdrawAmount: ({ percent, assetDepth, liquidityUnits, poolUnits, }: ShareParams<{
    percent: number;
    assetDepth: string;
}>) => Amount;

/**
 *  Ref: https://gitlab.com/thorchain/thornode/-/issues/657
 *  share = (s * A * (2 * T^2 - 2 * T * s + s^2))/T^3
 *  s = stakeUnits for member (after factoring in withdrawBasisPoints)
 *  T = totalPoolUnits for pool
 *  A = assetDepth to be withdrawn
 *
 *  Formula:
 *  share = (s * A * (2 * T^2 - 2 * T * s + s^2))/T^3
 *  (part1 * (part2 - part3 + part4)) / part5
 */
export declare const getAsymmetricRuneShare: ({ liquidityUnits, poolUnits, runeDepth, }: ShareParams<{
    runeDepth: string;
}>) => Amount;

export declare const getAsymmetricRuneWithdrawAmount: ({ percent, runeDepth, liquidityUnits, poolUnits, }: ShareParams<{
    percent: number;
    runeDepth: string;
}>) => Amount;

export declare const getEstimatedPoolShare: ({ runeDepth, poolUnits, assetDepth, liquidityUnits, runeAmount, assetAmount, }: ShareParams<{
    runeAmount: string;
    assetAmount: string;
    runeDepth: string;
    assetDepth: string;
}>) => number;

export declare const getLiquiditySlippage: ({ runeAmount, assetAmount, runeDepth, assetDepth, }: PoolParams) => number;

export declare const getMemoFor: <T extends MemoType>(memoType: T, options: MemoOptions<T>) => string;

export declare const getMinAmountByChain: (chain: Chain) => AssetAmount;

export declare const getNetworkName: (chain: Chain, ticker: string) => string;

export declare const getRuneShare: ({ liquidityUnits, poolUnits, runeDepth, }: ShareParams<{
    runeDepth: string;
}>) => Amount;

export declare const getSignatureAssetFor: (signature: Signature, synth?: boolean) => AssetEntity;

export declare const getSymmetricWithdraw: ({ liquidityUnits, poolUnits, runeDepth, assetDepth, percent, }: ShareParams<{
    runeDepth: string;
    assetDepth: string;
    percent: number;
}>) => {
    assetAmount: Amount;
    runeAmount: Amount;
};

export declare const getTHORNameCost: (year: number) => number;

export declare const isGasAsset: (asset: AssetEntity) => boolean;

export declare type MemoOptions<T extends MemoType> = {
    [MemoType.BOND]: WithAddress;
    [MemoType.LEAVE]: WithAddress;
    [MemoType.CLOSE_LOAN]: WithAddress<{
        asset: string;
        minAmount?: string;
    }>;
    [MemoType.OPEN_LOAN]: WithAddress<{
        asset: string;
        minAmount?: string;
    }>;
    [MemoType.UNBOND]: WithAddress<{
        unbondAmount: number;
    }>;
    [MemoType.DEPOSIT]: WithChain<{
        symbol: string;
        address?: string;
        singleSide?: boolean;
    }>;
    [MemoType.WITHDRAW]: WithChain<{
        ticker: string;
        symbol: string;
        basisPoints: number;
        targetAssetString?: string;
        singleSide?: boolean;
    }>;
    [MemoType.THORNAME_REGISTER]: Omit<ThornameRegisterParam, 'preferredAsset' | 'expiryBlock'>;
}[T];

export declare class Pool {
    readonly asset: AssetEntity;
    readonly runeDepth: Amount;
    readonly assetDepth: Amount;
    readonly assetUSDPrice: Amount;
    readonly detail: PoolDetail;
    static fromPoolData(poolDetail: PoolDetail): Pool | null;
    constructor(asset: AssetEntity, runeDepth: Amount, assetDepth: Amount, detail: PoolDetail);
    get assetPriceInRune(): Amount;
    get runePriceInAsset(): Amount;
}

export declare interface PoolDetail {
    annualPercentageRate: string;
    asset: string;
    assetDepth: string;
    assetPrice: string;
    assetPriceUSD: string;
    liquidityUnits: string;
    loanCollateral: string;
    poolAPY: string;
    runeDepth: string;
    status: string;
    synthSupply: string;
    synthUnits: string;
    units: string;
    volume24h: string;
    saversAPR: string;
    saversDepth: string;
    saversUnits: string;
}

declare type PoolParams<T = {}> = T & {
    runeAmount: string;
    assetAmount: string;
    runeDepth: string;
    assetDepth: string;
};

export declare class Price extends Amount {
    readonly baseAsset: AssetEntity;
    readonly quoteAsset?: AssetEntity;
    readonly unitPrice: BigNumber;
    readonly price: BigNumber;
    readonly amount: Amount;
    constructor({ baseAsset, quoteAsset, unitPrice, pools, priceAmount, }: {
        baseAsset: AssetEntity;
        quoteAsset?: AssetEntity;
        unitPrice?: BigNumber;
        pools?: Pool[];
        priceAmount?: Amount;
    });
    raw(): BigNumber;
    invert(): BigNumber;
    toCurrencyFormat(decimalPlaces?: number, abbreviate?: boolean): string;
    toAbbreviateRaw(decimalPlaces?: number): string;
    toFixedRaw(decimalPlaces?: number, format?: BigNumber.Format, rounding?: Rounding): string;
    toFixedInverted(decimalPlaces?: number, format?: BigNumber.Format, rounding?: Rounding): string;
}

export declare enum Rounding {
    ROUND_DOWN = 0,
    ROUND_HALF_UP = 1,
    ROUND_UP = 2
}

declare type ShareParams<T = {}> = T & {
    liquidityUnits: string;
    poolUnits: string;
};

declare type Signature = Chain | 'USD' | 'ETH_THOR' | 'ETH_VTHOR';

export declare type ThornameRegisterParam = {
    name: string;
    chain: string;
    address: string;
    owner?: string;
    preferredAsset?: string;
    expiryBlock?: string;
};

export declare const validateTHORName: (name: string) => boolean;

declare type WithAddress<T = {}> = T & {
    address: string;
};

declare type WithChain<T = {}> = T & {
    chain: Chain;
};

export { }
