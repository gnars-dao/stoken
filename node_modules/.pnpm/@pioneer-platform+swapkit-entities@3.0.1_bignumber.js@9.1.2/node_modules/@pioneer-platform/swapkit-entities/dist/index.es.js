var q = Object.defineProperty;
var W = (t, s, e) => s in t ? q(t, s, { enumerable: !0, configurable: !0, writable: !0, value: e }) : t[s] = e;
var A = (t, s, e) => (W(t, typeof s != "symbol" ? s + "" : s, e), e);
import { BigNumber as S } from "bignumber.js";
var I = /* @__PURE__ */ ((t) => (t.THOR = "THOR", t.RUNE = "RUNE", t.ATOM = "ATOM", t.MUON = "MUON", t.USDC = "USDC", t))(I || {}), a = /* @__PURE__ */ ((t) => (t.INVALID_INPUT_PARAMETERS = "1000", t.UNKNOWN_PROVIDERS = "1001", t.CANNOT_FIND_INBOUND_ADDRESS = "1002", t.NO_INBOUND_ADDRESSES = "1003", t.CHAIN_HALTED_OR_UNSUPPORTED = "1004", t.MISSING_INPUT_PARAMETER = "1005", t.INVALID_TYPE_GENERIC = "1100", t.INVALID_NUMBER_STRING = "1101", t.INVALID_NUMBER = "1102", t.INVALID_BOOLEAN = "1103", t.INVALID_OBJECT = "1104", t.INVALID_ARRAY = "1105", t.SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2000", t.SELL_BUY_ASSETS_ARE_THE_SAME = "2001", t.MISSING_SOURCE_ADDRESS_FOR_SYNTH = "2002", t.AFF_ADDRESS_AND_BPS_OR_NEITHER = "2003", t.AFF_ADDRESS_TOO_LONG = "2004", t.AFF_BPS_INTEGER_0_100 = "2005", t.SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN = "2006", t.DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN = "2007", t.PREFERRED_PROFVIDER_NOT_SUPPORTED = "2008", t.DESTINATION_ADDRESS_SMART_CONTRACT = "2009", t.BUY_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2010", t.SOURCE_ADDRESS_SMART_CONTRACT = "2011", t.INVALID_PROVIDER = "2100", t.MISSING_CROSS_CHAIN_PROVIDER = "2101", t.MISSING_AVAX_PROVIDER = "2102", t.MISSING_BSC_PROVIDER = "2103", t.MISSING_ETH_PROVIDER = "2104", t.INVALID_PROVIDER_FOR_SWAP_OUT = "2105", t.MISSING_ARB_PROVIDER = "2106", t.INVALID_CHAIN = "2200", t.INVALID_ASSET = "2201", t.INVALID_ASSET_IDENTIFIER = "2202", t.UNSUPPORTED_CHAIN = "2204", t.UNSUPPORTED_ASSET = "2203", t.UNSUPPORTED_ASSET_FOR_SWAPOUT = "2205", t.THORNODE_QUOTE_GENERIC_ERROR = "3000", t.NOT_ENOUGH_SYNTH_BALANCE = "3001", t.SYNTH_MINTING_CAP_REACHED = "3002", t.INVALID_QUOTE_MODE = "4000", t.NO_QUOTES = "4001", t.SERVICE_UNAVAILABLE_GENERIC = "5000", t.MISSING_GAS_DATA_GENERIC = "5100", t.MISSING_TOKEN_INFO_GENERIC = "5200", t.CANT_FIND_TOKEN_LIST = "5201", t.NO_PRICE = "5202", t.PRICE_IS_STALE = "5203", t.ADDRESS_NOT_WHITELISTED = "6000", t.ADDRESS_ALREADY_CLAIMED = "6001", t.TEMPORARY_ERROR = "9999", t))(a || {});
a.INVALID_INPUT_PARAMETERS + "", a.UNKNOWN_PROVIDERS + "", a.CANNOT_FIND_INBOUND_ADDRESS + "", a.NO_INBOUND_ADDRESSES + "", a.CHAIN_HALTED_OR_UNSUPPORTED + "", a.MISSING_INPUT_PARAMETER + "", a.INVALID_TYPE_GENERIC + "", a.INVALID_NUMBER_STRING + "", a.INVALID_NUMBER + "", a.INVALID_BOOLEAN + "", a.INVALID_OBJECT + "", a.INVALID_ARRAY + "", a.SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER + "", a.SELL_BUY_ASSETS_ARE_THE_SAME + "", a.MISSING_SOURCE_ADDRESS_FOR_SYNTH + "", a.AFF_ADDRESS_AND_BPS_OR_NEITHER + "", a.AFF_ADDRESS_TOO_LONG + "", a.AFF_BPS_INTEGER_0_100 + "", a.SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN + "", a.DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN + "", a.PREFERRED_PROFVIDER_NOT_SUPPORTED + "", a.DESTINATION_ADDRESS_SMART_CONTRACT + "", a.BUY_AMOUNT_MUST_BE_POSITIVE_INTEGER + "", a.INVALID_PROVIDER + "", a.MISSING_CROSS_CHAIN_PROVIDER + "", a.MISSING_AVAX_PROVIDER + "", a.MISSING_BSC_PROVIDER + "", a.MISSING_ETH_PROVIDER + "", a.MISSING_ARB_PROVIDER + "", a.INVALID_PROVIDER_FOR_SWAP_OUT + "", a.INVALID_CHAIN + "", a.INVALID_ASSET + "", a.UNSUPPORTED_CHAIN + "", a.UNSUPPORTED_ASSET + "", a.UNSUPPORTED_ASSET_FOR_SWAPOUT + "", a.THORNODE_QUOTE_GENERIC_ERROR + "", a.NOT_ENOUGH_SYNTH_BALANCE + "", a.SYNTH_MINTING_CAP_REACHED + "", a.INVALID_QUOTE_MODE + "", a.NO_QUOTES + "", a.SERVICE_UNAVAILABLE_GENERIC + "", a.MISSING_GAS_DATA_GENERIC + "", a.MISSING_TOKEN_INFO_GENERIC + "", a.CANT_FIND_TOKEN_LIST + "", a.NO_PRICE + "", a.PRICE_IS_STALE + "", a.ADDRESS_NOT_WHITELISTED + "", a.ADDRESS_ALREADY_CLAIMED + "";
var r = /* @__PURE__ */ ((t) => (t.Arbitrum = "ARB", t.Avalanche = "AVAX", t.Binance = "BNB", t.BinanceSmartChain = "BSC", t.Bitcoin = "BTC", t.BitcoinCash = "BCH", t.Cosmos = "GAIA", t.Dogecoin = "DOGE", t.Ethereum = "ETH", t.Litecoin = "LTC", t.Optimism = "OP", t.Polygon = "MATIC", t.THORChain = "THOR", t))(r || {}), m = /* @__PURE__ */ ((t) => (t[t.ARB = 18] = "ARB", t[t.AVAX = 18] = "AVAX", t[t.BCH = 8] = "BCH", t[t.BNB = 8] = "BNB", t[t.BSC = 18] = "BSC", t[t.BTC = 8] = "BTC", t[t.DOGE = 8] = "DOGE", t[t.ETH = 18] = "ETH", t[t.GAIA = 6] = "GAIA", t[t.LTC = 8] = "LTC", t[t.MATIC = 18] = "MATIC", t[t.OP = 18] = "OP", t[t.THOR = 8] = "THOR", t))(m || {}), w = /* @__PURE__ */ ((t) => (t.Arbitrum = "42161", t.ArbitrumHex = "0xa4b1", t.Avalanche = "43114", t.AvalancheHex = "0xa86a", t.Binance = "Binance-Chain-Tigris", t.BinanceHex = "", t.BinanceSmartChain = "56", t.BinanceSmartChainHex = "0x38", t.Bitcoin = "bitcoin", t.BitcoinHex = "", t.BitcoinCash = "bitcoincash", t.BitcoinCashHex = "", t.Cosmos = "cosmoshub-4", t.CosmosHex = "", t.Dogecoin = "dogecoin", t.DogecoinHex = "", t.Ethereum = "1", t.EthereumHex = "0x1", t.Litecoin = "litecoin", t.LitecoinHex = "", t.Optimism = "10", t.OptimismHex = "0xa", t.Polygon = "137", t.PolygonHex = "0x89", t.THORChain = "thorchain-mainnet-v1", t.THORChainHex = "", t.THORChainStagenet = "thorchain-stagenet-v2", t))(w || {}), g = /* @__PURE__ */ ((t) => (t.Arbitrum = "https://arb1.arbitrum.io/rpc", t.Avalanche = "https://node-router.thorswap.net/avalanche-c", t.Binance = "", t.BinanceSmartChain = "https://bsc-dataseed.binance.org", t.Bitcoin = "https://node-router.thorswap.net/bitcoin", t.BitcoinCash = "https://node-router.thorswap.net/bitcoin-cash", t.Cosmos = "https://node-router.thorswap.net/cosmos/rpc", t.Dogecoin = "https://node-router.thorswap.net/dogecoin", t.Ethereum = "https://node-router.thorswap.net/ethereum", t.Litecoin = "https://node-router.thorswap.net/litecoin", t.Optimism = "https://mainnet.optimism.io", t.Polygon = "https://polygon-rpc.com", t.THORChain = "https://rpc.thorswap.net", t.THORChainStagenet = "https://stagenet-rpc.ninerealms.com", t))(g || {});
const P = Object.values(r), Y = Object.keys(r), M = P.reduce(
  (t, s) => {
    const e = Y.find((i) => r[i] === s);
    return e && (t[s] = e), t;
  },
  {}
);
P.reduce(
  (t, s) => (t[s] = w[M[s]], t),
  {}
);
P.reduce(
  (t, s) => (t[s] = g[M[s]], t),
  {}
);
P.reduce(
  (t, s) => (t[s] = w[`${M[s]}Hex`], t),
  {}
);
var d = /* @__PURE__ */ ((t) => (t.BOND = "BOND", t.DEPOSIT = "+", t.LEAVE = "LEAVE", t.THORNAME_REGISTER = "~", t.UNBOND = "UNBOND", t.WITHDRAW = "-", t.OPEN_LOAN = "$+", t.CLOSE_LOAN = "$-", t))(d || {});
const k = (t, s, e = !1) => {
  if (e)
    return "Synth";
  switch (t) {
    case r.Bitcoin:
    case r.BitcoinCash:
    case r.Dogecoin:
    case r.Litecoin:
    case r.THORChain:
      return "Native";
    case r.Cosmos:
      return s === "ATOM" ? "Native" : "GAIA";
    case r.Binance:
      return s === r.Binance ? "Native" : "BEP2";
    case r.BinanceSmartChain:
      return s === r.Binance ? "Native" : "BEP20";
    case r.Ethereum:
      return s === r.Ethereum ? "Native" : "ERC20";
    case r.Avalanche:
      return s === r.Avalanche ? "Native" : "AVAX";
    case r.Polygon:
      return s === r.Polygon ? "Native" : "POLYGON";
    case r.Arbitrum:
      return [r.Ethereum, r.Arbitrum].includes(s) ? "Native" : "ARBITRUM";
    case r.Optimism:
      return [r.Ethereum, r.Optimism].includes(s) ? "Native" : "OPTIMISM";
    default:
      return t;
  }
}, l = {
  prefix: "",
  decimalSeparator: ".",
  groupSeparator: ",",
  groupSize: 3,
  secondaryGroupSize: 0,
  fractionGroupSeparator: " ",
  fractionGroupSize: 0,
  suffix: ""
};
var p = /* @__PURE__ */ ((t) => (t[t.ROUND_DOWN = 0] = "ROUND_DOWN", t[t.ROUND_HALF_UP = 1] = "ROUND_HALF_UP", t[t.ROUND_UP = 2] = "ROUND_UP", t))(p || {}), _ = /* @__PURE__ */ ((t) => (t[t.BASE_AMOUNT = 0] = "BASE_AMOUNT", t[t.ASSET_AMOUNT = 1] = "ASSET_AMOUNT", t))(_ || {});
const L = {
  0: S.ROUND_DOWN,
  1: S.ROUND_HALF_UP,
  2: S.ROUND_UP
}, Q = {
  groupSeparator: "",
  decimalSeparator: "."
};
class o {
  constructor(s, e = 0, i) {
    A(this, "assetAmount");
    A(this, "baseAmount");
    A(this, "decimal");
    this.decimal = i;
    const n = 10 ** i;
    e === 0 ? (this.baseAmount = new S(s), this.assetAmount = this.baseAmount.dividedBy(n)) : (this.assetAmount = new S(s), this.baseAmount = this.assetAmount.multipliedBy(n)), this.baseAmount = new S(this.baseAmount.integerValue(S.ROUND_DOWN));
  }
  static fromMidgard(s) {
    return new o(s || 0, 0, m.THOR);
  }
  static fromBaseAmount(s, e) {
    return new o(s, 0, e);
  }
  static fromAssetAmount(s, e) {
    return new o(s, 1, e);
  }
  static fromNormalAmount(s) {
    return new o(s || 0, 1, 1);
  }
  static sorter(s, e) {
    if (s.decimal !== e.decimal)
      throw new Error("Decimal must be same");
    return s.assetAmount.minus(e.assetAmount).toNumber();
  }
  add(s) {
    return new o(
      this.assetAmount.plus(s.assetAmount),
      1,
      this.decimal
    );
  }
  sub(s) {
    return new o(
      this.assetAmount.minus(s.assetAmount),
      1,
      this.decimal
    );
  }
  mul(s) {
    return s instanceof o ? new o(
      this.assetAmount.multipliedBy(s.assetAmount),
      1,
      this.decimal
    ) : new o(this.assetAmount.multipliedBy(s), 1, this.decimal);
  }
  div(s) {
    return s instanceof o ? new o(
      this.assetAmount.dividedBy(s.assetAmount),
      1,
      this.decimal
    ) : new o(this.assetAmount.dividedBy(s), 1, this.decimal);
  }
  gte(s) {
    return s instanceof o ? this.assetAmount.isGreaterThanOrEqualTo(s.assetAmount) : this.assetAmount.isGreaterThanOrEqualTo(s);
  }
  gt(s) {
    return s instanceof o ? this.assetAmount.isGreaterThan(s.assetAmount) : this.assetAmount.isGreaterThan(s);
  }
  lte(s) {
    return s instanceof o ? this.assetAmount.isLessThanOrEqualTo(s.assetAmount) : this.assetAmount.isLessThanOrEqualTo(s);
  }
  lt(s) {
    return s instanceof o ? this.assetAmount.isLessThan(s.assetAmount) : this.assetAmount.isLessThan(s);
  }
  eq(s) {
    return s instanceof o ? this.assetAmount.isEqualTo(s.assetAmount) : this.assetAmount.isEqualTo(s);
  }
  toSignificant(s = 8, e = 8, i = l, n = 0) {
    return this.toSignificantBigNumber(s, i, n).decimalPlaces(e).toFormat();
  }
  toFixedDecimal(s = 8, e = Q, i = 0) {
    if (!Number.isInteger(s))
      throw new Error(`${s} is not an integer.`);
    if (s <= 0)
      throw new Error(`${s} is not positive.`);
    return S.config({ FORMAT: e }), new S(this.assetAmount.toFixed(s, L[i])).toFormat();
  }
  toFixed(s = 8, e = l, i = 0) {
    return this.toFixedDecimal(s, e, i);
  }
  toAbbreviate(s = 2) {
    let e = this.assetAmount.toNumber();
    const i = ["", "K", "M", "B", "T", "Q", "Q", "s"];
    let n = 0;
    for (; e >= 1e3; )
      e /= 1e3, n++;
    return `${e.toFixed(s)}${n > 0 ? ` ${i[n]}` : ""}`;
  }
  toMidgard() {
    return new o(
      new S(
        this.baseAmount.dividedBy(10 ** this.decimal).multipliedBy(10 ** m.THOR).toFixed()
      ),
      0,
      m.THOR
    );
  }
  toSignificantBigNumber(s = 8, e = l, i = 0) {
    if (!Number.isInteger(s))
      throw new Error(`${s} is not an integer.`);
    if (s <= 0)
      throw new Error(`${s} is not positive.`);
    return S.config({ FORMAT: e }), new S(this.assetAmount.toPrecision(s, L[i]));
  }
}
const rt = (t, s = 8, e = 0) => (S.config({ FORMAT: l }), new S(t.toFixed(s, L[e])).toFormat()), K = ({
  liquidityUnits: t,
  poolUnits: s,
  runeDepth: e
}) => o.fromBaseAmount(e, m.THOR).mul(t).div(s), X = ({
  liquidityUnits: t,
  poolUnits: s,
  assetDepth: e
}) => o.fromBaseAmount(e, m.THOR).mul(t).div(s), j = ({
  liquidityUnits: t,
  poolUnits: s,
  runeDepth: e
}) => {
  const i = o.fromMidgard(t), n = o.fromBaseAmount(s, m.THOR), c = o.fromBaseAmount(e, m.THOR), h = i.mul(c), E = n.mul(n).mul(2), u = n.mul(i).mul(2), N = i.mul(i), T = n.mul(n).mul(n);
  return h.mul(E.sub(u).add(N)).div(T);
}, z = ({
  liquidityUnits: t,
  poolUnits: s,
  assetDepth: e
}) => {
  const i = o.fromMidgard(t), n = o.fromBaseAmount(s, m.THOR), c = o.fromBaseAmount(e, m.THOR), h = i.mul(c), E = n.mul(n).mul(2), u = n.mul(i).mul(2), N = i.mul(i), T = h.mul(E.sub(u).add(N)), f = n.mul(n).mul(n);
  return T.div(f);
}, ot = ({
  percent: t,
  runeDepth: s,
  liquidityUnits: e,
  poolUnits: i
}) => j({ runeDepth: s, liquidityUnits: e, poolUnits: i }).mul(t), at = ({
  percent: t,
  assetDepth: s,
  liquidityUnits: e,
  poolUnits: i
}) => z({ assetDepth: s, liquidityUnits: e, poolUnits: i }).mul(t), ct = ({
  liquidityUnits: t,
  poolUnits: s,
  runeDepth: e,
  assetDepth: i,
  percent: n
}) => ({
  assetAmount: X({ liquidityUnits: t, poolUnits: s, assetDepth: i }).mul(n),
  runeAmount: K({ liquidityUnits: t, poolUnits: s, runeDepth: e }).mul(n)
}), ut = ({
  runeDepth: t,
  poolUnits: s,
  assetDepth: e,
  liquidityUnits: i,
  runeAmount: n,
  assetAmount: c
}) => {
  const h = o.fromBaseAmount(t, m.THOR), E = o.fromBaseAmount(e, m.THOR), u = o.fromBaseAmount(s, m.THOR), N = o.fromBaseAmount(n, m.THOR), T = o.fromBaseAmount(c, m.THOR), f = N.mul(E), C = T.mul(h), F = N.mul(T), G = h.mul(E), $ = u.mul(f.add(C.add(F.mul(2)))), y = f.add(C.add(G.mul(2))), v = $.div(y), H = o.fromMidgard(i).add(v);
  if (v.assetAmount.toNumber() === 0)
    return H.div(u).assetAmount.toNumber();
  const x = u.add(H);
  return H.div(x).assetAmount.toNumber();
}, At = ({
  runeAmount: t,
  assetAmount: s,
  runeDepth: e,
  assetDepth: i
}) => {
  const n = o.fromBaseAmount(e, m.THOR), c = o.fromBaseAmount(i, m.THOR), h = o.fromBaseAmount(s, m.THOR), E = o.fromBaseAmount(t, m.THOR), u = h.mul(n).sub(c.mul(E)), N = c.mul(E).add(n.mul(c));
  return u.div(N).assetAmount.absoluteValue().toNumber();
}, J = ({
  symbol: t,
  ticker: s,
  chain: e
}) => e === "ETH" && s !== "ETH" ? `${s}-${t.slice(-3)}` : t, mt = (t, s) => {
  switch (t) {
    case d.LEAVE:
    case d.BOND: {
      const { address: e } = s;
      return `${t}:${e}`;
    }
    case d.UNBOND: {
      const { address: e, unbondAmount: i } = s;
      return `${t}:${e}:${i * 10 ** 8}`;
    }
    case d.THORNAME_REGISTER: {
      const { name: e, chain: i, address: n, owner: c } = s;
      return `${t}:${e}:${i}:${n}${c ? `:${c}` : ""}`;
    }
    case d.DEPOSIT: {
      const { chain: e, symbol: i, address: n, singleSide: c } = s;
      return c ? `${t}:${e}/${i}::t:0` : `${t}:${e}.${i}:${n || ""}:t:0`;
    }
    case d.WITHDRAW: {
      const { chain: e, ticker: i, symbol: n, basisPoints: c, targetAssetString: h, singleSide: E } = s, u = !E && h ? `:${h}` : "", N = J({ chain: e, symbol: n, ticker: i });
      return `${t}:${e}${E ? "/" : "."}${N}:${c}${u}`;
    }
    case d.OPEN_LOAN:
    case d.CLOSE_LOAN: {
      const { asset: e, address: i } = s;
      return `${t}:${e}:${i}`;
    }
    default:
      return "";
  }
}, Z = (t, s) => t === r.Bitcoin ? "Bitcoin" : t === r.Dogecoin ? "Dogecoin" : t === r.Litecoin ? "Litecoin" : t === r.BitcoinCash ? "Bitcoin Cash" : t === r.Ethereum && s === "ETH" ? "Ethereum" : s, ht = (t) => {
  if (t < 0)
    throw new Error("Invalid number of year");
  return 10 + t;
}, Et = (t) => {
  if (t.length > 30)
    return !1;
  const s = /^[a-zA-Z0-9+_-]+$/g;
  return !!t.match(s);
}, B = class B {
  constructor(s, e, i = !1, n) {
    A(this, "chain");
    A(this, "symbol");
    A(this, "ticker");
    A(this, "type");
    A(this, "network");
    A(this, "name");
    A(this, "decimal");
    A(this, "isSynth", !1);
    A(this, "L1Chain");
    A(this, "setDecimal", (s) => {
      this.decimal = s || m[this.chain] || m.THOR;
    });
    this.chain = s, this.symbol = e.toUpperCase(), this.ticker = n || e.toUpperCase().split("-")[0], this.type = k(s, this.ticker, i), this.name = i ? `Synth ${this.ticker}` : this.ticker, this.network = Z(s, this.ticker), this.decimal = i ? m.THOR : m[s], this.isSynth = i, this.L1Chain = i ? r.THORChain : s;
  }
  static fromAssetString(s) {
    var u;
    if (!s)
      return null;
    const e = s.includes("/"), [i, ...n] = s.split(e ? "/" : "."), c = n.join("."), h = (u = c == null ? void 0 : c.split("-")) == null ? void 0 : u[0];
    return i && c && h ? new B(i, c, e) : null;
  }
  getAssetObj() {
    if (this.isSynth) {
      const s = `${this.chain.toLowerCase()}/${this.symbol.toLowerCase()}`;
      return {
        chain: r.THORChain,
        symbol: s,
        ticker: s
      };
    }
    return { chain: this.chain, symbol: this.symbol, ticker: this.ticker };
  }
  /**
   * convert asset entity to string
   * @returns L1 asset -> btc.btc, Synth asset -> btc/btc
   */
  toString() {
    return `${this.chain}${this.isSynth ? "/" : "."}${this.symbol}`;
  }
  toURLEncoded() {
    return `${this.isSynth ? "THOR." : ""}${this.chain}.${this.symbol}`;
  }
  // full compare chain, symbol, synth
  eq(s) {
    return this.chain === s.chain && this.symbol.toUpperCase() === s.symbol.toUpperCase() && this.ticker.toUpperCase() === s.ticker.toUpperCase() && this.isSynth === s.isSynth;
  }
  // compare chain, symbol but not synth
  shallowEq(s) {
    return this.chain === s.chain && this.symbol.toUpperCase() === s.symbol.toUpperCase() && this.ticker.toUpperCase() === s.ticker.toUpperCase();
  }
  isRUNE() {
    return this.eq(b(r.THORChain));
  }
  identifier() {
    return `${this.chain}.${this.symbol}`;
  }
  toSynth() {
    return this.isSynth ? this : new B(r.THORChain, `${this.chain}/${this.symbol}`, !0);
  }
};
/**
 *
 * @param urlEncodedAsset asset string from url
 * @returns btc.btc -> btc.btc, thor.btc.btc -> btc/btc
 */
A(B, "decodeFromURL", (s) => {
  var i, n, c;
  let e = s.toUpperCase();
  return e.startsWith("THOR.") && ((i = e.split("THOR.")) == null ? void 0 : i[1]) !== "RUNE" && (e = (c = (n = e.split("THOR.")) == null ? void 0 : n[1]) == null ? void 0 : c.replace(".", "/")), B.fromAssetString(e);
});
let R = B;
const tt = "THOR-0xa5f2211B9b8170F694421f2046281775E8468044", st = "VTHOR-0x815C23eCA83261b6Ec689b60Cc4a58b54BC24D8D", O = {}, b = (t, s = !1) => {
  if (O[t])
    return O[t];
  switch (t) {
    case r.Avalanche:
    case r.Binance:
    case r.Bitcoin:
    case r.BitcoinCash:
    case r.Dogecoin:
    case r.Ethereum:
    case r.Litecoin: {
      const e = new R(t, t, s);
      return O[t] = e, e;
    }
    case r.Optimism:
    case r.Arbitrum: {
      const e = new R(t, r.Ethereum, s);
      return e.setDecimal(18), O[t] = e, e;
    }
    case r.BinanceSmartChain: {
      const e = new R(t, r.Binance, s);
      return e.setDecimal(18), O[t] = e, e;
    }
    case r.Polygon: {
      const e = new R(t, t, s);
      return e.setDecimal(18), O[t] = e, e;
    }
    case r.Cosmos: {
      const e = new R(t, I.ATOM, s, I.ATOM);
      return O[t] = e, e;
    }
    case r.THORChain: {
      const e = new R(r.THORChain, I.RUNE, s, I.RUNE);
      return O[t] = e, e;
    }
    case "USD": {
      const e = new R(r.THORChain, "USD-USD", s, "USD-USD");
      return O[t] = e, e;
    }
    case "ETH_THOR": {
      const e = new R(r.Ethereum, tt, s);
      return e.setDecimal(18), O[t] = e, e;
    }
    case "ETH_VTHOR": {
      const e = new R(r.Ethereum, st, s);
      return e.setDecimal(18), O[t] = e, e;
    }
    default:
      return new R(r.THORChain, I.RUNE, s, I.RUNE);
  }
}, St = (t) => t.eq(b(t.chain)), U = (t, s) => s.find((e) => t.shallowEq(e.asset));
class et extends o {
  constructor({
    baseAsset: e,
    quoteAsset: i,
    unitPrice: n,
    pools: c,
    priceAmount: h
  }) {
    const E = o.fromAssetAmount(
      h ? h.assetAmount : 1,
      e.decimal
    );
    super(E.assetAmount, _.ASSET_AMOUNT, e.decimal);
    A(this, "baseAsset");
    A(this, "quoteAsset");
    A(this, "unitPrice");
    A(this, "price");
    A(this, "amount");
    if (this.amount = E, this.baseAsset = e, this.quoteAsset = i, n !== void 0)
      this.unitPrice = n, this.price = E.assetAmount.multipliedBy(n);
    else {
      if (!c)
        throw new Error("Pools must be provided if unitPrice omitted");
      if (this.unitPrice = new S(0), i)
        if (e.isRUNE() && !i.isRUNE()) {
          const u = U(i, c);
          u && (this.unitPrice = u.runePriceInAsset.assetAmount);
        } else if (!e.isRUNE() && i.isRUNE()) {
          const u = U(e, c);
          u && (this.unitPrice = u.assetPriceInRune.assetAmount);
        } else if (!e.isRUNE() && !i.isRUNE()) {
          const u = U(e, c), N = U(i, c);
          u && N && (this.unitPrice = u.assetPriceInRune.div(
            N.assetPriceInRune
          ).assetAmount);
        } else
          this.unitPrice = new S(1);
      else if (e.isRUNE()) {
        const u = c == null ? void 0 : c[0];
        u && (this.unitPrice = u.runePriceInAsset.mul(u.assetUSDPrice).assetAmount);
      } else {
        const u = U(e, c);
        u && (this.unitPrice = u.assetUSDPrice.assetAmount);
      }
      this.price = this.unitPrice.multipliedBy(E.assetAmount);
    }
  }
  raw() {
    return this.price;
  }
  invert() {
    return new S(1).dividedBy(this.raw());
  }
  toCurrencyFormat(e = 8, i = !0) {
    var h;
    const n = i ? this.toAbbreviateRaw(e) : this.toFixedRaw(e);
    return !this.quoteAsset || this.quoteAsset.ticker === "USD" ? `$${n}` : `${n} ${(h = this.quoteAsset) == null ? void 0 : h.ticker}`;
  }
  toAbbreviateRaw(e = 2) {
    return o.fromAssetAmount(this.price, 8).toAbbreviate(e);
  }
  toFixedRaw(e = 8, i = l, n = p.ROUND_DOWN) {
    return o.fromAssetAmount(this.price, 8).toFixed(e, i, n);
  }
  toFixedInverted(e = 8, i = l, n = p.ROUND_DOWN) {
    return o.fromAssetAmount(this.invert(), 8).toFixed(e, i, n);
  }
}
class D extends o {
  constructor(e, i) {
    super(i.assetAmount, _.ASSET_AMOUNT, i.decimal);
    A(this, "asset");
    A(this, "amount");
    this.asset = e, this.amount = new o(i.assetAmount, _.ASSET_AMOUNT, i.decimal);
  }
  add(e) {
    if (!this.asset.shallowEq(e.asset))
      throw new Error("asset must be same");
    return new D(this.asset, this.amount.add(e.amount));
  }
  sub(e) {
    if (!this.asset.shallowEq(e.asset))
      throw new Error("asset must be same");
    return new D(this.asset, this.amount.sub(e.amount));
  }
  mul(e) {
    let i;
    return e instanceof o ? i = new o(
      this.assetAmount.multipliedBy(e.assetAmount),
      _.ASSET_AMOUNT,
      this.decimal
    ) : i = new o(
      this.assetAmount.multipliedBy(e),
      _.ASSET_AMOUNT,
      this.decimal
    ), new D(this.asset, i);
  }
  div(e) {
    let i;
    return e instanceof o ? i = new o(
      this.assetAmount.dividedBy(e.assetAmount),
      _.ASSET_AMOUNT,
      this.decimal
    ) : i = new o(this.assetAmount.dividedBy(e), _.ASSET_AMOUNT, this.decimal), new D(this.asset, i);
  }
  toCurrencyFormat({
    significantDigits: e,
    format: i,
    rounding: n
  } = {
    significantDigits: 6,
    format: l,
    rounding: p.ROUND_DOWN
  }, c = !1) {
    const h = super.toSignificant(e, 8, i, n);
    return c ? `${this.asset.ticker} ${h}` : `${h} ${this.asset.ticker}`;
  }
  totalPriceIn(e, i) {
    return new et({
      baseAsset: this.asset,
      quoteAsset: e,
      pools: i,
      priceAmount: o.fromAssetAmount(this.assetAmount, this.decimal)
    });
  }
}
const Nt = (t) => {
  const s = b(t), e = [r.Bitcoin, r.Litecoin, r.BitcoinCash].includes(t) ? (
    // 10001 satoshi
    10001
  ) : [r.Dogecoin].includes(t) ? (
    // 1 DOGE
    100000001
  ) : [r.Avalanche, r.Ethereum, r.BinanceSmartChain].includes(t) ? (
    //  10 gwei
    10 * 10 ** 9
  ) : t === r.THORChain ? (
    // 0 RUNE
    0
  ) : 1;
  return new D(s, o.fromBaseAmount(e, s.decimal));
};
class V {
  constructor(s, e, i, n) {
    A(this, "asset");
    A(this, "runeDepth");
    A(this, "assetDepth");
    A(this, "assetUSDPrice");
    A(this, "detail");
    this.asset = s, this.runeDepth = e, this.assetDepth = i, this.detail = n, this.assetUSDPrice = o.fromAssetAmount(n.assetPriceUSD, m.THOR);
  }
  static fromPoolData(s) {
    const { asset: e, runeDepth: i, assetDepth: n } = s, c = R.fromAssetString(e);
    if (c && i && n) {
      const h = o.fromBaseAmount(i, m.THOR), E = o.fromBaseAmount(n, m.THOR);
      return new V(c, h, E, s);
    }
    return null;
  }
  get assetPriceInRune() {
    return this.runeDepth.div(this.assetDepth);
  }
  get runePriceInAsset() {
    return this.assetDepth.div(this.runeDepth);
  }
}
export {
  o as Amount,
  _ as AmountType,
  D as AssetAmount,
  R as AssetEntity,
  l as BN_FORMAT,
  Q as EMPTY_FORMAT,
  V as Pool,
  et as Price,
  p as Rounding,
  rt as formatBigNumber,
  X as getAssetShare,
  k as getAssetType,
  z as getAsymmetricAssetShare,
  at as getAsymmetricAssetWithdrawAmount,
  j as getAsymmetricRuneShare,
  ot as getAsymmetricRuneWithdrawAmount,
  ut as getEstimatedPoolShare,
  At as getLiquiditySlippage,
  mt as getMemoFor,
  Nt as getMinAmountByChain,
  Z as getNetworkName,
  K as getRuneShare,
  b as getSignatureAssetFor,
  ct as getSymmetricWithdraw,
  ht as getTHORNameCost,
  St as isGasAsset,
  Et as validateTHORName
};
