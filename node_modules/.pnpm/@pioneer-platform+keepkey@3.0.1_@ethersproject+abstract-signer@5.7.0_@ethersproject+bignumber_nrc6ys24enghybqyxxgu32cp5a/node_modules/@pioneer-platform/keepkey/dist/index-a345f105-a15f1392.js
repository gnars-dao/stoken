import { c as m, l as Ue, m as z, d as q, h as H, a as le, b as pe, t as fe, s as Je } from "./index-0d0514da.js";
import { b as V } from "./index-8e30cada-963d49fd.js";
import { b as Me, d as X, a as Ke } from "./index-005ea00d-254e56cb.js";
import "fs";
import "path";
import "buffer";
import "events";
import "util";
import "string_decoder";
import "assert";
function Be(e, r) {
  for (var o = 0; o < r.length; o++) {
    const u = r[o];
    if (typeof u != "string" && !Array.isArray(u)) {
      for (const c in u)
        if (c !== "default" && !(c in e)) {
          const l = Object.getOwnPropertyDescriptor(u, c);
          l && Object.defineProperty(e, c, l.get ? l : {
            enumerable: !0,
            get: () => u[c]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var _e = {}, Z = {};
Object.defineProperty(Z, "__esModule", { value: !0 });
Z.parseCoins = void 0;
function De(e) {
  return e.replace(/\s/g, "").split(",").filter(Boolean).map((r) => {
    const o = r.match(/^([0-9]+)([a-zA-Z][a-zA-Z0-9/]{2,127})$/);
    if (!o)
      throw new Error("Got an invalid coin string");
    return {
      amount: o[1].replace(/^0+/, "") || "0",
      denom: o[2]
    };
  });
}
Z.parseCoins = De;
var Y = {};
Object.defineProperty(Y, "__esModule", { value: !0 });
Y.decodeTxRaw = void 0;
const re = fe;
function Ce(e) {
  const r = re.TxRaw.decode(e);
  return {
    authInfo: re.AuthInfo.decode(r.authInfoBytes),
    body: re.TxBody.decode(r.bodyBytes),
    signatures: r.signatures
  };
}
Y.decodeTxRaw = Ce;
var U = {}, w = {}, Ie = m && m.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(w, "__esModule", { value: !0 });
w.makeSignBytes = w.makeSignDoc = w.makeAuthInfoBytes = void 0;
const ge = Me, We = Je, $ = fe, ye = Ie(Ue);
function Fe(e, r) {
  return e.map(({ pubkey: o, sequence: u }) => ({
    publicKey: o,
    modeInfo: {
      single: { mode: r }
    },
    sequence: ye.default.fromNumber(u)
  }));
}
function ze(e, r, o, u, c, l = We.SignMode.SIGN_MODE_DIRECT) {
  (0, ge.assert)(u === void 0 || typeof u == "string", "feeGranter must be undefined or string"), (0, ge.assert)(c === void 0 || typeof c == "string", "feePayer must be undefined or string");
  const p = $.AuthInfo.fromPartial({
    signerInfos: Fe(e, l),
    fee: {
      amount: [...r],
      gasLimit: ye.default.fromNumber(o),
      granter: u,
      payer: c
    }
  });
  return $.AuthInfo.encode(p).finish();
}
w.makeAuthInfoBytes = ze;
function He(e, r, o, u) {
  return {
    bodyBytes: e,
    authInfoBytes: r,
    chainId: o,
    accountNumber: ye.default.fromNumber(u)
  };
}
w.makeSignDoc = He;
function Ge({ accountNumber: e, authInfoBytes: r, bodyBytes: o, chainId: u }) {
  const c = $.SignDoc.fromPartial({
    accountNumber: e,
    authInfoBytes: r,
    bodyBytes: o,
    chainId: u
  });
  return $.SignDoc.encode(c).finish();
}
w.makeSignBytes = Ge;
var me = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.decrypt = e.encrypt = e.supportedAlgorithms = e.executeKdf = e.cosmjsSalt = void 0;
  const r = X, o = q;
  e.cosmjsSalt = (0, o.toAscii)("The CosmJS salt.");
  async function u(p, b) {
    switch (b.algorithm) {
      case "argon2id": {
        const h = b.params;
        if (!(0, r.isArgon2idOptions)(h))
          throw new Error("Invalid format of argon2id params");
        return r.Argon2id.execute(p, e.cosmjsSalt, h);
      }
      default:
        throw new Error("Unsupported KDF algorithm");
    }
  }
  e.executeKdf = u, e.supportedAlgorithms = {
    xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
  };
  async function c(p, b, h) {
    switch (h.algorithm) {
      case e.supportedAlgorithms.xchacha20poly1305Ietf: {
        const k = r.Random.getBytes(r.xchacha20NonceLength);
        return new Uint8Array([
          ...k,
          ...await r.Xchacha20poly1305Ietf.encrypt(p, b, k)
        ]);
      }
      default:
        throw new Error(`Unsupported encryption algorithm: '${h.algorithm}'`);
    }
  }
  e.encrypt = c;
  async function l(p, b, h) {
    switch (h.algorithm) {
      case e.supportedAlgorithms.xchacha20poly1305Ietf: {
        const k = p.slice(0, r.xchacha20NonceLength);
        return r.Xchacha20poly1305Ietf.decrypt(p.slice(r.xchacha20NonceLength), b, k);
      }
      default:
        throw new Error(`Unsupported encryption algorithm: '${h.algorithm}'`);
    }
  }
  e.decrypt = l;
})(me);
Object.defineProperty(U, "__esModule", { value: !0 });
U.DirectSecp256k1HdWallet = U.extractKdfConfiguration = void 0;
const ae = V, v = X, D = q, _ = Me, Le = w, C = me, L = "directsecp256k1hdwallet-v1", $e = {
  algorithm: "argon2id",
  params: {
    outputLength: 32,
    opsLimit: 24,
    memLimitKib: 12 * 1024
  }
};
function qe(e) {
  return !(!(0, _.isNonNullObject)(e) || typeof e.hdPath != "string" || typeof e.prefix != "string");
}
function Ve(e) {
  return e.kdf;
}
function Xe(e) {
  const r = JSON.parse(e);
  if (!(0, _.isNonNullObject)(r))
    throw new Error("Root document is not an object.");
  switch (r.type) {
    case L:
      return Ve(r);
    default:
      throw new Error("Unsupported serialization type");
  }
}
U.extractKdfConfiguration = Xe;
const ke = {
  bip39Password: "",
  hdPaths: [(0, ae.makeCosmoshubPath)(0)],
  prefix: "cosmos"
};
class M {
  /**
   * Restores a wallet from the given BIP39 mnemonic.
   *
   * @param mnemonic Any valid English mnemonic.
   * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
   */
  static async fromMnemonic(r, o = {}) {
    const u = new v.EnglishMnemonic(r), c = await v.Bip39.mnemonicToSeed(u, o.bip39Password);
    return new M(u, {
      ...o,
      seed: c
    });
  }
  /**
   * Generates a new wallet with a BIP39 mnemonic of the given length.
   *
   * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
   * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
   */
  static async generate(r = 12, o = {}) {
    const u = 4 * Math.floor(11 * r / 33), c = v.Random.getBytes(u), l = v.Bip39.encode(c);
    return M.fromMnemonic(l.toString(), o);
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * @param password The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  static async deserialize(r, o) {
    const u = JSON.parse(r);
    if (!(0, _.isNonNullObject)(u))
      throw new Error("Root document is not an object.");
    switch (u.type) {
      case L:
        return M.deserializeTypeV1(r, o);
      default:
        throw new Error("Unsupported serialization type");
    }
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
   * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
   * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
   */
  static async deserializeWithEncryptionKey(r, o) {
    const u = JSON.parse(r);
    if (!(0, _.isNonNullObject)(u))
      throw new Error("Root document is not an object.");
    const c = u;
    switch (c.type) {
      case L: {
        const l = await (0, C.decrypt)((0, D.fromBase64)(c.data), o, c.encryption), p = JSON.parse((0, D.fromUtf8)(l)), { mnemonic: b, accounts: h } = p;
        if ((0, _.assert)(typeof b == "string"), !Array.isArray(h))
          throw new Error("Property 'accounts' is not an array");
        if (!h.every((S) => qe(S)))
          throw new Error("Account is not in the correct format.");
        const k = h[0].prefix;
        if (!h.every(({ prefix: S }) => S === k))
          throw new Error("Accounts do not all have the same prefix");
        const P = h.map(({ hdPath: S }) => (0, v.stringToPath)(S));
        return M.fromMnemonic(b, {
          hdPaths: P,
          prefix: k
        });
      }
      default:
        throw new Error("Unsupported serialization type");
    }
  }
  static async deserializeTypeV1(r, o) {
    const u = JSON.parse(r);
    if (!(0, _.isNonNullObject)(u))
      throw new Error("Root document is not an object.");
    const c = await (0, C.executeKdf)(o, u.kdf);
    return M.deserializeWithEncryptionKey(r, c);
  }
  constructor(r, o) {
    const u = o.prefix ?? ke.prefix, c = o.hdPaths ?? ke.hdPaths;
    this.secret = r, this.seed = o.seed, this.accounts = c.map((l) => ({
      hdPath: l,
      prefix: u
    }));
  }
  get mnemonic() {
    return this.secret.toString();
  }
  async getAccounts() {
    return (await this.getAccountsWithPrivkeys()).map(({ algo: r, pubkey: o, address: u }) => ({
      algo: r,
      pubkey: o,
      address: u
    }));
  }
  async signDirect(r, o) {
    const u = (await this.getAccountsWithPrivkeys()).find(({ address: S }) => S === r);
    if (u === void 0)
      throw new Error(`Address ${r} not found in wallet`);
    const { privkey: c, pubkey: l } = u, p = (0, Le.makeSignBytes)(o), b = (0, v.sha256)(p), h = await v.Secp256k1.createSignature(b, c), k = new Uint8Array([...h.r(32), ...h.s(32)]), P = (0, ae.encodeSecp256k1Signature)(l, k);
    return {
      signed: o,
      signature: P
    };
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * @param password The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  async serialize(r) {
    const o = $e, u = await (0, C.executeKdf)(r, o);
    return this.serializeWithEncryptionKey(u, o);
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
   * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF options. If this
   * is not the case, the wallet cannot be restored with the original password.
   */
  async serializeWithEncryptionKey(r, o) {
    const u = {
      mnemonic: this.mnemonic,
      accounts: this.accounts.map(({ hdPath: h, prefix: k }) => ({
        hdPath: (0, v.pathToString)(h),
        prefix: k
      }))
    }, c = (0, D.toUtf8)(JSON.stringify(u)), l = {
      algorithm: C.supportedAlgorithms.xchacha20poly1305Ietf
    }, p = await (0, C.encrypt)(c, r, l), b = {
      type: L,
      kdf: o,
      encryption: l,
      data: (0, D.toBase64)(p)
    };
    return JSON.stringify(b);
  }
  async getKeyPair(r) {
    const { privkey: o } = v.Slip10.derivePath(v.Slip10Curve.Secp256k1, this.seed, r), { pubkey: u } = await v.Secp256k1.makeKeypair(o);
    return {
      privkey: o,
      pubkey: v.Secp256k1.compressPubkey(u)
    };
  }
  async getAccountsWithPrivkeys() {
    return Promise.all(this.accounts.map(async ({ hdPath: r, prefix: o }) => {
      const { privkey: u, pubkey: c } = await this.getKeyPair(r), l = (0, D.toBech32)(o, (0, ae.rawSecp256k1PubkeyToRawAddress)(c));
      return {
        algo: "secp256k1",
        privkey: u,
        pubkey: c,
        address: l
      };
    }));
  }
}
U.DirectSecp256k1HdWallet = M;
var Q = {};
Object.defineProperty(Q, "__esModule", { value: !0 });
Q.DirectSecp256k1Wallet = void 0;
const Se = V, G = X, Ze = q, Ye = w;
class be {
  /**
   * Creates a DirectSecp256k1Wallet from the given private key
   *
   * @param privkey The private key.
   * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
   */
  static async fromKey(r, o = "cosmos") {
    const u = (await G.Secp256k1.makeKeypair(r)).pubkey;
    return new be(r, G.Secp256k1.compressPubkey(u), o);
  }
  constructor(r, o, u) {
    this.privkey = r, this.pubkey = o, this.prefix = u;
  }
  get address() {
    return (0, Ze.toBech32)(this.prefix, (0, Se.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
  }
  async getAccounts() {
    return [
      {
        algo: "secp256k1",
        address: this.address,
        pubkey: this.pubkey
      }
    ];
  }
  async signDirect(r, o) {
    const u = (0, Ye.makeSignBytes)(o);
    if (r !== this.address)
      throw new Error(`Address ${r} not found in wallet`);
    const c = (0, G.sha256)(u), l = await G.Secp256k1.createSignature(c, this.privkey), p = new Uint8Array([...l.r(32), ...l.s(32)]), b = (0, Se.encodeSecp256k1Signature)(this.pubkey, p);
    return {
      signed: o,
      signature: b
    };
  }
}
Q.DirectSecp256k1Wallet = be;
var ee = {};
Object.defineProperty(ee, "__esModule", { value: !0 });
ee.makeCosmoshubPath = void 0;
const I = X;
function Qe(e) {
  return [
    I.Slip10RawIndex.hardened(44),
    I.Slip10RawIndex.hardened(118),
    I.Slip10RawIndex.hardened(0),
    I.Slip10RawIndex.normal(0),
    I.Slip10RawIndex.normal(e)
  ];
}
ee.makeCosmoshubPath = Qe;
var A = {}, E = {}, et = m && m.__createBinding || (Object.create ? function(e, r, o, u) {
  u === void 0 && (u = o);
  var c = Object.getOwnPropertyDescriptor(r, o);
  (!c || ("get" in c ? !r.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
    return r[o];
  } }), Object.defineProperty(e, u, c);
} : function(e, r, o, u) {
  u === void 0 && (u = o), e[u] = r[o];
}), tt = m && m.__setModuleDefault || (Object.create ? function(e, r) {
  Object.defineProperty(e, "default", { enumerable: !0, value: r });
} : function(e, r) {
  e.default = r;
}), rt = m && m.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var r = {};
  if (e != null)
    for (var o in e)
      o !== "default" && Object.prototype.hasOwnProperty.call(e, o) && et(r, e, o);
  return tt(r, e), r;
};
Object.defineProperty(E, "__esModule", { value: !0 });
E.PrivKey = E.PubKey = E.protobufPackage = void 0;
const N = rt(z), R = H;
E.protobufPackage = "cosmos.crypto.ed25519";
function ve() {
  return {
    key: new Uint8Array()
  };
}
E.PubKey = {
  encode(e, r = N.Writer.create()) {
    return e.key.length !== 0 && r.uint32(10).bytes(e.key), r;
  },
  decode(e, r) {
    const o = e instanceof N.Reader ? e : new N.Reader(e);
    let u = r === void 0 ? o.len : o.pos + r;
    const c = ve();
    for (; o.pos < u; ) {
      const l = o.uint32();
      switch (l >>> 3) {
        case 1:
          c.key = o.bytes();
          break;
        default:
          o.skipType(l & 7);
          break;
      }
    }
    return c;
  },
  fromJSON(e) {
    return {
      key: (0, R.isSet)(e.key) ? (0, R.bytesFromBase64)(e.key) : new Uint8Array()
    };
  },
  toJSON(e) {
    const r = {};
    return e.key !== void 0 && (r.key = (0, R.base64FromBytes)(e.key !== void 0 ? e.key : new Uint8Array())), r;
  },
  fromPartial(e) {
    const r = ve();
    return r.key = e.key ?? new Uint8Array(), r;
  }
};
function Pe() {
  return {
    key: new Uint8Array()
  };
}
E.PrivKey = {
  encode(e, r = N.Writer.create()) {
    return e.key.length !== 0 && r.uint32(10).bytes(e.key), r;
  },
  decode(e, r) {
    const o = e instanceof N.Reader ? e : new N.Reader(e);
    let u = r === void 0 ? o.len : o.pos + r;
    const c = Pe();
    for (; o.pos < u; ) {
      const l = o.uint32();
      switch (l >>> 3) {
        case 1:
          c.key = o.bytes();
          break;
        default:
          o.skipType(l & 7);
          break;
      }
    }
    return c;
  },
  fromJSON(e) {
    return {
      key: (0, R.isSet)(e.key) ? (0, R.bytesFromBase64)(e.key) : new Uint8Array()
    };
  },
  toJSON(e) {
    const r = {};
    return e.key !== void 0 && (r.key = (0, R.base64FromBytes)(e.key !== void 0 ? e.key : new Uint8Array())), r;
  },
  fromPartial(e) {
    const r = Pe();
    return r.key = e.key ?? new Uint8Array(), r;
  }
};
var J = {}, nt = m && m.__createBinding || (Object.create ? function(e, r, o, u) {
  u === void 0 && (u = o);
  var c = Object.getOwnPropertyDescriptor(r, o);
  (!c || ("get" in c ? !r.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
    return r[o];
  } }), Object.defineProperty(e, u, c);
} : function(e, r, o, u) {
  u === void 0 && (u = o), e[u] = r[o];
}), ot = m && m.__setModuleDefault || (Object.create ? function(e, r) {
  Object.defineProperty(e, "default", { enumerable: !0, value: r });
} : function(e, r) {
  e.default = r;
}), st = m && m.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var r = {};
  if (e != null)
    for (var o in e)
      o !== "default" && Object.prototype.hasOwnProperty.call(e, o) && nt(r, e, o);
  return ot(r, e), r;
};
Object.defineProperty(J, "__esModule", { value: !0 });
J.LegacyAminoPubKey = J.protobufPackage = void 0;
const W = le, ne = st(z), at = H;
J.protobufPackage = "cosmos.crypto.multisig";
function Oe() {
  return {
    threshold: 0,
    publicKeys: []
  };
}
J.LegacyAminoPubKey = {
  encode(e, r = ne.Writer.create()) {
    e.threshold !== 0 && r.uint32(8).uint32(e.threshold);
    for (const o of e.publicKeys)
      W.Any.encode(o, r.uint32(18).fork()).ldelim();
    return r;
  },
  decode(e, r) {
    const o = e instanceof ne.Reader ? e : new ne.Reader(e);
    let u = r === void 0 ? o.len : o.pos + r;
    const c = Oe();
    for (; o.pos < u; ) {
      const l = o.uint32();
      switch (l >>> 3) {
        case 1:
          c.threshold = o.uint32();
          break;
        case 2:
          c.publicKeys.push(W.Any.decode(o, o.uint32()));
          break;
        default:
          o.skipType(l & 7);
          break;
      }
    }
    return c;
  },
  fromJSON(e) {
    return {
      threshold: (0, at.isSet)(e.threshold) ? Number(e.threshold) : 0,
      publicKeys: Array.isArray(e == null ? void 0 : e.publicKeys) ? e.publicKeys.map((r) => W.Any.fromJSON(r)) : []
    };
  },
  toJSON(e) {
    const r = {};
    return e.threshold !== void 0 && (r.threshold = Math.round(e.threshold)), e.publicKeys ? r.publicKeys = e.publicKeys.map((o) => o ? W.Any.toJSON(o) : void 0) : r.publicKeys = [], r;
  },
  fromPartial(e) {
    var r;
    const o = Oe();
    return o.threshold = e.threshold ?? 0, o.publicKeys = ((r = e.publicKeys) == null ? void 0 : r.map((u) => W.Any.fromPartial(u))) || [], o;
  }
};
var j = {}, it = m && m.__createBinding || (Object.create ? function(e, r, o, u) {
  u === void 0 && (u = o);
  var c = Object.getOwnPropertyDescriptor(r, o);
  (!c || ("get" in c ? !r.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
    return r[o];
  } }), Object.defineProperty(e, u, c);
} : function(e, r, o, u) {
  u === void 0 && (u = o), e[u] = r[o];
}), dt = m && m.__setModuleDefault || (Object.create ? function(e, r) {
  Object.defineProperty(e, "default", { enumerable: !0, value: r });
} : function(e, r) {
  e.default = r;
}), ut = m && m.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var r = {};
  if (e != null)
    for (var o in e)
      o !== "default" && Object.prototype.hasOwnProperty.call(e, o) && it(r, e, o);
  return dt(r, e), r;
};
Object.defineProperty(j, "__esModule", { value: !0 });
j.PrivKey = j.PubKey = j.protobufPackage = void 0;
const T = ut(z), x = H;
j.protobufPackage = "cosmos.crypto.secp256k1";
function we() {
  return {
    key: new Uint8Array()
  };
}
j.PubKey = {
  encode(e, r = T.Writer.create()) {
    return e.key.length !== 0 && r.uint32(10).bytes(e.key), r;
  },
  decode(e, r) {
    const o = e instanceof T.Reader ? e : new T.Reader(e);
    let u = r === void 0 ? o.len : o.pos + r;
    const c = we();
    for (; o.pos < u; ) {
      const l = o.uint32();
      switch (l >>> 3) {
        case 1:
          c.key = o.bytes();
          break;
        default:
          o.skipType(l & 7);
          break;
      }
    }
    return c;
  },
  fromJSON(e) {
    return {
      key: (0, x.isSet)(e.key) ? (0, x.bytesFromBase64)(e.key) : new Uint8Array()
    };
  },
  toJSON(e) {
    const r = {};
    return e.key !== void 0 && (r.key = (0, x.base64FromBytes)(e.key !== void 0 ? e.key : new Uint8Array())), r;
  },
  fromPartial(e) {
    const r = we();
    return r.key = e.key ?? new Uint8Array(), r;
  }
};
function Ae() {
  return {
    key: new Uint8Array()
  };
}
j.PrivKey = {
  encode(e, r = T.Writer.create()) {
    return e.key.length !== 0 && r.uint32(10).bytes(e.key), r;
  },
  decode(e, r) {
    const o = e instanceof T.Reader ? e : new T.Reader(e);
    let u = r === void 0 ? o.len : o.pos + r;
    const c = Ae();
    for (; o.pos < u; ) {
      const l = o.uint32();
      switch (l >>> 3) {
        case 1:
          c.key = o.bytes();
          break;
        default:
          o.skipType(l & 7);
          break;
      }
    }
    return c;
  },
  fromJSON(e) {
    return {
      key: (0, x.isSet)(e.key) ? (0, x.bytesFromBase64)(e.key) : new Uint8Array()
    };
  },
  toJSON(e) {
    const r = {};
    return e.key !== void 0 && (r.key = (0, x.base64FromBytes)(e.key !== void 0 ? e.key : new Uint8Array())), r;
  },
  fromPartial(e) {
    const r = Ae();
    return r.key = e.key ?? new Uint8Array(), r;
  }
};
Object.defineProperty(A, "__esModule", { value: !0 });
A.decodePubkey = A.anyToSinglePubkey = A.encodePubkey = void 0;
const F = V, Ee = q, ct = Ke, ie = E, de = J, ue = j, oe = le;
function Ne(e) {
  if ((0, F.isSecp256k1Pubkey)(e)) {
    const r = ue.PubKey.fromPartial({
      key: (0, Ee.fromBase64)(e.value)
    });
    return oe.Any.fromPartial({
      typeUrl: "/cosmos.crypto.secp256k1.PubKey",
      value: Uint8Array.from(ue.PubKey.encode(r).finish())
    });
  } else if ((0, F.isEd25519Pubkey)(e)) {
    const r = ie.PubKey.fromPartial({
      key: (0, Ee.fromBase64)(e.value)
    });
    return oe.Any.fromPartial({
      typeUrl: "/cosmos.crypto.ed25519.PubKey",
      value: Uint8Array.from(ie.PubKey.encode(r).finish())
    });
  } else if ((0, F.isMultisigThresholdPubkey)(e)) {
    const r = de.LegacyAminoPubKey.fromPartial({
      threshold: ct.Uint53.fromString(e.value.threshold).toNumber(),
      publicKeys: e.value.pubkeys.map(Ne)
    });
    return oe.Any.fromPartial({
      typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
      value: Uint8Array.from(de.LegacyAminoPubKey.encode(r).finish())
    });
  } else
    throw new Error(`Pubkey type ${e.type} not recognized`);
}
A.encodePubkey = Ne;
function ce(e) {
  switch (e.typeUrl) {
    case "/cosmos.crypto.secp256k1.PubKey": {
      const { key: r } = ue.PubKey.decode(e.value);
      return (0, F.encodeSecp256k1Pubkey)(r);
    }
    case "/cosmos.crypto.ed25519.PubKey": {
      const { key: r } = ie.PubKey.decode(e.value);
      return (0, F.encodeEd25519Pubkey)(r);
    }
    default:
      throw new Error(`Pubkey type_url ${e.typeUrl} not recognized as single public key type`);
  }
}
A.anyToSinglePubkey = ce;
function lt(e) {
  switch (e.typeUrl) {
    case "/cosmos.crypto.secp256k1.PubKey":
    case "/cosmos.crypto.ed25519.PubKey":
      return ce(e);
    case "/cosmos.crypto.multisig.LegacyAminoPubKey": {
      const { threshold: r, publicKeys: o } = de.LegacyAminoPubKey.decode(e.value);
      return {
        type: "tendermint/PubKeyMultisigThreshold",
        value: {
          threshold: r.toString(),
          pubkeys: o.map(ce)
        }
      };
    }
    default:
      throw new Error(`Pubkey type_url ${e.typeUrl} not recognized`);
  }
}
A.decodePubkey = lt;
var O = {}, Re = {}, Te = {};
(function(e) {
  var r = m && m.__createBinding || (Object.create ? function(t, a, i, n) {
    n === void 0 && (n = i);
    var s = Object.getOwnPropertyDescriptor(a, i);
    (!s || ("get" in s ? !a.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
      return a[i];
    } }), Object.defineProperty(t, n, s);
  } : function(t, a, i, n) {
    n === void 0 && (n = i), t[n] = a[i];
  }), o = m && m.__setModuleDefault || (Object.create ? function(t, a) {
    Object.defineProperty(t, "default", { enumerable: !0, value: a });
  } : function(t, a) {
    t.default = a;
  }), u = m && m.__importStar || function(t) {
    if (t && t.__esModule)
      return t;
    var a = {};
    if (t != null)
      for (var i in t)
        i !== "default" && Object.prototype.hasOwnProperty.call(t, i) && r(a, t, i);
    return o(a, t), a;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Metadata = e.DenomUnit = e.Supply = e.Output = e.Input = e.SendEnabled = e.Params = e.protobufPackage = void 0;
  const c = pe, l = u(z), p = H;
  e.protobufPackage = "cosmos.bank.v1beta1";
  function b() {
    return {
      sendEnabled: [],
      defaultSendEnabled: !1
    };
  }
  e.Params = {
    encode(t, a = l.Writer.create()) {
      for (const i of t.sendEnabled)
        e.SendEnabled.encode(i, a.uint32(10).fork()).ldelim();
      return t.defaultSendEnabled === !0 && a.uint32(16).bool(t.defaultSendEnabled), a;
    },
    decode(t, a) {
      const i = t instanceof l.Reader ? t : new l.Reader(t);
      let n = a === void 0 ? i.len : i.pos + a;
      const s = b();
      for (; i.pos < n; ) {
        const d = i.uint32();
        switch (d >>> 3) {
          case 1:
            s.sendEnabled.push(e.SendEnabled.decode(i, i.uint32()));
            break;
          case 2:
            s.defaultSendEnabled = i.bool();
            break;
          default:
            i.skipType(d & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(t) {
      return {
        sendEnabled: Array.isArray(t == null ? void 0 : t.sendEnabled) ? t.sendEnabled.map((a) => e.SendEnabled.fromJSON(a)) : [],
        defaultSendEnabled: (0, p.isSet)(t.defaultSendEnabled) ? !!t.defaultSendEnabled : !1
      };
    },
    toJSON(t) {
      const a = {};
      return t.sendEnabled ? a.sendEnabled = t.sendEnabled.map((i) => i ? e.SendEnabled.toJSON(i) : void 0) : a.sendEnabled = [], t.defaultSendEnabled !== void 0 && (a.defaultSendEnabled = t.defaultSendEnabled), a;
    },
    fromPartial(t) {
      var a;
      const i = b();
      return i.sendEnabled = ((a = t.sendEnabled) == null ? void 0 : a.map((n) => e.SendEnabled.fromPartial(n))) || [], i.defaultSendEnabled = t.defaultSendEnabled ?? !1, i;
    }
  };
  function h() {
    return {
      denom: "",
      enabled: !1
    };
  }
  e.SendEnabled = {
    encode(t, a = l.Writer.create()) {
      return t.denom !== "" && a.uint32(10).string(t.denom), t.enabled === !0 && a.uint32(16).bool(t.enabled), a;
    },
    decode(t, a) {
      const i = t instanceof l.Reader ? t : new l.Reader(t);
      let n = a === void 0 ? i.len : i.pos + a;
      const s = h();
      for (; i.pos < n; ) {
        const d = i.uint32();
        switch (d >>> 3) {
          case 1:
            s.denom = i.string();
            break;
          case 2:
            s.enabled = i.bool();
            break;
          default:
            i.skipType(d & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(t) {
      return {
        denom: (0, p.isSet)(t.denom) ? String(t.denom) : "",
        enabled: (0, p.isSet)(t.enabled) ? !!t.enabled : !1
      };
    },
    toJSON(t) {
      const a = {};
      return t.denom !== void 0 && (a.denom = t.denom), t.enabled !== void 0 && (a.enabled = t.enabled), a;
    },
    fromPartial(t) {
      const a = h();
      return a.denom = t.denom ?? "", a.enabled = t.enabled ?? !1, a;
    }
  };
  function k() {
    return {
      address: "",
      coins: []
    };
  }
  e.Input = {
    encode(t, a = l.Writer.create()) {
      t.address !== "" && a.uint32(10).string(t.address);
      for (const i of t.coins)
        c.Coin.encode(i, a.uint32(18).fork()).ldelim();
      return a;
    },
    decode(t, a) {
      const i = t instanceof l.Reader ? t : new l.Reader(t);
      let n = a === void 0 ? i.len : i.pos + a;
      const s = k();
      for (; i.pos < n; ) {
        const d = i.uint32();
        switch (d >>> 3) {
          case 1:
            s.address = i.string();
            break;
          case 2:
            s.coins.push(c.Coin.decode(i, i.uint32()));
            break;
          default:
            i.skipType(d & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(t) {
      return {
        address: (0, p.isSet)(t.address) ? String(t.address) : "",
        coins: Array.isArray(t == null ? void 0 : t.coins) ? t.coins.map((a) => c.Coin.fromJSON(a)) : []
      };
    },
    toJSON(t) {
      const a = {};
      return t.address !== void 0 && (a.address = t.address), t.coins ? a.coins = t.coins.map((i) => i ? c.Coin.toJSON(i) : void 0) : a.coins = [], a;
    },
    fromPartial(t) {
      var a;
      const i = k();
      return i.address = t.address ?? "", i.coins = ((a = t.coins) == null ? void 0 : a.map((n) => c.Coin.fromPartial(n))) || [], i;
    }
  };
  function P() {
    return {
      address: "",
      coins: []
    };
  }
  e.Output = {
    encode(t, a = l.Writer.create()) {
      t.address !== "" && a.uint32(10).string(t.address);
      for (const i of t.coins)
        c.Coin.encode(i, a.uint32(18).fork()).ldelim();
      return a;
    },
    decode(t, a) {
      const i = t instanceof l.Reader ? t : new l.Reader(t);
      let n = a === void 0 ? i.len : i.pos + a;
      const s = P();
      for (; i.pos < n; ) {
        const d = i.uint32();
        switch (d >>> 3) {
          case 1:
            s.address = i.string();
            break;
          case 2:
            s.coins.push(c.Coin.decode(i, i.uint32()));
            break;
          default:
            i.skipType(d & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(t) {
      return {
        address: (0, p.isSet)(t.address) ? String(t.address) : "",
        coins: Array.isArray(t == null ? void 0 : t.coins) ? t.coins.map((a) => c.Coin.fromJSON(a)) : []
      };
    },
    toJSON(t) {
      const a = {};
      return t.address !== void 0 && (a.address = t.address), t.coins ? a.coins = t.coins.map((i) => i ? c.Coin.toJSON(i) : void 0) : a.coins = [], a;
    },
    fromPartial(t) {
      var a;
      const i = P();
      return i.address = t.address ?? "", i.coins = ((a = t.coins) == null ? void 0 : a.map((n) => c.Coin.fromPartial(n))) || [], i;
    }
  };
  function S() {
    return {
      total: []
    };
  }
  e.Supply = {
    encode(t, a = l.Writer.create()) {
      for (const i of t.total)
        c.Coin.encode(i, a.uint32(10).fork()).ldelim();
      return a;
    },
    decode(t, a) {
      const i = t instanceof l.Reader ? t : new l.Reader(t);
      let n = a === void 0 ? i.len : i.pos + a;
      const s = S();
      for (; i.pos < n; ) {
        const d = i.uint32();
        switch (d >>> 3) {
          case 1:
            s.total.push(c.Coin.decode(i, i.uint32()));
            break;
          default:
            i.skipType(d & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(t) {
      return {
        total: Array.isArray(t == null ? void 0 : t.total) ? t.total.map((a) => c.Coin.fromJSON(a)) : []
      };
    },
    toJSON(t) {
      const a = {};
      return t.total ? a.total = t.total.map((i) => i ? c.Coin.toJSON(i) : void 0) : a.total = [], a;
    },
    fromPartial(t) {
      var a;
      const i = S();
      return i.total = ((a = t.total) == null ? void 0 : a.map((n) => c.Coin.fromPartial(n))) || [], i;
    }
  };
  function K() {
    return {
      denom: "",
      exponent: 0,
      aliases: []
    };
  }
  e.DenomUnit = {
    encode(t, a = l.Writer.create()) {
      t.denom !== "" && a.uint32(10).string(t.denom), t.exponent !== 0 && a.uint32(16).uint32(t.exponent);
      for (const i of t.aliases)
        a.uint32(26).string(i);
      return a;
    },
    decode(t, a) {
      const i = t instanceof l.Reader ? t : new l.Reader(t);
      let n = a === void 0 ? i.len : i.pos + a;
      const s = K();
      for (; i.pos < n; ) {
        const d = i.uint32();
        switch (d >>> 3) {
          case 1:
            s.denom = i.string();
            break;
          case 2:
            s.exponent = i.uint32();
            break;
          case 3:
            s.aliases.push(i.string());
            break;
          default:
            i.skipType(d & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(t) {
      return {
        denom: (0, p.isSet)(t.denom) ? String(t.denom) : "",
        exponent: (0, p.isSet)(t.exponent) ? Number(t.exponent) : 0,
        aliases: Array.isArray(t == null ? void 0 : t.aliases) ? t.aliases.map((a) => String(a)) : []
      };
    },
    toJSON(t) {
      const a = {};
      return t.denom !== void 0 && (a.denom = t.denom), t.exponent !== void 0 && (a.exponent = Math.round(t.exponent)), t.aliases ? a.aliases = t.aliases.map((i) => i) : a.aliases = [], a;
    },
    fromPartial(t) {
      var a;
      const i = K();
      return i.denom = t.denom ?? "", i.exponent = t.exponent ?? 0, i.aliases = ((a = t.aliases) == null ? void 0 : a.map((n) => n)) || [], i;
    }
  };
  function B() {
    return {
      description: "",
      denomUnits: [],
      base: "",
      display: "",
      name: "",
      symbol: "",
      uri: "",
      uriHash: ""
    };
  }
  e.Metadata = {
    encode(t, a = l.Writer.create()) {
      t.description !== "" && a.uint32(10).string(t.description);
      for (const i of t.denomUnits)
        e.DenomUnit.encode(i, a.uint32(18).fork()).ldelim();
      return t.base !== "" && a.uint32(26).string(t.base), t.display !== "" && a.uint32(34).string(t.display), t.name !== "" && a.uint32(42).string(t.name), t.symbol !== "" && a.uint32(50).string(t.symbol), t.uri !== "" && a.uint32(58).string(t.uri), t.uriHash !== "" && a.uint32(66).string(t.uriHash), a;
    },
    decode(t, a) {
      const i = t instanceof l.Reader ? t : new l.Reader(t);
      let n = a === void 0 ? i.len : i.pos + a;
      const s = B();
      for (; i.pos < n; ) {
        const d = i.uint32();
        switch (d >>> 3) {
          case 1:
            s.description = i.string();
            break;
          case 2:
            s.denomUnits.push(e.DenomUnit.decode(i, i.uint32()));
            break;
          case 3:
            s.base = i.string();
            break;
          case 4:
            s.display = i.string();
            break;
          case 5:
            s.name = i.string();
            break;
          case 6:
            s.symbol = i.string();
            break;
          case 7:
            s.uri = i.string();
            break;
          case 8:
            s.uriHash = i.string();
            break;
          default:
            i.skipType(d & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(t) {
      return {
        description: (0, p.isSet)(t.description) ? String(t.description) : "",
        denomUnits: Array.isArray(t == null ? void 0 : t.denomUnits) ? t.denomUnits.map((a) => e.DenomUnit.fromJSON(a)) : [],
        base: (0, p.isSet)(t.base) ? String(t.base) : "",
        display: (0, p.isSet)(t.display) ? String(t.display) : "",
        name: (0, p.isSet)(t.name) ? String(t.name) : "",
        symbol: (0, p.isSet)(t.symbol) ? String(t.symbol) : "",
        uri: (0, p.isSet)(t.uri) ? String(t.uri) : "",
        uriHash: (0, p.isSet)(t.uriHash) ? String(t.uriHash) : ""
      };
    },
    toJSON(t) {
      const a = {};
      return t.description !== void 0 && (a.description = t.description), t.denomUnits ? a.denomUnits = t.denomUnits.map((i) => i ? e.DenomUnit.toJSON(i) : void 0) : a.denomUnits = [], t.base !== void 0 && (a.base = t.base), t.display !== void 0 && (a.display = t.display), t.name !== void 0 && (a.name = t.name), t.symbol !== void 0 && (a.symbol = t.symbol), t.uri !== void 0 && (a.uri = t.uri), t.uriHash !== void 0 && (a.uriHash = t.uriHash), a;
    },
    fromPartial(t) {
      var a;
      const i = B();
      return i.description = t.description ?? "", i.denomUnits = ((a = t.denomUnits) == null ? void 0 : a.map((n) => e.DenomUnit.fromPartial(n))) || [], i.base = t.base ?? "", i.display = t.display ?? "", i.name = t.name ?? "", i.symbol = t.symbol ?? "", i.uri = t.uri ?? "", i.uriHash = t.uriHash ?? "", i;
    }
  };
})(Te);
(function(e) {
  var r = m && m.__createBinding || (Object.create ? function(n, s, d, f) {
    f === void 0 && (f = d);
    var y = Object.getOwnPropertyDescriptor(s, d);
    (!y || ("get" in y ? !s.__esModule : y.writable || y.configurable)) && (y = { enumerable: !0, get: function() {
      return s[d];
    } }), Object.defineProperty(n, f, y);
  } : function(n, s, d, f) {
    f === void 0 && (f = d), n[f] = s[d];
  }), o = m && m.__setModuleDefault || (Object.create ? function(n, s) {
    Object.defineProperty(n, "default", { enumerable: !0, value: s });
  } : function(n, s) {
    n.default = s;
  }), u = m && m.__importStar || function(n) {
    if (n && n.__esModule)
      return n;
    var s = {};
    if (n != null)
      for (var d in n)
        d !== "default" && Object.prototype.hasOwnProperty.call(n, d) && r(s, n, d);
    return o(s, n), s;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgSetSendEnabledResponse = e.MsgSetSendEnabled = e.MsgUpdateParamsResponse = e.MsgUpdateParams = e.MsgMultiSendResponse = e.MsgMultiSend = e.MsgSendResponse = e.MsgSend = e.protobufPackage = void 0;
  const c = pe, l = Te, p = u(z), b = H;
  e.protobufPackage = "cosmos.bank.v1beta1";
  function h() {
    return {
      fromAddress: "",
      toAddress: "",
      amount: []
    };
  }
  e.MsgSend = {
    encode(n, s = p.Writer.create()) {
      n.fromAddress !== "" && s.uint32(10).string(n.fromAddress), n.toAddress !== "" && s.uint32(18).string(n.toAddress);
      for (const d of n.amount)
        c.Coin.encode(d, s.uint32(26).fork()).ldelim();
      return s;
    },
    decode(n, s) {
      const d = n instanceof p.Reader ? n : new p.Reader(n);
      let f = s === void 0 ? d.len : d.pos + s;
      const y = h();
      for (; d.pos < f; ) {
        const g = d.uint32();
        switch (g >>> 3) {
          case 1:
            y.fromAddress = d.string();
            break;
          case 2:
            y.toAddress = d.string();
            break;
          case 3:
            y.amount.push(c.Coin.decode(d, d.uint32()));
            break;
          default:
            d.skipType(g & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(n) {
      return {
        fromAddress: (0, b.isSet)(n.fromAddress) ? String(n.fromAddress) : "",
        toAddress: (0, b.isSet)(n.toAddress) ? String(n.toAddress) : "",
        amount: Array.isArray(n == null ? void 0 : n.amount) ? n.amount.map((s) => c.Coin.fromJSON(s)) : []
      };
    },
    toJSON(n) {
      const s = {};
      return n.fromAddress !== void 0 && (s.fromAddress = n.fromAddress), n.toAddress !== void 0 && (s.toAddress = n.toAddress), n.amount ? s.amount = n.amount.map((d) => d ? c.Coin.toJSON(d) : void 0) : s.amount = [], s;
    },
    fromPartial(n) {
      var s;
      const d = h();
      return d.fromAddress = n.fromAddress ?? "", d.toAddress = n.toAddress ?? "", d.amount = ((s = n.amount) == null ? void 0 : s.map((f) => c.Coin.fromPartial(f))) || [], d;
    }
  };
  function k() {
    return {};
  }
  e.MsgSendResponse = {
    encode(n, s = p.Writer.create()) {
      return s;
    },
    decode(n, s) {
      const d = n instanceof p.Reader ? n : new p.Reader(n);
      let f = s === void 0 ? d.len : d.pos + s;
      const y = k();
      for (; d.pos < f; ) {
        const g = d.uint32();
        switch (g >>> 3) {
          default:
            d.skipType(g & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(n) {
      return {};
    },
    toJSON(n) {
      return {};
    },
    fromPartial(n) {
      return k();
    }
  };
  function P() {
    return {
      inputs: [],
      outputs: []
    };
  }
  e.MsgMultiSend = {
    encode(n, s = p.Writer.create()) {
      for (const d of n.inputs)
        l.Input.encode(d, s.uint32(10).fork()).ldelim();
      for (const d of n.outputs)
        l.Output.encode(d, s.uint32(18).fork()).ldelim();
      return s;
    },
    decode(n, s) {
      const d = n instanceof p.Reader ? n : new p.Reader(n);
      let f = s === void 0 ? d.len : d.pos + s;
      const y = P();
      for (; d.pos < f; ) {
        const g = d.uint32();
        switch (g >>> 3) {
          case 1:
            y.inputs.push(l.Input.decode(d, d.uint32()));
            break;
          case 2:
            y.outputs.push(l.Output.decode(d, d.uint32()));
            break;
          default:
            d.skipType(g & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(n) {
      return {
        inputs: Array.isArray(n == null ? void 0 : n.inputs) ? n.inputs.map((s) => l.Input.fromJSON(s)) : [],
        outputs: Array.isArray(n == null ? void 0 : n.outputs) ? n.outputs.map((s) => l.Output.fromJSON(s)) : []
      };
    },
    toJSON(n) {
      const s = {};
      return n.inputs ? s.inputs = n.inputs.map((d) => d ? l.Input.toJSON(d) : void 0) : s.inputs = [], n.outputs ? s.outputs = n.outputs.map((d) => d ? l.Output.toJSON(d) : void 0) : s.outputs = [], s;
    },
    fromPartial(n) {
      var s, d;
      const f = P();
      return f.inputs = ((s = n.inputs) == null ? void 0 : s.map((y) => l.Input.fromPartial(y))) || [], f.outputs = ((d = n.outputs) == null ? void 0 : d.map((y) => l.Output.fromPartial(y))) || [], f;
    }
  };
  function S() {
    return {};
  }
  e.MsgMultiSendResponse = {
    encode(n, s = p.Writer.create()) {
      return s;
    },
    decode(n, s) {
      const d = n instanceof p.Reader ? n : new p.Reader(n);
      let f = s === void 0 ? d.len : d.pos + s;
      const y = S();
      for (; d.pos < f; ) {
        const g = d.uint32();
        switch (g >>> 3) {
          default:
            d.skipType(g & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(n) {
      return {};
    },
    toJSON(n) {
      return {};
    },
    fromPartial(n) {
      return S();
    }
  };
  function K() {
    return {
      authority: "",
      params: void 0
    };
  }
  e.MsgUpdateParams = {
    encode(n, s = p.Writer.create()) {
      return n.authority !== "" && s.uint32(10).string(n.authority), n.params !== void 0 && l.Params.encode(n.params, s.uint32(18).fork()).ldelim(), s;
    },
    decode(n, s) {
      const d = n instanceof p.Reader ? n : new p.Reader(n);
      let f = s === void 0 ? d.len : d.pos + s;
      const y = K();
      for (; d.pos < f; ) {
        const g = d.uint32();
        switch (g >>> 3) {
          case 1:
            y.authority = d.string();
            break;
          case 2:
            y.params = l.Params.decode(d, d.uint32());
            break;
          default:
            d.skipType(g & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(n) {
      return {
        authority: (0, b.isSet)(n.authority) ? String(n.authority) : "",
        params: (0, b.isSet)(n.params) ? l.Params.fromJSON(n.params) : void 0
      };
    },
    toJSON(n) {
      const s = {};
      return n.authority !== void 0 && (s.authority = n.authority), n.params !== void 0 && (s.params = n.params ? l.Params.toJSON(n.params) : void 0), s;
    },
    fromPartial(n) {
      const s = K();
      return s.authority = n.authority ?? "", s.params = n.params !== void 0 && n.params !== null ? l.Params.fromPartial(n.params) : void 0, s;
    }
  };
  function B() {
    return {};
  }
  e.MsgUpdateParamsResponse = {
    encode(n, s = p.Writer.create()) {
      return s;
    },
    decode(n, s) {
      const d = n instanceof p.Reader ? n : new p.Reader(n);
      let f = s === void 0 ? d.len : d.pos + s;
      const y = B();
      for (; d.pos < f; ) {
        const g = d.uint32();
        switch (g >>> 3) {
          default:
            d.skipType(g & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(n) {
      return {};
    },
    toJSON(n) {
      return {};
    },
    fromPartial(n) {
      return B();
    }
  };
  function t() {
    return {
      authority: "",
      sendEnabled: [],
      useDefaultFor: []
    };
  }
  e.MsgSetSendEnabled = {
    encode(n, s = p.Writer.create()) {
      n.authority !== "" && s.uint32(10).string(n.authority);
      for (const d of n.sendEnabled)
        l.SendEnabled.encode(d, s.uint32(18).fork()).ldelim();
      for (const d of n.useDefaultFor)
        s.uint32(26).string(d);
      return s;
    },
    decode(n, s) {
      const d = n instanceof p.Reader ? n : new p.Reader(n);
      let f = s === void 0 ? d.len : d.pos + s;
      const y = t();
      for (; d.pos < f; ) {
        const g = d.uint32();
        switch (g >>> 3) {
          case 1:
            y.authority = d.string();
            break;
          case 2:
            y.sendEnabled.push(l.SendEnabled.decode(d, d.uint32()));
            break;
          case 3:
            y.useDefaultFor.push(d.string());
            break;
          default:
            d.skipType(g & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(n) {
      return {
        authority: (0, b.isSet)(n.authority) ? String(n.authority) : "",
        sendEnabled: Array.isArray(n == null ? void 0 : n.sendEnabled) ? n.sendEnabled.map((s) => l.SendEnabled.fromJSON(s)) : [],
        useDefaultFor: Array.isArray(n == null ? void 0 : n.useDefaultFor) ? n.useDefaultFor.map((s) => String(s)) : []
      };
    },
    toJSON(n) {
      const s = {};
      return n.authority !== void 0 && (s.authority = n.authority), n.sendEnabled ? s.sendEnabled = n.sendEnabled.map((d) => d ? l.SendEnabled.toJSON(d) : void 0) : s.sendEnabled = [], n.useDefaultFor ? s.useDefaultFor = n.useDefaultFor.map((d) => d) : s.useDefaultFor = [], s;
    },
    fromPartial(n) {
      var s, d;
      const f = t();
      return f.authority = n.authority ?? "", f.sendEnabled = ((s = n.sendEnabled) == null ? void 0 : s.map((y) => l.SendEnabled.fromPartial(y))) || [], f.useDefaultFor = ((d = n.useDefaultFor) == null ? void 0 : d.map((y) => y)) || [], f;
    }
  };
  function a() {
    return {};
  }
  e.MsgSetSendEnabledResponse = {
    encode(n, s = p.Writer.create()) {
      return s;
    },
    decode(n, s) {
      const d = n instanceof p.Reader ? n : new p.Reader(n);
      let f = s === void 0 ? d.len : d.pos + s;
      const y = a();
      for (; d.pos < f; ) {
        const g = d.uint32();
        switch (g >>> 3) {
          default:
            d.skipType(g & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(n) {
      return {};
    },
    toJSON(n) {
      return {};
    },
    fromPartial(n) {
      return a();
    }
  };
  class i {
    constructor(s) {
      this.rpc = s, this.Send = this.Send.bind(this), this.MultiSend = this.MultiSend.bind(this), this.UpdateParams = this.UpdateParams.bind(this), this.SetSendEnabled = this.SetSendEnabled.bind(this);
    }
    Send(s) {
      const d = e.MsgSend.encode(s).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Msg", "Send", d).then((f) => e.MsgSendResponse.decode(new p.Reader(f)));
    }
    MultiSend(s) {
      const d = e.MsgMultiSend.encode(s).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Msg", "MultiSend", d).then((f) => e.MsgMultiSendResponse.decode(new p.Reader(f)));
    }
    UpdateParams(s) {
      const d = e.MsgUpdateParams.encode(s).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Msg", "UpdateParams", d).then((f) => e.MsgUpdateParamsResponse.decode(new p.Reader(f)));
    }
    SetSendEnabled(s) {
      const d = e.MsgSetSendEnabled.encode(s).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Msg", "SetSendEnabled", d).then((f) => e.MsgSetSendEnabledResponse.decode(new p.Reader(f)));
    }
  }
  e.MsgClientImpl = i;
})(Re);
Object.defineProperty(O, "__esModule", { value: !0 });
O.Registry = O.isTxBodyEncodeObject = O.isPbjsGeneratedType = O.isTsProtoGeneratedType = void 0;
const pt = Re, ft = pe, se = fe, yt = le;
function he(e) {
  return typeof e.fromPartial == "function";
}
O.isTsProtoGeneratedType = he;
function mt(e) {
  return !he(e);
}
O.isPbjsGeneratedType = mt;
const je = {
  cosmosCoin: "/cosmos.base.v1beta1.Coin",
  cosmosMsgSend: "/cosmos.bank.v1beta1.MsgSend",
  cosmosTxBody: "/cosmos.tx.v1beta1.TxBody",
  googleAny: "/google.protobuf.Any"
};
function xe(e) {
  return e.typeUrl === "/cosmos.tx.v1beta1.TxBody";
}
O.isTxBodyEncodeObject = xe;
class bt {
  /**
   * Creates a new Registry for mapping protobuf type identifiers/type URLs to
   * actual implementations. Those implementations are typically generated with ts-proto
   * but we also support protobuf.js as a type generator.
   *
   * If there is no parameter given, a `new Registry()` adds the types `Coin` and `MsgSend`
   * for historic reasons. Those can be overriden by customTypes.
   *
   * There are currently two methods for adding new types:
   * 1. Passing types to the constructor.
   * 2. Using the `register()` method
   */
  constructor(r) {
    const { cosmosCoin: o, cosmosMsgSend: u } = je;
    this.types = r ? new Map([...r]) : /* @__PURE__ */ new Map([
      [o, ft.Coin],
      [u, pt.MsgSend]
    ]);
  }
  register(r, o) {
    this.types.set(r, o);
  }
  /**
   * Looks up a type that was previously added to the registry.
   *
   * The generator information (ts-proto or pbjs) gets lost along the way.
   * If you need to work with the result type in TypeScript, you can use:
   *
   * ```
   * import { assert } from "@cosmjs/utils";
   *
   * const Coin = registry.lookupType("/cosmos.base.v1beta1.Coin");
   * assert(Coin); // Ensures not unset
   * assert(isTsProtoGeneratedType(Coin)); // Ensures this is the type we expect
   *
   * // Coin is typed TsProtoGeneratedType now.
   * ```
   */
  lookupType(r) {
    return this.types.get(r);
  }
  lookupTypeWithError(r) {
    const o = this.lookupType(r);
    if (!o)
      throw new Error(`Unregistered type url: ${r}`);
    return o;
  }
  /**
   * Takes a typeUrl/value pair and encodes the value to protobuf if
   * the given type was previously registered.
   *
   * If the value has to be wrapped in an Any, this needs to be done
   * manually after this call. Or use `encodeAsAny` instead.
   */
  encode(r) {
    const { value: o, typeUrl: u } = r;
    if (xe(r))
      return this.encodeTxBody(o);
    const c = this.lookupTypeWithError(u), l = he(c) ? c.fromPartial(o) : c.create(o);
    return c.encode(l).finish();
  }
  /**
   * Takes a typeUrl/value pair and encodes the value to an Any if
   * the given type was previously registered.
   */
  encodeAsAny(r) {
    const o = this.encode(r);
    return yt.Any.fromPartial({
      typeUrl: r.typeUrl,
      value: o
    });
  }
  encodeTxBody(r) {
    const o = r.messages.map((c) => this.encodeAsAny(c)), u = se.TxBody.fromPartial({
      ...r,
      messages: o
    });
    return se.TxBody.encode(u).finish();
  }
  decode({ typeUrl: r, value: o }) {
    if (r === je.cosmosTxBody)
      return this.decodeTxBody(o);
    const u = this.lookupTypeWithError(r).decode(o);
    return Object.entries(u).forEach(([c, l]) => {
      typeof Buffer < "u" && typeof Buffer.isBuffer < "u" && Buffer.isBuffer(l) && (u[c] = Uint8Array.from(l));
    }), u;
  }
  decodeTxBody(r) {
    const o = se.TxBody.decode(r);
    return {
      ...o,
      messages: o.messages.map(({ typeUrl: u, value: c }) => {
        if (!u)
          throw new Error("Missing type_url in Any");
        if (!c)
          throw new Error("Missing value in Any");
        return this.decode({ typeUrl: u, value: c });
      })
    };
  }
}
O.Registry = bt;
var te = {};
Object.defineProperty(te, "__esModule", { value: !0 });
te.isOfflineDirectSigner = void 0;
function ht(e) {
  return e.signDirect !== void 0;
}
te.isOfflineDirectSigner = ht;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.coins = e.coin = e.executeKdf = e.makeSignDoc = e.makeSignBytes = e.makeAuthInfoBytes = e.isOfflineDirectSigner = e.Registry = e.isTxBodyEncodeObject = e.isTsProtoGeneratedType = e.isPbjsGeneratedType = e.encodePubkey = e.decodePubkey = e.anyToSinglePubkey = e.makeCosmoshubPath = e.DirectSecp256k1Wallet = e.extractKdfConfiguration = e.DirectSecp256k1HdWallet = e.decodeTxRaw = e.parseCoins = void 0;
  var r = Z;
  Object.defineProperty(e, "parseCoins", { enumerable: !0, get: function() {
    return r.parseCoins;
  } });
  var o = Y;
  Object.defineProperty(e, "decodeTxRaw", { enumerable: !0, get: function() {
    return o.decodeTxRaw;
  } });
  var u = U;
  Object.defineProperty(e, "DirectSecp256k1HdWallet", { enumerable: !0, get: function() {
    return u.DirectSecp256k1HdWallet;
  } }), Object.defineProperty(e, "extractKdfConfiguration", { enumerable: !0, get: function() {
    return u.extractKdfConfiguration;
  } });
  var c = Q;
  Object.defineProperty(e, "DirectSecp256k1Wallet", { enumerable: !0, get: function() {
    return c.DirectSecp256k1Wallet;
  } });
  var l = ee;
  Object.defineProperty(e, "makeCosmoshubPath", { enumerable: !0, get: function() {
    return l.makeCosmoshubPath;
  } });
  var p = A;
  Object.defineProperty(e, "anyToSinglePubkey", { enumerable: !0, get: function() {
    return p.anyToSinglePubkey;
  } }), Object.defineProperty(e, "decodePubkey", { enumerable: !0, get: function() {
    return p.decodePubkey;
  } }), Object.defineProperty(e, "encodePubkey", { enumerable: !0, get: function() {
    return p.encodePubkey;
  } });
  var b = O;
  Object.defineProperty(e, "isPbjsGeneratedType", { enumerable: !0, get: function() {
    return b.isPbjsGeneratedType;
  } }), Object.defineProperty(e, "isTsProtoGeneratedType", { enumerable: !0, get: function() {
    return b.isTsProtoGeneratedType;
  } }), Object.defineProperty(e, "isTxBodyEncodeObject", { enumerable: !0, get: function() {
    return b.isTxBodyEncodeObject;
  } }), Object.defineProperty(e, "Registry", { enumerable: !0, get: function() {
    return b.Registry;
  } });
  var h = te;
  Object.defineProperty(e, "isOfflineDirectSigner", { enumerable: !0, get: function() {
    return h.isOfflineDirectSigner;
  } });
  var k = w;
  Object.defineProperty(e, "makeAuthInfoBytes", { enumerable: !0, get: function() {
    return k.makeAuthInfoBytes;
  } }), Object.defineProperty(e, "makeSignBytes", { enumerable: !0, get: function() {
    return k.makeSignBytes;
  } }), Object.defineProperty(e, "makeSignDoc", { enumerable: !0, get: function() {
    return k.makeSignDoc;
  } });
  var P = me;
  Object.defineProperty(e, "executeKdf", { enumerable: !0, get: function() {
    return P.executeKdf;
  } });
  var S = V;
  Object.defineProperty(e, "coin", { enumerable: !0, get: function() {
    return S.coin;
  } }), Object.defineProperty(e, "coins", { enumerable: !0, get: function() {
    return S.coins;
  } });
})(_e);
const Mt = /* @__PURE__ */ Be({
  __proto__: null
}, [_e]);
export {
  Te as a,
  _e as b,
  Mt as i,
  Re as t
};
