"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformAccountInfo = exports.transformTransaction = exports.filterTokenTransfers = exports.transformInputOutput = exports.transformTokenInfo = exports.parseAsset = exports.getSubtype = exports.transformUtxos = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const utils_1 = require("./utils");
const transformUtxos = (utxos) => {
    const result = [];
    utxos.forEach(utxo => utxo.utxoData.amount.forEach(u => {
        result.push({
            address: utxo.address,
            txid: utxo.utxoData.tx_hash,
            confirmations: utxo.blockInfo.confirmations,
            blockHeight: utxo.blockInfo.height || 0,
            amount: u.quantity,
            vout: utxo.utxoData.output_index,
            path: utxo.path,
            cardanoSpecific: {
                unit: u.unit,
            },
        });
    }));
    return result;
};
exports.transformUtxos = transformUtxos;
const hexToString = (input) => {
    let str = '';
    for (let n = 0; n < input.length; n += 2) {
        str += String.fromCharCode(parseInt(input.substr(n, 2), 16));
    }
    return str;
};
const getSubtype = (tx) => {
    const withdrawal = tx.txData.withdrawal_count > 0;
    if (withdrawal) {
        return 'withdrawal';
    }
    const registrations = tx.txData.stake_cert_count;
    const delegations = tx.txData.delegation_count;
    if (registrations === 0 && delegations === 0)
        return null;
    if (registrations > 0) {
        if (new bignumber_js_1.default(tx.txData.deposit).gt(0)) {
            return 'stake_registration';
        }
        return 'stake_deregistration';
    }
    if (delegations > 0) {
        return 'stake_delegation';
    }
    return null;
};
exports.getSubtype = getSubtype;
const parseAsset = (hex) => {
    const policyIdSize = 56;
    const policyId = hex.slice(0, policyIdSize);
    const assetNameInHex = hex.slice(policyIdSize);
    const assetName = hexToString(assetNameInHex);
    return {
        policyId,
        assetName,
    };
};
exports.parseAsset = parseAsset;
const transformTokenInfo = (tokens) => {
    if (!tokens || !Array.isArray(tokens))
        return undefined;
    const info = tokens.map(token => {
        const { assetName } = (0, exports.parseAsset)(token.unit);
        return {
            type: 'BLOCKFROST',
            name: token.fingerprint,
            contract: token.unit,
            symbol: assetName || token.fingerprint,
            balance: token.quantity,
            decimals: token.decimals,
        };
    });
    return info.length > 0 ? info : undefined;
};
exports.transformTokenInfo = transformTokenInfo;
const transformInputOutput = (data, asset = 'lovelace') => data.map(utxo => {
    var _a, _b;
    return ({
        n: utxo.output_index,
        addresses: [utxo.address],
        isAddress: true,
        value: (_b = (_a = utxo.amount.find(a => a.unit === asset)) === null || _a === void 0 ? void 0 : _a.quantity) !== null && _b !== void 0 ? _b : '0',
    });
});
exports.transformInputOutput = transformInputOutput;
const filterTokenTransfers = (accountAddress, tx, type) => {
    const transfers = [];
    const myNonChangeAddresses = accountAddress.used.concat(accountAddress.unused);
    const myAddresses = accountAddress.change.concat(myNonChangeAddresses);
    tx.txUtxos.outputs.forEach(output => {
        output.amount
            .filter(a => a.unit !== 'lovelace')
            .forEach(asset => {
            var _a;
            const token = asset.unit;
            const inputs = (0, exports.transformInputOutput)(tx.txUtxos.inputs, token);
            const outputs = (0, exports.transformInputOutput)(tx.txUtxos.outputs, token);
            const outgoing = (0, utils_1.filterTargets)(myAddresses, inputs);
            const incoming = (0, utils_1.filterTargets)(myAddresses, outputs);
            const isChange = accountAddress.change.find(a => a.address === output.address);
            if (incoming.length === 0 && outgoing.length === 0)
                return null;
            const incomingForOutput = (0, utils_1.filterTargets)(myNonChangeAddresses, (0, exports.transformInputOutput)([output], token));
            let amount = '0';
            if (type === 'sent') {
                amount = isChange ? '0' : asset.quantity;
            }
            else if (type === 'recv') {
                amount = incomingForOutput.reduce(utils_1.sumVinVout, 0).toString();
            }
            else if (type === 'self' && !isChange) {
                amount = incomingForOutput.reduce(utils_1.sumVinVout, 0).toString();
            }
            if (amount === '0' || !asset.fingerprint)
                return null;
            const { assetName } = (0, exports.parseAsset)(token);
            transfers.push({
                type,
                name: asset.fingerprint,
                symbol: assetName || asset.fingerprint,
                contract: asset.unit,
                decimals: asset.decimals,
                amount: amount.toString(),
                from: type === 'sent' || type === 'self'
                    ? tx.address
                    : ((_a = tx.txUtxos.inputs.find(i => i.amount.find(a => a.unit === token))) === null || _a === void 0 ? void 0 : _a.address) || '',
                to: type === 'recv' ? tx.address : output.address,
            });
        });
    });
    return transfers.filter(t => !!t);
};
exports.filterTokenTransfers = filterTokenTransfers;
const transformTransaction = (descriptor, accountAddress, blockfrostTxData) => {
    var _a;
    const myAddresses = accountAddress
        ? accountAddress.change
            .concat(accountAddress.used, accountAddress.unused)
            .map(a => a.address)
        : [descriptor];
    let type;
    let targets = [];
    let amount = ((_a = blockfrostTxData.txData.output_amount.find(b => b.unit === 'lovelace')) === null || _a === void 0 ? void 0 : _a.quantity) || '0';
    const fee = blockfrostTxData.txData.fees;
    let withdrawal;
    let deposit;
    const inputs = (0, exports.transformInputOutput)(blockfrostTxData.txUtxos.inputs);
    const outputs = (0, exports.transformInputOutput)(blockfrostTxData.txUtxos.outputs);
    const vinLength = Array.isArray(inputs) ? inputs.length : 0;
    const voutLength = Array.isArray(outputs) ? outputs.length : 0;
    const outgoing = (0, utils_1.filterTargets)(myAddresses, inputs);
    const incoming = (0, utils_1.filterTargets)(myAddresses, outputs);
    const internal = accountAddress ? (0, utils_1.filterTargets)(accountAddress.change, outputs) : [];
    const totalInput = inputs.reduce(utils_1.sumVinVout, 0);
    const totalOutput = outputs.reduce(utils_1.sumVinVout, 0);
    if (outgoing.length === 0 && incoming.length === 0) {
        type = 'unknown';
    }
    else if (vinLength > 0 &&
        voutLength > 0 &&
        outgoing.length === vinLength &&
        incoming.length === voutLength) {
        type = 'self';
        targets = outputs.filter(o => internal.indexOf(o) < 0);
        amount = blockfrostTxData.txData.fees;
        if (blockfrostTxData.txData.withdrawal_count > 0) {
            withdrawal = new bignumber_js_1.default(totalOutput)
                .plus(blockfrostTxData.txData.fees)
                .minus(totalInput)
                .toString();
        }
        if (new bignumber_js_1.default(blockfrostTxData.txData.deposit).gt(0)) {
            deposit = blockfrostTxData.txData.deposit;
        }
    }
    else if (outgoing.length === 0 && incoming.length > 0) {
        type = 'recv';
        amount = '0';
        if (incoming.length > 0) {
            targets = incoming;
            amount = incoming.reduce(utils_1.sumVinVout, 0);
        }
    }
    else {
        type = 'sent';
        targets = outputs.filter(o => internal.indexOf(o) < 0);
        if (voutLength) {
            const myInputsSum = outgoing.reduce(utils_1.sumVinVout, 0);
            const totalSpent = incoming.reduce(utils_1.sumVinVout, 0);
            amount = new bignumber_js_1.default(myInputsSum).minus(totalSpent).minus(fee !== null && fee !== void 0 ? fee : '0');
        }
    }
    const tokens = accountAddress
        ? (0, exports.filterTokenTransfers)(accountAddress, blockfrostTxData, type)
        : [];
    return {
        type,
        txid: blockfrostTxData.txHash,
        blockTime: blockfrostTxData.txData.block_time,
        blockHeight: blockfrostTxData.txData.block_height || undefined,
        blockHash: blockfrostTxData.txData.block,
        amount: amount === null || amount === void 0 ? void 0 : amount.toString(),
        fee,
        targets: targets.map(t => (0, utils_1.transformTarget)(t, incoming)),
        tokens,
        internalTransfers: [],
        cardanoSpecific: {
            subtype: (0, exports.getSubtype)(blockfrostTxData),
            withdrawal,
            deposit,
        },
        feeRate: undefined,
        details: {
            vin: inputs.map((0, utils_1.enhanceVinVout)(myAddresses)),
            vout: outputs.map((0, utils_1.enhanceVinVout)(myAddresses)),
            size: blockfrostTxData.txData.size,
            totalInput: totalInput.toString(),
            totalOutput: totalOutput.toString(),
        },
    };
};
exports.transformTransaction = transformTransaction;
const transformAccountInfo = (info) => {
    const blockfrostTxs = info.history.transactions;
    const result = Object.assign(Object.assign({}, info), { tokens: (0, exports.transformTokenInfo)(info.tokens), history: Object.assign(Object.assign({}, info.history), { transactions: !blockfrostTxs
                ? []
                : blockfrostTxs === null || blockfrostTxs === void 0 ? void 0 : blockfrostTxs.map(tx => (0, exports.transformTransaction)(info.descriptor, info.addresses, tx)) }) });
    return result;
};
exports.transformAccountInfo = transformAccountInfo;
//# sourceMappingURL=blockfrost.js.map