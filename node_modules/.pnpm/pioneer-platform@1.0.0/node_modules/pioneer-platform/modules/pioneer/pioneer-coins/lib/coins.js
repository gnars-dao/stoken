"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.get_address_from_xpub = exports.normalize_pubkeys = exports.getExplorerTxUrl = exports.getExplorerAddressUrl = exports.getExplorerUrl = exports.segwitCoins = exports.stakingCoins = exports.baseAmountToNative = exports.nativeToBaseAmount = exports.getPrecision = exports.PoSchains = exports.supportedAssets = exports.supportedBlockchains = exports.COIN_MAP_LONG = exports.COIN_MAP = exports.UTXO_COINS = void 0;
var TAG = " | coin tools | ";
var log = require("@pioneer-platform/loggerdog")();
var cloneCrypto = require("@pioneer-platform/utxo-crypto");
var bitcoin = require("bitcoinjs-lib");
var ethUtils = require('ethereumjs-util');
var ripemd160 = require("crypto-js/ripemd160");
var CryptoJS = require("crypto-js");
var sha256 = require("crypto-js/sha256");
var bech32 = require("bech32");
var getPaths = require('./paths').getPaths;
var HDWALLETS;
(function (HDWALLETS) {
    HDWALLETS[HDWALLETS["pioneer"] = 0] = "pioneer";
    HDWALLETS[HDWALLETS["trezor"] = 1] = "trezor";
    HDWALLETS[HDWALLETS["keepkey"] = 2] = "keepkey";
    HDWALLETS[HDWALLETS["ledger"] = 3] = "ledger";
})(HDWALLETS || (HDWALLETS = {}));
/*


*/
exports.UTXO_COINS = [
    'BTC',
    'BCH',
    'LTC',
    'TEST'
];
/*
    Name maps
 */
exports.COIN_MAP = {
    Bitcoin: "BTC",
    Cosmos: "ATOM",
    Testnet: "BTCT",
    BitcoinCash: "BCH",
    Litecoin: "LTC",
    Dash: "DASH",
    DigiByte: "DGB",
    Dogecoin: "DOGE",
    Ethereum: "ETH",
    Cardano: "ADA",
    Binance: "BNB",
    Thorchain: "RUNE",
    Eos: "EOS",
    EOS: "EOS",
    Fio: "FIO",
    FIO: "FIO",
};
exports.COIN_MAP_LONG = {
    BTC: "Bitcoin",
    ATOM: "Cosmos",
    BTCT: "testnet",
    BCH: "BitcoinCash",
    LTC: "Litecoin",
    DASH: "Dash",
    DGB: "DigiByte",
    DOGE: "Dogecoin",
    RUNE: "Thorchain",
    ETH: "Ethereum",
    ADA: "Cardano",
    BNB: "Binance",
    EOS: "Eos",
    FIO: "Fio",
};
exports.supportedBlockchains = [];
exports.supportedAssets = [];
if (process.env['FEATURE_BITCOIN_BLOCKCHAIN']) {
    exports.supportedBlockchains.push("Bitcoin");
    exports.supportedAssets.push("BTC");
}
if (process.env['FEATURE_ETHEREUM_BLOCKCHAIN']) {
    exports.supportedBlockchains.push("Ethereum");
    exports.supportedAssets.push("ETH");
    //TODO get token list from npm
    //add all supported
}
if (process.env['FEATURE_THORCHAIN_BLOCKCHAIN']) {
    exports.supportedBlockchains.push("Thorchain");
    exports.supportedAssets.push("RUNE");
}
if (process.env['FEATURE_SECRET_BLOCKCHAIN']) {
    exports.supportedBlockchains.push("Secret");
    exports.supportedAssets.push("SCRT");
}
if (process.env['FEATURE_KAVA_BLOCKCHAIN']) {
    exports.supportedBlockchains.push("Kava");
    exports.supportedAssets.push("KAVA");
}
if (process.env['FEATURE_TERRA_BLOCKCHAIN']) {
    exports.supportedBlockchains.push("Terra");
    exports.supportedAssets.push("LUNA");
}
if (process.env['FEATURE_BSC_BLOCKCHAIN']) {
    exports.supportedBlockchains.push("BinanceSmartChain");
    exports.supportedAssets.push("BNB");
}
if (process.env['FEATURE_CARDANO_BLOCKCHAIN']) {
    exports.supportedBlockchains.push("Cardano");
    exports.supportedAssets.push("ADA");
}
if (process.env['FEATURE_BNB_BLOCKCHAIN']) {
    exports.supportedBlockchains.push("Thorchain");
    exports.supportedAssets.push("RUNE");
}
if (process.env['FEATURE_EOS_BLOCKCHAIN']) {
    exports.supportedBlockchains.push("Eos");
    exports.supportedAssets.push("EOS");
}
if (process.env['FEATURE_FIO_BLOCKCHAIN']) {
    exports.supportedBlockchains.push("Fio");
    exports.supportedAssets.push("FIO");
}
if (process.env['FEATURE_COSMOS_BLOCKCHAIN']) {
    exports.supportedBlockchains.push("Cosmos");
    exports.supportedAssets.push("ATOM");
}
if (process.env['FEATURE_BINANCE_BLOCKCHAIN']) {
    exports.supportedBlockchains.push("Binance");
    exports.supportedAssets.push("BNB");
}
if (process.env['FEATURE_BITCOINCASH_BLOCKCHAIN']) {
    exports.supportedBlockchains.push("BitcoinCash");
    exports.supportedAssets.push("BCH");
}
if (process.env['FEATURE_LITECOIN_BLOCKCHAIN']) {
    exports.supportedBlockchains.push("Litecoin");
    exports.supportedAssets.push("LTC");
}
//TODO add more flags by networks
var PoSchains;
(function (PoSchains) {
    PoSchains[PoSchains["Eos"] = 0] = "Eos";
    PoSchains[PoSchains["Cosmos"] = 1] = "Cosmos";
    PoSchains[PoSchains["Binance"] = 2] = "Binance";
    PoSchains[PoSchains["Fio"] = 3] = "Fio";
    PoSchains[PoSchains["Terra"] = 4] = "Terra";
    PoSchains[PoSchains["Kava"] = 5] = "Kava";
    PoSchains[PoSchains["secret"] = 6] = "secret";
})(PoSchains = exports.PoSchains || (exports.PoSchains = {}));
var CURRENCY_DECIMALS = {
    'btc': 8,
    'rune': 8,
    'dash': 8,
    'atom': 6,
    'ltc': 8,
    'bch': 8,
    'doge': 8,
    'eth': 18,
    'gnt': 18,
    'usdt': 6,
    'trx': 6,
    'bnb': 8,
    'poly': 18,
    'gno': 18,
    'sngls': 0,
    'icn': 18,
    'dgd': 9,
    'mln': 18,
    'rep': 18,
    'swt': 18,
    'wings': 18,
    'trst': 6,
    'rlc': 9,
    'gup': 3,
    'ant': 18,
    'bat': 18,
    'bnt': 18,
    'snt': 18,
    'nmr': 18,
    'edg': 0,
    'eos': 18,
    'cvc': 8,
    'link': 18,
    'knc': 18,
    'mtl': 8,
    'pay': 18,
    'fun': 8,
    'dnt': 18,
    'zrx': 18,
    '1st': 18,
    'omg': 18,
    'salt': 8,
    'rcn': 18,
    'storj': 8,
    'zil': 12,
    'mana': 18,
    'tusd': 18,
    'ae': 18,
    'dai': 18,
    'mkr': 18
};
function getPrecision(asset) {
    if (CURRENCY_DECIMALS[asset.toLowerCase()]) {
        return CURRENCY_DECIMALS[asset.toLowerCase()];
    }
    else {
        throw Error(" Unknown asset! " + asset);
    }
}
exports.getPrecision = getPrecision;
function nativeToBaseAmount(asset, amount) {
    if (!CURRENCY_DECIMALS[asset.toLowerCase()])
        throw Error("Unknown asset!");
    var output = amount / Math.pow(10, CURRENCY_DECIMALS[asset.toLowerCase()]);
    return output;
}
exports.nativeToBaseAmount = nativeToBaseAmount;
function baseAmountToNative(asset, amount) {
    if (!CURRENCY_DECIMALS[asset.toLowerCase()])
        throw Error("Unknown asset!");
    var output = amount * Math.pow(10, CURRENCY_DECIMALS[asset.toLowerCase()]);
    output = parseInt(output);
    return output;
}
exports.baseAmountToNative = baseAmountToNative;
exports.stakingCoins = ["EOS", "ATOM"];
exports.segwitCoins = ["Bitcoin", "Testnet", "BitcoinGold", "Litecoin"];
function getExplorerUrl(network, token, testnet) {
    if (testnet) {
        var href = void 0;
        switch (network) {
            case 'bitcoin':
                href = 'https://blockstream.info/testnet';
                break;
            case 'ethereum':
                href = 'https://ropsten.etherscan.io/';
                break;
        }
        return href;
    }
    else {
        var href = void 0;
        switch (network) {
            case 'bitcoin':
                href = 'https://www.blockchain.com/';
                break;
            case 'ethereum':
                href = 'https://etherscan.io';
                break;
            case 'bitcoinCash':
                href = 'https://blockchair.com/bitcoin-cash';
                break;
            case 'binance':
                href = 'https://explorer.binance.org';
                break;
            case 'cosmos':
                href = 'https://www.mintscan.io';
                break;
            case 'dash':
                return "https://chainz.cryptoid.info/dash";
            case 'doge':
                return "https://dogechain.info";
        }
        return href;
    }
}
exports.getExplorerUrl = getExplorerUrl;
function getExplorerAddressUrl(address, network, token, testnet) {
    if (testnet) {
        var href = void 0;
        switch (network) {
            case 'bitcoin':
                href = 'https://blockstream.info/testnet/address/' + address;
                break;
            case 'ethereum':
                href = 'https://ropsten.etherscan.io/address/' + address;
                break;
        }
        return href;
    }
    else {
        var href = void 0;
        switch (network) {
            //TODO
            // case 'bitcoin':
            //     href = 'https://www.blockchain.com/'
            //     break
            // case 'ethereum':
            //     href = 'https://etherscan.io'
            //     break
            // case 'bitcoinCash':
            //     href = 'https://blockchair.com/bitcoin-cash'
            //     break
            // case 'binance':
            //     href = 'https://explorer.binance.org'
            //     break
            // case 'cosmos':
            //     href = 'https://www.mintscan.io'
            //     break
            // case 'dash':
            //     return `https://chainz.cryptoid.info/dash`
            // case 'doge':
            //     return `https://dogechain.info`
        }
        return href;
    }
}
exports.getExplorerAddressUrl = getExplorerAddressUrl;
function getExplorerTxUrl(tx, network, token, testnet) {
    if (testnet) {
        var href = void 0;
        switch (network) {
            case 'bitcoin':
                href = 'https://blockstream.info/testnet/tx/' + tx;
                break;
            case 'ethereum':
                href = 'https://ropsten.etherscan.io/tx/' + tx;
                break;
        }
        return href;
    }
    else {
        var href = void 0;
        switch (network) {
            //TODO
            // case 'bitcoin':
            //     href = 'https://www.blockchain.com/'
            //     break
            // case 'ethereum':
            //     href = 'https://etherscan.io'
            //     break
            // case 'bitcoinCash':
            //     href = 'https://blockchair.com/bitcoin-cash'
            //     break
            // case 'binance':
            //     href = 'https://explorer.binance.org'
            //     break
            // case 'cosmos':
            //     href = 'https://www.mintscan.io'
            //     break
            // case 'dash':
            //     return `https://chainz.cryptoid.info/dash`
            // case 'doge':
            //     return `https://dogechain.info`
        }
        return href;
    }
}
exports.getExplorerTxUrl = getExplorerTxUrl;
function bech32ify(address, prefix) {
    var words = bech32.toWords(address);
    return bech32.encode(prefix, words);
}
// NOTE: this only works with a compressed public key (33 bytes)
function createBech32Address(publicKey, prefix) {
    var message = CryptoJS.enc.Hex.parse(publicKey.toString("hex"));
    var hash = ripemd160(sha256(message)).toString();
    var address = Buffer.from(hash, "hex");
    var cosmosAddress = bech32ify(address, prefix);
    return cosmosAddress;
}
function normalize_pubkeys(format, pubkeys, pathsIn, isTestnet) {
    return __awaiter(this, void 0, void 0, function () {
        var tag, pathsBySymbol, i, path, output, i, pubkeyRaw, pubkey, normalized, address, _a, e_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    tag = TAG + " | normalize_pubkeys | ";
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 10, , 11]);
                    log.info(tag, "input: ", { format: format, pubkeys: pubkeys, pathsIn: pathsIn, isTestnet: isTestnet });
                    if (!isTestnet)
                        isTestnet = false;
                    pathsBySymbol = {};
                    for (i = 0; i < pathsIn.length; i++) {
                        path = pathsIn[i];
                        pathsBySymbol[path.symbol] = path;
                    }
                    log.info(tag, "pathsBySymbol: ", pathsBySymbol);
                    output = [];
                    if (!(format === 'keepkey')) return [3 /*break*/, 8];
                    i = 0;
                    _b.label = 2;
                case 2:
                    if (!(i < pubkeys.length)) return [3 /*break*/, 7];
                    pubkeyRaw = pathsIn[i];
                    if (!pubkeyRaw) return [3 /*break*/, 6];
                    log.info(tag, "pubkeyRaw: ", pubkeyRaw);
                    pubkey = {};
                    pubkey.path = pubkeys[i].path;
                    pubkey.pathMaster = pubkeys[i].path;
                    //get "real" pubkey
                    pubkey = pathsBySymbol[pubkeyRaw.symbol];
                    log.debug(tag, "pubkey: ", pubkey);
                    pubkey.source = format;
                    pubkey.pubkey = pubkeys[i].xpub;
                    pubkey.xpub = pubkeys[i].xpub;
                    normalized = {};
                    //get "real" coin
                    normalized.note = pubkey.note;
                    normalized.coin = pubkey.symbol;
                    normalized.long = exports.COIN_MAP_LONG[pubkey.symbol];
                    normalized.network = pubkey.symbol;
                    return [4 /*yield*/, get_address_from_xpub(pubkey.xpub, pubkey.script_type, pubkey.symbol, 0, 0, false, isTestnet)];
                case 3:
                    address = _b.sent();
                    if (pubkey.symbol === 'ETH') {
                        normalized.type = "address";
                        normalized.pubkey = address;
                    }
                    else {
                        normalized.type = "xpub";
                        normalized.pubkey = pubkey.xpub;
                    }
                    normalized.script_type = pubkey.script_type; //TODO select script type?
                    if (!(isTestnet && pubkey.symbol === 'BTC')) return [3 /*break*/, 5];
                    //tpub
                    _a = normalized;
                    return [4 /*yield*/, cloneCrypto.xpubConvert(pubkey.xpub, 'tpub')];
                case 4:
                    //tpub
                    _a.tpub = _b.sent();
                    _b.label = 5;
                case 5:
                    normalized.xpub = pubkey.xpub;
                    normalized.master = address; //TODO
                    normalized.address = address; //TODO
                    output.push(normalized);
                    _b.label = 6;
                case 6:
                    i++;
                    return [3 /*break*/, 2];
                case 7: return [3 /*break*/, 9];
                case 8: throw Error(" unknown format! ");
                case 9: return [2 /*return*/, output];
                case 10:
                    e_1 = _b.sent();
                    log.error(tag, "e: ", e_1);
                    return [3 /*break*/, 11];
                case 11: return [2 /*return*/];
            }
        });
    });
}
exports.normalize_pubkeys = normalize_pubkeys;
function get_address_from_xpub(xpub, scriptType, coin, account, index, isChange, isTestnet) {
    return __awaiter(this, void 0, void 0, function () {
        var tag, output, publicKey, _a, e_2;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    tag = TAG + " | get_address_from_xpub | ";
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 19, , 20]);
                    output = void 0;
                    log.info(tag, "Input: ", { xpub: xpub, scriptType: scriptType, coin: coin, account: account, index: index, isChange: isChange, isTestnet: isTestnet });
                    //if xpub get next unused
                    if (!xpub)
                        throw Error("xpub required! coin:" + coin);
                    publicKey = bitcoin.bip32.fromBase58(xpub).derive(account).derive(index).publicKey;
                    log.info("publicKey: ********* ", coin);
                    log.info("publicKey: ********* ", publicKey);
                    log.info("isTestnet: ", isTestnet);
                    _a = coin;
                    switch (_a) {
                        case 'BTC': return [3 /*break*/, 2];
                        case 'BCH': return [3 /*break*/, 4];
                        case 'DOGE': return [3 /*break*/, 6];
                        case 'DASH': return [3 /*break*/, 8];
                        case 'LTC': return [3 /*break*/, 10];
                        case 'ETH': return [3 /*break*/, 12];
                        case 'RUNE': return [3 /*break*/, 13];
                        case 'ATOM': return [3 /*break*/, 14];
                        case 'BNB': return [3 /*break*/, 15];
                        case 'RUNE': return [3 /*break*/, 16];
                    }
                    return [3 /*break*/, 17];
                case 2:
                    //TODO more types
                    console.log("CHECKPOINT");
                    return [4 /*yield*/, cloneCrypto.generateAddress('BTC', publicKey, 'p2pkh', isTestnet)];
                case 3:
                    output = _b.sent();
                    return [3 /*break*/, 18];
                case 4: return [4 /*yield*/, cloneCrypto.generateAddress('BCH', publicKey, 'p2sh', isTestnet)];
                case 5:
                    //TODO more types
                    output = _b.sent();
                    return [3 /*break*/, 18];
                case 6: return [4 /*yield*/, cloneCrypto.generateAddress('DOGE', publicKey, 'bech32', isTestnet)];
                case 7:
                    //TODO more types
                    output = _b.sent();
                    return [3 /*break*/, 18];
                case 8: return [4 /*yield*/, cloneCrypto.generateAddress('DASH', publicKey, 'bech32', isTestnet)];
                case 9:
                    //TODO more types
                    output = _b.sent();
                    return [3 /*break*/, 18];
                case 10: return [4 /*yield*/, cloneCrypto.generateAddress('LTC', publicKey, 'bech32', isTestnet)];
                case 11:
                    //TODO more types
                    output = _b.sent();
                    return [3 /*break*/, 18];
                case 12:
                    output = ethUtils.bufferToHex(ethUtils.pubToAddress(publicKey, true));
                    return [3 /*break*/, 18];
                case 13:
                    // code block
                    output = createBech32Address(publicKey, 'tthor');
                    return [3 /*break*/, 18];
                case 14:
                    // code block
                    output = createBech32Address(publicKey, 'cosmos');
                    return [3 /*break*/, 18];
                case 15:
                    // code block
                    log.debug("pubkey: ", publicKey);
                    if (!isTestnet) {
                        output = createBech32Address(publicKey, 'bnb');
                    }
                    else {
                        output = createBech32Address(publicKey, 'tbnb');
                    }
                    return [3 /*break*/, 18];
                case 16:
                    // code block
                    log.debug("pubkey: ", publicKey);
                    if (!isTestnet) {
                        output = createBech32Address(publicKey, 'thor');
                    }
                    else {
                        output = createBech32Address(publicKey, 'tthor');
                    }
                    return [3 /*break*/, 18];
                case 17: throw Error("coin not yet implemented ! coin: " + coin);
                case 18:
                    log.debug(tag, "output: ", output);
                    return [2 /*return*/, output];
                case 19:
                    e_2 = _b.sent();
                    log.error(tag, "e: ", e_2);
                    return [3 /*break*/, 20];
                case 20: return [2 /*return*/];
            }
        });
    });
}
exports.get_address_from_xpub = get_address_from_xpub;
