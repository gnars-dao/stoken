"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
exports.pioneerPrivateController = exports.ApiError = void 0;
/*

    Pioneer REST endpoints



 */
var TAG = ' | API | ';
var pjson = require('../../package.json');
var log = require('@pioneer-platform/loggerdog')();
log.info(TAG, "PIONEER VERSION: ", pjson.version);
var _a = require('@pioneer-platform/default-redis'), subscriber = _a.subscriber, publisher = _a.publisher, redis = _a.redis, redisQueue = _a.redisQueue;
var connection = require("@pioneer-platform/default-mongo");
var queue = require("@pioneer-platform/redis-queue");
var randomstring = require("randomstring");
var coincap = require('@pioneer-platform/coincap');
var usersDB = connection.get('users');
var pubkeysDB = connection.get('pubkeys');
var txsDB = connection.get('transactions');
var utxosDB = connection.get('utxo');
usersDB.createIndex({ id: 1 }, { unique: true });
usersDB.createIndex({ username: 1 }, { unique: true });
txsDB.createIndex({ txid: 1 }, { unique: true });
utxosDB.createIndex({ txid: 1 }, { unique: true });
pubkeysDB.createIndex({ pubkey: 1 }, { unique: true });
var axios = require('axios');
var network = require("@pioneer-platform/network");
var uuid_1 = require("uuid");
//globals
//modules
var pioneer = require('../pioneer');
//rest-ts
var tsoa_1 = require("tsoa");
var PIONEER_INFO_CACHE_TIME = process.env['PIONEER_INFO_CACHE_TIME'] || 60 * 5;
var AuthProviders;
(function (AuthProviders) {
    AuthProviders["shapeshift"] = "shapeshift";
    AuthProviders["bitcoin"] = "bitcoin";
})(AuthProviders || (AuthProviders = {}));
var short = require('short-uuid');
var ApiError = /** @class */ (function (_super) {
    __extends(ApiError, _super);
    function ApiError(name, statusCode, message) {
        var _this = _super.call(this, message) || this;
        _this.name = name;
        _this.statusCode = statusCode;
        return _this;
    }
    return ApiError;
}(Error));
exports.ApiError = ApiError;
//route
var pioneerPrivateController = /** @class */ (function (_super) {
    __extends(pioneerPrivateController, _super);
    function pioneerPrivateController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
            Forget Account
                Clear transactions
     */
    pioneerPrivateController.prototype.forget = function (authorization) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, output, accountInfo, username, _a, _b, _c, _d, _e, _f, e_1, errorResp;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        tag = TAG + " | forget | ";
                        _g.label = 1;
                    case 1:
                        _g.trys.push([1, 9, , 10]);
                        log.debug(tag, "queryKey: ", authorization);
                        output = {};
                        return [4 /*yield*/, redis.hgetall(authorization)];
                    case 2:
                        accountInfo = _g.sent();
                        username = accountInfo.username;
                        if (!username)
                            throw Error("unknown token! token: " + authorization);
                        log.debug(tag, "accountInfo: ", accountInfo);
                        //del redis
                        _a = output;
                        return [4 /*yield*/, redis.del(accountInfo.username + ":cache:walletInfo")];
                    case 3:
                        //del redis
                        _a.cacheWallet = _g.sent();
                        _b = output;
                        return [4 /*yield*/, redis.del(authorization)];
                    case 4:
                        _b.cacheAuth = _g.sent();
                        _c = output;
                        return [4 /*yield*/, redis.del(accountInfo.username)
                            //delete mongo
                        ];
                    case 5:
                        _c.cacheUser = _g.sent();
                        //delete mongo
                        _d = output;
                        return [4 /*yield*/, usersDB.remove({ username: username })
                            //remove all pubkeys
                        ];
                    case 6:
                        //delete mongo
                        _d.userDelete = _g.sent();
                        //remove all pubkeys
                        _e = output;
                        return [4 /*yield*/, pubkeysDB.remove({ tags: { $all: [accountInfo.username] } })
                            //remove all pubkeys
                        ];
                    case 7:
                        //remove all pubkeys
                        _e.pubkeysDelete = _g.sent();
                        //remove all pubkeys
                        _f = output;
                        return [4 /*yield*/, txsDB.remove({ tags: { $all: [accountInfo.username] } })];
                    case 8:
                        //remove all pubkeys
                        _f.txsDelete = _g.sent();
                        return [2 /*return*/, output];
                    case 9:
                        e_1 = _g.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_1
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_1.toString());
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    /**
     Get the balances for a given username

     protect mongo with redis cache

     protect nodes with mongo data

     All events push OUT in production

        nodes ->  mongo -> redis -> (ws) user local db


     */
    pioneerPrivateController.prototype.info = function (walletId, authorization) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, accountInfo, walletInfo, isTestnet, username, isKnownWallet, userInfo, pubkeysMongo, pubkeys, masters, i, pubkeyInfo, assetBalances, valuePortfolio, _a, e_2, errorResp;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        tag = TAG + " | info | ";
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 12, , 13]);
                        log.info(tag, "queryKey: ", authorization);
                        log.info(tag, "walletId: ", walletId);
                        return [4 /*yield*/, redis.hgetall(authorization)];
                    case 2:
                        accountInfo = _b.sent();
                        if (!accountInfo)
                            throw Error("unknown token! token:" + authorization);
                        log.info(tag, "accountInfo: ", accountInfo);
                        walletInfo = void 0;
                        if (!accountInfo) return [3 /*break*/, 10];
                        log.info(tag, "accountInfo: ", accountInfo);
                        isTestnet = accountInfo.isTestnet || false;
                        username = accountInfo.username;
                        if (!username) {
                            log.error(tag, "invalid accountInfo: ", accountInfo);
                            throw Error("unknown token. token:" + authorization);
                        }
                        return [4 /*yield*/, redis.sismember(username + ':wallets', walletId)];
                    case 3:
                        isKnownWallet = _b.sent();
                        log.info(tag, "isKnownWallet: ", isKnownWallet);
                        if (!!walletId) return [3 /*break*/, 5];
                        return [4 /*yield*/, redis.hgetall(username)];
                    case 4:
                        userInfo = _b.sent();
                        log.info(tag, "userInfo: ", userInfo);
                        walletId = userInfo.context;
                        if (!walletId)
                            throw Error("No walletId on username! username: " + username);
                        _b.label = 5;
                    case 5:
                        walletInfo = {};
                        log.debug(tag, "user info NOT cached!: ");
                        log.info(tag, "walletId: ", walletId);
                        return [4 /*yield*/, pubkeysDB.find({ tags: { $all: [walletId] } })];
                    case 6:
                        pubkeysMongo = _b.sent();
                        log.info(tag, "pubkeysMongo: ", pubkeysMongo);
                        pubkeys = [];
                        masters = {};
                        for (i = 0; i < pubkeysMongo.length; i++) {
                            pubkeyInfo = pubkeysMongo[i];
                            delete pubkeyInfo._id;
                            //TODO validate pubkeys?
                            masters[pubkeyInfo.coin] = pubkeyInfo.master;
                            pubkeys.push(pubkeyInfo);
                        }
                        //build wallet info
                        walletInfo.pubkeys = pubkeys;
                        walletInfo.masters = masters;
                        return [4 /*yield*/, redis.hgetall(username + ":assets:" + walletId)];
                    case 7:
                        assetBalances = _b.sent();
                        log.info(tag, "assetBalances: ", assetBalances);
                        walletInfo.balances = assetBalances;
                        return [4 /*yield*/, coincap.valuePortfolio(assetBalances)];
                    case 8:
                        valuePortfolio = _b.sent();
                        log.info(tag, "valuePortfolio: ", valuePortfolio);
                        walletInfo.valueUsds = valuePortfolio.values;
                        walletInfo.totalValueUsd = valuePortfolio.total;
                        redis.hset(username, 'totalValueUsd', valuePortfolio.total);
                        walletInfo.username = username;
                        walletInfo.walletId = walletId;
                        _a = walletInfo;
                        return [4 /*yield*/, redis.smembers(username + ":apps")];
                    case 9:
                        _a.apps = _b.sent();
                        return [2 /*return*/, walletInfo];
                    case 10: return [2 /*return*/, {
                            error: true,
                            message: "101: Token not found! auth: " + authorization
                        }];
                    case 11: return [3 /*break*/, 13];
                    case 12:
                        e_2 = _b.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_2
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_2.toString());
                    case 13: return [2 /*return*/];
                }
            });
        });
    };
    pioneerPrivateController.prototype.user = function (authorization) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, accountInfo, username, userInfo, wallets, e_3, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | info | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 8, , 9]);
                        log.info(tag, "queryKey: ", authorization);
                        return [4 /*yield*/, redis.hgetall(authorization)];
                    case 2:
                        accountInfo = _a.sent();
                        if (!!accountInfo) return [3 /*break*/, 3];
                        return [2 /*return*/, {
                                success: false,
                                error: "QueryKey not registerd!"
                            }];
                    case 3:
                        log.info(tag, "accountInfo: ", accountInfo);
                        username = accountInfo.username;
                        if (!username) {
                        }
                        return [4 /*yield*/, redis.hgetall(username)];
                    case 4:
                        userInfo = _a.sent();
                        log.info(tag, "userInfo: ", userInfo);
                        if (!(Object.keys(userInfo).length === 0)) return [3 /*break*/, 5];
                        return [2 /*return*/, {
                                success: false,
                                error: "QueryKey not paired!"
                            }];
                    case 5: return [4 /*yield*/, redis.smembers(username + ":wallets")];
                    case 6:
                        wallets = _a.sent();
                        userInfo.wallets = wallets;
                        return [2 /*return*/, userInfo];
                    case 7: return [3 /*break*/, 9];
                    case 8:
                        e_3 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_3
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_3.toString());
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    /**
     Get the balances for a given username
     */
    pioneerPrivateController.prototype.context = function (authorization) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, accountInfo, walletInfo, username, userInfo, e_4, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | balance | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 6, , 7]);
                        log.debug(tag, "queryKey: ", authorization);
                        return [4 /*yield*/, redis.hgetall(authorization)];
                    case 2:
                        accountInfo = _a.sent();
                        if (!accountInfo)
                            throw Error("unknown token! token:" + authorization);
                        log.info(tag, "accountInfo: ", accountInfo);
                        walletInfo = void 0;
                        if (!accountInfo) return [3 /*break*/, 4];
                        username = accountInfo.username;
                        if (!username) {
                            log.error(tag, "invalid accountInfo: ", accountInfo);
                            throw Error("unknown token. token:" + authorization);
                        }
                        return [4 /*yield*/, redis.hgetall(username)];
                    case 3:
                        userInfo = _a.sent();
                        log.info(tag, "userInfo: ", userInfo);
                        return [2 /*return*/, userInfo.context];
                    case 4: throw Error("102: invalid auth token!");
                    case 5: return [3 /*break*/, 7];
                    case 6:
                        e_4 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_4
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_4.toString());
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
        Get the balances for a given username
     */
    pioneerPrivateController.prototype.balance = function (coin, authorization) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, accountInfo, username, balance, userInfo, pubkeys, i, pubkeyInfo, e_5, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | balance | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 10, , 11]);
                        log.debug(tag, "queryKey: ", authorization);
                        log.debug(tag, "coin: ", coin);
                        return [4 /*yield*/, redis.hgetall(authorization)];
                    case 2:
                        accountInfo = _a.sent();
                        username = accountInfo.username;
                        if (!username)
                            throw Error("unknown token! token:" + authorization);
                        //get cache
                        log.debug(tag, "cache path: ", accountInfo.username + ":cache:" + coin + ":balance");
                        return [4 /*yield*/, redis.get(accountInfo.username + ":cache:" + coin + ":balance")];
                    case 3:
                        balance = _a.sent();
                        log.debug(tag, "balance: ", balance);
                        if (!balance) return [3 /*break*/, 4];
                        return [2 /*return*/, (JSON.parse(balance))];
                    case 4:
                        log.debug(tag, "username: ", username);
                        return [4 /*yield*/, usersDB.findOne({ username: username })];
                    case 5:
                        userInfo = _a.sent();
                        if (!userInfo) {
                            throw Error("102: unknown user! username: " + username);
                        }
                        log.debug(tag, "userInfo: ", userInfo);
                        pubkeys = {};
                        for (i = 0; i < userInfo.pubkeys.length; i++) {
                            pubkeyInfo = userInfo.pubkeys[i];
                            pubkeys[pubkeyInfo.coin] = pubkeyInfo;
                        }
                        //import into wallet
                        return [4 /*yield*/, network.init('full', {
                                pubkeys: pubkeys
                            })
                            //get wallet info
                        ];
                    case 6:
                        //import into wallet
                        _a.sent();
                        return [4 /*yield*/, network.getBalance(coin)
                            //write to cache
                        ];
                    case 7:
                        //get wallet info
                        balance = _a.sent();
                        //write to cache
                        return [4 /*yield*/, redis.setex(accountInfo.username + ":cache:" + coin + ":balance", 1000 * 5, JSON.stringify(balance))];
                    case 8:
                        //write to cache
                        _a.sent();
                        _a.label = 9;
                    case 9: return [2 /*return*/, balance];
                    case 10:
                        e_5 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_5
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_5.toString());
                    case 11: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Pair an sdk with app
     * @param request This is an application pairing submission
     */
    pioneerPrivateController.prototype.pair = function (body, Authorization) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, userInfo, sdkQueryKey, url, isWhitelisted, pushAppMongo, sdkUser, saveRedis, output, e_6, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | pair | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 8, , 9]);
                        log.info(tag, "account: ", body);
                        log.info(tag, "Authorization: ", Authorization);
                        return [4 /*yield*/, redis.hgetall(Authorization)];
                    case 2:
                        userInfo = _a.sent();
                        log.info(tag, "userInfo: ", userInfo);
                        //if no info throw
                        if (!userInfo)
                            throw Error("User not known!");
                        if (!userInfo.username)
                            throw Error("invalid user!");
                        return [4 /*yield*/, redis.hget(body.code, "pairing")];
                    case 3:
                        sdkQueryKey = _a.sent();
                        if (!sdkQueryKey)
                            throw Error("unknown code!");
                        log.info(tag, "sdkQueryKey: ", sdkQueryKey);
                        return [4 /*yield*/, redis.hget(body.code, "url")
                            // if in whitelist
                        ];
                    case 4:
                        url = _a.sent();
                        return [4 /*yield*/, redis.sismember('serviceUrls', url)
                            // let app = {
                            //     added:new Date().getTime(),
                            //     url
                            //     //More?
                            // }
                            //push to username cache
                        ];
                    case 5:
                        isWhitelisted = _a.sent();
                        // let app = {
                        //     added:new Date().getTime(),
                        //     url
                        //     //More?
                        // }
                        //push to username cache
                        redis.sadd(userInfo.username + ":apps", url);
                        return [4 /*yield*/, usersDB.update({ username: userInfo.username }, { $addToSet: { apps: url } })];
                    case 6:
                        pushAppMongo = _a.sent();
                        log.info(tag, "pushAppMongo: ", pushAppMongo);
                        sdkUser = {
                            username: userInfo.username,
                            paired: new Date().getTime(),
                            queryKey: sdkQueryKey,
                            url: url
                        };
                        publisher.publish('pairings', JSON.stringify(sdkUser));
                        return [4 /*yield*/, redis.hmset(sdkQueryKey, sdkUser)];
                    case 7:
                        saveRedis = _a.sent();
                        output = {
                            user: sdkUser,
                            url: url,
                            saveRedis: saveRedis,
                            trusted: isWhitelisted
                        };
                        return [2 /*return*/, (output)];
                    case 8:
                        e_6 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_6
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_6.toString());
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Pair an sdk with app
     * @param request This is an application pairing request
     */
    pioneerPrivateController.prototype.createPairingCode = function (body, Authorization) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, userInfo, code, saveRedis, output, e_7, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | createPairingCode | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 4, , 5]);
                        log.debug(tag, "account: ", body);
                        log.debug(tag, "Authorization: ", Authorization);
                        return [4 /*yield*/, redis.hgetall(Authorization)];
                    case 2:
                        userInfo = _a.sent();
                        log.info(tag, "userInfo: ", userInfo);
                        code = randomstring.generate(6);
                        code = code.toUpperCase();
                        log.info(tag, "code: ", code);
                        return [4 /*yield*/, redis.hset(code, "pairing", Authorization)];
                    case 3:
                        saveRedis = _a.sent();
                        redis.hset(code, "url", body.url);
                        output = {
                            code: code,
                            saveRedis: saveRedis
                        };
                        return [2 /*return*/, (output)];
                    case 4:
                        e_7 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_7
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_7.toString());
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Create an api key
     * @param request This is a user creation request description
     */
    pioneerPrivateController.prototype.createApiKey = function (body, Authorization) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, account, accountInfo, newKey, isMember, createdDate, output, e_8, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | createApiKey | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 8, , 9]);
                        log.debug(tag, "account: ", body);
                        log.debug(tag, "Authorization: ", Authorization);
                        //username
                        if (!body.account)
                            throw Error("102: missing account");
                        account = body.account;
                        return [4 /*yield*/, redis.hgetall(body.account)];
                    case 2:
                        accountInfo = _a.sent();
                        log.debug(tag, "accountInfo: ", accountInfo);
                        newKey = short.generate();
                        log.debug(tag, "newKey: ", newKey);
                        isMember = false;
                        createdDate = new Date().getTime();
                        return [4 /*yield*/, redis.hset(newKey, 'account', account)];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, redis.hset(newKey, 'username', account)];
                    case 4:
                        _a.sent();
                        if (!isMember) return [3 /*break*/, 6];
                        return [4 /*yield*/, redis.hset(newKey, 'isMember', "true")];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6: return [4 /*yield*/, redis.hset(newKey, 'created', createdDate)];
                    case 7:
                        _a.sent();
                        output = {
                            queryKey: newKey,
                            created: createdDate,
                            isMember: isMember,
                            permissions: ['READ', 'SUBSCRIBE']
                        };
                        return [2 /*return*/, (output)];
                    case 8:
                        e_8 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_8
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_8.toString());
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * get utxos
     * @param request This is a users unspent txs
     */
    pioneerPrivateController.prototype.getUtxos = function (body, Authorization) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, accountInfo, utxos, e_9, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | getUtxos | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 6, , 7]);
                        log.debug(tag, "account: ", body);
                        log.debug(tag, "Authorization: ", Authorization);
                        return [4 /*yield*/, redis.hgetall(Authorization)];
                    case 2:
                        accountInfo = _a.sent();
                        log.debug(tag, "accountInfo: ", accountInfo);
                        if (!accountInfo) return [3 /*break*/, 4];
                        return [4 /*yield*/, utxosDB.find({ accounts: { $all: [accountInfo.username] } })];
                    case 3:
                        utxos = _a.sent();
                        log.info(tag, "utxos: ", utxos);
                        return [2 /*return*/, (utxos)];
                    case 4: throw Error("user not found!");
                    case 5: return [3 /*break*/, 7];
                    case 6:
                        e_9 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_9
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_9.toString());
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get transaction history
     *
     * start block
     * end block
     * coin
     *
     */
    pioneerPrivateController.prototype.transactions = function (authorization, body) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, accountInfo, username, coin, startBlock, query, txs, output, i, tx, type, from, to, amount, fee, j, event_1, addressInfo, summary, e_10, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | transactions | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 11, , 12]);
                        log.debug("************************** CHECKPOINT *******************88 ");
                        log.debug(tag, "body: ", body);
                        log.debug(tag, "queryKey: ", authorization);
                        return [4 /*yield*/, redis.hgetall(authorization)];
                    case 2:
                        accountInfo = _a.sent();
                        if (Object.keys(accountInfo).length === 0)
                            throw Error("102: Unknown Api key! ");
                        log.debug(tag, "accountInfo: ", accountInfo);
                        username = accountInfo.username;
                        coin = body.coin;
                        startBlock = body.startBlock;
                        if (!startBlock)
                            startBlock = 0;
                        query = {
                            $and: [
                                { asset: coin },
                                { height: { $gt: startBlock } },
                                { accounts: username }
                            ]
                        };
                        /*
                            How to do range
                            db.users.count({
                                marks: {$elemMatch: {$gte: 20, $lt: 30}}
                            })
                         */
                        log.debug(tag, "query: ", JSON.stringify(query));
                        return [4 /*yield*/, txsDB.find(query, { limit: 300, maxTimeMS: 30 * 1000 })];
                    case 3:
                        txs = _a.sent();
                        log.debug("txs: ", txs);
                        output = [];
                        i = 0;
                        _a.label = 4;
                    case 4:
                        if (!(i < txs.length)) return [3 /*break*/, 10];
                        tx = txs[i];
                        type = void 0;
                        from = void 0;
                        to = void 0;
                        amount = void 0;
                        fee = void 0;
                        log.debug(tag, "tx: ", tx);
                        j = 0;
                        _a.label = 5;
                    case 5:
                        if (!(j < tx.events.length)) return [3 /*break*/, 8];
                        event_1 = tx.events[j];
                        log.debug(tag, "event: ", event_1);
                        return [4 /*yield*/, redis.smembers(event_1.address + ":accounts")];
                    case 6:
                        addressInfo = _a.sent();
                        if (addressInfo.indexOf(username) >= 0 && event_1.type === 'debit') {
                            type = 'send';
                        }
                        if (addressInfo.indexOf(username) >= 0 && event_1.type === 'credit') {
                            type = 'receive';
                        }
                        if (event_1.type === 'debit' && !event_1.fee) {
                            from = event_1.address;
                        }
                        if (event_1.type === 'debit' && event_1.fee) {
                            fee = {
                                asset: tx.asset
                            };
                        }
                        if (event_1.type === 'credit') {
                            to = event_1.address;
                            amount = event_1.amount;
                        }
                        _a.label = 7;
                    case 7:
                        j++;
                        return [3 /*break*/, 5];
                    case 8:
                        //default (TODO dont do this)
                        if (!fee) {
                            fee = {
                                "amount": 0.0002,
                                "asset": "ETH"
                            };
                        }
                        summary = {
                            type: type,
                            asset: tx.asset,
                            from: from,
                            to: to,
                            amount: amount,
                            fee: fee,
                            txid: tx.txid,
                            height: tx.height,
                            time: tx.time
                        };
                        output.push(summary);
                        _a.label = 9;
                    case 9:
                        i++;
                        return [3 /*break*/, 4];
                    case 10: return [2 /*return*/, (output)];
                    case 11:
                        e_10 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_10
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_10.toString());
                    case 12: return [2 /*return*/];
                }
            });
        });
    };
    /**
     *  Create a user account on Pioneer
     *
     *  Auth providers
     *
     *     * Shapeshift
     *
     *     * Keypair
     *
     *
     *
     *
     *  NOTE:
     *
     *  Any already REGISTERED user may use this name to register additional coins/pubkeys or update context or state
     *
     *
     *  Output:
     *      QueryToken: (SUBSCRIBE/INFO permissions)
     *          Blockchain and payment info
     *
     *  Auth providers may issue/revoke Query tokens
     *
     * @param request This is a user creation
     */
    pioneerPrivateController.prototype.register = function (authorization, body) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, output, newKey, authInfo, isTestnet, username, userInfo, userInfoMongo, userInfo, _a, redisSuccess, redisSuccessAuth, redisSuccessKey, _b, userWallets, pubkeys, _c, _d, _e, userInfoRedis, e_11, errorResp;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        tag = TAG + " | register | ";
                        _f.label = 1;
                    case 1:
                        _f.trys.push([1, 25, , 26]);
                        output = {};
                        newKey = void 0;
                        log.info(tag, "body: ", body);
                        if (!body.walletName)
                            throw Error("walletName required on body!");
                        return [4 /*yield*/, redis.hgetall(authorization)];
                    case 2:
                        authInfo = _f.sent();
                        log.info(tag, "authInfo: ", authInfo);
                        isTestnet = authInfo.isTestnet || false;
                        if (body.isTestnet && Object.keys(authInfo).length != 0 && !isTestnet)
                            throw Error(" Username already registerd on mainnet! please create a new");
                        log.debug(tag, "authInfo: ", authInfo);
                        username = void 0;
                        if (!(Object.keys(authInfo).length > 0)) return [3 /*break*/, 6];
                        log.debug(tag, "checkpoint 1 auth key known");
                        username = authInfo.username;
                        if (!username)
                            throw Error("102: invalid auth data!");
                        if (!(username !== body.username)) return [3 /*break*/, 4];
                        return [4 /*yield*/, redis.hgetall(body.username)];
                    case 3:
                        userInfo = _f.sent();
                        if (Object.keys(userInfo).length > 0) {
                            throw Error("103: unable create new user, username taken!");
                        }
                        else {
                            log.error(tag, "authInfo.username: ", authInfo.username);
                            log.error(tag, "username: ", body.username);
                            throw Error("104: username transfers on tokens not supported! owned username:" + username);
                        }
                        return [3 /*break*/, 5];
                    case 4:
                        log.info("username available! checkpoint 1a");
                        _f.label = 5;
                    case 5: return [3 /*break*/, 7];
                    case 6:
                        log.info(tag, "checkpoint 1a auth key NOT known");
                        newKey = true;
                        _f.label = 7;
                    case 7:
                        if (!username)
                            username = body.username;
                        return [4 /*yield*/, usersDB.findOne({ username: username })];
                    case 8:
                        userInfoMongo = _f.sent();
                        log.info(tag, "userInfoMongo: ", userInfoMongo);
                        if (!newKey) return [3 /*break*/, 17];
                        userInfo = {
                            registered: new Date().getTime(),
                            id: "pioneer:" + pjson.version + ":" + uuid_1.v4(),
                            username: body.username,
                            verified: true,
                            wallets: [body.walletName] // just one wallet for now
                        };
                        if (!!userInfoMongo) return [3 /*break*/, 10];
                        _a = output;
                        return [4 /*yield*/, usersDB.insert(userInfo)];
                    case 9:
                        _a.resultSaveUserDB = _f.sent();
                        _f.label = 10;
                    case 10: return [4 /*yield*/, redis.hmset(body.username, userInfo)];
                    case 11:
                        redisSuccess = _f.sent();
                        log.info(tag, "redisSuccess: ", redisSuccess);
                        return [4 /*yield*/, redis.hmset(body.auth, userInfo)];
                    case 12:
                        redisSuccessAuth = _f.sent();
                        log.info(tag, "redisSuccessAuth: ", redisSuccessAuth);
                        return [4 /*yield*/, redis.hmset(authorization, userInfo)];
                    case 13:
                        redisSuccessKey = _f.sent();
                        log.info(tag, "redisSuccessKey: ", redisSuccessKey);
                        //Continue and register wallet
                        userInfoMongo = userInfo;
                        //Assume wallet new
                        _b = output;
                        return [4 /*yield*/, pioneer.register(body.username, body.data.pubkeys, body.walletName)];
                    case 14:
                        //Assume wallet new
                        _b.result = _f.sent();
                        log.info(tag, "resultPioneer: ", output.result);
                        //set user context to only wallet
                        return [4 /*yield*/, redis.hset(body.username, 'context', body.walletName)
                            //add to wallet set
                        ];
                    case 15:
                        //set user context to only wallet
                        _f.sent();
                        //add to wallet set
                        return [4 /*yield*/, redis.sadd(username + ':wallets', body.walletName)];
                    case 16:
                        //add to wallet set
                        _f.sent();
                        _f.label = 17;
                    case 17:
                        userWallets = userInfoMongo.wallets;
                        if (!userWallets)
                            throw Error("No wallets found!");
                        //add to wallet set
                        return [4 /*yield*/, redis.sadd(username + ':wallets', body.walletName)
                            //if current ! found
                        ];
                    case 18:
                        //add to wallet set
                        _f.sent();
                        if (!(userWallets.indexOf(body.walletName) < 0)) return [3 /*break*/, 21];
                        log.info(tag, "Registering new walelt! walletName:", body.walletName);
                        //Register wallet! (this ONLY hits when already registered
                        output.newWallet = true;
                        pubkeys = body.data.pubkeys;
                        _c = output;
                        return [4 /*yield*/, pioneer.register(body.username, pubkeys, body.walletName)];
                    case 19:
                        _c.result = _f.sent();
                        log.info(tag, "resultPioneer: ", output.result);
                        //set current context to newly registred wallet
                        //TODO flag to leave context? (silent register new wallet?)
                        //await redis.hset(body.username,'context',body.walletName)
                        //push new wallet to wallets
                        _d = output;
                        return [4 /*yield*/, usersDB.update({}, { $addToSet: { "wallets": body.walletName } })];
                    case 20:
                        //set current context to newly registred wallet
                        //TODO flag to leave context? (silent register new wallet?)
                        //await redis.hset(body.username,'context',body.walletName)
                        //push new wallet to wallets
                        _d.updateDBUser = _f.sent();
                        return [3 /*break*/, 23];
                    case 21:
                        //wallet already known!
                        log.info(tag, "Wallet already known! walletName: ", body.walletName);
                        //get pubkey array
                        _e = output;
                        return [4 /*yield*/, pioneer.update(body.username, body.data.pubkeys, body.walletName)];
                    case 22:
                        //get pubkey array
                        _e.result = _f.sent();
                        _f.label = 23;
                    case 23:
                        log.info("checkpoint 3");
                        return [4 /*yield*/, redis.hgetall(username)];
                    case 24:
                        userInfoRedis = _f.sent();
                        log.info(tag, "userInfoRedis: ", userInfoRedis);
                        log.info("checkpoint 4 final ");
                        output.success = true;
                        output.userInfo = userInfoRedis;
                        return [2 /*return*/, output];
                    case 25:
                        e_11 = _f.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_11
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_11.toString());
                    case 26: return [2 /*return*/];
                }
            });
        });
    };
    /**
     *  Import Pubkeys
     *
     *  Bulk add address's to be tracked under a username
     *
     */
    pioneerPrivateController.prototype["import"] = function (authorization, body) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, output, newKey, authInfo, username, userInfoMongo, saveActions, i, pubkeyInfo, entry, work, _a, e_12, userInfoRedis, e_13, errorResp;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        tag = TAG + " | import | ";
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 10, , 11]);
                        output = {};
                        newKey = void 0;
                        log.debug(tag, "body: ", body);
                        return [4 /*yield*/, redis.hgetall(authorization)];
                    case 2:
                        authInfo = _b.sent();
                        log.debug(tag, "authInfo: ", authInfo);
                        username = void 0;
                        if (Object.keys(authInfo).length > 0) {
                            log.debug(tag, "checkpoint 1 auth key known");
                            username = authInfo.username;
                            if (!username)
                                throw Error("102: invalid auth data!");
                        }
                        else {
                            log.info(tag, "checkpoint 1a auth key NOT known");
                            newKey = true;
                        }
                        if (!username)
                            throw Error("104: unable to find username!");
                        return [4 /*yield*/, usersDB.findOne({ username: username })];
                    case 3:
                        userInfoMongo = _b.sent();
                        log.info(tag, "userInfoMongo: ", userInfoMongo);
                        log.info("checkpoint 2 post mongo query!");
                        if (!(!userInfoMongo || newKey)) return [3 /*break*/, 4];
                        log.info("checkpoint 2a no mongo info!");
                        throw Error("unable to import until AFTER registered!");
                    case 4:
                        saveActions = [];
                        //bulk update mongo
                        for (i = 0; i < body.pubkeys.length; i++) {
                            pubkeyInfo = body.pubkeys[i];
                            log.debug(tag, "pubkey: ", pubkeyInfo);
                            entry = {
                                coin: body.coin,
                                path: pubkeyInfo.path,
                                created: new Date().getTime(),
                                tags: [body.source, username],
                                pubkey: pubkeyInfo.address
                            };
                            work = {
                                address: pubkeyInfo.address,
                                account: username
                            };
                            queue.createWork(body.coin + ":address:queue:ingest", work);
                            //save all
                            saveActions.push({ insertOne: entry });
                        }
                        output.count = saveActions.length;
                        _b.label = 5;
                    case 5:
                        _b.trys.push([5, 7, , 8]);
                        _a = output;
                        return [4 /*yield*/, pubkeysDB.bulkWrite(saveActions)];
                    case 6:
                        _a.resultSaveDB = _b.sent();
                        return [3 /*break*/, 8];
                    case 7:
                        e_12 = _b.sent();
                        output.resultSaveDB = e_12;
                        return [3 /*break*/, 8];
                    case 8:
                        log.info("checkpoint 3");
                        return [4 /*yield*/, redis.hgetall(username)];
                    case 9:
                        userInfoRedis = _b.sent();
                        log.info(tag, "userInfoRedis: ", userInfoRedis);
                        log.info("checkpoint 4 final ");
                        output.success = true;
                        output.userInfo = userInfoRedis;
                        return [2 /*return*/, output];
                    case 10:
                        e_13 = _b.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_13
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_13.toString());
                    case 11: return [2 /*return*/];
                }
            });
        });
    };
    __decorate([
        tsoa_1.Get('/forget'),
        __param(0, tsoa_1.Header('Authorization'))
    ], pioneerPrivateController.prototype, "forget");
    __decorate([
        tsoa_1.Get('/info/{walletId}'),
        __param(1, tsoa_1.Header('Authorization'))
    ], pioneerPrivateController.prototype, "info");
    __decorate([
        tsoa_1.Get('/user'),
        __param(0, tsoa_1.Header('Authorization'))
    ], pioneerPrivateController.prototype, "user");
    __decorate([
        tsoa_1.Get('/context'),
        __param(0, tsoa_1.Header('Authorization'))
    ], pioneerPrivateController.prototype, "context");
    __decorate([
        tsoa_1.Get('/balance/{coin}'),
        __param(1, tsoa_1.Header('Authorization'))
    ], pioneerPrivateController.prototype, "balance");
    __decorate([
        tsoa_1.Post('/pair'),
        __param(0, tsoa_1.Body()), __param(1, tsoa_1.Header())
    ], pioneerPrivateController.prototype, "pair");
    __decorate([
        tsoa_1.Post('/createPairingCode'),
        __param(0, tsoa_1.Body()), __param(1, tsoa_1.Header())
    ], pioneerPrivateController.prototype, "createPairingCode");
    __decorate([
        tsoa_1.Post('/createApiKey'),
        __param(0, tsoa_1.Body()), __param(1, tsoa_1.Header())
    ], pioneerPrivateController.prototype, "createApiKey");
    __decorate([
        tsoa_1.Post('/utxos'),
        __param(0, tsoa_1.Body()), __param(1, tsoa_1.Header())
    ], pioneerPrivateController.prototype, "getUtxos");
    __decorate([
        tsoa_1.Post('/transactions'),
        __param(0, tsoa_1.Header('Authorization')), __param(1, tsoa_1.Body())
    ], pioneerPrivateController.prototype, "transactions");
    __decorate([
        tsoa_1.Post('/register'),
        __param(0, tsoa_1.Header('Authorization')), __param(1, tsoa_1.Body())
    ], pioneerPrivateController.prototype, "register");
    __decorate([
        tsoa_1.Post('/import'),
        __param(0, tsoa_1.Header('Authorization')), __param(1, tsoa_1.Body())
    ], pioneerPrivateController.prototype, "import");
    pioneerPrivateController = __decorate([
        tsoa_1.Tags('Private Endpoints')
        /**
         *  Test
        
         */
        ,
        tsoa_1.Route('')
    ], pioneerPrivateController);
    return pioneerPrivateController;
}(tsoa_1.Controller));
exports.pioneerPrivateController = pioneerPrivateController;
