"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
exports.pioneerPublicController = exports.ApiError = void 0;
/*

    Pioneer REST endpoints



 */
var TAG = ' | API | ';
var pjson = require('../../package.json');
var log = require('@pioneer-platform/loggerdog')();
var _a = require('@pioneer-platform/default-redis'), subscriber = _a.subscriber, publisher = _a.publisher, redis = _a.redis, redisQueue = _a.redisQueue;
var tokenData = require("@pioneer-platform/pioneer-eth-token-data");
/*
    Feature Flags per blockchain

 */
var blockchains = [];
var networks = {};
if (process.env['FEATURE_BITCOIN_BLOCKCHAIN']) {
    blockchains.push('bitcoin');
    //all utxo's share
    networks['ANY'] = require('@pioneer-platform/utxo-network');
    networks['ANY'].init('full');
}
if (process.env['FEATURE_BITCOINCASH_BLOCKCHAIN']) {
    blockchains.push('bitcoincash');
}
if (process.env['FEATURE_LITECOIN_BLOCKCHAIN']) {
    blockchains.push('litecoin');
}
if (process.env['FEATURE_ETHEREUM_BLOCKCHAIN']) {
    blockchains.push('ethereum');
    networks['ETH'] = require('@pioneer-platform/eth-network');
    networks['ETH'].init();
}
if (process.env['FEATURE_COSMOS_BLOCKCHAIN']) {
    blockchains.push('cosmos');
    networks['ATOM'] = require('@pioneer-platform/cosmos-network');
}
if (process.env['FEATURE_BINANCE_BLOCKCHAIN']) {
    blockchains.push('binance');
    networks['BNB'] = require('@pioneer-platform/binance-network');
}
if (process.env['FEATURE_THORCHAIN_BLOCKCHAIN']) {
    blockchains.push('thorchain');
    networks['RUNE'] = require('@pioneer-platform/thor-network');
}
//Cache time
var CACHE_TIME = 1000 * 60 * 1;
var CACHE_OVERRIDE = true;
//rest-ts
var tsoa_1 = require("tsoa");
var ApiError = /** @class */ (function (_super) {
    __extends(ApiError, _super);
    function ApiError(name, statusCode, message) {
        var _this = _super.call(this, message) || this;
        _this.name = name;
        _this.statusCode = statusCode;
        return _this;
    }
    return ApiError;
}(Error));
exports.ApiError = ApiError;
//TODO move this to coins module!
var UTXO_COINS = [
    'BTC',
    'BCH',
    'LTC',
    'TEST'
];
//route
var pioneerPublicController = /** @class */ (function (_super) {
    __extends(pioneerPublicController, _super);
    function pioneerPublicController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /*
     * globals
     * */
    pioneerPublicController.prototype.globals = function () {
        return __awaiter(this, void 0, void 0, function () {
            var tag, globals, e_1, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | globals | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, redis.hgetall('globals')];
                    case 2:
                        globals = _a.sent();
                        globals.blockchains = blockchains;
                        return [2 /*return*/, (globals)];
                    case 3:
                        e_1 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_1
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_1.toString());
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    pioneerPublicController.prototype.online = function () {
        return __awaiter(this, void 0, void 0, function () {
            var tag, online, e_2, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | online | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, redis.smembers('online')];
                    case 2:
                        online = _a.sent();
                        return [2 /*return*/, (online)];
                    case 3:
                        e_2 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_2
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_2.toString());
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    pioneerPublicController.prototype.coins = function () {
        return __awaiter(this, void 0, void 0, function () {
            var tag, coins, errorResp;
            return __generator(this, function (_a) {
                tag = TAG + " | coins | ";
                try {
                    coins = blockchains;
                    //TODO assets/including tokens
                    return [2 /*return*/, (coins)];
                }
                catch (e) {
                    errorResp = {
                        success: false,
                        tag: tag,
                        e: e
                    };
                    log.error(tag, "e: ", { errorResp: errorResp });
                    throw new ApiError("error", 503, "error: " + e.toString());
                }
                return [2 /*return*/];
            });
        });
    };
    /*
     *
     * */
    pioneerPublicController.prototype.blockHeights = function () {
        return __awaiter(this, void 0, void 0, function () {
            var tag, output, e_3, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | blockHeights | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, redis.hgetall("blockHeights")];
                    case 2:
                        output = _a.sent();
                        return [2 /*return*/, (output)];
                    case 3:
                        e_3 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_3
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_3.toString());
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /*
     *     Get block count
     * */
    pioneerPublicController.prototype.blockHeight = function (coin) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, output, e_4, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | blockHeights | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        if (!networks[coin])
                            throw Error("102: network not supported! ");
                        if (!networks[coin].getBlockHeight)
                            throw Error("102: getBlockHeight not supported! coin: " + coin);
                        return [4 /*yield*/, networks[coin].getBlockHeight()];
                    case 2:
                        output = _a.sent();
                        return [2 /*return*/, (output)];
                    case 3:
                        e_4 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_4
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_4.toString());
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /*
    *
    * */
    pioneerPublicController.prototype.getBlockHash = function (coin, height) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, output, e_5, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | blockHeights | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        if (!networks[coin])
                            throw Error("102: network not supported! ");
                        return [4 /*yield*/, networks[coin].getBlockHash(height)];
                    case 2:
                        output = _a.sent();
                        return [2 /*return*/, (output)];
                    case 3:
                        e_5 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_5
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_5.toString());
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     *  get public user info
     * @param account
     */
    pioneerPublicController.prototype.user = function (username) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, output, accountInfo, domain, isAvailable, e_6, e_7, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | getAccount | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 9, , 10]);
                        output = {};
                        if (!username)
                            throw Error("102: address required! ");
                        return [4 /*yield*/, redis.hgetall(username)];
                    case 2:
                        accountInfo = _a.sent();
                        log.info(tag, "cache info:", accountInfo);
                        if (!(Object.keys(accountInfo).length === 0)) return [3 /*break*/, 7];
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        domain = "@scatter";
                        return [4 /*yield*/, networks['FIO'].isAvailable(username + domain)
                            //TODO opt out fio
                        ];
                    case 4:
                        isAvailable = _a.sent();
                        //TODO opt out fio
                        output.available = isAvailable;
                        output.username = username;
                        return [3 /*break*/, 6];
                    case 5:
                        e_6 = _a.sent();
                        output.isValid = false;
                        output.username = username;
                        return [3 /*break*/, 6];
                    case 6: return [3 /*break*/, 8];
                    case 7:
                        if (accountInfo.isPublic) {
                            output.accountInfo = accountInfo;
                        }
                        else {
                            output.isTaken = true;
                            output.created = accountInfo.created;
                            output.isPrivate = true;
                        }
                        _a.label = 8;
                    case 8: return [2 /*return*/, (output)];
                    case 9:
                        e_7 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_7
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_7.toString());
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
    /**
     *  get balance of an address
     */
    pioneerPublicController.prototype.getPubkeyBalance = function (coin, pubkey) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, output, e_8, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | getPubkeyBalance | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 12, , 13]);
                        log.info(tag, { coin: coin, pubkey: pubkey });
                        return [4 /*yield*/, redis.get("cache:balance:" + pubkey + ":" + coin)];
                    case 2:
                        output = _a.sent();
                        networks.ETH.init({ testnet: true });
                        if (!(!output || CACHE_OVERRIDE)) return [3 /*break*/, 11];
                        if (!(tokenData.tokens.indexOf(coin) >= 0 && coin !== 'EOS')) return [3 /*break*/, 4];
                        return [4 /*yield*/, networks['ETH'].getBalanceToken(pubkey, coin)];
                    case 3:
                        output = _a.sent();
                        return [3 /*break*/, 11];
                    case 4:
                        if (!(coin === 'ETH')) return [3 /*break*/, 6];
                        return [4 /*yield*/, networks['ETH'].getBalanceAddress(pubkey)];
                    case 5:
                        output = _a.sent();
                        return [3 /*break*/, 11];
                    case 6:
                        if (!(UTXO_COINS.indexOf(coin) >= 0)) return [3 /*break*/, 8];
                        return [4 /*yield*/, networks['ANY'].getBalanceByXpub(coin, pubkey)];
                    case 7:
                        //get xpub/zpub
                        output = _a.sent();
                        return [3 /*break*/, 11];
                    case 8:
                        if (!!networks[coin]) return [3 /*break*/, 9];
                        throw Error("109: coin not supported! coin: " + coin);
                    case 9: return [4 /*yield*/, networks[coin].getBalance(pubkey)];
                    case 10:
                        output = _a.sent();
                        _a.label = 11;
                    case 11: return [2 /*return*/, (output)];
                    case 12:
                        e_8 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_8
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_8.toString());
                    case 13: return [2 /*return*/];
                }
            });
        });
    };
    /**
     *  getTransaction
     */
    pioneerPublicController.prototype.getTransaction = function (coin, txid) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, output, e_9, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | getTransaction | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 6, , 7]);
                        if (!txid)
                            throw Error("102: txid required! ");
                        log.info(tag, "coin: ", coin);
                        log.info(tag, "txid: ", txid);
                        output = void 0;
                        if (!(UTXO_COINS.indexOf(coin) >= 0)) return [3 /*break*/, 3];
                        return [4 /*yield*/, networks['ANY'].getTransaction(coin, txid)];
                    case 2:
                        output = _a.sent();
                        return [3 /*break*/, 5];
                    case 3:
                        if (!networks[coin])
                            throw Error("102: coin not supported! coin: " + coin);
                        return [4 /*yield*/, networks[coin].getTransaction(txid)];
                    case 4:
                        output = _a.sent();
                        _a.label = 5;
                    case 5: return [2 /*return*/, (output)];
                    case 6:
                        e_9 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_9
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_9.toString());
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    pioneerPublicController.prototype.getFeeInfo = function (coin) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, output, e_10, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | getFee | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 6, , 7]);
                        output = void 0;
                        if (!(UTXO_COINS.indexOf(coin) >= 0)) return [3 /*break*/, 3];
                        return [4 /*yield*/, networks['ANY'].getFee(coin)];
                    case 2:
                        //TODO supported assets
                        output = _a.sent();
                        log.debug("output:", output);
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, networks[coin].getFee(coin)];
                    case 4:
                        output = _a.sent();
                        _a.label = 5;
                    case 5: return [2 /*return*/, (output)];
                    case 6:
                        e_10 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_10
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_10.toString());
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     *  Cosmos getValidators
     */
    pioneerPublicController.prototype.getValidators = function () {
        return __awaiter(this, void 0, void 0, function () {
            var tag, output, e_11, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | getValidators | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, networks['ATOM'].getValidators()];
                    case 2:
                        output = _a.sent();
                        log.debug("getValidators: output:", output);
                        //else error
                        return [2 /*return*/, (output)];
                    case 3:
                        e_11 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_11
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_11.toString());
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     *  Retrieve account info
     */
    pioneerPublicController.prototype.listUnspent = function (coin, xpub) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, output, inputs, i, input, rawInfo, normalized_inputs, i_1, vin, rawInfoInput, input_1, normalized_outputs, i_2, vout, output_1, e_12, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | listUnspent | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 12, , 13]);
                        output = [];
                        //TODO if UTXO coin else error
                        //TODO does this scale on large xpubs?
                        log.info(tag, "coin: ", coin);
                        log.info(tag, "xpub: ", xpub);
                        return [4 /*yield*/, networks.ANY.init()
                            //log.info("networks: ",networks)
                            //log.info("networks: ",networks.ANY)
                        ];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, networks.ANY.utxosByXpub(coin, xpub)
                            //for each get hex
                        ];
                    case 3:
                        inputs = _a.sent();
                        i = 0;
                        _a.label = 4;
                    case 4:
                        if (!(i < inputs.length)) return [3 /*break*/, 11];
                        input = inputs[i];
                        log.info(tag, "input: ", input);
                        return [4 /*yield*/, networks.ANY.getTransaction(coin, input.txid)];
                    case 5:
                        rawInfo = _a.sent();
                        log.info(tag, "rawInfo: ", rawInfo);
                        log.info(tag, "rawInfo: ", rawInfo.vin[0].addresses);
                        normalized_inputs = [];
                        i_1 = 0;
                        _a.label = 6;
                    case 6:
                        if (!(i_1 < rawInfo.vin.length)) return [3 /*break*/, 9];
                        vin = rawInfo.vin[i_1];
                        return [4 /*yield*/, networks.ANY.getTransaction(coin, vin.txid)];
                    case 7:
                        rawInfoInput = _a.sent();
                        log.info(tag, "rawInfoInput: ", JSON.stringify(rawInfoInput));
                        input_1 = {
                            txid: vin.txid,
                            vout: vin.vout,
                            addr: vin.addresses[0],
                            scriptSig: {
                                hex: "0014459a4d8600bfdaa52708eaae5be1dcf959069efc" //from input?
                            },
                            valueSat: parseInt(vin.value),
                            value: parseInt(vin.value) / 100000000
                        };
                        normalized_inputs.push(input_1);
                        _a.label = 8;
                    case 8:
                        i_1++;
                        return [3 /*break*/, 6];
                    case 9:
                        normalized_outputs = [];
                        for (i_2 = 0; i_2 < rawInfo.vout.length; i_2++) {
                            vout = rawInfo.vout[i_2];
                            output_1 = {
                                value: vout.value,
                                scriptPubKey: {
                                    hex: vout.hex
                                }
                            };
                            normalized_outputs.push(output_1);
                        }
                        input.tx = {
                            txid: rawInfo.txid,
                            hash: rawInfo.txid,
                            version: rawInfo.version,
                            locktime: rawInfo.lockTime,
                            vin: normalized_inputs,
                            vout: normalized_outputs,
                            hex: rawInfo.hex
                        };
                        input.hex = rawInfo.hex;
                        input.coin = coin;
                        output.push(input);
                        _a.label = 10;
                    case 10:
                        i++;
                        return [3 /*break*/, 4];
                    case 11: return [2 /*return*/, inputs];
                    case 12:
                        e_12 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_12
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_12.toString());
                    case 13: return [2 /*return*/];
                }
            });
        });
    };
    /**
     *  Retrieve account info
     */
    pioneerPublicController.prototype.getAccountInfo = function (coin, address) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, accounts, e_13, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | accountsFromPubkey | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        log.info(tag, "coin: ", coin);
                        log.info(tag, "address: ", address);
                        log.info(tag, "networks: ", networks);
                        return [4 /*yield*/, networks[coin].getAccount(address)];
                    case 2:
                        accounts = _a.sent();
                        return [2 /*return*/, accounts];
                    case 3:
                        e_13 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_13
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_13.toString());
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     *  Retrieve accounts for EOS pubkey
     */
    pioneerPublicController.prototype.accountsFromEosPubkey = function (pubkey) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, accounts, e_14, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | accountsFromEosPubkey | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, networks['FIO'].getAccountsFromPubkey(pubkey)];
                    case 2:
                        accounts = _a.sent();
                        return [2 /*return*/, accounts];
                    case 3:
                        e_14 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_14
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_14.toString());
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     *  Retrieve public user info
     */
    pioneerPublicController.prototype.eosAccountInfo = function (username) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, accounts, e_15, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | eosAccountInfo* | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, networks['EOS'].getAccount(username)];
                    case 2:
                        accounts = _a.sent();
                        return [2 /*return*/, accounts];
                    case 3:
                        e_15 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_15
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_15.toString());
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     *  Tokens balance check
     */
    pioneerPublicController.prototype.getBalanceToken = function (address, token) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, accounts, e_16, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | getBalanceToken | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, networks['ETH'].getBalanceToken(token, address)];
                    case 2:
                        accounts = _a.sent();
                        return [2 /*return*/, accounts];
                    case 3:
                        e_16 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_16
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_16.toString());
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     *  ETH nonce check
     */
    pioneerPublicController.prototype.getNonce = function (address) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, accounts, e_17, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | getNonce | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        //if cached
                        //get last tx index
                        console.log("networks['ETH']: ", networks['ETH']);
                        console.log("address: ", address);
                        return [4 /*yield*/, networks['ETH'].getNonce(address)];
                    case 2:
                        accounts = _a.sent();
                        return [2 /*return*/, accounts];
                    case 3:
                        e_17 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_17
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_17.toString());
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     *  ETH getGasPrice
     */
    pioneerPublicController.prototype.getGasPrice = function () {
        return __awaiter(this, void 0, void 0, function () {
            var tag, accounts, e_18, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | getGasPrice | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, networks['ETH'].getGasPrice()];
                    case 2:
                        accounts = _a.sent();
                        return [2 /*return*/, accounts];
                    case 3:
                        e_18 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_18
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_18.toString());
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     *  ETH getTransferData
     */
    pioneerPublicController.prototype.getTransferData = function (coin, address, amount) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, accounts, e_19, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | getGasPrice | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, networks['ETH'].getTransferData(coin, address, amount)];
                    case 2:
                        accounts = _a.sent();
                        return [2 /*return*/, accounts];
                    case 3:
                        e_19 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_19
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_19.toString());
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     *  ETH get token balance and info
     */
    pioneerPublicController.prototype.getTokenInfo = function (address) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, accounts, e_20, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | getGasPrice | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, networks['ETH'].getTokenInfo(address)];
                    case 2:
                        accounts = _a.sent();
                        return [2 /*return*/, accounts];
                    case 3:
                        e_20 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_20
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_20.toString());
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     *  EOS get token balance and info
     */
    pioneerPublicController.prototype.validateEosUsername = function (username) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, accounts, e_21, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | validateEosUsername | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, networks['EOS'].getAccount(username)];
                    case 2:
                        accounts = _a.sent();
                        return [2 /*return*/, accounts];
                    case 3:
                        e_21 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_21
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_21.toString());
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     *  EOS get token balance and info
     */
    pioneerPublicController.prototype.getEosAccountsByPubkey = function (pubkey) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, accounts, e_22, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | getEosAccountsByPubkey | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, networks['EOS'].getAccountsFromPubkey(pubkey)];
                    case 2:
                        accounts = _a.sent();
                        return [2 /*return*/, accounts];
                    case 3:
                        e_22 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_22
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_22.toString());
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    //TODO
    /**
     * Mempool intake (blocknative)
     *
     */
    pioneerPublicController.prototype.getAllowance = function (body) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, result, e_23, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | getAllowance | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        log.info(tag, "body: ", body);
                        return [4 /*yield*/, networks['ETH'].getAllowance(body.token, body.spender, body.sender)];
                    case 2:
                        result = _a.sent();
                        return [2 /*return*/, (result)];
                    case 3:
                        e_23 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_23
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_23.toString());
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    //multi chain
    pioneerPublicController.prototype.getFee = function (body) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, feeResult, errorResp;
            return __generator(this, function (_a) {
                tag = TAG + " | getFee | ";
                try {
                    log.info(tag, "mempool tx: ", body);
                    feeResult = networks['ETH'].getFees(body);
                    //save to mongo
                    return [2 /*return*/, (feeResult)];
                }
                catch (e) {
                    errorResp = {
                        success: false,
                        tag: tag,
                        e: e
                    };
                    log.error(tag, "e: ", { errorResp: errorResp });
                    throw new ApiError("error", 503, "error: " + e.toString());
                }
                return [2 /*return*/];
            });
        });
    };
    //ETH only
    pioneerPublicController.prototype.estimateFeesWithGasPricesAndLimits = function (body) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, feeResult, errorResp;
            return __generator(this, function (_a) {
                tag = TAG + " | getFee | ";
                try {
                    log.info(tag, "mempool tx: ", body);
                    //TODO filter by body.asset.chain
                    //if()
                    //TODO handle mainnet/testnet switch
                    networks.ETH.init({ testnet: true });
                    console.log("networks['ETH']: ", networks['ETH']);
                    feeResult = networks['ETH'].getFees(body);
                    //save to mongo
                    return [2 /*return*/, (feeResult)];
                }
                catch (e) {
                    errorResp = {
                        success: false,
                        tag: tag,
                        e: e
                    };
                    log.error(tag, "e: ", { errorResp: errorResp });
                    throw new ApiError("error", 503, "error: " + e.toString());
                }
                return [2 /*return*/];
            });
        });
    };
    pioneerPublicController.prototype.estimateFee = function (body) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, output, asset, params, response, e_24, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | estimateFee | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        output = {};
                        log.info(tag, "body: ", body);
                        asset = {
                            chain: "ETH",
                            symbol: "ETH",
                            ticker: "ETH"
                        };
                        params = [
                            body.contract,
                            "0x0000000000000000000000000000000000000000",
                            body.amount,
                            body.memo
                        ];
                        //TODO if not eth
                        networks.ETH.init({ testnet: true });
                        return [4 /*yield*/, networks['ETH'].estimateFee(asset, params)];
                    case 2:
                        response = _a.sent();
                        return [2 /*return*/, (response.data)];
                    case 3:
                        e_24 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_24
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_24.toString());
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /*
            let swap = {
                inboundAddress: {
                    chain: 'ETH',
                    pub_key: 'tthorpub1addwnpepqvuy8vh6yj4h28xp6gfpjsztpj6p46y2rs0763t6uw9f6lkky0ly5uvwla6',
                    address: '0x36286e570c412531aad366154eea9867b0e71755',
                    router: '0x9d496De78837f5a2bA64Cb40E62c19FBcB67f55a',
                    halted: false
                },
                asset: {
                    chain: 'ETH',
                    symbol: 'ETH',
                    ticker: 'ETH',
                    iconPath: 'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/binance/assets/ETH-1C9/logo.png'
                },
                memo: '=:THOR.RUNE:tthor1veu9u5h4mtdq34fjgu982s8pympp6w87ag58nh',
                amount: "0.01"
            }

     */
    pioneerPublicController.prototype.getThorchainMemoEncoded = function (body) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, resp, e_25, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | getFee | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        //TODO handle mainnet
                        networks.ETH.init({ testnet: true });
                        log.info(tag, "body: ", body);
                        return [4 /*yield*/, networks['ETH'].getMemoEncoded(body)];
                    case 2:
                        resp = _a.sent();
                        return [2 /*return*/, (resp)];
                    case 3:
                        e_25 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_25
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_25.toString());
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    pioneerPublicController.prototype.getFeesWithMemo = function (body) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, output, resp, e_26, errorResp;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tag = TAG + " | getFee | ";
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 5, , 6]);
                        output = {};
                        log.info(tag, "body: ", body);
                        if (!(UTXO_COINS.indexOf(body.coin) >= 0)) return [3 /*break*/, 3];
                        return [4 /*yield*/, networks['ANY'].getFeesWithRates(body.coin, body.memo)];
                    case 2:
                        resp = _a.sent();
                        log.info("resp:", resp);
                        //else error
                        output = resp;
                        return [3 /*break*/, 4];
                    case 3: 
                    //not supported
                    throw Error("coin not supported! coin: " + body.coin);
                    case 4: return [2 /*return*/, (output)];
                    case 5:
                        e_26 = _a.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_26
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_26.toString());
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    pioneerPublicController.prototype.pushTx = function (body) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, errorResp;
            return __generator(this, function (_a) {
                tag = TAG + " | pushTx | ";
                try {
                    log.info(tag, "mempool tx: ", body);
                    //push to redis
                    publisher.publish("mempool", JSON.stringify(body));
                    //save to mongo
                    return [2 /*return*/, (true)];
                }
                catch (e) {
                    errorResp = {
                        success: false,
                        tag: tag,
                        e: e
                    };
                    log.error(tag, "e: ", { errorResp: errorResp });
                    throw new ApiError("error", 503, "error: " + e.toString());
                }
                return [2 /*return*/];
            });
        });
    };
    //TODO
    // /**
    //  * UTXO Tooles
    //  *
    //  *
    //  *
    //  * Create Unsigned Transaction
    //  *
    //  */
    //
    // @Post('/createUnsignedTransaction')
    // public async createUnsignedTransaction(@Body() body: UnsignedUtxoRequest): Promise<any> {
    //     let tag = TAG + " | createUnsignedTransaction | "
    //     try{
    //         log.info(tag,"")
    //
    //         let result = await network.createUnsignedTransaction(body)
    //
    //         return(result);
    //     }catch(e){
    //         let errorResp:Error = {
    //             success:false,
    //             tag,
    //             e
    //         }
    //         log.error(tag,"e: ",{errorResp})
    //         throw new ApiError("error",503,"error: "+e.toString());
    //     }
    // }
    /**
     * BroadCast a signed transaction
     */
    pioneerPublicController.prototype.broadcast = function (body) {
        return __awaiter(this, void 0, void 0, function () {
            var tag, result, coin, isTestnet, result_1, broadcast, _a, e_27, errorResp;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        tag = TAG + " | transactions | ";
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 21, , 22]);
                        log.info("************************** CHECKPOINT *******************88 ");
                        log.info(tag, "body: ", body);
                        result = {
                            success: false
                        };
                        coin = body.coin;
                        isTestnet = false;
                        if (body.isTestnet) {
                            isTestnet = true;
                        }
                        //if(!networks[coin]) throw Error("102: unknown network coin:"+coin)
                        //if
                        if (body.invocationId) {
                            if (!body.txid)
                                throw Error("102 txid required for interactive hook!");
                            log.info(tag, "Release InvocationId: ", body.invocationId);
                            log.info(tag, "Release body.txid: ", body.txid);
                            redis.lpush(body.invocationId, body.txid);
                        }
                        if (!!body.noBroadcast) return [3 /*break*/, 19];
                        if (!(coin === 'EOS')) return [3 /*break*/, 3];
                        return [4 /*yield*/, networks[coin].broadcast(body.broadcastBody)];
                    case 2:
                        result_1 = _b.sent();
                        return [3 /*break*/, 18];
                    case 3:
                        if (!(coin === 'FIO')) return [3 /*break*/, 12];
                        broadcast = {
                            signatures: [body.signature],
                            compression: "none",
                            packed_context_free_data: '',
                            packed_trx: body.serialized
                        };
                        if (!body.type) {
                            log.error(tag, "invalid payload!: ", broadcast);
                            throw Error("Fio txs require type!");
                        }
                        _a = body.type;
                        switch (_a) {
                            case "fioSignAddPubAddressTx": return [3 /*break*/, 4];
                            case "fioSignRegisterDomainTx": return [3 /*break*/, 6];
                            case "fioSignRegisterFioAddressTx": return [3 /*break*/, 7];
                            case "fioSignNewFundsRequestTx": return [3 /*break*/, 8];
                        }
                        return [3 /*break*/, 10];
                    case 4:
                        log.info(tag, "checkpoint: fioSignAddPubAddressTx ");
                        log.info(tag, "broadcast: ", broadcast);
                        return [4 /*yield*/, networks[coin].broadcastAddPubAddressTx(broadcast)];
                    case 5:
                        result_1 = _b.sent();
                        return [3 /*break*/, 11];
                    case 6: 
                    //TODO
                    return [3 /*break*/, 11];
                    case 7: 
                    //TODO
                    return [3 /*break*/, 11];
                    case 8:
                        log.info(tag, "checkpoint: broadcastNewFundsRequestTx ");
                        log.info(tag, "broadcast: ", broadcast);
                        return [4 /*yield*/, networks[coin].broadcastNewFundsRequestTx(broadcast)];
                    case 9:
                        result_1 = _b.sent();
                        return [3 /*break*/, 11];
                    case 10: throw Error("Type not supported! " + body.type);
                    case 11: return [3 /*break*/, 18];
                    case 12:
                        if (!(UTXO_COINS.indexOf(coin) >= 0)) return [3 /*break*/, 15];
                        //normal broadcast
                        return [4 /*yield*/, networks.ANY.init('full')];
                    case 13:
                        //normal broadcast
                        _b.sent();
                        return [4 /*yield*/, networks['ANY'].broadcast(coin, body.serialized)];
                    case 14:
                        result_1 = _b.sent();
                        return [3 /*break*/, 18];
                    case 15: 
                    //normal broadcast
                    return [4 /*yield*/, networks[coin].init()];
                    case 16:
                        //normal broadcast
                        _b.sent();
                        return [4 /*yield*/, networks[coin].broadcast(body.serialized)];
                    case 17:
                        result_1 = _b.sent();
                        _b.label = 18;
                    case 18: return [3 /*break*/, 20];
                    case 19:
                        result.success = true;
                        result.broadcast = false;
                        result = body.invocationId;
                        _b.label = 20;
                    case 20: return [2 /*return*/, (result)];
                    case 21:
                        e_27 = _b.sent();
                        errorResp = {
                            success: false,
                            tag: tag,
                            e: e_27
                        };
                        log.error(tag, "e: ", { errorResp: errorResp });
                        throw new ApiError("error", 503, "error: " + e_27.toString());
                    case 22: return [2 /*return*/];
                }
            });
        });
    };
    __decorate([
        tsoa_1.Get('/globals')
    ], pioneerPublicController.prototype, "globals");
    __decorate([
        tsoa_1.Get('/online')
    ], pioneerPublicController.prototype, "online");
    __decorate([
        tsoa_1.Get('/coins')
    ], pioneerPublicController.prototype, "coins");
    __decorate([
        tsoa_1.Get('/blockHeights')
    ], pioneerPublicController.prototype, "blockHeights");
    __decorate([
        tsoa_1.Get('/blockHeight/{coin}')
    ], pioneerPublicController.prototype, "blockHeight");
    __decorate([
        tsoa_1.Get('/blocks/{coin}/{height}')
    ], pioneerPublicController.prototype, "getBlockHash");
    __decorate([
        tsoa_1.Get('/user/{username}')
    ], pioneerPublicController.prototype, "user");
    __decorate([
        tsoa_1.Get('/getPubkeyBalance/{coin}/{pubkey}')
    ], pioneerPublicController.prototype, "getPubkeyBalance");
    __decorate([
        tsoa_1.Get('{coin}/getTransaction/{txid}')
    ], pioneerPublicController.prototype, "getTransaction");
    __decorate([
        tsoa_1.Get('/getFeeInfo/{coin}')
    ], pioneerPublicController.prototype, "getFeeInfo");
    __decorate([
        tsoa_1.Get('/getValidators/')
    ], pioneerPublicController.prototype, "getValidators");
    __decorate([
        tsoa_1.Get('/listUnspent/{coin}/{xpub}')
    ], pioneerPublicController.prototype, "listUnspent");
    __decorate([
        tsoa_1.Get('/getAccountInfo/{coin}/{address}')
    ], pioneerPublicController.prototype, "getAccountInfo");
    __decorate([
        tsoa_1.Get('/eos/accountsFromPubkey/{pubkey}')
    ], pioneerPublicController.prototype, "accountsFromEosPubkey");
    __decorate([
        tsoa_1.Get('/eos/accountInfo/{username}')
    ], pioneerPublicController.prototype, "eosAccountInfo");
    __decorate([
        tsoa_1.Get('/eth/getBalanceToken/{address}/{token}')
    ], pioneerPublicController.prototype, "getBalanceToken");
    __decorate([
        tsoa_1.Get('/eth/getNonce/{address}')
    ], pioneerPublicController.prototype, "getNonce");
    __decorate([
        tsoa_1.Get('/eth/getGasPrice')
    ], pioneerPublicController.prototype, "getGasPrice");
    __decorate([
        tsoa_1.Get('/eth/getTransferData/{coin}/{address}/{amount}')
    ], pioneerPublicController.prototype, "getTransferData");
    __decorate([
        tsoa_1.Get('/eth/getTokens/{address}')
    ], pioneerPublicController.prototype, "getTokenInfo");
    __decorate([
        tsoa_1.Get('/eos/validateEosUsername/{username}')
    ], pioneerPublicController.prototype, "validateEosUsername");
    __decorate([
        tsoa_1.Get('/eos/getEosAccountsByPubkey/{pubkey}')
    ], pioneerPublicController.prototype, "getEosAccountsByPubkey");
    __decorate([
        tsoa_1.Post('/eth/getAllowance'),
        __param(0, tsoa_1.Body())
    ], pioneerPublicController.prototype, "getAllowance");
    __decorate([
        tsoa_1.Post('/getFee'),
        __param(0, tsoa_1.Body())
    ], pioneerPublicController.prototype, "getFee");
    __decorate([
        tsoa_1.Post('/estimateFeesWithGasPricesAndLimits'),
        __param(0, tsoa_1.Body())
    ], pioneerPublicController.prototype, "estimateFeesWithGasPricesAndLimits");
    __decorate([
        tsoa_1.Post('/estimateFee'),
        __param(0, tsoa_1.Body())
    ], pioneerPublicController.prototype, "estimateFee");
    __decorate([
        tsoa_1.Post('/getThorchainMemoEncoded'),
        __param(0, tsoa_1.Body())
    ], pioneerPublicController.prototype, "getThorchainMemoEncoded");
    __decorate([
        tsoa_1.Post('/getFeesWithMemo'),
        __param(0, tsoa_1.Body())
    ], pioneerPublicController.prototype, "getFeesWithMemo");
    __decorate([
        tsoa_1.Post('/pushTx'),
        __param(0, tsoa_1.Body())
    ], pioneerPublicController.prototype, "pushTx");
    __decorate([
        tsoa_1.Post('/broadcast'),
        __param(0, tsoa_1.Body())
    ], pioneerPublicController.prototype, "broadcast");
    pioneerPublicController = __decorate([
        tsoa_1.Tags('Public Endpoints'),
        tsoa_1.Route('')
    ], pioneerPublicController);
    return pioneerPublicController;
}(tsoa_1.Controller));
exports.pioneerPublicController = pioneerPublicController;
