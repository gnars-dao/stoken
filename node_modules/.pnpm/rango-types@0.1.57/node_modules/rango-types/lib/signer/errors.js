var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
export var SignerErrorCode;
(function (SignerErrorCode) {
    SignerErrorCode["REJECTED_BY_USER"] = "REJECTED_BY_USER";
    SignerErrorCode["SIGN_TX_ERROR"] = "SIGN_TX_ERROR";
    SignerErrorCode["SEND_TX_ERROR"] = "SEND_TX_ERROR";
    SignerErrorCode["TX_FAILED_IN_BLOCKCHAIN"] = "TX_FAILED_IN_BLOCKCHAIN";
    SignerErrorCode["OPERATION_UNSUPPORTED"] = "OPERATION_UNSUPPORTED";
    SignerErrorCode["UNEXPECTED_BEHAVIOUR"] = "UNEXPECTED_BEHAVIOUR";
    SignerErrorCode["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
})(SignerErrorCode || (SignerErrorCode = {}));
export var RPCErrorCode;
(function (RPCErrorCode) {
    RPCErrorCode["REJECTION"] = "REJECTION";
    RPCErrorCode["UNDER_PRICED"] = "UNDER_PRICED";
    RPCErrorCode["OUT_OF_GAS"] = "OUT_OF_GAS";
    RPCErrorCode["CALL_EXCEPTION"] = "CALL_EXCEPTION";
    RPCErrorCode["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    RPCErrorCode["INTERNAL"] = "INTERNAL";
    RPCErrorCode["SLIPPAGE"] = "SLIPPAGE";
    RPCErrorCode["UNKNOWN_ERROR"] = "UNKNOWN";
})(RPCErrorCode || (RPCErrorCode = {}));
export function isSignerErrorCode(value) {
    return Object.keys(SignerErrorCode).includes(value);
}
export function getDefaultErrorMessage(code) {
    var _a;
    var errorMap = (_a = {},
        _a[SignerErrorCode.REJECTED_BY_USER] = 'User rejected the transaction',
        _a[SignerErrorCode.SIGN_TX_ERROR] = 'Error signing the transaction',
        _a[SignerErrorCode.SEND_TX_ERROR] = 'Error sending the transaction',
        _a[SignerErrorCode.NOT_IMPLEMENTED] = 'Operation not implemented',
        _a[SignerErrorCode.OPERATION_UNSUPPORTED] = 'Unsupported operation',
        _a[SignerErrorCode.TX_FAILED_IN_BLOCKCHAIN] = 'Transaction failed in blockchain',
        _a[SignerErrorCode.UNEXPECTED_BEHAVIOUR] = 'Unexpected error',
        _a);
    return errorMap[code];
}
var SignerError = /** @class */ (function (_super) {
    __extends(SignerError, _super);
    function SignerError(code, m, root, rpcCode, trace) {
        var _this = _super.call(this, m || getDefaultErrorMessage(code)) || this;
        _this._isSignerError = true;
        Object.setPrototypeOf(_this, SignerError.prototype);
        SignerError.prototype._isSignerError = true;
        _this.code = code;
        _this.root = root;
        _this.rpcCode = rpcCode;
        _this.trace = trace;
        if (_this.code === SignerErrorCode.REJECTED_BY_USER ||
            SignerError.isRejectedError(root)) {
            _this.code = SignerErrorCode.REJECTED_BY_USER;
            _this.message = 'User rejected the transaction';
            _this.root = undefined;
        }
        return _this;
    }
    SignerError.isSignerError = function (obj) {
        return (obj instanceof SignerError ||
            Object.prototype.hasOwnProperty.call(obj, '_isSignerError'));
    };
    SignerError.isRejectedError = function (error) {
        var POSSIBLE_REJECTION_ERRORS = [
            'rejected by user',
            'rejected by the user',
            'user canceled',
            'user rejected',
            'user denied',
            'request rejected',
            'user abort',
            'declined by user',
        ];
        if (!!error && typeof error === 'string') {
            for (var _i = 0, POSSIBLE_REJECTION_ERRORS_1 = POSSIBLE_REJECTION_ERRORS; _i < POSSIBLE_REJECTION_ERRORS_1.length; _i++) {
                var msg = POSSIBLE_REJECTION_ERRORS_1[_i];
                if (error.toLowerCase().includes(msg.toLowerCase()))
                    return true;
            }
        }
        else if (!!error && typeof error === 'object') {
            if ((error === null || error === void 0 ? void 0 : error.code) === 4001)
                return true;
            for (var _a = 0, POSSIBLE_REJECTION_ERRORS_2 = POSSIBLE_REJECTION_ERRORS; _a < POSSIBLE_REJECTION_ERRORS_2.length; _a++) {
                var msg = POSSIBLE_REJECTION_ERRORS_2[_a];
                if (JSON.stringify(error).toLowerCase().includes(msg.toLowerCase()) ||
                    ((error === null || error === void 0 ? void 0 : error.message) || '').toLowerCase().includes(msg.toLowerCase()))
                    return true;
            }
        }
        return false;
    };
    SignerError.UnsupportedError = function (operation) {
        return new SignerError(SignerErrorCode.OPERATION_UNSUPPORTED, "'".concat(operation, "' is not supported by the signer"));
    };
    SignerError.UnimplementedError = function (operation) {
        return new SignerError(SignerErrorCode.NOT_IMPLEMENTED, "'".concat(operation, "' is not implemented by the signer"));
    };
    SignerError.AssertionFailed = function (m) {
        return new SignerError(SignerErrorCode.UNEXPECTED_BEHAVIOUR, 'Assertion failed: ' + m);
    };
    SignerError.prototype.getErrorDetail = function () {
        var _a;
        if (this.code === SignerErrorCode.REJECTED_BY_USER) {
            return {
                code: this.code,
                message: this.message,
                detail: ((_a = this.root) === null || _a === void 0 ? void 0 : _a.message) || 'User rejected the transaction'
            };
        }
        var rawMessage = typeof this.root === 'object' && this.root && this.root.error
            ? this.root.error
            : JSON.stringify(this.root);
        var rootStr = typeof this.root === 'string'
            ? this.root
            : this.root instanceof Error
                ? this.root.message
                : rawMessage;
        return {
            code: this.code,
            message: this.message,
            detail: rootStr
        };
    };
    return SignerError;
}(Error));
export { SignerError };
//# sourceMappingURL=errors.js.map