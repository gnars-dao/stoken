"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebsocketClient = void 0;
const ws_1 = __importDefault(require("ws"));
const logger_1 = require("@shapeshiftoss/logger");
class WebsocketClient {
    constructor(url, args, opts) {
        this.retries = 0;
        this.retryAttempts = 5;
        this.logger = new logger_1.Logger({ namespace: ['unchained', 'blockbook'], level: process.env.LOG_LEVEL });
        this.handleTransaction = args.transactionHandler;
        this.handleBlock = args.blockHandler;
        this.pingInterval = opts?.pingInterval ?? 10000;
        this.url = url;
        this.socket = new ws_1.default(this.url, { handshakeTimeout: 5000 });
        this.initialize(false);
    }
    initialize(retry) {
        if (retry) {
            if (++this.retries >= this.retryAttempts) {
                throw new Error('failed to reconnect');
            }
            this.socket = new ws_1.default(this.url, { handshakeTimeout: 5000 });
        }
        this.socket.on('ping', () => this.socket.pong());
        this.socket.on('pong', () => this.heartbeat());
        this.socket.onerror = (error) => {
            this.logger.error({ error, fn: 'ws.onerror' }, 'websocket error');
        };
        this.socket.onclose = ({ code, reason }) => {
            this.logger.error({ code, reason, fn: 'ws.close' }, 'websocket closed');
            this.close();
        };
        this.socket.onopen = () => this.onOpen();
        this.socket.onmessage = (msg) => this.onMessage(msg);
    }
    close() {
        this.interval && clearInterval(this.interval);
        // TODO: retry with backoff
        this.initialize(true);
    }
    heartbeat() {
        this.pingTimeout && clearTimeout(this.pingTimeout);
        this.pingTimeout = setTimeout(() => {
            this.logger.debug({ fn: 'pingTimeout' }, 'heartbeat failed');
            this.socket.terminate();
        }, this.pingInterval + 1000);
    }
    onOpen() {
        this.logger.debug({ fn: 'ws.onopen' }, 'websocket opened');
        this.retries = 0;
        this.interval = setInterval(() => {
            this.socket.ping();
        }, this.pingInterval);
        this.heartbeat();
        const newBlock = {
            id: 'newBlock',
            jsonrpc: '2.0',
            method: 'subscribeNewBlock',
        };
        const newTx = {
            id: 'newTx',
            jsonrpc: '2.0',
            method: 'subscribeNewTransaction',
        };
        this.socket.send(JSON.stringify(newBlock));
        this.socket.send(JSON.stringify(newTx));
    }
    async onMessage(message) {
        try {
            const res = JSON.parse(message.data.toString());
            if (!res.data)
                return;
            if (res.id === 'newBlock' && 'hash' in res.data) {
                await this.handleBlock(res.data);
            }
            if (res.id === 'newTx' && 'txid' in res.data) {
                await this.handleTransaction(res.data);
            }
        }
        catch (err) {
            this.logger.error(err, `failed to handle message: ${JSON.stringify(message)}`);
        }
    }
}
exports.WebsocketClient = WebsocketClient;
//# sourceMappingURL=websocket.js.map