"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransportReplayer = void 0;
const rxjs_1 = require("rxjs");
const hw_transport_1 = __importDefault(require("@ledgerhq/hw-transport"));
const logs_1 = require("@ledgerhq/logs");
class TransportReplayer extends hw_transport_1.default {
    constructor(recordStore) {
        super();
        this.artificialExchangeDelay = 0;
        this.recordStore = recordStore;
        this.exchangeBlocker = null;
    }
    setArtificialExchangeDelay(delay) {
        this.artificialExchangeDelay = delay;
    }
    setScrambleKey() { }
    close() {
        return Promise.resolve();
    }
    /**
     * Sets an observable blocking an exchange until `unblockExchange` is called
     */
    enableExchangeBlocker() {
        this.exchangeBlocker = new rxjs_1.Subject();
    }
    /**
     * Unblock exchange by emitting an event (if enabled), and remove the exchange blocker
     */
    unblockExchange() {
        if (this.exchangeBlocker) {
            this.exchangeBlocker.next(1);
            this.exchangeBlocker = null;
        }
    }
    exchange(apdu) {
        (0, logs_1.log)("apdu", apdu.toString("hex"));
        try {
            const buffer = this.recordStore.replayExchange(apdu);
            (0, logs_1.log)("apdu", buffer.toString("hex"));
            if (this.artificialExchangeDelay) {
                return new Promise(resolve => {
                    setTimeout(() => {
                        resolve(buffer);
                        this.setArtificialExchangeDelay(0);
                    }, this.artificialExchangeDelay);
                });
            }
            else if (this.exchangeBlocker) {
                return (0, rxjs_1.firstValueFrom)(
                // The exchange is unblocked once `exchangeBlocker` emits a value
                this.exchangeBlocker.pipe((0, rxjs_1.map)(_ => {
                    return buffer;
                })));
            }
            else {
                return Promise.resolve(buffer);
            }
        }
        catch (e) {
            (0, logs_1.log)("apdu-error", String(e));
            return Promise.reject(e);
        }
    }
}
exports.TransportReplayer = TransportReplayer;
TransportReplayer.isSupported = () => Promise.resolve(true);
TransportReplayer.list = () => Promise.resolve([null]);
TransportReplayer.listen = o => {
    let unsubscribed;
    setTimeout(() => {
        if (unsubscribed)
            return;
        o.next({
            type: "add",
            descriptor: null,
        });
        o.complete();
    }, 0);
    return {
        unsubscribe: () => {
            unsubscribed = true;
        },
    };
};
TransportReplayer.open = (recordStore) => Promise.resolve(new TransportReplayer(recordStore));
/**
 * create a transport replayer with a record store.
 * @param recordStore
 */
const openTransportReplayer = (recordStore) => {
    return TransportReplayer.open(recordStore);
};
exports.default = openTransportReplayer;
//# sourceMappingURL=openTransportReplayer.js.map