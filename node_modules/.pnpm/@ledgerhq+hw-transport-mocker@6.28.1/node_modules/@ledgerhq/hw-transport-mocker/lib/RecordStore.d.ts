/// <reference types="node" />
/**
 * thrown by the RecordStore.fromString parser.
 */
export declare function RecordStoreInvalidSynthax(message: string): void;
export declare namespace RecordStoreInvalidSynthax {
    var prototype: Error;
}
/**
 * thrown by the replayer if the queue is empty
 */
export declare function RecordStoreQueueEmpty(): void;
export declare namespace RecordStoreQueueEmpty {
    var prototype: Error;
}
/**
 * thrown by replayer if it meets an unexpected apdu
 */
export declare function RecordStoreWrongAPDU(expected: string, got: string, line: number): void;
export declare namespace RecordStoreWrongAPDU {
    var prototype: Error;
}
/**
 * thrown by ensureQueueEmpty
 */
export declare function RecordStoreRemainingAPDU(expected: string): void;
export declare namespace RecordStoreRemainingAPDU {
    var prototype: Error;
}
export type Queue = [string, string][];
/**
 * - autoSkipUnknownApdu:
 * smart mechanism that would skip an apdu un-recognize to the next one that does
 * this is meant to be used when you have refactored/dropped some APDUs
 * it will produces warnings for you to fix the APDUs queue
 * - warning:
 * allows to override the warning function (defaults to console.warn)
 */
export type RecordStoreOptions = {
    autoSkipUnknownApdu: boolean;
    warning: (arg0: string) => void;
};
/**
 * a RecordStore is a stateful object that represents a queue of APDUs.
 * It is both used by replayer and recorder transports and is the basic for writing Ledger tests with a mock device.
 */
export declare class RecordStore {
    passed: number;
    queue: Queue;
    opts: RecordStoreOptions;
    constructor(queue?: Queue | null | undefined, opts?: Partial<RecordStoreOptions>);
    /**
     * check if there is no more APDUs to replay
     */
    isEmpty: () => boolean;
    /**
     * Record an APDU (used by createTransportRecorder)
     * @param {Buffer} apdu input
     * @param {Buffer} out response
     */
    recordExchange(apdu: Buffer, out: Buffer): void;
    /**
     * Replay an APDU (used by createTransportReplayer)
     * @param apdu
     */
    replayExchange(apdu: Buffer): Buffer;
    /**
     * Check all APDUs was replayed. Throw if it's not the case.
     */
    ensureQueueEmpty(): void;
    /**
     * Print out the series of apdus
     */
    toString(): string;
    /**
     * Create a RecordStore by parsing a string (a series of => HEX\n<= HEX)
     * @param {string} series of APDUs
     * @param {$Shape<RecordStoreOptions>} opts
     */
    static fromString(str: string, opts?: Partial<RecordStoreOptions>): RecordStore;
}
//# sourceMappingURL=RecordStore.d.ts.map