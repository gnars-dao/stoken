"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeepKeyRestHDWallet = exports.isKeepKey = void 0;
const keepkey_sdk_1 = require("@keepkey/keepkey-sdk");
const core = __importStar(require("@shapeshiftoss/hdwallet-core"));
const lodash_1 = __importDefault(require("lodash"));
const semver_1 = __importDefault(require("semver"));
function isKeepKey(wallet) {
    return lodash_1.default.isObject(wallet) && wallet._isKeepKey;
}
exports.isKeepKey = isKeepKey;
class KeepKeyRestHDWallet {
    constructor(sdk) {
        this._supportsETHInfo = true;
        this._supportsBTCInfo = true;
        this._supportsCosmosInfo = true;
        this._supportsOsmosisInfo = true;
        this._supportsRippleInfo = true;
        this._supportsBinanceInfo = true;
        this._supportsEosInfo = true;
        this._supportsFioInfo = false;
        this._supportsPolygon = true;
        this._supportsGnosis = true;
        this._supportsDebugLink = false;
        this._isKeepKey = true;
        this._supportsETH = true;
        this._supportsEthSwitchChain = false;
        this._supportsAvalanche = true;
        this._supportsOptimism = true;
        this._supportsBSC = true;
        this._supportsBTC = true;
        this._supportsCosmos = true;
        this._supportsOsmosis = true;
        this._supportsRipple = true;
        this._supportsBinance = true;
        this._supportsEos = true;
        this._supportsThorchainInfo = true;
        this._supportsThorchain = true;
        this._supportsSecretInfo = false;
        this._supportsSecret = false;
        this._supportsKava = false;
        this._supportsKavaInfo = false;
        this._supportsTerra = false;
        this._supportsTerraInfo = false;
        this.abortControllers = new Map();
        this.ethChainId = '0x1';
        this.getPublicKeys = lodash_1.default.memoize((getPublicKeys) => __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                return yield Promise.all(getPublicKeys.map((x) => __awaiter(this, void 0, void 0, function* () {
                    const scriptType = (() => {
                        switch (x.scriptType) {
                            case undefined:
                                return undefined;
                            case core.BTCInputScriptType.SpendAddress:
                                return 'p2pkh';
                            case core.BTCInputScriptType.SpendWitness:
                                return 'p2wpkh';
                            case core.BTCInputScriptType.SpendP2SHWitness:
                                return 'p2sh-p2wpkh';
                            default:
                                throw new Error('bad scriptType');
                        }
                    })();
                    return yield this.sdk.system.info.getPublicKey({
                        coin_name: x.coin,
                        script_type: scriptType,
                        show_display: x.showDisplay,
                        ecdsa_curve_name: x.curve,
                        address_n: x.addressNList,
                    }, { signal });
                })));
            }));
        }), (msg) => JSON.stringify(msg));
        this.getFeaturesCached = lodash_1.default.memoize(() => __awaiter(this, void 0, void 0, function* () {
            return yield this.getFeaturesUncached();
        }));
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.btcGetAddress = lodash_1.default.memoize((msg) => __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                return (yield this.sdk.address.utxoGetAddress({
                    script_type: msg.scriptType,
                    coin: msg.coin,
                    address_n: msg.addressNList,
                    show_display: msg.showDisplay,
                }, { signal })).address;
            }));
        }), (msg) => JSON.stringify(msg));
        // TODO check if sdk supports below messages
        this.ethGetAddress = lodash_1.default.memoize((msg) => __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                return (yield this.sdk.address.ethereumGetAddress({
                    address_n: msg.addressNList,
                    show_display: msg.showDisplay,
                }, { signal })).address;
            }));
        }), (msg) => JSON.stringify(msg));
        this.rippleGetAddress = lodash_1.default.memoize((msg) => __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                return (yield this.sdk.address.xrpGetAddress({
                    address_n: msg.addressNList,
                    show_display: msg.showDisplay,
                }, { signal })).address;
            }));
        }), (msg) => JSON.stringify(msg));
        this.cosmosGetAddress = lodash_1.default.memoize((msg) => __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                return (yield this.sdk.address.cosmosGetAddress({
                    address_n: msg.addressNList,
                    show_display: msg.showDisplay,
                }, { signal })).address;
            }));
        }), (msg) => JSON.stringify(msg));
        this.osmosisGetAddress = lodash_1.default.memoize((msg) => __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                return (yield this.sdk.address.osmosisGetAddress({
                    address_n: msg.addressNList,
                    show_display: msg.showDisplay,
                }, { signal })).address;
            }));
        }), (msg) => JSON.stringify(msg));
        this.thorchainGetAddress = lodash_1.default.memoize((msg) => __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                return (yield this.sdk.address.thorchainGetAddress({
                    address_n: msg.addressNList,
                    show_display: msg.showDisplay,
                }, { signal })).address;
            }));
        }), (msg) => JSON.stringify(msg));
        this.binanceGetAddress = lodash_1.default.memoize((msg) => __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                // TODO: busted openapi-generator types
                return (yield this.sdk.address.binanceGetAddress({
                    address_n: msg.addressNList,
                    show_display: msg.showDisplay,
                }, { signal })).address;
            }));
        }), (msg) => JSON.stringify(msg));
        this.eosGetPublicKey = lodash_1.default.memoize(
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        (_msg) => __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        }), (msg) => JSON.stringify(msg));
        this.sdk = sdk;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ethSendTx(_msg) {
        throw new Error('Method not implemented.');
    }
    ethGetChainId() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // chainId as hex string
                return parseInt(this.ethChainId, 16);
            }
            catch (e) {
                console.error(e);
                return null;
            }
        });
    }
    ethSwitchChain(params) {
        return __awaiter(this, void 0, void 0, function* () {
            this.ethChainId = params.chainId;
            return;
        });
    }
    ethAddChain(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
    abortable(fn) {
        return __awaiter(this, void 0, void 0, function* () {
            const abortController = new AbortController();
            try {
                const promise = fn(abortController.signal);
                this.abortControllers.set(abortController, promise.then(() => { }, () => { }));
                return yield promise;
            }
            catch (err) {
                if (err instanceof keepkey_sdk_1.FetchError) {
                    throw new core.ActionCancelled();
                }
                throw err;
            }
            finally {
                this.abortControllers.delete(abortController);
            }
        });
    }
    static create(sdk) {
        return __awaiter(this, void 0, void 0, function* () {
            return new KeepKeyRestHDWallet(sdk);
        });
    }
    getDeviceID() {
        return __awaiter(this, void 0, void 0, function* () {
            const features = yield this.getFeatures();
            return features.deviceId;
        });
    }
    getVendor() {
        return 'KeepKey';
    }
    getModel() {
        return __awaiter(this, void 0, void 0, function* () {
            const features = yield this.getFeatures();
            return core.mustBeDefined(features).model;
        });
    }
    getFirmwareVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            const features = yield this.getFeatures();
            return `v${features.majorVersion}.${features.minorVersion}.${features.patchVersion}`;
        });
    }
    getLabel() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const features = yield this.getFeatures();
            return (_a = features.label) !== null && _a !== void 0 ? _a : '';
        });
    }
    isInitialized() {
        return __awaiter(this, void 0, void 0, function* () {
            const features = yield this.getFeatures();
            return !!features.initialized;
        });
    }
    isLocked() {
        return __awaiter(this, void 0, void 0, function* () {
            const features = yield this.getFeaturesUncached();
            if (features.pinProtection && !features.pinCached)
                return true;
            if (features.passphraseProtection && !features.passphraseCached)
                return true;
            return false;
        });
    }
    ping(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                const formattedMsg = {
                    message: msg.msg,
                    passphrase_protection: msg.passphrase,
                    pin_protection: msg.pin,
                    button_protection: msg.button,
                };
                const { message: respmsg } = yield this.sdk.system.info.ping(formattedMsg, { signal });
                return { msg: respmsg };
            }));
        });
    }
    reset(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                console.log('sending reset', msg);
                yield this.sdk.system.initialize.resetDevice({
                    u2f_counter: msg.u2fCounter,
                    auto_lock_delay_ms: msg.autoLockDelayMs,
                    label: msg.label,
                    passphrase_protection: msg.passphrase,
                    pin_protection: msg.pin,
                    strength: msg.entropy,
                }, { signal });
            }));
        });
    }
    recover(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                console.log('sending recoverDevice', msg);
                yield this.sdk.system.initialize.recoverDevice({
                    u2f_counter: msg.u2fCounter,
                    auto_lock_delay_ms: msg.autoLockDelayMs,
                    label: msg.label,
                    passphrase_protection: msg.passphrase,
                    pin_protection: msg.pin,
                    word_count: (() => {
                        switch (msg.entropy) {
                            case 128:
                                return 12;
                            case 192:
                                return 18;
                            case 256:
                                return 24;
                            default:
                                throw new Error('unsupported entropy value');
                        }
                    })(),
                }, { signal });
            }));
        });
    }
    pressYes() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.press(true);
        });
    }
    pressNo() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.press(false);
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    press(_isYes) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
    hasOnDevicePinEntry() {
        return false;
    }
    hasOnDevicePassphrase() {
        return false;
    }
    hasOnDeviceDisplay() {
        return true;
    }
    hasOnDeviceRecovery() {
        return false;
    }
    supportsBip44Accounts() {
        return true;
    }
    supportsOfflineSigning() {
        return true;
    }
    supportsBroadcast() {
        return false;
    }
    sendPin() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("pin entry is handled by the server, so don't call this");
        });
    }
    sendPassphrase() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("passphrase entry is handled by the server, so don't call this");
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sendCharacter(_character) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("character entry is handled by the server, so don't call this");
        });
    }
    sendCharacterDelete() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("character entry is handled by the server, so don't call this");
        });
    }
    sendCharacterDone() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("character entry is handled by the server, so don't call this");
        });
    }
    sendWord() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('obsolete');
        });
    }
    hasNativeShapeShift() {
        return false;
    }
    btcSupportsNativeShapeShift() {
        return false;
    }
    ethSupportsNativeShapeShift() {
        return false;
    }
    applyPolicy(p) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                yield this.sdk.system.applyPolicies([
                    {
                        policy_name: p.policyName,
                        enabled: p.enabled,
                    },
                ], { signal });
            }));
        });
    }
    applySettings(s) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                yield this.sdk.system.applySettings({
                    u2f_counter: s.u2fCounter,
                    auto_lock_delay_ms: s.autoLockDelayMs,
                    label: s.label,
                    language: s.language,
                    use_passphrase: s.usePassphrase,
                }, { signal });
            }));
        });
    }
    cancel() {
        return __awaiter(this, void 0, void 0, function* () {
            const inFlight = Array.from(this.abortControllers.values());
            this.abortControllers.forEach((_, abortController) => abortController.abort());
            this.abortControllers.clear();
            yield Promise.allSettled(inFlight);
        });
    }
    changePin() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                yield this.sdk.system.changePin({}, { signal });
            }));
        });
    }
    clearSession() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                yield this.sdk.system.clearSession({ signal });
            }));
        });
    }
    firmwareErase() {
        return __awaiter(this, void 0, void 0, function* () {
            // skipped, as this is done automatically by the server during firmwareUpload
        });
    }
    // @ts-ignore
    firmwareUpload(firmware) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                yield this.sdk.system.firmwareUpdate(new Blob([firmware]), undefined, { signal });
            }));
        });
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            // await this.sdk.developer.initialize({ body: {} });
        });
    }
    getFeaturesUncached() {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            const raw = yield this.sdk.system.info.getFeatures();
            // @ts-ignore
            return {
                vendor: raw.vendor,
                // TODO: openapi-generator has busted types on these
                majorVersion: raw.major_version,
                minorVersion: raw.minor_version,
                patchVersion: raw.patch_version,
                bootloaderMode: raw.bootloader_mode,
                pinProtection: raw.pin_protection,
                passphraseProtection: raw.passphrase_protection,
                deviceId: raw.device_id,
                model: raw.model,
                language: raw.language,
                label: raw.label,
                coinsList: [],
                initialized: raw.initialized,
                //@ts-ignore
                revision: Buffer.from((_a = raw.revision) !== null && _a !== void 0 ? _a : '', 'utf8').toString('base64'),
                //@ts-ignore
                bootloaderHash: Buffer.from((_b = raw.bootloader_hash) !== null && _b !== void 0 ? _b : '', 'hex').toString('base64'),
                //@ts-ignore
                firmwareHash: Buffer.from((_c = raw.firmware_hash) !== null && _c !== void 0 ? _c : '', 'hex').toString('base64'),
                imported: raw.imported,
                pinCached: raw.pin_cached,
                passphraseCached: raw.passphrase_cached,
                policiesList: ((_d = raw.policies) !== null && _d !== void 0 ? _d : []).map((x) => ({
                    policyName: x.policy_name,
                    enabled: x.enabled,
                })),
                firmwareVariant: raw.firmware_variant,
                noBackup: raw.no_backup,
                wipeCodeProtection: raw.wipe_code_protection,
                autoLockDelayMs: raw.auto_lock_delay_ms,
            };
        });
    }
    resetCaches() {
        this.getFeaturesCached.cache = new lodash_1.default.memoize.Cache();
        this.btcGetAddress.cache = new lodash_1.default.memoize.Cache();
        this.ethGetAddress.cache = new lodash_1.default.memoize.Cache();
        this.rippleGetAddress.cache = new lodash_1.default.memoize.Cache();
        this.cosmosGetAddress.cache = new lodash_1.default.memoize.Cache();
        this.osmosisGetAddress.cache = new lodash_1.default.memoize.Cache();
        this.thorchainGetAddress.cache = new lodash_1.default.memoize.Cache();
        this.binanceGetAddress.cache = new lodash_1.default.memoize.Cache();
        this.eosGetPublicKey.cache = new lodash_1.default.memoize.Cache();
        this.getPublicKeys.cache = new lodash_1.default.memoize.Cache();
    }
    getFeatures(cached) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(cached !== null && cached !== void 0 ? cached : true)) {
                this.resetCaches();
            }
            return yield this.getFeaturesCached();
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getEntropy(_size) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
    getNumCoins() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
    getCoinTable(start = 0, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _end = start + 10) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
    loadDevice(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                yield this.sdk.system.initialize.loadDevice({
                    mnemonic: msg.mnemonic,
                    label: msg.label,
                    passphrase_protection: msg.passphrase,
                    pin: msg.pin,
                    skip_checksum: msg.skipChecksum,
                    // TODO: openapi-generator typing is busted here
                    xprv: '',
                }, { signal });
            }));
        });
    }
    removePin() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                yield this.sdk.system.changePin({ remove: true }, { signal });
            }));
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    send(_events) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
    softReset() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                yield this.sdk.system.manufacturing.softReset({ signal });
            }));
        });
    }
    wipe() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                yield this.sdk.system.wipeDevice({ signal });
            }));
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    btcSupportsCoin(_coin) {
        return __awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    btcSupportsScriptType(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _coin, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _scriptType) {
        return __awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    btcSignTx(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                const { serializedTx } = yield this.sdk.utxo.utxoSignTransaction(msg, { signal });
                return {
                    signatures: core.untouchable('signatures field not implemented'),
                    serializedTx: serializedTx,
                };
            }));
        });
    }
    btcSupportsSecureTransfer() {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    ethSupportsEIP1559() {
        return __awaiter(this, void 0, void 0, function* () {
            return semver_1.default.gte(yield this.getFirmwareVersion(), 'v7.2.1');
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    btcSignMessage(_msg) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    btcVerifyMessage(_msg) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    btcGetAccountPaths(_msg) {
        throw new Error('not implemented');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    btcIsSameAccount(_msg) {
        throw new Error('not implemented');
    }
    ethSignTx(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                if (!msg.data)
                    msg.data = '0x';
                if (msg.to === undefined || !msg.to || msg.to === null) {
                    msg.to = '0x';
                }
                console.log('MSG: ', msg);
                const sig = yield this.sdk.eth.ethSignTransaction({
                    nonce: msg.nonce,
                    value: msg.value,
                    data: msg.data,
                    from: (yield this.sdk.address.ethereumGetAddress({ address_n: msg.addressNList }, { signal })).address,
                    to: msg.to,
                    gas: msg.gasLimit,
                    gasPrice: msg.gasPrice,
                    maxFeePerGas: msg.maxFeePerGas,
                    maxPriorityFeePerGas: msg.maxPriorityFeePerGas,
                    chainId: msg.chainId,
                }, { signal });
                console.log('sig.serialized: ', sig.serialized);
                return {
                    v: sig.v,
                    r: sig.r,
                    s: sig.s,
                    serialized: sig.serialized,
                };
            }));
        });
    }
    ethSignMessage(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                const address = (yield this.sdk.address.ethereumGetAddress({ address_n: msg.addressNList }, { signal })).address;
                // @ts-ignore
                const message = `0x${Buffer.from(Uint8Array.from(typeof msg.message === 'string' ? new TextEncoder().encode(msg.message) : msg.message)).toString('hex')}`;
                // TODO: openapi-generator types are terrible
                const signature = (yield this.sdk.eth.ethSign({
                    address,
                    message,
                }, { signal }));
                return {
                    address,
                    signature,
                };
            }));
        });
    }
    ethSignTypedData(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                console.log('msg: ', msg);
                console.log('msg: ', JSON.stringify(msg));
                const address = (yield this.sdk.address.ethereumGetAddress({ address_n: msg.addressNList }, { signal })).address;
                // TODO: openapi-generator types are terrible
                const signature = (yield this.sdk.eth.ethSignTypedData({
                    // (Our types are a bit stricter than the ones from the eip712 library.)
                    typedData: msg.typedData,
                    address,
                }, { signal }));
                return {
                    address,
                    signature,
                };
            }));
        });
    }
    ethVerifyMessage(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                // @ts-ignore
                const message = `0x${Buffer.from(Uint8Array.from(typeof msg.message === 'string' ? new TextEncoder().encode(msg.message) : msg.message)).toString('hex')}`;
                const output = yield this.sdk.eth.ethVerify({
                    signature: msg.signature,
                    address: msg.address,
                    message,
                }, { signal });
                return output;
            }));
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ethSupportsNetwork(_chain_id) {
        return __awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    ethSupportsSecureTransfer() {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    ethGetAccountPaths(msg) {
        const slip44 = core.slip44ByCoin(msg.coin);
        if (slip44 === undefined)
            return [];
        return [
            {
                addressNList: [0x80000000 + 44, 0x80000000 + slip44, 0x80000000 + msg.accountIdx, 0, 0],
                hardenedPath: [0x80000000 + 44, 0x80000000 + slip44, 0x80000000 + msg.accountIdx],
                relPath: [0, 0],
                description: 'KeepKey',
            },
        ];
    }
    rippleGetAccountPaths(msg) {
        return [
            {
                addressNList: [
                    0x80000000 + 44,
                    0x80000000 + core.slip44ByCoin('Ripple'),
                    0x80000000 + msg.accountIdx,
                    0,
                    0,
                ],
            },
        ];
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    rippleSignTx(_msg) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
    cosmosGetAccountPaths(msg) {
        return [
            {
                addressNList: [
                    0x80000000 + 44,
                    0x80000000 + core.slip44ByCoin('Atom'),
                    0x80000000 + msg.accountIdx,
                    0,
                    0,
                ],
            },
        ];
    }
    cosmosSignTx(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
                const signerAddress = (yield this.sdk.address.cosmosGetAddress({
                    address_n: msg.addressNList,
                }, { signal })).address;
                let signed;
                //switch statement
                switch (msg.tx.msg[0].type) {
                    case 'cosmos-sdk/MsgSend':
                        console.log('MSG: ', msg);
                        signed = yield this.sdk.cosmos.cosmosSignAmino({
                            signDoc: {
                                account_number: msg.account_number,
                                chain_id: msg.chain_id,
                                msgs: msg.tx.msg,
                                memo: (_a = msg.tx.memo) !== null && _a !== void 0 ? _a : '',
                                sequence: msg.sequence,
                                fee: {
                                    gas: String((_b = msg.fee) !== null && _b !== void 0 ? _b : 0),
                                    amount: [],
                                },
                            },
                            signerAddress,
                        }, { signal });
                        break;
                    case 'cosmos-sdk/MsgDelegate':
                        signed = yield this.sdk.cosmos.cosmosSignAminoDelegate({
                            signDoc: {
                                account_number: msg.account_number,
                                chain_id: msg.chain_id,
                                msgs: msg.tx.msg,
                                memo: (_c = msg.tx.memo) !== null && _c !== void 0 ? _c : '',
                                sequence: msg.sequence,
                                fee: {
                                    gas: String((_d = msg.fee) !== null && _d !== void 0 ? _d : 0),
                                    amount: [],
                                },
                            },
                            signerAddress,
                        }, { signal });
                        break;
                    case 'cosmos-sdk/MsgBeginRedelegate':
                    case 'cosmos-sdk/MsgReDelegate':
                        signed = yield this.sdk.cosmos.cosmosSignAminoRedelegate({
                            signDoc: {
                                account_number: msg.account_number,
                                chain_id: msg.chain_id,
                                msgs: msg.tx.msg,
                                memo: (_e = msg.tx.memo) !== null && _e !== void 0 ? _e : '',
                                sequence: msg.sequence,
                                fee: {
                                    gas: String((_f = msg.fee) !== null && _f !== void 0 ? _f : 0),
                                    amount: [],
                                },
                            },
                            signerAddress,
                        }, { signal });
                        break;
                    case 'cosmos-sdk/MsgUndelegate':
                    case 'cosmos-sdk/MsgUnDelegate':
                        signed = yield this.sdk.cosmos.cosmosSignAminoUndelegate({
                            signDoc: {
                                account_number: msg.account_number,
                                chain_id: msg.chain_id,
                                msgs: msg.tx.msg,
                                memo: (_g = msg.tx.memo) !== null && _g !== void 0 ? _g : '',
                                sequence: msg.sequence,
                                fee: {
                                    gas: String((_h = msg.fee) !== null && _h !== void 0 ? _h : 0),
                                    amount: [],
                                },
                            },
                            signerAddress,
                        }, { signal });
                        break;
                    case 'cosmos-sdk/MsgWithdrawDelegatorReward':
                    case 'cosmos-sdk/MsgWithdrawDelegationReward':
                        signed = yield this.sdk.cosmos.cosmosSignAminoWithdrawDelegatorRewardsAll({
                            signDoc: {
                                account_number: msg.account_number,
                                chain_id: msg.chain_id,
                                msgs: msg.tx.msg,
                                memo: (_j = msg.tx.memo) !== null && _j !== void 0 ? _j : '',
                                sequence: msg.sequence,
                                fee: {
                                    gas: String((_k = msg.fee) !== null && _k !== void 0 ? _k : 0),
                                    amount: [],
                                },
                            },
                            signerAddress,
                        }, { signal });
                        break;
                    case 'cosmos-sdk/MsgTransfer':
                        signed = yield this.sdk.cosmos.cosmosSignAminoIbcTransfer({
                            signDoc: {
                                account_number: msg.account_number,
                                chain_id: msg.chain_id,
                                msgs: msg.tx.msg,
                                memo: msg.tx.memo || ' ',
                                sequence: msg.sequence,
                                fee: {
                                    gas: String((_l = msg.fee) !== null && _l !== void 0 ? _l : 0),
                                    amount: [],
                                },
                            },
                            signerAddress,
                        }, { signal });
                        break;
                    default:
                        throw Error('osmo Msg not supported ' + msg.tx.msg[0].type);
                }
                return {
                    signatures: [signed.signature],
                    serialized: signed.serialized,
                    authInfoBytes: core.untouchable('not implemented'),
                    body: core.untouchable('not implemented'),
                };
            }));
        });
    }
    osmosisGetAccountPaths(msg) {
        return [
            {
                addressNList: [
                    0x80000000 + 44,
                    0x80000000 + core.slip44ByCoin('Osmo'),
                    0x80000000 + msg.accountIdx,
                    0,
                    0,
                ],
            },
        ];
    }
    osmosisSignTx(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
                const signerAddress = (yield this.sdk.address.osmosisGetAddress({
                    address_n: msg.addressNList,
                }, { signal })).address;
                let signed;
                //switch statement
                switch (msg.tx.msg[0].type) {
                    case 'cosmos-sdk/MsgSend':
                        signed = yield this.sdk.osmosis.osmosisSignAmino({
                            signDoc: {
                                account_number: msg.account_number,
                                chain_id: msg.chain_id,
                                msgs: msg.tx.msg,
                                memo: (_a = msg.tx.memo) !== null && _a !== void 0 ? _a : '',
                                sequence: msg.sequence,
                                fee: {
                                    gas: String((_b = msg.fee) !== null && _b !== void 0 ? _b : 0),
                                    amount: [],
                                },
                            },
                            signerAddress,
                        }, { signal });
                        break;
                    case 'cosmos-sdk/MsgDelegate':
                        signed = yield this.sdk.osmosis.osmoSignAminoDelegate({
                            signDoc: {
                                account_number: msg.account_number,
                                chain_id: msg.chain_id,
                                msgs: msg.tx.msg,
                                memo: (_c = msg.tx.memo) !== null && _c !== void 0 ? _c : '',
                                sequence: msg.sequence,
                                fee: {
                                    gas: String((_d = msg.fee) !== null && _d !== void 0 ? _d : 0),
                                    amount: [],
                                },
                            },
                            signerAddress,
                        }, { signal });
                        break;
                    case 'cosmos-sdk/MsgReDelegate':
                        signed = yield this.sdk.osmosis.osmoSignAminoRedelegate({
                            signDoc: {
                                account_number: msg.account_number,
                                chain_id: msg.chain_id,
                                msgs: msg.tx.msg,
                                memo: (_e = msg.tx.memo) !== null && _e !== void 0 ? _e : '',
                                sequence: msg.sequence,
                                fee: {
                                    gas: String((_f = msg.fee) !== null && _f !== void 0 ? _f : 0),
                                    amount: [],
                                },
                            },
                            signerAddress,
                        }, { signal });
                        break;
                    case 'cosmos-sdk/MsgUnDelegate':
                        signed = yield this.sdk.osmosis.osmoSignAminoUndelegate({
                            signDoc: {
                                account_number: msg.account_number,
                                chain_id: msg.chain_id,
                                msgs: msg.tx.msg,
                                memo: (_g = msg.tx.memo) !== null && _g !== void 0 ? _g : '',
                                sequence: msg.sequence,
                                fee: {
                                    gas: String((_h = msg.fee) !== null && _h !== void 0 ? _h : 0),
                                    amount: [],
                                },
                            },
                            signerAddress,
                        }, { signal });
                        break;
                    case 'cosmos-sdk/MsgWithdrawDelegationReward':
                        signed = yield this.sdk.osmosis.osmoSignAminoWithdrawDelegatorRewardsAll({
                            signDoc: {
                                account_number: msg.account_number,
                                chain_id: msg.chain_id,
                                msgs: msg.tx.msg,
                                memo: (_j = msg.tx.memo) !== null && _j !== void 0 ? _j : '',
                                sequence: msg.sequence,
                                fee: {
                                    gas: String((_k = msg.fee) !== null && _k !== void 0 ? _k : 0),
                                    amount: [],
                                },
                            },
                            signerAddress,
                        }, { signal });
                        break;
                    case 'cosmos-sdk/MsgTransfer':
                        signed = yield this.sdk.osmosis.osmoSignAminoIbcTransfer({
                            signDoc: {
                                account_number: msg.account_number,
                                chain_id: msg.chain_id,
                                msgs: msg.tx.msg,
                                memo: (_l = msg.tx.memo) !== null && _l !== void 0 ? _l : '',
                                sequence: msg.sequence,
                                fee: {
                                    gas: String((_m = msg.fee) !== null && _m !== void 0 ? _m : 0),
                                    amount: [],
                                },
                            },
                            signerAddress,
                        }, { signal });
                        break;
                    case 'osmosis/gamm/join-pool':
                        signed = yield this.sdk.osmosis.osmoSignAminoLpAdd({
                            signDoc: {
                                account_number: msg.account_number,
                                chain_id: msg.chain_id,
                                msgs: msg.tx.msg,
                                memo: msg.tx.memo || '',
                                sequence: msg.sequence,
                                fee: {
                                    gas: String((_o = msg.fee) !== null && _o !== void 0 ? _o : 0),
                                    amount: [],
                                },
                            },
                            signerAddress,
                        }, { signal });
                        break;
                    case 'osmosis/gamm/exit-pool':
                        signed = yield this.sdk.osmosis.osmoSignAminoLpRemove({
                            signDoc: {
                                account_number: msg.account_number,
                                chain_id: msg.chain_id,
                                msgs: msg.tx.msg,
                                memo: (_p = msg.tx.memo) !== null && _p !== void 0 ? _p : '',
                                sequence: msg.sequence,
                                fee: {
                                    gas: String((_q = msg.fee) !== null && _q !== void 0 ? _q : 0),
                                    amount: [],
                                },
                            },
                            signerAddress,
                        }, { signal });
                        break;
                    case 'osmosis/gamm/swap-exact-amount-in': //mosis/gamm/swap-exact-amount-in
                        signed = yield this.sdk.osmosis.osmoSignAminoSwap({
                            signDoc: {
                                account_number: msg.account_number,
                                chain_id: msg.chain_id,
                                msgs: msg.tx.msg,
                                memo: (_r = msg.tx.memo) !== null && _r !== void 0 ? _r : '',
                                sequence: msg.sequence,
                                fee: {
                                    gas: String((_s = msg.fee) !== null && _s !== void 0 ? _s : 0),
                                    amount: [],
                                },
                            },
                            signerAddress,
                        }, { signal });
                        break;
                    default:
                        throw Error('Msg not supported ' + msg.tx.msg[0].type);
                }
                return {
                    signatures: [signed.signature],
                    serialized: signed.serialized,
                    authInfoBytes: core.untouchable('not implemented'),
                    body: core.untouchable('not implemented'),
                };
            }));
        });
    }
    thorchainGetAccountPaths(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _msg) {
        throw new Error('not implemented');
    }
    thorchainSignTx(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c, _d;
                const signerAddress = (yield this.sdk.address.thorchainGetAddress({
                    address_n: msg.addressNList,
                }, { signal })).address;
                /*
                 */
                let signed;
                //switch statement
                switch (msg.tx.msg[0].type) {
                    case 'thorchain/MsgDeposit':
                        console.log('thorchain/MsgDeposit MSG: ', msg);
                        signed = yield this.sdk.thorchain.thorchainSignAminoDeposit({
                            signDoc: {
                                account_number: msg.account_number,
                                chain_id: msg.chain_id,
                                msgs: msg.tx.msg,
                                memo: (_a = msg.tx.memo) !== null && _a !== void 0 ? _a : '',
                                sequence: msg.sequence,
                                fee: {
                                    gas: String((_b = msg.fee) !== null && _b !== void 0 ? _b : 0),
                                    amount: [],
                                },
                            },
                            signerAddress,
                        }, { signal });
                        break;
                    case 'thorchain/MsgSend':
                        console.log('thorchain/MsgSend MSG: ', msg);
                        signed = yield this.sdk.thorchain.thorchainSignAminoTransfer({
                            signDoc: {
                                account_number: msg.account_number,
                                chain_id: msg.chain_id,
                                msgs: msg.tx.msg,
                                memo: (_c = msg.tx.memo) !== null && _c !== void 0 ? _c : '',
                                sequence: msg.sequence,
                                fee: {
                                    gas: String((_d = msg.fee) !== null && _d !== void 0 ? _d : 0),
                                    amount: [],
                                },
                            },
                            signerAddress,
                        }, { signal });
                        break;
                    default:
                        throw Error('thorchain Msg not supported ' + msg.tx.msg[0].type);
                }
                return {
                    signatures: [signed.signature],
                    serialized: signed.serialized,
                    authInfoBytes: core.untouchable('not implemented'),
                    body: core.untouchable('not implemented'),
                };
            }));
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    binanceGetAccountPaths(_msg) {
        throw new Error('not implemented');
    }
    binanceSignTx(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.abortable((signal) => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c, _d, _e;
                const signerAddress = yield this.sdk.address.binanceGetAddress({
                    address_n: msg.addressNList,
                }, { signal });
                const signed = yield this.sdk.bnb.bnbSignTransaction({
                    signDoc: {
                        account_number: (_a = msg.tx.account_number) !== null && _a !== void 0 ? _a : '',
                        chain_id: (_b = msg.tx.chain_id) !== null && _b !== void 0 ? _b : '',
                        msgs: msg.tx.msgs,
                        memo: (_c = msg.tx.memo) !== null && _c !== void 0 ? _c : '',
                        sequence: (_d = msg.tx.sequence) !== null && _d !== void 0 ? _d : '',
                        source: (_e = msg.tx.source) !== null && _e !== void 0 ? _e : '',
                    },
                    signerAddress,
                }, { signal });
                return { signatures: { signature: signed.signature } };
            }));
        });
    }
    eosGetAccountPaths(msg) {
        return [
            {
                addressNList: [
                    0x80000000 + 44,
                    0x80000000 + core.slip44ByCoin('Eos'),
                    0x80000000 + msg.accountIdx,
                    0,
                    0,
                ],
            },
        ];
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    eosSignTx(_msg) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
    describePath(msg) {
        switch (msg.coin) {
            case 'Ethereum':
                return core.describeETHPath(msg.path);
            case 'Atom':
                return core.cosmosDescribePath(msg.path);
            case 'Binance':
                return core.binanceDescribePath(msg.path);
            default:
                return core.describeUTXOPath(msg.path, msg.coin, msg.scriptType);
        }
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            // does nothing
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    btcNextAccountPath(_msg) {
        throw new Error('not implemented');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ethNextAccountPath(_msg) {
        throw new Error('not implemented');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    eosNextAccountPath(_msg) {
        throw new Error('not implemented');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    cosmosNextAccountPath(_msg) {
        throw new Error('not implemented');
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    rippleNextAccountPath(_msg) {
        throw new Error('not implemented');
    }
    binanceNextAccountPath(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _msg) {
        throw new Error('not implemented');
    }
}
exports.KeepKeyRestHDWallet = KeepKeyRestHDWallet;
