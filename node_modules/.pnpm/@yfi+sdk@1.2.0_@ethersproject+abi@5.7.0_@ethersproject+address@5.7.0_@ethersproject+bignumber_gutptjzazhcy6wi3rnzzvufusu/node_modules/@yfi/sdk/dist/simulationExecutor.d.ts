import { Context } from "./context";
import { TelegramService } from "./services/telegram";
import { SimulationOptions } from "./types";
import { Address, Integer } from "./types/common";
export interface SimulationResponse {
    transaction: {
        transaction_info: {
            call_trace: SimulationCallTrace;
            logs: SimulationLog[];
        };
        error_message?: string;
    };
    simulation: {
        id: string;
    };
}
interface SimulationLog {
    raw: {
        address: Address;
        topics: string[];
        data: string;
    };
}
interface SimulationCallTrace {
    output: Integer;
    calls: SimulationCallTrace[] | null;
    error?: string;
}
/**
 * [[SimulationExecutor]] performs simulation requests and returns the response
 * with no data manipulation. If the simulation results in an error then an alert is sent
 * via telegram if the appropriate environment variables are set. Forks are necessary to be
 * created if two subsequent simulations are needed e.g. if a zap in is wished to be simulated
 * but the user has not approved the zap contract then the steps to simulate it are:
 * 1. Create a fork
 * 2. Simulate the approval transaction using this fork
 * 3. Simulate the zap in using the approval transaction as the root
 */
export declare class SimulationExecutor {
    private telegram;
    private ctx;
    constructor(telegram: TelegramService, ctx: Context);
    /**
     * Simulate a transaction
     * @param from
     * @param to
     * @param input the encoded input data as per the ethereum abi specification
     * @param value the ether value of the transaction
     * @param options simulation options
     * @returns data about the simulated transaction
     */
    simulateRaw(from: Address, to: Address, input: string, options?: SimulationOptions, value?: Integer): Promise<any>;
    /**
     * Simulates an interaction with a vault to see how much of the desired token
     * will be received. This happens by inspecting the logs of the transaction and
     * finding the Transfer event where the desired token is transferred to the user.
     * @param from
     * @param to
     * @param data
     * @param targetToken the token being bought by this transaction
     * @param from the address initiating this transaction
     * @param options
     * @param value
     * @returns the amount of tokens simulated to be bought
     */
    simulateVaultInteraction(from: Address, to: Address, data: string, targetToken: Address, options: SimulationOptions, value?: Integer): Promise<Integer>;
    /**
     * Performs a simulation with preset parameters
     * @param from
     * @param to
     * @param data
     * @param options
     * @param value
     * @returns the resulting data from the transaction
     */
    makeSimulationRequest(from: Address, to: Address, data: string, options: SimulationOptions, value?: Integer): Promise<SimulationResponse>;
    /**
     * Simulates a transaction, with the `save` parameter initially set to `false`. If this simulation fails then
     * the simulation is re-executed but with `save` set to `true` so the failure can be stored and later analyzed.
     * @param simulate the function which executes the simulation, passing in `save` as an argument.
     * @param forkIdToDeleteOnSuccess if the simulation is successful there is no reason to save it. Delete the fork to avoid clutter
     * @returns the result of the simulate parameter
     */
    executeSimulationWithReSimulationOnFailure<T>(simulate: (save: boolean) => Promise<T>, forkIdToDeleteOnSuccess?: string | null): Promise<T>;
    /**
     * Recursively loops through the simulation call trace, aggregating all calls into a flattened array.
     * @param callTrace the starting call trace to inspect
     * @returns a flattened array of call data
     */
    private getAllSimulationCalls;
    /**
     * Creates a transaction object and populates it to fill in parameters such as gas price,
     * gas limit and nonce for a more accurate simulations
     * @param from
     * @param to
     * @param data
     * @param value
     * @param options
     * @returns A populated TransactionRequest object
     */
    private getPopulatedTransactionRequest;
    /**
     * Create a new fork that can be used to simulate multiple sequential transactions on
     * e.g. approval followed by a deposit.
     * @returns the uuid of a new fork that has been created
     */
    createFork(): Promise<string>;
    /**
     * Deletes a fork. This should be done after its successful use in order to avoid clutter.
     * @param forkId the fork to be deleted
     * @returns the deletion response
     */
    private deleteFork;
    /**
     * Sends a message to a telegram channel reporting a simulation error
     * @param errorMessage the error to be reported
     * @param simulationId the id of the simulation so the simulation failure can be inspected in the dashboard
     * @param forkId the optional id of the fork so the simulation failure can be inspected in the dashboard
     */
    private sendErrorMessage;
}
export {};
