/// <reference types="node" />
import { JsonRpcProvider } from "@ethersproject/providers";
import EventEmitter from "events";
import { PartialDeep } from "type-fest";
import { Address } from "./types";
export interface AddressesOverride {
    lens?: Address;
    oracle?: Address;
    adapters: {
        registryV2?: Address;
        ironBank?: Address;
    };
    helper?: Address;
    allowList?: Address;
}
/**
 * For particular situations it's helpful to have two separate providers, one
 * for reading data and one for writing data.
 */
export interface ReadWriteProvider {
    read: JsonRpcProvider;
    write: JsonRpcProvider;
}
/**
 * To provide configuration for simulation error reporting
 */
export interface SimulationConfiguration extends TelegramConfiguration {
    dashboardUrl?: string;
}
/**
 * Provides details about sending a message from a telegram bot to a
 * specific chat
 */
export interface TelegramConfiguration {
    telegramChatId?: string;
    telegramBotId?: string;
}
export interface CacheConfiguration {
    useCache: boolean;
    url?: string;
}
/**
 * Context options that are used to access all the data sources queried by the
 * SDK.
 */
export interface ContextValue {
    provider?: JsonRpcProvider | ReadWriteProvider;
    zapper?: string;
    etherscan?: string;
    addresses?: PartialDeep<AddressesOverride>;
    simulation?: SimulationConfiguration;
    cache?: CacheConfiguration;
}
/**
 * [[Context]] is the configuration object passed around every function in
 * the SDK. It contains basic information on how to access the various services
 * that the SDK aggregates.
 *
 * [[Context]] **should not** be instantiated by users, as it's managed by
 * {@link Yearn.context}.
 */
export declare class Context implements Required<ContextValue> {
    static PROVIDER: string;
    private ctx;
    /**
     * For internal events only.
     */
    events: EventEmitter;
    constructor(ctx: ContextValue);
    /**
     * Change providers during executions for all services that require on-chain
     * interaction.
     * @param provider new provider(s)
     */
    setProvider(provider?: JsonRpcProvider | ReadWriteProvider): void;
    get provider(): ReadWriteProvider;
    get zapper(): string;
    get etherscan(): string;
    get addresses(): AddressesOverride;
    get simulation(): SimulationConfiguration;
    get cache(): CacheConfiguration;
}
