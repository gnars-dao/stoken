import { CallOverrides } from "@ethersproject/contracts";
import { TransactionResponse } from "@ethersproject/providers";
import { ChainId } from "../chain";
import { ServiceInterface } from "../common";
import { Address, Balance, DepositOptions, Integer, Token, VaultDynamic, VaultMetadataOverrides, VaultStatic, VaultsUserSummary, VaultUserMetadata, WithdrawOptions } from "../types";
import { Position, Vault } from "../types";
export declare class VaultInterface<T extends ChainId> extends ServiceInterface<T> {
    private cachedFetcherGet;
    private cachedFetcherGetDynamic;
    private cachedFetcherTokens;
    /**
     * Get all yearn vaults.
     * @param addresses filter, if not provided all positions are returned
     * @param overrides
     * @returns
     */
    get(addresses?: Address[], overrides?: CallOverrides): Promise<Vault[]>;
    /**
     * Get static part of yearn vaults.
     * @param addresses filter, if not provided all positions are returned
     * @param overrides
     * @returns
     */
    getStatic(addresses?: Address[], overrides?: CallOverrides): Promise<VaultStatic[]>;
    /**
     * Get dynamic part of yearn vaults.
     * @param addresses filter, if not provided all positions are returned
     * @param overrides
     * @returns
     */
    getDynamic(addresses?: Address[], vaultMetadataOverrides?: VaultMetadataOverrides[], overrides?: CallOverrides): Promise<VaultDynamic[]>;
    /**
     * Get yearn vault positions for a particular address.
     * @param address
     * @param addresses filter, if not provided all positions are returned
     * @param overrides
     * @returns
     */
    positionsOf(address: Address, addresses?: Address[], overrides?: CallOverrides): Promise<Position[]>;
    /**
     * Get the Vaults User Summary for a particular address.
     * @param address
     * @returns
     */
    summaryOf(address: Address): Promise<VaultsUserSummary>;
    /**
     * Get the Vault User Metadata for a particular address.
     * @param address
     * @param addresses filter, if provided only those addresses' Vault User Metadata are returned
     * @returns
     */
    metadataOf(address: Address, addresses?: Address[]): Promise<VaultUserMetadata[]>;
    /**
     * Get all yearn vault's underlying token balances for a particular address.
     * @param address
     * @param overrides
     * @returns
     */
    balances(address: Address, overrides?: CallOverrides): Promise<Balance[]>;
    /**
     * Get all yearn vault's underlying tokens.
     * @param overrides
     * @returns
     */
    tokens(overrides?: CallOverrides): Promise<Token[]>;
    /**
     * Deposit into a yearn vault
     * @param vault
     * @param token
     * @param amount
     * @param account
     * @param overrides
     * @returns transaction
     */
    deposit(vault: Address, token: Address, amount: Integer, account: Address, options?: DepositOptions, overrides?: CallOverrides): Promise<TransactionResponse>;
    /**
     * Withdraw from a yearn vault.
     * @param vault
     * @param token
     * @param amount
     * @param account
     * @param overrides
     * @returns transaction
     */
    withdraw(vault: Address, token: Address, amount: Integer, account: Address, options?: WithdrawOptions, overrides?: CallOverrides): Promise<TransactionResponse>;
    private zapIn;
    private executeZapperTransaction;
    private executeVaultContractTransaction;
    private fillTokenMetadataOverrides;
    private fillMetadataOverrides;
    private makeEmptyApy;
}
