import 'cross-fetch/polyfill';
import { JsonRpcProvider } from '@ethersproject/providers';
import EventEmitter from 'events';
import { getAddress } from '@ethersproject/address';
import BigNumber$1, { BigNumber } from 'bignumber.js';
import { Contract } from '@ethersproject/contracts';
import Emittery from 'emittery';
import { BigNumber as BigNumber$2 } from '@ethersproject/bignumber';
import fetch$1 from 'cross-fetch';
import { isBigNumberish } from '@ethersproject/bignumber/lib/bignumber';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var CustomError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(CustomError, _Error);

  function CustomError(message, error_type) {
    var _this;

    _this = _Error.call(this, message) || this;
    _this.error_type = error_type;
    return _this;
  }

  return CustomError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * Generic SDK error. Wrapped errors are:
 *
 * - ethers.js errors
 * - http request errors
 */

var SdkError = /*#__PURE__*/function (_CustomError) {
  _inheritsLoose(SdkError, _CustomError);

  function SdkError(message, error_code) {
    var _this2;

    _this2 = _CustomError.call(this, message, "sdk") || this;
    _this2.error_code = error_code;
    return _this2;
  }

  return SdkError;
}(CustomError);
SdkError.NO_SLIPPAGE = "no_slippage";

var SimulationError = /*#__PURE__*/function (_CustomError) {
  _inheritsLoose(SimulationError, _CustomError);

  function SimulationError(message, error_code) {
    var _this;

    _this = _CustomError.call(this, message, "simulation") || this;
    _this.error_code = error_code;
    return _this;
  }

  return SimulationError;
}(CustomError);
SimulationError.NO_LOG = "no_log";
SimulationError.TENDERLY_RESPONSE_ERROR = "tenderly_response_error";
SimulationError.PARTIAL_REVERT = "partial_revert";
var ZapperError = /*#__PURE__*/function (_CustomError2) {
  _inheritsLoose(ZapperError, _CustomError2);

  function ZapperError(message, error_code) {
    var _this2;

    _this2 = _CustomError2.call(this, message, "zapper") || this;
    _this2.error_code = error_code;
    return _this2;
  }

  return ZapperError;
}(CustomError);
ZapperError.ZAP_IN_APPROVAL_STATE = "zap_in_approval_state";
ZapperError.ZAP_IN_APPROVAL = "zap_in_approval";
ZapperError.ZAP_OUT_APPROVAL_STATE = "zap_out_approval_state";
ZapperError.ZAP_OUT_APPROVAL = "zap_out_approval";
ZapperError.ZAP_IN = "zap_in";
ZapperError.ZAP_OUT = "zap_out";
var EthersError = /*#__PURE__*/function (_CustomError3) {
  _inheritsLoose(EthersError, _CustomError3);

  function EthersError(message, error_code) {
    var _this3;

    _this3 = _CustomError3.call(this, message, "ethers") || this;
    _this3.error_code = error_code;
    return _this3;
  }

  return EthersError;
}(CustomError);
EthersError.FAIL_TOKEN_FETCH = "fail_token_fetch";
EthersError.NO_DECIMALS = "no_decimals";
EthersError.NO_PRICE_PER_SHARE = "no_price_per_share";
EthersError.POPULATING_TRANSACTION = "populating_transaction";
var TenderlyError = /*#__PURE__*/function (_CustomError4) {
  _inheritsLoose(TenderlyError, _CustomError4);

  function TenderlyError(message, error_code) {
    var _this4;

    _this4 = _CustomError4.call(this, message, "tenderly") || this;
    _this4.error_code = error_code;
    return _this4;
  }

  return TenderlyError;
}(CustomError);
TenderlyError.SIMULATION_CALL = "simulation_call";
TenderlyError.CREATE_FORK = "create_fork";
var PriceFetchingError = /*#__PURE__*/function (_CustomError5) {
  _inheritsLoose(PriceFetchingError, _CustomError5);

  function PriceFetchingError(message, error_code) {
    var _this5;

    _this5 = _CustomError5.call(this, message, "price_fetching") || this;
    _this5.error_code = error_code;
    return _this5;
  }

  return PriceFetchingError;
}(CustomError);
PriceFetchingError.FETCHING_PRICE_ORACLE = "fetching_price_oracle";
PriceFetchingError.FETCHING_PRICE_PICKLE = "fetching_price_pickle";

var ZapProtocol;

(function (ZapProtocol) {
  ZapProtocol["PICKLE"] = "pickle";
  ZapProtocol["YEARN"] = "yearn";
})(ZapProtocol || (ZapProtocol = {}));

var DefaultContext = {
  // Public API key provided by zapper.
  // see https://docs.zapper.fi/zapper-api/endpoints
  zapper: "96e0cc51-a62e-42ca-acee-910ea7d2a241",
  // The default tenderly dashboard for Yearn
  simulation: {
    dashboardUrl: "https://dashboard.tenderly.co/yearn/yearn-web"
  },
  cache: {
    useCache: true,
    url: "https://cache.yearn.finance"
  }
};
/**
 * [[Context]] is the configuration object passed around every function in
 * the SDK. It contains basic information on how to access the various services
 * that the SDK aggregates.
 *
 * [[Context]] **should not** be instantiated by users, as it's managed by
 * {@link Yearn.context}.
 */

var Context = /*#__PURE__*/function () {
  function Context(ctx) {
    this.ctx = Object.assign({}, DefaultContext, ctx);
    this.events = new EventEmitter().setMaxListeners(100);
    this.setProvider(ctx.provider);
  }
  /**
   * Change providers during executions for all services that require on-chain
   * interaction.
   * @param provider new provider(s)
   */


  var _proto = Context.prototype;

  _proto.setProvider = function setProvider(provider) {
    if (provider instanceof JsonRpcProvider) {
      this.ctx.provider = {
        read: provider,
        write: provider
      };
    } else if (provider) {
      this.ctx.provider = provider;
    }

    this.events.emit(Context.PROVIDER, this.ctx.provider);
  };

  _createClass(Context, [{
    key: "provider",
    get: function get() {
      if (this.ctx.provider) return this.ctx.provider;
      throw new SdkError("provider must be undefined in Context for this feature to work.");
    }
  }, {
    key: "zapper",
    get: function get() {
      if (this.ctx.zapper) return this.ctx.zapper;
      throw new SdkError("zapper must be undefined in Context for this feature to work.");
    }
  }, {
    key: "etherscan",
    get: function get() {
      if (this.ctx.etherscan) return this.ctx.etherscan;
      throw new SdkError("etherscan must be undefined in Context for this feature to work.");
    }
  }, {
    key: "addresses",
    get: function get() {
      return Object.assign({
        adapters: {}
      }, this.ctx.addresses);
    }
  }, {
    key: "simulation",
    get: function get() {
      if (this.ctx.simulation) return this.ctx.simulation;
      throw new SdkError("simulation configuration must be defined in Context for this feature to work.");
    }
  }, {
    key: "cache",
    get: function get() {
      if (this.ctx.cache) return this.ctx.cache;
      throw new SdkError("cache must be defined in Context for this feature to work.");
    }
  }]);

  return Context;
}();
Context.PROVIDER = "refresh:provider";

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var runtime_1 = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined$1; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined$1) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined$1;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined$1;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined$1;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined$1, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined$1;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined$1;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined$1;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined$1;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined$1;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports 
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}
});

var CachedFetcher = /*#__PURE__*/function () {
  function CachedFetcher(path, ctx, chainId) {
    this.path = path;
    this.ctx = ctx;
    this.chainId = chainId;
  }

  var _proto = CachedFetcher.prototype;

  _proto.fetch = /*#__PURE__*/function () {
    var _fetch = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(queryParameters) {
      var _call$headers$get;

      var cached, path, call, timeout, _call, url, status, statusText, json, maxAgeMatches, maxAge, now;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(!this.ctx.cache.useCache || !this.ctx.cache.url)) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return", undefined);

            case 2:
              cached = this.currentValue;

              if (!cached) {
                _context.next = 5;
                break;
              }

              return _context.abrupt("return", cached);

            case 5:
              path = this.ctx.cache.url + "/v1/chains/" + this.chainId + "/" + this.path;

              if (queryParameters) {
                path += "?" + queryParameters;
              }

              _context.prev = 7;
              timeout = 5000;
              _context.next = 11;
              return this.fetchWithTimeout(path, timeout);

            case 11:
              call = _context.sent;
              _context.next = 18;
              break;

            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](7);
              console.warn("Call to cache at " + path + " timed out");
              return _context.abrupt("return", undefined);

            case 18:
              if (!(call.status !== 200)) {
                _context.next = 22;
                break;
              }

              _call = call, url = _call.url, status = _call.status, statusText = _call.statusText;
              console.warn("Call to cache failed at " + url + " (status " + status + " " + statusText + ")");
              return _context.abrupt("return", undefined);

            case 22:
              _context.next = 24;
              return call.json();

            case 24:
              json = _context.sent;

              if (json) {
                _context.next = 27;
                break;
              }

              return _context.abrupt("return", undefined);

            case 27:
              maxAgeMatches = (_call$headers$get = call.headers.get("cache-control")) == null ? void 0 : _call$headers$get.match(/max-age=(\d+)/);
              maxAge = maxAgeMatches ? parseInt(maxAgeMatches[1], 10) : 30;
              now = new Date().getTime();
              this.expiryDate = new Date(now + maxAge * 1000);
              this.cachedValue = json;
              return _context.abrupt("return", json);

            case 33:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[7, 14]]);
    }));

    function fetch(_x) {
      return _fetch.apply(this, arguments);
    }

    return fetch;
  }();

  _proto.fetchWithTimeout = /*#__PURE__*/function () {
    var _fetchWithTimeout = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(url, timeout) {
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", Promise.race([fetch(url), new Promise(function (_, reject) {
                return setTimeout(function () {
                  return reject("timeout");
                }, timeout);
              })]));

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    function fetchWithTimeout(_x2, _x3) {
      return _fetchWithTimeout.apply(this, arguments);
    }

    return fetchWithTimeout;
  }();

  _createClass(CachedFetcher, [{
    key: "currentValue",
    get: function get() {
      if (!this.expiryDate) {
        return undefined;
      }

      var now = new Date();

      if (now < this.expiryDate && this.cachedValue) {
        return this.cachedValue;
      }

      return undefined;
    }
  }]);

  return CachedFetcher;
}();

var Service = function Service(chainId, ctx) {
  this.chainId = chainId;
  this.ctx = ctx;
  this.events = new Emittery();
};
var ServiceInterface = /*#__PURE__*/function (_Service) {
  _inheritsLoose(ServiceInterface, _Service);

  function ServiceInterface(yearn, chainId, ctx) {
    var _this;

    _this = _Service.call(this, chainId, ctx) || this;
    _this.yearn = yearn;
    return _this;
  }

  return ServiceInterface;
}(Service);
/**
 * Contract that supports two different providers to differentiate read and
 * write operations.
 */

var WrappedContract = function WrappedContract(address, abi, ctx) {
  var _this2 = this;

  this.address = address;
  this.abi = abi;
  this.read = new Contract(address, abi, ctx.provider.read);
  this.write = new Contract(address, abi, ctx.provider.write);
  ctx.events.on(Context.PROVIDER, function (provider) {
    _this2.read = new Contract(_this2.address, _this2.abi, provider.read);
    _this2.write = new Contract(_this2.address, _this2.abi, provider.write);
  });
};
/**
 * A service that has a contract representation on chain.
 */

var ContractService = /*#__PURE__*/function (_Service2) {
  _inheritsLoose(ContractService, _Service2);

  function ContractService(address, chainId, ctx) {
    var _this3;

    _this3 = _Service2.call(this, chainId, ctx) || this;
    _this3.address = address;
    _this3.contract = new WrappedContract(_this3.address, // @ts-ignore
    _this3.constructor.abi, ctx);
    return _this3;
  }

  return ContractService;
}(Service);
ContractService.abi = [];

var YVBOOST = "0x9d409a0a012cfba9b15f6d4b36ac57a46966ab9a";
var YVECRV = "0xc5bddf9843308380375a611c18b50fb9341f502a";
var PSLPYVBOOSTETH = "0xced67a187b923f0e5ebcc77c7f2f7da20099e378";
var LAB_ADDRESSESS = [YVBOOST, YVECRV, PSLPYVBOOSTETH];
var VAULT_EARNINGS = "query VaultEarnings($vault: ID!) {\n    vault(id: $vault) {\n      token {\n        id\n        decimals\n      }\n      latestUpdate {\n        returnsGenerated\n      }\n    }\n  }\n";
var PROTOCOL_EARNINGS = "query ProtocolEarnings {\n    vaults {\n      token {\n        id\n        decimals\n      }\n      latestUpdate {\n        returnsGenerated\n      }\n    }\n  }\n";
var buildAccountEarningsVariables = function buildAccountEarningsVariables(id) {
  return {
    id: id,
    ignoredVaults: LAB_ADDRESSESS
  };
};
var ACCOUNT_EARNINGS = "\n  query AccountEarnings($id: ID!, $ignoredVaults: [String!]) {\n    account(id: $id) {\n      vaultPositions(where: { vault_not_in: $ignoredVaults } ) {\n        balanceShares\n        token {\n          id\n          decimals\n        }\n        shareToken {\n          symbol\n        }\n        updates {\n          deposits\n          withdrawals\n          tokensReceived\n          tokensSent\n        }\n        vault {\n          id\n          latestUpdate {\n            pricePerShare\n          }\n        }\n      }\n    }\n  }\n";
var ASSET_HISTORIC_EARNINGS = function ASSET_HISTORIC_EARNINGS(blocks) {
  var makeBlockQuery = function makeBlockQuery(block) {
    return "\n    block_" + block + ": vault(id: $id, block: { number: " + block + " } ) {\n      vaultDayData(orderBy: timestamp, orderDirection: desc, first: 1) {\n        timestamp\n      }\n      strategies {\n        latestReport {\n          totalGain\n          totalLoss\n        }\n      }\n    }\n    ";
  };

  var historicQueries = blocks.map(function (block) {
    return makeBlockQuery(block);
  });
  var result = "query AssetHistoricEarnings($id: ID!) {\n    vault(id: $id) {\n      token {\n        id\n        decimals\n      }\n    }\n    " + historicQueries.join("") + "\n  }\n  ";
  return result;
};
var ACCOUNT_HISTORIC_EARNINGS = "query AccountHistoricEarnings($id: ID!, $shareToken: String!, $fromDate: String!, $toDate: BigInt!) {\n  account(id: $id) {\n      vaultPositions(where: { shareToken: $shareToken }) {\n        balanceShares\n        token {\n          id\n          decimals\n        }\n        vault {\n          vaultDayData(where: { timestamp_gte: $fromDate, timestamp_lte: $toDate }, orderBy: timestamp, orderDirection: asc, first: 1000) {\n            pricePerShare\n            timestamp\n          }\n        }\n        updates(orderBy: timestamp, orderDirection: asc, first: 1000) {\n          balanceShares\n          timestamp\n          deposits\n          withdrawals\n          tokensReceived\n          tokensSent\n        }\n      }\n    }\n  }\n";
var PROTOCOL_FEES = "query ProtocolFees($sinceDate: BigInt!) {\n    transfers(where: { timestamp_gt: $sinceDate }, first: 1000) {\n      tokenAmountUsdc\n    }\n  }\n";

var BigZero = /*#__PURE__*/new BigNumber(0);
var EarningsInterface = /*#__PURE__*/function (_ServiceInterface) {
  _inheritsLoose(EarningsInterface, _ServiceInterface);

  function EarningsInterface() {
    var _this;

    _this = _ServiceInterface.apply(this, arguments) || this;
    _this.assetHistoricEarningsCache = new CachedFetcher("vaults/earnings/get", _this.ctx, _this.chainId);
    return _this;
  }
  /**
   * @deprecated
   * Not able to be accurately calculated by the subgraph, this functionality will be removed in a future version
   */


  var _proto = EarningsInterface.prototype;

  _proto.protocolEarnings =
  /*#__PURE__*/
  function () {
    var _protocolEarnings = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      var _response$data;

      var response, result, _iterator, _step, vault, returnsGenerated, earningsUsdc;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.yearn.services.subgraph.fetchQuery(PROTOCOL_EARNINGS);

            case 2:
              response = _context.sent;
              result = BigZero;

              if (!(!(response != null && response.data) || !((_response$data = response.data) != null && _response$data.vaults))) {
                _context.next = 6;
                break;
              }

              return _context.abrupt("return", result.toFixed(0));

            case 6:
              _iterator = _createForOfIteratorHelperLoose(response.data.vaults);

            case 7:
              if ((_step = _iterator()).done) {
                _context.next = 18;
                break;
              }

              vault = _step.value;

              if (vault.latestUpdate) {
                _context.next = 11;
                break;
              }

              return _context.abrupt("continue", 16);

            case 11:
              returnsGenerated = new BigNumber(vault.latestUpdate.returnsGenerated);
              _context.next = 14;
              return this.tokensValueInUsdc(returnsGenerated, vault.token.id, vault.token.decimals);

            case 14:
              earningsUsdc = _context.sent;
              result = result.plus(earningsUsdc);

            case 16:
              _context.next = 7;
              break;

            case 18:
              return _context.abrupt("return", result.toFixed(0));

            case 19:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function protocolEarnings() {
      return _protocolEarnings.apply(this, arguments);
    }

    return protocolEarnings;
  }();

  _proto.assetEarnings = /*#__PURE__*/function () {
    var _assetEarnings = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(assetAddress) {
      var _response$data2, _vault$latestUpdate;

      var response, vault, returnsGenerated, earningsUsdc;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.yearn.services.subgraph.fetchQuery(VAULT_EARNINGS, {
                vault: assetAddress
              });

            case 2:
              response = _context2.sent;

              if (!(!(response != null && response.data) || !((_response$data2 = response.data) != null && _response$data2.vault))) {
                _context2.next = 5;
                break;
              }

              throw new SdkError("No asset with address " + assetAddress);

            case 5:
              vault = response.data.vault;
              returnsGenerated = new BigNumber(((_vault$latestUpdate = vault.latestUpdate) == null ? void 0 : _vault$latestUpdate.returnsGenerated) || 0);
              _context2.next = 9;
              return this.tokensValueInUsdc(returnsGenerated, vault.token.id, vault.token.decimals);

            case 9:
              earningsUsdc = _context2.sent;
              return _context2.abrupt("return", {
                assetAddress: getAddress(assetAddress),
                amount: returnsGenerated.toFixed(0),
                amountUsdc: earningsUsdc.toFixed(0),
                tokenAddress: getAddress(vault.token.id)
              });

            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function assetEarnings(_x) {
      return _assetEarnings.apply(this, arguments);
    }

    return assetEarnings;
  }();

  _proto.accountAssetsData = /*#__PURE__*/function () {
    var _accountAssetsData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(accountAddress) {
      var _response$data3,
          _this2 = this;

      var response, account, assetsData, assetAddresses, apys, totalEarnings, holdings, grossApy, estimatedYearlyYield, earningsAssetData;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.yearn.services.subgraph.fetchQuery(ACCOUNT_EARNINGS, buildAccountEarningsVariables(accountAddress));

            case 2:
              response = _context4.sent;
              account = response == null ? void 0 : (_response$data3 = response.data) == null ? void 0 : _response$data3.account;

              if (account) {
                _context4.next = 6;
                break;
              }

              return _context4.abrupt("return", {
                earnings: "0",
                holdings: "0",
                earningsAssetData: [],
                grossApy: 0,
                estimatedYearlyYield: "0"
              });

            case 6:
              _context4.next = 8;
              return Promise.all(account.vaultPositions.map( /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(assetPosition) {
                  var _assetPosition$vault$;

                  var balanceTokens, _assetPosition$update, deposits, withdrawals, tokensReceived, tokensSent, positiveTokens, negativeTokens, earningsTokens, earningsUsdc, balanceUsdc;

                  return runtime_1.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          balanceTokens = new BigNumber(assetPosition.balanceShares).multipliedBy(new BigNumber(((_assetPosition$vault$ = assetPosition.vault.latestUpdate) == null ? void 0 : _assetPosition$vault$.pricePerShare) || 0)).div(Math.pow(10, assetPosition.token.decimals));
                          _assetPosition$update = assetPosition.updates.reduce(function (_ref2, current) {
                            var deposits = _ref2.deposits,
                                withdrawals = _ref2.withdrawals,
                                tokensReceived = _ref2.tokensReceived,
                                tokensSent = _ref2.tokensSent;
                            return {
                              deposits: deposits.plus(new BigNumber(current.deposits)),
                              withdrawals: withdrawals.plus(new BigNumber(current.withdrawals)),
                              tokensReceived: tokensReceived.plus(new BigNumber(current.tokensReceived)),
                              tokensSent: tokensSent.plus(new BigNumber(current.tokensSent))
                            };
                          }, {
                            deposits: BigZero,
                            withdrawals: BigZero,
                            tokensReceived: BigZero,
                            tokensSent: BigZero
                          }), deposits = _assetPosition$update.deposits, withdrawals = _assetPosition$update.withdrawals, tokensReceived = _assetPosition$update.tokensReceived, tokensSent = _assetPosition$update.tokensSent;
                          positiveTokens = balanceTokens.plus(withdrawals).plus(tokensSent);
                          negativeTokens = deposits.plus(tokensReceived);
                          earningsTokens = positiveTokens.minus(negativeTokens);
                          _context3.next = 7;
                          return _this2.tokensValueInUsdc(earningsTokens, assetPosition.token.id, assetPosition.token.decimals);

                        case 7:
                          earningsUsdc = _context3.sent;
                          _context3.next = 10;
                          return _this2.tokensValueInUsdc(balanceTokens, assetPosition.token.id, assetPosition.token.decimals);

                        case 10:
                          balanceUsdc = _context3.sent;
                          return _context3.abrupt("return", {
                            assetAddress: getAddress(assetPosition.vault.id),
                            balanceUsdc: balanceUsdc,
                            earned: earningsUsdc.toFixed(0)
                          });

                        case 12:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3);
                }));

                return function (_x3) {
                  return _ref.apply(this, arguments);
                };
              }()));

            case 8:
              assetsData = _context4.sent;
              assetAddresses = assetsData.map(function (assetData) {
                return assetData.assetAddress;
              });
              _context4.next = 12;
              return this.yearn.services.vision.apy(assetAddresses);

            case 12:
              apys = _context4.sent;
              totalEarnings = assetsData.map(function (datum) {
                return new BigNumber(datum.earned);
              }).reduce(function (sum, value) {
                return sum.plus(value);
              });
              holdings = assetsData.map(function (datum) {
                return new BigNumber(datum.balanceUsdc);
              }).reduce(function (sum, value) {
                return sum.plus(value);
              });
              grossApy = holdings.isEqualTo(BigZero) ? BigZero : assetsData.map(function (datum) {
                var _apys$datum$assetAddr;

                var apy = ((_apys$datum$assetAddr = apys[datum.assetAddress]) == null ? void 0 : _apys$datum$assetAddr.net_apy) || 0;
                return new BigNumber(apy).times(datum.balanceUsdc).div(holdings);
              }).reduce(function (sum, value) {
                return sum.plus(value);
              });
              estimatedYearlyYield = grossApy.multipliedBy(holdings);
              earningsAssetData = assetsData.map(function (datum) {
                return {
                  assetAddress: datum.assetAddress,
                  earned: datum.earned
                };
              });
              return _context4.abrupt("return", {
                earnings: BigNumber.max(totalEarnings, 0).toFixed(0),
                holdings: BigNumber.max(holdings, 0).toFixed(0),
                grossApy: grossApy.toNumber(),
                estimatedYearlyYield: BigNumber.max(estimatedYearlyYield, 0).toFixed(0),
                earningsAssetData: earningsAssetData
              });

            case 19:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function accountAssetsData(_x2) {
      return _accountAssetsData.apply(this, arguments);
    }

    return accountAssetsData;
  }();

  _proto.assetsHistoricEarnings = /*#__PURE__*/function () {
    var _assetsHistoricEarnings = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(fromDaysAgo) {
      var _this3 = this;

      var cached, assetsStatic, assetAddresses, latestBlockNumber, resolvedPromises, result, _iterator2, _step2, resolvedPromise;

      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (fromDaysAgo === void 0) {
                fromDaysAgo = 30;
              }

              if (!(fromDaysAgo === 30)) {
                _context6.next = 7;
                break;
              }

              _context6.next = 4;
              return this.assetHistoricEarningsCache.fetch();

            case 4:
              cached = _context6.sent;

              if (!cached) {
                _context6.next = 7;
                break;
              }

              return _context6.abrupt("return", cached);

            case 7:
              _context6.next = 9;
              return this.yearn.services.lens.adapters.vaults.v2.assetsStatic();

            case 9:
              assetsStatic = _context6.sent;
              assetAddresses = assetsStatic.map(function (asset) {
                return asset.address;
              });
              _context6.next = 13;
              return this.ctx.provider.read.getBlockNumber();

            case 13:
              latestBlockNumber = _context6.sent;
              _context6.next = 16;
              return Promise.allSettled(assetAddresses.map( /*#__PURE__*/function () {
                var _ref3 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(address) {
                  return runtime_1.wrap(function _callee5$(_context5) {
                    while (1) {
                      switch (_context5.prev = _context5.next) {
                        case 0:
                          return _context5.abrupt("return", _this3.assetHistoricEarnings(address, fromDaysAgo, latestBlockNumber));

                        case 1:
                        case "end":
                          return _context5.stop();
                      }
                    }
                  }, _callee5);
                }));

                return function (_x5) {
                  return _ref3.apply(this, arguments);
                };
              }()));

            case 16:
              resolvedPromises = _context6.sent;
              result = [];

              for (_iterator2 = _createForOfIteratorHelperLoose(resolvedPromises); !(_step2 = _iterator2()).done;) {
                resolvedPromise = _step2.value;

                if (resolvedPromise.status === "fulfilled") {
                  result.push(resolvedPromise.value);
                }
              }

              return _context6.abrupt("return", result);

            case 20:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function assetsHistoricEarnings(_x4) {
      return _assetsHistoricEarnings.apply(this, arguments);
    }

    return assetsHistoricEarnings;
  }();

  _proto.assetHistoricEarnings = /*#__PURE__*/function () {
    var _assetHistoricEarnings = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(vault, fromDaysAgo, latestBlockNumber) {
      var _this4 = this;

      var blockNumber, blocks, response, data, labels, token, priceUsdc, earningsDayData, result;
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (!latestBlockNumber) {
                _context7.next = 4;
                break;
              }

              blockNumber = latestBlockNumber;
              _context7.next = 7;
              break;

            case 4:
              _context7.next = 6;
              return this.ctx.provider.read.getBlockNumber();

            case 6:
              blockNumber = _context7.sent;

            case 7:
              blockNumber -= this.blockOffset(); // subgraph might be slightly behind latest block

              blocks = Array.from(Array(fromDaysAgo).keys()).reverse().map(function (day) {
                return blockNumber - day * _this4.blocksPerDay();
              });
              _context7.next = 11;
              return this.yearn.services.subgraph.fetchQuery(ASSET_HISTORIC_EARNINGS(blocks), {
                id: vault
              });

            case 11:
              response = _context7.sent;
              data = response.data;
              labels = blocks.map(function (block) {
                return "block_" + block;
              });
              token = data.vault.token.id;
              _context7.next = 17;
              return this.yearn.services.oracle.getPriceUsdc(token).then(function (price) {
                return new BigNumber(price);
              });

            case 17:
              priceUsdc = _context7.sent;
              earningsDayData = labels.map(function (label) {
                var strategies = data[label].strategies;
                var totalGain = strategies.map(function (strategy) {
                  return strategy.latestReport ? new BigNumber(strategy.latestReport.totalGain) : new BigNumber(0);
                }).reduce(function (sum, value) {
                  return sum.plus(value);
                });
                var totalLoss = strategies.map(function (strategy) {
                  return strategy.latestReport ? new BigNumber(strategy.latestReport.totalLoss) : new BigNumber(0);
                }).reduce(function (sum, value) {
                  return sum.plus(value);
                });
                var amountEarnt = totalGain.minus(totalLoss);
                var amountUsdc = priceUsdc.multipliedBy(amountEarnt).dividedBy(new BigNumber(10).pow(new BigNumber(data.vault.token.decimals)));
                var dayData = {
                  earnings: {
                    amountUsdc: amountUsdc.toFixed(0),
                    amount: amountEarnt.toFixed(0)
                  },
                  date: new Date(+data[label].vaultDayData[0].timestamp).toJSON()
                };
                return dayData;
              });
              result = {
                assetAddress: vault,
                dayData: earningsDayData,
                decimals: data.vault.token.decimals
              };
              return _context7.abrupt("return", result);

            case 21:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function assetHistoricEarnings(_x6, _x7, _x8) {
      return _assetHistoricEarnings.apply(this, arguments);
    }

    return assetHistoricEarnings;
  }();

  _proto.accountHistoricEarnings = /*#__PURE__*/function () {
    var _accountHistoricEarnings = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(accountAddress, shareTokenAddress, fromDaysAgo, toDaysAgo) {
      var _response$data$accoun;

      var response, vaultPositions, snapshotTimeline, updates, _iterator3, _step3, _step3$value, index, vaultPositionUpdate, _snapshot, previousSnapshot, _snapshot2, lastSnapshot, distantFuture, snapshot, vaultDayData, token, usdcPrice, earningsDayData;

      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              if (!(toDaysAgo && toDaysAgo > fromDaysAgo)) {
                _context9.next = 2;
                break;
              }

              throw new SdkError("fromDaysAgo must be greater than toDaysAgo");

            case 2:
              _context9.next = 4;
              return this.yearn.services.subgraph.fetchQuery(ACCOUNT_HISTORIC_EARNINGS, {
                id: accountAddress,
                shareToken: shareTokenAddress,
                fromDate: this.getDate(fromDaysAgo).getTime().toString(),
                toDate: this.getDate(toDaysAgo || 0).getTime().toString()
              });

            case 4:
              response = _context9.sent;
              vaultPositions = (_response$data$accoun = response.data.account) == null ? void 0 : _response$data$accoun.vaultPositions;

              if (vaultPositions) {
                _context9.next = 8;
                break;
              }

              throw new SdkError("No account with address " + accountAddress);

            case 8:
              snapshotTimeline = [];
              updates = vaultPositions.flatMap(function (vaultPosition) {
                return vaultPosition.updates;
              }).sort(function (lhs, rhs) {
                return +lhs.timestamp - +rhs.timestamp;
              });

              for (_iterator3 = _createForOfIteratorHelperLoose(updates.entries()); !(_step3 = _iterator3()).done;) {
                _step3$value = _step3.value, index = _step3$value[0], vaultPositionUpdate = _step3$value[1];

                if (index === 0) {
                  _snapshot = {
                    startDate: new Date(0),
                    endDate: new Date(+vaultPositionUpdate.timestamp),
                    deposits: new BigNumber(vaultPositionUpdate.deposits),
                    withdrawals: new BigNumber(vaultPositionUpdate.withdrawals),
                    tokensReceived: new BigNumber(vaultPositionUpdate.tokensReceived),
                    tokensSent: new BigNumber(vaultPositionUpdate.tokensSent),
                    balanceShares: new BigNumber(vaultPositionUpdate.balanceShares)
                  };
                  snapshotTimeline.push(_snapshot);
                } else {
                  previousSnapshot = snapshotTimeline[index - 1];
                  _snapshot2 = {
                    startDate: previousSnapshot.endDate,
                    endDate: new Date(+vaultPositionUpdate.timestamp),
                    deposits: previousSnapshot.deposits.plus(new BigNumber(vaultPositionUpdate.deposits)),
                    withdrawals: previousSnapshot.withdrawals.plus(new BigNumber(vaultPositionUpdate.withdrawals)),
                    tokensReceived: previousSnapshot.tokensReceived.plus(new BigNumber(vaultPositionUpdate.tokensReceived)),
                    tokensSent: previousSnapshot.tokensSent.plus(new BigNumber(vaultPositionUpdate.tokensSent)),
                    balanceShares: previousSnapshot.balanceShares.plus(new BigNumber(vaultPositionUpdate.balanceShares))
                  };
                  snapshotTimeline.push(_snapshot2);
                }
              }

              if (snapshotTimeline.length > 0) {
                lastSnapshot = snapshotTimeline[snapshotTimeline.length - 1];
                distantFuture = new Date().setFullYear(3000);
                snapshot = {
                  startDate: lastSnapshot.endDate,
                  endDate: new Date(distantFuture),
                  deposits: lastSnapshot.deposits,
                  withdrawals: lastSnapshot.withdrawals,
                  tokensReceived: lastSnapshot.tokensReceived,
                  tokensSent: lastSnapshot.tokensSent,
                  balanceShares: lastSnapshot.balanceShares
                };
                snapshotTimeline.push(snapshot);
              }

              vaultDayData = vaultPositions[0].vault.vaultDayData;
              token = vaultPositions[0].token;
              _context9.next = 16;
              return this.yearn.services.oracle.getPriceUsdc(token.id).then(function (id) {
                return new BigNumber(id);
              });

            case 16:
              usdcPrice = _context9.sent;
              _context9.next = 19;
              return Promise.all(vaultDayData.map( /*#__PURE__*/function () {
                var _ref4 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(vaultDayDatum) {
                  var date, snapshot, balanceTokens, positives, negatives, earnings, amountUsdc;
                  return runtime_1.wrap(function _callee8$(_context8) {
                    while (1) {
                      switch (_context8.prev = _context8.next) {
                        case 0:
                          date = new Date(+vaultDayDatum.timestamp);
                          snapshot = snapshotTimeline.find(function (snapshot) {
                            return date >= snapshot.startDate && date < snapshot.endDate;
                          });

                          if (!snapshot) {
                            _context8.next = 11;
                            break;
                          }

                          balanceTokens = snapshot.balanceShares.multipliedBy(new BigNumber(vaultDayDatum.pricePerShare)).dividedBy(new BigNumber(Math.pow(10, token.decimals)));
                          positives = balanceTokens.plus(snapshot.withdrawals).plus(snapshot.tokensSent);
                          negatives = snapshot.deposits.plus(snapshot.tokensReceived);
                          earnings = positives.minus(negatives);
                          amountUsdc = usdcPrice.multipliedBy(earnings).dividedBy(new BigNumber(10).pow(token.decimals));
                          return _context8.abrupt("return", {
                            earnings: {
                              amount: earnings.toFixed(0),
                              amountUsdc: amountUsdc.toFixed(0)
                            },
                            date: date.toJSON()
                          });

                        case 11:
                          return _context8.abrupt("return", {
                            earnings: {
                              amount: "0",
                              amountUsdc: "0"
                            },
                            date: date.toJSON()
                          });

                        case 12:
                        case "end":
                          return _context8.stop();
                      }
                    }
                  }, _callee8);
                }));

                return function (_x13) {
                  return _ref4.apply(this, arguments);
                };
              }()));

            case 19:
              earningsDayData = _context9.sent;
              return _context9.abrupt("return", {
                accountAddress: accountAddress,
                shareTokenAddress: shareTokenAddress,
                decimals: token.decimals,
                dayData: earningsDayData
              });

            case 21:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));

    function accountHistoricEarnings(_x9, _x10, _x11, _x12) {
      return _accountHistoricEarnings.apply(this, arguments);
    }

    return accountHistoricEarnings;
  }();

  _proto.tokensValueInUsdc = /*#__PURE__*/function () {
    var _tokensValueInUsdc = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(tokenAmount, tokenAddress, decimals) {
      var tokenUsdcPrice;
      return runtime_1.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              _context10.next = 2;
              return this.yearn.services.oracle.getPriceUsdc(tokenAddress);

            case 2:
              tokenUsdcPrice = _context10.sent;
              return _context10.abrupt("return", new BigNumber(tokenUsdcPrice).multipliedBy(tokenAmount).div(Math.pow(10, decimals)));

            case 4:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));

    function tokensValueInUsdc(_x14, _x15, _x16) {
      return _tokensValueInUsdc.apply(this, arguments);
    }

    return tokensValueInUsdc;
  }();

  _proto.getDate = function getDate(daysAgo) {
    var date = new Date();
    date.setDate(date.getDate() - daysAgo);
    return date;
  };

  _proto.blocksPerDay = function blocksPerDay() {
    switch (this.chainId) {
      case 1:
      case 1337:
      case 42161:
        return 5760;

      case 250:
        return 86400;
    }
  };

  _proto.blockOffset = function blockOffset() {
    switch (this.chainId) {
      case 1:
      case 1337:
      case 42161:
        return 100;

      case 250:
        return 1000;
    }
  };

  return EarningsInterface;
}(ServiceInterface);

var FeesInterface = /*#__PURE__*/function (_ServiceInterface) {
  _inheritsLoose(FeesInterface, _ServiceInterface);

  function FeesInterface() {
    return _ServiceInterface.apply(this, arguments) || this;
  }

  var _proto = FeesInterface.prototype;

  _proto.protocolFees = /*#__PURE__*/function () {
    var _protocolFees = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(since) {
      var response, transfers;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.yearn.services.subgraph.fetchQuery(PROTOCOL_FEES, {
                sinceDate: since.getTime().toString()
              });

            case 2:
              response = _context.sent;
              transfers = response.data.transfers;
              return _context.abrupt("return", transfers.reduce(function (prev, current) {
                return prev.plus(new BigNumber$1(current.tokenAmountUsdc || 0));
              }, new BigNumber$1(0)).toFixed(0));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function protocolFees(_x) {
      return _protocolFees.apply(this, arguments);
    }

    return protocolFees;
  }();

  return FeesInterface;
}(ServiceInterface);

var IronBankInterface = /*#__PURE__*/function (_ServiceInterface) {
  _inheritsLoose(IronBankInterface, _ServiceInterface);

  function IronBankInterface() {
    var _this;

    _this = _ServiceInterface.apply(this, arguments) || this;
    _this.cachedFetcherGet = new CachedFetcher("ironbank/get", _this.ctx, _this.chainId);
    _this.cachedFetcherGetDynamic = new CachedFetcher("ironbank/getDynamic", _this.ctx, _this.chainId);
    _this.cachedFetcherTokens = new CachedFetcher("ironbank/tokens", _this.ctx, _this.chainId);
    return _this;
  }
  /**
   * Get all IronBank markets.
   * @param addresses filter, if not provided all positions are returned
   * @param overrides
   * @returns
   */


  var _proto = IronBankInterface.prototype;

  _proto.get =
  /*#__PURE__*/
  function () {
    var _get = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(addresses, overrides) {
      var cached, assetsStatic, assetsDynamic, assets, _loop, _iterator, _step;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.cachedFetcherGet.fetch();

            case 2:
              cached = _context.sent;

              if (!cached) {
                _context.next = 9;
                break;
              }

              if (!addresses) {
                _context.next = 8;
                break;
              }

              return _context.abrupt("return", cached.filter(function (market) {
                return addresses.includes(market.address);
              }));

            case 8:
              return _context.abrupt("return", cached);

            case 9:
              _context.next = 11;
              return this.yearn.services.lens.adapters.ironBank.assetsStatic(addresses, overrides);

            case 11:
              assetsStatic = _context.sent;
              _context.next = 14;
              return this.yearn.services.lens.adapters.ironBank.assetsDynamic(addresses, overrides);

            case 14:
              assetsDynamic = _context.sent;
              assets = new Array();

              _loop = function _loop() {
                var asset = _step.value;
                var dynamic = assetsDynamic.find(function (_ref) {
                  var address = _ref.address;
                  return asset.address === address;
                });

                if (!dynamic) {
                  throw new SdkError("Dynamic asset does not exist for " + asset.address);
                }

                assets.push(_extends({}, asset, dynamic));
              };

              for (_iterator = _createForOfIteratorHelperLoose(assetsStatic); !(_step = _iterator()).done;) {
                _loop();
              }

              return _context.abrupt("return", assets);

            case 19:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function get(_x, _x2) {
      return _get.apply(this, arguments);
    }

    return get;
  }()
  /**
   * Get static part of IronBank markets.
   * @param addresses filter, if not provided all positions are returned
   * @param overrides
   * @returns
   */
  ;

  _proto.getStatic =
  /*#__PURE__*/
  function () {
    var _getStatic = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(addresses, overrides) {
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.yearn.services.lens.adapters.ironBank.assetsStatic(addresses, overrides);

            case 2:
              return _context2.abrupt("return", _context2.sent);

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function getStatic(_x3, _x4) {
      return _getStatic.apply(this, arguments);
    }

    return getStatic;
  }()
  /**
   * Get dynamic part of IronBank markets.
   * @param addresses filter, if not provided all positions are returned
   * @param overrides
   * @returns
   */
  ;

  _proto.getDynamic =
  /*#__PURE__*/
  function () {
    var _getDynamic = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(addresses, overrides) {
      var cached;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.cachedFetcherGetDynamic.fetch();

            case 2:
              cached = _context3.sent;

              if (!cached) {
                _context3.next = 9;
                break;
              }

              if (!addresses) {
                _context3.next = 8;
                break;
              }

              return _context3.abrupt("return", cached.filter(function (market) {
                return addresses.includes(market.address);
              }));

            case 8:
              return _context3.abrupt("return", cached);

            case 9:
              _context3.next = 11;
              return this.yearn.services.lens.adapters.ironBank.assetsDynamic(addresses, overrides);

            case 11:
              return _context3.abrupt("return", _context3.sent);

            case 12:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function getDynamic(_x5, _x6) {
      return _getDynamic.apply(this, arguments);
    }

    return getDynamic;
  }()
  /**
   * Get IronBank market positions for a particular address.
   * @param address
   * @param addresses filter, if not provided all positions are returned
   * @param overrides
   * @returns
   */
  ;

  _proto.positionsOf =
  /*#__PURE__*/
  function () {
    var _positionsOf = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(address, addresses, overrides) {
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", this.yearn.services.lens.adapters.ironBank.positionsOf(address, addresses, overrides));

            case 1:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function positionsOf(_x7, _x8, _x9) {
      return _positionsOf.apply(this, arguments);
    }

    return positionsOf;
  }()
  /**
   * Get the IronBank User Summary for a particular address.
   * @param address
   * @param overrides
   * @returns
   */
  ;

  _proto.summaryOf =
  /*#__PURE__*/
  function () {
    var _summaryOf = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(address, overrides) {
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", this.yearn.services.lens.adapters.ironBank.generalPositionOf(address, overrides));

            case 1:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function summaryOf(_x10, _x11) {
      return _summaryOf.apply(this, arguments);
    }

    return summaryOf;
  }()
  /**
   * Get the IronBank User Metadata for a particular address.
   * @param address
   * @param addresses
   * @param overrides
   * @returns
   */
  ;

  _proto.metadataOf =
  /*#__PURE__*/
  function () {
    var _metadataOf = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(address, addresses, overrides) {
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              return _context6.abrupt("return", this.yearn.services.lens.adapters.ironBank.assetsUserMetadata(address, addresses, overrides));

            case 1:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function metadataOf(_x12, _x13, _x14) {
      return _metadataOf.apply(this, arguments);
    }

    return metadataOf;
  }()
  /**
   * Get all IronBank market's underlying token balances for a particular
   * address.
   * @param address
   * @param overrides
   * @returns
   */
  ;

  _proto.balances =
  /*#__PURE__*/
  function () {
    var _balances = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(address, overrides) {
      var tokens, balances;
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return this.tokens();

            case 2:
              tokens = _context7.sent;
              _context7.next = 5;
              return this.yearn.services.helper.tokenBalances(address, tokens.map(function (token) {
                return token.address;
              }), overrides);

            case 5:
              balances = _context7.sent;
              return _context7.abrupt("return", balances.map(function (balance) {
                var token = tokens.find(function (token) {
                  return token.address === balance.address;
                });

                if (!token) {
                  throw new SdkError("Token does not exist for Balance(" + balance.address + ")");
                }

                return _extends({}, balance, {
                  token: token
                });
              }));

            case 7:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function balances(_x15, _x16) {
      return _balances.apply(this, arguments);
    }

    return balances;
  }()
  /**
   * Get all IronBank market's underlying tokens.
   * @param overrides
   * @returns
   */
  ;

  _proto.tokens =
  /*#__PURE__*/
  function () {
    var _tokens = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(overrides) {
      var _this2 = this;

      var cached, tokenAddresses, tokens, icons;
      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              _context9.next = 2;
              return this.cachedFetcherTokens.fetch();

            case 2:
              cached = _context9.sent;

              if (!cached) {
                _context9.next = 5;
                break;
              }

              return _context9.abrupt("return", cached);

            case 5:
              _context9.next = 7;
              return this.yearn.services.lens.adapters.ironBank.tokens(overrides);

            case 7:
              tokenAddresses = _context9.sent;
              _context9.next = 10;
              return this.yearn.services.helper.tokens(tokenAddresses, overrides);

            case 10:
              tokens = _context9.sent;
              icons = this.yearn.services.asset.icon(tokenAddresses);
              return _context9.abrupt("return", Promise.all(tokens.map( /*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(token) {
                  return runtime_1.wrap(function _callee8$(_context8) {
                    while (1) {
                      switch (_context8.prev = _context8.next) {
                        case 0:
                          _context8.t0 = _extends;
                          _context8.t1 = {};
                          _context8.t2 = token;
                          _context8.t3 = icons[token.address];
                          _context8.t4 = {};
                          _context8.next = 7;
                          return _this2.yearn.services.oracle.getPriceUsdc(token.address, overrides);

                        case 7:
                          _context8.t5 = _context8.sent;
                          _context8.t6 = {
                            icon: _context8.t3,
                            supported: _context8.t4,
                            priceUsdc: _context8.t5
                          };
                          return _context8.abrupt("return", (0, _context8.t0)(_context8.t1, _context8.t2, _context8.t6));

                        case 10:
                        case "end":
                          return _context8.stop();
                      }
                    }
                  }, _callee8);
                }));

                return function (_x18) {
                  return _ref2.apply(this, arguments);
                };
              }())));

            case 13:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));

    function tokens(_x17) {
      return _tokens.apply(this, arguments);
    }

    return tokens;
  }();

  return IronBankInterface;
}(ServiceInterface);

var ZeroAddress = "0x0000000000000000000000000000000000000000";
var EthAddress = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
var WethAddress = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"; // handle a non-200 `fetch` response.

function handleHttpError(_x) {
  return _handleHttpError.apply(this, arguments);
} // formally convert USD values to USDC values (* 1e6), using Usdc type alias.

function _handleHttpError() {
  _handleHttpError = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(response) {
    var url, status, statusText;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(response.status !== 200)) {
              _context.next = 3;
              break;
            }

            url = response.url, status = response.status, statusText = response.statusText;
            throw new SdkError("HTTP to " + url + " request failed (status " + status + " " + statusText + ")");

          case 3:
            return _context.abrupt("return", response);

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _handleHttpError.apply(this, arguments);
}

function usdc(usd) {
  return BigNumber$2.from(Math.floor(Number(usd) * 1e6)).toString();
} // formally convert BigNumber to Integer type alias.

function _int(value) {
  return value.toString();
}
function chunkArray(array, size) {
  if (size < 1) {
    throw new Error("Size needs to be positive: " + size);
  }

  var result = [];

  for (var i = 0; i < array.length; i += size) {
    var chunk = array.slice(i, i + size);
    result.push(chunk);
  }

  return result;
}

var HourInMilliseconds = 1000 * 60 * 60;
var PickleApiUrl = "https://api.pickle.finance/prod/protocol/pools";
var PickleApiBackupUrl = "https://f8wgg18t1h.execute-api.us-west-1.amazonaws.com/prod/protocol/pools";
var PickleJars = ["0xCeD67a187b923F0E5ebcc77C7f2F7da20099e378" // yvboost-eth
];
var PickleService = /*#__PURE__*/function (_Service) {
  _inheritsLoose(PickleService, _Service);

  function PickleService() {
    var _this;

    _this = _Service.apply(this, arguments) || this;
    _this.pickleJarUSDPrices = new Map();
    _this.lastFetchedDate = new Date(0);
    return _this;
  }
  /**
   * Fetches the USD price of a pickle jar token
   * @param jar the address of the jar to fetch
   * @returns the price of the jar token in USD
   */


  var _proto = PickleService.prototype;

  _proto.getPriceUsdc =
  /*#__PURE__*/
  function () {
    var _getPriceUsdc = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(jar) {
      var _this$pickleJarUSDPri;

      var oneHourAgo;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              oneHourAgo = new Date(Date.now() - HourInMilliseconds);

              if (!(this.lastFetchedDate < oneHourAgo)) {
                _context.next = 4;
                break;
              }

              _context.next = 4;
              return this.fetchPickleJarPrices();

            case 4:
              return _context.abrupt("return", usdc((_this$pickleJarUSDPri = this.pickleJarUSDPrices.get(jar)) == null ? void 0 : _this$pickleJarUSDPri.toFixed(0)) || "0");

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function getPriceUsdc(_x) {
      return _getPriceUsdc.apply(this, arguments);
    }

    return getPriceUsdc;
  }();

  _proto.fetchPickleJarPrices = /*#__PURE__*/function () {
    var _fetchPickleJarPrices = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
      var jarData, relevantJars, _iterator, _step, jarDatum, usdPrice;

      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return fetch(PickleApiUrl)["catch"](function () {
                return fetch(PickleApiBackupUrl);
              }).then(function (res) {
                return res.json();
              });

            case 2:
              jarData = _context2.sent;
              this.pickleJarUSDPrices.clear();
              this.lastFetchedDate = new Date();
              relevantJars = jarData.filter(function (jar) {
                return PickleJars.includes(getAddress(jar.jarAddress));
              });

              for (_iterator = _createForOfIteratorHelperLoose(relevantJars); !(_step = _iterator()).done;) {
                jarDatum = _step.value;
                usdPrice = new BigNumber(jarDatum.liquidity_locked / jarDatum.tokens);
                this.pickleJarUSDPrices.set(getAddress(jarDatum.jarAddress), usdPrice);
              }

            case 7:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function fetchPickleJarPrices() {
      return _fetchPickleJarPrices.apply(this, arguments);
    }

    return fetchPickleJarPrices;
  }();

  return PickleService;
}(Service);

var baseUrl = "https://simulate.yearn.network";
var latestBlockKey = -1;
/**
 * [[SimulationExecutor]] performs simulation requests and returns the response
 * with no data manipulation. If the simulation results in an error then an alert is sent
 * via telegram if the appropriate environment variables are set. Forks are necessary to be
 * created if two subsequent simulations are needed e.g. if a zap in is wished to be simulated
 * but the user has not approved the zap contract then the steps to simulate it are:
 * 1. Create a fork
 * 2. Simulate the approval transaction using this fork
 * 3. Simulate the zap in using the approval transaction as the root
 */

var SimulationExecutor = /*#__PURE__*/function () {
  function SimulationExecutor(telegram, ctx) {
    this.telegram = telegram;
    this.ctx = ctx;
  }
  /**
   * Simulate a transaction
   * @param from
   * @param to
   * @param input the encoded input data as per the ethereum abi specification
   * @param value the ether value of the transaction
   * @param options simulation options
   * @returns data about the simulated transaction
   */


  var _proto = SimulationExecutor.prototype;

  _proto.simulateRaw =
  /*#__PURE__*/
  function () {
    var _simulateRaw = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(from, to, input, options, value) {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (options === void 0) {
                options = {};
              }

              if (value === void 0) {
                value = "0";
              }

              _context.next = 4;
              return this.makeSimulationRequest(from, to, input, options, value);

            case 4:
              return _context.abrupt("return", _context.sent);

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function simulateRaw(_x, _x2, _x3, _x4, _x5) {
      return _simulateRaw.apply(this, arguments);
    }

    return simulateRaw;
  }()
  /**
   * Simulates an interaction with a vault to see how much of the desired token
   * will be received. This happens by inspecting the logs of the transaction and
   * finding the Transfer event where the desired token is transferred to the user.
   * @param from
   * @param to
   * @param data
   * @param targetToken the token being bought by this transaction
   * @param from the address initiating this transaction
   * @param options
   * @param value
   * @returns the amount of tokens simulated to be bought
   */
  ;

  _proto.simulateVaultInteraction =
  /*#__PURE__*/
  function () {
    var _simulateVaultInteraction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(from, to, data, targetToken, options, value) {
      var response, getAddressFromTopic, encodedTransferFunction, log, tokensReceived;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (value === void 0) {
                value = "0";
              }

              _context2.next = 3;
              return this.makeSimulationRequest(from, to, data, options, value);

            case 3:
              response = _context2.sent;

              getAddressFromTopic = function getAddressFromTopic(topic) {
                return getAddress(topic.slice(-40)); // the last 20 bytes of the topic is the address
              };

              encodedTransferFunction = "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"; // keccak256("Transfer(address,address,uint256)")

              log = response.transaction.transaction_info.logs.reverse().find(function (log) {
                return log.raw.topics[0] === encodedTransferFunction && getAddressFromTopic(log.raw.topics[2]) === getAddress(from);
              });

              if (log) {
                _context2.next = 9;
                break;
              }

              throw new SimulationError("No log of transferring token " + targetToken + " to " + from, SimulationError.NO_LOG);

            case 9:
              tokensReceived = new BigNumber$1(log.raw.data).toFixed(0);
              return _context2.abrupt("return", tokensReceived);

            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function simulateVaultInteraction(_x6, _x7, _x8, _x9, _x10, _x11) {
      return _simulateVaultInteraction.apply(this, arguments);
    }

    return simulateVaultInteraction;
  }()
  /**
   * Performs a simulation with preset parameters
   * @param from
   * @param to
   * @param data
   * @param options
   * @param value
   * @returns the resulting data from the transaction
   */
  ;

  _proto.makeSimulationRequest =
  /*#__PURE__*/
  function () {
    var _makeSimulationRequest = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(from, to, data, options, value) {
      var _transactionRequest$c, _transactionRequest$v, _transactionRequest$g, _transactionRequest$g2;

      var constructedPath, transactionRequest, body, simulationResponse, errorMessage, _allCalls$find, allCalls, partialRevertError, _errorMessage;

      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (value === void 0) {
                value = "0";
              }

              constructedPath = options != null && options.forkId ? baseUrl + "/fork/" + options.forkId + "/simulate" : baseUrl + "/simulate";
              _context3.next = 4;
              return this.getPopulatedTransactionRequest(from, to, data, options, value);

            case 4:
              transactionRequest = _context3.sent;
              body = {
                from: from,
                to: to,
                input: data,
                network_id: ((_transactionRequest$c = transactionRequest.chainId) == null ? void 0 : _transactionRequest$c.toString()) || "1",
                block_number: latestBlockKey,
                simulation_type: "quick",
                root: options == null ? void 0 : options.root,
                value: ((_transactionRequest$v = transactionRequest.value) == null ? void 0 : _transactionRequest$v.toString()) || "0",
                gas: parseInt(((_transactionRequest$g = transactionRequest.gasLimit) == null ? void 0 : _transactionRequest$g.toString()) || "0"),
                gas_price: ((_transactionRequest$g2 = transactionRequest.gasPrice) == null ? void 0 : _transactionRequest$g2.toString()) || 0,
                save: options.save || true,
                nonce: transactionRequest.nonce
              };
              _context3.next = 8;
              return fetch(constructedPath, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json"
                },
                body: JSON.stringify(body)
              }).then(function (res) {
                return res.json();
              })["catch"](function () {
                throw new TenderlyError("simulation call to Tenderly failed", TenderlyError.SIMULATION_CALL);
              });

            case 8:
              simulationResponse = _context3.sent;
              errorMessage = simulationResponse.transaction.error_message;

              if (!errorMessage) {
                _context3.next = 15;
                break;
              }

              if (options.save) {
                this.sendErrorMessage(errorMessage, simulationResponse.simulation.id, options.forkId);
              }

              throw new SimulationError(errorMessage, SimulationError.TENDERLY_RESPONSE_ERROR);

            case 15:
              // even though the transaction has been successful one of it's calls could have failed i.e. a partial revert might have happened
              allCalls = this.getAllSimulationCalls(simulationResponse.transaction.transaction_info.call_trace);
              partialRevertError = (_allCalls$find = allCalls.find(function (call) {
                return call.error;
              })) == null ? void 0 : _allCalls$find.error;

              if (!partialRevertError) {
                _context3.next = 21;
                break;
              }

              _errorMessage = "Partial Revert - " + partialRevertError;
              this.sendErrorMessage(_errorMessage, simulationResponse.simulation.id, options == null ? void 0 : options.forkId);
              throw new SimulationError(_errorMessage, SimulationError.PARTIAL_REVERT);

            case 21:
              return _context3.abrupt("return", simulationResponse);

            case 22:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function makeSimulationRequest(_x12, _x13, _x14, _x15, _x16) {
      return _makeSimulationRequest.apply(this, arguments);
    }

    return makeSimulationRequest;
  }()
  /**
   * Simulates a transaction, with the `save` parameter initially set to `false`. If this simulation fails then
   * the simulation is re-executed but with `save` set to `true` so the failure can be stored and later analyzed.
   * @param simulate the function which executes the simulation, passing in `save` as an argument.
   * @param forkIdToDeleteOnSuccess if the simulation is successful there is no reason to save it. Delete the fork to avoid clutter
   * @returns the result of the simulate parameter
   */
  ;

  _proto.executeSimulationWithReSimulationOnFailure =
  /*#__PURE__*/
  function () {
    var _executeSimulationWithReSimulationOnFailure = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(simulate, forkIdToDeleteOnSuccess) {
      var _this = this;

      var result;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (forkIdToDeleteOnSuccess === void 0) {
                forkIdToDeleteOnSuccess = null;
              }

              _context4.prev = 1;
              _context4.next = 4;
              return simulate(false).then(function (res) {
                // if the transaction used a fork and was successful then delete it
                if (forkIdToDeleteOnSuccess) {
                  _this.deleteFork(forkIdToDeleteOnSuccess);
                }

                return res;
              });

            case 4:
              result = _context4.sent;
              return _context4.abrupt("return", result);

            case 8:
              _context4.prev = 8;
              _context4.t0 = _context4["catch"](1);

              // re-simulate the transaction with `save` set to true so the failure can be analyzed later
              try {
                simulate(true);
              } catch (_unused) {}

              throw _context4.t0;

            case 12:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, null, [[1, 8]]);
    }));

    function executeSimulationWithReSimulationOnFailure(_x17, _x18) {
      return _executeSimulationWithReSimulationOnFailure.apply(this, arguments);
    }

    return executeSimulationWithReSimulationOnFailure;
  }()
  /**
   * Recursively loops through the simulation call trace, aggregating all calls into a flattened array.
   * @param callTrace the starting call trace to inspect
   * @returns a flattened array of call data
   */
  ;

  _proto.getAllSimulationCalls = function getAllSimulationCalls(callTrace) {
    var result = [];
    result = result.concat(callTrace.calls || []);

    for (var _iterator = _createForOfIteratorHelperLoose(callTrace.calls || []), _step; !(_step = _iterator()).done;) {
      var calls = _step.value;
      var res = this.getAllSimulationCalls(calls);
      result = result.concat(res);
    }

    return result;
  }
  /**
   * Creates a transaction object and populates it to fill in parameters such as gas price,
   * gas limit and nonce for a more accurate simulations
   * @param from
   * @param to
   * @param data
   * @param value
   * @param options
   * @returns A populated TransactionRequest object
   */
  ;

  _proto.getPopulatedTransactionRequest =
  /*#__PURE__*/
  function () {
    var _getPopulatedTransactionRequest = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(from, to, data, options, value) {
      var signer, provider, transactionRequest, result;
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (value === void 0) {
                value = "0";
              }

              if (options != null && options.forkId) {
                provider = new JsonRpcProvider("https://rpc.tenderly.co/fork/" + options.forkId);
                signer = provider.getSigner(from);
              } else {
                signer = this.ctx.provider.write.getSigner(from);
              }

              if (options.maxFeePerGas && options.maxPriorityFeePerGas) {
                delete options.gasPrice;
              }

              transactionRequest = {
                from: from,
                to: to,
                data: data,
                value: value,
                gasLimit: options.gasLimit,
                gasPrice: options.gasPrice,
                maxFeePerGas: options.maxFeePerGas,
                maxPriorityFeePerGas: options.maxPriorityFeePerGas,
                type: options.gasPrice ? 0 : undefined
              };
              _context5.next = 6;
              return signer.populateTransaction(transactionRequest)["catch"](function () {
                throw new EthersError("error populating transaction", EthersError.POPULATING_TRANSACTION);
              });

            case 6:
              result = _context5.sent;
              return _context5.abrupt("return", result);

            case 8:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function getPopulatedTransactionRequest(_x19, _x20, _x21, _x22, _x23) {
      return _getPopulatedTransactionRequest.apply(this, arguments);
    }

    return getPopulatedTransactionRequest;
  }()
  /**
   * Create a new fork that can be used to simulate multiple sequential transactions on
   * e.g. approval followed by a deposit.
   * @returns the uuid of a new fork that has been created
   */
  ;

  _proto.createFork =
  /*#__PURE__*/
  function () {
    var _createFork = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6() {
      var body, response;
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              body = {
                alias: "",
                description: "",
                network_id: "1"
              };
              _context6.next = 3;
              return fetch(baseUrl + "/fork", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json"
                },
                body: JSON.stringify(body)
              }).then(function (res) {
                return res.json();
              })["catch"](function () {
                throw new TenderlyError("failed to create fork", TenderlyError.CREATE_FORK);
              });

            case 3:
              response = _context6.sent;
              return _context6.abrupt("return", response.simulation_fork.id);

            case 5:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));

    function createFork() {
      return _createFork.apply(this, arguments);
    }

    return createFork;
  }()
  /**
   * Deletes a fork. This should be done after its successful use in order to avoid clutter.
   * @param forkId the fork to be deleted
   * @returns the deletion response
   */
  ;

  _proto.deleteFork =
  /*#__PURE__*/
  function () {
    var _deleteFork = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(forkId) {
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return fetch(baseUrl + "/fork/" + forkId, {
                method: "DELETE"
              });

            case 2:
              return _context7.abrupt("return", _context7.sent);

            case 3:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));

    function deleteFork(_x24) {
      return _deleteFork.apply(this, arguments);
    }

    return deleteFork;
  }()
  /**
   * Sends a message to a telegram channel reporting a simulation error
   * @param errorMessage the error to be reported
   * @param simulationId the id of the simulation so the simulation failure can be inspected in the dashboard
   * @param forkId the optional id of the fork so the simulation failure can be inspected in the dashboard
   */
  ;

  _proto.sendErrorMessage = function sendErrorMessage(errorMessage, simulationId, forkId) {
    var transactionUrl;

    if (this.ctx.simulation.dashboardUrl) {
      transactionUrl = this.ctx.simulation.dashboardUrl + "/" + (forkId ? "fork/" + forkId + "/simulation" : "simulator") + "/" + simulationId;
    }

    var message = ["Simulation error", errorMessage, transactionUrl].map(function (item) {
      return item;
    }).join("\n\n");
    this.telegram.sendMessage(message);
  };

  return SimulationExecutor;
}();

var VaultContract = /*#__PURE__*/function () {
  function VaultContract(contract) {
    var _this = this;

    this.contract = contract;

    this.encodeDeposit = function (amount) {
      return _this.contract["interface"].encodeFunctionData("deposit", [amount]);
    };

    this.encodeWithdraw = function (amount) {
      return _this.contract["interface"].encodeFunctionData("withdraw", [amount]);
    };
  }

  var _proto = VaultContract.prototype;

  _proto.decimals = /*#__PURE__*/function () {
    var _decimals = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      var decimals;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.contract.decimals();

            case 2:
              decimals = _context.sent;
              return _context.abrupt("return", new BigNumber(decimals.toString()));

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function decimals() {
      return _decimals.apply(this, arguments);
    }

    return decimals;
  }();

  _proto.token = /*#__PURE__*/function () {
    var _token = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.contract.token();

            case 2:
              return _context2.abrupt("return", _context2.sent);

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function token() {
      return _token.apply(this, arguments);
    }

    return token;
  }();

  _createClass(VaultContract, null, [{
    key: "abi",
    get: function get() {
      return ["function token() view returns (address)", "function decimals() view returns (uint256)", "function deposit(uint256 amount) public", "function withdraw(uint256 amount) public"];
    }
  }]);

  return VaultContract;
}();
var PickleJarContract = /*#__PURE__*/function (_VaultContract) {
  _inheritsLoose(PickleJarContract, _VaultContract);

  function PickleJarContract(jarAddress, signer) {
    return _VaultContract.call(this, new Contract(jarAddress, [].concat(VaultContract.abi, PickleJarContract.pickleJarAbi), signer)) || this;
  }

  var _proto2 = PickleJarContract.prototype;

  _proto2.pricePerShare = /*#__PURE__*/function () {
    var _pricePerShare = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3() {
      var ratio;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.contract.getRatio();

            case 2:
              ratio = _context3.sent;
              return _context3.abrupt("return", new BigNumber(ratio.toString()));

            case 4:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function pricePerShare() {
      return _pricePerShare.apply(this, arguments);
    }

    return pricePerShare;
  }();

  _createClass(PickleJarContract, null, [{
    key: "pickleJarAbi",
    get: function get() {
      return ["function getRatio() public view returns (uint256)"];
    }
  }]);

  return PickleJarContract;
}(VaultContract);
var YearnVaultContract = /*#__PURE__*/function (_VaultContract2) {
  _inheritsLoose(YearnVaultContract, _VaultContract2);

  function YearnVaultContract(jarAddress, signer) {
    return _VaultContract2.call(this, new Contract(jarAddress, [].concat(VaultContract.abi, YearnVaultContract.yearnVaultAbi), signer)) || this;
  }

  var _proto3 = YearnVaultContract.prototype;

  _proto3.pricePerShare = /*#__PURE__*/function () {
    var _pricePerShare2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4() {
      var pricePerShare;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.contract.pricePerShare();

            case 2:
              pricePerShare = _context4.sent;
              return _context4.abrupt("return", new BigNumber(pricePerShare.toString()));

            case 4:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function pricePerShare() {
      return _pricePerShare2.apply(this, arguments);
    }

    return pricePerShare;
  }();

  _createClass(YearnVaultContract, null, [{
    key: "yearnVaultAbi",
    get: function get() {
      return ["function pricePerShare() view returns (uint256)"];
    }
  }]);

  return YearnVaultContract;
}(VaultContract);

/**
 * [[SimulationInterface]] allows the simulation of ethereum transactions using Tenderly's api.
 * This allows us to know information before executing a transaction on mainnet.
 * For example it can simulate how much slippage is likely to be experienced when withdrawing from a vault,
 * or how many underlying tokens the user will receive upon withdrawing share tokens.
 */

var SimulationInterface = /*#__PURE__*/function (_ServiceInterface) {
  _inheritsLoose(SimulationInterface, _ServiceInterface);

  function SimulationInterface() {
    var _this;

    _this = _ServiceInterface.apply(this, arguments) || this;
    _this.simulationExecutor = new SimulationExecutor(_this.yearn.services.telegram, _this.ctx);
    return _this;
  }

  var _proto = SimulationInterface.prototype;

  _proto.deposit = /*#__PURE__*/function () {
    var _deposit = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(from, sellToken, amount, toVault, options) {
      var _this2 = this;

      var signer, zapProtocol, vaultContract, underlyingToken, isZapping, forkId, simulateDeposit, needsApproving, approvalTransactionId, _needsApproving, _approvalTransactionId;

      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (options === void 0) {
                options = {};
              }

              signer = this.ctx.provider.write.getSigner(from);
              zapProtocol = PickleJars.includes(toVault) ? ZapProtocol.PICKLE : ZapProtocol.YEARN;
              vaultContract = zapProtocol === ZapProtocol.PICKLE ? new PickleJarContract(toVault, signer) : new YearnVaultContract(toVault, signer);
              _context2.next = 6;
              return vaultContract.token()["catch"](function () {
                throw new EthersError("failed to fetch token", EthersError.FAIL_TOKEN_FETCH);
              });

            case 6:
              underlyingToken = _context2.sent;
              isZapping = underlyingToken !== sellToken;

              if (!isZapping) {
                _context2.next = 39;
                break;
              }

              if (options.slippage) {
                _context2.next = 11;
                break;
              }

              throw new SdkError("slippage needs to be specified for a zap", SdkError.NO_SLIPPAGE);

            case 11:
              if (!(sellToken === EthAddress)) {
                _context2.next = 15;
                break;
              }

              needsApproving = false;
              _context2.next = 18;
              break;

            case 15:
              _context2.next = 17;
              return this.yearn.services.zapper.zapInApprovalState(from, sellToken, zapProtocol).then(function (state) {
                return !state.isApproved;
              })["catch"](function () {
                throw new ZapperError("approval state", ZapperError.ZAP_IN_APPROVAL_STATE);
              });

            case 17:
              needsApproving = _context2.sent;

            case 18:
              if (!needsApproving) {
                _context2.next = 24;
                break;
              }

              _context2.next = 21;
              return this.simulationExecutor.createFork();

            case 21:
              _context2.t0 = _context2.sent;
              _context2.next = 25;
              break;

            case 24:
              _context2.t0 = undefined;

            case 25:
              forkId = _context2.t0;
              options.forkId = forkId;

              if (!needsApproving) {
                _context2.next = 33;
                break;
              }

              _context2.next = 30;
              return this.yearn.services.zapper.zapInApprovalTransaction(from, sellToken, "0", zapProtocol)["catch"](function () {
                throw new ZapperError("approval", ZapperError.ZAP_IN_APPROVAL);
              }).then( /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(approvalTransaction) {
                  return runtime_1.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _context.next = 2;
                          return _this2.simulateZapApprovalTransaction(approvalTransaction, options);

                        case 2:
                          return _context.abrupt("return", _context.sent);

                        case 3:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                }));

                return function (_x6) {
                  return _ref.apply(this, arguments);
                };
              }()).then(function (res) {
                return res.simulation.id;
              });

            case 30:
              _context2.t1 = _context2.sent;
              _context2.next = 34;
              break;

            case 33:
              _context2.t1 = undefined;

            case 34:
              approvalTransactionId = _context2.t1;
              options.root = approvalTransactionId;

              simulateDeposit = function simulateDeposit(save) {
                options.save = save;
                return _this2.zapIn(from, sellToken, underlyingToken, amount, toVault, vaultContract, zapProtocol, needsApproving, options);
              };

              _context2.next = 61;
              break;

            case 39:
              _context2.next = 41;
              return this.depositNeedsApproving(from, sellToken, toVault, amount, signer);

            case 41:
              _needsApproving = _context2.sent;

              if (!_needsApproving) {
                _context2.next = 48;
                break;
              }

              _context2.next = 45;
              return this.simulationExecutor.createFork();

            case 45:
              _context2.t2 = _context2.sent;
              _context2.next = 49;
              break;

            case 48:
              _context2.t2 = undefined;

            case 49:
              forkId = _context2.t2;
              options.forkId = forkId;

              if (!_needsApproving) {
                _context2.next = 57;
                break;
              }

              _context2.next = 54;
              return this.approve(from, sellToken, amount, toVault, options);

            case 54:
              _context2.t3 = _context2.sent;
              _context2.next = 58;
              break;

            case 57:
              _context2.t3 = undefined;

            case 58:
              _approvalTransactionId = _context2.t3;
              options.root = _approvalTransactionId;

              simulateDeposit = function simulateDeposit(save) {
                options.save = save;
                return _this2.directDeposit(from, sellToken, amount, toVault, vaultContract, options);
              };

            case 61:
              return _context2.abrupt("return", this.simulationExecutor.executeSimulationWithReSimulationOnFailure(simulateDeposit, forkId));

            case 62:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function deposit(_x, _x2, _x3, _x4, _x5) {
      return _deposit.apply(this, arguments);
    }

    return deposit;
  }();

  _proto.withdraw = /*#__PURE__*/function () {
    var _withdraw = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(from, fromVault, amount, toToken, options) {
      var _this3 = this;

      var signer, vaultContract, underlyingToken, isZapping, forkId, simulateWithdrawal, needsApproving, approvalSimulationId;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (options === void 0) {
                options = {};
              }

              signer = this.ctx.provider.write.getSigner(from);
              vaultContract = new YearnVaultContract(fromVault, signer);
              _context4.next = 5;
              return vaultContract.token();

            case 5:
              underlyingToken = _context4.sent;
              isZapping = underlyingToken !== getAddress(toToken);

              if (!isZapping) {
                _context4.next = 38;
                break;
              }

              if (options.slippage) {
                _context4.next = 10;
                break;
              }

              throw new SdkError("slippage needs to be specified for a zap", SdkError.NO_SLIPPAGE);

            case 10:
              if (!(fromVault === EthAddress)) {
                _context4.next = 14;
                break;
              }

              needsApproving = false;
              _context4.next = 17;
              break;

            case 14:
              _context4.next = 16;
              return this.yearn.services.zapper.zapOutApprovalState(from, fromVault).then(function (state) {
                return !state.isApproved;
              })["catch"](function () {
                throw new ZapperError("zap out approval state", ZapperError.ZAP_OUT_APPROVAL_STATE);
              });

            case 16:
              needsApproving = _context4.sent;

            case 17:
              if (!needsApproving) {
                _context4.next = 23;
                break;
              }

              _context4.next = 20;
              return this.simulationExecutor.createFork();

            case 20:
              _context4.t0 = _context4.sent;
              _context4.next = 24;
              break;

            case 23:
              _context4.t0 = undefined;

            case 24:
              forkId = _context4.t0;
              options.forkId = forkId;

              if (!needsApproving) {
                _context4.next = 32;
                break;
              }

              _context4.next = 29;
              return this.yearn.services.zapper.zapOutApprovalTransaction(from, fromVault, "0")["catch"](function () {
                throw new ZapperError("zap out approval transaction", ZapperError.ZAP_OUT_APPROVAL);
              }).then( /*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(approvalTransaction) {
                  return runtime_1.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          _context3.next = 2;
                          return _this3.simulateZapApprovalTransaction(approvalTransaction, options);

                        case 2:
                          return _context3.abrupt("return", _context3.sent);

                        case 3:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3);
                }));

                return function (_x12) {
                  return _ref2.apply(this, arguments);
                };
              }()).then(function (res) {
                return res.simulation.id;
              });

            case 29:
              _context4.t1 = _context4.sent;
              _context4.next = 33;
              break;

            case 32:
              _context4.t1 = undefined;

            case 33:
              approvalSimulationId = _context4.t1;
              options.root = approvalSimulationId;

              simulateWithdrawal = function simulateWithdrawal(save) {
                options.save = save;
                return _this3.zapOut(from, toToken, underlyingToken, amount, fromVault, needsApproving, options);
              };

              _context4.next = 39;
              break;

            case 38:
              simulateWithdrawal = function simulateWithdrawal(save) {
                options.save = save;
                return _this3.directWithdraw(from, toToken, amount, fromVault, vaultContract, options);
              };

            case 39:
              return _context4.abrupt("return", this.simulationExecutor.executeSimulationWithReSimulationOnFailure(simulateWithdrawal, forkId));

            case 40:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function withdraw(_x7, _x8, _x9, _x10, _x11) {
      return _withdraw.apply(this, arguments);
    }

    return withdraw;
  }();

  _proto.approve = /*#__PURE__*/function () {
    var _approve = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(from, token, amount, vault, options) {
      var TokenAbi, signer, tokenContract, encodedInputData, simulationResponse;
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              TokenAbi = ["function approve(address spender, uint256 amount) returns (bool)"];
              signer = this.ctx.provider.write.getSigner(from);
              tokenContract = new Contract(token, TokenAbi, signer);
              encodedInputData = tokenContract["interface"].encodeFunctionData("approve", [vault, amount]);
              options.save = true;
              _context5.next = 7;
              return this.simulationExecutor.makeSimulationRequest(from, token, encodedInputData, options);

            case 7:
              simulationResponse = _context5.sent;
              return _context5.abrupt("return", simulationResponse.simulation.id);

            case 9:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function approve(_x13, _x14, _x15, _x16, _x17) {
      return _approve.apply(this, arguments);
    }

    return approve;
  }();

  _proto.depositNeedsApproving = /*#__PURE__*/function () {
    var _depositNeedsApproving = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(from, token, vault, amount, signer) {
      var TokenAbi, contract, result;
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              TokenAbi = ["function allowance(address owner, address spender) view returns (uint256)"];
              contract = new Contract(token, TokenAbi, signer);
              _context6.next = 4;
              return contract.allowance(from, vault)["catch"](function () {
                "deposit needs approving";
              });

            case 4:
              result = _context6.sent;
              return _context6.abrupt("return", new BigNumber$1(result.toString()).lt(new BigNumber$1(amount)));

            case 6:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));

    function depositNeedsApproving(_x18, _x19, _x20, _x21, _x22) {
      return _depositNeedsApproving.apply(this, arguments);
    }

    return depositNeedsApproving;
  }();

  _proto.directDeposit = /*#__PURE__*/function () {
    var _directDeposit = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(from, sellToken, amount, toVault, vaultContract, options) {
      var encodedInputData, tokensReceived, targetTokenAmountUsdc, _yield$Promise$all, decimals, pricePerShare, targetUnderlyingTokensReceived, result;

      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              encodedInputData = vaultContract.encodeDeposit(amount);
              _context7.next = 3;
              return this.simulationExecutor.simulateVaultInteraction(from, toVault, encodedInputData, toVault, options);

            case 3:
              tokensReceived = _context7.sent;
              _context7.next = 6;
              return this.yearn.services.oracle.getNormalizedValueUsdc(toVault, tokensReceived)["catch"](function () {
                throw new PriceFetchingError("Error fetching price", PriceFetchingError.FETCHING_PRICE_ORACLE);
              });

            case 6:
              targetTokenAmountUsdc = _context7.sent;
              _context7.next = 9;
              return Promise.all([vaultContract.decimals()["catch"](function () {
                throw new EthersError("no decimals", EthersError.NO_DECIMALS);
              }), vaultContract.pricePerShare()["catch"](function () {
                throw new EthersError("no price per share", EthersError.NO_PRICE_PER_SHARE);
              })]);

            case 9:
              _yield$Promise$all = _context7.sent;
              decimals = _yield$Promise$all[0];
              pricePerShare = _yield$Promise$all[1];
              targetUnderlyingTokensReceived = new BigNumber$1(tokensReceived).div(new BigNumber$1(10).pow(decimals)).multipliedBy(pricePerShare).toFixed(0);
              result = {
                sourceTokenAddress: sellToken,
                sourceTokenAmount: amount,
                targetTokenAddress: toVault,
                targetTokenAmount: tokensReceived,
                targetTokenAmountUsdc: targetTokenAmountUsdc,
                targetUnderlyingTokenAddress: toVault,
                targetUnderlyingTokenAmount: targetUnderlyingTokensReceived,
                conversionRate: 1,
                slippage: 0
              };
              return _context7.abrupt("return", result);

            case 15:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function directDeposit(_x23, _x24, _x25, _x26, _x27, _x28) {
      return _directDeposit.apply(this, arguments);
    }

    return directDeposit;
  }();

  _proto.zapIn = /*#__PURE__*/function () {
    var _zapIn = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(from, sellToken, underlyingTokenAddress, amount, toVault, vaultContract, zapProtocol, skipGasEstimate, options) {
      var zapToken, zapInParams, value, tokensReceived, _yield$Promise$all2, decimals, pricePerShare, targetUnderlyingTokensReceived, amountReceivedUsdc, oracleToken, zapInAmountUsdc, conversionRate, result;

      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              zapToken = sellToken === EthAddress ? ZeroAddress : sellToken;

              if (options.slippage) {
                _context8.next = 3;
                break;
              }

              throw new SdkError("slippage needs to be set", SdkError.NO_SLIPPAGE);

            case 3:
              _context8.next = 5;
              return this.yearn.services.zapper.zapIn(from, zapToken, amount, toVault, options.gasPrice || "0", options.slippage, skipGasEstimate, zapProtocol)["catch"](function () {
                throw new ZapperError("zap in", ZapperError.ZAP_IN);
              });

            case 5:
              zapInParams = _context8.sent;
              value = new BigNumber$1(zapInParams.value).toFixed(0);
              options.gasPrice = options.gasPrice || zapInParams.gasPrice;

              if (!skipGasEstimate) {
                options.gasLimit = zapInParams.gas;
              }

              _context8.next = 11;
              return this.simulationExecutor.simulateVaultInteraction(from, zapInParams.to, zapInParams.data, toVault, options, value);

            case 11:
              tokensReceived = _context8.sent;
              _context8.next = 14;
              return Promise.all([vaultContract.decimals()["catch"](function () {
                throw new EthersError("no decimals", EthersError.NO_DECIMALS);
              }), vaultContract.pricePerShare()["catch"](function () {
                throw new EthersError("no price per share", EthersError.NO_PRICE_PER_SHARE);
              })]);

            case 14:
              _yield$Promise$all2 = _context8.sent;
              decimals = _yield$Promise$all2[0];
              pricePerShare = _yield$Promise$all2[1];
              targetUnderlyingTokensReceived = new BigNumber$1(tokensReceived).div(new BigNumber$1(10).pow(decimals)).multipliedBy(pricePerShare).toFixed(0);
              _context8.t0 = zapProtocol;
              _context8.next = _context8.t0 === ZapProtocol.YEARN ? 21 : _context8.t0 === ZapProtocol.PICKLE ? 25 : 29;
              break;

            case 21:
              _context8.next = 23;
              return this.yearn.services.oracle.getNormalizedValueUsdc(toVault, tokensReceived).then(function (price) {
                return new BigNumber$1(price);
              })["catch"](function () {
                throw new PriceFetchingError("error fetching price", PriceFetchingError.FETCHING_PRICE_ORACLE);
              });

            case 23:
              amountReceivedUsdc = _context8.sent;
              return _context8.abrupt("break", 29);

            case 25:
              _context8.next = 27;
              return this.yearn.services.pickle.getPriceUsdc(toVault)["catch"](function () {
                throw new PriceFetchingError("error fetching price", PriceFetchingError.FETCHING_PRICE_PICKLE);
              }).then(function (usdc) {
                return new BigNumber$1(usdc);
              });

            case 27:
              amountReceivedUsdc = _context8.sent.dividedBy(new BigNumber$1(10).pow(decimals)).multipliedBy(new BigNumber$1(tokensReceived));
              return _context8.abrupt("break", 29);

            case 29:
              oracleToken = sellToken === EthAddress ? WethAddress : sellToken;
              _context8.t1 = BigNumber$1;
              _context8.next = 33;
              return this.yearn.services.oracle.getNormalizedValueUsdc(oracleToken, amount)["catch"](function () {
                throw new PriceFetchingError("error fetching price", PriceFetchingError.FETCHING_PRICE_ORACLE);
              });

            case 33:
              _context8.t2 = _context8.sent;
              zapInAmountUsdc = new _context8.t1(_context8.t2);
              conversionRate = amountReceivedUsdc.div(new BigNumber$1(zapInAmountUsdc)).toNumber();
              result = {
                sourceTokenAddress: sellToken,
                sourceTokenAmount: amount,
                targetTokenAddress: zapInParams.buyTokenAddress,
                targetTokenAmount: tokensReceived,
                targetTokenAmountUsdc: amountReceivedUsdc.toFixed(0),
                targetUnderlyingTokenAddress: underlyingTokenAddress,
                targetUnderlyingTokenAmount: targetUnderlyingTokensReceived,
                conversionRate: conversionRate,
                slippage: 1 - conversionRate
              };
              return _context8.abrupt("return", result);

            case 38:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function zapIn(_x29, _x30, _x31, _x32, _x33, _x34, _x35, _x36, _x37) {
      return _zapIn.apply(this, arguments);
    }

    return zapIn;
  }();

  _proto.directWithdraw = /*#__PURE__*/function () {
    var _directWithdraw = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(from, toToken, amount, fromVault, vaultContract, options) {
      var encodedInputData, tokensReceived, targetTokenAmountUsdc, result;
      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              encodedInputData = vaultContract.encodeWithdraw(amount);
              _context9.next = 3;
              return this.simulationExecutor.simulateVaultInteraction(from, fromVault, encodedInputData, toToken, options);

            case 3:
              tokensReceived = _context9.sent;
              _context9.next = 6;
              return this.yearn.services.oracle.getNormalizedValueUsdc(toToken, tokensReceived)["catch"](function () {
                throw new PriceFetchingError("error fetching price", PriceFetchingError.FETCHING_PRICE_ORACLE);
              });

            case 6:
              targetTokenAmountUsdc = _context9.sent;
              result = {
                sourceTokenAddress: fromVault,
                sourceTokenAmount: amount,
                targetTokenAddress: toToken,
                targetTokenAmount: tokensReceived,
                targetTokenAmountUsdc: targetTokenAmountUsdc,
                targetUnderlyingTokenAddress: toToken,
                targetUnderlyingTokenAmount: tokensReceived,
                conversionRate: 1,
                slippage: 0
              };
              return _context9.abrupt("return", result);

            case 9:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));

    function directWithdraw(_x38, _x39, _x40, _x41, _x42, _x43) {
      return _directWithdraw.apply(this, arguments);
    }

    return directWithdraw;
  }();

  _proto.zapOut = /*#__PURE__*/function () {
    var _zapOut = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(from, toToken, underlyingTokenAddress, amount, fromVault, skipGasEstimate, options) {
      var _this4 = this;

      var zapToken, zapOutParams, tokensReceived, oracleToken, zapOutAmountUsdc, soldAssetAmountUsdc, conversionRate, result;
      return runtime_1.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              if (options.slippage) {
                _context11.next = 2;
                break;
              }

              throw new SdkError("slippage needs to be set", SdkError.NO_SLIPPAGE);

            case 2:
              zapToken = toToken === EthAddress ? ZeroAddress : toToken;
              _context11.next = 5;
              return this.yearn.services.zapper.zapOut(from, zapToken, amount, fromVault, "0", options.slippage, skipGasEstimate)["catch"](function () {
                throw new ZapperError("error zapping out", ZapperError.ZAP_OUT);
              });

            case 5:
              zapOutParams = _context11.sent;

              if (!skipGasEstimate) {
                options.gasLimit = zapOutParams.gas;
              }

              _context11.next = 9;
              return _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10() {
                var response;
                return runtime_1.wrap(function _callee10$(_context10) {
                  while (1) {
                    switch (_context10.prev = _context10.next) {
                      case 0:
                        if (!(zapToken === ZeroAddress)) {
                          _context10.next = 7;
                          break;
                        }

                        _context10.next = 3;
                        return _this4.simulationExecutor.makeSimulationRequest(from, zapOutParams.to, zapOutParams.data, options, zapOutParams.value);

                      case 3:
                        response = _context10.sent;
                        return _context10.abrupt("return", new BigNumber$1(response.transaction.transaction_info.call_trace.output).toFixed(0));

                      case 7:
                        _context10.next = 9;
                        return _this4.simulationExecutor.simulateVaultInteraction(from, zapOutParams.to, zapOutParams.data, toToken, options, zapOutParams.value);

                      case 9:
                        return _context10.abrupt("return", _context10.sent);

                      case 10:
                      case "end":
                        return _context10.stop();
                    }
                  }
                }, _callee10);
              }))();

            case 9:
              tokensReceived = _context11.sent;
              oracleToken = toToken === EthAddress ? WethAddress : toToken;
              _context11.next = 13;
              return this.yearn.services.oracle.getNormalizedValueUsdc(oracleToken, tokensReceived)["catch"](function () {
                throw new PriceFetchingError("error fetching price", PriceFetchingError.FETCHING_PRICE_ORACLE);
              });

            case 13:
              zapOutAmountUsdc = _context11.sent;
              _context11.next = 16;
              return this.yearn.services.oracle.getNormalizedValueUsdc(fromVault, amount)["catch"](function () {
                throw new PriceFetchingError("error fetching price", PriceFetchingError.FETCHING_PRICE_ORACLE);
              });

            case 16:
              soldAssetAmountUsdc = _context11.sent;
              conversionRate = new BigNumber$1(zapOutAmountUsdc).div(new BigNumber$1(soldAssetAmountUsdc)).toNumber();
              result = {
                sourceTokenAddress: fromVault,
                sourceTokenAmount: amount,
                targetTokenAddress: toToken,
                targetTokenAmount: tokensReceived,
                targetTokenAmountUsdc: zapOutAmountUsdc,
                targetUnderlyingTokenAddress: underlyingTokenAddress,
                targetUnderlyingTokenAmount: tokensReceived,
                conversionRate: conversionRate,
                slippage: 1 - conversionRate
              };
              return _context11.abrupt("return", result);

            case 20:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));

    function zapOut(_x44, _x45, _x46, _x47, _x48, _x49, _x50) {
      return _zapOut.apply(this, arguments);
    }

    return zapOut;
  }();

  _proto.simulateZapApprovalTransaction = /*#__PURE__*/function () {
    var _simulateZapApprovalTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12(zapApprovalTransaction, options) {
      return runtime_1.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              options.save = true;
              _context12.next = 3;
              return this.simulationExecutor.makeSimulationRequest(zapApprovalTransaction.from, zapApprovalTransaction.to, zapApprovalTransaction.data, options);

            case 3:
              return _context12.abrupt("return", _context12.sent);

            case 4:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12, this);
    }));

    function simulateZapApprovalTransaction(_x51, _x52) {
      return _simulateZapApprovalTransaction.apply(this, arguments);
    }

    return simulateZapApprovalTransaction;
  }();

  return SimulationInterface;
}(ServiceInterface);

var VaultAbi = ["function strategies(address) view returns (uint256 performanceFee, uint256 activation, uint256 debtRatio, uint256 rateLimit, uint256 lastReport, uint256 totalDebt, uint256 totalGain, uint256 totalLoss)", "function token() view returns (address)", "event StrategyAdded(address indexed strategy, uint256 debtRatio, uint256 minDebtPerHarvest, uint256 maxDebtPerHarvest, uint256 performanceFee)"];
var TokenAbi = ["function symbol() view returns (string)"];
var StrategyInterface = /*#__PURE__*/function (_ServiceInterface) {
  _inheritsLoose(StrategyInterface, _ServiceInterface);

  function StrategyInterface() {
    var _this;

    _this = _ServiceInterface.apply(this, arguments) || this;
    _this.cachedFetcher = new CachedFetcher("strategies/metadata/get", _this.ctx, _this.chainId);
    return _this;
  }

  var _proto = StrategyInterface.prototype;

  _proto.vaultsStrategiesMetadata = /*#__PURE__*/function () {
    var _vaultsStrategiesMetadata = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(vaultAddresses) {
      var cached, vaults, vaultStrategiesMetadata;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.cachedFetcher.fetch();

            case 2:
              cached = _context.sent;

              if (!cached) {
                _context.next = 5;
                break;
              }

              return _context.abrupt("return", cached);

            case 5:
              if (!vaultAddresses) {
                _context.next = 9;
                break;
              }

              vaults = vaultAddresses;
              _context.next = 12;
              break;

            case 9:
              _context.next = 11;
              return this.yearn.services.lens.adapters.vaults.v2.assetsStatic().then(function (assets) {
                return assets.map(function (asset) {
                  return asset.address;
                });
              });

            case 11:
              vaults = _context.sent;

            case 12:
              _context.prev = 12;
              _context.next = 15;
              return this.fetchMetadataFromApi(vaults);

            case 15:
              vaultStrategiesMetadata = _context.sent;
              _context.next = 21;
              break;

            case 18:
              _context.prev = 18;
              _context.t0 = _context["catch"](12);
              console.error(_context.t0);

            case 21:
              if (vaultStrategiesMetadata) {
                _context.next = 25;
                break;
              }

              _context.next = 24;
              return this.fetchMetadataFromChain(vaults);

            case 24:
              vaultStrategiesMetadata = _context.sent;

            case 25:
              return _context.abrupt("return", vaultStrategiesMetadata);

            case 26:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[12, 18]]);
    }));

    function vaultsStrategiesMetadata(_x) {
      return _vaultsStrategiesMetadata.apply(this, arguments);
    }

    return vaultsStrategiesMetadata;
  }();

  _proto.fetchMetadataFromApi = /*#__PURE__*/function () {
    var _fetchMetadataFromApi = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(vaultAddresses) {
      var _this2 = this;

      var vaultsData, strategiesMetadata, vaultsStrategiesMetadataPromises;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.fetchVaultsData();

            case 2:
              vaultsData = _context3.sent;
              _context3.next = 5;
              return this.yearn.services.meta.strategies();

            case 5:
              strategiesMetadata = _context3.sent;
              vaultsStrategiesMetadataPromises = vaultAddresses.map( /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(vaultAddress) {
                  var vaultDatum, vaultContract;
                  return runtime_1.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          vaultDatum = vaultsData.find(function (datum) {
                            return datum.address === vaultAddress;
                          });

                          if (vaultDatum) {
                            _context2.next = 3;
                            break;
                          }

                          return _context2.abrupt("return", undefined);

                        case 3:
                          vaultContract = new Contract(vaultDatum.address, VaultAbi, _this2.ctx.provider.read);
                          return _context2.abrupt("return", _this2.fetchVaultStrategiesMetadata(vaultDatum.strategies, strategiesMetadata, vaultContract, vaultDatum.token.symbol));

                        case 5:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2);
                }));

                return function (_x3) {
                  return _ref.apply(this, arguments);
                };
              }());
              return _context3.abrupt("return", Promise.all(vaultsStrategiesMetadataPromises).then(function (vaultsStrategyData) {
                return vaultsStrategyData.flatMap(function (data) {
                  return data ? [data] : [];
                });
              }));

            case 8:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function fetchMetadataFromApi(_x2) {
      return _fetchMetadataFromApi.apply(this, arguments);
    }

    return fetchMetadataFromApi;
  }();

  _proto.fetchMetadataFromChain = /*#__PURE__*/function () {
    var _fetchMetadataFromChain = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(vaultAddresses) {
      var _this3 = this;

      var strategiesMetadata, provider, vaultsStrategiesMetadataPromises;
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return this.yearn.services.meta.strategies();

            case 2:
              strategiesMetadata = _context5.sent;
              provider = this.ctx.provider.read;
              vaultsStrategiesMetadataPromises = vaultAddresses.map( /*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(vaultAddress) {
                  var vaultContract, strategiesPromise, _yield$Promise$all, strategies, underlyingTokenAddress, underlyingTokenContract, underlyingTokenSymbol;

                  return runtime_1.wrap(function _callee4$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          vaultContract = new Contract(vaultAddress, VaultAbi, provider);
                          strategiesPromise = _this3.yearn.services.helper.assetStrategiesAddresses(vaultAddress).then(function (addresses) {
                            return addresses.map(function (strat) {
                              return {
                                address: strat
                              };
                            });
                          });
                          _context4.next = 4;
                          return Promise.all([strategiesPromise, vaultContract.token()]);

                        case 4:
                          _yield$Promise$all = _context4.sent;
                          strategies = _yield$Promise$all[0];
                          underlyingTokenAddress = _yield$Promise$all[1];
                          underlyingTokenContract = new Contract(underlyingTokenAddress, TokenAbi, provider);
                          _context4.next = 10;
                          return underlyingTokenContract.symbol();

                        case 10:
                          underlyingTokenSymbol = _context4.sent;
                          return _context4.abrupt("return", _this3.fetchVaultStrategiesMetadata(strategies, strategiesMetadata, vaultContract, underlyingTokenSymbol));

                        case 12:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  }, _callee4);
                }));

                return function (_x5) {
                  return _ref2.apply(this, arguments);
                };
              }());
              return _context5.abrupt("return", Promise.all(vaultsStrategiesMetadataPromises).then(function (vaultsStrategyData) {
                return vaultsStrategyData.flatMap(function (data) {
                  return data ? [data] : [];
                });
              }));

            case 6:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function fetchMetadataFromChain(_x4) {
      return _fetchMetadataFromChain.apply(this, arguments);
    }

    return fetchMetadataFromChain;
  }();

  _proto.fetchVaultStrategiesMetadata = /*#__PURE__*/function () {
    var _fetchVaultStrategiesMetadata = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(strategies, strategiesMetadata, vaultContract, underlyingTokenSymbol) {
      var metadata, result;
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (!(strategies.length === 0)) {
                _context7.next = 2;
                break;
              }

              return _context7.abrupt("return", undefined);

            case 2:
              _context7.next = 4;
              return Promise.all(strategies.map( /*#__PURE__*/function () {
                var _ref3 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(strategy) {
                  var _metadatum$descriptio, _metadatum$protocols;

                  var debtRatio, struct, metadatum, metadata;
                  return runtime_1.wrap(function _callee6$(_context6) {
                    while (1) {
                      switch (_context6.prev = _context6.next) {
                        case 0:
                          _context6.prev = 0;
                          _context6.next = 3;
                          return vaultContract.strategies(strategy.address);

                        case 3:
                          struct = _context6.sent;
                          debtRatio = struct.debtRatio;
                          _context6.next = 10;
                          break;

                        case 7:
                          _context6.prev = 7;
                          _context6.t0 = _context6["catch"](0);
                          return _context6.abrupt("return", undefined);

                        case 10:
                          if (!debtRatio.lte(BigNumber$2.from("0"))) {
                            _context6.next = 12;
                            break;
                          }

                          return _context6.abrupt("return", undefined);

                        case 12:
                          metadatum = strategiesMetadata.find(function (strategiesMetadata) {
                            return strategiesMetadata.addresses.includes(strategy.address);
                          });
                          metadata = {
                            address: strategy.address,
                            name: (metadatum == null ? void 0 : metadatum.name) || strategy.name || "Strategy",
                            description: (_metadatum$descriptio = metadatum == null ? void 0 : metadatum.description) != null ? _metadatum$descriptio : "I don't have a description for this strategy yet",
                            protocols: (_metadatum$protocols = metadatum == null ? void 0 : metadatum.protocols) != null ? _metadatum$protocols : []
                          };
                          metadata.description = metadata == null ? void 0 : metadata.description.replace(/{{token}}/g, underlyingTokenSymbol);
                          return _context6.abrupt("return", {
                            data: metadata,
                            debtRatio: debtRatio
                          });

                        case 16:
                        case "end":
                          return _context6.stop();
                      }
                    }
                  }, _callee6, null, [[0, 7]]);
                }));

                return function (_x10) {
                  return _ref3.apply(this, arguments);
                };
              }())).then(function (metadataAndDebtRatio) {
                return metadataAndDebtRatio.flatMap(function (data) {
                  return data ? [data] : [];
                }).sort(function (lhs, rhs) {
                  if (lhs.debtRatio.lt(rhs.debtRatio)) {
                    return 1;
                  } else if (lhs.debtRatio.eq(rhs.debtRatio)) {
                    return 0;
                  } else {
                    return -1;
                  }
                }).map(function (metadata) {
                  return metadata.data;
                });
              });

            case 4:
              metadata = _context7.sent;

              if (!(metadata.length === 0)) {
                _context7.next = 7;
                break;
              }

              return _context7.abrupt("return", undefined);

            case 7:
              result = {
                vaultAddress: vaultContract.address,
                strategiesMetadata: metadata
              };
              return _context7.abrupt("return", result);

            case 9:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));

    function fetchVaultStrategiesMetadata(_x6, _x7, _x8, _x9) {
      return _fetchVaultStrategiesMetadata.apply(this, arguments);
    }

    return fetchVaultStrategiesMetadata;
  }();

  _proto.fetchVaultsData = /*#__PURE__*/function () {
    var _fetchVaultsData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8() {
      var res;
      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return fetch$1("https://api.yearn.finance/v1/chains/" + this.chainId + "/vaults/all");

            case 2:
              res = _context8.sent;

              if (res.ok) {
                _context8.next = 5;
                break;
              }

              throw new Error("An error has occured fetching vaults data: " + res.status);

            case 5:
              _context8.next = 7;
              return res.json();

            case 7:
              return _context8.abrupt("return", _context8.sent);

            case 8:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function fetchVaultsData() {
      return _fetchVaultsData.apply(this, arguments);
    }

    return fetchVaultsData;
  }();

  return StrategyInterface;
}(ServiceInterface);

var TokenAbi$1 = ["function approve(address _spender, uint256 _value) public"];
var TokenInterface = /*#__PURE__*/function (_ServiceInterface) {
  _inheritsLoose(TokenInterface, _ServiceInterface);

  function TokenInterface() {
    var _this;

    _this = _ServiceInterface.apply(this, arguments) || this;
    _this.cachedFetcherSupported = new CachedFetcher("tokens/supported", _this.ctx, _this.chainId);
    _this.cachedFetcher = new CachedFetcher("tokens/metadata", _this.ctx, _this.chainId);
    return _this;
  }
  /**
   * Get exchange rate between two tokens.
   * @param from
   * @param to
   * @returns exchange rate
   */


  var _proto = TokenInterface.prototype;

  _proto.price =
  /*#__PURE__*/
  function () {
    var _price = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(from, to) {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", this.yearn.services.oracle.getPriceFromRouter(from, to));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function price(_x, _x2) {
      return _price.apply(this, arguments);
    }

    return price;
  }();

  _proto.priceUsdc = /*#__PURE__*/function () {
    var _priceUsdc = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(tokens, overrides) {
      var _this2 = this;

      var entries;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!Array.isArray(tokens)) {
                _context3.next = 5;
                break;
              }

              _context3.next = 3;
              return Promise.all(tokens.map( /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(token) {
                  var price;
                  return runtime_1.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          _context2.next = 2;
                          return _this2.yearn.services.oracle.getPriceUsdc(token, overrides);

                        case 2:
                          price = _context2.sent;
                          return _context2.abrupt("return", [token, price]);

                        case 4:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2);
                }));

                return function (_x5) {
                  return _ref.apply(this, arguments);
                };
              }()));

            case 3:
              entries = _context3.sent;
              return _context3.abrupt("return", Object.fromEntries(entries));

            case 5:
              return _context3.abrupt("return", this.yearn.services.oracle.getPriceUsdc(tokens, overrides));

            case 6:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function priceUsdc(_x3, _x4) {
      return _priceUsdc.apply(this, arguments);
    }

    return priceUsdc;
  }()
  /**
   * Fetch token balances from the {@link TokenInterface.supported} list
   * for a particular address.
   * @param address
   */
  ;

  _proto.balances =
  /*#__PURE__*/
  function () {
    var _balances = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(address) {
      var vaultBalances, zapperBalances, vaultBalanceAddresses, ironBankTokens, _vaultBalanceAddresses;

      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.yearn.vaults.balances(address).then(function (balances) {
                return balances.filter(function (token) {
                  return token.balance !== "0";
                });
              });

            case 2:
              vaultBalances = _context4.sent;
              _context4.t0 = this.chainId;
              _context4.next = _context4.t0 === 1 ? 6 : _context4.t0 === 1337 ? 6 : _context4.t0 === 250 ? 19 : _context4.t0 === 42161 ? 19 : 25;
              break;

            case 6:
              zapperBalances = [];
              _context4.prev = 7;
              _context4.next = 10;
              return this.yearn.services.zapper.balances(address);

            case 10:
              zapperBalances = _context4.sent;
              _context4.next = 16;
              break;

            case 13:
              _context4.prev = 13;
              _context4.t1 = _context4["catch"](7);
              console.error(_context4.t1);

            case 16:
              vaultBalanceAddresses = new Set(vaultBalances.map(function (balance) {
                return balance.address;
              }));
              zapperBalances = zapperBalances.filter(function (balance) {
                return !vaultBalanceAddresses.has(balance.address);
              });
              return _context4.abrupt("return", zapperBalances.concat(vaultBalances));

            case 19:
              _context4.next = 21;
              return this.yearn.ironBank.balances(address);

            case 21:
              ironBankTokens = _context4.sent;
              _vaultBalanceAddresses = new Set(vaultBalances.map(function (balance) {
                return balance.address;
              }));
              ironBankTokens = ironBankTokens.filter(function (balance) {
                return !_vaultBalanceAddresses.has(balance.address);
              });
              return _context4.abrupt("return", ironBankTokens.concat(vaultBalances));

            case 25:
              console.error("the chain " + this.chainId + " hasn't been implemented yet");
              return _context4.abrupt("return", []);

            case 27:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this, [[7, 13]]);
    }));

    function balances(_x6) {
      return _balances.apply(this, arguments);
    }

    return balances;
  }()
  /**
   * Fetch all the tokens supported by the zapper protocol along with some basic
   * metadata.
   * @returns list of tokens supported by the zapper protocol.
   */
  ;

  _proto.supported =
  /*#__PURE__*/
  function () {
    var _supported = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5() {
      var _this3 = this;

      var cached, tokens, icons;
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              _context5.next = 3;
              return this.cachedFetcherSupported.fetch();

            case 3:
              cached = _context5.sent;

              if (!cached) {
                _context5.next = 6;
                break;
              }

              return _context5.abrupt("return", cached);

            case 6:
              if (!(this.chainId === 1 || this.chainId === 1337)) {
                _context5.next = 14;
                break;
              }

              _context5.next = 9;
              return this.yearn.services.zapper.supportedTokens();

            case 9:
              tokens = _context5.sent;
              _context5.next = 12;
              return this.yearn.services.asset.ready.then(function () {
                return _this3.yearn.services.asset.icon(tokens.map(function (token) {
                  return token.address;
                }));
              });

            case 12:
              icons = _context5.sent;
              return _context5.abrupt("return", tokens.map(function (token) {
                var icon = icons[token.address];
                return icon ? _extends({}, token, {
                  icon: icon
                }) : token;
              }));

            case 14:
              console.error("the chain " + this.chainId + " hasn't been implemented yet");
              _context5.next = 20;
              break;

            case 17:
              _context5.prev = 17;
              _context5.t0 = _context5["catch"](0);
              console.error(_context5.t0);

            case 20:
              return _context5.abrupt("return", []);

            case 21:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this, [[0, 17]]);
    }));

    function supported() {
      return _supported.apply(this, arguments);
    }

    return supported;
  }()
  /**
   * Approve vault to spend a token on zapIn
   * @param vault
   * @param token
   * @param amount
   * @param account
   * @returns transaction
   */
  ;

  _proto.approve =
  /*#__PURE__*/
  function () {
    var _approve = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(vault, token, amount, account) {
      var signer, tokenContract, tx, gasPrice, gasPriceFastGwei, zapProtocol, zapInApprovalState, zapInApprovalParams, transaction;
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (!(EthAddress === token)) {
                _context6.next = 2;
                break;
              }

              return _context6.abrupt("return", true);

            case 2:
              signer = this.ctx.provider.write.getSigner(account);

              if (!(vault.token === token)) {
                _context6.next = 9;
                break;
              }

              tokenContract = new Contract(token, TokenAbi$1, signer);
              _context6.next = 7;
              return tokenContract.populateTransaction.approve(vault.address, amount);

            case 7:
              tx = _context6.sent;
              return _context6.abrupt("return", this.yearn.services.transaction.sendTransaction(tx));

            case 9:
              _context6.next = 11;
              return this.yearn.services.zapper.gas();

            case 11:
              gasPrice = _context6.sent;
              gasPriceFastGwei = new BigNumber$1(gasPrice.fast).times(new BigNumber$1(Math.pow(10, 9)));
              zapProtocol = PickleJars.includes(vault.address) ? ZapProtocol.PICKLE : ZapProtocol.YEARN;
              _context6.next = 16;
              return this.yearn.services.zapper.zapInApprovalState(account, token, zapProtocol);

            case 16:
              zapInApprovalState = _context6.sent;

              if (zapInApprovalState.isApproved) {
                _context6.next = 23;
                break;
              }

              _context6.next = 20;
              return this.yearn.services.zapper.zapInApprovalTransaction(account, token, gasPriceFastGwei.toString(), zapProtocol);

            case 20:
              zapInApprovalParams = _context6.sent;
              transaction = {
                to: zapInApprovalParams.to,
                from: zapInApprovalParams.from,
                gasPrice: zapInApprovalParams.gasPrice,
                data: zapInApprovalParams.data
              };
              return _context6.abrupt("return", signer.sendTransaction(transaction));

            case 23:
              return _context6.abrupt("return", true);

            case 24:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function approve(_x7, _x8, _x9, _x10) {
      return _approve.apply(this, arguments);
    }

    return approve;
  }()
  /**
   * Approve vault to spend a vault token on zapOut
   * @param vault
   * @param token
   * @param account
   * @returns transaction
   */
  ;

  _proto.approveZapOut =
  /*#__PURE__*/
  function () {
    var _approveZapOut = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(vault, token, account) {
      var signer, gasPrice, gasPriceFastGwei, sellToken, zapOutApprovalState, zapOutApprovalParams, transaction;
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              signer = this.ctx.provider.write.getSigner(account);

              if (!(vault.token === token)) {
                _context7.next = 16;
                break;
              }

              _context7.next = 4;
              return this.yearn.services.zapper.gas();

            case 4:
              gasPrice = _context7.sent;
              gasPriceFastGwei = new BigNumber$1(gasPrice.fast).times(new BigNumber$1(Math.pow(10, 9)));
              sellToken = token;
              _context7.next = 9;
              return this.yearn.services.zapper.zapOutApprovalState(account, sellToken);

            case 9:
              zapOutApprovalState = _context7.sent;

              if (zapOutApprovalState.isApproved) {
                _context7.next = 16;
                break;
              }

              _context7.next = 13;
              return this.yearn.services.zapper.zapOutApprovalTransaction(account, sellToken, gasPriceFastGwei.toString());

            case 13:
              zapOutApprovalParams = _context7.sent;
              transaction = {
                to: zapOutApprovalParams.to,
                from: zapOutApprovalParams.from,
                gasPrice: zapOutApprovalParams.gasPrice,
                data: zapOutApprovalParams.data
              };
              return _context7.abrupt("return", signer.sendTransaction(transaction));

            case 16:
              return _context7.abrupt("return", false);

            case 17:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function approveZapOut(_x11, _x12, _x13) {
      return _approveZapOut.apply(this, arguments);
    }

    return approveZapOut;
  }();

  _proto.icon = function icon(address) {
    return this.yearn.services.asset.icon(address);
  };

  _proto.metadata = /*#__PURE__*/function () {
    var _metadata = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(addresses) {
      var result, cached;
      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return this.cachedFetcher.fetch();

            case 2:
              cached = _context8.sent;

              if (!cached) {
                _context8.next = 7;
                break;
              }

              result = cached;
              _context8.next = 10;
              break;

            case 7:
              _context8.next = 9;
              return this.yearn.services.meta.tokens();

            case 9:
              result = _context8.sent;

            case 10:
              if (!addresses) {
                _context8.next = 14;
                break;
              }

              return _context8.abrupt("return", result.filter(function (metadata) {
                return addresses.includes(metadata.address);
              }));

            case 14:
              return _context8.abrupt("return", result);

            case 15:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function metadata(_x14) {
      return _metadata.apply(this, arguments);
    }

    return metadata;
  }();

  return TokenInterface;
}(ServiceInterface);

var VaultAbi$1 = ["function deposit(uint256 amount) public", "function withdraw(uint256 amount) public"];
var VaultInterface = /*#__PURE__*/function (_ServiceInterface) {
  _inheritsLoose(VaultInterface, _ServiceInterface);

  function VaultInterface() {
    var _this;

    _this = _ServiceInterface.apply(this, arguments) || this;
    _this.cachedFetcherGet = new CachedFetcher("vaults/get", _this.ctx, _this.chainId);
    _this.cachedFetcherGetDynamic = new CachedFetcher("vaults/getDynamic", _this.ctx, _this.chainId);
    _this.cachedFetcherTokens = new CachedFetcher("vaults/tokens", _this.ctx, _this.chainId);
    return _this;
  }
  /**
   * Get all yearn vaults.
   * @param addresses filter, if not provided all positions are returned
   * @param overrides
   * @returns
   */


  var _proto = VaultInterface.prototype;

  _proto.get =
  /*#__PURE__*/
  function () {
    var _get = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(addresses, overrides) {
      var _this2 = this;

      var cached, vaultMetadataOverridesPromise, _yield$Promise$all, vaultMetadataOverrides, assetsStatic, assetsDynamic, allAddresses, chunks, promises, strategiesMetadataPromise, assetsHistoricEarningsPromise, _yield$Promise$all2, strategiesMetadata, assetsHistoricEarnings, assetsWithOrder, _loop, _iterator, _step, _ret;

      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.cachedFetcherGet.fetch();

            case 2:
              cached = _context2.sent;

              if (!cached) {
                _context2.next = 9;
                break;
              }

              if (!addresses) {
                _context2.next = 8;
                break;
              }

              return _context2.abrupt("return", cached.filter(function (vault) {
                return addresses.includes(vault.address);
              }));

            case 8:
              return _context2.abrupt("return", cached);

            case 9:
              vaultMetadataOverridesPromise = this.yearn.services.meta.vaults()["catch"](function (error) {
                console.error(error);
                return Promise.resolve([]);
              });
              _context2.next = 12;
              return Promise.all([vaultMetadataOverridesPromise, this.getStatic(addresses, overrides)]);

            case 12:
              _yield$Promise$all = _context2.sent;
              vaultMetadataOverrides = _yield$Promise$all[0];
              assetsStatic = _yield$Promise$all[1];
              assetsDynamic = [];
              _context2.prev = 16;
              _context2.next = 19;
              return this.getDynamic(addresses, vaultMetadataOverrides, overrides);

            case 19:
              assetsDynamic = _context2.sent;
              _context2.next = 30;
              break;

            case 22:
              _context2.prev = 22;
              _context2.t0 = _context2["catch"](16);
              allAddresses = assetsStatic.map(function (asset) {
                return asset.address;
              });
              chunks = chunkArray(allAddresses, 30);
              promises = chunks.map( /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(chunk) {
                  return runtime_1.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          return _context.abrupt("return", _this2.getDynamic(chunk, vaultMetadataOverrides, overrides));

                        case 1:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee);
                }));

                return function (_x3) {
                  return _ref.apply(this, arguments);
                };
              }());
              _context2.next = 29;
              return Promise.all(promises).then(function (chunks) {
                return chunks.flat();
              });

            case 29:
              assetsDynamic = _context2.sent;

            case 30:
              strategiesMetadataPromise = this.yearn.strategies.vaultsStrategiesMetadata(assetsDynamic.map(function (asset) {
                return asset.address;
              }))["catch"](function (error) {
                console.error(error);
                return Promise.resolve([]);
              });
              assetsHistoricEarningsPromise = this.yearn.earnings.assetsHistoricEarnings()["catch"](function (error) {
                console.error(error);
                return Promise.resolve([]);
              });
              _context2.next = 34;
              return Promise.all([strategiesMetadataPromise, assetsHistoricEarningsPromise]);

            case 34:
              _yield$Promise$all2 = _context2.sent;
              strategiesMetadata = _yield$Promise$all2[0];
              assetsHistoricEarnings = _yield$Promise$all2[1];
              assetsWithOrder = [];

              _loop = function _loop() {
                var _overrides$order, _assetsHistoricEarnin;

                var asset = _step.value;
                var dynamic = assetsDynamic.find(function (_ref2) {
                  var address = _ref2.address;
                  return asset.address === address;
                });

                if (!dynamic) {
                  throw new SdkError("Dynamic asset does not exist for " + asset.address);
                }

                var overrides = vaultMetadataOverrides.find(function (override) {
                  return override.address === asset.address;
                });

                if (overrides != null && overrides.hideAlways) {
                  return "continue";
                }

                var order = (_overrides$order = overrides == null ? void 0 : overrides.order) != null ? _overrides$order : Math.max();
                dynamic.metadata.displayName = dynamic.metadata.displayName || asset.name;
                dynamic.metadata.strategies = strategiesMetadata.find(function (metadata) {
                  return metadata.vaultAddress === asset.address;
                });
                dynamic.metadata.historicEarnings = (_assetsHistoricEarnin = assetsHistoricEarnings.find(function (earnings) {
                  return earnings.assetAddress === asset.address;
                })) == null ? void 0 : _assetsHistoricEarnin.dayData;
                assetsWithOrder.push({
                  vault: _extends({}, asset, dynamic),
                  order: order
                });
              };

              _iterator = _createForOfIteratorHelperLoose(assetsStatic);

            case 40:
              if ((_step = _iterator()).done) {
                _context2.next = 46;
                break;
              }

              _ret = _loop();

              if (!(_ret === "continue")) {
                _context2.next = 44;
                break;
              }

              return _context2.abrupt("continue", 44);

            case 44:
              _context2.next = 40;
              break;

            case 46:
              return _context2.abrupt("return", assetsWithOrder.sort(function (lhs, rhs) {
                return lhs.order - rhs.order;
              }).map(function (asset) {
                return asset.vault;
              }));

            case 47:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this, [[16, 22]]);
    }));

    function get(_x, _x2) {
      return _get.apply(this, arguments);
    }

    return get;
  }()
  /**
   * Get static part of yearn vaults.
   * @param addresses filter, if not provided all positions are returned
   * @param overrides
   * @returns
   */
  ;

  _proto.getStatic =
  /*#__PURE__*/
  function () {
    var _getStatic = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(addresses, overrides) {
      var adapters;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              adapters = Object.values(this.yearn.services.lens.adapters.vaults);
              _context4.next = 3;
              return Promise.all(adapters.map( /*#__PURE__*/function () {
                var _ref3 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(adapter) {
                  return runtime_1.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          _context3.next = 2;
                          return adapter.assetsStatic(addresses, overrides);

                        case 2:
                          return _context3.abrupt("return", _context3.sent);

                        case 3:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3);
                }));

                return function (_x6) {
                  return _ref3.apply(this, arguments);
                };
              }())).then(function (arr) {
                return arr.flat();
              });

            case 3:
              return _context4.abrupt("return", _context4.sent);

            case 4:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function getStatic(_x4, _x5) {
      return _getStatic.apply(this, arguments);
    }

    return getStatic;
  }()
  /**
   * Get dynamic part of yearn vaults.
   * @param addresses filter, if not provided all positions are returned
   * @param overrides
   * @returns
   */
  ;

  _proto.getDynamic =
  /*#__PURE__*/
  function () {
    var _getDynamic = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(addresses, vaultMetadataOverrides, overrides) {
      var _this3 = this;

      var cached, metadataOverrides, adapters;
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.cachedFetcherGetDynamic.fetch();

            case 2:
              cached = _context6.sent;

              if (!cached) {
                _context6.next = 5;
                break;
              }

              return _context6.abrupt("return", addresses ? cached.filter(function (vault) {
                return addresses.includes(vault.address);
              }) : cached);

            case 5:
              if (!vaultMetadataOverrides) {
                _context6.next = 9;
                break;
              }

              _context6.t0 = vaultMetadataOverrides;
              _context6.next = 12;
              break;

            case 9:
              _context6.next = 11;
              return this.yearn.services.meta.vaults()["catch"](function (error) {
                console.error(error);
                return Promise.resolve([]);
              });

            case 11:
              _context6.t0 = _context6.sent;

            case 12:
              metadataOverrides = _context6.t0;
              adapters = Object.values(this.yearn.services.lens.adapters.vaults);
              _context6.next = 16;
              return Promise.all(adapters.map( /*#__PURE__*/function () {
                var _ref4 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(adapter) {
                  var data, assetsApy;
                  return runtime_1.wrap(function _callee5$(_context5) {
                    while (1) {
                      switch (_context5.prev = _context5.next) {
                        case 0:
                          _context5.next = 2;
                          return adapter.assetsDynamic(addresses, overrides);

                        case 2:
                          data = _context5.sent;
                          _context5.next = 5;
                          return _this3.yearn.services.vision.apy(data.map(function (dynamic) {
                            return dynamic.address;
                          }));

                        case 5:
                          assetsApy = _context5.sent;
                          return _context5.abrupt("return", data.map(function (dynamic) {
                            var overrides = metadataOverrides.find(function (override) {
                              return override.address === dynamic.address;
                            });
                            dynamic.metadata.apy = assetsApy[dynamic.address];

                            if (dynamic.tokenId === WethAddress) {
                              var _this3$yearn$services;

                              var icon = (_this3$yearn$services = _this3.yearn.services.asset.icon(EthAddress)) != null ? _this3$yearn$services : "";
                              dynamic.metadata.displayIcon = icon;
                              dynamic.metadata.displayName = "ETH";
                              dynamic.metadata.defaultDisplayToken = EthAddress;
                            } else {
                              var _this3$yearn$services2;

                              var _icon = (_this3$yearn$services2 = _this3.yearn.services.asset.icon(dynamic.tokenId)) != null ? _this3$yearn$services2 : "";

                              dynamic.metadata.displayIcon = _icon;

                              var alias = _this3.yearn.services.asset.alias(dynamic.tokenId);

                              dynamic.metadata.displayName = alias ? alias.symbol : "";
                              dynamic.metadata.defaultDisplayToken = dynamic.tokenId;
                            }

                            if (overrides) {
                              _this3.fillMetadataOverrides(dynamic, overrides);
                            }

                            return dynamic;
                          }));

                        case 7:
                        case "end":
                          return _context5.stop();
                      }
                    }
                  }, _callee5);
                }));

                return function (_x10) {
                  return _ref4.apply(this, arguments);
                };
              }())).then(function (arr) {
                return arr.flat();
              });

            case 16:
              return _context6.abrupt("return", _context6.sent);

            case 17:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function getDynamic(_x7, _x8, _x9) {
      return _getDynamic.apply(this, arguments);
    }

    return getDynamic;
  }()
  /**
   * Get yearn vault positions for a particular address.
   * @param address
   * @param addresses filter, if not provided all positions are returned
   * @param overrides
   * @returns
   */
  ;

  _proto.positionsOf =
  /*#__PURE__*/
  function () {
    var _positionsOf = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(address, addresses, overrides) {
      var _this4 = this;

      var adapters;
      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              adapters = Object.values(this.yearn.services.lens.adapters.vaults);
              _context9.next = 3;
              return Promise.all(adapters.map( /*#__PURE__*/function () {
                var _ref5 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(adapter) {
                  var allAddresses, chunks, promises;
                  return runtime_1.wrap(function _callee8$(_context8) {
                    while (1) {
                      switch (_context8.prev = _context8.next) {
                        case 0:
                          _context8.prev = 0;
                          _context8.next = 3;
                          return adapter.positionsOf(address, addresses, overrides);

                        case 3:
                          return _context8.abrupt("return", _context8.sent);

                        case 6:
                          _context8.prev = 6;
                          _context8.t0 = _context8["catch"](0);

                          if (!addresses) {
                            _context8.next = 12;
                            break;
                          }

                          allAddresses = addresses;
                          _context8.next = 15;
                          break;

                        case 12:
                          _context8.next = 14;
                          return _this4.getStatic(addresses, overrides).then(function (assets) {
                            return assets.map(function (asset) {
                              return asset.address;
                            });
                          });

                        case 14:
                          allAddresses = _context8.sent;

                        case 15:
                          chunks = chunkArray(allAddresses, 30);
                          promises = chunks.map( /*#__PURE__*/function () {
                            var _ref6 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(chunk) {
                              return runtime_1.wrap(function _callee7$(_context7) {
                                while (1) {
                                  switch (_context7.prev = _context7.next) {
                                    case 0:
                                      return _context7.abrupt("return", adapter.positionsOf(address, chunk, overrides));

                                    case 1:
                                    case "end":
                                      return _context7.stop();
                                  }
                                }
                              }, _callee7);
                            }));

                            return function (_x15) {
                              return _ref6.apply(this, arguments);
                            };
                          }());
                          _context8.next = 19;
                          return Promise.all(promises).then(function (chunks) {
                            return chunks.flat();
                          });

                        case 19:
                          return _context8.abrupt("return", _context8.sent);

                        case 20:
                        case "end":
                          return _context8.stop();
                      }
                    }
                  }, _callee8, null, [[0, 6]]);
                }));

                return function (_x14) {
                  return _ref5.apply(this, arguments);
                };
              }())).then(function (arr) {
                return arr.flat();
              });

            case 3:
              return _context9.abrupt("return", _context9.sent);

            case 4:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));

    function positionsOf(_x11, _x12, _x13) {
      return _positionsOf.apply(this, arguments);
    }

    return positionsOf;
  }()
  /**
   * Get the Vaults User Summary for a particular address.
   * @param address
   * @returns
   */
  ;

  _proto.summaryOf =
  /*#__PURE__*/
  function () {
    var _summaryOf = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(address) {
      var _yield$this$yearn$ear, earnings, holdings, grossApy, estimatedYearlyYield;

      return runtime_1.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              _context10.next = 2;
              return this.yearn.earnings.accountAssetsData(address);

            case 2:
              _yield$this$yearn$ear = _context10.sent;
              earnings = _yield$this$yearn$ear.earnings;
              holdings = _yield$this$yearn$ear.holdings;
              grossApy = _yield$this$yearn$ear.grossApy;
              estimatedYearlyYield = _yield$this$yearn$ear.estimatedYearlyYield;
              return _context10.abrupt("return", {
                earnings: earnings,
                holdings: holdings,
                grossApy: grossApy,
                estimatedYearlyYield: estimatedYearlyYield
              });

            case 8:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));

    function summaryOf(_x16) {
      return _summaryOf.apply(this, arguments);
    }

    return summaryOf;
  }()
  /**
   * Get the Vault User Metadata for a particular address.
   * @param address
   * @param addresses filter, if provided only those addresses' Vault User Metadata are returned
   * @returns
   */
  ;

  _proto.metadataOf =
  /*#__PURE__*/
  function () {
    var _metadataOf = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(address, addresses) {
      var _yield$this$yearn$ear2, earningsAssetData;

      return runtime_1.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              _context11.next = 2;
              return this.yearn.earnings.accountAssetsData(address);

            case 2:
              _yield$this$yearn$ear2 = _context11.sent;
              earningsAssetData = _yield$this$yearn$ear2.earningsAssetData;

              if (addresses) {
                _context11.next = 6;
                break;
              }

              return _context11.abrupt("return", earningsAssetData);

            case 6:
              return _context11.abrupt("return", earningsAssetData.filter(function (asset) {
                return addresses.includes(asset.assetAddress);
              }));

            case 7:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));

    function metadataOf(_x17, _x18) {
      return _metadataOf.apply(this, arguments);
    }

    return metadataOf;
  }()
  /**
   * Get all yearn vault's underlying token balances for a particular address.
   * @param address
   * @param overrides
   * @returns
   */
  ;

  _proto.balances =
  /*#__PURE__*/
  function () {
    var _balances = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12(address, overrides) {
      var tokens, balances;
      return runtime_1.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 2;
              return this.tokens();

            case 2:
              tokens = _context12.sent;
              _context12.next = 5;
              return this.yearn.services.helper.tokenBalances(address, tokens.map(function (token) {
                return token.address;
              }), overrides);

            case 5:
              balances = _context12.sent;
              return _context12.abrupt("return", balances.map(function (balance) {
                var token = tokens.find(function (token) {
                  return token.address === balance.address;
                });

                if (!token) {
                  throw new SdkError("Token does not exist for Balance(" + balance.address + ")");
                }

                return _extends({}, balance, {
                  token: token
                });
              }));

            case 7:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12, this);
    }));

    function balances(_x19, _x20) {
      return _balances.apply(this, arguments);
    }

    return balances;
  }()
  /**
   * Get all yearn vault's underlying tokens.
   * @param overrides
   * @returns
   */
  ;

  _proto.tokens =
  /*#__PURE__*/
  function () {
    var _tokens = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee15(overrides) {
      var _this5 = this;

      var cached, adapters;
      return runtime_1.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              _context15.next = 2;
              return this.cachedFetcherTokens.fetch();

            case 2:
              cached = _context15.sent;

              if (!cached) {
                _context15.next = 5;
                break;
              }

              return _context15.abrupt("return", cached);

            case 5:
              adapters = Object.values(this.yearn.services.lens.adapters.vaults);
              _context15.next = 8;
              return this.yearn.services.asset.ready;

            case 8:
              _context15.next = 10;
              return Promise.all(adapters.map( /*#__PURE__*/function () {
                var _ref7 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee14(adapter) {
                  var tokenAddresses, icons, tokensPromise, tokensMetadataPromise, _yield$Promise$all3, tokens, tokensMetadata;

                  return runtime_1.wrap(function _callee14$(_context14) {
                    while (1) {
                      switch (_context14.prev = _context14.next) {
                        case 0:
                          _context14.next = 2;
                          return adapter.tokens(overrides);

                        case 2:
                          tokenAddresses = _context14.sent;
                          icons = _this5.yearn.services.asset.icon(tokenAddresses.concat(EthAddress));
                          tokensPromise = _this5.yearn.services.helper.tokens(tokenAddresses, overrides);
                          tokensMetadataPromise = _this5.yearn.tokens.metadata(tokenAddresses);
                          _context14.next = 8;
                          return Promise.all([tokensPromise, tokensMetadataPromise]);

                        case 8:
                          _yield$Promise$all3 = _context14.sent;
                          tokens = _yield$Promise$all3[0];
                          tokensMetadata = _yield$Promise$all3[1];
                          return _context14.abrupt("return", Promise.all(tokens.map( /*#__PURE__*/function () {
                            var _ref8 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee13(token) {
                              var _this5$yearn$services;

                              var tokenMetadata, result, symbolOverride;
                              return runtime_1.wrap(function _callee13$(_context13) {
                                while (1) {
                                  switch (_context13.prev = _context13.next) {
                                    case 0:
                                      tokenMetadata = tokensMetadata.find(function (metadata) {
                                        return metadata.address === token.address;
                                      });
                                      _context13.t0 = _extends;
                                      _context13.t1 = {};
                                      _context13.t2 = token;
                                      _context13.t3 = icons[token.address];
                                      _context13.t4 = {};
                                      _context13.next = 8;
                                      return _this5.yearn.services.oracle.getPriceUsdc(token.address, overrides);

                                    case 8:
                                      _context13.t5 = _context13.sent;
                                      _context13.t6 = tokenMetadata;
                                      _context13.t7 = {
                                        icon: _context13.t3,
                                        supported: _context13.t4,
                                        priceUsdc: _context13.t5,
                                        metadata: _context13.t6
                                      };
                                      result = (0, _context13.t0)(_context13.t1, _context13.t2, _context13.t7);
                                      symbolOverride = (_this5$yearn$services = _this5.yearn.services.asset.alias(token.address)) == null ? void 0 : _this5$yearn$services.symbol;

                                      if (symbolOverride) {
                                        result.symbol = symbolOverride;
                                      }

                                      if (tokenMetadata) {
                                        _this5.fillTokenMetadataOverrides(result, tokenMetadata);
                                      }

                                      return _context13.abrupt("return", result);

                                    case 16:
                                    case "end":
                                      return _context13.stop();
                                  }
                                }
                              }, _callee13);
                            }));

                            return function (_x23) {
                              return _ref8.apply(this, arguments);
                            };
                          }())));

                        case 12:
                        case "end":
                          return _context14.stop();
                      }
                    }
                  }, _callee14);
                }));

                return function (_x22) {
                  return _ref7.apply(this, arguments);
                };
              }())).then(function (arr) {
                return arr.flat();
              });

            case 10:
              return _context15.abrupt("return", _context15.sent);

            case 11:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15, this);
    }));

    function tokens(_x21) {
      return _tokens.apply(this, arguments);
    }

    return tokens;
  }()
  /**
   * Deposit into a yearn vault
   * @param vault
   * @param token
   * @param amount
   * @param account
   * @param overrides
   * @returns transaction
   */
  ;

  _proto.deposit =
  /*#__PURE__*/
  function () {
    var _deposit = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee17(vault, token, amount, account, options, overrides) {
      var _this6 = this;

      var signer, isZappingIntoPickleJar, _yield$this$getStatic, vaultRef, vaultContract, makeTransaction;

      return runtime_1.wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              if (options === void 0) {
                options = {};
              }

              if (overrides === void 0) {
                overrides = {};
              }

              signer = this.ctx.provider.write.getSigner(account);
              isZappingIntoPickleJar = PickleJars.includes(vault);

              if (!isZappingIntoPickleJar) {
                _context17.next = 6;
                break;
              }

              return _context17.abrupt("return", this.zapIn(vault, token, amount, account, options, ZapProtocol.PICKLE, overrides));

            case 6:
              _context17.next = 8;
              return this.getStatic([vault], overrides);

            case 8:
              _yield$this$getStatic = _context17.sent;
              vaultRef = _yield$this$getStatic[0];

              if (!(vaultRef.token === token)) {
                _context17.next = 20;
                break;
              }

              if (!(token === EthAddress)) {
                _context17.next = 15;
                break;
              }

              throw new SdkError("deposit:v2:eth not implemented");

            case 15:
              vaultContract = new Contract(vault, VaultAbi$1, signer);

              makeTransaction = /*#__PURE__*/function () {
                var _ref9 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee16(overrides) {
                  var tx;
                  return runtime_1.wrap(function _callee16$(_context16) {
                    while (1) {
                      switch (_context16.prev = _context16.next) {
                        case 0:
                          _context16.next = 2;
                          return vaultContract.populateTransaction.deposit(amount, overrides);

                        case 2:
                          tx = _context16.sent;
                          return _context16.abrupt("return", _this6.yearn.services.transaction.sendTransaction(tx));

                        case 4:
                        case "end":
                          return _context16.stop();
                      }
                    }
                  }, _callee16);
                }));

                return function makeTransaction(_x30) {
                  return _ref9.apply(this, arguments);
                };
              }();

              return _context17.abrupt("return", this.executeVaultContractTransaction(makeTransaction, overrides));

            case 18:
              _context17.next = 21;
              break;

            case 20:
              return _context17.abrupt("return", this.zapIn(vault, token, amount, account, options, ZapProtocol.YEARN, overrides));

            case 21:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17, this);
    }));

    function deposit(_x24, _x25, _x26, _x27, _x28, _x29) {
      return _deposit.apply(this, arguments);
    }

    return deposit;
  }()
  /**
   * Withdraw from a yearn vault.
   * @param vault
   * @param token
   * @param amount
   * @param account
   * @param overrides
   * @returns transaction
   */
  ;

  _proto.withdraw =
  /*#__PURE__*/
  function () {
    var _withdraw = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee19(vault, token, amount, account, options, overrides) {
      var _this7 = this;

      var _yield$this$getStatic2, vaultRef, signer, vaultContract, makeTransaction, zapOutParams, transactionRequest;

      return runtime_1.wrap(function _callee19$(_context19) {
        while (1) {
          switch (_context19.prev = _context19.next) {
            case 0:
              if (options === void 0) {
                options = {};
              }

              if (overrides === void 0) {
                overrides = {};
              }

              _context19.next = 4;
              return this.getStatic([vault], overrides);

            case 4:
              _yield$this$getStatic2 = _context19.sent;
              vaultRef = _yield$this$getStatic2[0];
              signer = this.ctx.provider.write.getSigner(account);

              if (!(vaultRef.token === token)) {
                _context19.next = 13;
                break;
              }

              vaultContract = new Contract(vault, VaultAbi$1, signer);

              makeTransaction = /*#__PURE__*/function () {
                var _ref10 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee18(overrides) {
                  var tx;
                  return runtime_1.wrap(function _callee18$(_context18) {
                    while (1) {
                      switch (_context18.prev = _context18.next) {
                        case 0:
                          _context18.next = 2;
                          return vaultContract.populateTransaction.withdraw(amount, overrides);

                        case 2:
                          tx = _context18.sent;
                          return _context18.abrupt("return", _this7.yearn.services.transaction.sendTransaction(tx));

                        case 4:
                        case "end":
                          return _context18.stop();
                      }
                    }
                  }, _callee18);
                }));

                return function makeTransaction(_x37) {
                  return _ref10.apply(this, arguments);
                };
              }();

              return _context19.abrupt("return", this.executeVaultContractTransaction(makeTransaction, overrides));

            case 13:
              if (!(options.slippage === undefined)) {
                _context19.next = 15;
                break;
              }

              throw new SdkError("zap operations should have a slippage set");

            case 15:
              _context19.next = 17;
              return this.yearn.services.zapper.zapOut(account, token, amount, vault, "0", options.slippage, false, undefined, options.signature);

            case 17:
              zapOutParams = _context19.sent;
              transactionRequest = {
                to: zapOutParams.to,
                from: zapOutParams.from,
                gasPrice: BigNumber$2.from(zapOutParams.gasPrice),
                gasLimit: BigNumber$2.from(zapOutParams.gas),
                data: zapOutParams.data,
                value: BigNumber$2.from(zapOutParams.value)
              };
              return _context19.abrupt("return", this.executeZapperTransaction(transactionRequest, overrides, BigNumber$2.from(zapOutParams.gasPrice)));

            case 20:
            case "end":
              return _context19.stop();
          }
        }
      }, _callee19, this);
    }));

    function withdraw(_x31, _x32, _x33, _x34, _x35, _x36) {
      return _withdraw.apply(this, arguments);
    }

    return withdraw;
  }();

  _proto.zapIn = /*#__PURE__*/function () {
    var _zapIn = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee20(vault, token, amount, account, options, zapProtocol, overrides) {
      var zapInParams, transactionRequest;
      return runtime_1.wrap(function _callee20$(_context20) {
        while (1) {
          switch (_context20.prev = _context20.next) {
            case 0:
              if (options === void 0) {
                options = {};
              }

              if (zapProtocol === void 0) {
                zapProtocol = ZapProtocol.YEARN;
              }

              if (overrides === void 0) {
                overrides = {};
              }

              if (!(options.slippage === undefined)) {
                _context20.next = 5;
                break;
              }

              throw new SdkError("zap operations should have a slippage set");

            case 5:
              _context20.next = 7;
              return this.yearn.services.zapper.zapIn(account, token, amount, vault, "0", options.slippage, false, zapProtocol);

            case 7:
              zapInParams = _context20.sent;
              transactionRequest = {
                to: zapInParams.to,
                from: zapInParams.from,
                data: zapInParams.data,
                value: BigNumber$2.from(zapInParams.value),
                gasLimit: BigNumber$2.from(zapInParams.gas)
              };
              return _context20.abrupt("return", this.executeZapperTransaction(transactionRequest, overrides, BigNumber$2.from(zapInParams.gasPrice)));

            case 10:
            case "end":
              return _context20.stop();
          }
        }
      }, _callee20, this);
    }));

    function zapIn(_x38, _x39, _x40, _x41, _x42, _x43, _x44) {
      return _zapIn.apply(this, arguments);
    }

    return zapIn;
  }();

  _proto.executeZapperTransaction = /*#__PURE__*/function () {
    var _executeZapperTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee21(transactionRequest, overrides, fallbackGasPrice) {
      var combinedParams, _combinedParams;

      return runtime_1.wrap(function _callee21$(_context21) {
        while (1) {
          switch (_context21.prev = _context21.next) {
            case 0:
              _context21.prev = 0;
              combinedParams = _extends({}, transactionRequest, overrides);
              combinedParams.gasPrice = undefined;
              _context21.next = 5;
              return this.yearn.services.transaction.sendTransaction(combinedParams);

            case 5:
              return _context21.abrupt("return", _context21.sent);

            case 8:
              _context21.prev = 8;
              _context21.t0 = _context21["catch"](0);

              if (!(_context21.t0.code === -32602)) {
                _context21.next = 18;
                break;
              }

              _combinedParams = _extends({}, transactionRequest, overrides);
              _combinedParams.maxFeePerGas = undefined;
              _combinedParams.maxPriorityFeePerGas = undefined;
              _combinedParams.gasPrice = overrides.gasPrice || fallbackGasPrice;
              _context21.next = 17;
              return this.yearn.services.transaction.sendTransaction(_combinedParams);

            case 17:
              return _context21.abrupt("return", _context21.sent);

            case 18:
              throw _context21.t0;

            case 19:
            case "end":
              return _context21.stop();
          }
        }
      }, _callee21, this, [[0, 8]]);
    }));

    function executeZapperTransaction(_x45, _x46, _x47) {
      return _executeZapperTransaction.apply(this, arguments);
    }

    return executeZapperTransaction;
  }();

  _proto.executeVaultContractTransaction = /*#__PURE__*/function () {
    var _executeVaultContractTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee22(makeTransaction, overrides) {
      var originalGasPrice, tx, _tx;

      return runtime_1.wrap(function _callee22$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              originalGasPrice = overrides.gasPrice;
              _context22.prev = 1;
              overrides.gasPrice = undefined;
              _context22.next = 5;
              return makeTransaction(overrides);

            case 5:
              tx = _context22.sent;
              return _context22.abrupt("return", tx);

            case 9:
              _context22.prev = 9;
              _context22.t0 = _context22["catch"](1);

              if (!(_context22.t0.code === -32602)) {
                _context22.next = 19;
                break;
              }

              overrides.maxFeePerGas = undefined;
              overrides.maxPriorityFeePerGas = undefined;
              overrides.gasPrice = originalGasPrice;
              _context22.next = 17;
              return makeTransaction(overrides);

            case 17:
              _tx = _context22.sent;
              return _context22.abrupt("return", _tx);

            case 19:
              throw _context22.t0;

            case 20:
            case "end":
              return _context22.stop();
          }
        }
      }, _callee22, null, [[1, 9]]);
    }));

    function executeVaultContractTransaction(_x48, _x49) {
      return _executeVaultContractTransaction.apply(this, arguments);
    }

    return executeVaultContractTransaction;
  }();

  _proto.fillTokenMetadataOverrides = function fillTokenMetadataOverrides(token, overrides) {
    if (overrides.tokenIconOverride) {
      token.icon = overrides.tokenIconOverride;
    }

    if (overrides.tokenSymbolOverride) {
      token.symbol = overrides.tokenSymbolOverride;
    }

    if (overrides.tokenNameOverride) {
      token.name = overrides.tokenNameOverride;
    }
  };

  _proto.fillMetadataOverrides = function fillMetadataOverrides(dynamic, overrides) {
    if (overrides.displayName) {
      dynamic.metadata.displayName = overrides.displayName;
    }

    if (overrides.vaultSymbolOverride) {
      dynamic.metadata.symbol = overrides.vaultSymbolOverride;
    }

    if (overrides.vaultIconOverride) {
      dynamic.metadata.displayIcon = overrides.vaultIconOverride;
    }

    if (overrides.apyTypeOverride) {
      if (!dynamic.metadata.apy) {
        dynamic.metadata.apy = this.makeEmptyApy();
      }

      dynamic.metadata.apy.type = overrides.apyTypeOverride;
    }

    if (overrides.apyOverride) {
      if (!dynamic.metadata.apy) {
        dynamic.metadata.apy = this.makeEmptyApy();
      }

      dynamic.metadata.apy.net_apy = overrides.apyOverride;
      dynamic.metadata.apy.type = "override";
    }

    dynamic.metadata.depositsDisabled = overrides.depositsDisabled;
    dynamic.metadata.withdrawalsDisabled = overrides.withdrawalsDisabled;
    dynamic.metadata.allowZapIn = overrides.allowZapIn;
    dynamic.metadata.allowZapOut = overrides.allowZapOut;
    dynamic.metadata.migrationContract = overrides.migrationContract;
    dynamic.metadata.migrationTargetVault = overrides.migrationTargetVault;
    dynamic.metadata.vaultNameOverride = overrides.vaultNameOverride;
    dynamic.metadata.vaultDetailPageAssets = overrides.vaultDetailPageAssets;
    dynamic.metadata.hideIfNoDeposits = dynamic.metadata.emergencyShutdown || overrides.retired || overrides.migrationAvailable || false;
    dynamic.metadata.migrationAvailable = dynamic.metadata.migrationAvailable || overrides.migrationAvailable || false;
  };

  _proto.makeEmptyApy = function makeEmptyApy() {
    var apy = {
      type: "manual_override",
      gross_apr: 0,
      net_apy: 0,
      fees: {
        performance: null,
        withdrawal: null,
        management: null,
        keep_crv: null,
        cvx_keep_crv: null
      },
      points: null,
      composite: null
    };
    return apy;
  };

  return VaultInterface;
}(ServiceInterface);

/**
 * Storing ABIs in Human-Readable ABI format.
 * https://blog.ricmoo.com/human-readable-contract-abis-in-ethers-js-141902f4d917
 */
var TokenAbi$2 = "tuple(address address, string name, string symbol, uint256 decimals)";
var TokenPriceAbi = "tuple(address address, uint256 priceUsdc)";
var TokenBalanceAbi = "tuple(\n  address address, \n  uint256 priceUsdc, \n  uint256 balance,\n  uint256 balanceUsdc\n)";
var AllowanceAbi = "tuple(address owner, address spender, uint256 amount, address token)";
var AssetStaticAbi = "tuple(\n  address address,\n  string typeId,\n  address token,\n  string name,\n  string version,\n  string symbol,\n  uint8 decimals,\n)";
var AssetDynamicAbi = function AssetDynamicAbi(Metadata) {
  return "tuple(\n  address address, \n  string typeId,\n  address tokenId,\n  tuple(uint256 amount, uint256 amountUsdc) underlyingTokenBalance,\n  " + Metadata + " metadata\n)";
};
var PositionAbi = "tuple(address assetAddress, address tokenAddress, string typeId, uint256 balance," + "tuple(uint256 amount, uint256 amountUsdc) underlyingTokenBalance," + "tuple(address owner, address spender, uint256 amount)[] tokenAllowances," + "tuple(address owner, address spender, uint256 amount)[] assetAllowances)";
var AdapterAbi = function AdapterAbi(Metadata) {
  return ["function assetsStatic() public view returns (" + AssetStaticAbi + "[] memory)", "function assetsStatic(address[] memory) public view returns (" + AssetStaticAbi + "[] memory)", "function assetsDynamic() public view returns (" + AssetDynamicAbi(Metadata) + "[] memory)", "function assetsDynamic(address[] memory) public view returns (" + AssetDynamicAbi(Metadata) + "[] memory)", "function assetsPositionsOf(address) public view returns (" + PositionAbi + "[] memory)", "function assetsPositionsOf(address, address[] memory) public view returns (" + PositionAbi + "[] memory)", "function assetsTokensAddresses() public view returns (address[] memory)"];
};

/**
 * Utility functions to convert raw structures returned from ethers to plain
 * javascript objects.
 *
 * eg.
 *
 * ```javascript
 * [
 *   1,
 *   "hello"
 *   "a": 1,
 *   "b": "hello"
 * ]
 * ```
 *
 * to
 *
 * ```javascript
 * {
 *   "a": 1,
 *   "b": "hello"
 * }
 * ```
 */

function struct(tuple) {
  if (typeof tuple !== "object") return tuple;
  var keys = Object.keys(tuple); // check if tuple is actually an array
  // [1, 2, 3] => array vs [1, 2, 3, "a": 1, "b": 2, "c": 3] => object
  // NOTE: [] are not picked up as array (see *)

  var properties = keys.filter(function (key) {
    return isNaN(Number(key));
  });
  if (properties.length === 0) return structArray(tuple);
  var copy = {};
  properties.forEach(function (property) {
    var value = tuple[property];

    if (typeof value === "object" && !isBigNumberish(value)) {
      // recursive!
      copy[property] = struct(value);
    } else if (Array.isArray(value)) {
      // (*) all empty arrays are picked up here
      copy[property] = value;
    } else if (isBigNumberish(value)) {
      // all BigNumbers are converted to strings
      copy[property] = value.toString();
    } else {
      copy[property] = value;
    }
  });
  return copy;
} // convert arrays

function structArray(tuples) {
  return tuples.map(function (tuple) {
    return struct(tuple);
  });
}

var CyTokenMetadataAbi = "tuple(\n  uint256 totalSuppliedUsdc,\n  uint256 totalBorrowedUsdc,\n  uint256 lendAprBips,\n  uint256 borrowAprBips,\n  uint256 liquidity,\n  uint256 liquidityUsdc,\n  uint256 totalCollateralTokens,\n  uint256 collateralFactor,\n  uint256 collateralCap,\n  bool isActive,\n  uint256 reserveFactor,\n  uint256 exchangeRate\n)";
var CyTokenUserMetadataAbi = "tuple(\n  address assetAddress,\n  bool enteredMarket,\n  uint256 supplyBalanceUsdc,\n  uint256 borrowBalanceUsdc,\n  uint256 collateralBalanceUsdc,\n  uint256 borrowLimitUsdc\n)";
var IronBankUserSummaryAbi = "tuple(\n  uint256 supplyBalanceUsdc,\n  uint256 borrowBalanceUsdc,\n  uint256 borrowLimitUsdc,\n  uint256 utilizationRatioBips\n)";
var CustomAbi = ["function adapterPositionOf(address) external view returns (" + IronBankUserSummaryAbi + " memory)", "function assetsUserMetadata(address) public view returns (" + CyTokenUserMetadataAbi + "[] memory)", "function blocksPerYear() public view returns (uint256)"];
var IronBankAdapter = /*#__PURE__*/function (_ContractService) {
  _inheritsLoose(IronBankAdapter, _ContractService);

  function IronBankAdapter(chainId, ctx) {
    var _ctx$addresses$adapte;

    return _ContractService.call(this, (_ctx$addresses$adapte = ctx.addresses.adapters.ironBank) != null ? _ctx$addresses$adapte : IronBankAdapter.addressByChain(chainId), chainId, ctx) || this;
  }
  /**
   * Get most up-to-date address of the IronBank adapter contract for a
   * particular chain id.
   * @param chainId
   * @returns address
   */


  IronBankAdapter.addressByChain = function addressByChain(chainId) {
    switch (chainId) {
      case 1:
      case 1337:
        return "0x5D03ad44F4Fce73407C73A1779295011691D2e1F";

      case 250:
        return "0xC31E8C238287448f0d0CCF65df40424eeF429940";

      case 42161:
        return "0x7AAd416eB4e16a27b85e7076dD56742A44E9d25B";
    }
  }
  /**
   * Get the static part of IronBank assets.
   * @param addresses filter, if not provided all assets are returned
   * @param overrides
   * @returns static
   */
  ;

  var _proto = IronBankAdapter.prototype;

  _proto.assetsStatic =
  /*#__PURE__*/
  function () {
    var _assetsStatic = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(addresses, overrides) {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              if (!addresses) {
                _context.next = 5;
                break;
              }

              _context.next = 4;
              return this.contract.read["assetsStatic(address[])"](addresses, overrides).then(structArray);

            case 4:
              return _context.abrupt("return", _context.sent);

            case 5:
              _context.next = 7;
              return this.contract.read["assetsStatic()"](overrides).then(structArray);

            case 7:
              return _context.abrupt("return", _context.sent);

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function assetsStatic(_x, _x2) {
      return _assetsStatic.apply(this, arguments);
    }

    return assetsStatic;
  }()
  /**
   * Get the dynamic part of IronBank assets.
   * @param addresses filter, if not provided all assets are returned
   * @param overrides
   * @returns dynamic
   */
  ;

  _proto.assetsDynamic =
  /*#__PURE__*/
  function () {
    var _assetsDynamic = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(addresses, overrides) {
      var assetsPromise, _yield$Promise$all, assets, blocksPerYear, _iterator, _step, asset;

      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              assetsPromise = addresses ? this.contract.read["assetsDynamic(address[])"](addresses, overrides).then(structArray) : this.contract.read["assetsDynamic()"](overrides).then(structArray);
              _context2.next = 4;
              return Promise.all([assetsPromise, this.blocksPerYear()]);

            case 4:
              _yield$Promise$all = _context2.sent;
              assets = _yield$Promise$all[0];
              blocksPerYear = _yield$Promise$all[1];

              for (_iterator = _createForOfIteratorHelperLoose(assets); !(_step = _iterator()).done;) {
                asset = _step.value;
                asset.metadata.lendApyBips = this.aprBipsToApyBips(asset.metadata.lendAprBips, blocksPerYear);
                asset.metadata.borrowApyBips = this.aprBipsToApyBips(asset.metadata.borrowAprBips, blocksPerYear);
              }

              return _context2.abrupt("return", assets);

            case 9:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function assetsDynamic(_x3, _x4) {
      return _assetsDynamic.apply(this, arguments);
    }

    return assetsDynamic;
  }()
  /**
   * Get all IronBankMarket asset positions for a particular address.
   * @param address
   * @param addresses filter, if not provided all positions are returned
   * @param overrides
   * @returns
   */
  ;

  _proto.positionsOf =
  /*#__PURE__*/
  function () {
    var _positionsOf = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(address, addresses, overrides) {
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              if (!addresses) {
                _context3.next = 5;
                break;
              }

              _context3.next = 4;
              return this.contract.read["assetsPositionsOf(address,address[])"](address, addresses, overrides).then(structArray);

            case 4:
              return _context3.abrupt("return", _context3.sent);

            case 5:
              _context3.next = 7;
              return this.contract.read["assetsPositionsOf(address)"](address, overrides).then(structArray);

            case 7:
              return _context3.abrupt("return", _context3.sent);

            case 8:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function positionsOf(_x5, _x6, _x7) {
      return _positionsOf.apply(this, arguments);
    }

    return positionsOf;
  }()
  /**
   * Get the IronBank Position for a particular address.
   * @param address
   * @param overrides
   * @returns
   */
  ;

  _proto.generalPositionOf =
  /*#__PURE__*/
  function () {
    var _generalPositionOf = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(address, overrides) {
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context4.next = 3;
              return this.contract.read.adapterPositionOf(address, overrides).then(struct);

            case 3:
              return _context4.abrupt("return", _context4.sent);

            case 4:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function generalPositionOf(_x8, _x9) {
      return _generalPositionOf.apply(this, arguments);
    }

    return generalPositionOf;
  }()
  /**
   * Get the IronBank User Metadata for a particular address.
   * @param address
   * @param overrides
   * @returns
   */
  ;

  _proto.assetsUserMetadata =
  /*#__PURE__*/
  function () {
    var _assetsUserMetadata = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(address, addresses, overrides) {
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              if (!addresses) {
                _context5.next = 5;
                break;
              }

              _context5.next = 4;
              return this.contract.read["assetsUserMetadata(address,address[])"](address, addresses, overrides).then(structArray);

            case 4:
              return _context5.abrupt("return", _context5.sent);

            case 5:
              _context5.next = 7;
              return this.contract.read["assetsUserMetadata(address)"](address, overrides).then(structArray);

            case 7:
              return _context5.abrupt("return", _context5.sent);

            case 8:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function assetsUserMetadata(_x10, _x11, _x12) {
      return _assetsUserMetadata.apply(this, arguments);
    }

    return assetsUserMetadata;
  }()
  /**
   * Get all IronBank underlying token addresses.
   * @param overrides
   * @returns
   */
  ;

  _proto.tokens =
  /*#__PURE__*/
  function () {
    var _tokens = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(overrides) {
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context6.next = 3;
              return this.contract.read.assetsTokensAddresses(overrides);

            case 3:
              return _context6.abrupt("return", _context6.sent);

            case 4:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function tokens(_x13) {
      return _tokens.apply(this, arguments);
    }

    return tokens;
  }();

  _proto.blocksPerYear = /*#__PURE__*/function () {
    var _blocksPerYear = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(overrides) {
      var blocks;
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context7.next = 3;
              return this.contract.read["blocksPerYear"](overrides);

            case 3:
              blocks = _context7.sent;
              return _context7.abrupt("return", blocks.toString());

            case 5:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function blocksPerYear(_x14) {
      return _blocksPerYear.apply(this, arguments);
    }

    return blocksPerYear;
  }();

  _proto.aprBipsToApyBips = function aprBipsToApyBips(aprBips, period) {
    var bn = BigNumber.clone({
      POW_PRECISION: 6
    });
    var apy = new bn(aprBips).div(new bn(10).pow(4)).div(period).plus(1).pow(period).minus(1).multipliedBy(new bn(10).pow(4)).toFixed(0);
    return apy;
  };

  return IronBankAdapter;
}(ContractService);
IronBankAdapter.abi = /*#__PURE__*/AdapterAbi(CyTokenMetadataAbi).concat(CustomAbi);

var VaultV2MetadataAbi = "tuple(\n  uint256 pricePerShare,\n  bool migrationAvailable,\n  address latestVaultAddress,\n  uint256 depositLimit,\n  bool emergencyShutdown\n)";
var RegistryV2Adapter = /*#__PURE__*/function (_ContractService) {
  _inheritsLoose(RegistryV2Adapter, _ContractService);

  function RegistryV2Adapter(chainId, ctx) {
    var _ctx$addresses$adapte;

    return _ContractService.call(this, (_ctx$addresses$adapte = ctx.addresses.adapters.registryV2) != null ? _ctx$addresses$adapte : RegistryV2Adapter.addressByChain(chainId), chainId, ctx) || this;
  }
  /**
   * Get most up-to-date address of the Vault V2 adapter contract for a
   * particular chain id.
   * @param chainId
   * @returns address
   */


  RegistryV2Adapter.addressByChain = function addressByChain(chainId) {
    switch (chainId) {
      case 1:
      case 1337:
        return "0x240315db938d44bb124ae619f5fd0269a02d1271";

      case 250:
        return "0xF628Fb7436fFC382e2af8E63DD7ccbaa142E3cd1";

      case 42161:
        return "0x57AA88A0810dfe3f9b71a9b179Dd8bF5F956C46A";
    }
  }
  /**
   * Get the static part of Vault assets.
   * @param addresses filter, if not provided all assets are returned
   * @param overrides
   * @returns static
   */
  ;

  var _proto = RegistryV2Adapter.prototype;

  _proto.assetsStatic =
  /*#__PURE__*/
  function () {
    var _assetsStatic = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(addresses, overrides) {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              if (!addresses) {
                _context.next = 5;
                break;
              }

              _context.next = 4;
              return this.contract.read["assetsStatic(address[])"](addresses, overrides).then(structArray);

            case 4:
              return _context.abrupt("return", _context.sent);

            case 5:
              _context.next = 7;
              return this.contract.read["assetsStatic()"]().then(structArray);

            case 7:
              return _context.abrupt("return", _context.sent);

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function assetsStatic(_x, _x2) {
      return _assetsStatic.apply(this, arguments);
    }

    return assetsStatic;
  }()
  /**
   * Get the dynamic part of Vault assets.
   * @param addresses filter, if not provided all assets are returned
   * @param overrides
   * @returns dynamic
   */
  ;

  _proto.assetsDynamic =
  /*#__PURE__*/
  function () {
    var _assetsDynamic = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(addresses, overrides) {
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              if (!addresses) {
                _context2.next = 5;
                break;
              }

              _context2.next = 4;
              return this.contract.read["assetsDynamic(address[])"](addresses, overrides).then(structArray).then(function (assets) {
                return assets.map(function (asset) {
                  return _extends({}, asset, {
                    metadata: _extends({
                      controller: ZeroAddress,
                      totalAssets: "0",
                      totalSupply: "0"
                    }, asset.metadata)
                  });
                });
              });

            case 4:
              return _context2.abrupt("return", _context2.sent);

            case 5:
              _context2.next = 7;
              return this.contract.read["assetsDynamic()"]().then(structArray).then(function (assets) {
                return assets.map(function (asset) {
                  return _extends({}, asset, {
                    metadata: _extends({
                      controller: ZeroAddress,
                      totalAssets: "0",
                      totalSupply: "0"
                    }, asset.metadata)
                  });
                });
              });

            case 7:
              return _context2.abrupt("return", _context2.sent);

            case 8:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function assetsDynamic(_x3, _x4) {
      return _assetsDynamic.apply(this, arguments);
    }

    return assetsDynamic;
  }()
  /**
   * Get all Vault asset positions for a particular address.
   * @param address
   * @param addresses filter, if not provided all positions are returned
   * @param overrides
   * @returns
   */
  ;

  _proto.positionsOf =
  /*#__PURE__*/
  function () {
    var _positionsOf = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(address, addresses, overrides) {
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              if (!addresses) {
                _context3.next = 5;
                break;
              }

              _context3.next = 4;
              return this.contract.read["assetsPositionsOf(address,address[])"](address, addresses, overrides).then(structArray);

            case 4:
              return _context3.abrupt("return", _context3.sent);

            case 5:
              _context3.next = 7;
              return this.contract.read["assetsPositionsOf(address)"](address, overrides).then(structArray);

            case 7:
              return _context3.abrupt("return", _context3.sent);

            case 8:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function positionsOf(_x5, _x6, _x7) {
      return _positionsOf.apply(this, arguments);
    }

    return positionsOf;
  }()
  /**
   * Get all Vault underlying token addresses.
   * @param overrides
   * @returns
   */
  ;

  _proto.tokens =
  /*#__PURE__*/
  function () {
    var _tokens = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(overrides) {
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context4.next = 3;
              return this.contract.read.assetsTokensAddresses(overrides);

            case 3:
              return _context4.abrupt("return", _context4.sent);

            case 4:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function tokens(_x8) {
      return _tokens.apply(this, arguments);
    }

    return tokens;
  }();

  return RegistryV2Adapter;
}(ContractService);
RegistryV2Adapter.abi = /*#__PURE__*/AdapterAbi(VaultV2MetadataAbi);

var YearnAliases = "https://raw.githubusercontent.com/yearn/yearn-assets/master/icons/aliases.json";

var YearnAssets = function YearnAssets(chainId) {
  return "https://api.github.com/repos/yearn/yearn-assets/contents/icons/multichain-tokens/" + chainId;
};

var TrustAssets = "https://raw.githack.com/trustwallet/assets/master/blockchains/ethereum/tokenlist.json";

var YearnAsset = function YearnAsset(address, chainId) {
  return "https://raw.githack.com/yearn/yearn-assets/master/icons/multichain-tokens/" + chainId + "/" + address + "/logo-128.png";
};

var YearnAssetAlt = function YearnAssetAlt(address, chainId) {
  return "https://raw.githack.com/yearn/yearn-assets/master/icons/multichain-tokens/" + chainId + "/" + address + "/logo-alt-128.png";
};

var TrustAsset = function TrustAsset(address) {
  return "https://raw.githack.com/trustwallet/assets/master/blockchains/ethereum/assets/" + address + "/logo.png";
};
/**
 * [[AssetService]] fetches correct icons & aliases related to eth addresses
 * from trusted asset sources
 */


var AssetService = /*#__PURE__*/function (_Service) {
  _inheritsLoose(AssetService, _Service);

  function AssetService(chainId, ctx, state) {
    var _this;

    _this = _Service.call(this, chainId, ctx) || this;
    _this.alts = [WethAddress];

    if (state) {
      _this.supported = state.supported;
      _this.aliases = state.aliases;
      _this.ready = Promise.resolve();
    } else {
      _this.supported = new Map();
      _this.aliases = new Map();
      _this.ready = _this.initialize();
    }

    return _this;
  }

  AssetService.deserializeState = function deserializeState(data) {
    var obj = JSON.parse(data);
    var supported = new Map(JSON.parse(obj.supported));
    var aliases = new Map(JSON.parse(obj.aliases));
    return {
      supported: supported,
      aliases: aliases
    };
  };

  var _proto = AssetService.prototype;

  _proto.makeSerializedState = /*#__PURE__*/function () {
    var _makeSerializedState = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      var supportedJson, aliasesJson;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.ready;

            case 2:
              supportedJson = JSON.stringify(Array.from(this.supported.entries()));
              aliasesJson = JSON.stringify(Array.from(this.aliases.entries()));
              return _context.abrupt("return", JSON.stringify({
                supported: supportedJson,
                aliases: aliasesJson
              }));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function makeSerializedState() {
      return _makeSerializedState.apply(this, arguments);
    }

    return makeSerializedState;
  }();

  _proto.initialize = /*#__PURE__*/function () {
    var _initialize = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
      var aliases, _iterator, _step, alias, trust, _iterator2, _step2, token, yearn, _iterator3, _step3, _token;

      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(this.chainId === 1 || this.chainId === 1337)) {
                _context2.next = 9;
                break;
              }

              _context2.next = 3;
              return fetch$1(YearnAliases).then(handleHttpError).then(function (res) {
                return res.json();
              })["catch"](function (error) {
                console.error(error);
                return [];
              });

            case 3:
              aliases = _context2.sent;

              for (_iterator = _createForOfIteratorHelperLoose(aliases); !(_step = _iterator()).done;) {
                alias = _step.value;
                this.aliases.set(alias.address, alias);
              }

              _context2.next = 7;
              return fetch$1(TrustAssets).then(handleHttpError).then(function (res) {
                return res.json();
              }).then(function (res) {
                return res.tokens;
              })["catch"](function (error) {
                console.error(error);
                return [];
              });

            case 7:
              trust = _context2.sent;

              for (_iterator2 = _createForOfIteratorHelperLoose(trust); !(_step2 = _iterator2()).done;) {
                token = _step2.value;
                this.supported.set(token.address, TrustAsset(token.address));
              }

            case 9:
              _context2.next = 11;
              return fetch$1(YearnAssets(this.chainId)).then(handleHttpError).then(function (res) {
                return res.json();
              })["catch"](function (error) {
                console.error(error);
                return [];
              });

            case 11:
              yearn = _context2.sent;

              for (_iterator3 = _createForOfIteratorHelperLoose(yearn); !(_step3 = _iterator3()).done;) {
                _token = _step3.value;
                this.supported.set(_token.name, YearnAsset(_token.name, this.chainId));

                if (this.alts.includes(_token.name)) {
                  this.supported.set(_token.name, YearnAssetAlt(_token.name, this.chainId));
                } else {
                  this.supported.set(_token.name, YearnAsset(_token.name, this.chainId));
                }
              }

            case 13:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function initialize() {
      return _initialize.apply(this, arguments);
    }

    return initialize;
  }();

  _proto.icon = function icon(address) {
    var _this2 = this;

    if (!Array.isArray(address)) {
      return this.supported.get(address);
    }

    return Object.fromEntries(address.map(function (address) {
      return [address, _this2.supported.get(address)];
    }));
  };

  _proto.alias = function alias(address) {
    var _this3 = this;

    if (!Array.isArray(address)) {
      return this.aliases.get(address);
    }

    return Object.fromEntries(address.map(function (address) {
      return [address, _this3.aliases.get(address)];
    }));
  };

  return AssetService;
}(Service);

var LensAbi = ["function getRegistries() external view returns (address[] memory)"];
/**
 * [[LensService]] provides access to all yearn's assets and user positions.
 * It's implemented in the form of a contract that lives on all networks
 * supported by yearn.
 */

var LensService = /*#__PURE__*/function (_ContractService) {
  _inheritsLoose(LensService, _ContractService);

  function LensService(chainId, ctx) {
    var _ctx$addresses$lens;

    return _ContractService.call(this, (_ctx$addresses$lens = ctx.addresses.lens) != null ? _ctx$addresses$lens : LensService.addressByChain(chainId), chainId, ctx) || this;
  }

  /**
   * Get most up-to-date address of the Lens contract for a particular chain id.
   * @param chainId
   * @returns address
   */
  LensService.addressByChain = function addressByChain(chainId) {
    switch (chainId) {
      case 1: // FIXME: doesn't actually exist

      case 250: // ditto

      case 1337: // ditto

      case 42161:
        // ditto
        return "0xFa58130BE296EDFA23C42a1d15549fA91449F979";
    }
  }
  /**
   * Get all the adapter addresses attached to Lens.
   * @param overrides
   * @returns list of registry addresses
   */
  ;

  var _proto = LensService.prototype;

  _proto.getAdapters =
  /*#__PURE__*/
  function () {
    var _getAdapters = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(overrides) {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context.next = 3;
              return this.contract.read.getRegistries(overrides);

            case 3:
              return _context.abrupt("return", _context.sent);

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function getAdapters(_x) {
      return _getAdapters.apply(this, arguments);
    }

    return getAdapters;
  }()
  /**
   * Get all the assets from all the adapters attached to Lens.
   * @param overrides
   * @returns list of assets
   */
  ;

  _proto.getAssets =
  /*#__PURE__*/
  function () {
    var _getAssets = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(overrides) {
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context2.next = 3;
              return this.contract.read.getAssets(overrides).then(structArray);

            case 3:
              return _context2.abrupt("return", _context2.sent);

            case 4:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function getAssets(_x2) {
      return _getAssets.apply(this, arguments);
    }

    return getAssets;
  }()
  /**
   * Get all positions of a particular assets for all the assets in all the
   * adapters attached to lens.
   * @param address
   * @param overrides
   * @returns list of user positions
   */
  ;

  _proto.getPositions =
  /*#__PURE__*/
  function () {
    var _getPositions = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(address, overrides) {
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context3.next = 3;
              return this.contract.read.getPositionsOf(address, overrides).then(structArray);

            case 3:
              return _context3.abrupt("return", _context3.sent);

            case 4:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function getPositions(_x3, _x4) {
      return _getPositions.apply(this, arguments);
    }

    return getPositions;
  }()
  /**
   * Get all the assets from a specific Lens adapter.
   * @param adapter
   * @param overrides
   * @returns list of assets
   */
  ;

  _proto.getAssetsFromAdapter =
  /*#__PURE__*/
  function () {
    var _getAssetsFromAdapter = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(adapter, overrides) {
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context4.next = 3;
              return this.contract.read.getAssetsFromAdapter(adapter, overrides).then(structArray);

            case 3:
              return _context4.abrupt("return", _context4.sent);

            case 4:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function getAssetsFromAdapter(_x5, _x6) {
      return _getAssetsFromAdapter.apply(this, arguments);
    }

    return getAssetsFromAdapter;
  }();

  _createClass(LensService, [{
    key: "adapters",
    get: function get() {
      return {
        vaults: {
          v2: new RegistryV2Adapter(this.chainId, this.ctx)
        },
        ironBank: new IronBankAdapter(this.chainId, this.ctx)
      };
    }
  }]);

  return LensService;
}(ContractService);
LensService.abi = LensAbi;

var OracleAbi = [// Oracle general
"function calculations() external view returns (address[] memory)", "function getPriceUsdcRecommended(address) public view returns (uint256)", "function usdcAddress() public view returns (address)", "function getNormalizedValueUsdc(address,uint256) view returns (uint256)", // Calculations Curve
"function isCurveLpToken(address) public view returns (bool)", "function getCurvePriceUsdc(address) public view returns (uint256)", "function getBasePrice(address) public view returns (uint256)", "function getVirtualPrice(address) public view returns (uint256)", "function curveRegistryAddress() public view returns (address)", // Calculations Iron Bank
"function isIronBankMarket(address) public view returns (bool)", "function getIronBankMarketPriceUsdc(address) public view returns (uint256)", "function getIronBankMarkets() public view returns (address[] memory)", // Calculations Sushiswap
"function isLpToken(address) public view returns (bool)", "function getPriceFromRouter(address, address) public view returns (uint256)", "function getPriceFromRouterUsdc(address) public view returns (uint256)", "function getLpTokenTotalLiquidityUsdc(address) public view returns (uint256)", "function getLpTokenPriceUsdc(address) public view returns (uint256)"];
/**
 * [[OracleService]] is the main pricing engine, used by all price calculations.
 * It's implemented in the form of a contract that lives on all networks
 * supported by yearn.
 */

var OracleService = /*#__PURE__*/function (_ContractService) {
  _inheritsLoose(OracleService, _ContractService);

  function OracleService(chainId, ctx) {
    var _ctx$addresses$oracle;

    return _ContractService.call(this, (_ctx$addresses$oracle = ctx.addresses.oracle) != null ? _ctx$addresses$oracle : OracleService.addressByChain(chainId), chainId, ctx) || this;
  }
  /**
   * Get most up-to-date address of the Oracle contract for a particular chain
   * id.
   * @param chainId
   * @returns address
   */


  OracleService.addressByChain = function addressByChain(chainId) {
    switch (chainId) {
      case 1:
      case 1337:
        return "0x83d95e0D5f402511dB06817Aff3f9eA88224B030";

      case 250:
        return "0x57AA88A0810dfe3f9b71a9b179Dd8bF5F956C46A";

      case 42161:
        return "0x043518AB266485dC085a1DB095B8d9C2Fc78E9b9";
    }
  }
  /**
   * Fetch all the active Oracle calculations.
   * @param overrides
   * @returns list of calculations contract addresses
   */
  ;

  var _proto = OracleService.prototype;

  _proto.getCalculations =
  /*#__PURE__*/
  function () {
    var _getCalculations = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(overrides) {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context.next = 3;
              return this.contract.read.calculations(overrides);

            case 3:
              return _context.abrupt("return", _context.sent);

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function getCalculations(_x) {
      return _getCalculations.apply(this, arguments);
    }

    return getCalculations;
  }()
  /**
   * Get the suggested Usdc exchange rate for an token.
   * @param token
   * @param overrides
   * @returns Usdc exchange rate (6 decimals)
   */
  ;

  _proto.getPriceUsdc =
  /*#__PURE__*/
  function () {
    var _getPriceUsdc = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(token, overrides) {
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context2.next = 3;
              return this.contract.read.getPriceUsdcRecommended(token, overrides).then(_int);

            case 3:
              return _context2.abrupt("return", _context2.sent);

            case 4:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function getPriceUsdc(_x2, _x3) {
      return _getPriceUsdc.apply(this, arguments);
    }

    return getPriceUsdc;
  }()
  /**
   * Get the normalized Usdc value for the token and corresponding quantity.
   * @param token
   * @param amount
   * @param overrides
   * @returns Usdc exchange rate (6 decimals)
   */
  ;

  _proto.getNormalizedValueUsdc =
  /*#__PURE__*/
  function () {
    var _getNormalizedValueUsdc = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(token, amount, overrides) {
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context3.next = 3;
              return this.contract.read.getNormalizedValueUsdc(token, amount, overrides).then(_int);

            case 3:
              return _context3.abrupt("return", _context3.sent);

            case 4:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function getNormalizedValueUsdc(_x4, _x5, _x6) {
      return _getNormalizedValueUsdc.apply(this, arguments);
    }

    return getNormalizedValueUsdc;
  }()
  /**
   * Get the token address that lens considers Usdc.
   * @param overrides
   * @returns address
   */
  ;

  _proto.getUsdcAddress =
  /*#__PURE__*/
  function () {
    var _getUsdcAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(overrides) {
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context4.next = 3;
              return this.contract.read.usdcAddress(overrides);

            case 3:
              return _context4.abrupt("return", _context4.sent);

            case 4:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function getUsdcAddress(_x7) {
      return _getUsdcAddress.apply(this, arguments);
    }

    return getUsdcAddress;
  }() // Calculations Curve

  /**
   * Test if a token address is a curve liquidity provider token.
   * @param lpToken
   * @param overrides
   * @returns test result
   */
  ;

  _proto.isCurveLpToken =
  /*#__PURE__*/
  function () {
    var _isCurveLpToken = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(lpToken, overrides) {
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context5.next = 3;
              return this.contract.read.isCurveLpToken(lpToken, overrides);

            case 3:
              return _context5.abrupt("return", _context5.sent);

            case 4:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function isCurveLpToken(_x8, _x9) {
      return _isCurveLpToken.apply(this, arguments);
    }

    return isCurveLpToken;
  }()
  /**
   * Get Usdc exchange rate for a curve liquidity provider token.
   * @param lpToken
   * @param overrides
   * @returns Usdc exchange rate (6 decimals)
   */
  ;

  _proto.getCurvePriceUsdc =
  /*#__PURE__*/
  function () {
    var _getCurvePriceUsdc = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(lpToken, overrides) {
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context6.next = 3;
              return this.contract.read.getCurvePriceUsdc(lpToken, overrides).then(_int);

            case 3:
              return _context6.abrupt("return", _context6.sent);

            case 4:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function getCurvePriceUsdc(_x10, _x11) {
      return _getCurvePriceUsdc.apply(this, arguments);
    }

    return getCurvePriceUsdc;
  }()
  /**
   * Get Usdc exchange rate of underlying token of the curve liquidity provider
   * token's pool.
   * @param lpToken
   * @param overrides
   * @returns Usdc exchange rate (6 decimals)
   */
  ;

  _proto.getBasePrice =
  /*#__PURE__*/
  function () {
    var _getBasePrice = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(lpToken, overrides) {
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context7.next = 3;
              return this.contract.read.getBasePrice(lpToken, overrides).then(_int);

            case 3:
              return _context7.abrupt("return", _context7.sent);

            case 4:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function getBasePrice(_x12, _x13) {
      return _getBasePrice.apply(this, arguments);
    }

    return getBasePrice;
  }()
  /**
   * Get virtual price for a curve liquidity provider token.
   * @param lpToken
   * @param overrides
   * @returns virtual price
   */
  ;

  _proto.getVirtualPrice =
  /*#__PURE__*/
  function () {
    var _getVirtualPrice = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(lpToken, overrides) {
      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context8.next = 3;
              return this.contract.read.getVirtualPrice(lpToken, overrides).then(_int);

            case 3:
              return _context8.abrupt("return", _context8.sent);

            case 4:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function getVirtualPrice(_x14, _x15) {
      return _getVirtualPrice.apply(this, arguments);
    }

    return getVirtualPrice;
  }()
  /**
   * Get the contract address that lens considers as Curve Registry.
   * @param overrides
   * @returns
   */
  ;

  _proto.getCurveRegistryAddress =
  /*#__PURE__*/
  function () {
    var _getCurveRegistryAddress = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(overrides) {
      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context9.next = 3;
              return this.contract.read.usdcAddress(overrides).then(_int);

            case 3:
              return _context9.abrupt("return", _context9.sent);

            case 4:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));

    function getCurveRegistryAddress(_x16) {
      return _getCurveRegistryAddress.apply(this, arguments);
    }

    return getCurveRegistryAddress;
  }() // Calculations: Iron Bank

  /**
   * Test if a token address is an iron bank market.
   * @param token
   * @param overrides
   * @returns test result
   */
  ;

  _proto.isIronBankMarket =
  /*#__PURE__*/
  function () {
    var _isIronBankMarket = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee10(token, overrides) {
      return runtime_1.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context10.next = 3;
              return this.contract.read.isIronBankMarket(token, overrides);

            case 3:
              return _context10.abrupt("return", _context10.sent);

            case 4:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10, this);
    }));

    function isIronBankMarket(_x17, _x18) {
      return _isIronBankMarket.apply(this, arguments);
    }

    return isIronBankMarket;
  }()
  /**
   * Get Usdc exchange rate for an iron bank market token.
   * @param token
   * @param overrides
   * @returns Usdc exchange rate (6 decimals)
   */
  ;

  _proto.getIronBankMarketPriceUsdc =
  /*#__PURE__*/
  function () {
    var _getIronBankMarketPriceUsdc = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee11(token, overrides) {
      return runtime_1.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context11.next = 3;
              return this.contract.read.getIronBankMarketPriceUsdc(token, overrides).then(_int);

            case 3:
              return _context11.abrupt("return", _context11.sent);

            case 4:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11, this);
    }));

    function getIronBankMarketPriceUsdc(_x19, _x20) {
      return _getIronBankMarketPriceUsdc.apply(this, arguments);
    }

    return getIronBankMarketPriceUsdc;
  }()
  /**
   * Get all the iron bank market addresses.
   * @param overrides
   * @returns list of iron bank market addresses
   */
  ;

  _proto.getIronBankMarkets =
  /*#__PURE__*/
  function () {
    var _getIronBankMarkets = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee12(overrides) {
      return runtime_1.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context12.next = 3;
              return this.contract.read.getIronBankMarkets(overrides);

            case 3:
              return _context12.abrupt("return", _context12.sent);

            case 4:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12, this);
    }));

    function getIronBankMarkets(_x21) {
      return _getIronBankMarkets.apply(this, arguments);
    }

    return getIronBankMarkets;
  }() // Calculations: Sushiswap

  /**
   * Test if a token address is a sushiswap liquidity provider token.
   * @param token
   * @param overrides
   * @returns test result
   */
  ;

  _proto.isLpToken =
  /*#__PURE__*/
  function () {
    var _isLpToken = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee13(token, overrides) {
      return runtime_1.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context13.next = 3;
              return this.contract.read.isLpToken(token, overrides);

            case 3:
              return _context13.abrupt("return", _context13.sent);

            case 4:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13, this);
    }));

    function isLpToken(_x22, _x23) {
      return _isLpToken.apply(this, arguments);
    }

    return isLpToken;
  }()
  /**
   * Get exchange rate between two tokens from the sushiswap router.
   * @param token0
   * @param token1
   * @param overrides
   * @returns exchange rate
   */
  ;

  _proto.getPriceFromRouter =
  /*#__PURE__*/
  function () {
    var _getPriceFromRouter = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee14(token0, token1, overrides) {
      return runtime_1.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context14.next = 3;
              return this.contract.read.getPriceFromRouter(token0, token1, overrides).then(_int);

            case 3:
              return _context14.abrupt("return", _context14.sent);

            case 4:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14, this);
    }));

    function getPriceFromRouter(_x24, _x25, _x26) {
      return _getPriceFromRouter.apply(this, arguments);
    }

    return getPriceFromRouter;
  }()
  /**
   * Get Usdc exchange rate for a token.
   * @param token
   * @param overrides
   * @returns Usdc exchange rate (6 decimals)
   */
  ;

  _proto.getPriceFromRouterUsdc =
  /*#__PURE__*/
  function () {
    var _getPriceFromRouterUsdc = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee15(token, overrides) {
      return runtime_1.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context15.next = 3;
              return this.contract.read.getPriceFromRouterUsdc(token, overrides).then(_int);

            case 3:
              return _context15.abrupt("return", _context15.sent);

            case 4:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15, this);
    }));

    function getPriceFromRouterUsdc(_x27, _x28) {
      return _getPriceFromRouterUsdc.apply(this, arguments);
    }

    return getPriceFromRouterUsdc;
  }()
  /**
   * Get total liquidity for a liquidity provider token in Usdc
   * @param token
   * @param overrides
   * @returns Usdc liquidity (6 decimals)
   */
  ;

  _proto.getLpTokenTotalLiquidityUsdc =
  /*#__PURE__*/
  function () {
    var _getLpTokenTotalLiquidityUsdc = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee16(token, overrides) {
      return runtime_1.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context16.next = 3;
              return this.contract.read.getLpTokenTotalLiquidityUsdc(token, overrides).then(_int);

            case 3:
              return _context16.abrupt("return", _context16.sent);

            case 4:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16, this);
    }));

    function getLpTokenTotalLiquidityUsdc(_x29, _x30) {
      return _getLpTokenTotalLiquidityUsdc.apply(this, arguments);
    }

    return getLpTokenTotalLiquidityUsdc;
  }()
  /**
   * Get Usdc exchange rate for a sushiswap liquidity provider token.
   * @param token
   * @param overrides
   * @returns Usdc exchange rate (6 decimals)
   */
  ;

  _proto.getLpTokenPriceUsdc =
  /*#__PURE__*/
  function () {
    var _getLpTokenPriceUsdc = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee17(token, overrides) {
      return runtime_1.wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context17.next = 3;
              return this.contract.read.getLpTokenPriceUsdc(token, overrides).then(_int);

            case 3:
              return _context17.abrupt("return", _context17.sent);

            case 4:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17, this);
    }));

    function getLpTokenPriceUsdc(_x31, _x32) {
      return _getLpTokenPriceUsdc.apply(this, arguments);
    }

    return getLpTokenPriceUsdc;
  }();

  return OracleService;
}(ContractService);
OracleService.abi = OracleAbi;

var SubgraphService = /*#__PURE__*/function (_Service) {
  _inheritsLoose(SubgraphService, _Service);

  function SubgraphService(chainId, ctx) {
    var _this;

    _this = _Service.call(this, chainId, ctx) || this;
    var subgraphName;

    switch (chainId) {
      case 1:
      case 1337:
        subgraphName = "salazarguille/yearn-vaults-v2-subgraph-mainnet";
        break;

      case 250:
        subgraphName = "yearn/yearn-vaults-v2-fantom";
        break;

      case 42161:
        subgraphName = "yearn/yearn-vaults-v2-arbitrum";
        break;

      default:
        throw new SdkError("No subgraph name for chain " + chainId);
    }

    _this.yearnSubgraphEndpoint = "https://api.thegraph.com/subgraphs/name/" + subgraphName;
    return _this;
  }

  var _proto = SubgraphService.prototype;

  _proto.fetchQuery = /*#__PURE__*/function () {
    var _fetchQuery = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(query, variables) {
      var body;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (variables === void 0) {
                variables = {};
              }

              // the subgraph only works with lowercased addresses
              Object.keys(variables).forEach(function (key) {
                var variable = variables[key];

                if (typeof variable === "string") {
                  variables[key] = variable.toLowerCase();
                } else if (Array.isArray(variable)) {
                  for (var _iterator = _createForOfIteratorHelperLoose(variable.entries()), _step; !(_step = _iterator()).done;) {
                    var _step$value = _step.value,
                        index = _step$value[0],
                        value = _step$value[1];

                    if (typeof value === "string") {
                      variable[index] = value.toLowerCase();
                    }
                  }
                }
              });
              body = {
                query: query,
                variables: variables
              };
              _context.next = 5;
              return fetch(this.yearnSubgraphEndpoint, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json"
                },
                body: JSON.stringify(body)
              }).then(function (res) {
                return res.json();
              }).then(function (json) {
                if (json.errors) {
                  throw new SdkError("Subgraph Error - " + JSON.stringify(json.errors));
                }

                return json;
              });

            case 5:
              return _context.abrupt("return", _context.sent);

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function fetchQuery(_x, _x2) {
      return _fetchQuery.apply(this, arguments);
    }

    return fetchQuery;
  }();

  return SubgraphService;
}(Service);

var TelegramService = /*#__PURE__*/function (_Service) {
  _inheritsLoose(TelegramService, _Service);

  function TelegramService() {
    return _Service.apply(this, arguments) || this;
  }

  var _proto = TelegramService.prototype;

  _proto.sendMessage = function sendMessage(text) {
    if (!this.ctx.simulation.telegramChatId || !this.ctx.simulation.telegramBotId) {
      return;
    }

    var params = new URLSearchParams({
      chat_id: this.ctx.simulation.telegramChatId,
      text: text,
      disable_web_page_preview: "true"
    });
    var url = "https://api.telegram.org/bot" + this.ctx.simulation.telegramBotId + "/sendMessage?" + params;
    fetch(url);
  };

  return TelegramService;
}(Service);

/**
 * Fix for backscratcher vaults returning different casing and property names so it's all normalized.
 */

function convertCompositeApyToSnakeCase(apy) {
  return apy ? _extends({}, apy, {
    composite: apy.composite ? _extends({}, apy.composite, {
      boost: apy.composite.boost ? apy.composite.boost : apy.composite.currentBoost,
      pool_apy: apy.composite.pool_apy ? apy.composite.pool_apy : apy.composite.poolApy,
      boosted_apr: apy.composite.boosted_apr ? apy.composite.boosted_apr : apy.composite.boostedApy,
      base_apr: apy.composite.base_apr ? apy.composite.base_apr : apy.composite.baseApy
    }) : null
  }) : undefined;
}
/**
 * [[VisionService]] provides access to off chain apy calculations for yearn
 * products.
 */

var VisionService = /*#__PURE__*/function (_Service) {
  _inheritsLoose(VisionService, _Service);

  function VisionService() {
    return _Service.apply(this, arguments) || this;
  }

  var _proto = VisionService.prototype;

  _proto.apy = /*#__PURE__*/function () {
    var _apy = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(addresses) {
      var url, vaults, map, _loop, _iterator, _step, vault;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              url = "https://d28fcsszptni1s.cloudfront.net/v1/chains/" + this.chainId + "/vaults/all";
              _context.next = 3;
              return fetch(url).then(handleHttpError).then(function (res) {
                return res.json();
              });

            case 3:
              vaults = _context.sent;
              // fix backscratcher apys
              vaults = vaults.map(function (vault) {
                return vault.apy && vault.apy.type === "backscratcher" ? _extends({}, vault, {
                  apy: convertCompositeApyToSnakeCase(vault.apy)
                }) : vault;
              });

              if (!Array.isArray(addresses)) {
                _context.next = 12;
                break;
              }

              map = new Map();

              _loop = function _loop() {
                var address = _step.value;
                var vault = vaults.find(function (vault) {
                  return vault.address === address;
                });
                map.set(address, vault ? vault.apy : undefined);
              };

              for (_iterator = _createForOfIteratorHelperLoose(addresses); !(_step = _iterator()).done;) {
                _loop();
              }

              return _context.abrupt("return", Object.fromEntries(map));

            case 12:
              if (!addresses) {
                _context.next = 19;
                break;
              }

              vault = vaults.find(function (vault) {
                return vault.address === addresses;
              });

              if (vault) {
                _context.next = 16;
                break;
              }

              return _context.abrupt("return", undefined);

            case 16:
              return _context.abrupt("return", vault.apy);

            case 19:
              return _context.abrupt("return", Object.fromEntries(vaults.map(function (vault) {
                return [vault.address, vault.apy];
              })));

            case 20:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function apy(_x) {
      return _apy.apply(this, arguments);
    }

    return apy;
  }();

  return VisionService;
}(Service);

/**
 * Supported chains in the yearn ecosystem.
 */
var Chains = {
  1: "ethereum",
  250: "fantom",
  1337: "ethereum",
  42161: "arbitrum"
};

var ZAPPER_AFFILIATE_ADDRESS = "0xFEB4acf3df3cDEA7399794D0869ef76A6EfAff52";
/**
 * [[ZapperService]] interacts with the zapper api to gather more insight for
 * tokens and user positions.
 */

var ZapperService = /*#__PURE__*/function (_Service) {
  _inheritsLoose(ZapperService, _Service);

  function ZapperService() {
    return _Service.apply(this, arguments) || this;
  }

  var _proto = ZapperService.prototype;

  /**
   * Fetch all the tokens supported by the zapper protocol along with some basic
   * metadata.
   * @returns list of tokens supported by the zapper protocol.
   */
  _proto.supportedTokens =
  /*#__PURE__*/
  function () {
    var _supportedTokens = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      var _Chains$this$chainId;

      var url, params, tokens, network;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              url = "https://api.zapper.fi/v1/prices";
              params = new URLSearchParams({
                api_key: this.ctx.zapper
              });
              _context.next = 4;
              return fetch(url + "?" + params).then(handleHttpError).then(function (res) {
                return res.json();
              });

            case 4:
              tokens = _context.sent;
              network = (_Chains$this$chainId = Chains[this.chainId]) != null ? _Chains$this$chainId : "ethereum";
              return _context.abrupt("return", tokens.map(function (token) {
                var address = token.address === ZeroAddress ? EthAddress : getAddress(String(token.address));
                var supported = token.hide ? !token.hide : true;
                return {
                  address: address,
                  name: token.symbol,
                  symbol: token.symbol,
                  icon: "https://assets.yearn.network/tokens/" + network + "/" + token.address + ".png",
                  decimals: token.decimals,
                  priceUsdc: usdc(token.price),
                  supported: {
                    zapper: supported
                  }
                };
              }));

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function supportedTokens() {
      return _supportedTokens.apply(this, arguments);
    }

    return supportedTokens;
  }();

  _proto.balances = /*#__PURE__*/function () {
    var _balances = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(addresses) {
      var url, params, balances;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              url = "https://api.zapper.fi/v1/protocols/tokens/balances";
              params = new URLSearchParams({
                "addresses[]": Array.isArray(addresses) ? addresses.join() : addresses,
                api_key: this.ctx.zapper
              });
              _context2.next = 4;
              return fetch(url + "?" + params).then(handleHttpError).then(function (res) {
                return res.json();
              });

            case 4:
              balances = _context2.sent;
              Object.keys(balances).forEach(function (address) {
                var copy = balances[address];
                delete balances[address];

                if (copy.products.length === 0) {
                  balances[getAddress(address)] = [];
                } else {
                  var assets = copy.products[0].assets;
                  balances[getAddress(address)] = assets.map(function (balance) {
                    var address = balance.address === ZeroAddress ? EthAddress : getAddress(String(balance.address));
                    return {
                      address: address,
                      token: {
                        address: address,
                        name: balance.symbol,
                        symbol: balance.symbol,
                        decimals: balance.decimals
                      },
                      balance: balance.balanceRaw,
                      balanceUsdc: usdc(balance.balanceUSD),
                      priceUsdc: usdc(balance.price)
                    };
                  });
                }
              });

              if (Array.isArray(addresses)) {
                _context2.next = 8;
                break;
              }

              return _context2.abrupt("return", balances[addresses]);

            case 8:
              return _context2.abrupt("return", balances);

            case 9:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function balances(_x) {
      return _balances.apply(this, arguments);
    }

    return balances;
  }()
  /**
   * Fetch up to date gas prices in gwei
   * @returns gas prices
   */
  ;

  _proto.gas =
  /*#__PURE__*/
  function () {
    var _gas = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3() {
      var url, params, gas;
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              url = "https://api.zapper.fi/v1/gas-price";
              params = new URLSearchParams({
                api_key: this.ctx.zapper
              });
              _context3.next = 4;
              return fetch(url + "?" + params).then(handleHttpError).then(function (res) {
                return res.json();
              });

            case 4:
              gas = _context3.sent;
              return _context3.abrupt("return", gas);

            case 6:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function gas() {
      return _gas.apply(this, arguments);
    }

    return gas;
  }()
  /**
   * Fetches the data needed to check token ZapIn contract approval state
   * @param from - the address that is depositing
   * @param token - the token to be sold to pay for the deposit
   * @param zapProtocol the protocol to use with zapper e.g. Yearn, Pickle
   */
  ;

  _proto.zapInApprovalState =
  /*#__PURE__*/
  function () {
    var _zapInApprovalState = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(from, token, zapProtocol) {
      var url, params, response;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (zapProtocol === void 0) {
                zapProtocol = ZapProtocol.YEARN;
              }

              url = "https://api.zapper.fi/v1/zap-in/vault/" + zapProtocol + "/approval-state";
              params = new URLSearchParams({
                ownerAddress: from,
                sellTokenAddress: token,
                api_key: this.ctx.zapper
              });
              _context4.next = 5;
              return fetch(url + "?" + params).then(handleHttpError).then(function (res) {
                return res.json();
              });

            case 5:
              response = _context4.sent;
              return _context4.abrupt("return", response);

            case 7:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function zapInApprovalState(_x2, _x3, _x4) {
      return _zapInApprovalState.apply(this, arguments);
    }

    return zapInApprovalState;
  }()
  /**
   * Fetches the data needed to approve ZapIn Contract for a token
   * @param from - the address that is depositing
   * @param token - the token to be sold to pay for the deposit
   * @param gasPrice
   * @param zapProtocol the protocol to use with zapper e.g. Yearn, Pickle
   */
  ;

  _proto.zapInApprovalTransaction =
  /*#__PURE__*/
  function () {
    var _zapInApprovalTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(from, token, gasPrice, zapProtocol) {
      var url, params, response;
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (zapProtocol === void 0) {
                zapProtocol = ZapProtocol.YEARN;
              }

              url = "https://api.zapper.fi/v1/zap-in/vault/" + zapProtocol + "/approval-transaction";
              params = new URLSearchParams({
                gasPrice: gasPrice,
                ownerAddress: from,
                sellTokenAddress: token,
                api_key: this.ctx.zapper
              });
              _context5.next = 5;
              return fetch(url + "?" + params).then(handleHttpError).then(function (res) {
                return res.json();
              });

            case 5:
              response = _context5.sent;
              return _context5.abrupt("return", response);

            case 7:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function zapInApprovalTransaction(_x5, _x6, _x7, _x8) {
      return _zapInApprovalTransaction.apply(this, arguments);
    }

    return zapInApprovalTransaction;
  }()
  /**
   * Fetches the data needed to check token ZapOut contract approval state
   * @param from - the address that is withdrawing
   * @param token - the vault token to be withdrawn
   * @param zapProtocol the protocol to use with zapper e.g. Yearn, Pickle
   */
  ;

  _proto.zapOutApprovalState =
  /*#__PURE__*/
  function () {
    var _zapOutApprovalState = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(from, token, zapProtocol) {
      var url, params, response;
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (zapProtocol === void 0) {
                zapProtocol = ZapProtocol.YEARN;
              }

              url = "https://api.zapper.fi/v1/zap-out/vault/" + zapProtocol + "/approval-state";
              params = new URLSearchParams({
                ownerAddress: from,
                sellTokenAddress: token,
                api_key: this.ctx.zapper
              });
              _context6.next = 5;
              return fetch(url + "?" + params).then(handleHttpError).then(function (res) {
                return res.json();
              });

            case 5:
              response = _context6.sent;
              return _context6.abrupt("return", response);

            case 7:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function zapOutApprovalState(_x9, _x10, _x11) {
      return _zapOutApprovalState.apply(this, arguments);
    }

    return zapOutApprovalState;
  }()
  /**
   * Fetches the data needed to approve ZapOut Contract for a token
   * @param from - the address that is withdrawing
   * @param token - the vault token to be withdrawn
   * @param gasPrice
   * @param zapProtocol the protocol to use with zapper e.g. Yearn, Pickle
   */
  ;

  _proto.zapOutApprovalTransaction =
  /*#__PURE__*/
  function () {
    var _zapOutApprovalTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(from, token, gasPrice, zapProtocol) {
      var url, params, response;
      return runtime_1.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (zapProtocol === void 0) {
                zapProtocol = ZapProtocol.YEARN;
              }

              url = "https://api.zapper.fi/v1/zap-out/vault/" + zapProtocol + "/approval-transaction";
              params = new URLSearchParams({
                gasPrice: gasPrice,
                ownerAddress: from,
                sellTokenAddress: token,
                api_key: this.ctx.zapper
              });
              _context7.next = 5;
              return fetch(url + "?" + params).then(handleHttpError).then(function (res) {
                return res.json();
              });

            case 5:
              response = _context7.sent;
              return _context7.abrupt("return", response);

            case 7:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7, this);
    }));

    function zapOutApprovalTransaction(_x12, _x13, _x14, _x15) {
      return _zapOutApprovalTransaction.apply(this, arguments);
    }

    return zapOutApprovalTransaction;
  }()
  /**
   * Fetches the data needed to zap into a vault
   * @param from - the address that is depositing
   * @param token - the token to be sold to pay for the deposit
   * @param amount - the amount of tokens to be sold
   * @param vault - the vault to zap into
   * @param gasPrice
   * @param slippagePercentage - slippage as a decimal
   * @param skipGasEstimate - provide the gasLimit in the response. Should be set to true when simulating a zap without approval
   * @param zapProtocol the protocol to use with zapper e.g. Yearn, Pickle
   */
  ;

  _proto.zapIn =
  /*#__PURE__*/
  function () {
    var _zapIn = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee8(from, token, amount, vault, gasPrice, slippagePercentage, skipGasEstimate, zapProtocol) {
      var sellToken, url, params, response;
      return runtime_1.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              if (zapProtocol === void 0) {
                zapProtocol = ZapProtocol.YEARN;
              }

              sellToken = token;

              if (EthAddress === token) {
                // If Ether is being sent, the sellTokenAddress should be the zero address
                sellToken = ZeroAddress;
              }

              url = "https://api.zapper.fi/v1/zap-in/vault/" + zapProtocol + "/transaction";
              params = new URLSearchParams({
                affiliateAddress: ZAPPER_AFFILIATE_ADDRESS,
                ownerAddress: from,
                sellTokenAddress: sellToken,
                sellAmount: amount,
                poolAddress: vault,
                gasPrice: gasPrice,
                slippagePercentage: slippagePercentage.toString(),
                api_key: this.ctx.zapper,
                skipGasEstimate: skipGasEstimate ? "true" : "false"
              });
              _context8.next = 7;
              return fetch(url + "?" + params).then(handleHttpError).then(function (res) {
                return res.json();
              });

            case 7:
              response = _context8.sent;
              return _context8.abrupt("return", response);

            case 9:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8, this);
    }));

    function zapIn(_x16, _x17, _x18, _x19, _x20, _x21, _x22, _x23) {
      return _zapIn.apply(this, arguments);
    }

    return zapIn;
  }()
  /**
   * Fetches the data needed to zap out of a vault
   * @param from - the address that is withdrawing
   * @param token - the token that'll be received
   * @param amount - the amount of tokens to sell
   * @param vault - the vault to zap out of
   * @param gasPrice
   * @param slippagePercentage - slippage as a decimal
   * @param skipGasEstimate - provide the gasLimit in the response. Should be set to true when simulating a zap without approval
   * @param zapProtocol the protocol to use with zapper e.g. Yearn, Pickle
   * @param signature - the account valid secp256k1 signature of Permit encoded from r, s, v. (https://eips.ethereum.org/EIPS/eip-2612)
   */
  ;

  _proto.zapOut =
  /*#__PURE__*/
  function () {
    var _zapOut = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee9(from, token, amount, vault, gasPrice, slippagePercentage, skipGasEstimate, zapProtocol, signature) {
      var toToken, url, params, response;
      return runtime_1.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              if (zapProtocol === void 0) {
                zapProtocol = ZapProtocol.YEARN;
              }

              toToken = token;

              if (EthAddress === token) {
                // If Ether is being received, the toTokenAddress should be the zero address
                toToken = ZeroAddress;
              }

              url = "https://api.zapper.fi/v1/zap-out/vault/" + zapProtocol + "/transaction";
              params = new URLSearchParams(_extends({
                affiliateAddress: ZAPPER_AFFILIATE_ADDRESS,
                ownerAddress: from,
                toTokenAddress: toToken,
                sellAmount: amount,
                poolAddress: vault,
                gasPrice: gasPrice,
                slippagePercentage: slippagePercentage.toString(),
                api_key: this.ctx.zapper,
                shouldSellEntireBalance: "true",
                skipGasEstimate: skipGasEstimate ? "true" : "false"
              }, signature && {
                signature: signature
              }));
              _context9.next = 7;
              return fetch(url + "?" + params).then(handleHttpError).then(function (res) {
                return res.json();
              });

            case 7:
              response = _context9.sent;
              return _context9.abrupt("return", response);

            case 9:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9, this);
    }));

    function zapOut(_x24, _x25, _x26, _x27, _x28, _x29, _x30, _x31, _x32) {
      return _zapOut.apply(this, arguments);
    }

    return zapOut;
  }();

  return ZapperService;
}(Service);

/**
 * [[AllowListService]] is used to interface with yearn's deployed AllowList contract. The purpose of it is to be able to
 * validate that all interactions that are about to be written to the blockchain follow the set of rules that the AllowList defines on chain.
 * It should be used to validate any transaction before it is written. For example, it can be used to check that an approval transaction that the sdk makes
 * is approving a token that is an underlying asset of a vault, and also that the first parameter in the approval transaction is the address of a valid yearn vault.
 * Similiarly, for a deposit transaction, it can be used to check whether the vault is a valid yearn vault
 */

var AllowListService = /*#__PURE__*/function (_ContractService) {
  _inheritsLoose(AllowListService, _ContractService);

  function AllowListService(chainId, ctx, address) {
    return _ContractService.call(this, address, chainId, ctx) || this;
  }
  /**
   * Get most up-to-date address of the Allow List Factory contract for a particular chain id
   * @param chainId
   * @returns address
   */


  AllowListService.addressByChain = function addressByChain(chainId) {
    switch (chainId) {
      case 250:
        return "0xD2322468e5Aa331381200754f6daAD3dF923539e";

      case 1:
      case 1337:
      case 42161:
      default:
        return null;
    }
  }
  /**
   * Uses yearn's on chain AllowList to verify whether the calldata being sent to the target contract by the sdk is valid. This should be used prior to any
   * write method, including token approvals. This method will raise an error if the parameters are not valid.
   * @param targetAddress The contract that is being interacted with e.g. for approving depositing usdc into a vault this would be usdc.
   *                      For depositing/withdrawing from a vault it'd be the vault contract itself
   * @param callData The data from the tx that should be validated. This should be from a tx that has been populated and is about to be sent
   */
  ;

  var _proto = AllowListService.prototype;

  _proto.validateCalldata =
  /*#__PURE__*/
  function () {
    var _validateCalldata = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(targetAddress, callData) {
      var valid;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (targetAddress) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return", {
                success: false,
                error: "can't validate a tx that isn't targeting an address"
              });

            case 2:
              if (callData) {
                _context.next = 4;
                break;
              }

              return _context.abrupt("return", {
                success: false,
                error: "can't validate a tx that has no call data"
              });

            case 4:
              _context.prev = 4;
              _context.next = 7;
              return this.contract.read.validateCalldataByOrigin(AllowListService.originName, targetAddress, callData);

            case 7:
              valid = _context.sent;

              if (valid) {
                _context.next = 10;
                break;
              }

              return _context.abrupt("return", {
                success: false,
                error: "tx is not permitted by the allow list"
              });

            case 10:
              return _context.abrupt("return", {
                success: true
              });

            case 13:
              _context.prev = 13;
              _context.t0 = _context["catch"](4);
              return _context.abrupt("return", {
                success: false,
                error: "failed to read from the allow list whether the transaction is valid"
              });

            case 16:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this, [[4, 13]]);
    }));

    function validateCalldata(_x, _x2) {
      return _validateCalldata.apply(this, arguments);
    }

    return validateCalldata;
  }();

  return AllowListService;
}(ContractService);
AllowListService.abi = ["function validateCalldataByOrigin(string memory originName, address targetAddress, bytes calldata data) public view returns (bool)"];
/**
 * This is used by the AllowListFactory to resolve which set of rules are applicable to which organization
 */

AllowListService.originName = "yearn.finance";

var HelperAbi = ["function tokensMetadata(address[] memory) public view returns (" + TokenAbi$2 + "[] memory)", "function tokensPrices(address[] memory) public view returns (" + TokenPriceAbi + "[] memory)", "function tokensBalances(address, address[] memory) public view returns (" + TokenBalanceAbi + "[] memory)", "function allowances(address, address[] memory, address[] memory) external view returns (" + AllowanceAbi + "[] memory)", "function assetStrategiesAddresses(address) public view returns (address[])"];
/**
 * [[HelperService]] is a generalized containers for all the utilities that are
 * used in the lens codebase and in the SDK.
 */

var HelperService = /*#__PURE__*/function (_ContractService) {
  _inheritsLoose(HelperService, _ContractService);

  function HelperService(chainId, ctx) {
    var _ctx$addresses$helper;

    return _ContractService.call(this, (_ctx$addresses$helper = ctx.addresses.helper) != null ? _ctx$addresses$helper : HelperService.addressByChain(chainId), chainId, ctx) || this;
  }
  /**
   * Get most up-to-date address of the Helper contract for a particular chain
   * id.
   * @param chainId
   * @returns address
   */


  HelperService.addressByChain = function addressByChain(chainId) {
    switch (chainId) {
      case 1:
      case 1337:
        return "0x5AACD0D03096039aC4381CD814637e9FB7C34a6f";

      case 250:
        return "0xE55Dd55b3355c261A048B3f310706C7478657d74";

      case 42161:
        return "0xE55Dd55b3355c261A048B3f310706C7478657d74";
    }
  }
  /**
   * Get a list of [[ERC20]] objects for a list of token addresses.
   * @param addresses
   * @param overrides
   * @returns list of erc20 object
   */
  ;

  var _proto = HelperService.prototype;

  _proto.tokens =
  /*#__PURE__*/
  function () {
    var _tokens = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(addresses, overrides) {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context.next = 3;
              return this.contract.read.tokensMetadata(addresses, overrides).then(structArray);

            case 3:
              return _context.abrupt("return", _context.sent);

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function tokens(_x, _x2) {
      return _tokens.apply(this, arguments);
    }

    return tokens;
  }()
  /**
   * Get a list of token prices for a list of token addresses.
   * @param addresses
   * @param overrides
   * @returns list of token prices
   */
  ;

  _proto.tokenPrices =
  /*#__PURE__*/
  function () {
    var _tokenPrices = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(addresses, overrides) {
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context2.next = 3;
              return this.contract.read.tokensPrices(addresses, overrides).then(structArray);

            case 3:
              return _context2.abrupt("return", _context2.sent);

            case 4:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function tokenPrices(_x3, _x4) {
      return _tokenPrices.apply(this, arguments);
    }

    return tokenPrices;
  }()
  /**
   * Get a list of token balances from a list of token addresses for a
   * particular address.
   * @param address
   * @param tokens
   * @param overrides
   * @returns list of token balances
   */
  ;

  _proto.tokenBalances =
  /*#__PURE__*/
  function () {
    var _tokenBalances = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(address, tokens, overrides) {
      var _this = this;

      var chunks, promises;
      return runtime_1.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              chunks = chunkArray(tokens, 30);
              promises = chunks.map( /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(chunk) {
                  return runtime_1.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          return _context3.abrupt("return", _this.contract.read.tokensBalances(address, chunk, overrides).then(structArray));

                        case 1:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3);
                }));

                return function (_x8) {
                  return _ref.apply(this, arguments);
                };
              }());
              return _context4.abrupt("return", Promise.all(promises).then(function (chunks) {
                return chunks.flat();
              }));

            case 4:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    function tokenBalances(_x5, _x6, _x7) {
      return _tokenBalances.apply(this, arguments);
    }

    return tokenBalances;
  }()
  /**
   * Get a list of token allowances for a list of token addresses and spenders
   * for a particular address.
   * @param address
   * @param tokens
   * @param spenders
   * @param overrides
   * @returns
   */
  ;

  _proto.tokenAllowances =
  /*#__PURE__*/
  function () {
    var _tokenAllowances = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(address, tokens, spenders, overrides) {
      return runtime_1.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              _context5.next = 3;
              return this.contract.read.allowances(address, tokens, spenders, overrides).then(structArray);

            case 3:
              return _context5.abrupt("return", _context5.sent);

            case 4:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));

    function tokenAllowances(_x9, _x10, _x11, _x12) {
      return _tokenAllowances.apply(this, arguments);
    }

    return tokenAllowances;
  }();

  _proto.assetStrategiesAddresses = /*#__PURE__*/function () {
    var _assetStrategiesAddresses = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(address, overrides) {
      return runtime_1.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (overrides === void 0) {
                overrides = {};
              }

              return _context6.abrupt("return", this.contract.read.assetStrategiesAddresses(address, overrides));

            case 2:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));

    function assetStrategiesAddresses(_x13, _x14) {
      return _assetStrategiesAddresses.apply(this, arguments);
    }

    return assetStrategiesAddresses;
  }();

  return HelperService;
}(ContractService);
HelperService.abi = HelperAbi;

var MetaURL = "https://meta.yearn.network";
var CHAIN_ID_KEY = "{chain_id}";
/**
 * [[MetaService]] fetches meta data about things such as vaults and tokens
 * from yearn-meta
 */

var MetaService = /*#__PURE__*/function (_Service) {
  _inheritsLoose(MetaService, _Service);

  function MetaService() {
    return _Service.apply(this, arguments) || this;
  }

  var _proto = MetaService.prototype;

  _proto.tokens = /*#__PURE__*/function () {
    var _tokens = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", fetch(this.buildUrl("tokens/" + CHAIN_ID_KEY + "/all")).then(function (res) {
                return res.json();
              }));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function tokens() {
      return _tokens.apply(this, arguments);
    }

    return tokens;
  }();

  _proto.strategies = /*#__PURE__*/function () {
    var _strategies = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", fetch(this.buildUrl("strategies/" + CHAIN_ID_KEY + "/all")).then(function (res) {
                return res.json();
              }));

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function strategies() {
      return _strategies.apply(this, arguments);
    }

    return strategies;
  }();

  _proto.vaults = /*#__PURE__*/function () {
    var _vaults = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3() {
      return runtime_1.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", fetch(this.buildUrl("vaults/" + CHAIN_ID_KEY + "/all")).then(function (res) {
                return res.json();
              }));

            case 1:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function vaults() {
      return _vaults.apply(this, arguments);
    }

    return vaults;
  }();

  _proto.buildUrl = function buildUrl(path) {
    return (MetaURL + "/" + path).replace(CHAIN_ID_KEY, this.chainId.toString());
  };

  return MetaService;
}(Service);

var TransactionService = /*#__PURE__*/function (_Service) {
  _inheritsLoose(TransactionService, _Service);

  function TransactionService(chainId, ctx, allowListService) {
    var _this;

    _this = _Service.call(this, chainId, ctx) || this;
    _this.allowListService = allowListService;
    return _this;
  }

  var _proto = TransactionService.prototype;

  _proto.sendTransaction = /*#__PURE__*/function () {
    var _sendTransaction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(transaction) {
      var _yield$this$validateT, success, error, signer;

      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.validateTx(transaction);

            case 2:
              _yield$this$validateT = _context.sent;
              success = _yield$this$validateT.success;
              error = _yield$this$validateT.error;

              if (success) {
                _context.next = 7;
                break;
              }

              throw new SdkError(error || "transaction is not valid");

            case 7:
              signer = this.ctx.provider.write.getSigner();
              return _context.abrupt("return", signer.sendTransaction(transaction));

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function sendTransaction(_x) {
      return _sendTransaction.apply(this, arguments);
    }

    return sendTransaction;
  }();

  _proto.validateTx = /*#__PURE__*/function () {
    var _validateTx = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(transaction) {
      var _yield$Promise$all, to, data;

      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (this.allowListService) {
                _context2.next = 2;
                break;
              }

              return _context2.abrupt("return", Promise.resolve({
                success: true,
                error: undefined
              }));

            case 2:
              _context2.next = 4;
              return Promise.all([transaction.to, transaction.data]);

            case 4:
              _yield$Promise$all = _context2.sent;
              to = _yield$Promise$all[0];
              data = _yield$Promise$all[1];
              _context2.next = 9;
              return this.allowListService.validateCalldata(to, data);

            case 9:
              return _context2.abrupt("return", _context2.sent);

            case 10:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function validateTx(_x2) {
      return _validateTx.apply(this, arguments);
    }

    return validateTx;
  }();

  return TransactionService;
}(Service);

/**
 * [[Yearn]] is a wrapper for all the services and interfaces of the SDK.
 *
 * Yearn namespace can be instantiated as a class, providing configuration
 * options that will then be used by all the services and interfaces:
 *
 * ```typescript
 * import { Yearn } from "@yfi/sdk";
 *
 * const provider = new JsonRpcProvider("http://localhost:8545");
 * const yearn = new Yearn(1, { provider });
 * ```
 */

var Yearn = /*#__PURE__*/function () {
  /**
   * Create a new SDK instance.
   * @param chainId
   * @param context plain object containing all the optional configuration
   * @param assetServiceState the asset service does some expensive computation at initialization, passing the state from a previous sdk instance can prevent this
   */
  function Yearn(chainId, context, assetServiceState) {
    this.context = new Context(context);
    var allowlistAddress = AllowListService.addressByChain(chainId);
    var allowListService = allowlistAddress ? new AllowListService(chainId, this.context, allowlistAddress) : undefined;
    this.services = {
      lens: new LensService(chainId, this.context),
      oracle: new OracleService(chainId, this.context),
      zapper: new ZapperService(chainId, this.context),
      asset: new AssetService(chainId, this.context, assetServiceState),
      vision: new VisionService(chainId, this.context),
      subgraph: new SubgraphService(chainId, this.context),
      pickle: new PickleService(chainId, this.context),
      helper: new HelperService(chainId, this.context),
      telegram: new TelegramService(chainId, this.context),
      meta: new MetaService(chainId, this.context),
      allowList: allowListService,
      transaction: new TransactionService(chainId, this.context, allowListService)
    };
    this.vaults = new VaultInterface(this, chainId, this.context);
    this.tokens = new TokenInterface(this, chainId, this.context);
    this.earnings = new EarningsInterface(this, chainId, this.context);
    this.fees = new FeesInterface(this, chainId, this.context);
    this.ironBank = new IronBankInterface(this, chainId, this.context);
    this.simulation = new SimulationInterface(this, chainId, this.context);
    this.strategies = new StrategyInterface(this, chainId, this.context);
    this.ready = Promise.all([this.services.asset.ready]);
  }

  var _proto = Yearn.prototype;

  _proto.setChainId = function setChainId(chainId) {
    var allowlistAddress = AllowListService.addressByChain(chainId);
    var allowListService = allowlistAddress ? new AllowListService(chainId, this.context, allowlistAddress) : undefined;
    this.services = {
      lens: new LensService(chainId, this.context),
      oracle: new OracleService(chainId, this.context),
      zapper: new ZapperService(chainId, this.context),
      asset: new AssetService(chainId, this.context),
      vision: new VisionService(chainId, this.context),
      subgraph: new SubgraphService(chainId, this.context),
      pickle: new PickleService(chainId, this.context),
      helper: new HelperService(chainId, this.context),
      telegram: new TelegramService(chainId, this.context),
      meta: new MetaService(chainId, this.context),
      allowList: allowListService,
      transaction: new TransactionService(chainId, this.context, allowListService)
    };
    this.vaults = new VaultInterface(this, chainId, this.context);
    this.tokens = new TokenInterface(this, chainId, this.context);
    this.earnings = new EarningsInterface(this, chainId, this.context);
    this.fees = new FeesInterface(this, chainId, this.context);
    this.ironBank = new IronBankInterface(this, chainId, this.context);
    this.simulation = new SimulationInterface(this, chainId, this.context);
    this.strategies = new StrategyInterface(this, chainId, this.context);
    this.ready = Promise.all([this.services.asset.ready]);
  };

  return Yearn;
}();

export { AssetService, Context, CustomError, EarningsInterface, EthersError, FeesInterface, IronBankAdapter, IronBankInterface, LensService, OracleService, PriceFetchingError, RegistryV2Adapter, SdkError, SimulationError, SimulationInterface, StrategyInterface, SubgraphService, TelegramService, TenderlyError, TokenInterface, VaultInterface, VisionService, Yearn, ZapProtocol, ZapperError, ZapperService };
//# sourceMappingURL=sdk.esm.js.map
