"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseTransactionParser = void 0;
const caip_1 = require("@shapeshiftoss/caip");
const logger_1 = require("@shapeshiftoss/logger");
const bignumber_js_1 = require("bignumber.js");
const ethers_1 = require("ethers");
const types_1 = require("../../types");
const utils_1 = require("../../utils");
__exportStar(require("./types"), exports);
__exportStar(require("./utils"), exports);
const logger = new logger_1.Logger({
    namespace: ['unchained-client', 'evm', 'parser'],
    level: process.env.LOG_LEVEL,
});
class BaseTransactionParser {
    constructor(args) {
        this.parsers = [];
        this.chainId = args.chainId;
        this.provider = new ethers_1.ethers.providers.JsonRpcProvider(args.rpcUrl);
    }
    /**
     * Register custom transaction sub parser to extract contract specific data
     *
     * _parsers should be registered from most generic first to most specific last_
     */
    registerParser(parser) {
        this.parsers.unshift(parser);
    }
    registerParsers(parsers) {
        parsers.forEach((parser) => this.registerParser(parser));
    }
    async parse(tx, address) {
        var _a;
        address = ethers_1.ethers.utils.getAddress(address);
        // We expect only one Parser to return a result. If multiple do, we take the first and early exit.
        const contractParserResult = await (0, utils_1.findAsyncSequential)(this.parsers, async (parser) => await parser.parse(tx));
        const parsedTx = {
            address,
            blockHash: tx.blockHash,
            blockHeight: tx.blockHeight,
            blockTime: tx.timestamp,
            chainId: this.chainId,
            confirmations: tx.confirmations,
            status: this.getStatus(tx),
            trade: contractParserResult === null || contractParserResult === void 0 ? void 0 : contractParserResult.trade,
            transfers: (_a = contractParserResult === null || contractParserResult === void 0 ? void 0 : contractParserResult.transfers) !== null && _a !== void 0 ? _a : [],
            txid: tx.txid,
            data: contractParserResult === null || contractParserResult === void 0 ? void 0 : contractParserResult.data,
        };
        return this.getParsedTxWithTransfers(tx, parsedTx, address);
    }
    getStatus(tx) {
        const status = tx.status;
        if (status === -1 && tx.confirmations <= 0)
            return types_1.TxStatus.Pending;
        if (status === 1 && tx.confirmations > 0)
            return types_1.TxStatus.Confirmed;
        if (status === 0)
            return types_1.TxStatus.Failed;
        return types_1.TxStatus.Unknown;
    }
    getParsedTxWithTransfers(tx, parsedTx, address) {
        var _a, _b;
        if (address === tx.from) {
            // send amount
            const sendValue = new bignumber_js_1.BigNumber(tx.value);
            if (sendValue.gt(0)) {
                parsedTx.transfers = (0, utils_1.aggregateTransfer)(parsedTx.transfers, types_1.TransferType.Send, this.assetId, tx.from, tx.to, sendValue.toString(10));
            }
            // network fee
            const fees = new bignumber_js_1.BigNumber(tx.fee);
            if (fees.gt(0)) {
                parsedTx.fee = { assetId: this.assetId, value: fees.toString(10) };
            }
        }
        if (address === tx.to) {
            // receive amount
            const receiveValue = new bignumber_js_1.BigNumber(tx.value);
            if (receiveValue.gt(0)) {
                parsedTx.transfers = (0, utils_1.aggregateTransfer)(parsedTx.transfers, types_1.TransferType.Receive, this.assetId, tx.from, tx.to, receiveValue.toString(10));
            }
        }
        (_a = tx.tokenTransfers) === null || _a === void 0 ? void 0 : _a.forEach((transfer) => {
            // FTX Token (FTT) name and symbol was set backwards on the ERC20 contract (Ethereum Mainnet)
            if (this.chainId === caip_1.ethChainId &&
                transfer.contract === '0x50D1c9771902476076eCFc8B2A83Ad6b9355a4c9') {
                transfer.name = transfer.symbol;
                transfer.symbol = transfer.name;
            }
            const token = {
                contract: transfer.contract,
                decimals: transfer.decimals,
                name: transfer.name,
                symbol: transfer.symbol,
            };
            const assetId = (() => {
                // alias ether token on optimism to native asset as they are the same
                if (transfer.contract === '0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000') {
                    return (0, caip_1.toAssetId)({
                        chainId: this.chainId,
                        assetNamespace: 'slip44',
                        assetReference: caip_1.ASSET_REFERENCE.Optimism,
                    });
                }
                const assetNamespace = (() => {
                    switch (transfer.type) {
                        case 'ERC20':
                            return caip_1.ASSET_NAMESPACE.erc20;
                        case 'ERC721':
                            return caip_1.ASSET_NAMESPACE.erc721;
                        case 'BEP20':
                            return caip_1.ASSET_NAMESPACE.bep20;
                        case 'BEP721':
                            return caip_1.ASSET_NAMESPACE.bep721;
                        default:
                            logger.warn(`unsupported asset namespace: ${transfer.type}`);
                            return;
                    }
                })();
                if (!assetNamespace)
                    return;
                return (0, caip_1.toAssetId)({
                    chainId: this.chainId,
                    assetNamespace,
                    assetReference: transfer.contract,
                });
            })();
            if (!assetId)
                return;
            const transferArgs = [assetId, transfer.from, transfer.to, transfer.value, token];
            // token send amount
            if (address === transfer.from) {
                parsedTx.transfers = (0, utils_1.aggregateTransfer)(parsedTx.transfers, types_1.TransferType.Send, ...transferArgs);
            }
            // token receive amount
            if (address === transfer.to) {
                parsedTx.transfers = (0, utils_1.aggregateTransfer)(parsedTx.transfers, types_1.TransferType.Receive, ...transferArgs);
            }
        });
        (_b = tx.internalTxs) === null || _b === void 0 ? void 0 : _b.forEach((internalTx) => {
            const transferArgs = [this.assetId, internalTx.from, internalTx.to, internalTx.value];
            // internal eth send
            if (address === internalTx.from) {
                parsedTx.transfers = (0, utils_1.aggregateTransfer)(parsedTx.transfers, types_1.TransferType.Send, ...transferArgs);
            }
            // internal eth receive
            if (address === internalTx.to) {
                parsedTx.transfers = (0, utils_1.aggregateTransfer)(parsedTx.transfers, types_1.TransferType.Receive, ...transferArgs);
            }
        });
        return parsedTx;
    }
}
exports.BaseTransactionParser = BaseTransactionParser;
