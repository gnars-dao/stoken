/// <reference types="node" />
import { TypedEmitter } from '@trezor/utils/lib/typedEventEmitter';
import type { AnyError, AsyncResultWithTypedError, Success, Logger } from '../types';
import * as ERRORS from '../errors';
type TransportInterfaceDevice<DeviceType> = {
    session?: null | string;
    path: string;
    device: DeviceType;
};
type ConstructorParams = {
    logger?: Logger;
};
export declare abstract class AbstractInterface<DeviceType> extends TypedEmitter<{
    'transport-interface-change': TransportInterfaceDevice<DeviceType>[];
    'transport-interface-error': typeof ERRORS.DEVICE_NOT_FOUND | typeof ERRORS.DEVICE_UNREADABLE;
}> {
    devices: TransportInterfaceDevice<DeviceType>[];
    logger: Logger;
    constructor({ logger }: ConstructorParams);
    abstract enumerate(): AsyncResultWithTypedError<string[], string>;
    abstract read(path: string): AsyncResultWithTypedError<ArrayBuffer, typeof ERRORS.DEVICE_NOT_FOUND | typeof ERRORS.INTERFACE_UNABLE_TO_OPEN_DEVICE | typeof ERRORS.INTERFACE_DATA_TRANSFER | typeof ERRORS.DEVICE_DISCONNECTED_DURING_ACTION | typeof ERRORS.UNEXPECTED_ERROR>;
    abstract write(path: string, buffers: Buffer): AsyncResultWithTypedError<undefined, typeof ERRORS.DEVICE_NOT_FOUND | typeof ERRORS.INTERFACE_UNABLE_TO_OPEN_DEVICE | typeof ERRORS.INTERFACE_DATA_TRANSFER | typeof ERRORS.DEVICE_DISCONNECTED_DURING_ACTION | typeof ERRORS.UNEXPECTED_ERROR>;
    abstract openDevice(path: string, first: boolean): AsyncResultWithTypedError<undefined, typeof ERRORS.DEVICE_NOT_FOUND | typeof ERRORS.INTERFACE_UNABLE_TO_OPEN_DEVICE | typeof ERRORS.UNEXPECTED_ERROR | typeof ERRORS.ABORTED_BY_TIMEOUT | typeof ERRORS.ABORTED_BY_SIGNAL>;
    abstract closeDevice(path: string): AsyncResultWithTypedError<undefined, typeof ERRORS.DEVICE_NOT_FOUND | typeof ERRORS.INTERFACE_UNABLE_TO_CLOSE_DEVICE | typeof ERRORS.UNEXPECTED_ERROR>;
    protected success<T>(payload: T): Success<T>;
    protected error<E extends AnyError>(payload: {
        error: E;
        message?: string;
    }): {
        success: false;
        error: E;
        message: string | undefined;
    };
    protected unknownError<E extends AnyError>(err: Error, expectedErrors: E[]): {
        success: false;
        error: NonNullable<E>;
        message: string | undefined;
    } | {
        success: false;
        error: "unexpected error";
        message: string;
    };
}
export {};
//# sourceMappingURL=abstract.d.ts.map