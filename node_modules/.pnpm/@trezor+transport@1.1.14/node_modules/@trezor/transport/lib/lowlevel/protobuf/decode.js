"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = void 0;
const bytebuffer_1 = __importDefault(require("bytebuffer"));
const protobuf_1 = require("../../utils/protobuf");
const transform = (field, value) => {
    if ((0, protobuf_1.isPrimitiveField)(field.type)) {
        if (field.optional && typeof value === 'undefined') {
            return null;
        }
        if (field.type === 'bytes') {
            return bytebuffer_1.default.wrap(value).toString('hex');
        }
        if (field.long) {
            if (Number.isSafeInteger(value.toNumber())) {
                return value.toNumber();
            }
            return value.toString();
        }
        return value;
    }
    if ('valuesById' in field.resolvedType) {
        return field.resolvedType.valuesById[value];
    }
    if (field.resolvedType.fields) {
        return messageToJSON(value, field.resolvedType.fields);
    }
    throw new Error(`transport: decode: case not handled: ${field}`);
};
function messageToJSON(Message, fields) {
    const message = __rest(Message, []);
    const res = {};
    Object.keys(fields).forEach(key => {
        const field = fields[key];
        const value = message[key];
        if (field.repeated) {
            res[key] = value.map((v) => transform(field, v));
        }
        else {
            res[key] = transform(field, value);
        }
    });
    return res;
}
const decode = (Message, data) => {
    const buff = data.toBuffer();
    const a = new Uint8Array(buff);
    const decoded = Message.decode(a);
    return messageToJSON(decoded, decoded.$type.fields);
};
exports.decode = decode;
//# sourceMappingURL=decode.js.map