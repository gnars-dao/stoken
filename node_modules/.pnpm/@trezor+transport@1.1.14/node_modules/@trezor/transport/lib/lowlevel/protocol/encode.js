"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encode = void 0;
const bytebuffer_1 = __importDefault(require("bytebuffer"));
const constants_1 = require("../../constants");
function encode(data, options) {
    const { addTrezorHeaders, chunked, messageType } = options;
    const fullSize = (addTrezorHeaders ? constants_1.HEADER_SIZE : constants_1.HEADER_SIZE - 2) + data.limit;
    const encodedByteBuffer = new bytebuffer_1.default(fullSize);
    if (addTrezorHeaders) {
        encodedByteBuffer.writeByte(constants_1.MESSAGE_HEADER_BYTE);
        encodedByteBuffer.writeByte(constants_1.MESSAGE_HEADER_BYTE);
    }
    encodedByteBuffer.writeUint16(messageType);
    encodedByteBuffer.writeUint32(data.limit);
    encodedByteBuffer.append(data.buffer);
    encodedByteBuffer.reset();
    if (chunked === false) {
        return encodedByteBuffer;
    }
    const result = [];
    const size = constants_1.BUFFER_SIZE;
    const count = Math.floor((encodedByteBuffer.limit - 1) / size) + 1 || 1;
    for (let i = 0; i < count; i++) {
        const start = i * size;
        const end = Math.min((i + 1) * size, encodedByteBuffer.limit);
        const slice = encodedByteBuffer.slice(start, end);
        slice.compact();
        result.push(slice.buffer);
    }
    return result;
}
exports.encode = encode;
//# sourceMappingURL=encode.js.map