import * as protobuf from 'protobufjs/light';
import { ScheduleActionParams, ScheduledAction, Deferred } from '@trezor/utils';
import { TypedEmitter } from '@trezor/utils/lib/typedEventEmitter';
import { MessageFromTrezor, Session, Descriptor, AbortableCall, AsyncResultWithTypedError, ResultWithTypedError, Success, AnyError, Logger } from '../types';
import * as ERRORS from '../errors';
import { TRANSPORT } from '../constants';
export type AcquireInput = {
    path: string;
    previous?: Session;
};
export type ReleaseInput = {
    path: string;
    session: string;
    onClose?: boolean;
};
type DeviceDescriptorDiff = {
    didUpdate: boolean;
    descriptors: Descriptor[];
    connected: Descriptor[];
    disconnected: Descriptor[];
    changedSessions: Descriptor[];
    acquired: Descriptor[];
    acquiredByMyself: Descriptor[];
    acquiredElsewhere: Descriptor[];
    released: Descriptor[];
    releasedByMyself: Descriptor[];
    releasedElsewhere: Descriptor[];
};
type ConstructorParams = {
    messages: Record<string, any>;
    signal?: AbortSignal;
    logger?: Logger;
};
export declare abstract class AbstractTransport extends TypedEmitter<{
    [TRANSPORT.UPDATE]: DeviceDescriptorDiff;
    [TRANSPORT.ERROR]: typeof ERRORS.HTTP_ERROR | typeof ERRORS.WRONG_RESULT_TYPE | typeof ERRORS.UNEXPECTED_ERROR;
}> {
    abstract name: 'BridgeTransport' | 'NodeUsbTransport' | 'WebUsbTransport';
    isOutdated: boolean;
    version: string;
    protected stopped: boolean;
    protected listening: boolean;
    protected messages: protobuf.Root;
    protected descriptors: Descriptor[];
    protected acquiredUnconfirmed: Record<string, string>;
    protected listenPromise: Record<string, Deferred<ResultWithTypedError<string, typeof ERRORS.DEVICE_DISCONNECTED_DURING_ACTION | typeof ERRORS.SESSION_WRONG_PREVIOUS | typeof ERRORS.DEVICE_NOT_FOUND | typeof ERRORS.INTERFACE_UNABLE_TO_OPEN_DEVICE | typeof ERRORS.UNEXPECTED_ERROR | typeof ERRORS.ABORTED_BY_TIMEOUT | typeof ERRORS.ABORTED_BY_SIGNAL>>>;
    protected releasePromise?: Deferred<any>;
    protected releasingSession: string | undefined;
    protected abortController: AbortController;
    protected logger: Logger;
    constructor({ messages, signal, logger }: ConstructorParams);
    abstract init(): AbortableCall<undefined, typeof ERRORS.SESSION_BACKGROUND_TIMEOUT | typeof ERRORS.WRONG_ENVIRONMENT | typeof ERRORS.WRONG_RESULT_TYPE | typeof ERRORS.HTTP_ERROR | typeof ERRORS.UNEXPECTED_ERROR | typeof ERRORS.ABORTED_BY_TIMEOUT | typeof ERRORS.ABORTED_BY_SIGNAL>;
    abstract listen(): ResultWithTypedError<undefined, typeof ERRORS.ALREADY_LISTENING | typeof ERRORS.WRONG_ENVIRONMENT>;
    abstract enumerate(): AbortableCall<Descriptor[], typeof ERRORS.HTTP_ERROR | typeof ERRORS.WRONG_RESULT_TYPE | typeof ERRORS.ABORTED_BY_TIMEOUT | typeof ERRORS.ABORTED_BY_SIGNAL | typeof ERRORS.UNEXPECTED_ERROR | typeof ERRORS.WRONG_ENVIRONMENT>;
    abstract acquire({ input }: {
        input: AcquireInput;
    }): AbortableCall<string, typeof ERRORS.INTERFACE_UNABLE_TO_OPEN_DEVICE | typeof ERRORS.WRONG_RESULT_TYPE | typeof ERRORS.HTTP_ERROR | typeof ERRORS.DEVICE_DISCONNECTED_DURING_ACTION | typeof ERRORS.DEVICE_NOT_FOUND | typeof ERRORS.SESSION_WRONG_PREVIOUS | typeof ERRORS.UNEXPECTED_ERROR | typeof ERRORS.ABORTED_BY_TIMEOUT | typeof ERRORS.ABORTED_BY_SIGNAL | typeof ERRORS.WRONG_ENVIRONMENT>;
    abstract release({ path, session, onClose }: ReleaseInput): AbortableCall<void, typeof ERRORS.SESSION_NOT_FOUND | typeof ERRORS.HTTP_ERROR | typeof ERRORS.WRONG_RESULT_TYPE | typeof ERRORS.DEVICE_DISCONNECTED_DURING_ACTION | typeof ERRORS.SESSION_WRONG_PREVIOUS | typeof ERRORS.DEVICE_NOT_FOUND | typeof ERRORS.INTERFACE_UNABLE_TO_OPEN_DEVICE | typeof ERRORS.UNEXPECTED_ERROR | typeof ERRORS.ABORTED_BY_TIMEOUT | typeof ERRORS.ABORTED_BY_SIGNAL | typeof ERRORS.WRONG_ENVIRONMENT>;
    abstract releaseDevice(path: string): AsyncResultWithTypedError<void, string>;
    abstract send({ path, session, data, name, }: {
        path?: string;
        session?: string;
        name: string;
        data: Record<string, unknown>;
    }): AbortableCall<undefined, typeof ERRORS.DEVICE_DISCONNECTED_DURING_ACTION | typeof ERRORS.HTTP_ERROR | typeof ERRORS.WRONG_RESULT_TYPE | typeof ERRORS.OTHER_CALL_IN_PROGRESS | typeof ERRORS.PROTOCOL_MALFORMED | typeof ERRORS.UNEXPECTED_ERROR | typeof ERRORS.SESSION_NOT_FOUND | typeof ERRORS.ABORTED_BY_TIMEOUT | typeof ERRORS.ABORTED_BY_SIGNAL | typeof ERRORS.WRONG_ENVIRONMENT>;
    abstract receive({ path, session }: {
        path?: string;
        session?: string;
    }): AbortableCall<MessageFromTrezor, typeof ERRORS.HTTP_ERROR | typeof ERRORS.WRONG_RESULT_TYPE | typeof ERRORS.OTHER_CALL_IN_PROGRESS | typeof ERRORS.PROTOCOL_MALFORMED | typeof ERRORS.DEVICE_DISCONNECTED_DURING_ACTION | typeof ERRORS.UNEXPECTED_ERROR | typeof ERRORS.SESSION_NOT_FOUND | typeof ERRORS.ABORTED_BY_TIMEOUT | typeof ERRORS.ABORTED_BY_SIGNAL | typeof ERRORS.WRONG_ENVIRONMENT>;
    abstract call({ session, name, data, }: {
        session: string;
        name: string;
        data: Record<string, unknown>;
    }): AbortableCall<MessageFromTrezor, typeof ERRORS.HTTP_ERROR | typeof ERRORS.WRONG_RESULT_TYPE | typeof ERRORS.OTHER_CALL_IN_PROGRESS | typeof ERRORS.DEVICE_DISCONNECTED_DURING_ACTION | typeof ERRORS.PROTOCOL_MALFORMED | typeof ERRORS.UNEXPECTED_ERROR | typeof ERRORS.ABORTED_BY_TIMEOUT | typeof ERRORS.ABORTED_BY_SIGNAL | typeof ERRORS.WRONG_ENVIRONMENT | typeof ERRORS.DEVICE_NOT_FOUND | typeof ERRORS.INTERFACE_UNABLE_TO_OPEN_DEVICE | typeof ERRORS.INTERFACE_DATA_TRANSFER>;
    abstract stop(): void;
    private _getDiff;
    handleDescriptorsChange(nextDescriptors: Descriptor[]): void;
    protected success<T>(payload: T): Success<T>;
    protected error<E extends AnyError>(payload: {
        error: E;
        message?: string;
    }): {
        success: false;
        error: E;
        message: string | undefined;
    };
    protected unknownError: <E extends AnyError>(err: Error | string, expectedErrors: E[]) => {
        success: false;
        error: NonNullable<E>;
        message: string | undefined;
    } | {
        success: false;
        error: "unexpected error";
        message: string;
    };
    private createLocalAbortController;
    protected scheduleAction: <T, E extends AnyError>(action: ScheduledAction<T>, params?: ScheduleActionParams, errors?: E[] | undefined) => {
        promise: Promise<T | {
            success: false;
            error: NonNullable<"Aborted by signal" | "Aborted by timeout">;
            message: string | undefined;
        } | {
            success: false;
            error: "unexpected error";
            message: string;
        }>;
        abort: () => void;
    };
}
export {};
//# sourceMappingURL=abstract.d.ts.map