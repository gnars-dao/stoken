"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractUsbTransport = void 0;
const utils_1 = require("@trezor/utils");
const abstract_1 = require("./abstract");
const send_1 = require("../lowlevel/send");
const receive_1 = require("../lowlevel/receive");
const ERRORS = __importStar(require("../errors"));
class AbstractUsbTransport extends abstract_1.AbstractTransport {
    constructor({ messages, usbInterface, sessionsClient, signal }) {
        super({ messages, signal });
        this.sessionsClient = sessionsClient;
        this.transportInterface = usbInterface;
    }
    init() {
        return this.scheduleAction(() => __awaiter(this, void 0, void 0, function* () {
            const handshakeRes = yield this.sessionsClient.handshake();
            return handshakeRes.success
                ? this.success(undefined)
                : this.unknownError('handshake error', []);
        }));
    }
    listen() {
        if (this.listening) {
            return this.error({ error: ERRORS.ALREADY_LISTENING });
        }
        this.listening = true;
        this.transportInterface.on('transport-interface-change', devices => {
            this.sessionsClient.enumerateDone({
                paths: devices.map(d => d.path),
            });
        });
        this.sessionsClient.on('descriptors', (descriptors) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            if ((_a = this.acquirePromise) === null || _a === void 0 ? void 0 : _a.promise) {
                yield this.acquirePromise.promise;
            }
            this.handleDescriptorsChange(descriptors);
        }));
        return this.success(undefined);
    }
    enumerate() {
        return this.scheduleAction(() => __awaiter(this, void 0, void 0, function* () {
            yield this.sessionsClient.enumerateIntent();
            const enumerateResult = yield this.transportInterface.enumerate();
            if (!enumerateResult.success) {
                return enumerateResult;
            }
            const occupiedPaths = enumerateResult.payload;
            const enumerateDoneResponse = yield this.sessionsClient.enumerateDone({
                paths: occupiedPaths,
            });
            return this.success(enumerateDoneResponse.payload.descriptors);
        }));
    }
    acquire({ input }) {
        return this.scheduleAction(() => __awaiter(this, void 0, void 0, function* () {
            const { path } = input;
            if (this.listening) {
                this.listenPromise[path] = (0, utils_1.createDeferred)();
            }
            this.acquirePromise = (0, utils_1.createDeferred)();
            const acquireIntentResponse = yield this.sessionsClient.acquireIntent(input);
            if (this.acquirePromise) {
                this.acquirePromise.resolve(undefined);
            }
            if (!acquireIntentResponse.success) {
                return this.error({ error: acquireIntentResponse.error });
            }
            this.acquiredUnconfirmed[path] = acquireIntentResponse.payload.session;
            const reset = !!input.previous;
            const openDeviceResult = yield this.transportInterface.openDevice(path, reset);
            if (!openDeviceResult.success) {
                if (this.listenPromise) {
                    this.listenPromise[path].resolve(openDeviceResult);
                }
                return openDeviceResult;
            }
            this.sessionsClient.acquireDone({ path });
            if (!this.listenPromise[path]) {
                return this.success(acquireIntentResponse.payload.session);
            }
            return this.listenPromise[path].promise.finally(() => {
                delete this.listenPromise[path];
            });
        }), undefined, [ERRORS.DEVICE_DISCONNECTED_DURING_ACTION, ERRORS.SESSION_WRONG_PREVIOUS]);
    }
    release({ path, session, onClose }) {
        return this.scheduleAction(() => __awaiter(this, void 0, void 0, function* () {
            if (this.listening) {
                this.releasingSession = session;
                this.listenPromise[path] = (0, utils_1.createDeferred)();
            }
            const releaseIntentResponse = yield this.sessionsClient.releaseIntent({
                session,
            });
            if (!releaseIntentResponse.success) {
                return this.error({ error: releaseIntentResponse.error });
            }
            const releasePromise = this.releaseDevice(releaseIntentResponse.payload.path);
            if (onClose)
                return this.success(undefined);
            yield releasePromise;
            yield this.sessionsClient.releaseDone({
                path: releaseIntentResponse.payload.path,
            });
            if (!this.listenPromise[path]) {
                return this.success(undefined);
            }
            return this.listenPromise[path].promise
                .then(() => this.success(undefined))
                .finally(() => {
                delete this.listenPromise[path];
            });
        }));
    }
    call({ session, name, data, }) {
        return this.scheduleAction(() => __awaiter(this, void 0, void 0, function* () {
            const getPathBySessionResponse = yield this.sessionsClient.getPathBySession({
                session,
            });
            if (!getPathBySessionResponse.success) {
                if (getPathBySessionResponse.error === 'session not found') {
                    return this.error({ error: ERRORS.DEVICE_DISCONNECTED_DURING_ACTION });
                }
                return this.error({ error: ERRORS.UNEXPECTED_ERROR });
            }
            const { path } = getPathBySessionResponse.payload;
            try {
                yield (0, send_1.buildAndSend)(this.messages, (buffer) => this.transportInterface.write(path, buffer).then(result => {
                    if (!result.success) {
                        throw new Error(result.error);
                    }
                }), name, data);
                const message = yield (0, receive_1.receiveAndParse)(this.messages, () => this.transportInterface.read(path).then(result => {
                    if (result.success) {
                        return result.payload;
                    }
                    throw new Error(result.error);
                }));
                return this.success(message);
            }
            catch (err) {
                if (err.message === ERRORS.DEVICE_DISCONNECTED_DURING_ACTION) {
                    this.enumerate();
                }
                return this.unknownError(err, [
                    ERRORS.DEVICE_DISCONNECTED_DURING_ACTION,
                    ERRORS.DEVICE_NOT_FOUND,
                    ERRORS.INTERFACE_UNABLE_TO_OPEN_DEVICE,
                    ERRORS.INTERFACE_DATA_TRANSFER,
                ]);
            }
        }), { timeout: undefined });
    }
    send({ data, session, name, }) {
        return this.scheduleAction(() => __awaiter(this, void 0, void 0, function* () {
            const getPathBySessionResponse = yield this.sessionsClient.getPathBySession({
                session,
            });
            if (!getPathBySessionResponse.success) {
                return this.error({ error: getPathBySessionResponse.error });
            }
            const { path } = getPathBySessionResponse.payload;
            try {
                yield (0, send_1.buildAndSend)(this.messages, (buffer) => this.transportInterface.write(path, buffer).then(result => {
                    if (!result.success) {
                        throw new Error(result.error);
                    }
                }), name, data);
                return this.success(undefined);
            }
            catch (err) {
                if (err.message === ERRORS.DEVICE_DISCONNECTED_DURING_ACTION) {
                    this.enumerate();
                }
                return this.unknownError(err, [ERRORS.DEVICE_DISCONNECTED_DURING_ACTION]);
            }
        }));
    }
    receive({ session }) {
        return this.scheduleAction(() => __awaiter(this, void 0, void 0, function* () {
            const getPathBySessionResponse = yield this.sessionsClient.getPathBySession({
                session,
            });
            if (!getPathBySessionResponse.success) {
                return this.error({ error: getPathBySessionResponse.error });
            }
            const { path } = getPathBySessionResponse.payload;
            try {
                const message = yield (0, receive_1.receiveAndParse)(this.messages, () => this.transportInterface.read(path).then(result => {
                    if (!result.success) {
                        throw new Error(result.error);
                    }
                    return result.payload;
                }));
                return this.success(message);
            }
            catch (err) {
                if (err.message === ERRORS.DEVICE_DISCONNECTED_DURING_ACTION) {
                    this.enumerate();
                }
                return this.unknownError(err, [ERRORS.DEVICE_DISCONNECTED_DURING_ACTION]);
            }
        }));
    }
    releaseDevice(path) {
        return this.transportInterface.closeDevice(path);
    }
    stop() {
        this.transportInterface.on('transport-interface-change', () => {
            this.logger.debug('device connected after transport stopped');
        });
        this.stopped = true;
        this.abortController.abort();
    }
}
exports.AbstractUsbTransport = AbstractUsbTransport;
//# sourceMappingURL=abstractUsb.js.map