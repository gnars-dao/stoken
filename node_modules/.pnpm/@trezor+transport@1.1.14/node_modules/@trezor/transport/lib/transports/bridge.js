"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BridgeTransport = void 0;
const utils_1 = require("@trezor/utils");
const bridgeApiCall_1 = require("../utils/bridgeApiCall");
const bridgeApiResult = __importStar(require("../utils/bridgeApiResult"));
const send_1 = require("../lowlevel/send");
const receive_1 = require("../lowlevel/receive");
const abstract_1 = require("./abstract");
const ERRORS = __importStar(require("../errors"));
const DEFAULT_URL = 'http://127.0.0.1:21325';
class BridgeTransport extends abstract_1.AbstractTransport {
    constructor(_a) {
        var { url = DEFAULT_URL, latestVersion } = _a, args = __rest(_a, ["url", "latestVersion"]);
        super(args);
        this.name = 'BridgeTransport';
        this.url = url;
        this.latestVersion = latestVersion;
    }
    init() {
        return this.scheduleAction((signal) => __awaiter(this, void 0, void 0, function* () {
            const response = yield this._post('/', {
                signal,
            });
            if (!response.success) {
                return response;
            }
            this.version = response.payload.version;
            if (this.latestVersion) {
                this.isOutdated = utils_1.versionUtils.isNewer(this.latestVersion, this.version);
            }
            return this.success(undefined);
        }));
    }
    listen() {
        if (this.listening) {
            return this.error({ error: ERRORS.ALREADY_LISTENING });
        }
        this.listening = true;
        this._listen();
        return this.success(undefined);
    }
    _listen() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.stopped) {
                return;
            }
            const listenTimestamp = new Date().getTime();
            const response = yield this._post('/listen', {
                body: this.descriptors,
                signal: this.abortController.signal,
            });
            if (!response.success) {
                const time = new Date().getTime() - listenTimestamp;
                if (time > 1100) {
                    yield (0, utils_1.createTimeoutPromise)(1000);
                    return this._listen();
                }
                this.emit('transport-error', response.error);
                return;
            }
            if (this.acquirePromise) {
                yield this.acquirePromise.promise;
            }
            this.handleDescriptorsChange(response.payload);
            return this._listen();
        });
    }
    enumerate() {
        return this.scheduleAction(signal => this._post('/enumerate', { signal }));
    }
    acquire({ input }) {
        return this.scheduleAction((signal) => __awaiter(this, void 0, void 0, function* () {
            const previous = input.previous == null ? 'null' : input.previous;
            if (this.listening) {
                this.listenPromise[input.path] = (0, utils_1.createDeferred)();
            }
            this.acquirePromise = (0, utils_1.createDeferred)();
            const response = yield this._post('/acquire', {
                params: `${input.path}/${previous}`,
                timeout: true,
                signal,
            });
            this.acquirePromise.resolve(undefined);
            if (!response.success) {
                return response;
            }
            this.acquiredUnconfirmed[input.path] = response.payload;
            if (!this.listenPromise[input.path]) {
                return this.success(response.payload);
            }
            return this.listenPromise[input.path].promise.finally(() => {
                delete this.listenPromise[input.path];
            });
        }), undefined, [ERRORS.DEVICE_DISCONNECTED_DURING_ACTION, ERRORS.SESSION_WRONG_PREVIOUS]);
    }
    release({ path, session, onClose }) {
        return this.scheduleAction(signal => {
            if (this.listening && !onClose) {
                this.releasingSession = session;
                this.listenPromise[path] = (0, utils_1.createDeferred)();
            }
            const releasePromise = this._post('/release', {
                params: session,
                signal,
            });
            if (onClose) {
                return Promise.resolve(this.success(undefined));
            }
            if (!this.listenPromise[path]) {
                return releasePromise;
            }
            return this.listenPromise[path].promise
                .then(() => this.success(undefined))
                .finally(() => {
                delete this.listenPromise[path];
            });
        });
    }
    releaseDevice() {
        return Promise.resolve(this.success(undefined));
    }
    call({ session, name, data, }) {
        return this.scheduleAction((signal) => __awaiter(this, void 0, void 0, function* () {
            const { messages } = this;
            const o = (0, send_1.buildOne)(messages, name, data);
            const outData = o.toString('hex');
            const response = yield this._post(`/call`, {
                params: session,
                body: outData,
                signal,
            });
            if (!response.success) {
                return response;
            }
            const jsonData = (0, receive_1.receiveOne)(this.messages, response.payload);
            return this.success(jsonData);
        }), { timeout: undefined });
    }
    send({ session, name, data, }) {
        return this.scheduleAction((signal) => __awaiter(this, void 0, void 0, function* () {
            const { messages } = this;
            const outData = (0, send_1.buildOne)(messages, name, data).toString('hex');
            const response = yield this._post('/post', {
                params: session,
                body: outData,
                signal,
            });
            if (!response.success) {
                return response;
            }
            return this.success(undefined);
        }));
    }
    receive({ session }) {
        return this.scheduleAction((signal) => __awaiter(this, void 0, void 0, function* () {
            const response = yield this._post('/read', {
                params: session,
                signal,
            });
            if (!response.success) {
                return response;
            }
            const jsonData = (0, receive_1.receiveOne)(this.messages, response.payload);
            return this.success(jsonData);
        }));
    }
    stop() {
        this.stopped = true;
        this.listening = false;
        this.abortController.abort();
    }
    _post(endpoint, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { timeout, signal } = options, restOptions = __rest(options, ["timeout", "signal"]);
            const response = yield (0, bridgeApiCall_1.bridgeApiCall)(Object.assign(Object.assign({}, restOptions), { method: 'POST', url: `${this.url + endpoint}${(options === null || options === void 0 ? void 0 : options.params) ? `/${options.params}` : ''}`, skipContentTypeHeader: true }));
            if (!response.success) {
                if (response.error === ERRORS.UNEXPECTED_ERROR) {
                    return response;
                }
                if (response.error === ERRORS.HTTP_ERROR) {
                    return this.error({ error: response.error });
                }
                switch (endpoint) {
                    case '/':
                        return this.unknownError(response.error, []);
                    case '/acquire':
                        return this.unknownError(response.error, [
                            ERRORS.SESSION_WRONG_PREVIOUS,
                            ERRORS.DEVICE_NOT_FOUND,
                            ERRORS.INTERFACE_UNABLE_TO_OPEN_DEVICE,
                            ERRORS.DEVICE_DISCONNECTED_DURING_ACTION,
                        ]);
                    case '/read':
                    case '/call':
                        return this.unknownError(response.error, [
                            ERRORS.SESSION_NOT_FOUND,
                            ERRORS.DEVICE_DISCONNECTED_DURING_ACTION,
                            ERRORS.OTHER_CALL_IN_PROGRESS,
                        ]);
                    case '/enumerate':
                    case '/listen':
                        return this.unknownError(response.error, []);
                    case '/post':
                        return this.unknownError(response.error, [
                            ERRORS.SESSION_NOT_FOUND,
                            ERRORS.DEVICE_DISCONNECTED_DURING_ACTION,
                            ERRORS.OTHER_CALL_IN_PROGRESS,
                        ]);
                    case '/release':
                        return this.unknownError(response.error, [
                            ERRORS.SESSION_NOT_FOUND,
                            ERRORS.DEVICE_DISCONNECTED_DURING_ACTION,
                        ]);
                    default:
                        return this.error({
                            error: ERRORS.WRONG_RESULT_TYPE,
                            message: 'just for type safety, should never happen',
                        });
                }
            }
            switch (endpoint) {
                case '/':
                    return bridgeApiResult.info(response.payload);
                case '/acquire':
                    return bridgeApiResult.acquire(response.payload);
                case '/read':
                case '/call':
                    return bridgeApiResult.call(response.payload);
                case '/enumerate':
                case '/listen':
                    return bridgeApiResult.devices(response.payload);
                case '/post':
                case '/release':
                    return bridgeApiResult.empty(response.payload);
                default:
                    return this.error({
                        error: ERRORS.WRONG_RESULT_TYPE,
                        message: 'just for type safety, should never happen',
                    });
            }
        });
    }
}
exports.BridgeTransport = BridgeTransport;
//# sourceMappingURL=bridge.js.map