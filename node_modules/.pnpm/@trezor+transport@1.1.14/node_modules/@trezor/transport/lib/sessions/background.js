"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionsBackground = void 0;
const utils_1 = require("@trezor/utils");
const typedEventEmitter_1 = require("@trezor/utils/lib/typedEventEmitter");
const ERRORS = __importStar(require("../errors"));
const lockDuration = 1000 * 4;
class SessionsBackground extends typedEventEmitter_1.TypedEmitter {
    constructor() {
        super(...arguments);
        this.sessions = {};
        this.locksQueue = [];
        this.locksTimeoutQueue = [];
        this.lastSession = 0;
    }
    handleMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            let result;
            try {
                switch (message.type) {
                    case 'handshake':
                        result = this.handshake();
                        break;
                    case 'enumerateIntent':
                        result = yield this.enumerateIntent();
                        break;
                    case 'enumerateDone':
                        result = yield this.enumerateDone(message.payload);
                        break;
                    case 'acquireIntent':
                        result = yield this.acquireIntent(message.payload);
                        break;
                    case 'acquireDone':
                        result = yield this.acquireDone(message.payload);
                        break;
                    case 'getSessions':
                        result = yield this.getSessions();
                        break;
                    case 'releaseIntent':
                        result = yield this.releaseIntent(message.payload);
                        break;
                    case 'releaseDone':
                        result = yield this.releaseDone(message.payload);
                        break;
                    case 'getPathBySession':
                        result = this.getPathBySession(message.payload);
                        break;
                    default:
                        throw new Error(ERRORS.UNEXPECTED_ERROR);
                }
                return Object.assign(Object.assign({}, result), { id: message.id });
            }
            catch (err) {
                return Object.assign(Object.assign({}, this.error(ERRORS.UNEXPECTED_ERROR)), { id: message.type });
            }
            finally {
                if (result && result.success && result.payload && 'descriptors' in result.payload) {
                    const { descriptors } = result.payload;
                    setTimeout(() => this.emit('descriptors', descriptors), 0);
                }
            }
        });
    }
    handshake() {
        return this.success(undefined);
    }
    enumerateIntent() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.waitInQueue();
            return this.success({ sessions: this.sessions });
        });
    }
    enumerateDone(payload) {
        this.clearLock();
        const disconnectedDevices = this.filterDisconnectedDevices(this.sessionsToDescriptors(), payload.paths);
        disconnectedDevices.forEach(d => {
            delete this.sessions[d.path];
        });
        payload.paths.forEach(d => {
            if (!this.sessions[d]) {
                this.sessions[d] = null;
            }
        });
        const descriptors = this.sessionsToDescriptors();
        return Promise.resolve(this.success({
            sessions: this.sessions,
            descriptors,
        }));
    }
    acquireIntent(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            const previous = this.sessions[payload.path];
            if (payload.previous && payload.previous !== previous) {
                return this.error(ERRORS.SESSION_WRONG_PREVIOUS);
            }
            yield this.waitInQueue();
            if (previous !== this.sessions[payload.path]) {
                this.clearLock();
                return this.error(ERRORS.SESSION_WRONG_PREVIOUS);
            }
            const unconfirmedSessions = JSON.parse(JSON.stringify(this.sessions));
            const id = `${this.getNewSessionId()}`;
            unconfirmedSessions[payload.path] = id;
            const descriptors = this.sessionsToDescriptors(unconfirmedSessions);
            return this.success({
                session: id,
                descriptors,
            });
        });
    }
    acquireDone(payload) {
        this.clearLock();
        this.sessions[payload.path] = `${this.lastSession}`;
        const descriptors = this.sessionsToDescriptors();
        return Promise.resolve(this.success({
            descriptors,
        }));
    }
    releaseIntent(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = this._getPathBySession({ session: payload.session });
            if (!path) {
                return this.error(ERRORS.SESSION_NOT_FOUND);
            }
            yield this.waitInQueue();
            return this.success({ path });
        });
    }
    releaseDone(payload) {
        this.sessions[payload.path] = null;
        this.clearLock();
        const descriptors = this.sessionsToDescriptors();
        return Promise.resolve(this.success({ descriptors }));
    }
    getSessions() {
        return Promise.resolve(this.success({ sessions: this.sessions }));
    }
    getPathBySession({ session }) {
        const path = this._getPathBySession({ session });
        if (!path) {
            return this.error(ERRORS.SESSION_NOT_FOUND);
        }
        return this.success({ path });
    }
    _getPathBySession({ session }) {
        let path;
        Object.keys(this.sessions).forEach(pathKey => {
            if (this.sessions[pathKey] === session) {
                path = pathKey;
            }
        });
        return path;
    }
    startLock() {
        const dfd = (0, utils_1.createDeferred)();
        const timeout = setTimeout(() => {
            dfd.resolve(undefined);
        }, lockDuration);
        this.locksQueue.push(dfd);
        this.locksTimeoutQueue.push(timeout);
        return this.locksQueue.length - 1;
    }
    clearLock() {
        const lock = this.locksQueue[0];
        if (lock) {
            this.locksQueue[0].resolve(undefined);
            this.locksQueue.shift();
            clearTimeout(this.locksTimeoutQueue[0]);
            this.locksTimeoutQueue.shift();
        }
        else {
            console.warn('empty lock queue');
        }
    }
    waitForUnlocked(myIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            if (myIndex > 0) {
                const beforeMe = this.locksQueue.slice(0, myIndex);
                if (beforeMe.length) {
                    yield Promise.all(beforeMe.map(dfd => dfd.promise));
                }
            }
        });
    }
    waitInQueue() {
        return __awaiter(this, void 0, void 0, function* () {
            const myIndex = this.startLock();
            yield this.waitForUnlocked(myIndex);
        });
    }
    getNewSessionId() {
        this.lastSession++;
        return this.lastSession;
    }
    sessionsToDescriptors(sessions) {
        return Object.entries(sessions || this.sessions).map(obj => ({
            path: obj[0],
            session: obj[1],
        }));
    }
    filterDisconnectedDevices(prevDevices, paths) {
        return prevDevices.filter(d => !paths.find(p => d.path === p));
    }
    success(payload) {
        return {
            success: true,
            payload,
        };
    }
    error(error) {
        return {
            success: false,
            error,
        };
    }
}
exports.SessionsBackground = SessionsBackground;
//# sourceMappingURL=background.js.map