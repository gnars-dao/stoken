import { Amount } from '@pioneer-platform/swapkit-entities';
import type { AmountWithBaseDenom } from '@pioneer-platform/types';
import type { ARBToolbox } from '@pioneer-platform/toolbox-evm';
import { AssetAmount } from '@pioneer-platform/swapkit-entities';
import { AssetEntity } from '@pioneer-platform/swapkit-entities';
import type { AVAXToolbox } from '@pioneer-platform/toolbox-evm';
import type { BaseWalletMethods } from '@pioneer-platform/types';
import type { BCHToolbox } from '@pioneer-platform/toolbox-utxo';
import type { BinanceToolbox } from '@pioneer-platform/toolbox-cosmos';
import type { BSCToolbox } from '@pioneer-platform/toolbox-evm';
import type { BTCToolbox } from '@pioneer-platform/toolbox-utxo';
import { Chain } from '@pioneer-platform/types';
import type { CosmosMaxSendableAmountParams } from '@pioneer-platform/toolbox-cosmos';
import type { DepositParam } from '@pioneer-platform/toolbox-cosmos';
import type { DOGEToolbox } from '@pioneer-platform/toolbox-utxo';
import type { ETHToolbox } from '@pioneer-platform/toolbox-evm';
import type { EVMMaxSendableAmountsParams } from '@pioneer-platform/toolbox-evm';
import type { EVMWalletOptions } from '@pioneer-platform/types';
import type { ExtendParams } from '@pioneer-platform/types';
import type { FeeOption } from '@pioneer-platform/types';
import type { GaiaToolbox } from '@pioneer-platform/toolbox-cosmos';
import type { LTCToolbox } from '@pioneer-platform/toolbox-utxo';
import type { MATICToolbox } from '@pioneer-platform/toolbox-evm';
import type { OPToolbox } from '@pioneer-platform/toolbox-evm';
import type { Pool } from '@pioneer-platform/swapkit-entities';
import type { QuoteRoute } from '@pioneer-platform/swapkit-api';
import type { ThorchainToolboxType } from '@pioneer-platform/toolbox-cosmos';
import type { ThornameRegisterParam } from '@pioneer-platform/swapkit-entities';
import type { TxParams } from '@pioneer-platform/types';
import type { UTXOEstimateFeeParams } from '@pioneer-platform/toolbox-utxo';
import type { WalletOption } from '@pioneer-platform/types';

export declare type AddLiquidityParams = {
    pool: Pool;
    isPendingSymmAsset?: boolean;
    runeAmount?: AssetAmount;
    assetAmount?: AssetAmount;
    runeAddr?: string;
    assetAddr?: string;
    mode?: LPType;
};

export declare type AddLiquidityTxns = {
    runeTx?: string;
    assetTx?: string;
};

export declare type ChainWallet = {
    address: string;
    balance: AssetAmount[];
    walletType: WalletOption;
};

export declare type CoreTxParams = {
    assetAmount: AssetAmount;
    recipient: string;
    memo?: string;
    feeOptionKey?: FeeOption;
    feeRate?: number;
    data?: string;
    from?: string;
};

export declare type CosmosBasedWallet<T extends typeof BinanceToolbox | typeof GaiaToolbox> = BaseWalletMethods & ReturnType<T> & {
    transfer: (params: TxParams) => Promise<string>;
};

export declare type CreateLiquidityParams = {
    runeAmount: AssetAmount;
    assetAmount: AssetAmount;
};

export declare type EVMWallet<T extends typeof AVAXToolbox | typeof BSCToolbox | typeof ETHToolbox | typeof OPToolbox> = BaseWalletMethods & ReturnType<T> & {
    transfer: (params: TxParams) => Promise<string>;
};

declare type LPType = 'sym' | 'rune' | 'asset';

export declare class SwapKitCore<T = ''> {
    connectedChains: Wallet;
    connectedWallets: WalletMethods;
    readonly stagenet: boolean;
    constructor({ stagenet }?: {
        stagenet?: boolean;
    } | undefined);
    getAddress: (chain: Chain) => string;
    getExplorerTxUrl: (chain: Chain, txHash: string) => string;
    getWallet: <T_1 extends Chain>(chain: Chain) => WalletMethods[T_1];
    getExplorerAddressUrl: (chain: Chain, address: string) => string;
    getBalance: (chain: Chain, refresh?: boolean) => Promise<AssetAmount[]>;
    swap: ({ streamSwap, recipient, route, feeOptionKey }: SwapParams) => Promise<string>;
    approveAsset: (asset: AssetEntity, amount?: AmountWithBaseDenom) => Promise<string | true>;
    approveAssetForContract: (asset: AssetEntity, contractAddress: string, amount?: AmountWithBaseDenom) => Promise<string | true>;
    getWalletByChain: (chain: Chain) => Promise<{
        balance: AssetAmount[];
        address?: string | undefined;
        walletType?: WalletOption | undefined;
    } | null>;
    isAssetApproved: (asset: AssetEntity, amount?: AmountWithBaseDenom) => Promise<boolean>;
    isAssetApprovedForContract: (asset: AssetEntity, contractAddress: string, amount?: AmountWithBaseDenom) => Promise<boolean>;
    validateAddress: ({ address, chain }: {
        address: string;
        chain: Chain;
    }) => boolean | Promise<boolean> | undefined;
    transfer: (params: CoreTxParams & {
        router?: string;
    }) => Promise<string>;
    deposit: ({ assetAmount, recipient, router, ...rest }: CoreTxParams & {
        router?: string | undefined;
    }) => Promise<string>;
    /**
     * TC related Methods
     */
    createLiquidity: ({ runeAmount, assetAmount }: CreateLiquidityParams) => Promise<{
        runeTx: string;
        assetTx: string;
    }>;
    addLiquidity: ({ pool, runeAmount, assetAmount, runeAddr, assetAddr, isPendingSymmAsset, mode, }: AddLiquidityParams) => Promise<{
        runeTx: string | undefined;
        assetTx: string | undefined;
    }>;
    withdraw: ({ memo, asset, percent, from, to }: WithdrawParams) => Promise<string>;
    addSavings: ({ assetAmount, memo }: {
        assetAmount: AssetAmount;
        memo?: string | undefined;
    }) => Promise<string>;
    withdrawSavings: ({ memo, asset, percent, }: {
        memo?: string | undefined;
        asset: AssetEntity;
        percent: Amount;
    }) => Promise<string>;
    openLoan: ({ assetAmount, assetTicker, borrowAmount, memo, }: {
        assetAmount: AssetAmount;
        assetTicker: string;
        borrowAmount?: Amount | undefined;
        memo?: string | undefined;
    }) => Promise<string>;
    closeLoan: ({ assetAmount, assetTicker, borrowAmount, memo, }: {
        assetAmount: AssetAmount;
        assetTicker: string;
        borrowAmount?: Amount | undefined;
        memo?: string | undefined;
    }) => Promise<string>;
    registerThorname: (param: ThornameRegisterParam, amount: Amount) => Promise<string>;
    bond: (address: string, amount: Amount) => Promise<string>;
    unbond: (address: string, unbondAmount: number) => Promise<string>;
    leave: (address: string) => Promise<string>;
    /**
     * Wallet connection methods
     */
    connectXDEFI: (_chains: Chain[]) => Promise<void>;
    connectEVMWallet: (_chains: Chain[] | Chain, _wallet: EVMWalletOptions) => Promise<void>;
    connectWalletconnect: (_chains: Chain[], _options?: any) => Promise<void>;
    connectKeystore: (_chains: Chain[], _phrase: string) => Promise<void>;
    connectLedger: (_chains: Chain, _derivationPath: number[]) => Promise<void>;
    connectTrezor: (_chains: Chain, _derivationPath: number[]) => Promise<void>;
    connectKeplr: () => Promise<void>;
    connectOkx: (_chains: Chain[]) => Promise<void>;
    disconnectChain: (chain: Chain) => void;
    extend: ({ wallets, config, apis, rpcUrls }: ExtendParams<T>) => void;
    estimateMaxSendableAmount: ({ chain, params, }: {
        chain: Chain;
        params: Omit<UTXOEstimateFeeParams | EVMMaxSendableAmountsParams | CosmosMaxSendableAmountParams, 'toolbox'>;
    }) => Promise<AmountWithBaseDenom>;
    /**
     * Private methods (internal use only ¯\_(ツ)_/¯)
     */
    private _getInboundDataByChain;
    private _addConnectedChain;
    private _approve;
    private _depositToPool;
    private _thorchainTransfer;
    private _prepareTxParams;
}

export declare type SwapParams = {
    recipient: string;
    streamSwap?: boolean;
    route: QuoteRoute;
    feeOptionKey: FeeOption;
};

export declare type ThorchainWallet = BaseWalletMethods & ThorchainToolboxType & {
    transfer: (params: TxParams) => Promise<string>;
    deposit: (params: DepositParam) => Promise<string>;
};

export declare type UpgradeParams = {
    runeAmount: AssetAmount;
    recipient: string;
};

export declare type UTXOWallet<T extends typeof BCHToolbox | typeof BTCToolbox | typeof DOGEToolbox | typeof LTCToolbox> = BaseWalletMethods & ReturnType<T> & {
    transfer: (prams: TxParams) => Promise<string>;
};

export declare type Wallet = Record<Chain, ChainWallet | null>;

export declare type WalletMethods = {
    [Chain.Arbitrum]: EVMWallet<typeof ARBToolbox> | null;
    [Chain.Avalanche]: EVMWallet<typeof AVAXToolbox> | null;
    [Chain.BinanceSmartChain]: EVMWallet<typeof BSCToolbox> | null;
    [Chain.Binance]: CosmosBasedWallet<typeof BinanceToolbox> | null;
    [Chain.BitcoinCash]: UTXOWallet<typeof BCHToolbox> | null;
    [Chain.Bitcoin]: UTXOWallet<typeof BTCToolbox> | null;
    [Chain.Cosmos]: CosmosBasedWallet<typeof GaiaToolbox> | null;
    [Chain.Dogecoin]: UTXOWallet<typeof DOGEToolbox> | null;
    [Chain.Ethereum]: EVMWallet<typeof ETHToolbox> | null;
    [Chain.Litecoin]: UTXOWallet<typeof LTCToolbox> | null;
    [Chain.THORChain]: ThorchainWallet | null;
    [Chain.Optimism]: EVMWallet<typeof OPToolbox> | null;
    [Chain.Polygon]: EVMWallet<typeof MATICToolbox> | null;
};

export declare type WithdrawParams = {
    memo?: string;
    asset: AssetEntity;
    percent: Amount;
    from: LPType;
    to: LPType;
};


export * from "@pioneer-platform/swapkit-entities";
export * from "@pioneer-platform/types";

export { }
