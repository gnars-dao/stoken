var ci = Object.defineProperty;
var yi = (e, n, a) => n in e ? ci(e, n, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[n] = a;
var L = (e, n, a) => (yi(e, typeof n != "symbol" ? n + "" : n, a), a);
var Ti = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function _i(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var _n = { exports: {} };
_n.exports;
(function(e) {
  (function(n, a) {
    function o(p, t) {
      if (!p)
        throw new Error(t || "Assertion failed");
    }
    function m(p, t) {
      p.super_ = t;
      var i = function() {
      };
      i.prototype = t.prototype, p.prototype = new i(), p.prototype.constructor = p;
    }
    function f(p, t, i) {
      if (f.isBN(p))
        return p;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, p !== null && ((t === "le" || t === "be") && (i = t, t = 10), this._init(p || 0, t || 10, i || "be"));
    }
    typeof n == "object" ? n.exports = f : a.BN = f, f.BN = f, f.wordSize = 26;
    var A;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? A = window.Buffer : A = require("buffer").Buffer;
    } catch {
    }
    f.isBN = function(t) {
      return t instanceof f ? !0 : t !== null && typeof t == "object" && t.constructor.wordSize === f.wordSize && Array.isArray(t.words);
    }, f.max = function(t, i) {
      return t.cmp(i) > 0 ? t : i;
    }, f.min = function(t, i) {
      return t.cmp(i) < 0 ? t : i;
    }, f.prototype._init = function(t, i, s) {
      if (typeof t == "number")
        return this._initNumber(t, i, s);
      if (typeof t == "object")
        return this._initArray(t, i, s);
      i === "hex" && (i = 16), o(i === (i | 0) && i >= 2 && i <= 36), t = t.toString().replace(/\s+/g, "");
      var u = 0;
      t[0] === "-" && (u++, this.negative = 1), u < t.length && (i === 16 ? this._parseHex(t, u, s) : (this._parseBase(t, i, u), s === "le" && this._initArray(this.toArray(), i, s)));
    }, f.prototype._initNumber = function(t, i, s) {
      t < 0 && (this.negative = 1, t = -t), t < 67108864 ? (this.words = [t & 67108863], this.length = 1) : t < 4503599627370496 ? (this.words = [
        t & 67108863,
        t / 67108864 & 67108863
      ], this.length = 2) : (o(t < 9007199254740992), this.words = [
        t & 67108863,
        t / 67108864 & 67108863,
        1
      ], this.length = 3), s === "le" && this._initArray(this.toArray(), i, s);
    }, f.prototype._initArray = function(t, i, s) {
      if (o(typeof t.length == "number"), t.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(t.length / 3), this.words = new Array(this.length);
      for (var u = 0; u < this.length; u++)
        this.words[u] = 0;
      var l, c, w = 0;
      if (s === "be")
        for (u = t.length - 1, l = 0; u >= 0; u -= 3)
          c = t[u] | t[u - 1] << 8 | t[u - 2] << 16, this.words[l] |= c << w & 67108863, this.words[l + 1] = c >>> 26 - w & 67108863, w += 24, w >= 26 && (w -= 26, l++);
      else if (s === "le")
        for (u = 0, l = 0; u < t.length; u += 3)
          c = t[u] | t[u + 1] << 8 | t[u + 2] << 16, this.words[l] |= c << w & 67108863, this.words[l + 1] = c >>> 26 - w & 67108863, w += 24, w >= 26 && (w -= 26, l++);
      return this._strip();
    };
    function v(p, t) {
      var i = p.charCodeAt(t);
      if (i >= 48 && i <= 57)
        return i - 48;
      if (i >= 65 && i <= 70)
        return i - 55;
      if (i >= 97 && i <= 102)
        return i - 87;
      o(!1, "Invalid character in " + p);
    }
    function O(p, t, i) {
      var s = v(p, i);
      return i - 1 >= t && (s |= v(p, i - 1) << 4), s;
    }
    f.prototype._parseHex = function(t, i, s) {
      this.length = Math.ceil((t.length - i) / 6), this.words = new Array(this.length);
      for (var u = 0; u < this.length; u++)
        this.words[u] = 0;
      var l = 0, c = 0, w;
      if (s === "be")
        for (u = t.length - 1; u >= i; u -= 2)
          w = O(t, i, u) << l, this.words[c] |= w & 67108863, l >= 18 ? (l -= 18, c += 1, this.words[c] |= w >>> 26) : l += 8;
      else {
        var d = t.length - i;
        for (u = d % 2 === 0 ? i + 1 : i; u < t.length; u += 2)
          w = O(t, i, u) << l, this.words[c] |= w & 67108863, l >= 18 ? (l -= 18, c += 1, this.words[c] |= w >>> 26) : l += 8;
      }
      this._strip();
    };
    function b(p, t, i, s) {
      for (var u = 0, l = 0, c = Math.min(p.length, i), w = t; w < c; w++) {
        var d = p.charCodeAt(w) - 48;
        u *= s, d >= 49 ? l = d - 49 + 10 : d >= 17 ? l = d - 17 + 10 : l = d, o(d >= 0 && l < s, "Invalid character"), u += l;
      }
      return u;
    }
    f.prototype._parseBase = function(t, i, s) {
      this.words = [0], this.length = 1;
      for (var u = 0, l = 1; l <= 67108863; l *= i)
        u++;
      u--, l = l / i | 0;
      for (var c = t.length - s, w = c % u, d = Math.min(c, c - w) + s, r = 0, y = s; y < d; y += u)
        r = b(t, y, y + u, i), this.imuln(l), this.words[0] + r < 67108864 ? this.words[0] += r : this._iaddn(r);
      if (w !== 0) {
        var I = 1;
        for (r = b(t, y, t.length, i), y = 0; y < w; y++)
          I *= i;
        this.imuln(I), this.words[0] + r < 67108864 ? this.words[0] += r : this._iaddn(r);
      }
      this._strip();
    }, f.prototype.copy = function(t) {
      t.words = new Array(this.length);
      for (var i = 0; i < this.length; i++)
        t.words[i] = this.words[i];
      t.length = this.length, t.negative = this.negative, t.red = this.red;
    };
    function D(p, t) {
      p.words = t.words, p.length = t.length, p.negative = t.negative, p.red = t.red;
    }
    if (f.prototype._move = function(t) {
      D(t, this);
    }, f.prototype.clone = function() {
      var t = new f(null);
      return this.copy(t), t;
    }, f.prototype._expand = function(t) {
      for (; this.length < t; )
        this.words[this.length++] = 0;
      return this;
    }, f.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, f.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        f.prototype[Symbol.for("nodejs.util.inspect.custom")] = U;
      } catch {
        f.prototype.inspect = U;
      }
    else
      f.prototype.inspect = U;
    function U() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var j = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], Be = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], ee = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    f.prototype.toString = function(t, i) {
      t = t || 10, i = i | 0 || 1;
      var s;
      if (t === 16 || t === "hex") {
        s = "";
        for (var u = 0, l = 0, c = 0; c < this.length; c++) {
          var w = this.words[c], d = ((w << u | l) & 16777215).toString(16);
          l = w >>> 24 - u & 16777215, u += 2, u >= 26 && (u -= 26, c--), l !== 0 || c !== this.length - 1 ? s = j[6 - d.length] + d + s : s = d + s;
        }
        for (l !== 0 && (s = l.toString(16) + s); s.length % i !== 0; )
          s = "0" + s;
        return this.negative !== 0 && (s = "-" + s), s;
      }
      if (t === (t | 0) && t >= 2 && t <= 36) {
        var r = Be[t], y = ee[t];
        s = "";
        var I = this.clone();
        for (I.negative = 0; !I.isZero(); ) {
          var M = I.modrn(y).toString(t);
          I = I.idivn(y), I.isZero() ? s = M + s : s = j[r - M.length] + M + s;
        }
        for (this.isZero() && (s = "0" + s); s.length % i !== 0; )
          s = "0" + s;
        return this.negative !== 0 && (s = "-" + s), s;
      }
      o(!1, "Base should be between 2 and 36");
    }, f.prototype.toNumber = function() {
      var t = this.words[0];
      return this.length === 2 ? t += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? t += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && o(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -t : t;
    }, f.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, A && (f.prototype.toBuffer = function(t, i) {
      return this.toArrayLike(A, t, i);
    }), f.prototype.toArray = function(t, i) {
      return this.toArrayLike(Array, t, i);
    };
    var ke = function(t, i) {
      return t.allocUnsafe ? t.allocUnsafe(i) : new t(i);
    };
    f.prototype.toArrayLike = function(t, i, s) {
      this._strip();
      var u = this.byteLength(), l = s || Math.max(1, u);
      o(u <= l, "byte array longer than desired length"), o(l > 0, "Requested array length <= 0");
      var c = ke(t, l), w = i === "le" ? "LE" : "BE";
      return this["_toArrayLike" + w](c, u), c;
    }, f.prototype._toArrayLikeLE = function(t, i) {
      for (var s = 0, u = 0, l = 0, c = 0; l < this.length; l++) {
        var w = this.words[l] << c | u;
        t[s++] = w & 255, s < t.length && (t[s++] = w >> 8 & 255), s < t.length && (t[s++] = w >> 16 & 255), c === 6 ? (s < t.length && (t[s++] = w >> 24 & 255), u = 0, c = 0) : (u = w >>> 24, c += 2);
      }
      if (s < t.length)
        for (t[s++] = u; s < t.length; )
          t[s++] = 0;
    }, f.prototype._toArrayLikeBE = function(t, i) {
      for (var s = t.length - 1, u = 0, l = 0, c = 0; l < this.length; l++) {
        var w = this.words[l] << c | u;
        t[s--] = w & 255, s >= 0 && (t[s--] = w >> 8 & 255), s >= 0 && (t[s--] = w >> 16 & 255), c === 6 ? (s >= 0 && (t[s--] = w >> 24 & 255), u = 0, c = 0) : (u = w >>> 24, c += 2);
      }
      if (s >= 0)
        for (t[s--] = u; s >= 0; )
          t[s--] = 0;
    }, Math.clz32 ? f.prototype._countBits = function(t) {
      return 32 - Math.clz32(t);
    } : f.prototype._countBits = function(t) {
      var i = t, s = 0;
      return i >= 4096 && (s += 13, i >>>= 13), i >= 64 && (s += 7, i >>>= 7), i >= 8 && (s += 4, i >>>= 4), i >= 2 && (s += 2, i >>>= 2), s + i;
    }, f.prototype._zeroBits = function(t) {
      if (t === 0)
        return 26;
      var i = t, s = 0;
      return i & 8191 || (s += 13, i >>>= 13), i & 127 || (s += 7, i >>>= 7), i & 15 || (s += 4, i >>>= 4), i & 3 || (s += 2, i >>>= 2), i & 1 || s++, s;
    }, f.prototype.bitLength = function() {
      var t = this.words[this.length - 1], i = this._countBits(t);
      return (this.length - 1) * 26 + i;
    };
    function te(p) {
      for (var t = new Array(p.bitLength()), i = 0; i < t.length; i++) {
        var s = i / 26 | 0, u = i % 26;
        t[i] = p.words[s] >>> u & 1;
      }
      return t;
    }
    f.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var t = 0, i = 0; i < this.length; i++) {
        var s = this._zeroBits(this.words[i]);
        if (t += s, s !== 26)
          break;
      }
      return t;
    }, f.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, f.prototype.toTwos = function(t) {
      return this.negative !== 0 ? this.abs().inotn(t).iaddn(1) : this.clone();
    }, f.prototype.fromTwos = function(t) {
      return this.testn(t - 1) ? this.notn(t).iaddn(1).ineg() : this.clone();
    }, f.prototype.isNeg = function() {
      return this.negative !== 0;
    }, f.prototype.neg = function() {
      return this.clone().ineg();
    }, f.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, f.prototype.iuor = function(t) {
      for (; this.length < t.length; )
        this.words[this.length++] = 0;
      for (var i = 0; i < t.length; i++)
        this.words[i] = this.words[i] | t.words[i];
      return this._strip();
    }, f.prototype.ior = function(t) {
      return o((this.negative | t.negative) === 0), this.iuor(t);
    }, f.prototype.or = function(t) {
      return this.length > t.length ? this.clone().ior(t) : t.clone().ior(this);
    }, f.prototype.uor = function(t) {
      return this.length > t.length ? this.clone().iuor(t) : t.clone().iuor(this);
    }, f.prototype.iuand = function(t) {
      var i;
      this.length > t.length ? i = t : i = this;
      for (var s = 0; s < i.length; s++)
        this.words[s] = this.words[s] & t.words[s];
      return this.length = i.length, this._strip();
    }, f.prototype.iand = function(t) {
      return o((this.negative | t.negative) === 0), this.iuand(t);
    }, f.prototype.and = function(t) {
      return this.length > t.length ? this.clone().iand(t) : t.clone().iand(this);
    }, f.prototype.uand = function(t) {
      return this.length > t.length ? this.clone().iuand(t) : t.clone().iuand(this);
    }, f.prototype.iuxor = function(t) {
      var i, s;
      this.length > t.length ? (i = this, s = t) : (i = t, s = this);
      for (var u = 0; u < s.length; u++)
        this.words[u] = i.words[u] ^ s.words[u];
      if (this !== i)
        for (; u < i.length; u++)
          this.words[u] = i.words[u];
      return this.length = i.length, this._strip();
    }, f.prototype.ixor = function(t) {
      return o((this.negative | t.negative) === 0), this.iuxor(t);
    }, f.prototype.xor = function(t) {
      return this.length > t.length ? this.clone().ixor(t) : t.clone().ixor(this);
    }, f.prototype.uxor = function(t) {
      return this.length > t.length ? this.clone().iuxor(t) : t.clone().iuxor(this);
    }, f.prototype.inotn = function(t) {
      o(typeof t == "number" && t >= 0);
      var i = Math.ceil(t / 26) | 0, s = t % 26;
      this._expand(i), s > 0 && i--;
      for (var u = 0; u < i; u++)
        this.words[u] = ~this.words[u] & 67108863;
      return s > 0 && (this.words[u] = ~this.words[u] & 67108863 >> 26 - s), this._strip();
    }, f.prototype.notn = function(t) {
      return this.clone().inotn(t);
    }, f.prototype.setn = function(t, i) {
      o(typeof t == "number" && t >= 0);
      var s = t / 26 | 0, u = t % 26;
      return this._expand(s + 1), i ? this.words[s] = this.words[s] | 1 << u : this.words[s] = this.words[s] & ~(1 << u), this._strip();
    }, f.prototype.iadd = function(t) {
      var i;
      if (this.negative !== 0 && t.negative === 0)
        return this.negative = 0, i = this.isub(t), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && t.negative !== 0)
        return t.negative = 0, i = this.isub(t), t.negative = 1, i._normSign();
      var s, u;
      this.length > t.length ? (s = this, u = t) : (s = t, u = this);
      for (var l = 0, c = 0; c < u.length; c++)
        i = (s.words[c] | 0) + (u.words[c] | 0) + l, this.words[c] = i & 67108863, l = i >>> 26;
      for (; l !== 0 && c < s.length; c++)
        i = (s.words[c] | 0) + l, this.words[c] = i & 67108863, l = i >>> 26;
      if (this.length = s.length, l !== 0)
        this.words[this.length] = l, this.length++;
      else if (s !== this)
        for (; c < s.length; c++)
          this.words[c] = s.words[c];
      return this;
    }, f.prototype.add = function(t) {
      var i;
      return t.negative !== 0 && this.negative === 0 ? (t.negative = 0, i = this.sub(t), t.negative ^= 1, i) : t.negative === 0 && this.negative !== 0 ? (this.negative = 0, i = t.sub(this), this.negative = 1, i) : this.length > t.length ? this.clone().iadd(t) : t.clone().iadd(this);
    }, f.prototype.isub = function(t) {
      if (t.negative !== 0) {
        t.negative = 0;
        var i = this.iadd(t);
        return t.negative = 1, i._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(t), this.negative = 1, this._normSign();
      var s = this.cmp(t);
      if (s === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var u, l;
      s > 0 ? (u = this, l = t) : (u = t, l = this);
      for (var c = 0, w = 0; w < l.length; w++)
        i = (u.words[w] | 0) - (l.words[w] | 0) + c, c = i >> 26, this.words[w] = i & 67108863;
      for (; c !== 0 && w < u.length; w++)
        i = (u.words[w] | 0) + c, c = i >> 26, this.words[w] = i & 67108863;
      if (c === 0 && w < u.length && u !== this)
        for (; w < u.length; w++)
          this.words[w] = u.words[w];
      return this.length = Math.max(this.length, w), u !== this && (this.negative = 1), this._strip();
    }, f.prototype.sub = function(t) {
      return this.clone().isub(t);
    };
    function He(p, t, i) {
      i.negative = t.negative ^ p.negative;
      var s = p.length + t.length | 0;
      i.length = s, s = s - 1 | 0;
      var u = p.words[0] | 0, l = t.words[0] | 0, c = u * l, w = c & 67108863, d = c / 67108864 | 0;
      i.words[0] = w;
      for (var r = 1; r < s; r++) {
        for (var y = d >>> 26, I = d & 67108863, M = Math.min(r, t.length - 1), N = Math.max(0, r - p.length + 1); N <= M; N++) {
          var q = r - N | 0;
          u = p.words[q] | 0, l = t.words[N] | 0, c = u * l + I, y += c / 67108864 | 0, I = c & 67108863;
        }
        i.words[r] = I | 0, d = y | 0;
      }
      return d !== 0 ? i.words[r] = d | 0 : i.length--, i._strip();
    }
    var R = function(t, i, s) {
      var u = t.words, l = i.words, c = s.words, w = 0, d, r, y, I = u[0] | 0, M = I & 8191, N = I >>> 13, q = u[1] | 0, X = q & 8191, Y = q >>> 13, Et = u[2] | 0, W = Et & 8191, z = Et >>> 13, Ve = u[3] | 0, k = Ve & 8191, H = Ve >>> 13, Rn = u[4] | 0, ne = Rn & 8191, ie = Rn >>> 13, Mn = u[5] | 0, re = Mn & 8191, ae = Mn >>> 13, On = u[6] | 0, se = On & 8191, oe = On >>> 13, Nn = u[7] | 0, ue = Nn & 8191, le = Nn >>> 13, Sn = u[8] | 0, pe = Sn & 8191, de = Sn >>> 13, bn = u[9] | 0, fe = bn & 8191, he = bn >>> 13, In = l[0] | 0, me = In & 8191, ce = In >>> 13, xn = l[1] | 0, ye = xn & 8191, Te = xn >>> 13, Cn = l[2] | 0, _e = Cn & 8191, we = Cn >>> 13, Dn = l[3] | 0, ge = Dn & 8191, Ee = Dn >>> 13, Pn = l[4] | 0, Ae = Pn & 8191, ve = Pn >>> 13, Bn = l[5] | 0, Re = Bn & 8191, Me = Bn >>> 13, Un = l[6] | 0, Oe = Un & 8191, Ne = Un >>> 13, Ln = l[7] | 0, Se = Ln & 8191, be = Ln >>> 13, Hn = l[8] | 0, Ie = Hn & 8191, xe = Hn >>> 13, Vn = l[9] | 0, Ce = Vn & 8191, De = Vn >>> 13;
      s.negative = t.negative ^ i.negative, s.length = 19, d = Math.imul(M, me), r = Math.imul(M, ce), r = r + Math.imul(N, me) | 0, y = Math.imul(N, ce);
      var Vt = (w + d | 0) + ((r & 8191) << 13) | 0;
      w = (y + (r >>> 13) | 0) + (Vt >>> 26) | 0, Vt &= 67108863, d = Math.imul(X, me), r = Math.imul(X, ce), r = r + Math.imul(Y, me) | 0, y = Math.imul(Y, ce), d = d + Math.imul(M, ye) | 0, r = r + Math.imul(M, Te) | 0, r = r + Math.imul(N, ye) | 0, y = y + Math.imul(N, Te) | 0;
      var Ft = (w + d | 0) + ((r & 8191) << 13) | 0;
      w = (y + (r >>> 13) | 0) + (Ft >>> 26) | 0, Ft &= 67108863, d = Math.imul(W, me), r = Math.imul(W, ce), r = r + Math.imul(z, me) | 0, y = Math.imul(z, ce), d = d + Math.imul(X, ye) | 0, r = r + Math.imul(X, Te) | 0, r = r + Math.imul(Y, ye) | 0, y = y + Math.imul(Y, Te) | 0, d = d + Math.imul(M, _e) | 0, r = r + Math.imul(M, we) | 0, r = r + Math.imul(N, _e) | 0, y = y + Math.imul(N, we) | 0;
      var kt = (w + d | 0) + ((r & 8191) << 13) | 0;
      w = (y + (r >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, d = Math.imul(k, me), r = Math.imul(k, ce), r = r + Math.imul(H, me) | 0, y = Math.imul(H, ce), d = d + Math.imul(W, ye) | 0, r = r + Math.imul(W, Te) | 0, r = r + Math.imul(z, ye) | 0, y = y + Math.imul(z, Te) | 0, d = d + Math.imul(X, _e) | 0, r = r + Math.imul(X, we) | 0, r = r + Math.imul(Y, _e) | 0, y = y + Math.imul(Y, we) | 0, d = d + Math.imul(M, ge) | 0, r = r + Math.imul(M, Ee) | 0, r = r + Math.imul(N, ge) | 0, y = y + Math.imul(N, Ee) | 0;
      var Gt = (w + d | 0) + ((r & 8191) << 13) | 0;
      w = (y + (r >>> 13) | 0) + (Gt >>> 26) | 0, Gt &= 67108863, d = Math.imul(ne, me), r = Math.imul(ne, ce), r = r + Math.imul(ie, me) | 0, y = Math.imul(ie, ce), d = d + Math.imul(k, ye) | 0, r = r + Math.imul(k, Te) | 0, r = r + Math.imul(H, ye) | 0, y = y + Math.imul(H, Te) | 0, d = d + Math.imul(W, _e) | 0, r = r + Math.imul(W, we) | 0, r = r + Math.imul(z, _e) | 0, y = y + Math.imul(z, we) | 0, d = d + Math.imul(X, ge) | 0, r = r + Math.imul(X, Ee) | 0, r = r + Math.imul(Y, ge) | 0, y = y + Math.imul(Y, Ee) | 0, d = d + Math.imul(M, Ae) | 0, r = r + Math.imul(M, ve) | 0, r = r + Math.imul(N, Ae) | 0, y = y + Math.imul(N, ve) | 0;
      var $t = (w + d | 0) + ((r & 8191) << 13) | 0;
      w = (y + (r >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, d = Math.imul(re, me), r = Math.imul(re, ce), r = r + Math.imul(ae, me) | 0, y = Math.imul(ae, ce), d = d + Math.imul(ne, ye) | 0, r = r + Math.imul(ne, Te) | 0, r = r + Math.imul(ie, ye) | 0, y = y + Math.imul(ie, Te) | 0, d = d + Math.imul(k, _e) | 0, r = r + Math.imul(k, we) | 0, r = r + Math.imul(H, _e) | 0, y = y + Math.imul(H, we) | 0, d = d + Math.imul(W, ge) | 0, r = r + Math.imul(W, Ee) | 0, r = r + Math.imul(z, ge) | 0, y = y + Math.imul(z, Ee) | 0, d = d + Math.imul(X, Ae) | 0, r = r + Math.imul(X, ve) | 0, r = r + Math.imul(Y, Ae) | 0, y = y + Math.imul(Y, ve) | 0, d = d + Math.imul(M, Re) | 0, r = r + Math.imul(M, Me) | 0, r = r + Math.imul(N, Re) | 0, y = y + Math.imul(N, Me) | 0;
      var qt = (w + d | 0) + ((r & 8191) << 13) | 0;
      w = (y + (r >>> 13) | 0) + (qt >>> 26) | 0, qt &= 67108863, d = Math.imul(se, me), r = Math.imul(se, ce), r = r + Math.imul(oe, me) | 0, y = Math.imul(oe, ce), d = d + Math.imul(re, ye) | 0, r = r + Math.imul(re, Te) | 0, r = r + Math.imul(ae, ye) | 0, y = y + Math.imul(ae, Te) | 0, d = d + Math.imul(ne, _e) | 0, r = r + Math.imul(ne, we) | 0, r = r + Math.imul(ie, _e) | 0, y = y + Math.imul(ie, we) | 0, d = d + Math.imul(k, ge) | 0, r = r + Math.imul(k, Ee) | 0, r = r + Math.imul(H, ge) | 0, y = y + Math.imul(H, Ee) | 0, d = d + Math.imul(W, Ae) | 0, r = r + Math.imul(W, ve) | 0, r = r + Math.imul(z, Ae) | 0, y = y + Math.imul(z, ve) | 0, d = d + Math.imul(X, Re) | 0, r = r + Math.imul(X, Me) | 0, r = r + Math.imul(Y, Re) | 0, y = y + Math.imul(Y, Me) | 0, d = d + Math.imul(M, Oe) | 0, r = r + Math.imul(M, Ne) | 0, r = r + Math.imul(N, Oe) | 0, y = y + Math.imul(N, Ne) | 0;
      var Wt = (w + d | 0) + ((r & 8191) << 13) | 0;
      w = (y + (r >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, d = Math.imul(ue, me), r = Math.imul(ue, ce), r = r + Math.imul(le, me) | 0, y = Math.imul(le, ce), d = d + Math.imul(se, ye) | 0, r = r + Math.imul(se, Te) | 0, r = r + Math.imul(oe, ye) | 0, y = y + Math.imul(oe, Te) | 0, d = d + Math.imul(re, _e) | 0, r = r + Math.imul(re, we) | 0, r = r + Math.imul(ae, _e) | 0, y = y + Math.imul(ae, we) | 0, d = d + Math.imul(ne, ge) | 0, r = r + Math.imul(ne, Ee) | 0, r = r + Math.imul(ie, ge) | 0, y = y + Math.imul(ie, Ee) | 0, d = d + Math.imul(k, Ae) | 0, r = r + Math.imul(k, ve) | 0, r = r + Math.imul(H, Ae) | 0, y = y + Math.imul(H, ve) | 0, d = d + Math.imul(W, Re) | 0, r = r + Math.imul(W, Me) | 0, r = r + Math.imul(z, Re) | 0, y = y + Math.imul(z, Me) | 0, d = d + Math.imul(X, Oe) | 0, r = r + Math.imul(X, Ne) | 0, r = r + Math.imul(Y, Oe) | 0, y = y + Math.imul(Y, Ne) | 0, d = d + Math.imul(M, Se) | 0, r = r + Math.imul(M, be) | 0, r = r + Math.imul(N, Se) | 0, y = y + Math.imul(N, be) | 0;
      var Xt = (w + d | 0) + ((r & 8191) << 13) | 0;
      w = (y + (r >>> 13) | 0) + (Xt >>> 26) | 0, Xt &= 67108863, d = Math.imul(pe, me), r = Math.imul(pe, ce), r = r + Math.imul(de, me) | 0, y = Math.imul(de, ce), d = d + Math.imul(ue, ye) | 0, r = r + Math.imul(ue, Te) | 0, r = r + Math.imul(le, ye) | 0, y = y + Math.imul(le, Te) | 0, d = d + Math.imul(se, _e) | 0, r = r + Math.imul(se, we) | 0, r = r + Math.imul(oe, _e) | 0, y = y + Math.imul(oe, we) | 0, d = d + Math.imul(re, ge) | 0, r = r + Math.imul(re, Ee) | 0, r = r + Math.imul(ae, ge) | 0, y = y + Math.imul(ae, Ee) | 0, d = d + Math.imul(ne, Ae) | 0, r = r + Math.imul(ne, ve) | 0, r = r + Math.imul(ie, Ae) | 0, y = y + Math.imul(ie, ve) | 0, d = d + Math.imul(k, Re) | 0, r = r + Math.imul(k, Me) | 0, r = r + Math.imul(H, Re) | 0, y = y + Math.imul(H, Me) | 0, d = d + Math.imul(W, Oe) | 0, r = r + Math.imul(W, Ne) | 0, r = r + Math.imul(z, Oe) | 0, y = y + Math.imul(z, Ne) | 0, d = d + Math.imul(X, Se) | 0, r = r + Math.imul(X, be) | 0, r = r + Math.imul(Y, Se) | 0, y = y + Math.imul(Y, be) | 0, d = d + Math.imul(M, Ie) | 0, r = r + Math.imul(M, xe) | 0, r = r + Math.imul(N, Ie) | 0, y = y + Math.imul(N, xe) | 0;
      var Yt = (w + d | 0) + ((r & 8191) << 13) | 0;
      w = (y + (r >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, d = Math.imul(fe, me), r = Math.imul(fe, ce), r = r + Math.imul(he, me) | 0, y = Math.imul(he, ce), d = d + Math.imul(pe, ye) | 0, r = r + Math.imul(pe, Te) | 0, r = r + Math.imul(de, ye) | 0, y = y + Math.imul(de, Te) | 0, d = d + Math.imul(ue, _e) | 0, r = r + Math.imul(ue, we) | 0, r = r + Math.imul(le, _e) | 0, y = y + Math.imul(le, we) | 0, d = d + Math.imul(se, ge) | 0, r = r + Math.imul(se, Ee) | 0, r = r + Math.imul(oe, ge) | 0, y = y + Math.imul(oe, Ee) | 0, d = d + Math.imul(re, Ae) | 0, r = r + Math.imul(re, ve) | 0, r = r + Math.imul(ae, Ae) | 0, y = y + Math.imul(ae, ve) | 0, d = d + Math.imul(ne, Re) | 0, r = r + Math.imul(ne, Me) | 0, r = r + Math.imul(ie, Re) | 0, y = y + Math.imul(ie, Me) | 0, d = d + Math.imul(k, Oe) | 0, r = r + Math.imul(k, Ne) | 0, r = r + Math.imul(H, Oe) | 0, y = y + Math.imul(H, Ne) | 0, d = d + Math.imul(W, Se) | 0, r = r + Math.imul(W, be) | 0, r = r + Math.imul(z, Se) | 0, y = y + Math.imul(z, be) | 0, d = d + Math.imul(X, Ie) | 0, r = r + Math.imul(X, xe) | 0, r = r + Math.imul(Y, Ie) | 0, y = y + Math.imul(Y, xe) | 0, d = d + Math.imul(M, Ce) | 0, r = r + Math.imul(M, De) | 0, r = r + Math.imul(N, Ce) | 0, y = y + Math.imul(N, De) | 0;
      var zt = (w + d | 0) + ((r & 8191) << 13) | 0;
      w = (y + (r >>> 13) | 0) + (zt >>> 26) | 0, zt &= 67108863, d = Math.imul(fe, ye), r = Math.imul(fe, Te), r = r + Math.imul(he, ye) | 0, y = Math.imul(he, Te), d = d + Math.imul(pe, _e) | 0, r = r + Math.imul(pe, we) | 0, r = r + Math.imul(de, _e) | 0, y = y + Math.imul(de, we) | 0, d = d + Math.imul(ue, ge) | 0, r = r + Math.imul(ue, Ee) | 0, r = r + Math.imul(le, ge) | 0, y = y + Math.imul(le, Ee) | 0, d = d + Math.imul(se, Ae) | 0, r = r + Math.imul(se, ve) | 0, r = r + Math.imul(oe, Ae) | 0, y = y + Math.imul(oe, ve) | 0, d = d + Math.imul(re, Re) | 0, r = r + Math.imul(re, Me) | 0, r = r + Math.imul(ae, Re) | 0, y = y + Math.imul(ae, Me) | 0, d = d + Math.imul(ne, Oe) | 0, r = r + Math.imul(ne, Ne) | 0, r = r + Math.imul(ie, Oe) | 0, y = y + Math.imul(ie, Ne) | 0, d = d + Math.imul(k, Se) | 0, r = r + Math.imul(k, be) | 0, r = r + Math.imul(H, Se) | 0, y = y + Math.imul(H, be) | 0, d = d + Math.imul(W, Ie) | 0, r = r + Math.imul(W, xe) | 0, r = r + Math.imul(z, Ie) | 0, y = y + Math.imul(z, xe) | 0, d = d + Math.imul(X, Ce) | 0, r = r + Math.imul(X, De) | 0, r = r + Math.imul(Y, Ce) | 0, y = y + Math.imul(Y, De) | 0;
      var Kt = (w + d | 0) + ((r & 8191) << 13) | 0;
      w = (y + (r >>> 13) | 0) + (Kt >>> 26) | 0, Kt &= 67108863, d = Math.imul(fe, _e), r = Math.imul(fe, we), r = r + Math.imul(he, _e) | 0, y = Math.imul(he, we), d = d + Math.imul(pe, ge) | 0, r = r + Math.imul(pe, Ee) | 0, r = r + Math.imul(de, ge) | 0, y = y + Math.imul(de, Ee) | 0, d = d + Math.imul(ue, Ae) | 0, r = r + Math.imul(ue, ve) | 0, r = r + Math.imul(le, Ae) | 0, y = y + Math.imul(le, ve) | 0, d = d + Math.imul(se, Re) | 0, r = r + Math.imul(se, Me) | 0, r = r + Math.imul(oe, Re) | 0, y = y + Math.imul(oe, Me) | 0, d = d + Math.imul(re, Oe) | 0, r = r + Math.imul(re, Ne) | 0, r = r + Math.imul(ae, Oe) | 0, y = y + Math.imul(ae, Ne) | 0, d = d + Math.imul(ne, Se) | 0, r = r + Math.imul(ne, be) | 0, r = r + Math.imul(ie, Se) | 0, y = y + Math.imul(ie, be) | 0, d = d + Math.imul(k, Ie) | 0, r = r + Math.imul(k, xe) | 0, r = r + Math.imul(H, Ie) | 0, y = y + Math.imul(H, xe) | 0, d = d + Math.imul(W, Ce) | 0, r = r + Math.imul(W, De) | 0, r = r + Math.imul(z, Ce) | 0, y = y + Math.imul(z, De) | 0;
      var Zt = (w + d | 0) + ((r & 8191) << 13) | 0;
      w = (y + (r >>> 13) | 0) + (Zt >>> 26) | 0, Zt &= 67108863, d = Math.imul(fe, ge), r = Math.imul(fe, Ee), r = r + Math.imul(he, ge) | 0, y = Math.imul(he, Ee), d = d + Math.imul(pe, Ae) | 0, r = r + Math.imul(pe, ve) | 0, r = r + Math.imul(de, Ae) | 0, y = y + Math.imul(de, ve) | 0, d = d + Math.imul(ue, Re) | 0, r = r + Math.imul(ue, Me) | 0, r = r + Math.imul(le, Re) | 0, y = y + Math.imul(le, Me) | 0, d = d + Math.imul(se, Oe) | 0, r = r + Math.imul(se, Ne) | 0, r = r + Math.imul(oe, Oe) | 0, y = y + Math.imul(oe, Ne) | 0, d = d + Math.imul(re, Se) | 0, r = r + Math.imul(re, be) | 0, r = r + Math.imul(ae, Se) | 0, y = y + Math.imul(ae, be) | 0, d = d + Math.imul(ne, Ie) | 0, r = r + Math.imul(ne, xe) | 0, r = r + Math.imul(ie, Ie) | 0, y = y + Math.imul(ie, xe) | 0, d = d + Math.imul(k, Ce) | 0, r = r + Math.imul(k, De) | 0, r = r + Math.imul(H, Ce) | 0, y = y + Math.imul(H, De) | 0;
      var Qt = (w + d | 0) + ((r & 8191) << 13) | 0;
      w = (y + (r >>> 13) | 0) + (Qt >>> 26) | 0, Qt &= 67108863, d = Math.imul(fe, Ae), r = Math.imul(fe, ve), r = r + Math.imul(he, Ae) | 0, y = Math.imul(he, ve), d = d + Math.imul(pe, Re) | 0, r = r + Math.imul(pe, Me) | 0, r = r + Math.imul(de, Re) | 0, y = y + Math.imul(de, Me) | 0, d = d + Math.imul(ue, Oe) | 0, r = r + Math.imul(ue, Ne) | 0, r = r + Math.imul(le, Oe) | 0, y = y + Math.imul(le, Ne) | 0, d = d + Math.imul(se, Se) | 0, r = r + Math.imul(se, be) | 0, r = r + Math.imul(oe, Se) | 0, y = y + Math.imul(oe, be) | 0, d = d + Math.imul(re, Ie) | 0, r = r + Math.imul(re, xe) | 0, r = r + Math.imul(ae, Ie) | 0, y = y + Math.imul(ae, xe) | 0, d = d + Math.imul(ne, Ce) | 0, r = r + Math.imul(ne, De) | 0, r = r + Math.imul(ie, Ce) | 0, y = y + Math.imul(ie, De) | 0;
      var Jt = (w + d | 0) + ((r & 8191) << 13) | 0;
      w = (y + (r >>> 13) | 0) + (Jt >>> 26) | 0, Jt &= 67108863, d = Math.imul(fe, Re), r = Math.imul(fe, Me), r = r + Math.imul(he, Re) | 0, y = Math.imul(he, Me), d = d + Math.imul(pe, Oe) | 0, r = r + Math.imul(pe, Ne) | 0, r = r + Math.imul(de, Oe) | 0, y = y + Math.imul(de, Ne) | 0, d = d + Math.imul(ue, Se) | 0, r = r + Math.imul(ue, be) | 0, r = r + Math.imul(le, Se) | 0, y = y + Math.imul(le, be) | 0, d = d + Math.imul(se, Ie) | 0, r = r + Math.imul(se, xe) | 0, r = r + Math.imul(oe, Ie) | 0, y = y + Math.imul(oe, xe) | 0, d = d + Math.imul(re, Ce) | 0, r = r + Math.imul(re, De) | 0, r = r + Math.imul(ae, Ce) | 0, y = y + Math.imul(ae, De) | 0;
      var jt = (w + d | 0) + ((r & 8191) << 13) | 0;
      w = (y + (r >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, d = Math.imul(fe, Oe), r = Math.imul(fe, Ne), r = r + Math.imul(he, Oe) | 0, y = Math.imul(he, Ne), d = d + Math.imul(pe, Se) | 0, r = r + Math.imul(pe, be) | 0, r = r + Math.imul(de, Se) | 0, y = y + Math.imul(de, be) | 0, d = d + Math.imul(ue, Ie) | 0, r = r + Math.imul(ue, xe) | 0, r = r + Math.imul(le, Ie) | 0, y = y + Math.imul(le, xe) | 0, d = d + Math.imul(se, Ce) | 0, r = r + Math.imul(se, De) | 0, r = r + Math.imul(oe, Ce) | 0, y = y + Math.imul(oe, De) | 0;
      var en = (w + d | 0) + ((r & 8191) << 13) | 0;
      w = (y + (r >>> 13) | 0) + (en >>> 26) | 0, en &= 67108863, d = Math.imul(fe, Se), r = Math.imul(fe, be), r = r + Math.imul(he, Se) | 0, y = Math.imul(he, be), d = d + Math.imul(pe, Ie) | 0, r = r + Math.imul(pe, xe) | 0, r = r + Math.imul(de, Ie) | 0, y = y + Math.imul(de, xe) | 0, d = d + Math.imul(ue, Ce) | 0, r = r + Math.imul(ue, De) | 0, r = r + Math.imul(le, Ce) | 0, y = y + Math.imul(le, De) | 0;
      var tn = (w + d | 0) + ((r & 8191) << 13) | 0;
      w = (y + (r >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, d = Math.imul(fe, Ie), r = Math.imul(fe, xe), r = r + Math.imul(he, Ie) | 0, y = Math.imul(he, xe), d = d + Math.imul(pe, Ce) | 0, r = r + Math.imul(pe, De) | 0, r = r + Math.imul(de, Ce) | 0, y = y + Math.imul(de, De) | 0;
      var nn = (w + d | 0) + ((r & 8191) << 13) | 0;
      w = (y + (r >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, d = Math.imul(fe, Ce), r = Math.imul(fe, De), r = r + Math.imul(he, Ce) | 0, y = Math.imul(he, De);
      var rn = (w + d | 0) + ((r & 8191) << 13) | 0;
      return w = (y + (r >>> 13) | 0) + (rn >>> 26) | 0, rn &= 67108863, c[0] = Vt, c[1] = Ft, c[2] = kt, c[3] = Gt, c[4] = $t, c[5] = qt, c[6] = Wt, c[7] = Xt, c[8] = Yt, c[9] = zt, c[10] = Kt, c[11] = Zt, c[12] = Qt, c[13] = Jt, c[14] = jt, c[15] = en, c[16] = tn, c[17] = nn, c[18] = rn, w !== 0 && (c[19] = w, s.length++), s;
    };
    Math.imul || (R = He);
    function it(p, t, i) {
      i.negative = t.negative ^ p.negative, i.length = p.length + t.length;
      for (var s = 0, u = 0, l = 0; l < i.length - 1; l++) {
        var c = u;
        u = 0;
        for (var w = s & 67108863, d = Math.min(l, t.length - 1), r = Math.max(0, l - p.length + 1); r <= d; r++) {
          var y = l - r, I = p.words[y] | 0, M = t.words[r] | 0, N = I * M, q = N & 67108863;
          c = c + (N / 67108864 | 0) | 0, q = q + w | 0, w = q & 67108863, c = c + (q >>> 26) | 0, u += c >>> 26, c &= 67108863;
        }
        i.words[l] = w, s = c, c = u;
      }
      return s !== 0 ? i.words[l] = s : i.length--, i._strip();
    }
    function mt(p, t, i) {
      return it(p, t, i);
    }
    f.prototype.mulTo = function(t, i) {
      var s, u = this.length + t.length;
      return this.length === 10 && t.length === 10 ? s = R(this, t, i) : u < 63 ? s = He(this, t, i) : u < 1024 ? s = it(this, t, i) : s = mt(this, t, i), s;
    }, f.prototype.mul = function(t) {
      var i = new f(null);
      return i.words = new Array(this.length + t.length), this.mulTo(t, i);
    }, f.prototype.mulf = function(t) {
      var i = new f(null);
      return i.words = new Array(this.length + t.length), mt(this, t, i);
    }, f.prototype.imul = function(t) {
      return this.clone().mulTo(t, this);
    }, f.prototype.imuln = function(t) {
      var i = t < 0;
      i && (t = -t), o(typeof t == "number"), o(t < 67108864);
      for (var s = 0, u = 0; u < this.length; u++) {
        var l = (this.words[u] | 0) * t, c = (l & 67108863) + (s & 67108863);
        s >>= 26, s += l / 67108864 | 0, s += c >>> 26, this.words[u] = c & 67108863;
      }
      return s !== 0 && (this.words[u] = s, this.length++), i ? this.ineg() : this;
    }, f.prototype.muln = function(t) {
      return this.clone().imuln(t);
    }, f.prototype.sqr = function() {
      return this.mul(this);
    }, f.prototype.isqr = function() {
      return this.imul(this.clone());
    }, f.prototype.pow = function(t) {
      var i = te(t);
      if (i.length === 0)
        return new f(1);
      for (var s = this, u = 0; u < i.length && i[u] === 0; u++, s = s.sqr())
        ;
      if (++u < i.length)
        for (var l = s.sqr(); u < i.length; u++, l = l.sqr())
          i[u] !== 0 && (s = s.mul(l));
      return s;
    }, f.prototype.iushln = function(t) {
      o(typeof t == "number" && t >= 0);
      var i = t % 26, s = (t - i) / 26, u = 67108863 >>> 26 - i << 26 - i, l;
      if (i !== 0) {
        var c = 0;
        for (l = 0; l < this.length; l++) {
          var w = this.words[l] & u, d = (this.words[l] | 0) - w << i;
          this.words[l] = d | c, c = w >>> 26 - i;
        }
        c && (this.words[l] = c, this.length++);
      }
      if (s !== 0) {
        for (l = this.length - 1; l >= 0; l--)
          this.words[l + s] = this.words[l];
        for (l = 0; l < s; l++)
          this.words[l] = 0;
        this.length += s;
      }
      return this._strip();
    }, f.prototype.ishln = function(t) {
      return o(this.negative === 0), this.iushln(t);
    }, f.prototype.iushrn = function(t, i, s) {
      o(typeof t == "number" && t >= 0);
      var u;
      i ? u = (i - i % 26) / 26 : u = 0;
      var l = t % 26, c = Math.min((t - l) / 26, this.length), w = 67108863 ^ 67108863 >>> l << l, d = s;
      if (u -= c, u = Math.max(0, u), d) {
        for (var r = 0; r < c; r++)
          d.words[r] = this.words[r];
        d.length = c;
      }
      if (c !== 0)
        if (this.length > c)
          for (this.length -= c, r = 0; r < this.length; r++)
            this.words[r] = this.words[r + c];
        else
          this.words[0] = 0, this.length = 1;
      var y = 0;
      for (r = this.length - 1; r >= 0 && (y !== 0 || r >= u); r--) {
        var I = this.words[r] | 0;
        this.words[r] = y << 26 - l | I >>> l, y = I & w;
      }
      return d && y !== 0 && (d.words[d.length++] = y), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, f.prototype.ishrn = function(t, i, s) {
      return o(this.negative === 0), this.iushrn(t, i, s);
    }, f.prototype.shln = function(t) {
      return this.clone().ishln(t);
    }, f.prototype.ushln = function(t) {
      return this.clone().iushln(t);
    }, f.prototype.shrn = function(t) {
      return this.clone().ishrn(t);
    }, f.prototype.ushrn = function(t) {
      return this.clone().iushrn(t);
    }, f.prototype.testn = function(t) {
      o(typeof t == "number" && t >= 0);
      var i = t % 26, s = (t - i) / 26, u = 1 << i;
      if (this.length <= s)
        return !1;
      var l = this.words[s];
      return !!(l & u);
    }, f.prototype.imaskn = function(t) {
      o(typeof t == "number" && t >= 0);
      var i = t % 26, s = (t - i) / 26;
      if (o(this.negative === 0, "imaskn works only with positive numbers"), this.length <= s)
        return this;
      if (i !== 0 && s++, this.length = Math.min(s, this.length), i !== 0) {
        var u = 67108863 ^ 67108863 >>> i << i;
        this.words[this.length - 1] &= u;
      }
      return this._strip();
    }, f.prototype.maskn = function(t) {
      return this.clone().imaskn(t);
    }, f.prototype.iaddn = function(t) {
      return o(typeof t == "number"), o(t < 67108864), t < 0 ? this.isubn(-t) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= t ? (this.words[0] = t - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(t), this.negative = 1, this) : this._iaddn(t);
    }, f.prototype._iaddn = function(t) {
      this.words[0] += t;
      for (var i = 0; i < this.length && this.words[i] >= 67108864; i++)
        this.words[i] -= 67108864, i === this.length - 1 ? this.words[i + 1] = 1 : this.words[i + 1]++;
      return this.length = Math.max(this.length, i + 1), this;
    }, f.prototype.isubn = function(t) {
      if (o(typeof t == "number"), o(t < 67108864), t < 0)
        return this.iaddn(-t);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(t), this.negative = 1, this;
      if (this.words[0] -= t, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var i = 0; i < this.length && this.words[i] < 0; i++)
          this.words[i] += 67108864, this.words[i + 1] -= 1;
      return this._strip();
    }, f.prototype.addn = function(t) {
      return this.clone().iaddn(t);
    }, f.prototype.subn = function(t) {
      return this.clone().isubn(t);
    }, f.prototype.iabs = function() {
      return this.negative = 0, this;
    }, f.prototype.abs = function() {
      return this.clone().iabs();
    }, f.prototype._ishlnsubmul = function(t, i, s) {
      var u = t.length + s, l;
      this._expand(u);
      var c, w = 0;
      for (l = 0; l < t.length; l++) {
        c = (this.words[l + s] | 0) + w;
        var d = (t.words[l] | 0) * i;
        c -= d & 67108863, w = (c >> 26) - (d / 67108864 | 0), this.words[l + s] = c & 67108863;
      }
      for (; l < this.length - s; l++)
        c = (this.words[l + s] | 0) + w, w = c >> 26, this.words[l + s] = c & 67108863;
      if (w === 0)
        return this._strip();
      for (o(w === -1), w = 0, l = 0; l < this.length; l++)
        c = -(this.words[l] | 0) + w, w = c >> 26, this.words[l] = c & 67108863;
      return this.negative = 1, this._strip();
    }, f.prototype._wordDiv = function(t, i) {
      var s = this.length - t.length, u = this.clone(), l = t, c = l.words[l.length - 1] | 0, w = this._countBits(c);
      s = 26 - w, s !== 0 && (l = l.ushln(s), u.iushln(s), c = l.words[l.length - 1] | 0);
      var d = u.length - l.length, r;
      if (i !== "mod") {
        r = new f(null), r.length = d + 1, r.words = new Array(r.length);
        for (var y = 0; y < r.length; y++)
          r.words[y] = 0;
      }
      var I = u.clone()._ishlnsubmul(l, 1, d);
      I.negative === 0 && (u = I, r && (r.words[d] = 1));
      for (var M = d - 1; M >= 0; M--) {
        var N = (u.words[l.length + M] | 0) * 67108864 + (u.words[l.length + M - 1] | 0);
        for (N = Math.min(N / c | 0, 67108863), u._ishlnsubmul(l, N, M); u.negative !== 0; )
          N--, u.negative = 0, u._ishlnsubmul(l, 1, M), u.isZero() || (u.negative ^= 1);
        r && (r.words[M] = N);
      }
      return r && r._strip(), u._strip(), i !== "div" && s !== 0 && u.iushrn(s), {
        div: r || null,
        mod: u
      };
    }, f.prototype.divmod = function(t, i, s) {
      if (o(!t.isZero()), this.isZero())
        return {
          div: new f(0),
          mod: new f(0)
        };
      var u, l, c;
      return this.negative !== 0 && t.negative === 0 ? (c = this.neg().divmod(t, i), i !== "mod" && (u = c.div.neg()), i !== "div" && (l = c.mod.neg(), s && l.negative !== 0 && l.iadd(t)), {
        div: u,
        mod: l
      }) : this.negative === 0 && t.negative !== 0 ? (c = this.divmod(t.neg(), i), i !== "mod" && (u = c.div.neg()), {
        div: u,
        mod: c.mod
      }) : this.negative & t.negative ? (c = this.neg().divmod(t.neg(), i), i !== "div" && (l = c.mod.neg(), s && l.negative !== 0 && l.isub(t)), {
        div: c.div,
        mod: l
      }) : t.length > this.length || this.cmp(t) < 0 ? {
        div: new f(0),
        mod: this
      } : t.length === 1 ? i === "div" ? {
        div: this.divn(t.words[0]),
        mod: null
      } : i === "mod" ? {
        div: null,
        mod: new f(this.modrn(t.words[0]))
      } : {
        div: this.divn(t.words[0]),
        mod: new f(this.modrn(t.words[0]))
      } : this._wordDiv(t, i);
    }, f.prototype.div = function(t) {
      return this.divmod(t, "div", !1).div;
    }, f.prototype.mod = function(t) {
      return this.divmod(t, "mod", !1).mod;
    }, f.prototype.umod = function(t) {
      return this.divmod(t, "mod", !0).mod;
    }, f.prototype.divRound = function(t) {
      var i = this.divmod(t);
      if (i.mod.isZero())
        return i.div;
      var s = i.div.negative !== 0 ? i.mod.isub(t) : i.mod, u = t.ushrn(1), l = t.andln(1), c = s.cmp(u);
      return c < 0 || l === 1 && c === 0 ? i.div : i.div.negative !== 0 ? i.div.isubn(1) : i.div.iaddn(1);
    }, f.prototype.modrn = function(t) {
      var i = t < 0;
      i && (t = -t), o(t <= 67108863);
      for (var s = (1 << 26) % t, u = 0, l = this.length - 1; l >= 0; l--)
        u = (s * u + (this.words[l] | 0)) % t;
      return i ? -u : u;
    }, f.prototype.modn = function(t) {
      return this.modrn(t);
    }, f.prototype.idivn = function(t) {
      var i = t < 0;
      i && (t = -t), o(t <= 67108863);
      for (var s = 0, u = this.length - 1; u >= 0; u--) {
        var l = (this.words[u] | 0) + s * 67108864;
        this.words[u] = l / t | 0, s = l % t;
      }
      return this._strip(), i ? this.ineg() : this;
    }, f.prototype.divn = function(t) {
      return this.clone().idivn(t);
    }, f.prototype.egcd = function(t) {
      o(t.negative === 0), o(!t.isZero());
      var i = this, s = t.clone();
      i.negative !== 0 ? i = i.umod(t) : i = i.clone();
      for (var u = new f(1), l = new f(0), c = new f(0), w = new f(1), d = 0; i.isEven() && s.isEven(); )
        i.iushrn(1), s.iushrn(1), ++d;
      for (var r = s.clone(), y = i.clone(); !i.isZero(); ) {
        for (var I = 0, M = 1; !(i.words[0] & M) && I < 26; ++I, M <<= 1)
          ;
        if (I > 0)
          for (i.iushrn(I); I-- > 0; )
            (u.isOdd() || l.isOdd()) && (u.iadd(r), l.isub(y)), u.iushrn(1), l.iushrn(1);
        for (var N = 0, q = 1; !(s.words[0] & q) && N < 26; ++N, q <<= 1)
          ;
        if (N > 0)
          for (s.iushrn(N); N-- > 0; )
            (c.isOdd() || w.isOdd()) && (c.iadd(r), w.isub(y)), c.iushrn(1), w.iushrn(1);
        i.cmp(s) >= 0 ? (i.isub(s), u.isub(c), l.isub(w)) : (s.isub(i), c.isub(u), w.isub(l));
      }
      return {
        a: c,
        b: w,
        gcd: s.iushln(d)
      };
    }, f.prototype._invmp = function(t) {
      o(t.negative === 0), o(!t.isZero());
      var i = this, s = t.clone();
      i.negative !== 0 ? i = i.umod(t) : i = i.clone();
      for (var u = new f(1), l = new f(0), c = s.clone(); i.cmpn(1) > 0 && s.cmpn(1) > 0; ) {
        for (var w = 0, d = 1; !(i.words[0] & d) && w < 26; ++w, d <<= 1)
          ;
        if (w > 0)
          for (i.iushrn(w); w-- > 0; )
            u.isOdd() && u.iadd(c), u.iushrn(1);
        for (var r = 0, y = 1; !(s.words[0] & y) && r < 26; ++r, y <<= 1)
          ;
        if (r > 0)
          for (s.iushrn(r); r-- > 0; )
            l.isOdd() && l.iadd(c), l.iushrn(1);
        i.cmp(s) >= 0 ? (i.isub(s), u.isub(l)) : (s.isub(i), l.isub(u));
      }
      var I;
      return i.cmpn(1) === 0 ? I = u : I = l, I.cmpn(0) < 0 && I.iadd(t), I;
    }, f.prototype.gcd = function(t) {
      if (this.isZero())
        return t.abs();
      if (t.isZero())
        return this.abs();
      var i = this.clone(), s = t.clone();
      i.negative = 0, s.negative = 0;
      for (var u = 0; i.isEven() && s.isEven(); u++)
        i.iushrn(1), s.iushrn(1);
      do {
        for (; i.isEven(); )
          i.iushrn(1);
        for (; s.isEven(); )
          s.iushrn(1);
        var l = i.cmp(s);
        if (l < 0) {
          var c = i;
          i = s, s = c;
        } else if (l === 0 || s.cmpn(1) === 0)
          break;
        i.isub(s);
      } while (!0);
      return s.iushln(u);
    }, f.prototype.invm = function(t) {
      return this.egcd(t).a.umod(t);
    }, f.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, f.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, f.prototype.andln = function(t) {
      return this.words[0] & t;
    }, f.prototype.bincn = function(t) {
      o(typeof t == "number");
      var i = t % 26, s = (t - i) / 26, u = 1 << i;
      if (this.length <= s)
        return this._expand(s + 1), this.words[s] |= u, this;
      for (var l = u, c = s; l !== 0 && c < this.length; c++) {
        var w = this.words[c] | 0;
        w += l, l = w >>> 26, w &= 67108863, this.words[c] = w;
      }
      return l !== 0 && (this.words[c] = l, this.length++), this;
    }, f.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, f.prototype.cmpn = function(t) {
      var i = t < 0;
      if (this.negative !== 0 && !i)
        return -1;
      if (this.negative === 0 && i)
        return 1;
      this._strip();
      var s;
      if (this.length > 1)
        s = 1;
      else {
        i && (t = -t), o(t <= 67108863, "Number is too big");
        var u = this.words[0] | 0;
        s = u === t ? 0 : u < t ? -1 : 1;
      }
      return this.negative !== 0 ? -s | 0 : s;
    }, f.prototype.cmp = function(t) {
      if (this.negative !== 0 && t.negative === 0)
        return -1;
      if (this.negative === 0 && t.negative !== 0)
        return 1;
      var i = this.ucmp(t);
      return this.negative !== 0 ? -i | 0 : i;
    }, f.prototype.ucmp = function(t) {
      if (this.length > t.length)
        return 1;
      if (this.length < t.length)
        return -1;
      for (var i = 0, s = this.length - 1; s >= 0; s--) {
        var u = this.words[s] | 0, l = t.words[s] | 0;
        if (u !== l) {
          u < l ? i = -1 : u > l && (i = 1);
          break;
        }
      }
      return i;
    }, f.prototype.gtn = function(t) {
      return this.cmpn(t) === 1;
    }, f.prototype.gt = function(t) {
      return this.cmp(t) === 1;
    }, f.prototype.gten = function(t) {
      return this.cmpn(t) >= 0;
    }, f.prototype.gte = function(t) {
      return this.cmp(t) >= 0;
    }, f.prototype.ltn = function(t) {
      return this.cmpn(t) === -1;
    }, f.prototype.lt = function(t) {
      return this.cmp(t) === -1;
    }, f.prototype.lten = function(t) {
      return this.cmpn(t) <= 0;
    }, f.prototype.lte = function(t) {
      return this.cmp(t) <= 0;
    }, f.prototype.eqn = function(t) {
      return this.cmpn(t) === 0;
    }, f.prototype.eq = function(t) {
      return this.cmp(t) === 0;
    }, f.red = function(t) {
      return new E(t);
    }, f.prototype.toRed = function(t) {
      return o(!this.red, "Already a number in reduction context"), o(this.negative === 0, "red works only with positives"), t.convertTo(this)._forceRed(t);
    }, f.prototype.fromRed = function() {
      return o(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, f.prototype._forceRed = function(t) {
      return this.red = t, this;
    }, f.prototype.forceRed = function(t) {
      return o(!this.red, "Already a number in reduction context"), this._forceRed(t);
    }, f.prototype.redAdd = function(t) {
      return o(this.red, "redAdd works only with red numbers"), this.red.add(this, t);
    }, f.prototype.redIAdd = function(t) {
      return o(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, t);
    }, f.prototype.redSub = function(t) {
      return o(this.red, "redSub works only with red numbers"), this.red.sub(this, t);
    }, f.prototype.redISub = function(t) {
      return o(this.red, "redISub works only with red numbers"), this.red.isub(this, t);
    }, f.prototype.redShl = function(t) {
      return o(this.red, "redShl works only with red numbers"), this.red.shl(this, t);
    }, f.prototype.redMul = function(t) {
      return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.mul(this, t);
    }, f.prototype.redIMul = function(t) {
      return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.imul(this, t);
    }, f.prototype.redSqr = function() {
      return o(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, f.prototype.redISqr = function() {
      return o(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, f.prototype.redSqrt = function() {
      return o(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, f.prototype.redInvm = function() {
      return o(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, f.prototype.redNeg = function() {
      return o(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, f.prototype.redPow = function(t) {
      return o(this.red && !t.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, t);
    };
    var ct = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Q(p, t) {
      this.name = p, this.p = new f(t, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Q.prototype._tmp = function() {
      var t = new f(null);
      return t.words = new Array(Math.ceil(this.n / 13)), t;
    }, Q.prototype.ireduce = function(t) {
      var i = t, s;
      do
        this.split(i, this.tmp), i = this.imulK(i), i = i.iadd(this.tmp), s = i.bitLength();
      while (s > this.n);
      var u = s < this.n ? -1 : i.ucmp(this.p);
      return u === 0 ? (i.words[0] = 0, i.length = 1) : u > 0 ? i.isub(this.p) : i.strip !== void 0 ? i.strip() : i._strip(), i;
    }, Q.prototype.split = function(t, i) {
      t.iushrn(this.n, 0, i);
    }, Q.prototype.imulK = function(t) {
      return t.imul(this.k);
    };
    function Ge() {
      Q.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    m(Ge, Q), Ge.prototype.split = function(t, i) {
      for (var s = 4194303, u = Math.min(t.length, 9), l = 0; l < u; l++)
        i.words[l] = t.words[l];
      if (i.length = u, t.length <= 9) {
        t.words[0] = 0, t.length = 1;
        return;
      }
      var c = t.words[9];
      for (i.words[i.length++] = c & s, l = 10; l < t.length; l++) {
        var w = t.words[l] | 0;
        t.words[l - 10] = (w & s) << 4 | c >>> 22, c = w;
      }
      c >>>= 22, t.words[l - 10] = c, c === 0 && t.length > 10 ? t.length -= 10 : t.length -= 9;
    }, Ge.prototype.imulK = function(t) {
      t.words[t.length] = 0, t.words[t.length + 1] = 0, t.length += 2;
      for (var i = 0, s = 0; s < t.length; s++) {
        var u = t.words[s] | 0;
        i += u * 977, t.words[s] = i & 67108863, i = u * 64 + (i / 67108864 | 0);
      }
      return t.words[t.length - 1] === 0 && (t.length--, t.words[t.length - 1] === 0 && t.length--), t;
    };
    function h() {
      Q.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    m(h, Q);
    function T() {
      Q.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    m(T, Q);
    function _() {
      Q.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    m(_, Q), _.prototype.imulK = function(t) {
      for (var i = 0, s = 0; s < t.length; s++) {
        var u = (t.words[s] | 0) * 19 + i, l = u & 67108863;
        u >>>= 26, t.words[s] = l, i = u;
      }
      return i !== 0 && (t.words[t.length++] = i), t;
    }, f._prime = function(t) {
      if (ct[t])
        return ct[t];
      var i;
      if (t === "k256")
        i = new Ge();
      else if (t === "p224")
        i = new h();
      else if (t === "p192")
        i = new T();
      else if (t === "p25519")
        i = new _();
      else
        throw new Error("Unknown prime " + t);
      return ct[t] = i, i;
    };
    function E(p) {
      if (typeof p == "string") {
        var t = f._prime(p);
        this.m = t.p, this.prime = t;
      } else
        o(p.gtn(1), "modulus must be greater than 1"), this.m = p, this.prime = null;
    }
    E.prototype._verify1 = function(t) {
      o(t.negative === 0, "red works only with positives"), o(t.red, "red works only with red numbers");
    }, E.prototype._verify2 = function(t, i) {
      o((t.negative | i.negative) === 0, "red works only with positives"), o(
        t.red && t.red === i.red,
        "red works only with red numbers"
      );
    }, E.prototype.imod = function(t) {
      return this.prime ? this.prime.ireduce(t)._forceRed(this) : (D(t, t.umod(this.m)._forceRed(this)), t);
    }, E.prototype.neg = function(t) {
      return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this);
    }, E.prototype.add = function(t, i) {
      this._verify2(t, i);
      var s = t.add(i);
      return s.cmp(this.m) >= 0 && s.isub(this.m), s._forceRed(this);
    }, E.prototype.iadd = function(t, i) {
      this._verify2(t, i);
      var s = t.iadd(i);
      return s.cmp(this.m) >= 0 && s.isub(this.m), s;
    }, E.prototype.sub = function(t, i) {
      this._verify2(t, i);
      var s = t.sub(i);
      return s.cmpn(0) < 0 && s.iadd(this.m), s._forceRed(this);
    }, E.prototype.isub = function(t, i) {
      this._verify2(t, i);
      var s = t.isub(i);
      return s.cmpn(0) < 0 && s.iadd(this.m), s;
    }, E.prototype.shl = function(t, i) {
      return this._verify1(t), this.imod(t.ushln(i));
    }, E.prototype.imul = function(t, i) {
      return this._verify2(t, i), this.imod(t.imul(i));
    }, E.prototype.mul = function(t, i) {
      return this._verify2(t, i), this.imod(t.mul(i));
    }, E.prototype.isqr = function(t) {
      return this.imul(t, t.clone());
    }, E.prototype.sqr = function(t) {
      return this.mul(t, t);
    }, E.prototype.sqrt = function(t) {
      if (t.isZero())
        return t.clone();
      var i = this.m.andln(3);
      if (o(i % 2 === 1), i === 3) {
        var s = this.m.add(new f(1)).iushrn(2);
        return this.pow(t, s);
      }
      for (var u = this.m.subn(1), l = 0; !u.isZero() && u.andln(1) === 0; )
        l++, u.iushrn(1);
      o(!u.isZero());
      var c = new f(1).toRed(this), w = c.redNeg(), d = this.m.subn(1).iushrn(1), r = this.m.bitLength();
      for (r = new f(2 * r * r).toRed(this); this.pow(r, d).cmp(w) !== 0; )
        r.redIAdd(w);
      for (var y = this.pow(r, u), I = this.pow(t, u.addn(1).iushrn(1)), M = this.pow(t, u), N = l; M.cmp(c) !== 0; ) {
        for (var q = M, X = 0; q.cmp(c) !== 0; X++)
          q = q.redSqr();
        o(X < N);
        var Y = this.pow(y, new f(1).iushln(N - X - 1));
        I = I.redMul(Y), y = Y.redSqr(), M = M.redMul(y), N = X;
      }
      return I;
    }, E.prototype.invm = function(t) {
      var i = t._invmp(this.m);
      return i.negative !== 0 ? (i.negative = 0, this.imod(i).redNeg()) : this.imod(i);
    }, E.prototype.pow = function(t, i) {
      if (i.isZero())
        return new f(1).toRed(this);
      if (i.cmpn(1) === 0)
        return t.clone();
      var s = 4, u = new Array(1 << s);
      u[0] = new f(1).toRed(this), u[1] = t;
      for (var l = 2; l < u.length; l++)
        u[l] = this.mul(u[l - 1], t);
      var c = u[0], w = 0, d = 0, r = i.bitLength() % 26;
      for (r === 0 && (r = 26), l = i.length - 1; l >= 0; l--) {
        for (var y = i.words[l], I = r - 1; I >= 0; I--) {
          var M = y >> I & 1;
          if (c !== u[0] && (c = this.sqr(c)), M === 0 && w === 0) {
            d = 0;
            continue;
          }
          w <<= 1, w |= M, d++, !(d !== s && (l !== 0 || I !== 0)) && (c = this.mul(c, u[w]), d = 0, w = 0);
        }
        r = 26;
      }
      return c;
    }, E.prototype.convertTo = function(t) {
      var i = t.umod(this.m);
      return i === t ? i.clone() : i;
    }, E.prototype.convertFrom = function(t) {
      var i = t.clone();
      return i.red = null, i;
    }, f.mont = function(t) {
      return new g(t);
    };
    function g(p) {
      E.call(this, p), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    m(g, E), g.prototype.convertTo = function(t) {
      return this.imod(t.ushln(this.shift));
    }, g.prototype.convertFrom = function(t) {
      var i = this.imod(t.mul(this.rinv));
      return i.red = null, i;
    }, g.prototype.imul = function(t, i) {
      if (t.isZero() || i.isZero())
        return t.words[0] = 0, t.length = 1, t;
      var s = t.imul(i), u = s.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), l = s.isub(u).iushrn(this.shift), c = l;
      return l.cmp(this.m) >= 0 ? c = l.isub(this.m) : l.cmpn(0) < 0 && (c = l.iadd(this.m)), c._forceRed(this);
    }, g.prototype.mul = function(t, i) {
      if (t.isZero() || i.isZero())
        return new f(0)._forceRed(this);
      var s = t.mul(i), u = s.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), l = s.isub(u).iushrn(this.shift), c = l;
      return l.cmp(this.m) >= 0 ? c = l.isub(this.m) : l.cmpn(0) < 0 && (c = l.iadd(this.m)), c._forceRed(this);
    }, g.prototype.invm = function(t) {
      var i = this.imod(t._invmp(this.m).mul(this.r2));
      return i._forceRed(this);
    };
  })(e, Ti);
})(_n);
var wi = _n.exports;
const gi = /* @__PURE__ */ _i(wi), Ei = "logger/5.7.0";
let Fn = !1, kn = !1;
const Pt = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let Gn = Pt.default, an = null;
function Ai() {
  try {
    const e = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((n) => {
      try {
        if ("test".normalize(n) !== "test")
          throw new Error("bad normalize");
      } catch {
        e.push(n);
      }
    }), e.length)
      throw new Error("missing " + e.join(", "));
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769))
      throw new Error("broken implementation");
  } catch (e) {
    return e.message;
  }
  return null;
}
const $n = Ai();
var hn;
(function(e) {
  e.DEBUG = "DEBUG", e.INFO = "INFO", e.WARNING = "WARNING", e.ERROR = "ERROR", e.OFF = "OFF";
})(hn || (hn = {}));
var nt;
(function(e) {
  e.UNKNOWN_ERROR = "UNKNOWN_ERROR", e.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", e.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", e.NETWORK_ERROR = "NETWORK_ERROR", e.SERVER_ERROR = "SERVER_ERROR", e.TIMEOUT = "TIMEOUT", e.BUFFER_OVERRUN = "BUFFER_OVERRUN", e.NUMERIC_FAULT = "NUMERIC_FAULT", e.MISSING_NEW = "MISSING_NEW", e.INVALID_ARGUMENT = "INVALID_ARGUMENT", e.MISSING_ARGUMENT = "MISSING_ARGUMENT", e.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", e.CALL_EXCEPTION = "CALL_EXCEPTION", e.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", e.NONCE_EXPIRED = "NONCE_EXPIRED", e.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", e.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", e.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", e.ACTION_REJECTED = "ACTION_REJECTED";
})(nt || (nt = {}));
const qn = "0123456789abcdef";
class $ {
  constructor(n) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: n,
      writable: !1
    });
  }
  _log(n, a) {
    const o = n.toLowerCase();
    Pt[o] == null && this.throwArgumentError("invalid log level name", "logLevel", n), !(Gn > Pt[o]) && console.log.apply(console, a);
  }
  debug(...n) {
    this._log($.levels.DEBUG, n);
  }
  info(...n) {
    this._log($.levels.INFO, n);
  }
  warn(...n) {
    this._log($.levels.WARNING, n);
  }
  makeError(n, a, o) {
    if (kn)
      return this.makeError("censored error", a, {});
    a || (a = $.errors.UNKNOWN_ERROR), o || (o = {});
    const m = [];
    Object.keys(o).forEach((O) => {
      const b = o[O];
      try {
        if (b instanceof Uint8Array) {
          let D = "";
          for (let U = 0; U < b.length; U++)
            D += qn[b[U] >> 4], D += qn[b[U] & 15];
          m.push(O + "=Uint8Array(0x" + D + ")");
        } else
          m.push(O + "=" + JSON.stringify(b));
      } catch {
        m.push(O + "=" + JSON.stringify(o[O].toString()));
      }
    }), m.push(`code=${a}`), m.push(`version=${this.version}`);
    const f = n;
    let A = "";
    switch (a) {
      case nt.NUMERIC_FAULT: {
        A = "NUMERIC_FAULT";
        const O = n;
        switch (O) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            A += "-" + O;
            break;
          case "negative-power":
          case "negative-width":
            A += "-unsupported";
            break;
          case "unbound-bitwise-result":
            A += "-unbound-result";
            break;
        }
        break;
      }
      case nt.CALL_EXCEPTION:
      case nt.INSUFFICIENT_FUNDS:
      case nt.MISSING_NEW:
      case nt.NONCE_EXPIRED:
      case nt.REPLACEMENT_UNDERPRICED:
      case nt.TRANSACTION_REPLACED:
      case nt.UNPREDICTABLE_GAS_LIMIT:
        A = a;
        break;
    }
    A && (n += " [ See: https://links.ethers.org/v5-errors-" + A + " ]"), m.length && (n += " (" + m.join(", ") + ")");
    const v = new Error(n);
    return v.reason = f, v.code = a, Object.keys(o).forEach(function(O) {
      v[O] = o[O];
    }), v;
  }
  throwError(n, a, o) {
    throw this.makeError(n, a, o);
  }
  throwArgumentError(n, a, o) {
    return this.throwError(n, $.errors.INVALID_ARGUMENT, {
      argument: a,
      value: o
    });
  }
  assert(n, a, o, m) {
    n || this.throwError(a, o, m);
  }
  assertArgument(n, a, o, m) {
    n || this.throwArgumentError(a, o, m);
  }
  checkNormalize(n) {
    $n && this.throwError("platform missing String.prototype.normalize", $.errors.UNSUPPORTED_OPERATION, {
      operation: "String.prototype.normalize",
      form: $n
    });
  }
  checkSafeUint53(n, a) {
    typeof n == "number" && (a == null && (a = "value not safe"), (n < 0 || n >= 9007199254740991) && this.throwError(a, $.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "out-of-safe-range",
      value: n
    }), n % 1 && this.throwError(a, $.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "non-integer",
      value: n
    }));
  }
  checkArgumentCount(n, a, o) {
    o ? o = ": " + o : o = "", n < a && this.throwError("missing argument" + o, $.errors.MISSING_ARGUMENT, {
      count: n,
      expectedCount: a
    }), n > a && this.throwError("too many arguments" + o, $.errors.UNEXPECTED_ARGUMENT, {
      count: n,
      expectedCount: a
    });
  }
  checkNew(n, a) {
    (n === Object || n == null) && this.throwError("missing new", $.errors.MISSING_NEW, { name: a.name });
  }
  checkAbstract(n, a) {
    n === a ? this.throwError("cannot instantiate abstract class " + JSON.stringify(a.name) + " directly; use a sub-class", $.errors.UNSUPPORTED_OPERATION, { name: n.name, operation: "new" }) : (n === Object || n == null) && this.throwError("missing new", $.errors.MISSING_NEW, { name: a.name });
  }
  static globalLogger() {
    return an || (an = new $(Ei)), an;
  }
  static setCensorship(n, a) {
    if (!n && a && this.globalLogger().throwError("cannot permanently disable censorship", $.errors.UNSUPPORTED_OPERATION, {
      operation: "setCensorship"
    }), Fn) {
      if (!n)
        return;
      this.globalLogger().throwError("error censorship permanent", $.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    kn = !!n, Fn = !!a;
  }
  static setLogLevel(n) {
    const a = Pt[n.toLowerCase()];
    if (a == null) {
      $.globalLogger().warn("invalid log level - " + n);
      return;
    }
    Gn = a;
  }
  static from(n) {
    return new $(n);
  }
}
$.errors = nt;
$.levels = hn;
const vi = "bytes/5.7.0", ht = new $(vi);
function jn(e) {
  return !!e.toHexString;
}
function Bt(e) {
  return e.slice || (e.slice = function() {
    const n = Array.prototype.slice.call(arguments);
    return Bt(new Uint8Array(Array.prototype.slice.apply(e, n)));
  }), e;
}
function Wn(e) {
  return typeof e == "number" && e == e && e % 1 === 0;
}
function It(e) {
  if (e == null)
    return !1;
  if (e.constructor === Uint8Array)
    return !0;
  if (typeof e == "string" || !Wn(e.length) || e.length < 0)
    return !1;
  for (let n = 0; n < e.length; n++) {
    const a = e[n];
    if (!Wn(a) || a < 0 || a >= 256)
      return !1;
  }
  return !0;
}
function Ri(e, n) {
  if (n || (n = {}), typeof e == "number") {
    ht.checkSafeUint53(e, "invalid arrayify value");
    const a = [];
    for (; e; )
      a.unshift(e & 255), e = parseInt(String(e / 256));
    return a.length === 0 && a.push(0), Bt(new Uint8Array(a));
  }
  if (n.allowMissingPrefix && typeof e == "string" && e.substring(0, 2) !== "0x" && (e = "0x" + e), jn(e) && (e = e.toHexString()), gt(e)) {
    let a = e.substring(2);
    a.length % 2 && (n.hexPad === "left" ? a = "0" + a : n.hexPad === "right" ? a += "0" : ht.throwArgumentError("hex data is odd-length", "value", e));
    const o = [];
    for (let m = 0; m < a.length; m += 2)
      o.push(parseInt(a.substring(m, m + 2), 16));
    return Bt(new Uint8Array(o));
  }
  return It(e) ? Bt(new Uint8Array(e)) : ht.throwArgumentError("invalid arrayify value", "value", e);
}
function gt(e, n) {
  return !(typeof e != "string" || !e.match(/^0x[0-9A-Fa-f]*$/) || n && e.length !== 2 + 2 * n);
}
const sn = "0123456789abcdef";
function ei(e, n) {
  if (n || (n = {}), typeof e == "number") {
    ht.checkSafeUint53(e, "invalid hexlify value");
    let a = "";
    for (; e; )
      a = sn[e & 15] + a, e = Math.floor(e / 16);
    return a.length ? (a.length % 2 && (a = "0" + a), "0x" + a) : "0x00";
  }
  if (typeof e == "bigint")
    return e = e.toString(16), e.length % 2 ? "0x0" + e : "0x" + e;
  if (n.allowMissingPrefix && typeof e == "string" && e.substring(0, 2) !== "0x" && (e = "0x" + e), jn(e))
    return e.toHexString();
  if (gt(e))
    return e.length % 2 && (n.hexPad === "left" ? e = "0x0" + e.substring(2) : n.hexPad === "right" ? e += "0" : ht.throwArgumentError("hex data is odd-length", "value", e)), e.toLowerCase();
  if (It(e)) {
    let a = "0x";
    for (let o = 0; o < e.length; o++) {
      let m = e[o];
      a += sn[(m & 240) >> 4] + sn[m & 15];
    }
    return a;
  }
  return ht.throwArgumentError("invalid hexlify value", "value", e);
}
function Xn(e, n) {
  for (typeof e != "string" ? e = ei(e) : gt(e) || ht.throwArgumentError("invalid hex string", "value", e), e.length > 2 * n + 2 && ht.throwArgumentError("value out of range", "value", arguments[1]); e.length < 2 * n + 2; )
    e = "0x0" + e.substring(2);
  return e;
}
const ti = "bignumber/5.7.0";
var mn = gi.BN;
const pt = new $(ti), on = {}, Yn = 9007199254740991;
function Mi(e) {
  return e != null && (ze.isBigNumber(e) || typeof e == "number" && e % 1 === 0 || typeof e == "string" && !!e.match(/^-?[0-9]+$/) || gt(e) || typeof e == "bigint" || It(e));
}
let zn = !1, ze = class tt {
  constructor(n, a) {
    n !== on && pt.throwError("cannot call constructor directly; use BigNumber.from", $.errors.UNSUPPORTED_OPERATION, {
      operation: "new (BigNumber)"
    }), this._hex = a, this._isBigNumber = !0, Object.freeze(this);
  }
  fromTwos(n) {
    return $e(G(this).fromTwos(n));
  }
  toTwos(n) {
    return $e(G(this).toTwos(n));
  }
  abs() {
    return this._hex[0] === "-" ? tt.from(this._hex.substring(1)) : this;
  }
  add(n) {
    return $e(G(this).add(G(n)));
  }
  sub(n) {
    return $e(G(this).sub(G(n)));
  }
  div(n) {
    return tt.from(n).isZero() && Ke("division-by-zero", "div"), $e(G(this).div(G(n)));
  }
  mul(n) {
    return $e(G(this).mul(G(n)));
  }
  mod(n) {
    const a = G(n);
    return a.isNeg() && Ke("division-by-zero", "mod"), $e(G(this).umod(a));
  }
  pow(n) {
    const a = G(n);
    return a.isNeg() && Ke("negative-power", "pow"), $e(G(this).pow(a));
  }
  and(n) {
    const a = G(n);
    return (this.isNegative() || a.isNeg()) && Ke("unbound-bitwise-result", "and"), $e(G(this).and(a));
  }
  or(n) {
    const a = G(n);
    return (this.isNegative() || a.isNeg()) && Ke("unbound-bitwise-result", "or"), $e(G(this).or(a));
  }
  xor(n) {
    const a = G(n);
    return (this.isNegative() || a.isNeg()) && Ke("unbound-bitwise-result", "xor"), $e(G(this).xor(a));
  }
  mask(n) {
    return (this.isNegative() || n < 0) && Ke("negative-width", "mask"), $e(G(this).maskn(n));
  }
  shl(n) {
    return (this.isNegative() || n < 0) && Ke("negative-width", "shl"), $e(G(this).shln(n));
  }
  shr(n) {
    return (this.isNegative() || n < 0) && Ke("negative-width", "shr"), $e(G(this).shrn(n));
  }
  eq(n) {
    return G(this).eq(G(n));
  }
  lt(n) {
    return G(this).lt(G(n));
  }
  lte(n) {
    return G(this).lte(G(n));
  }
  gt(n) {
    return G(this).gt(G(n));
  }
  gte(n) {
    return G(this).gte(G(n));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return G(this).isZero();
  }
  toNumber() {
    try {
      return G(this).toNumber();
    } catch {
      Ke("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch {
    }
    return pt.throwError("this platform does not support BigInt", $.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    return arguments.length > 0 && (arguments[0] === 10 ? zn || (zn = !0, pt.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? pt.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", $.errors.UNEXPECTED_ARGUMENT, {}) : pt.throwError("BigNumber.toString does not accept parameters", $.errors.UNEXPECTED_ARGUMENT, {})), G(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(n) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(n) {
    if (n instanceof tt)
      return n;
    if (typeof n == "string")
      return n.match(/^-?0x[0-9a-f]+$/i) ? new tt(on, St(n)) : n.match(/^-?[0-9]+$/) ? new tt(on, St(new mn(n))) : pt.throwArgumentError("invalid BigNumber string", "value", n);
    if (typeof n == "number")
      return n % 1 && Ke("underflow", "BigNumber.from", n), (n >= Yn || n <= -Yn) && Ke("overflow", "BigNumber.from", n), tt.from(String(n));
    const a = n;
    if (typeof a == "bigint")
      return tt.from(a.toString());
    if (It(a))
      return tt.from(ei(a));
    if (a)
      if (a.toHexString) {
        const o = a.toHexString();
        if (typeof o == "string")
          return tt.from(o);
      } else {
        let o = a._hex;
        if (o == null && a.type === "BigNumber" && (o = a.hex), typeof o == "string" && (gt(o) || o[0] === "-" && gt(o.substring(1))))
          return tt.from(o);
      }
    return pt.throwArgumentError("invalid BigNumber value", "value", n);
  }
  static isBigNumber(n) {
    return !!(n && n._isBigNumber);
  }
};
function St(e) {
  if (typeof e != "string")
    return St(e.toString(16));
  if (e[0] === "-")
    return e = e.substring(1), e[0] === "-" && pt.throwArgumentError("invalid hex", "value", e), e = St(e), e === "0x00" ? e : "-" + e;
  if (e.substring(0, 2) !== "0x" && (e = "0x" + e), e === "0x")
    return "0x00";
  for (e.length % 2 && (e = "0x0" + e.substring(2)); e.length > 4 && e.substring(0, 4) === "0x00"; )
    e = "0x" + e.substring(4);
  return e;
}
function $e(e) {
  return ze.from(St(e));
}
function G(e) {
  const n = ze.from(e).toHexString();
  return n[0] === "-" ? new mn("-" + n.substring(3), 16) : new mn(n.substring(2), 16);
}
function Ke(e, n, a) {
  const o = { fault: e, operation: n };
  return a != null && (o.value = a), pt.throwError(e, $.errors.NUMERIC_FAULT, o);
}
const Fe = new $(ti), Mt = {}, ni = ze.from(0), ii = ze.from(-1);
function ri(e, n, a, o) {
  const m = { fault: n, operation: a };
  return o !== void 0 && (m.value = o), Fe.throwError(e, $.errors.NUMERIC_FAULT, m);
}
let Ot = "0";
for (; Ot.length < 256; )
  Ot += Ot;
function wn(e) {
  if (typeof e != "number")
    try {
      e = ze.from(e).toNumber();
    } catch {
    }
  return typeof e == "number" && e >= 0 && e <= 256 && !(e % 1) ? "1" + Ot.substring(0, e) : Fe.throwArgumentError("invalid decimal size", "decimals", e);
}
function un(e, n) {
  n == null && (n = 0);
  const a = wn(n);
  e = ze.from(e);
  const o = e.lt(ni);
  o && (e = e.mul(ii));
  let m = e.mod(a).toString();
  for (; m.length < a.length - 1; )
    m = "0" + m;
  m = m.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const f = e.div(a).toString();
  return a.length === 1 ? e = f : e = f + "." + m, o && (e = "-" + e), e;
}
function at(e, n) {
  n == null && (n = 0);
  const a = wn(n);
  (typeof e != "string" || !e.match(/^-?[0-9.]+$/)) && Fe.throwArgumentError("invalid decimal value", "value", e);
  const o = e.substring(0, 1) === "-";
  o && (e = e.substring(1)), e === "." && Fe.throwArgumentError("missing value", "value", e);
  const m = e.split(".");
  m.length > 2 && Fe.throwArgumentError("too many decimal points", "value", e);
  let f = m[0], A = m[1];
  for (f || (f = "0"), A || (A = "0"); A[A.length - 1] === "0"; )
    A = A.substring(0, A.length - 1);
  for (A.length > a.length - 1 && ri("fractional component exceeds decimals", "underflow", "parseFixed"), A === "" && (A = "0"); A.length < a.length - 1; )
    A += "0";
  const v = ze.from(f), O = ze.from(A);
  let b = v.mul(a).add(O);
  return o && (b = b.mul(ii)), b;
}
class vt {
  constructor(n, a, o, m) {
    n !== Mt && Fe.throwError("cannot use FixedFormat constructor; use FixedFormat.from", $.errors.UNSUPPORTED_OPERATION, {
      operation: "new FixedFormat"
    }), this.signed = a, this.width = o, this.decimals = m, this.name = (a ? "" : "u") + "fixed" + String(o) + "x" + String(m), this._multiplier = wn(m), Object.freeze(this);
  }
  static from(n) {
    if (n instanceof vt)
      return n;
    typeof n == "number" && (n = `fixed128x${n}`);
    let a = !0, o = 128, m = 18;
    if (typeof n == "string") {
      if (n !== "fixed")
        if (n === "ufixed")
          a = !1;
        else {
          const f = n.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
          f || Fe.throwArgumentError("invalid fixed format", "format", n), a = f[1] !== "u", o = parseInt(f[2]), m = parseInt(f[3]);
        }
    } else if (n) {
      const f = (A, v, O) => n[A] == null ? O : (typeof n[A] !== v && Fe.throwArgumentError("invalid fixed format (" + A + " not " + v + ")", "format." + A, n[A]), n[A]);
      a = f("signed", "boolean", a), o = f("width", "number", o), m = f("decimals", "number", m);
    }
    return o % 8 && Fe.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", o), m > 80 && Fe.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", m), new vt(Mt, a, o, m);
  }
}
class Ue {
  constructor(n, a, o, m) {
    n !== Mt && Fe.throwError("cannot use FixedNumber constructor; use FixedNumber.from", $.errors.UNSUPPORTED_OPERATION, {
      operation: "new FixedFormat"
    }), this.format = m, this._hex = a, this._value = o, this._isFixedNumber = !0, Object.freeze(this);
  }
  _checkFormat(n) {
    this.format.name !== n.format.name && Fe.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", n);
  }
  addUnsafe(n) {
    this._checkFormat(n);
    const a = at(this._value, this.format.decimals), o = at(n._value, n.format.decimals);
    return Ue.fromValue(a.add(o), this.format.decimals, this.format);
  }
  subUnsafe(n) {
    this._checkFormat(n);
    const a = at(this._value, this.format.decimals), o = at(n._value, n.format.decimals);
    return Ue.fromValue(a.sub(o), this.format.decimals, this.format);
  }
  mulUnsafe(n) {
    this._checkFormat(n);
    const a = at(this._value, this.format.decimals), o = at(n._value, n.format.decimals);
    return Ue.fromValue(a.mul(o).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(n) {
    this._checkFormat(n);
    const a = at(this._value, this.format.decimals), o = at(n._value, n.format.decimals);
    return Ue.fromValue(a.mul(this.format._multiplier).div(o), this.format.decimals, this.format);
  }
  floor() {
    const n = this.toString().split(".");
    n.length === 1 && n.push("0");
    let a = Ue.from(n[0], this.format);
    const o = !n[1].match(/^(0*)$/);
    return this.isNegative() && o && (a = a.subUnsafe(Kn.toFormat(a.format))), a;
  }
  ceiling() {
    const n = this.toString().split(".");
    n.length === 1 && n.push("0");
    let a = Ue.from(n[0], this.format);
    const o = !n[1].match(/^(0*)$/);
    return !this.isNegative() && o && (a = a.addUnsafe(Kn.toFormat(a.format))), a;
  }
  // @TODO: Support other rounding algorithms
  round(n) {
    n == null && (n = 0);
    const a = this.toString().split(".");
    if (a.length === 1 && a.push("0"), (n < 0 || n > 80 || n % 1) && Fe.throwArgumentError("invalid decimal count", "decimals", n), a[1].length <= n)
      return this;
    const o = Ue.from("1" + Ot.substring(0, n), this.format), m = Oi.toFormat(this.format);
    return this.mulUnsafe(o).addUnsafe(m).floor().divUnsafe(o);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(n) {
    if (n == null)
      return this._hex;
    n % 8 && Fe.throwArgumentError("invalid byte width", "width", n);
    const a = ze.from(this._hex).fromTwos(this.format.width).toTwos(n).toHexString();
    return Xn(a, n / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(n) {
    return Ue.fromString(this._value, n);
  }
  static fromValue(n, a, o) {
    return o == null && a != null && !Mi(a) && (o = a, a = null), a == null && (a = 0), o == null && (o = "fixed"), Ue.fromString(un(n, a), vt.from(o));
  }
  static fromString(n, a) {
    a == null && (a = "fixed");
    const o = vt.from(a), m = at(n, o.decimals);
    !o.signed && m.lt(ni) && ri("unsigned value cannot be negative", "overflow", "value", n);
    let f = null;
    o.signed ? f = m.toTwos(o.width).toHexString() : (f = m.toHexString(), f = Xn(f, o.width / 8));
    const A = un(m, o.decimals);
    return new Ue(Mt, f, A, o);
  }
  static fromBytes(n, a) {
    a == null && (a = "fixed");
    const o = vt.from(a);
    if (Ri(n).length > o.width / 8)
      throw new Error("overflow");
    let m = ze.from(n);
    o.signed && (m = m.fromTwos(o.width));
    const f = m.toTwos((o.signed ? 0 : 1) + o.width).toHexString(), A = un(m, o.decimals);
    return new Ue(Mt, f, A, o);
  }
  static from(n, a) {
    if (typeof n == "string")
      return Ue.fromString(n, a);
    if (It(n))
      return Ue.fromBytes(n, a);
    try {
      return Ue.fromValue(n, 0, a);
    } catch (o) {
      if (o.code !== $.errors.INVALID_ARGUMENT)
        throw o;
    }
    return Fe.throwArgumentError("invalid FixedNumber value", "value", n);
  }
  static isFixedNumber(n) {
    return !!(n && n._isFixedNumber);
  }
}
const Kn = Ue.from(1), Oi = Ue.from("0.5"), ot = (e) => typeof e == "string" || typeof e == "number" || e instanceof ze, At = (e, n = 8) => {
  const a = ze.from(e || 0);
  return {
    amount: () => a,
    plus: (o, m = n) => At(a.add(ot(o) ? o : o.amount()), m),
    minus: (o, m = n) => At(a.sub(ot(o) ? o : o.amount()), m),
    times: (o, m = n) => At(a.mul(ot(o) ? o : o.amount()), m),
    div: (o, m = n) => At(a.div(ot(o) ? o : o.amount()), m),
    lt: (o) => a.lt(ot(o) ? o : o.amount()),
    lte: (o) => a.lte(ot(o) ? o : o.amount()),
    gt: (o) => a.gt(ot(o) ? o : o.amount()),
    gte: (o) => a.gte(ot(o) ? o : o.amount()),
    eq: (o) => a.eq(ot(o) ? o : o.amount()),
    decimal: n
  };
}, Ni = (e) => {
  var A;
  const [n, ...a] = e.split("."), o = e.includes("/"), m = a.join("."), f = (A = m == null ? void 0 : m.split("-")) == null ? void 0 : A[0];
  return { chain: n, symbol: m, ticker: f, synth: o };
}, Si = {
  /**
   * Core
   */
  core_wallet_connection_not_found: 10001,
  core_estimated_max_spendable_chain_not_supported: 10002,
  core_extend_error: 10003,
  core_inbound_data_not_found: 10004,
  core_approve_asset_address_or_from_not_found: 10005,
  core_chain_halted: 10099,
  /**
   * Core - Wallet Connection
   */
  core_wallet_xdefi_not_installed: 10101,
  core_wallet_evmwallet_not_installed: 10102,
  core_wallet_walletconnect_not_installed: 10103,
  core_wallet_keystore_not_installed: 10104,
  core_wallet_ledger_not_installed: 10105,
  core_wallet_trezor_not_installed: 10106,
  core_wallet_keplr_not_installed: 10107,
  core_wallet_okx_not_installed: 10108,
  /**
   * Core - Swap
   */
  core_swap_invalid_params: 10200,
  core_swap_route_not_complete: 10201,
  core_swap_asset_not_recognized: 10202,
  core_swap_contract_not_found: 10203,
  core_swap_route_transaction_not_found: 10204,
  core_swap_contract_not_supported: 10205,
  core_swap_transaction_error: 10206,
  core_swap_quote_mode_not_supported: 10207,
  /**
   * Core - Transaction
   */
  core_transaction_deposit_error: 10301,
  core_transaction_create_liquidity_rune_error: 10302,
  core_transaction_create_liquidity_asset_error: 10303,
  core_transaction_create_liquidity_invalid_params: 10304,
  core_transaction_add_liquidity_invalid_params: 10305,
  core_transaction_add_liquidity_no_rune_address: 10306,
  core_transaction_add_liquidity_rune_error: 10307,
  core_transaction_add_liquidity_asset_error: 10308,
  core_transaction_withdraw_error: 10309,
  core_transaction_deposit_to_pool_error: 10310,
  /**
   * Wallets
   */
  wallet_ledger_connection_error: 2001
};
class F extends Error {
  constructor(n, a) {
    console.error(a), super(n, { cause: { code: Si[n], message: n } }), Object.setPrototypeOf(this, F.prototype);
  }
}
var bi = Object.defineProperty, Ii = (e, n, a) => n in e ? bi(e, n, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[n] = a, rt = (e, n, a) => (Ii(e, typeof n != "symbol" ? n + "" : n, a), a);
const Vr = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !0, internalType: "address", name: "spender", type: "address" },
      { indexed: !1, internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "from", type: "address" },
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "success", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "success", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "success", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  }
], xi = [
  {
    inputs: [{ internalType: "address", name: "rune", type: "address" }],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !0, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "Deposit",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferAllowance",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOut",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !1, internalType: "address", name: "target", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "address", name: "finalAsset", type: "address" },
      { indexed: !1, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOutAndCall",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        indexed: !1,
        internalType: "struct THORChain_Router.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "VaultTransfer",
    type: "event"
  },
  {
    inputs: [],
    name: "RUNE",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "deposit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" },
      { internalType: "uint256", name: "expiration", type: "uint256" }
    ],
    name: "depositWithExpiry",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address payable", name: "asgard", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        internalType: "struct THORChain_Router.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "returnVaultAssets",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address", name: "newVault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferAllowance",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "to", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "aggregator", type: "address" },
      { internalType: "address", name: "finalToken", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOutAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "vault", type: "address" },
      { internalType: "address", name: "token", type: "address" }
    ],
    name: "vaultAllowance",
    outputs: [{ internalType: "uint256", name: "amount", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  }
], Ci = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !0, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "Deposit",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferAllowance",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOut",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !1, internalType: "address", name: "target", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "address", name: "finalAsset", type: "address" },
      { indexed: !1, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOutAndCall",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        indexed: !1,
        internalType: "struct AvaxRouter.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "VaultTransfer",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "deposit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" },
      { internalType: "uint256", name: "expiration", type: "uint256" }
    ],
    name: "depositWithExpiry",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address payable", name: "asgard", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        internalType: "struct AvaxRouter.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "returnVaultAssets",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address", name: "newVault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferAllowance",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "to", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "target", type: "address" },
      { internalType: "address", name: "finalToken", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOutAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "vault", type: "address" },
      { internalType: "address", name: "token", type: "address" }
    ],
    name: "vaultAllowance",
    outputs: [{ internalType: "uint256", name: "amount", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  }
], Di = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !0, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "Deposit",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferAllowance",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOut",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !1, internalType: "address", name: "target", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "address", name: "finalAsset", type: "address" },
      { indexed: !1, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOutAndCall",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        indexed: !1,
        internalType: "struct THORChain_Router.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "VaultTransfer",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" },
      { internalType: "uint256", name: "expiration", type: "uint256" }
    ],
    name: "depositWithExpiry",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address payable", name: "asgard", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        internalType: "struct THORChain_Router.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "returnVaultAssets",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address", name: "newVault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferAllowance",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "to", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "target", type: "address" },
      { internalType: "address", name: "finalToken", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOutAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "vault", type: "address" },
      { internalType: "address", name: "token", type: "address" }
    ],
    name: "vaultAllowance",
    outputs: [{ internalType: "uint256", name: "amount", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  }
];
var Pi = /* @__PURE__ */ ((e) => (e.THOR = "THOR", e.RUNE = "RUNE", e.ATOM = "ATOM", e.MUON = "MUON", e.USDC = "USDC", e))(Pi || {}), Bi = /* @__PURE__ */ ((e) => (e.TC_SUPPORTED_TO_TC_SUPPORTED = "TC-TC", e.TC_SUPPORTED_TO_ETH = "TC-ERC20", e.TC_SUPPORTED_TO_AVAX = "TC-ARC20", e.TC_SUPPORTED_TO_BSC = "TC-BEP20", e.ETH_TO_TC_SUPPORTED = "ERC20-TC", e.ETH_TO_ETH = "ERC20-ERC20", e.ETH_TO_AVAX = "ERC20-ARC20", e.ETH_TO_BSC = "ERC20-BEP20", e.AVAX_TO_TC_SUPPORTED = "ARC20-TC", e.AVAX_TO_ETH = "ARC20-ERC20", e.AVAX_TO_AVAX = "ARC20-ARC20", e.AVAX_TO_BSC = "ARC20-BEP20", e.BSC_TO_TC_SUPPORTED = "BEP20-TC", e.BSC_TO_ETH = "BEP20-ERC20", e.BSC_TO_AVAX = "BEP20-ARC20", e.BSC_TO_BSC = "BEP20-BEP20", e))(Bi || {});
const Ui = [
  "ERC20-ERC20",
  "ARC20-ARC20",
  "BEP20-BEP20"
  /* BSC_TO_BSC */
], Li = [
  "ERC20-TC",
  "ERC20-ARC20",
  "ERC20-BEP20",
  "ARC20-TC",
  "ARC20-ERC20",
  "ARC20-BEP20",
  "BEP20-TC",
  "BEP20-ERC20",
  "BEP20-ARC20"
  /* BSC_TO_AVAX */
], Hi = [
  "TC-TC",
  "TC-ERC20",
  "TC-ARC20",
  "TC-BEP20"
  /* TC_SUPPORTED_TO_BSC */
];
var ai = /* @__PURE__ */ ((e) => (e.VALIDATION_ERROR = "VALIDATION_ERROR", e.REQUEST_PARAMETER_ERROR = "REQUEST_PARAMETER_ERROR", e.RESPONSE_PARSING_ERROR = "RESPONSE_PARSING_ERROR", e.UNSUPPORTED = "UNSUPPORTED", e.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", e.INCOMPATIBLE_ASSETS_OPERATIONS = "INCOMPATIBLE_ASSETS_OPERATIONS", e.SERVICE_UNAVAILABLE = "SERVICE_UNAVAILABLE", e.DOWN_FOR_MAINTENANCE = "DOWN_FOR_MAINTENANCE", e.MISSING_INBOUND_INFO = "MISSING_INBOUND_INFO", e.QUOTE_FETCHING_ERROR = "QUOTE_FETCHING_ERROR", e.AIRDROP_ERROR = "AIRDROP_ERROR", e.UNHANDLED_ERROR = "UNHANDLED_ERROR", e))(ai || {}), Vi = /* @__PURE__ */ ((e) => (e.HEALTH_CONTROLLER = "1000", e.LIQUIDITY_CONTROLLER = "1001", e.PROVIDER_CONTROLLER = "1002", e.QUOTE_CONTROLLER = "1003", e.SWAP_CONTROLLER = "1004", e.UTIL_CONTROLLER = "1005", e.AIRDROP_CONTROLLER = "1006", e.PROVIDER = "2000", e.ASSET = "2001", e.TOKEN_LIST = "2002", e.QUOTE = "2100", e.QUOTE_TXN_DETAILS = "2101", e.THORCHAIN_PROVIDER = "3000", e.UNISWAPV2_ETH_PROVIDER = "3001", e.UNISWAPV3_ETH_PROVIDER = "3002", e.SUSHISWAP_ETH_PROVIDER = "3003", e.PANCAKESWAP_BSC_PROVIDER = "3004", e.PANCAKESWAP_ETH_PROVIDER = "3005", e.ONEINCH_ETH_PROVIDER = "3006", e.ONEINCH_BSC_PROVIDER = "3007", e.ONEINCH_AVAX_PROVIDER = "3008", e.ZEROX_ETH_PROVIDER = "3009", e.WOOFI_AVAX_PROVIDER = "3010", e.PANGOLIN_AVAX_PROVIDER = "3011", e.TRADERJOE_AVAX_PROVIDER = "3012", e.KYBER_ETH_PROVIDER = "3013", e.KYBER_AVAX_PROVIDER = "3014", e.WOOFI_BSC_PROVIDER = "3015", e.STARGATE_PROVIDER = "3016", e.PROVIDER_UTIL = "4000", e.TXN_DETAILS = "5000", e.AIRDROP_UTIL = "6000", e))(Vi || {}), P = /* @__PURE__ */ ((e) => (e.INVALID_INPUT_PARAMETERS = "1000", e.UNKNOWN_PROVIDERS = "1001", e.CANNOT_FIND_INBOUND_ADDRESS = "1002", e.NO_INBOUND_ADDRESSES = "1003", e.CHAIN_HALTED_OR_UNSUPPORTED = "1004", e.MISSING_INPUT_PARAMETER = "1005", e.INVALID_TYPE_GENERIC = "1100", e.INVALID_NUMBER_STRING = "1101", e.INVALID_NUMBER = "1102", e.INVALID_BOOLEAN = "1103", e.INVALID_OBJECT = "1104", e.INVALID_ARRAY = "1105", e.SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2000", e.SELL_BUY_ASSETS_ARE_THE_SAME = "2001", e.MISSING_SOURCE_ADDRESS_FOR_SYNTH = "2002", e.AFF_ADDRESS_AND_BPS_OR_NEITHER = "2003", e.AFF_ADDRESS_TOO_LONG = "2004", e.AFF_BPS_INTEGER_0_100 = "2005", e.SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN = "2006", e.DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN = "2007", e.PREFERRED_PROFVIDER_NOT_SUPPORTED = "2008", e.DESTINATION_ADDRESS_SMART_CONTRACT = "2009", e.BUY_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2010", e.SOURCE_ADDRESS_SMART_CONTRACT = "2011", e.INVALID_PROVIDER = "2100", e.MISSING_CROSS_CHAIN_PROVIDER = "2101", e.MISSING_AVAX_PROVIDER = "2102", e.MISSING_BSC_PROVIDER = "2103", e.MISSING_ETH_PROVIDER = "2104", e.INVALID_PROVIDER_FOR_SWAP_OUT = "2105", e.MISSING_ARB_PROVIDER = "2106", e.INVALID_CHAIN = "2200", e.INVALID_ASSET = "2201", e.INVALID_ASSET_IDENTIFIER = "2202", e.UNSUPPORTED_CHAIN = "2204", e.UNSUPPORTED_ASSET = "2203", e.UNSUPPORTED_ASSET_FOR_SWAPOUT = "2205", e.THORNODE_QUOTE_GENERIC_ERROR = "3000", e.NOT_ENOUGH_SYNTH_BALANCE = "3001", e.SYNTH_MINTING_CAP_REACHED = "3002", e.INVALID_QUOTE_MODE = "4000", e.NO_QUOTES = "4001", e.SERVICE_UNAVAILABLE_GENERIC = "5000", e.MISSING_GAS_DATA_GENERIC = "5100", e.MISSING_TOKEN_INFO_GENERIC = "5200", e.CANT_FIND_TOKEN_LIST = "5201", e.NO_PRICE = "5202", e.PRICE_IS_STALE = "5203", e.ADDRESS_NOT_WHITELISTED = "6000", e.ADDRESS_ALREADY_CLAIMED = "6001", e.TEMPORARY_ERROR = "9999", e))(P || {});
const Fi = {
  [P.INVALID_INPUT_PARAMETERS]: "Invalid input parameters: {0}.",
  [P.UNKNOWN_PROVIDERS]: "Unknown providers: {0}.",
  [P.CANNOT_FIND_INBOUND_ADDRESS]: "Cannot find inbound address.",
  [P.NO_INBOUND_ADDRESSES]: "No inbound addresses.",
  [P.CHAIN_HALTED_OR_UNSUPPORTED]: "Chain {0} halted or unsupported.",
  [P.MISSING_INPUT_PARAMETER]: "Missing input parameter: {0}.",
  [P.INVALID_TYPE_GENERIC]: "Invalid type",
  [P.INVALID_NUMBER_STRING]: "Invalid number string.",
  [P.INVALID_NUMBER]: "Invalid number.",
  [P.INVALID_BOOLEAN]: "Invalid boolean.",
  [P.INVALID_OBJECT]: "Invalid object.",
  [P.INVALID_ARRAY]: "Invalid array.",
  [P.SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER]: "Sell amount must be a positive integer.",
  [P.SELL_BUY_ASSETS_ARE_THE_SAME]: "Sell and buy assets are the same.",
  [P.MISSING_SOURCE_ADDRESS_FOR_SYNTH]: "Source address is required for synth quote.",
  [P.AFF_ADDRESS_AND_BPS_OR_NEITHER]: "Must provide affiliateAddress and affiliateBasisPoints params, or neither.",
  [P.AFF_ADDRESS_TOO_LONG]: "affiliateAddress too long: 3 characters max.",
  [P.AFF_BPS_INTEGER_0_100]: "affiliateBasisPoints must be an integer between 0 and 100.",
  [P.SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN]: "Source address {0} invalid for sell chain.",
  [P.DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN]: "Destination address {0} invalid for buy chain.",
  [P.PREFERRED_PROFVIDER_NOT_SUPPORTED]: "Preferred provider not supported.",
  [P.DESTINATION_ADDRESS_SMART_CONTRACT]: "Destination address is a smart contract.",
  [P.BUY_AMOUNT_MUST_BE_POSITIVE_INTEGER]: "Buy amount must be a positive integer.",
  [P.INVALID_PROVIDER]: "Invalid provider {0}.",
  [P.MISSING_CROSS_CHAIN_PROVIDER]: "Missing cross-chain provider.",
  [P.MISSING_AVAX_PROVIDER]: "Missing AVAX provider.",
  [P.MISSING_BSC_PROVIDER]: "Missing BSC provider.",
  [P.MISSING_ETH_PROVIDER]: "Missing ETH provider.",
  [P.MISSING_ARB_PROVIDER]: "Missing ARB provider.",
  [P.INVALID_PROVIDER_FOR_SWAP_OUT]: "Invalid provider for swap out.",
  [P.INVALID_CHAIN]: "Invalid chain {0}.",
  [P.INVALID_ASSET]: "Invalid asset {0}.",
  [P.UNSUPPORTED_CHAIN]: "Unsupported chain {0}.",
  [P.UNSUPPORTED_ASSET]: "Unsupported asset {0}.",
  [P.UNSUPPORTED_ASSET_FOR_SWAPOUT]: "Unsupported asset {0} for swap out.",
  [P.THORNODE_QUOTE_GENERIC_ERROR]: "ThorNode quote generic error.",
  [P.NOT_ENOUGH_SYNTH_BALANCE]: "Source address doesn't have enough synth balance for this quote.",
  [P.SYNTH_MINTING_CAP_REACHED]: "Synth minting cap reached.",
  [P.INVALID_QUOTE_MODE]: "Invalid quote mode.",
  [P.NO_QUOTES]: "No quotes to service this request.",
  [P.SERVICE_UNAVAILABLE_GENERIC]: "Service unavailable.",
  [P.MISSING_GAS_DATA_GENERIC]: "Missing gas data.",
  [P.MISSING_TOKEN_INFO_GENERIC]: "Missing token info.",
  [P.CANT_FIND_TOKEN_LIST]: "Can't find tokenlist {0}.",
  [P.NO_PRICE]: "No price for asset {0}.",
  [P.PRICE_IS_STALE]: "Price is stale for asset {0}.",
  [P.ADDRESS_NOT_WHITELISTED]: "Address {0} not whitelisted for airdrop.",
  [P.ADDRESS_ALREADY_CLAIMED]: "Address {0} already claimed the airdrop."
}, ln = (e, n) => {
  let a = Fi[e];
  for (let o = 0; o < n.length; o++)
    a = a.replace(`{${o}}`, n[o]);
  return n.length === 0 ? a.replace("{0}", "") : a;
};
let Fr = class si extends Error {
  constructor({
    status: n,
    revision: a,
    module: o,
    code: m,
    message: f,
    type: A,
    options: { shouldLog: v, shouldThrow: O, shouldTrace: b } = {
      shouldLog: !0,
      shouldThrow: !0,
      shouldTrace: !0
    },
    displayMessageParams: D
  }) {
    const U = f || ln(m, D || []) || "";
    super(U), rt(this, "status"), rt(this, "revision"), rt(this, "type"), rt(this, "module"), rt(this, "code"), rt(this, "message"), rt(this, "display"), rt(this, "stack"), rt(this, "options"), rt(this, "displayMessageParams"), this.status = n, this.revision = a || "NO_REVISION", this.module = o, this.message = U, this.display = ln(m, D || []), this.code = m, this.type = A || ai.UNHANDLED_ERROR, this.options = {
      shouldLog: v || !0,
      shouldTrace: b || !0,
      shouldThrow: O || !1
    }, this.displayMessageParams = D || [], this.options.shouldTrace && Error.captureStackTrace(this);
  }
  static fromErrorInfo(n) {
    return new si(n);
  }
  toErrorInfo() {
    return { ...this, identifier: this.identifier };
  }
  get identifier() {
    return `${this.revision}-${this.type || "NO_TYPE"}-${this.module}-${this.code}`;
  }
  get displayMessage() {
    return ln(this.code, this.displayMessageParams || []);
  }
  handle() {
    const n = `[${this.identifier}]: ${this.message}`;
    if (this.options.shouldLog && console.error(n, `
`, this.stack || ""), this.options.shouldThrow)
      throw Error(n, { cause: this.stack });
    return this.toErrorInfo();
  }
};
var S = /* @__PURE__ */ ((e) => (e.Arbitrum = "ARB", e.Avalanche = "AVAX", e.Binance = "BNB", e.BinanceSmartChain = "BSC", e.Bitcoin = "BTC", e.BitcoinCash = "BCH", e.Cosmos = "GAIA", e.Dogecoin = "DOGE", e.Ethereum = "ETH", e.Litecoin = "LTC", e.Optimism = "OP", e.Polygon = "MATIC", e.THORChain = "THOR", e))(S || {}), ki = /* @__PURE__ */ ((e) => (e.ARB = "0x0000000000000000000000000000000000000000", e.AVAX = "0x0000000000000000000000000000000000000000", e.ETH = "0x0000000000000000000000000000000000000000", e.BSC = "0x0000000000000000000000000000000000000000", e.MATIC = "0x0000000000000000000000000000000000001010", e.OP = "0x4200000000000000000000000000000000000042", e))(ki || {}), Gi = /* @__PURE__ */ ((e) => (e[e.Ethereum = 60] = "Ethereum", e[e.Binance = 714] = "Binance", e[e.THORChain = 931] = "THORChain", e))(Gi || {}), $i = /* @__PURE__ */ ((e) => (e.ARB = "m/44'/60'/0'/0", e.AVAX = "m/44'/60'/0'/0", e.BCH = "m/44'/145'/0'/0", e.BNB = "m/44'/714'/0'/0", e.BSC = "m/44'/60'/0'/0", e.BTC = "m/84'/0'/0'/0", e.DOGE = "m/44'/3'/0'/0", e.ETH = "m/44'/60'/0'/0", e.GAIA = "m/44'/118'/0'/0", e.LTC = "m/84'/2'/0'/0", e.MATIC = "m/44'/60'/0'/0", e.OP = "m/44'/60'/0'/0", e.THOR = "m/44'/931'/0'/0", e))($i || {});
const kr = {
  ARB: [44, 60, 0, 0, 0],
  AVAX: [44, 60, 0, 0, 0],
  BCH: [44, 145, 0, 0, 0],
  BNB: [44, 714, 0, 0, 0],
  BSC: [44, 60, 0, 0, 0],
  BTC: [84, 0, 0, 0, 0],
  DOGE: [44, 3, 0, 0, 0],
  ETH: [44, 60, 0, 0, 0],
  GAIA: [44, 118, 0, 0, 0],
  LTC: [84, 2, 0, 0, 0],
  MATIC: [44, 60, 0, 0, 0],
  OP: [44, 60, 0, 0, 0],
  THOR: [44, 931, 0, 0, 0]
};
var oi = /* @__PURE__ */ ((e) => (e[e.ARB = 18] = "ARB", e[e.AVAX = 18] = "AVAX", e[e.BCH = 8] = "BCH", e[e.BNB = 8] = "BNB", e[e.BSC = 18] = "BSC", e[e.BTC = 8] = "BTC", e[e.DOGE = 8] = "DOGE", e[e.ETH = 18] = "ETH", e[e.GAIA = 6] = "GAIA", e[e.LTC = 8] = "LTC", e[e.MATIC = 18] = "MATIC", e[e.OP = 18] = "OP", e[e.THOR = 8] = "THOR", e))(oi || {});
const Gr = [
  "ETH",
  "AVAX",
  "BSC",
  "ARB",
  "OP",
  "MATIC"
  /* Polygon */
], $r = [
  "BTC",
  "BCH",
  "DOGE",
  "LTC"
  /* Litecoin */
], qr = [
  "GAIA",
  "THOR",
  "BNB"
  /* Binance */
];
var gn = /* @__PURE__ */ ((e) => (e.Arbitrum = "42161", e.ArbitrumHex = "0xa4b1", e.Avalanche = "43114", e.AvalancheHex = "0xa86a", e.Binance = "Binance-Chain-Tigris", e.BinanceHex = "", e.BinanceSmartChain = "56", e.BinanceSmartChainHex = "0x38", e.Bitcoin = "bitcoin", e.BitcoinHex = "", e.BitcoinCash = "bitcoincash", e.BitcoinCashHex = "", e.Cosmos = "cosmoshub-4", e.CosmosHex = "", e.Dogecoin = "dogecoin", e.DogecoinHex = "", e.Ethereum = "1", e.EthereumHex = "0x1", e.Litecoin = "litecoin", e.LitecoinHex = "", e.Optimism = "10", e.OptimismHex = "0xa", e.Polygon = "137", e.PolygonHex = "0x89", e.THORChain = "thorchain-mainnet-v1", e.THORChainHex = "", e.THORChainStagenet = "thorchain-stagenet-v2", e))(gn || {}), ui = /* @__PURE__ */ ((e) => (e.Arbitrum = "https://arb1.arbitrum.io/rpc", e.Avalanche = "https://node-router.thorswap.net/avalanche-c", e.Binance = "", e.BinanceSmartChain = "https://bsc-dataseed.binance.org", e.Bitcoin = "https://node-router.thorswap.net/bitcoin", e.BitcoinCash = "https://node-router.thorswap.net/bitcoin-cash", e.Cosmos = "https://node-router.thorswap.net/cosmos/rpc", e.Dogecoin = "https://node-router.thorswap.net/dogecoin", e.Ethereum = "https://node-router.thorswap.net/ethereum", e.Litecoin = "https://node-router.thorswap.net/litecoin", e.Optimism = "https://mainnet.optimism.io", e.Polygon = "https://polygon-rpc.com", e.THORChain = "https://rpc.thorswap.net", e.THORChainStagenet = "https://stagenet-rpc.ninerealms.com", e))(ui || {}), bt = /* @__PURE__ */ ((e) => (e.Cosmos = "https://node-router.thorswap.net/cosmos/rest", e.ThornodeMainnet = "https://thornode.thorswap.net", e.ThornodeStagenet = "https://stagenet-thornode.ninerealms.com", e.ThorswapApi = "https://api.thorswap.finance", e.ThorswapStatic = "https://static.thorswap.net", e))(bt || {});
const Lt = Object.values(S), qi = Object.keys(S), En = Lt.reduce(
  (e, n) => {
    const a = qi.find((o) => S[o] === n);
    return a && (e[n] = a), e;
  },
  {}
), Wi = Lt.reduce(
  (e, n) => (e[n] = gn[En[n]], e),
  {}
), Wr = Lt.reduce(
  (e, n) => (e[n] = ui[En[n]], e),
  {}
), Xr = Lt.reduce(
  (e, n) => (e[n] = gn[`${En[n]}Hex`], e),
  {}
), Yr = {
  42161: "ARB",
  "0xa4b1": "ARB",
  "0xa86a": "AVAX",
  43114: "AVAX",
  "Binance-Chain-Tigris": "BNB",
  56: "BSC",
  "0x38": "BSC",
  bitcoin: "BTC",
  bitcoincash: "BCH",
  "cosmoshub-4": "GAIA",
  dogecoin: "DOGE",
  "0x1": "ETH",
  1: "ETH",
  litecoin: "LTC",
  "thorchain-mainnet-v1": "THOR",
  "": "THOR",
  "thorchain-stagenet-v2": "THOR",
  10: "OP",
  "0xa": "OP",
  137: "MATIC",
  "0x89": "MATIC"
  /* Polygon */
}, li = {
  ARB: "https://arbiscan.io",
  AVAX: "https://snowtrace.io",
  BSC: "https://bscscan.com",
  BNB: "https://explorer.binance.org",
  BCH: "https://www.blockchain.com/bch",
  BTC: "https://blockstream.info",
  GAIA: "https://cosmos.bigdipper.live",
  DOGE: "https://blockchair.com/dogecoin",
  ETH: "https://etherscan.io",
  LTC: "https://ltc.bitaps.com",
  OP: "https://optimistic.etherscan.io",
  MATIC: "https://polygonscan.com",
  THOR: "https://viewblock.io/thorchain"
};
var Xi = /* @__PURE__ */ ((e) => (e[e.NoError = 36864] = "NoError", e))(Xi || {}), qe = /* @__PURE__ */ ((e) => (e.BOND = "BOND", e.DEPOSIT = "+", e.LEAVE = "LEAVE", e.THORNAME_REGISTER = "~", e.UNBOND = "UNBOND", e.WITHDRAW = "-", e.OPEN_LOAN = "$+", e.CLOSE_LOAN = "$-", e))(qe || {});
const zr = "image rally need wedding health address purse army antenna leopard sea gain";
var Yi = /* @__PURE__ */ ((e) => (e[e.NotInstalled = 0] = "NotInstalled", e[e.Detected = 1] = "Detected", e))(Yi || {}), Nt = /* @__PURE__ */ ((e) => (e.Average = "average", e.Fast = "fast", e.Fastest = "fastest", e))(Nt || {}), zi = /* @__PURE__ */ ((e) => (e.KEYSTORE = "KEYSTORE", e.XDEFI = "XDEFI", e.METAMASK = "METAMASK", e.COINBASE_WEB = "COINBASE_WEB", e.TREZOR = "TREZOR", e.KEEPKEY = "KEEPKEY", e.TRUSTWALLET_WEB = "TRUSTWALLET_WEB", e.LEDGER = "LEDGER", e.KEPLR = "KEPLR", e.OKX = "OKX", e.BRAVE = "BRAVE", e.WALLETCONNECT = "WALLETCONNECT", e))(zi || {});
const Ki = {
  [Nt.Average]: 1.2,
  [Nt.Fast]: 1.5,
  [Nt.Fastest]: 2
}, pi = async (e, n) => {
  const a = Object.entries(n || {}).reduce((m, [f, A]) => (A && (m[f] = A), m), {});
  return (await fetch(
    `${e}${n ? `?${new URLSearchParams(a).toString()}` : ""}`,
    { method: "GET", mode: "cors", credentials: "omit" }
  )).json();
};
var Zi = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, pn = Math.ceil, Qe = Math.floor, We = "[BigNumber Error] ", Zn = We + "Number primitive has more than 15 significant digits: ", je = 1e14, V = 14, dn = 9007199254740991, fn = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], ft = 1e7, Pe = 1e9;
function di(e) {
  var n, a, o, m = R.prototype = { constructor: R, toString: null, valueOf: null }, f = new R(1), A = 20, v = 4, O = -7, b = 21, D = -1e7, U = 1e7, j = !1, Be = 1, ee = 0, ke = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, te = "0123456789abcdefghijklmnopqrstuvwxyz", He = !0;
  function R(h, T) {
    var _, E, g, p, t, i, s, u, l = this;
    if (!(l instanceof R))
      return new R(h, T);
    if (T == null) {
      if (h && h._isBigNumber === !0) {
        l.s = h.s, !h.c || h.e > U ? l.c = l.e = null : h.e < D ? l.c = [l.e = 0] : (l.e = h.e, l.c = h.c.slice());
        return;
      }
      if ((i = typeof h == "number") && h * 0 == 0) {
        if (l.s = 1 / h < 0 ? (h = -h, -1) : 1, h === ~~h) {
          for (p = 0, t = h; t >= 10; t /= 10, p++)
            ;
          p > U ? l.c = l.e = null : (l.e = p, l.c = [h]);
          return;
        }
        u = String(h);
      } else {
        if (!Zi.test(u = String(h)))
          return o(l, u, i);
        l.s = u.charCodeAt(0) == 45 ? (u = u.slice(1), -1) : 1;
      }
      (p = u.indexOf(".")) > -1 && (u = u.replace(".", "")), (t = u.search(/e/i)) > 0 ? (p < 0 && (p = t), p += +u.slice(t + 1), u = u.substring(0, t)) : p < 0 && (p = u.length);
    } else {
      if (J(T, 2, te.length, "Base"), T == 10 && He)
        return l = new R(h), Q(l, A + l.e + 1, v);
      if (u = String(h), i = typeof h == "number") {
        if (h * 0 != 0)
          return o(l, u, i, T);
        if (l.s = 1 / h < 0 ? (u = u.slice(1), -1) : 1, R.DEBUG && u.replace(/^0\.0*|\./, "").length > 15)
          throw Error(Zn + h);
      } else
        l.s = u.charCodeAt(0) === 45 ? (u = u.slice(1), -1) : 1;
      for (_ = te.slice(0, T), p = t = 0, s = u.length; t < s; t++)
        if (_.indexOf(E = u.charAt(t)) < 0) {
          if (E == ".") {
            if (t > p) {
              p = s;
              continue;
            }
          } else if (!g && (u == u.toUpperCase() && (u = u.toLowerCase()) || u == u.toLowerCase() && (u = u.toUpperCase()))) {
            g = !0, t = -1, p = 0;
            continue;
          }
          return o(l, String(h), i, T);
        }
      i = !1, u = a(u, T, 10, l.s), (p = u.indexOf(".")) > -1 ? u = u.replace(".", "") : p = u.length;
    }
    for (t = 0; u.charCodeAt(t) === 48; t++)
      ;
    for (s = u.length; u.charCodeAt(--s) === 48; )
      ;
    if (u = u.slice(t, ++s)) {
      if (s -= t, i && R.DEBUG && s > 15 && (h > dn || h !== Qe(h)))
        throw Error(Zn + l.s * h);
      if ((p = p - t - 1) > U)
        l.c = l.e = null;
      else if (p < D)
        l.c = [l.e = 0];
      else {
        if (l.e = p, l.c = [], t = (p + 1) % V, p < 0 && (t += V), t < s) {
          for (t && l.c.push(+u.slice(0, t)), s -= V; t < s; )
            l.c.push(+u.slice(t, t += V));
          t = V - (u = u.slice(t)).length;
        } else
          t -= s;
        for (; t--; u += "0")
          ;
        l.c.push(+u);
      }
    } else
      l.c = [l.e = 0];
  }
  R.clone = di, R.ROUND_UP = 0, R.ROUND_DOWN = 1, R.ROUND_CEIL = 2, R.ROUND_FLOOR = 3, R.ROUND_HALF_UP = 4, R.ROUND_HALF_DOWN = 5, R.ROUND_HALF_EVEN = 6, R.ROUND_HALF_CEIL = 7, R.ROUND_HALF_FLOOR = 8, R.EUCLID = 9, R.config = R.set = function(h) {
    var T, _;
    if (h != null)
      if (typeof h == "object") {
        if (h.hasOwnProperty(T = "DECIMAL_PLACES") && (_ = h[T], J(_, 0, Pe, T), A = _), h.hasOwnProperty(T = "ROUNDING_MODE") && (_ = h[T], J(_, 0, 8, T), v = _), h.hasOwnProperty(T = "EXPONENTIAL_AT") && (_ = h[T], _ && _.pop ? (J(_[0], -Pe, 0, T), J(_[1], 0, Pe, T), O = _[0], b = _[1]) : (J(_, -Pe, Pe, T), O = -(b = _ < 0 ? -_ : _))), h.hasOwnProperty(T = "RANGE"))
          if (_ = h[T], _ && _.pop)
            J(_[0], -Pe, -1, T), J(_[1], 1, Pe, T), D = _[0], U = _[1];
          else if (J(_, -Pe, Pe, T), _)
            D = -(U = _ < 0 ? -_ : _);
          else
            throw Error(We + T + " cannot be zero: " + _);
        if (h.hasOwnProperty(T = "CRYPTO"))
          if (_ = h[T], _ === !!_)
            if (_)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                j = _;
              else
                throw j = !_, Error(We + "crypto unavailable");
            else
              j = _;
          else
            throw Error(We + T + " not true or false: " + _);
        if (h.hasOwnProperty(T = "MODULO_MODE") && (_ = h[T], J(_, 0, 9, T), Be = _), h.hasOwnProperty(T = "POW_PRECISION") && (_ = h[T], J(_, 0, Pe, T), ee = _), h.hasOwnProperty(T = "FORMAT"))
          if (_ = h[T], typeof _ == "object")
            ke = _;
          else
            throw Error(We + T + " not an object: " + _);
        if (h.hasOwnProperty(T = "ALPHABET"))
          if (_ = h[T], typeof _ == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(_))
            He = _.slice(0, 10) == "0123456789", te = _;
          else
            throw Error(We + T + " invalid: " + _);
      } else
        throw Error(We + "Object expected: " + h);
    return {
      DECIMAL_PLACES: A,
      ROUNDING_MODE: v,
      EXPONENTIAL_AT: [O, b],
      RANGE: [D, U],
      CRYPTO: j,
      MODULO_MODE: Be,
      POW_PRECISION: ee,
      FORMAT: ke,
      ALPHABET: te
    };
  }, R.isBigNumber = function(h) {
    if (!h || h._isBigNumber !== !0)
      return !1;
    if (!R.DEBUG)
      return !0;
    var T, _, E = h.c, g = h.e, p = h.s;
    e:
      if ({}.toString.call(E) == "[object Array]") {
        if ((p === 1 || p === -1) && g >= -Pe && g <= Pe && g === Qe(g)) {
          if (E[0] === 0) {
            if (g === 0 && E.length === 1)
              return !0;
            break e;
          }
          if (T = (g + 1) % V, T < 1 && (T += V), String(E[0]).length == T) {
            for (T = 0; T < E.length; T++)
              if (_ = E[T], _ < 0 || _ >= je || _ !== Qe(_))
                break e;
            if (_ !== 0)
              return !0;
          }
        }
      } else if (E === null && g === null && (p === null || p === 1 || p === -1))
        return !0;
    throw Error(We + "Invalid BigNumber: " + h);
  }, R.maximum = R.max = function() {
    return mt(arguments, -1);
  }, R.minimum = R.min = function() {
    return mt(arguments, 1);
  }, R.random = function() {
    var h = 9007199254740992, T = Math.random() * h & 2097151 ? function() {
      return Qe(Math.random() * h);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(_) {
      var E, g, p, t, i, s = 0, u = [], l = new R(f);
      if (_ == null ? _ = A : J(_, 0, Pe), t = pn(_ / V), j)
        if (crypto.getRandomValues) {
          for (E = crypto.getRandomValues(new Uint32Array(t *= 2)); s < t; )
            i = E[s] * 131072 + (E[s + 1] >>> 11), i >= 9e15 ? (g = crypto.getRandomValues(new Uint32Array(2)), E[s] = g[0], E[s + 1] = g[1]) : (u.push(i % 1e14), s += 2);
          s = t / 2;
        } else if (crypto.randomBytes) {
          for (E = crypto.randomBytes(t *= 7); s < t; )
            i = (E[s] & 31) * 281474976710656 + E[s + 1] * 1099511627776 + E[s + 2] * 4294967296 + E[s + 3] * 16777216 + (E[s + 4] << 16) + (E[s + 5] << 8) + E[s + 6], i >= 9e15 ? crypto.randomBytes(7).copy(E, s) : (u.push(i % 1e14), s += 7);
          s = t / 7;
        } else
          throw j = !1, Error(We + "crypto unavailable");
      if (!j)
        for (; s < t; )
          i = T(), i < 9e15 && (u[s++] = i % 1e14);
      for (t = u[--s], _ %= V, t && _ && (i = fn[V - _], u[s] = Qe(t / i) * i); u[s] === 0; u.pop(), s--)
        ;
      if (s < 0)
        u = [p = 0];
      else {
        for (p = -1; u[0] === 0; u.splice(0, 1), p -= V)
          ;
        for (s = 1, i = u[0]; i >= 10; i /= 10, s++)
          ;
        s < V && (p -= V - s);
      }
      return l.e = p, l.c = u, l;
    };
  }(), R.sum = function() {
    for (var h = 1, T = arguments, _ = new R(T[0]); h < T.length; )
      _ = _.plus(T[h++]);
    return _;
  }, a = function() {
    var h = "0123456789";
    function T(_, E, g, p) {
      for (var t, i = [0], s, u = 0, l = _.length; u < l; ) {
        for (s = i.length; s--; i[s] *= E)
          ;
        for (i[0] += p.indexOf(_.charAt(u++)), t = 0; t < i.length; t++)
          i[t] > g - 1 && (i[t + 1] == null && (i[t + 1] = 0), i[t + 1] += i[t] / g | 0, i[t] %= g);
      }
      return i.reverse();
    }
    return function(_, E, g, p, t) {
      var i, s, u, l, c, w, d, r, y = _.indexOf("."), I = A, M = v;
      for (y >= 0 && (l = ee, ee = 0, _ = _.replace(".", ""), r = new R(E), w = r.pow(_.length - y), ee = l, r.c = T(
        ut(Ze(w.c), w.e, "0"),
        10,
        g,
        h
      ), r.e = r.c.length), d = T(_, E, g, t ? (i = te, h) : (i = h, te)), u = l = d.length; d[--l] == 0; d.pop())
        ;
      if (!d[0])
        return i.charAt(0);
      if (y < 0 ? --u : (w.c = d, w.e = u, w.s = p, w = n(w, r, I, M, g), d = w.c, c = w.r, u = w.e), s = u + I + 1, y = d[s], l = g / 2, c = c || s < 0 || d[s + 1] != null, c = M < 4 ? (y != null || c) && (M == 0 || M == (w.s < 0 ? 3 : 2)) : y > l || y == l && (M == 4 || c || M == 6 && d[s - 1] & 1 || M == (w.s < 0 ? 8 : 7)), s < 1 || !d[0])
        _ = c ? ut(i.charAt(1), -I, i.charAt(0)) : i.charAt(0);
      else {
        if (d.length = s, c)
          for (--g; ++d[--s] > g; )
            d[s] = 0, s || (++u, d = [1].concat(d));
        for (l = d.length; !d[--l]; )
          ;
        for (y = 0, _ = ""; y <= l; _ += i.charAt(d[y++]))
          ;
        _ = ut(_, u, i.charAt(0));
      }
      return _;
    };
  }(), n = function() {
    function h(E, g, p) {
      var t, i, s, u, l = 0, c = E.length, w = g % ft, d = g / ft | 0;
      for (E = E.slice(); c--; )
        s = E[c] % ft, u = E[c] / ft | 0, t = d * s + u * w, i = w * s + t % ft * ft + l, l = (i / p | 0) + (t / ft | 0) + d * u, E[c] = i % p;
      return l && (E = [l].concat(E)), E;
    }
    function T(E, g, p, t) {
      var i, s;
      if (p != t)
        s = p > t ? 1 : -1;
      else
        for (i = s = 0; i < p; i++)
          if (E[i] != g[i]) {
            s = E[i] > g[i] ? 1 : -1;
            break;
          }
      return s;
    }
    function _(E, g, p, t) {
      for (var i = 0; p--; )
        E[p] -= i, i = E[p] < g[p] ? 1 : 0, E[p] = i * t + E[p] - g[p];
      for (; !E[0] && E.length > 1; E.splice(0, 1))
        ;
    }
    return function(E, g, p, t, i) {
      var s, u, l, c, w, d, r, y, I, M, N, q, X, Y, Et, W, z, Ve = E.s == g.s ? 1 : -1, k = E.c, H = g.c;
      if (!k || !k[0] || !H || !H[0])
        return new R(
          // Return NaN if either NaN, or both Infinity or 0.
          !E.s || !g.s || (k ? H && k[0] == H[0] : !H) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            k && k[0] == 0 || !H ? Ve * 0 : Ve / 0
          )
        );
      for (y = new R(Ve), I = y.c = [], u = E.e - g.e, Ve = p + u + 1, i || (i = je, u = Je(E.e / V) - Je(g.e / V), Ve = Ve / V | 0), l = 0; H[l] == (k[l] || 0); l++)
        ;
      if (H[l] > (k[l] || 0) && u--, Ve < 0)
        I.push(1), c = !0;
      else {
        for (Y = k.length, W = H.length, l = 0, Ve += 2, w = Qe(i / (H[0] + 1)), w > 1 && (H = h(H, w, i), k = h(k, w, i), W = H.length, Y = k.length), X = W, M = k.slice(0, W), N = M.length; N < W; M[N++] = 0)
          ;
        z = H.slice(), z = [0].concat(z), Et = H[0], H[1] >= i / 2 && Et++;
        do {
          if (w = 0, s = T(H, M, W, N), s < 0) {
            if (q = M[0], W != N && (q = q * i + (M[1] || 0)), w = Qe(q / Et), w > 1)
              for (w >= i && (w = i - 1), d = h(H, w, i), r = d.length, N = M.length; T(d, M, r, N) == 1; )
                w--, _(d, W < r ? z : H, r, i), r = d.length, s = 1;
            else
              w == 0 && (s = w = 1), d = H.slice(), r = d.length;
            if (r < N && (d = [0].concat(d)), _(M, d, N, i), N = M.length, s == -1)
              for (; T(H, M, W, N) < 1; )
                w++, _(M, W < N ? z : H, N, i), N = M.length;
          } else
            s === 0 && (w++, M = [0]);
          I[l++] = w, M[0] ? M[N++] = k[X] || 0 : (M = [k[X]], N = 1);
        } while ((X++ < Y || M[0] != null) && Ve--);
        c = M[0] != null, I[0] || I.splice(0, 1);
      }
      if (i == je) {
        for (l = 1, Ve = I[0]; Ve >= 10; Ve /= 10, l++)
          ;
        Q(y, p + (y.e = l + u * V - 1) + 1, t, c);
      } else
        y.e = u, y.r = +c;
      return y;
    };
  }();
  function it(h, T, _, E) {
    var g, p, t, i, s;
    if (_ == null ? _ = v : J(_, 0, 8), !h.c)
      return h.toString();
    if (g = h.c[0], t = h.e, T == null)
      s = Ze(h.c), s = E == 1 || E == 2 && (t <= O || t >= b) ? Ct(s, t) : ut(s, t, "0");
    else if (h = Q(new R(h), T, _), p = h.e, s = Ze(h.c), i = s.length, E == 1 || E == 2 && (T <= p || p <= O)) {
      for (; i < T; s += "0", i++)
        ;
      s = Ct(s, p);
    } else if (T -= t, s = ut(s, p, "0"), p + 1 > i) {
      if (--T > 0)
        for (s += "."; T--; s += "0")
          ;
    } else if (T += p - i, T > 0)
      for (p + 1 == i && (s += "."); T--; s += "0")
        ;
    return h.s < 0 && g ? "-" + s : s;
  }
  function mt(h, T) {
    for (var _, E, g = 1, p = new R(h[0]); g < h.length; g++)
      E = new R(h[g]), (!E.s || (_ = yt(p, E)) === T || _ === 0 && p.s === T) && (p = E);
    return p;
  }
  function ct(h, T, _) {
    for (var E = 1, g = T.length; !T[--g]; T.pop())
      ;
    for (g = T[0]; g >= 10; g /= 10, E++)
      ;
    return (_ = E + _ * V - 1) > U ? h.c = h.e = null : _ < D ? h.c = [h.e = 0] : (h.e = _, h.c = T), h;
  }
  o = function() {
    var h = /^(-?)0([xbo])(?=\w[\w.]*$)/i, T = /^([^.]+)\.$/, _ = /^\.([^.]+)$/, E = /^-?(Infinity|NaN)$/, g = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(p, t, i, s) {
      var u, l = i ? t : t.replace(g, "");
      if (E.test(l))
        p.s = isNaN(l) ? null : l < 0 ? -1 : 1;
      else {
        if (!i && (l = l.replace(h, function(c, w, d) {
          return u = (d = d.toLowerCase()) == "x" ? 16 : d == "b" ? 2 : 8, !s || s == u ? w : c;
        }), s && (u = s, l = l.replace(T, "$1").replace(_, "0.$1")), t != l))
          return new R(l, u);
        if (R.DEBUG)
          throw Error(We + "Not a" + (s ? " base " + s : "") + " number: " + t);
        p.s = null;
      }
      p.c = p.e = null;
    };
  }();
  function Q(h, T, _, E) {
    var g, p, t, i, s, u, l, c = h.c, w = fn;
    if (c) {
      e: {
        for (g = 1, i = c[0]; i >= 10; i /= 10, g++)
          ;
        if (p = T - g, p < 0)
          p += V, t = T, s = c[u = 0], l = Qe(s / w[g - t - 1] % 10);
        else if (u = pn((p + 1) / V), u >= c.length)
          if (E) {
            for (; c.length <= u; c.push(0))
              ;
            s = l = 0, g = 1, p %= V, t = p - V + 1;
          } else
            break e;
        else {
          for (s = i = c[u], g = 1; i >= 10; i /= 10, g++)
            ;
          p %= V, t = p - V + g, l = t < 0 ? 0 : Qe(s / w[g - t - 1] % 10);
        }
        if (E = E || T < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        c[u + 1] != null || (t < 0 ? s : s % w[g - t - 1]), E = _ < 4 ? (l || E) && (_ == 0 || _ == (h.s < 0 ? 3 : 2)) : l > 5 || l == 5 && (_ == 4 || E || _ == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (p > 0 ? t > 0 ? s / w[g - t] : 0 : c[u - 1]) % 10 & 1 || _ == (h.s < 0 ? 8 : 7)), T < 1 || !c[0])
          return c.length = 0, E ? (T -= h.e + 1, c[0] = w[(V - T % V) % V], h.e = -T || 0) : c[0] = h.e = 0, h;
        if (p == 0 ? (c.length = u, i = 1, u--) : (c.length = u + 1, i = w[V - p], c[u] = t > 0 ? Qe(s / w[g - t] % w[t]) * i : 0), E)
          for (; ; )
            if (u == 0) {
              for (p = 1, t = c[0]; t >= 10; t /= 10, p++)
                ;
              for (t = c[0] += i, i = 1; t >= 10; t /= 10, i++)
                ;
              p != i && (h.e++, c[0] == je && (c[0] = 1));
              break;
            } else {
              if (c[u] += i, c[u] != je)
                break;
              c[u--] = 0, i = 1;
            }
        for (p = c.length; c[--p] === 0; c.pop())
          ;
      }
      h.e > U ? h.c = h.e = null : h.e < D && (h.c = [h.e = 0]);
    }
    return h;
  }
  function Ge(h) {
    var T, _ = h.e;
    return _ === null ? h.toString() : (T = Ze(h.c), T = _ <= O || _ >= b ? Ct(T, _) : ut(T, _, "0"), h.s < 0 ? "-" + T : T);
  }
  return m.absoluteValue = m.abs = function() {
    var h = new R(this);
    return h.s < 0 && (h.s = 1), h;
  }, m.comparedTo = function(h, T) {
    return yt(this, new R(h, T));
  }, m.decimalPlaces = m.dp = function(h, T) {
    var _, E, g, p = this;
    if (h != null)
      return J(h, 0, Pe), T == null ? T = v : J(T, 0, 8), Q(new R(p), h + p.e + 1, T);
    if (!(_ = p.c))
      return null;
    if (E = ((g = _.length - 1) - Je(this.e / V)) * V, g = _[g])
      for (; g % 10 == 0; g /= 10, E--)
        ;
    return E < 0 && (E = 0), E;
  }, m.dividedBy = m.div = function(h, T) {
    return n(this, new R(h, T), A, v);
  }, m.dividedToIntegerBy = m.idiv = function(h, T) {
    return n(this, new R(h, T), 0, 1);
  }, m.exponentiatedBy = m.pow = function(h, T) {
    var _, E, g, p, t, i, s, u, l, c = this;
    if (h = new R(h), h.c && !h.isInteger())
      throw Error(We + "Exponent not an integer: " + Ge(h));
    if (T != null && (T = new R(T)), i = h.e > 14, !c.c || !c.c[0] || c.c[0] == 1 && !c.e && c.c.length == 1 || !h.c || !h.c[0])
      return l = new R(Math.pow(+Ge(c), i ? h.s * (2 - xt(h)) : +Ge(h))), T ? l.mod(T) : l;
    if (s = h.s < 0, T) {
      if (T.c ? !T.c[0] : !T.s)
        return new R(NaN);
      E = !s && c.isInteger() && T.isInteger(), E && (c = c.mod(T));
    } else {
      if (h.e > 9 && (c.e > 0 || c.e < -1 || (c.e == 0 ? c.c[0] > 1 || i && c.c[1] >= 24e7 : c.c[0] < 8e13 || i && c.c[0] <= 9999975e7)))
        return p = c.s < 0 && xt(h) ? -0 : 0, c.e > -1 && (p = 1 / p), new R(s ? 1 / p : p);
      ee && (p = pn(ee / V + 2));
    }
    for (i ? (_ = new R(0.5), s && (h.s = 1), u = xt(h)) : (g = Math.abs(+Ge(h)), u = g % 2), l = new R(f); ; ) {
      if (u) {
        if (l = l.times(c), !l.c)
          break;
        p ? l.c.length > p && (l.c.length = p) : E && (l = l.mod(T));
      }
      if (g) {
        if (g = Qe(g / 2), g === 0)
          break;
        u = g % 2;
      } else if (h = h.times(_), Q(h, h.e + 1, 1), h.e > 14)
        u = xt(h);
      else {
        if (g = +Ge(h), g === 0)
          break;
        u = g % 2;
      }
      c = c.times(c), p ? c.c && c.c.length > p && (c.c.length = p) : E && (c = c.mod(T));
    }
    return E ? l : (s && (l = f.div(l)), T ? l.mod(T) : p ? Q(l, ee, v, t) : l);
  }, m.integerValue = function(h) {
    var T = new R(this);
    return h == null ? h = v : J(h, 0, 8), Q(T, T.e + 1, h);
  }, m.isEqualTo = m.eq = function(h, T) {
    return yt(this, new R(h, T)) === 0;
  }, m.isFinite = function() {
    return !!this.c;
  }, m.isGreaterThan = m.gt = function(h, T) {
    return yt(this, new R(h, T)) > 0;
  }, m.isGreaterThanOrEqualTo = m.gte = function(h, T) {
    return (T = yt(this, new R(h, T))) === 1 || T === 0;
  }, m.isInteger = function() {
    return !!this.c && Je(this.e / V) > this.c.length - 2;
  }, m.isLessThan = m.lt = function(h, T) {
    return yt(this, new R(h, T)) < 0;
  }, m.isLessThanOrEqualTo = m.lte = function(h, T) {
    return (T = yt(this, new R(h, T))) === -1 || T === 0;
  }, m.isNaN = function() {
    return !this.s;
  }, m.isNegative = function() {
    return this.s < 0;
  }, m.isPositive = function() {
    return this.s > 0;
  }, m.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, m.minus = function(h, T) {
    var _, E, g, p, t = this, i = t.s;
    if (h = new R(h, T), T = h.s, !i || !T)
      return new R(NaN);
    if (i != T)
      return h.s = -T, t.plus(h);
    var s = t.e / V, u = h.e / V, l = t.c, c = h.c;
    if (!s || !u) {
      if (!l || !c)
        return l ? (h.s = -T, h) : new R(c ? t : NaN);
      if (!l[0] || !c[0])
        return c[0] ? (h.s = -T, h) : new R(l[0] ? t : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          v == 3 ? -0 : 0
        ));
    }
    if (s = Je(s), u = Je(u), l = l.slice(), i = s - u) {
      for ((p = i < 0) ? (i = -i, g = l) : (u = s, g = c), g.reverse(), T = i; T--; g.push(0))
        ;
      g.reverse();
    } else
      for (E = (p = (i = l.length) < (T = c.length)) ? i : T, i = T = 0; T < E; T++)
        if (l[T] != c[T]) {
          p = l[T] < c[T];
          break;
        }
    if (p && (g = l, l = c, c = g, h.s = -h.s), T = (E = c.length) - (_ = l.length), T > 0)
      for (; T--; l[_++] = 0)
        ;
    for (T = je - 1; E > i; ) {
      if (l[--E] < c[E]) {
        for (_ = E; _ && !l[--_]; l[_] = T)
          ;
        --l[_], l[E] += je;
      }
      l[E] -= c[E];
    }
    for (; l[0] == 0; l.splice(0, 1), --u)
      ;
    return l[0] ? ct(h, l, u) : (h.s = v == 3 ? -1 : 1, h.c = [h.e = 0], h);
  }, m.modulo = m.mod = function(h, T) {
    var _, E, g = this;
    return h = new R(h, T), !g.c || !h.s || h.c && !h.c[0] ? new R(NaN) : !h.c || g.c && !g.c[0] ? new R(g) : (Be == 9 ? (E = h.s, h.s = 1, _ = n(g, h, 0, 3), h.s = E, _.s *= E) : _ = n(g, h, 0, Be), h = g.minus(_.times(h)), !h.c[0] && Be == 1 && (h.s = g.s), h);
  }, m.multipliedBy = m.times = function(h, T) {
    var _, E, g, p, t, i, s, u, l, c, w, d, r, y, I, M = this, N = M.c, q = (h = new R(h, T)).c;
    if (!N || !q || !N[0] || !q[0])
      return !M.s || !h.s || N && !N[0] && !q || q && !q[0] && !N ? h.c = h.e = h.s = null : (h.s *= M.s, !N || !q ? h.c = h.e = null : (h.c = [0], h.e = 0)), h;
    for (E = Je(M.e / V) + Je(h.e / V), h.s *= M.s, s = N.length, c = q.length, s < c && (r = N, N = q, q = r, g = s, s = c, c = g), g = s + c, r = []; g--; r.push(0))
      ;
    for (y = je, I = ft, g = c; --g >= 0; ) {
      for (_ = 0, w = q[g] % I, d = q[g] / I | 0, t = s, p = g + t; p > g; )
        u = N[--t] % I, l = N[t] / I | 0, i = d * u + l * w, u = w * u + i % I * I + r[p] + _, _ = (u / y | 0) + (i / I | 0) + d * l, r[p--] = u % y;
      r[p] = _;
    }
    return _ ? ++E : r.splice(0, 1), ct(h, r, E);
  }, m.negated = function() {
    var h = new R(this);
    return h.s = -h.s || null, h;
  }, m.plus = function(h, T) {
    var _, E = this, g = E.s;
    if (h = new R(h, T), T = h.s, !g || !T)
      return new R(NaN);
    if (g != T)
      return h.s = -T, E.minus(h);
    var p = E.e / V, t = h.e / V, i = E.c, s = h.c;
    if (!p || !t) {
      if (!i || !s)
        return new R(g / 0);
      if (!i[0] || !s[0])
        return s[0] ? h : new R(i[0] ? E : g * 0);
    }
    if (p = Je(p), t = Je(t), i = i.slice(), g = p - t) {
      for (g > 0 ? (t = p, _ = s) : (g = -g, _ = i), _.reverse(); g--; _.push(0))
        ;
      _.reverse();
    }
    for (g = i.length, T = s.length, g - T < 0 && (_ = s, s = i, i = _, T = g), g = 0; T; )
      g = (i[--T] = i[T] + s[T] + g) / je | 0, i[T] = je === i[T] ? 0 : i[T] % je;
    return g && (i = [g].concat(i), ++t), ct(h, i, t);
  }, m.precision = m.sd = function(h, T) {
    var _, E, g, p = this;
    if (h != null && h !== !!h)
      return J(h, 1, Pe), T == null ? T = v : J(T, 0, 8), Q(new R(p), h, T);
    if (!(_ = p.c))
      return null;
    if (g = _.length - 1, E = g * V + 1, g = _[g]) {
      for (; g % 10 == 0; g /= 10, E--)
        ;
      for (g = _[0]; g >= 10; g /= 10, E++)
        ;
    }
    return h && p.e + 1 > E && (E = p.e + 1), E;
  }, m.shiftedBy = function(h) {
    return J(h, -dn, dn), this.times("1e" + h);
  }, m.squareRoot = m.sqrt = function() {
    var h, T, _, E, g, p = this, t = p.c, i = p.s, s = p.e, u = A + 4, l = new R("0.5");
    if (i !== 1 || !t || !t[0])
      return new R(!i || i < 0 && (!t || t[0]) ? NaN : t ? p : 1 / 0);
    if (i = Math.sqrt(+Ge(p)), i == 0 || i == 1 / 0 ? (T = Ze(t), (T.length + s) % 2 == 0 && (T += "0"), i = Math.sqrt(+T), s = Je((s + 1) / 2) - (s < 0 || s % 2), i == 1 / 0 ? T = "5e" + s : (T = i.toExponential(), T = T.slice(0, T.indexOf("e") + 1) + s), _ = new R(T)) : _ = new R(i + ""), _.c[0]) {
      for (s = _.e, i = s + u, i < 3 && (i = 0); ; )
        if (g = _, _ = l.times(g.plus(n(p, g, u, 1))), Ze(g.c).slice(0, i) === (T = Ze(_.c)).slice(0, i))
          if (_.e < s && --i, T = T.slice(i - 3, i + 1), T == "9999" || !E && T == "4999") {
            if (!E && (Q(g, g.e + A + 2, 0), g.times(g).eq(p))) {
              _ = g;
              break;
            }
            u += 4, i += 4, E = 1;
          } else {
            (!+T || !+T.slice(1) && T.charAt(0) == "5") && (Q(_, _.e + A + 2, 1), h = !_.times(_).eq(p));
            break;
          }
    }
    return Q(_, _.e + A + 1, v, h);
  }, m.toExponential = function(h, T) {
    return h != null && (J(h, 0, Pe), h++), it(this, h, T, 1);
  }, m.toFixed = function(h, T) {
    return h != null && (J(h, 0, Pe), h = h + this.e + 1), it(this, h, T);
  }, m.toFormat = function(h, T, _) {
    var E, g = this;
    if (_ == null)
      h != null && T && typeof T == "object" ? (_ = T, T = null) : h && typeof h == "object" ? (_ = h, h = T = null) : _ = ke;
    else if (typeof _ != "object")
      throw Error(We + "Argument not an object: " + _);
    if (E = g.toFixed(h, T), g.c) {
      var p, t = E.split("."), i = +_.groupSize, s = +_.secondaryGroupSize, u = _.groupSeparator || "", l = t[0], c = t[1], w = g.s < 0, d = w ? l.slice(1) : l, r = d.length;
      if (s && (p = i, i = s, s = p, r -= p), i > 0 && r > 0) {
        for (p = r % i || i, l = d.substr(0, p); p < r; p += i)
          l += u + d.substr(p, i);
        s > 0 && (l += u + d.slice(p)), w && (l = "-" + l);
      }
      E = c ? l + (_.decimalSeparator || "") + ((s = +_.fractionGroupSize) ? c.replace(
        new RegExp("\\d{" + s + "}\\B", "g"),
        "$&" + (_.fractionGroupSeparator || "")
      ) : c) : l;
    }
    return (_.prefix || "") + E + (_.suffix || "");
  }, m.toFraction = function(h) {
    var T, _, E, g, p, t, i, s, u, l, c, w, d = this, r = d.c;
    if (h != null && (i = new R(h), !i.isInteger() && (i.c || i.s !== 1) || i.lt(f)))
      throw Error(We + "Argument " + (i.isInteger() ? "out of range: " : "not an integer: ") + Ge(i));
    if (!r)
      return new R(d);
    for (T = new R(f), u = _ = new R(f), E = s = new R(f), w = Ze(r), p = T.e = w.length - d.e - 1, T.c[0] = fn[(t = p % V) < 0 ? V + t : t], h = !h || i.comparedTo(T) > 0 ? p > 0 ? T : u : i, t = U, U = 1 / 0, i = new R(w), s.c[0] = 0; l = n(i, T, 0, 1), g = _.plus(l.times(E)), g.comparedTo(h) != 1; )
      _ = E, E = g, u = s.plus(l.times(g = u)), s = g, T = i.minus(l.times(g = T)), i = g;
    return g = n(h.minus(_), E, 0, 1), s = s.plus(g.times(u)), _ = _.plus(g.times(E)), s.s = u.s = d.s, p = p * 2, c = n(u, E, p, v).minus(d).abs().comparedTo(
      n(s, _, p, v).minus(d).abs()
    ) < 1 ? [u, E] : [s, _], U = t, c;
  }, m.toNumber = function() {
    return +Ge(this);
  }, m.toPrecision = function(h, T) {
    return h != null && J(h, 1, Pe), it(this, h, T, 2);
  }, m.toString = function(h) {
    var T, _ = this, E = _.s, g = _.e;
    return g === null ? E ? (T = "Infinity", E < 0 && (T = "-" + T)) : T = "NaN" : (h == null ? T = g <= O || g >= b ? Ct(Ze(_.c), g) : ut(Ze(_.c), g, "0") : h === 10 && He ? (_ = Q(new R(_), A + g + 1, v), T = ut(Ze(_.c), _.e, "0")) : (J(h, 2, te.length, "Base"), T = a(ut(Ze(_.c), g, "0"), 10, h, E, !0)), E < 0 && _.c[0] && (T = "-" + T)), T;
  }, m.valueOf = m.toJSON = function() {
    return Ge(this);
  }, m._isBigNumber = !0, m[Symbol.toStringTag] = "BigNumber", m[Symbol.for("nodejs.util.inspect.custom")] = m.valueOf, e != null && R.set(e), R;
}
function Je(e) {
  var n = e | 0;
  return e > 0 || e === n ? n : n - 1;
}
function Ze(e) {
  for (var n, a, o = 1, m = e.length, f = e[0] + ""; o < m; ) {
    for (n = e[o++] + "", a = V - n.length; a--; n = "0" + n)
      ;
    f += n;
  }
  for (m = f.length; f.charCodeAt(--m) === 48; )
    ;
  return f.slice(0, m + 1 || 1);
}
function yt(e, n) {
  var a, o, m = e.c, f = n.c, A = e.s, v = n.s, O = e.e, b = n.e;
  if (!A || !v)
    return null;
  if (a = m && !m[0], o = f && !f[0], a || o)
    return a ? o ? 0 : -v : A;
  if (A != v)
    return A;
  if (a = A < 0, o = O == b, !m || !f)
    return o ? 0 : !m ^ a ? 1 : -1;
  if (!o)
    return O > b ^ a ? 1 : -1;
  for (v = (O = m.length) < (b = f.length) ? O : b, A = 0; A < v; A++)
    if (m[A] != f[A])
      return m[A] > f[A] ^ a ? 1 : -1;
  return O == b ? 0 : O > b ^ a ? 1 : -1;
}
function J(e, n, a, o) {
  if (e < n || e > a || e !== Qe(e))
    throw Error(We + (o || "Argument") + (typeof e == "number" ? e < n || e > a ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e));
}
function xt(e) {
  var n = e.c.length - 1;
  return Je(e.e / V) == n && e.c[n] % 2 != 0;
}
function Ct(e, n) {
  return (e.length > 1 ? e.charAt(0) + "." + e.slice(1) : e) + (n < 0 ? "e" : "e+") + n;
}
function ut(e, n, a) {
  var o, m;
  if (n < 0) {
    for (m = a + "."; ++n; m += a)
      ;
    e = m + e;
  } else if (o = e.length, ++n > o) {
    for (m = a, n -= o; --n; m += a)
      ;
    e += m;
  } else
    n < o && (e = e.slice(0, n) + "." + e.slice(n));
  return e;
}
var Le = di(), Qi = Object.defineProperty, Ji = (e, n, a) => n in e ? Qi(e, n, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[n] = a, K = (e, n, a) => (Ji(e, typeof n != "symbol" ? n + "" : n, a), a), Tt = /* @__PURE__ */ ((e) => (e.THOR = "THOR", e.RUNE = "RUNE", e.ATOM = "ATOM", e.MUON = "MUON", e.USDC = "USDC", e))(Tt || {}), B = /* @__PURE__ */ ((e) => (e.INVALID_INPUT_PARAMETERS = "1000", e.UNKNOWN_PROVIDERS = "1001", e.CANNOT_FIND_INBOUND_ADDRESS = "1002", e.NO_INBOUND_ADDRESSES = "1003", e.CHAIN_HALTED_OR_UNSUPPORTED = "1004", e.MISSING_INPUT_PARAMETER = "1005", e.INVALID_TYPE_GENERIC = "1100", e.INVALID_NUMBER_STRING = "1101", e.INVALID_NUMBER = "1102", e.INVALID_BOOLEAN = "1103", e.INVALID_OBJECT = "1104", e.INVALID_ARRAY = "1105", e.SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2000", e.SELL_BUY_ASSETS_ARE_THE_SAME = "2001", e.MISSING_SOURCE_ADDRESS_FOR_SYNTH = "2002", e.AFF_ADDRESS_AND_BPS_OR_NEITHER = "2003", e.AFF_ADDRESS_TOO_LONG = "2004", e.AFF_BPS_INTEGER_0_100 = "2005", e.SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN = "2006", e.DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN = "2007", e.PREFERRED_PROFVIDER_NOT_SUPPORTED = "2008", e.DESTINATION_ADDRESS_SMART_CONTRACT = "2009", e.BUY_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2010", e.SOURCE_ADDRESS_SMART_CONTRACT = "2011", e.INVALID_PROVIDER = "2100", e.MISSING_CROSS_CHAIN_PROVIDER = "2101", e.MISSING_AVAX_PROVIDER = "2102", e.MISSING_BSC_PROVIDER = "2103", e.MISSING_ETH_PROVIDER = "2104", e.INVALID_PROVIDER_FOR_SWAP_OUT = "2105", e.MISSING_ARB_PROVIDER = "2106", e.INVALID_CHAIN = "2200", e.INVALID_ASSET = "2201", e.INVALID_ASSET_IDENTIFIER = "2202", e.UNSUPPORTED_CHAIN = "2204", e.UNSUPPORTED_ASSET = "2203", e.UNSUPPORTED_ASSET_FOR_SWAPOUT = "2205", e.THORNODE_QUOTE_GENERIC_ERROR = "3000", e.NOT_ENOUGH_SYNTH_BALANCE = "3001", e.SYNTH_MINTING_CAP_REACHED = "3002", e.INVALID_QUOTE_MODE = "4000", e.NO_QUOTES = "4001", e.SERVICE_UNAVAILABLE_GENERIC = "5000", e.MISSING_GAS_DATA_GENERIC = "5100", e.MISSING_TOKEN_INFO_GENERIC = "5200", e.CANT_FIND_TOKEN_LIST = "5201", e.NO_PRICE = "5202", e.PRICE_IS_STALE = "5203", e.ADDRESS_NOT_WHITELISTED = "6000", e.ADDRESS_ALREADY_CLAIMED = "6001", e.TEMPORARY_ERROR = "9999", e))(B || {});
B.INVALID_INPUT_PARAMETERS + "", B.UNKNOWN_PROVIDERS + "", B.CANNOT_FIND_INBOUND_ADDRESS + "", B.NO_INBOUND_ADDRESSES + "", B.CHAIN_HALTED_OR_UNSUPPORTED + "", B.MISSING_INPUT_PARAMETER + "", B.INVALID_TYPE_GENERIC + "", B.INVALID_NUMBER_STRING + "", B.INVALID_NUMBER + "", B.INVALID_BOOLEAN + "", B.INVALID_OBJECT + "", B.INVALID_ARRAY + "", B.SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER + "", B.SELL_BUY_ASSETS_ARE_THE_SAME + "", B.MISSING_SOURCE_ADDRESS_FOR_SYNTH + "", B.AFF_ADDRESS_AND_BPS_OR_NEITHER + "", B.AFF_ADDRESS_TOO_LONG + "", B.AFF_BPS_INTEGER_0_100 + "", B.SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN + "", B.DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN + "", B.PREFERRED_PROFVIDER_NOT_SUPPORTED + "", B.DESTINATION_ADDRESS_SMART_CONTRACT + "", B.BUY_AMOUNT_MUST_BE_POSITIVE_INTEGER + "", B.INVALID_PROVIDER + "", B.MISSING_CROSS_CHAIN_PROVIDER + "", B.MISSING_AVAX_PROVIDER + "", B.MISSING_BSC_PROVIDER + "", B.MISSING_ETH_PROVIDER + "", B.MISSING_ARB_PROVIDER + "", B.INVALID_PROVIDER_FOR_SWAP_OUT + "", B.INVALID_CHAIN + "", B.INVALID_ASSET + "", B.UNSUPPORTED_CHAIN + "", B.UNSUPPORTED_ASSET + "", B.UNSUPPORTED_ASSET_FOR_SWAPOUT + "", B.THORNODE_QUOTE_GENERIC_ERROR + "", B.NOT_ENOUGH_SYNTH_BALANCE + "", B.SYNTH_MINTING_CAP_REACHED + "", B.INVALID_QUOTE_MODE + "", B.NO_QUOTES + "", B.SERVICE_UNAVAILABLE_GENERIC + "", B.MISSING_GAS_DATA_GENERIC + "", B.MISSING_TOKEN_INFO_GENERIC + "", B.CANT_FIND_TOKEN_LIST + "", B.NO_PRICE + "", B.PRICE_IS_STALE + "", B.ADDRESS_NOT_WHITELISTED + "", B.ADDRESS_ALREADY_CLAIMED + "";
var x = /* @__PURE__ */ ((e) => (e.Arbitrum = "ARB", e.Avalanche = "AVAX", e.Binance = "BNB", e.BinanceSmartChain = "BSC", e.Bitcoin = "BTC", e.BitcoinCash = "BCH", e.Cosmos = "GAIA", e.Dogecoin = "DOGE", e.Ethereum = "ETH", e.Litecoin = "LTC", e.Optimism = "OP", e.Polygon = "MATIC", e.THORChain = "THOR", e))(x || {}), Z = /* @__PURE__ */ ((e) => (e[e.ARB = 18] = "ARB", e[e.AVAX = 18] = "AVAX", e[e.BCH = 8] = "BCH", e[e.BNB = 8] = "BNB", e[e.BSC = 18] = "BSC", e[e.BTC = 8] = "BTC", e[e.DOGE = 8] = "DOGE", e[e.ETH = 18] = "ETH", e[e.GAIA = 6] = "GAIA", e[e.LTC = 8] = "LTC", e[e.MATIC = 18] = "MATIC", e[e.OP = 18] = "OP", e[e.THOR = 8] = "THOR", e))(Z || {}), An = /* @__PURE__ */ ((e) => (e.Arbitrum = "42161", e.ArbitrumHex = "0xa4b1", e.Avalanche = "43114", e.AvalancheHex = "0xa86a", e.Binance = "Binance-Chain-Tigris", e.BinanceHex = "", e.BinanceSmartChain = "56", e.BinanceSmartChainHex = "0x38", e.Bitcoin = "bitcoin", e.BitcoinHex = "", e.BitcoinCash = "bitcoincash", e.BitcoinCashHex = "", e.Cosmos = "cosmoshub-4", e.CosmosHex = "", e.Dogecoin = "dogecoin", e.DogecoinHex = "", e.Ethereum = "1", e.EthereumHex = "0x1", e.Litecoin = "litecoin", e.LitecoinHex = "", e.Optimism = "10", e.OptimismHex = "0xa", e.Polygon = "137", e.PolygonHex = "0x89", e.THORChain = "thorchain-mainnet-v1", e.THORChainHex = "", e.THORChainStagenet = "thorchain-stagenet-v2", e))(An || {}), fi = /* @__PURE__ */ ((e) => (e.Arbitrum = "https://arb1.arbitrum.io/rpc", e.Avalanche = "https://node-router.thorswap.net/avalanche-c", e.Binance = "", e.BinanceSmartChain = "https://bsc-dataseed.binance.org", e.Bitcoin = "https://node-router.thorswap.net/bitcoin", e.BitcoinCash = "https://node-router.thorswap.net/bitcoin-cash", e.Cosmos = "https://node-router.thorswap.net/cosmos/rpc", e.Dogecoin = "https://node-router.thorswap.net/dogecoin", e.Ethereum = "https://node-router.thorswap.net/ethereum", e.Litecoin = "https://node-router.thorswap.net/litecoin", e.Optimism = "https://mainnet.optimism.io", e.Polygon = "https://polygon-rpc.com", e.THORChain = "https://rpc.thorswap.net", e.THORChainStagenet = "https://stagenet-rpc.ninerealms.com", e))(fi || {});
const Ht = Object.values(x), ji = Object.keys(x), vn = Ht.reduce(
  (e, n) => {
    const a = ji.find((o) => x[o] === n);
    return a && (e[n] = a), e;
  },
  {}
);
Ht.reduce(
  (e, n) => (e[n] = An[vn[n]], e),
  {}
);
Ht.reduce(
  (e, n) => (e[n] = fi[vn[n]], e),
  {}
);
Ht.reduce(
  (e, n) => (e[n] = An[`${vn[n]}Hex`], e),
  {}
);
var lt = /* @__PURE__ */ ((e) => (e.BOND = "BOND", e.DEPOSIT = "+", e.LEAVE = "LEAVE", e.THORNAME_REGISTER = "~", e.UNBOND = "UNBOND", e.WITHDRAW = "-", e.OPEN_LOAN = "$+", e.CLOSE_LOAN = "$-", e))(lt || {});
const er = (e, n, a = !1) => {
  if (a)
    return "Synth";
  switch (e) {
    case x.Bitcoin:
    case x.BitcoinCash:
    case x.Dogecoin:
    case x.Litecoin:
    case x.THORChain:
      return "Native";
    case x.Cosmos:
      return n === "ATOM" ? "Native" : "GAIA";
    case x.Binance:
      return n === x.Binance ? "Native" : "BEP2";
    case x.BinanceSmartChain:
      return n === x.Binance ? "Native" : "BEP20";
    case x.Ethereum:
      return n === x.Ethereum ? "Native" : "ERC20";
    case x.Avalanche:
      return n === x.Avalanche ? "Native" : "AVAX";
    case x.Polygon:
      return n === x.Polygon ? "Native" : "POLYGON";
    case x.Arbitrum:
      return [x.Ethereum, x.Arbitrum].includes(n) ? "Native" : "ARBITRUM";
    case x.Optimism:
      return [x.Ethereum, x.Optimism].includes(n) ? "Native" : "OPTIMISM";
    default:
      return e;
  }
}, wt = {
  prefix: "",
  decimalSeparator: ".",
  groupSeparator: ",",
  groupSize: 3,
  secondaryGroupSize: 0,
  fractionGroupSeparator: " ",
  fractionGroupSize: 0,
  suffix: ""
};
var Ut = /* @__PURE__ */ ((e) => (e[e.ROUND_DOWN = 0] = "ROUND_DOWN", e[e.ROUND_HALF_UP = 1] = "ROUND_HALF_UP", e[e.ROUND_UP = 2] = "ROUND_UP", e))(Ut || {}), dt = /* @__PURE__ */ ((e) => (e[e.BASE_AMOUNT = 0] = "BASE_AMOUNT", e[e.ASSET_AMOUNT = 1] = "ASSET_AMOUNT", e))(dt || {});
const cn = {
  0: Le.ROUND_DOWN,
  1: Le.ROUND_HALF_UP,
  2: Le.ROUND_UP
}, tr = {
  groupSeparator: "",
  decimalSeparator: "."
};
class C {
  constructor(n, a = 0, o) {
    K(this, "assetAmount"), K(this, "baseAmount"), K(this, "decimal"), this.decimal = o;
    const m = 10 ** o;
    a === 0 ? (this.baseAmount = new Le(n), this.assetAmount = this.baseAmount.dividedBy(m)) : (this.assetAmount = new Le(n), this.baseAmount = this.assetAmount.multipliedBy(m)), this.baseAmount = new Le(this.baseAmount.integerValue(Le.ROUND_DOWN));
  }
  static fromMidgard(n) {
    return new C(n || 0, 0, Z.THOR);
  }
  static fromBaseAmount(n, a) {
    return new C(n, 0, a);
  }
  static fromAssetAmount(n, a) {
    return new C(n, 1, a);
  }
  static fromNormalAmount(n) {
    return new C(n || 0, 1, 1);
  }
  static sorter(n, a) {
    if (n.decimal !== a.decimal)
      throw new Error("Decimal must be same");
    return n.assetAmount.minus(a.assetAmount).toNumber();
  }
  add(n) {
    return new C(
      this.assetAmount.plus(n.assetAmount),
      1,
      this.decimal
    );
  }
  sub(n) {
    return new C(
      this.assetAmount.minus(n.assetAmount),
      1,
      this.decimal
    );
  }
  mul(n) {
    return n instanceof C ? new C(
      this.assetAmount.multipliedBy(n.assetAmount),
      1,
      this.decimal
    ) : new C(this.assetAmount.multipliedBy(n), 1, this.decimal);
  }
  div(n) {
    return n instanceof C ? new C(
      this.assetAmount.dividedBy(n.assetAmount),
      1,
      this.decimal
    ) : new C(this.assetAmount.dividedBy(n), 1, this.decimal);
  }
  gte(n) {
    return n instanceof C ? this.assetAmount.isGreaterThanOrEqualTo(n.assetAmount) : this.assetAmount.isGreaterThanOrEqualTo(n);
  }
  gt(n) {
    return n instanceof C ? this.assetAmount.isGreaterThan(n.assetAmount) : this.assetAmount.isGreaterThan(n);
  }
  lte(n) {
    return n instanceof C ? this.assetAmount.isLessThanOrEqualTo(n.assetAmount) : this.assetAmount.isLessThanOrEqualTo(n);
  }
  lt(n) {
    return n instanceof C ? this.assetAmount.isLessThan(n.assetAmount) : this.assetAmount.isLessThan(n);
  }
  eq(n) {
    return n instanceof C ? this.assetAmount.isEqualTo(n.assetAmount) : this.assetAmount.isEqualTo(n);
  }
  toSignificant(n = 8, a = 8, o = wt, m = 0) {
    return this.toSignificantBigNumber(n, o, m).decimalPlaces(a).toFormat();
  }
  toFixedDecimal(n = 8, a = tr, o = 0) {
    if (!Number.isInteger(n))
      throw new Error(`${n} is not an integer.`);
    if (n <= 0)
      throw new Error(`${n} is not positive.`);
    return Le.config({ FORMAT: a }), new Le(this.assetAmount.toFixed(n, cn[o])).toFormat();
  }
  toFixed(n = 8, a = wt, o = 0) {
    return this.toFixedDecimal(n, a, o);
  }
  toAbbreviate(n = 2) {
    let a = this.assetAmount.toNumber();
    const o = ["", "K", "M", "B", "T", "Q", "Q", "s"];
    let m = 0;
    for (; a >= 1e3; )
      a /= 1e3, m++;
    return `${a.toFixed(n)}${m > 0 ? ` ${o[m]}` : ""}`;
  }
  toMidgard() {
    return new C(
      new Le(
        this.baseAmount.dividedBy(10 ** this.decimal).multipliedBy(10 ** Z.THOR).toFixed()
      ),
      0,
      Z.THOR
    );
  }
  toSignificantBigNumber(n = 8, a = wt, o = 0) {
    if (!Number.isInteger(n))
      throw new Error(`${n} is not an integer.`);
    if (n <= 0)
      throw new Error(`${n} is not positive.`);
    return Le.config({ FORMAT: a }), new Le(this.assetAmount.toPrecision(n, cn[o]));
  }
}
const Kr = (e, n = 8, a = 0) => (Le.config({ FORMAT: wt }), new Le(e.toFixed(n, cn[a])).toFormat()), nr = ({
  liquidityUnits: e,
  poolUnits: n,
  runeDepth: a
}) => C.fromBaseAmount(a, Z.THOR).mul(e).div(n), ir = ({
  liquidityUnits: e,
  poolUnits: n,
  assetDepth: a
}) => C.fromBaseAmount(a, Z.THOR).mul(e).div(n), rr = ({
  liquidityUnits: e,
  poolUnits: n,
  runeDepth: a
}) => {
  const o = C.fromMidgard(e), m = C.fromBaseAmount(n, Z.THOR), f = C.fromBaseAmount(a, Z.THOR), A = o.mul(f), v = m.mul(m).mul(2), O = m.mul(o).mul(2), b = o.mul(o), D = m.mul(m).mul(m);
  return A.mul(v.sub(O).add(b)).div(D);
}, ar = ({
  liquidityUnits: e,
  poolUnits: n,
  assetDepth: a
}) => {
  const o = C.fromMidgard(e), m = C.fromBaseAmount(n, Z.THOR), f = C.fromBaseAmount(a, Z.THOR), A = o.mul(f), v = m.mul(m).mul(2), O = m.mul(o).mul(2), b = o.mul(o), D = A.mul(v.sub(O).add(b)), U = m.mul(m).mul(m);
  return D.div(U);
}, Zr = ({
  percent: e,
  runeDepth: n,
  liquidityUnits: a,
  poolUnits: o
}) => rr({ runeDepth: n, liquidityUnits: a, poolUnits: o }).mul(e), Qr = ({
  percent: e,
  assetDepth: n,
  liquidityUnits: a,
  poolUnits: o
}) => ar({ assetDepth: n, liquidityUnits: a, poolUnits: o }).mul(e), Jr = ({
  liquidityUnits: e,
  poolUnits: n,
  runeDepth: a,
  assetDepth: o,
  percent: m
}) => ({
  assetAmount: ir({ liquidityUnits: e, poolUnits: n, assetDepth: o }).mul(m),
  runeAmount: nr({ liquidityUnits: e, poolUnits: n, runeDepth: a }).mul(m)
}), jr = ({
  runeDepth: e,
  poolUnits: n,
  assetDepth: a,
  liquidityUnits: o,
  runeAmount: m,
  assetAmount: f
}) => {
  const A = C.fromBaseAmount(e, Z.THOR), v = C.fromBaseAmount(a, Z.THOR), O = C.fromBaseAmount(n, Z.THOR), b = C.fromBaseAmount(m, Z.THOR), D = C.fromBaseAmount(f, Z.THOR), U = b.mul(v), j = D.mul(A), Be = b.mul(D), ee = A.mul(v), ke = O.mul(U.add(j.add(Be.mul(2)))), te = U.add(j.add(ee.mul(2))), He = ke.div(te), R = C.fromMidgard(o).add(He);
  if (He.assetAmount.toNumber() === 0)
    return R.div(O).assetAmount.toNumber();
  const it = O.add(R);
  return R.div(it).assetAmount.toNumber();
}, ea = ({
  runeAmount: e,
  assetAmount: n,
  runeDepth: a,
  assetDepth: o
}) => {
  const m = C.fromBaseAmount(a, Z.THOR), f = C.fromBaseAmount(o, Z.THOR), A = C.fromBaseAmount(n, Z.THOR), v = C.fromBaseAmount(e, Z.THOR), O = A.mul(m).sub(f.mul(v)), b = f.mul(v).add(m.mul(f));
  return O.div(b).assetAmount.absoluteValue().toNumber();
}, sr = ({
  symbol: e,
  ticker: n,
  chain: a
}) => a === "ETH" && n !== "ETH" ? `${n}-${e.slice(-3)}` : e, Ye = (e, n) => {
  switch (e) {
    case lt.LEAVE:
    case lt.BOND: {
      const { address: a } = n;
      return `${e}:${a}`;
    }
    case lt.UNBOND: {
      const { address: a, unbondAmount: o } = n;
      return `${e}:${a}:${o * 10 ** 8}`;
    }
    case lt.THORNAME_REGISTER: {
      const { name: a, chain: o, address: m, owner: f } = n;
      return `${e}:${a}:${o}:${m}${f ? `:${f}` : ""}`;
    }
    case lt.DEPOSIT: {
      const { chain: a, symbol: o, address: m, singleSide: f } = n;
      return f ? `${e}:${a}/${o}::t:0` : `${e}:${a}.${o}:${m || ""}:t:0`;
    }
    case lt.WITHDRAW: {
      const { chain: a, ticker: o, symbol: m, basisPoints: f, targetAssetString: A, singleSide: v } = n, O = !v && A ? `:${A}` : "", b = sr({ chain: a, symbol: m, ticker: o });
      return `${e}:${a}${v ? "/" : "."}${b}:${f}${O}`;
    }
    case lt.OPEN_LOAN:
    case lt.CLOSE_LOAN: {
      const { asset: a, address: o } = n;
      return `${e}:${a}:${o}`;
    }
    default:
      return "";
  }
}, or = (e, n) => e === x.Bitcoin ? "Bitcoin" : e === x.Dogecoin ? "Dogecoin" : e === x.Litecoin ? "Litecoin" : e === x.BitcoinCash ? "Bitcoin Cash" : e === x.Ethereum && n === "ETH" ? "Ethereum" : n, ta = (e) => {
  if (e < 0)
    throw new Error("Invalid number of year");
  return 10 + e;
}, na = (e) => {
  if (e.length > 30)
    return !1;
  const n = /^[a-zA-Z0-9+_-]+$/g;
  return !!e.match(n);
}, yn = class Tn {
  constructor(n, a, o = !1, m) {
    K(this, "chain"), K(this, "symbol"), K(this, "ticker"), K(this, "type"), K(this, "network"), K(this, "name"), K(this, "decimal"), K(this, "isSynth", !1), K(this, "L1Chain"), K(this, "setDecimal", (f) => {
      this.decimal = f || Z[this.chain] || Z.THOR;
    }), this.chain = n, this.symbol = a.toUpperCase(), this.ticker = m || a.toUpperCase().split("-")[0], this.type = er(n, this.ticker, o), this.name = o ? `Synth ${this.ticker}` : this.ticker, this.network = or(n, this.ticker), this.decimal = o ? Z.THOR : Z[n], this.isSynth = o, this.L1Chain = o ? x.THORChain : n;
  }
  static fromAssetString(n) {
    var a;
    if (!n)
      return null;
    const o = n.includes("/"), [m, ...f] = n.split(o ? "/" : "."), A = f.join("."), v = (a = A == null ? void 0 : A.split("-")) == null ? void 0 : a[0];
    return m && A && v ? new Tn(m, A, o) : null;
  }
  getAssetObj() {
    if (this.isSynth) {
      const n = `${this.chain.toLowerCase()}/${this.symbol.toLowerCase()}`;
      return {
        chain: x.THORChain,
        symbol: n,
        ticker: n
      };
    }
    return { chain: this.chain, symbol: this.symbol, ticker: this.ticker };
  }
  /**
   * convert asset entity to string
   * @returns L1 asset -> btc.btc, Synth asset -> btc/btc
   */
  toString() {
    return `${this.chain}${this.isSynth ? "/" : "."}${this.symbol}`;
  }
  toURLEncoded() {
    return `${this.isSynth ? "THOR." : ""}${this.chain}.${this.symbol}`;
  }
  // full compare chain, symbol, synth
  eq(n) {
    return this.chain === n.chain && this.symbol.toUpperCase() === n.symbol.toUpperCase() && this.ticker.toUpperCase() === n.ticker.toUpperCase() && this.isSynth === n.isSynth;
  }
  // compare chain, symbol but not synth
  shallowEq(n) {
    return this.chain === n.chain && this.symbol.toUpperCase() === n.symbol.toUpperCase() && this.ticker.toUpperCase() === n.ticker.toUpperCase();
  }
  isRUNE() {
    return this.eq(_t(x.THORChain));
  }
  identifier() {
    return `${this.chain}.${this.symbol}`;
  }
  toSynth() {
    return this.isSynth ? this : new Tn(x.THORChain, `${this.chain}/${this.symbol}`, !0);
  }
};
K(yn, "decodeFromURL", (e) => {
  var n, a, o;
  let m = e.toUpperCase();
  return m.startsWith("THOR.") && ((n = m.split("THOR.")) == null ? void 0 : n[1]) !== "RUNE" && (m = (o = (a = m.split("THOR.")) == null ? void 0 : a[1]) == null ? void 0 : o.replace(".", "/")), yn.fromAssetString(m);
});
let Xe = yn;
const ur = "THOR-0xa5f2211B9b8170F694421f2046281775E8468044", lr = "VTHOR-0x815C23eCA83261b6Ec689b60Cc4a58b54BC24D8D", et = {}, _t = (e, n = !1) => {
  if (et[e])
    return et[e];
  switch (e) {
    case x.Avalanche:
    case x.Binance:
    case x.Bitcoin:
    case x.BitcoinCash:
    case x.Dogecoin:
    case x.Ethereum:
    case x.Litecoin: {
      const a = new Xe(e, e, n);
      return et[e] = a, a;
    }
    case x.Optimism:
    case x.Arbitrum: {
      const a = new Xe(e, x.Ethereum, n);
      return a.setDecimal(18), et[e] = a, a;
    }
    case x.BinanceSmartChain: {
      const a = new Xe(e, x.Binance, n);
      return a.setDecimal(18), et[e] = a, a;
    }
    case x.Polygon: {
      const a = new Xe(e, e, n);
      return a.setDecimal(18), et[e] = a, a;
    }
    case x.Cosmos: {
      const a = new Xe(e, Tt.ATOM, n, Tt.ATOM);
      return et[e] = a, a;
    }
    case x.THORChain: {
      const a = new Xe(x.THORChain, Tt.RUNE, n, Tt.RUNE);
      return et[e] = a, a;
    }
    case "USD": {
      const a = new Xe(x.THORChain, "USD-USD", n, "USD-USD");
      return et[e] = a, a;
    }
    case "ETH_THOR": {
      const a = new Xe(x.Ethereum, ur, n);
      return a.setDecimal(18), et[e] = a, a;
    }
    case "ETH_VTHOR": {
      const a = new Xe(x.Ethereum, lr, n);
      return a.setDecimal(18), et[e] = a, a;
    }
    default:
      return new Xe(x.THORChain, Tt.RUNE, n, Tt.RUNE);
  }
}, Qn = (e) => e.eq(_t(e.chain)), Rt = (e, n) => n.find((a) => e.shallowEq(a.asset));
class pr extends C {
  constructor({
    baseAsset: n,
    quoteAsset: a,
    unitPrice: o,
    pools: m,
    priceAmount: f
  }) {
    const A = C.fromAssetAmount(
      f ? f.assetAmount : 1,
      n.decimal
    );
    if (super(A.assetAmount, dt.ASSET_AMOUNT, n.decimal), K(this, "baseAsset"), K(this, "quoteAsset"), K(this, "unitPrice"), K(this, "price"), K(this, "amount"), this.amount = A, this.baseAsset = n, this.quoteAsset = a, o !== void 0)
      this.unitPrice = o, this.price = A.assetAmount.multipliedBy(o);
    else {
      if (!m)
        throw new Error("Pools must be provided if unitPrice omitted");
      if (this.unitPrice = new Le(0), a)
        if (n.isRUNE() && !a.isRUNE()) {
          const v = Rt(a, m);
          v && (this.unitPrice = v.runePriceInAsset.assetAmount);
        } else if (!n.isRUNE() && a.isRUNE()) {
          const v = Rt(n, m);
          v && (this.unitPrice = v.assetPriceInRune.assetAmount);
        } else if (!n.isRUNE() && !a.isRUNE()) {
          const v = Rt(n, m), O = Rt(a, m);
          v && O && (this.unitPrice = v.assetPriceInRune.div(
            O.assetPriceInRune
          ).assetAmount);
        } else
          this.unitPrice = new Le(1);
      else if (n.isRUNE()) {
        const v = m == null ? void 0 : m[0];
        v && (this.unitPrice = v.runePriceInAsset.mul(v.assetUSDPrice).assetAmount);
      } else {
        const v = Rt(n, m);
        v && (this.unitPrice = v.assetUSDPrice.assetAmount);
      }
      this.price = this.unitPrice.multipliedBy(A.assetAmount);
    }
  }
  raw() {
    return this.price;
  }
  invert() {
    return new Le(1).dividedBy(this.raw());
  }
  toCurrencyFormat(n = 8, a = !0) {
    var o;
    const m = a ? this.toAbbreviateRaw(n) : this.toFixedRaw(n);
    return !this.quoteAsset || this.quoteAsset.ticker === "USD" ? `$${m}` : `${m} ${(o = this.quoteAsset) == null ? void 0 : o.ticker}`;
  }
  toAbbreviateRaw(n = 2) {
    return C.fromAssetAmount(this.price, 8).toAbbreviate(n);
  }
  toFixedRaw(n = 8, a = wt, o = Ut.ROUND_DOWN) {
    return C.fromAssetAmount(this.price, 8).toFixed(n, a, o);
  }
  toFixedInverted(n = 8, a = wt, o = Ut.ROUND_DOWN) {
    return C.fromAssetAmount(this.invert(), 8).toFixed(n, a, o);
  }
}
class st extends C {
  constructor(n, a) {
    super(a.assetAmount, dt.ASSET_AMOUNT, a.decimal), K(this, "asset"), K(this, "amount"), this.asset = n, this.amount = new C(a.assetAmount, dt.ASSET_AMOUNT, a.decimal);
  }
  add(n) {
    if (!this.asset.shallowEq(n.asset))
      throw new Error("asset must be same");
    return new st(this.asset, this.amount.add(n.amount));
  }
  sub(n) {
    if (!this.asset.shallowEq(n.asset))
      throw new Error("asset must be same");
    return new st(this.asset, this.amount.sub(n.amount));
  }
  mul(n) {
    let a;
    return n instanceof C ? a = new C(
      this.assetAmount.multipliedBy(n.assetAmount),
      dt.ASSET_AMOUNT,
      this.decimal
    ) : a = new C(
      this.assetAmount.multipliedBy(n),
      dt.ASSET_AMOUNT,
      this.decimal
    ), new st(this.asset, a);
  }
  div(n) {
    let a;
    return n instanceof C ? a = new C(
      this.assetAmount.dividedBy(n.assetAmount),
      dt.ASSET_AMOUNT,
      this.decimal
    ) : a = new C(this.assetAmount.dividedBy(n), dt.ASSET_AMOUNT, this.decimal), new st(this.asset, a);
  }
  toCurrencyFormat({
    significantDigits: n,
    format: a,
    rounding: o
  } = {
    significantDigits: 6,
    format: wt,
    rounding: Ut.ROUND_DOWN
  }, m = !1) {
    const f = super.toSignificant(n, 8, a, o);
    return m ? `${this.asset.ticker} ${f}` : `${f} ${this.asset.ticker}`;
  }
  totalPriceIn(n, a) {
    return new pr({
      baseAsset: this.asset,
      quoteAsset: n,
      pools: a,
      priceAmount: C.fromAssetAmount(this.assetAmount, this.decimal)
    });
  }
}
const Dt = (e) => {
  const n = _t(e), a = [x.Bitcoin, x.Litecoin, x.BitcoinCash].includes(e) ? (
    // 10001 satoshi
    10001
  ) : [x.Dogecoin].includes(e) ? (
    // 1 DOGE
    100000001
  ) : [x.Avalanche, x.Ethereum, x.BinanceSmartChain].includes(e) ? (
    //  10 gwei
    10 * 10 ** 9
  ) : e === x.THORChain ? (
    // 0 RUNE
    0
  ) : 1;
  return new st(n, C.fromBaseAmount(a, n.decimal));
};
class hi {
  constructor(n, a, o, m) {
    K(this, "asset"), K(this, "runeDepth"), K(this, "assetDepth"), K(this, "assetUSDPrice"), K(this, "detail"), this.asset = n, this.runeDepth = a, this.assetDepth = o, this.detail = m, this.assetUSDPrice = C.fromAssetAmount(m.assetPriceUSD, Z.THOR);
  }
  static fromPoolData(n) {
    const { asset: a, runeDepth: o, assetDepth: m } = n, f = Xe.fromAssetString(a);
    if (f && o && m) {
      const A = C.fromBaseAmount(o, Z.THOR), v = C.fromBaseAmount(m, Z.THOR);
      return new hi(f, A, v, n);
    }
    return null;
  }
  get assetPriceInRune() {
    return this.runeDepth.div(this.assetDepth);
  }
  get runePriceInAsset() {
    return this.assetDepth.div(this.runeDepth);
  }
}
const dr = [
  {
    inputs: [{ internalType: "address", name: "_ttp", type: "address" }],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tcRouter", type: "address" },
      { internalType: "address", name: "tcVault", type: "address" },
      { internalType: "string", name: "tcMemo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "router", type: "address" },
      { internalType: "bytes", name: "data", type: "bytes" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], fr = [
  {
    inputs: [
      { internalType: "address", name: "_ttp", type: "address" },
      { internalType: "address", name: "_weth", type: "address" },
      { internalType: "address", name: "_swapRouter", type: "address" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "address", name: "from", type: "address" },
      { indexed: !1, internalType: "address", name: "token", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "uint256", name: "out", type: "uint256" },
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "vault", type: "address" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "SwapIn",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "address", name: "token", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" }
    ],
    name: "SwapOut",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address", name: "vault", type: "address" },
      { internalType: "string", name: "memo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" }
    ],
    name: "swapOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "swapRouter",
    outputs: [{ internalType: "contract IWoofi", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "weth",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], hr = [
  {
    inputs: [{ internalType: "address", name: "_ttp", type: "address" }],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "address", name: "from", type: "address" },
      { indexed: !1, internalType: "address", name: "token", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "uint256", name: "out", type: "uint256" },
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "vault", type: "address" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "SwapIn",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address", name: "vault", type: "address" },
      { internalType: "string", name: "memo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "swapRouter", type: "address" },
      { internalType: "bytes", name: "data", type: "bytes" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], mr = [
  {
    inputs: [{ internalType: "address", name: "_ttp", type: "address" }],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tcRouter", type: "address" },
      { internalType: "address", name: "tcVault", type: "address" },
      { internalType: "string", name: "tcMemo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "router", type: "address" },
      { internalType: "bytes", name: "data", type: "bytes" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], cr = [
  {
    inputs: [
      { internalType: "address", name: "_ttp", type: "address" },
      { internalType: "address", name: "_wbnb", type: "address" },
      { internalType: "address", name: "_swapRouter", type: "address" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "address", name: "from", type: "address" },
      { indexed: !1, internalType: "address", name: "token", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "uint256", name: "out", type: "uint256" },
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "vault", type: "address" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "SwapIn",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "address", name: "token", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" }
    ],
    name: "SwapOut",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address", name: "vault", type: "address" },
      { internalType: "string", name: "memo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" }
    ],
    name: "swapOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "swapRouter",
    outputs: [{ internalType: "contract IPancakeRouterV2", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "wbnb",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], yr = [
  {
    inputs: [
      { internalType: "address", name: "_ttp", type: "address" },
      { internalType: "address", name: "_weth", type: "address" },
      { internalType: "address", name: "_swapRouter", type: "address" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tcRouter", type: "address" },
      { internalType: "address", name: "tcVault", type: "address" },
      { internalType: "string", name: "tcMemo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" }
    ],
    name: "swapOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "swapRouter",
    outputs: [{ internalType: "contract IUniswapRouterV2AVAX", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "weth",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], Tr = [
  {
    inputs: [
      { internalType: "address", name: "_ttp", type: "address" },
      { internalType: "address", name: "_weth", type: "address" },
      { internalType: "address", name: "_swapRouter", type: "address" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tcRouter", type: "address" },
      { internalType: "address", name: "tcVault", type: "address" },
      { internalType: "string", name: "tcMemo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" }
    ],
    name: "swapOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "swapRouter",
    outputs: [{ internalType: "contract IUniswapRouterV2", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "weth",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], _r = [
  {
    inputs: [
      { internalType: "address", name: "_ttp", type: "address" },
      { internalType: "address", name: "_weth", type: "address" },
      { internalType: "address", name: "_swapRouter", type: "address" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tcRouter", type: "address" },
      { internalType: "address", name: "tcVault", type: "address" },
      { internalType: "string", name: "tcMemo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" }
    ],
    name: "swapOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "swapRouter",
    outputs: [{ internalType: "contract IUniswapRouterV2AVAX", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "weth",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], wr = [
  {
    inputs: [
      { internalType: "address", name: "_ttp", type: "address" },
      { internalType: "address", name: "_weth", type: "address" },
      { internalType: "address", name: "_swapRouter", type: "address" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tcRouter", type: "address" },
      { internalType: "address", name: "tcVault", type: "address" },
      { internalType: "string", name: "tcMemo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" }
    ],
    name: "swapOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "swapRouter",
    outputs: [{ internalType: "contract IUniswapRouterV2", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "weth",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], gr = [
  {
    inputs: [
      { internalType: "address", name: "_ttp", type: "address" },
      { internalType: "address", name: "_weth", type: "address" },
      { internalType: "address", name: "_swapRouter", type: "address" },
      { internalType: "address", name: "_legToken", type: "address" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "legToken",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tcRouter", type: "address" },
      { internalType: "address", name: "tcVault", type: "address" },
      { internalType: "string", name: "tcMemo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" }
    ],
    name: "swapOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "swapRouter",
    outputs: [{ internalType: "contract IUniswapRouterV2", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "weth",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], Er = [
  {
    inputs: [
      { internalType: "address", name: "_ttp", type: "address" },
      { internalType: "address", name: "_weth", type: "address" },
      { internalType: "address", name: "_swapRouter", type: "address" },
      { internalType: "uint24", name: "_poolFee", type: "uint24" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "poolFee",
    outputs: [{ internalType: "uint24", name: "", type: "uint24" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tcRouter", type: "address" },
      { internalType: "address", name: "tcVault", type: "address" },
      { internalType: "string", name: "tcMemo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" }
    ],
    name: "swapOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "swapRouter",
    outputs: [{ internalType: "contract IUniswapRouterV3", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "weth",
    outputs: [{ internalType: "contract IWETH9", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], Ar = [
  {
    inputs: [
      { internalType: "address", name: "_ttp", type: "address" },
      { internalType: "address", name: "_weth", type: "address" },
      { internalType: "address", name: "_swapRouter", type: "address" },
      { internalType: "uint24", name: "_poolFee", type: "uint24" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "poolFee",
    outputs: [{ internalType: "uint24", name: "", type: "uint24" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tcRouter", type: "address" },
      { internalType: "address", name: "tcVault", type: "address" },
      { internalType: "string", name: "tcMemo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" }
    ],
    name: "swapOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "swapRouter",
    outputs: [{ internalType: "contract IUniswapRouterV3", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "weth",
    outputs: [{ internalType: "contract IWETH9", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], vr = [
  {
    inputs: [
      { internalType: "address", name: "_ttp", type: "address" },
      { internalType: "address", name: "_weth", type: "address" },
      { internalType: "address", name: "_swapRouter", type: "address" },
      { internalType: "uint24", name: "_poolFee", type: "uint24" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "poolFee",
    outputs: [{ internalType: "uint24", name: "", type: "uint24" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tcRouter", type: "address" },
      { internalType: "address", name: "tcVault", type: "address" },
      { internalType: "string", name: "tcMemo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" }
    ],
    name: "swapOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "swapRouter",
    outputs: [{ internalType: "contract IUniswapRouterV3", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "weth",
    outputs: [{ internalType: "contract IWETH9", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], Rr = [
  {
    inputs: [
      { internalType: "address", name: "_ttp", type: "address" },
      { internalType: "address", name: "_weth", type: "address" },
      { internalType: "address", name: "_swapRouter", type: "address" },
      { internalType: "uint24", name: "_poolFee", type: "uint24" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !1, internalType: "uint256", name: "fee", type: "uint256" },
      { indexed: !1, internalType: "address", name: "feeRecipient", type: "address" }
    ],
    name: "FeeSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !1, internalType: "bool", name: "active", type: "bool" }
    ],
    name: "OwnerSet",
    type: "event"
  },
  {
    inputs: [],
    name: "fee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "feeRecipient",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "owners",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "poolFee",
    outputs: [{ internalType: "uint24", name: "", type: "uint24" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "_fee", type: "uint256" },
      { internalType: "address", name: "_feeRecipient", type: "address" }
    ],
    name: "setFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "bool", name: "active", type: "bool" }
    ],
    name: "setOwner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "tcRouter", type: "address" },
      { internalType: "address", name: "tcVault", type: "address" },
      { internalType: "string", name: "tcMemo", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" }
    ],
    name: "swapIn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" }
    ],
    name: "swapOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "swapRouter",
    outputs: [{ internalType: "contract IUniswapRouterV3", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenTransferProxy",
    outputs: [
      { internalType: "contract TSAggregatorTokenTransferProxy", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "weth",
    outputs: [{ internalType: "contract IWETH9", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
], mi = {
  ["0x7C38b8B2efF28511ECc14a621e263857Fb5771d3".toLowerCase()]: dr,
  ["0xB6fA6f1DcD686F4A573Fd243a6FABb4ba36Ba98c".toLowerCase()]: hr,
  ["0xd31f7e39afECEc4855fecc51b693F9A0Cec49fd2".toLowerCase()]: mr
}, Mr = {
  ...mi,
  // AVAX
  ["0x942c6dA485FD6cEf255853ef83a149d43A73F18a".toLowerCase()]: yr,
  ["0x5505BE604dFA8A1ad402A71f8A357fba47F9bf5a".toLowerCase()]: fr,
  ["0x3b7DbdD635B99cEa39D3d95Dbd0217F05e55B212".toLowerCase()]: _r,
  // BSC
  ["0x30912B38618D3D37De3191A4FFE982C65a9aEC2E".toLowerCase()]: cr,
  // ETH
  ["0xbf365e79aA44A2164DA135100C57FDB6635ae870".toLowerCase()]: Tr,
  ["0x86904Eb2b3c743400D03f929F2246EfA80B91215".toLowerCase()]: wr,
  ["0x3660dE6C56cFD31998397652941ECe42118375DA".toLowerCase()]: gr,
  ["0xBd68cBe6c247e2c3a0e36B8F0e24964914f26Ee8".toLowerCase()]: Er,
  ["0xe4ddca21881bac219af7f217703db0475d2a9f02".toLowerCase()]: Ar,
  ["0x11733abf0cdb43298f7e949c930188451a9a9ef2".toLowerCase()]: vr,
  ["0xb33874810e5395eb49d8bd7e912631db115d5a03".toLowerCase()]: Rr
}, Or = "units/5.7.0", Nr = new $(Or), Sr = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function br(e, n) {
  if (typeof e != "string" && Nr.throwArgumentError("value must be a string", "value", e), typeof n == "string") {
    const a = Sr.indexOf(n);
    a !== -1 && (n = 3 * a);
  }
  return at(e, n ?? 18);
}
const Ir = ({
  evmChain: e,
  transaction: { data: n, from: a, to: o, value: m }
}) => ({
  data: n,
  from: a,
  to: o.toLowerCase(),
  chainId: parseInt(Wi[e]),
  value: gt(m) ? parseInt(m, 16) > 0 ? m : void 0 : br(m, "wei").toHexString()
}), xr = ({
  streamSwap: e,
  recipient: n,
  callData: { fromAsset: a, amountIn: o, memo: m, memoStreamingSwap: f }
}) => {
  const A = Xe.fromAssetString(a);
  if (!A)
    throw new F("core_swap_asset_not_recognized");
  const v = e && f || m;
  return {
    assetAmount: new st(A, new C(o, 0, A.decimal)),
    memo: v == null ? void 0 : v.replace("{recipientAddress}", n)
  };
}, Cr = ({
  streamSwap: e,
  contractAddress: n,
  recipient: a,
  toChecksumAddress: o,
  calldata: {
    amount: m,
    amountOutMin: f = "",
    data: A = "",
    deadline: v,
    memo: O,
    router: b,
    memoStreamingSwap: D,
    tcMemo: U,
    tcRouter: j,
    tcVault: Be,
    vault: ee,
    token: ke
  }
}) => {
  const te = !!mi[n.toLowerCase()];
  if (te && !b)
    throw new Error("Router is required on calldata for swapIn with GenericContract");
  const He = U || O;
  let R = e && D || He;
  if (R = R.replace("::t:30", ""), !Be && !ee)
    throw new Error("TC Vault is required on calldata");
  if (!j && !b)
    throw new Error("TC Router is required on calldata");
  if (!R)
    throw new Error("TC Memo is required on calldata");
  if (!ke)
    throw new Error("Token is required on calldata");
  const it = [
    // v2 contracts don't have tcVault, tcRouter, tcMemo but vault, router, memo
    o(j || b),
    o(Be || ee),
    R.replace("{recipientAddress}", a),
    o(ke),
    m
  ], mt = te ? [o(b), A, v] : [f, v];
  return [...it, ...mt];
}, Dr = ({ symbol: e, chain: n }) => {
  var f, A, v, O;
  const a = e.includes("/"), o = (A = a ? (f = e.split("/")) == null ? void 0 : f[0] : n) == null ? void 0 : A.toUpperCase(), m = (O = a ? (v = e.split("/")) == null ? void 0 : v[1] : e) == null ? void 0 : O.toUpperCase();
  return new Xe(o, m, a);
}, Pr = (e) => {
  const n = e ? bt.ThornodeStagenet : bt.ThornodeMainnet;
  return pi(`${n}/thorchain/inbound_addresses`);
}, Br = (e) => {
  const n = e ? bt.ThornodeStagenet : bt.ThornodeMainnet;
  return pi(`${n}/thorchain/mimir`);
}, Jn = () => Object.values(S).reduce(
  (e, n) => (e[n] = null, e),
  {}
), Ur = ({ chain: e, txHash: n }) => {
  const a = li[e];
  switch (e) {
    case S.Binance:
    case S.Bitcoin:
    case S.BitcoinCash:
    case S.THORChain:
      return `${a}/tx/${n}`;
    case S.Arbitrum:
    case S.Avalanche:
    case S.BinanceSmartChain:
    case S.Ethereum:
    case S.Optimism:
    case S.Polygon:
      return `${a}/tx/${n.startsWith("0x") ? n : `0x${n}`}`;
    case S.Cosmos:
      return `${a}/transactions/${n}`;
    case S.Dogecoin:
      return `${a}/transaction/${n.toLowerCase()}`;
    case S.Litecoin:
      return `${a}/${n}`;
    default:
      throw new Error(`Unsupported chain: ${e}`);
  }
}, Lr = ({ chain: e, address: n }) => {
  const a = li[e];
  switch (e) {
    case S.Arbitrum:
    case S.Avalanche:
    case S.Binance:
    case S.BinanceSmartChain:
    case S.Bitcoin:
    case S.BitcoinCash:
    case S.Dogecoin:
    case S.Ethereum:
    case S.Optimism:
    case S.Polygon:
    case S.THORChain:
      return `${a}/address/${n}`;
    case S.Cosmos:
      return `${a}/account/${n}`;
    case S.Litecoin:
      return `${a}/${n}`;
    default:
      throw new Error(`Unsupported chain: ${e}`);
  }
};
class ia {
  constructor({ stagenet: n } = {}) {
    L(this, "connectedChains", Jn());
    L(this, "connectedWallets", Jn());
    L(this, "stagenet", !1);
    L(this, "getAddress", (n) => {
      var a;
      return ((a = this.connectedChains[n]) == null ? void 0 : a.address) || "";
    });
    L(this, "getExplorerTxUrl", (n, a) => Ur({ chain: n, txHash: a }));
    L(this, "getWallet", (n) => this.connectedWallets[n]);
    L(this, "getExplorerAddressUrl", (n, a) => Lr({ chain: n, address: a }));
    L(this, "getBalance", async (n, a) => {
      var o, m;
      return a ? ((m = await this.getWalletByChain(n)) == null ? void 0 : m.balance) || [] : ((o = this.connectedChains[n]) == null ? void 0 : o.balance) || [];
    });
    L(this, "swap", async ({ streamSwap: n, recipient: a, route: o, feeOptionKey: m }) => {
      var v, O;
      const { quoteMode: f } = o.meta, A = f.startsWith("ERC20-") ? S.Ethereum : f.startsWith("ARC20-") ? S.Avalanche : S.BinanceSmartChain;
      if (!o.complete)
        throw new F("core_swap_route_not_complete");
      try {
        if (Ui.includes(f)) {
          const b = this.connectedWallets[A];
          if (!(b != null && b.sendTransaction))
            throw new F("core_wallet_connection_not_found");
          const D = n ? (v = o == null ? void 0 : o.streamingSwap) == null ? void 0 : v.transaction : o == null ? void 0 : o.transaction;
          if (!D)
            throw new F("core_swap_route_transaction_not_found");
          return b.sendTransaction(
            Ir({ transaction: D, evmChain: A }),
            m
          );
        }
        if (Hi.includes(f)) {
          const b = Xe.fromAssetString(o.calldata.fromAsset);
          if (!b)
            throw new F("core_swap_asset_not_recognized");
          const { address: D } = await this._getInboundDataByChain(b.L1Chain);
          return this.deposit({
            ...xr({ recipient: a, streamSwap: n, callData: o.calldata }),
            feeOptionKey: m,
            router: o.contract,
            recipient: D
          });
        }
        if (Li.includes(f)) {
          const { calldata: b, contract: D } = o;
          if (!D)
            throw new F("core_swap_contract_not_found");
          const U = this.connectedWallets[A], j = this.getAddress(A);
          if (!(U != null && U.sendTransaction) || !j)
            throw new F("core_wallet_connection_not_found");
          const { getProvider: Be, toChecksumAddress: ee } = await import("@pioneer-platform/toolbox-evm"), ke = Be(A), te = Mr[D.toLowerCase()];
          if (!te)
            throw new F("core_swap_contract_not_supported", { contractAddress: D });
          const R = await ((O = U.createContract) == null ? void 0 : O.call(U, D, te, ke)).populateTransaction.swapIn(
            ...Cr({
              streamSwap: n,
              toChecksumAddress: ee,
              contractAddress: D,
              recipient: a,
              calldata: b
            }),
            { from: j }
          );
          return U.sendTransaction(R, m);
        }
        throw new F("core_swap_quote_mode_not_supported", { quoteMode: f });
      } catch (b) {
        throw new F("core_swap_transaction_error", b);
      }
    });
    L(this, "approveAsset", (n, a) => this._approve({ asset: n, amount: a }, "approve"));
    L(this, "approveAssetForContract", (n, a, o) => this._approve({ asset: n, amount: o, contractAddress: a }, "approve"));
    L(this, "getWalletByChain", async (n) => {
      var f, A;
      const a = this.getAddress(n);
      if (!a)
        return null;
      const m = (await ((f = this.getWallet(n)) == null ? void 0 : f.getBalance(a)) || [
        { asset: _t(n), amount: At(0, oi[n]) }
      ]).map(
        ({ amount: v, asset: O }) => new st(
          Dr(O),
          new C(v.amount().toString() || "0", dt.BASE_AMOUNT, v.decimal)
        )
      );
      return this.connectedChains[n] = {
        address: a,
        balance: m,
        walletType: (A = this.connectedChains[n]) == null ? void 0 : A.walletType
      }, { ...this.connectedChains[n] || {}, balance: m };
    });
    L(this, "isAssetApproved", (n, a) => this._approve({ asset: n, amount: a }, "checkOnly"));
    L(this, "isAssetApprovedForContract", (n, a, o) => this._approve({ asset: n, amount: o, contractAddress: a }, "checkOnly"));
    L(this, "validateAddress", ({ address: n, chain: a }) => {
      var o, m;
      return (m = (o = this.getWallet(a)) == null ? void 0 : o.validateAddress) == null ? void 0 : m.call(o, n);
    });
    L(this, "transfer", async (n) => {
      const a = n.assetAmount.asset.L1Chain, o = this.connectedWallets[a];
      if (!o)
        throw new F("core_wallet_connection_not_found");
      const m = this._prepareTxParams(n);
      try {
        return await o.transfer(m);
      } catch (f) {
        throw new F("core_swap_transaction_error", f);
      }
    });
    L(this, "deposit", async ({
      assetAmount: n,
      recipient: a,
      router: o,
      ...m
    }) => {
      const f = n.asset.L1Chain, A = this.connectedWallets[f];
      if (!A)
        throw new F("core_wallet_connection_not_found");
      const v = this._prepareTxParams({ assetAmount: n, recipient: a, router: o, ...m });
      try {
        switch (f) {
          case S.THORChain:
            return await (a === "" ? A.deposit(v) : A.transfer(v));
          case S.Ethereum:
          case S.BinanceSmartChain:
          case S.Avalanche: {
            const { getBigNumberFrom: O, getChecksumAddressFromAsset: b } = await import("@pioneer-platform/toolbox-evm"), { asset: D } = n, U = f === S.Avalanche ? Ci : f === S.BinanceSmartChain ? Di : xi;
            return await A.call({
              abi: U,
              contractAddress: o || (await this._getInboundDataByChain(f)).router,
              funcName: "depositWithExpiry",
              funcParams: [
                a,
                b(D, D == null ? void 0 : D.chain),
                v.amount.amount().toString(),
                v.memo,
                (/* @__PURE__ */ new Date()).setMinutes((/* @__PURE__ */ new Date()).getMinutes() + 10)
              ],
              txOverrides: {
                from: v.from,
                value: O(
                  Qn(n.asset) ? v.amount.amount().toString() : 0
                ).toHexString()
              }
            });
          }
          default:
            return await A.transfer(v);
        }
      } catch (O) {
        throw new F("core_transaction_deposit_error", O);
      }
    });
    /**
     * TC related Methods
     */
    L(this, "createLiquidity", async ({ runeAmount: n, assetAmount: a }) => {
      if (n.lte(0) || a.lte(0))
        throw new F("core_transaction_create_liquidity_invalid_params");
      let o = "", m = "";
      try {
        o = await this._depositToPool({
          assetAmount: n,
          memo: Ye(qe.DEPOSIT, {
            ...a.asset,
            address: this.getAddress(a.asset.chain)
          })
        });
      } catch (f) {
        throw new F("core_transaction_create_liquidity_rune_error", f);
      }
      try {
        m = await this._depositToPool({
          assetAmount: a,
          memo: Ye(qe.DEPOSIT, {
            ...a.asset,
            address: this.getAddress(S.THORChain)
          })
        });
      } catch (f) {
        throw new F("core_transaction_create_liquidity_asset_error", f);
      }
      return { runeTx: o, assetTx: m };
    });
    L(this, "addLiquidity", async ({
      pool: n,
      runeAmount: a,
      assetAmount: o,
      runeAddr: m,
      assetAddr: f,
      isPendingSymmAsset: A,
      mode: v = "sym"
    }) => {
      const { chain: O, symbol: b } = n.asset, D = v === "sym", U = (a == null ? void 0 : a.gt(0)) && (D || v === "rune"), j = (o == null ? void 0 : o.gt(0)) && (D || v === "asset"), Be = A || U, ee = Be ? m || this.getAddress(S.THORChain) : "", ke = D || v === "asset" ? f || this.getAddress(O) : "";
      if (!U && !j)
        throw new F("core_transaction_add_liquidity_invalid_params");
      if (Be && !ee)
        throw new F("core_transaction_add_liquidity_no_rune_address");
      let te, He;
      if (U && a)
        try {
          te = await this._depositToPool({
            assetAmount: a,
            memo: Ye(qe.DEPOSIT, {
              chain: O,
              symbol: b,
              address: ke
            })
          });
        } catch (R) {
          throw new F("core_transaction_add_liquidity_rune_error", R);
        }
      if (j && o)
        try {
          He = await this._depositToPool({
            assetAmount: o,
            memo: Ye(qe.DEPOSIT, {
              chain: O,
              symbol: b,
              address: ee
            })
          });
        } catch (R) {
          throw new F("core_transaction_add_liquidity_asset_error", R);
        }
      return { runeTx: te, assetTx: He };
    });
    L(this, "withdraw", async ({ memo: n, asset: a, percent: o, from: m, to: f }) => {
      const A = f === "rune" ? _t(S.THORChain) : m === "sym" && f === "sym" || m === "rune" || m === "asset" ? void 0 : a;
      try {
        return await this._depositToPool({
          assetAmount: Dt(m === "asset" ? a.chain : S.THORChain),
          memo: n || Ye(qe.WITHDRAW, {
            ...a,
            basisPoints: o.mul(100).assetAmount.toNumber(),
            targetAssetString: A == null ? void 0 : A.toString(),
            singleSide: !1
          })
        });
      } catch (v) {
        throw new F("core_transaction_withdraw_error", v);
      }
    });
    L(this, "addSavings", async ({ assetAmount: n, memo: a }) => {
      try {
        return await this._depositToPool({
          assetAmount: n,
          memo: a || Ye(qe.DEPOSIT, {
            chain: n.asset.chain,
            symbol: n.asset.symbol,
            singleSide: !0
          })
        });
      } catch (o) {
        throw new F("core_transaction_deposit_to_pool_error", o);
      }
    });
    L(this, "withdrawSavings", async ({
      memo: n,
      asset: a,
      percent: o
    }) => {
      try {
        return await this._depositToPool({
          assetAmount: Dt(a.chain),
          memo: n || Ye(qe.WITHDRAW, {
            ...a,
            basisPoints: o.mul(100).assetAmount.toNumber(),
            singleSide: !0
          })
        });
      } catch (m) {
        throw new F("core_transaction_withdraw_error", m);
      }
    });
    L(this, "openLoan", ({
      assetAmount: n,
      assetTicker: a,
      borrowAmount: o,
      memo: m
    }) => this._depositToPool({
      assetAmount: n,
      memo: m || Ye(qe.OPEN_LOAN, {
        asset: a,
        minAmount: o == null ? void 0 : o.assetAmount.toString(),
        address: this.getAddress(a.split(".")[0])
      })
    }));
    L(this, "closeLoan", ({
      assetAmount: n,
      assetTicker: a,
      borrowAmount: o,
      memo: m
    }) => this._depositToPool({
      assetAmount: n,
      memo: m || Ye(qe.CLOSE_LOAN, {
        asset: a,
        minAmount: o == null ? void 0 : o.assetAmount.toString(),
        address: this.getAddress(a.split(".")[0])
      })
    }));
    L(this, "registerThorname", (n, a) => this._thorchainTransfer({
      memo: Ye(qe.THORNAME_REGISTER, n),
      assetAmount: new st(_t(S.THORChain), a)
    }));
    L(this, "bond", (n, a) => this._thorchainTransfer({
      memo: Ye(qe.BOND, { address: n }),
      assetAmount: new st(_t(S.THORChain), a)
    }));
    L(this, "unbond", (n, a) => this._thorchainTransfer({
      memo: Ye(qe.UNBOND, { address: n, unbondAmount: a }),
      assetAmount: Dt(S.THORChain)
    }));
    L(this, "leave", (n) => this._thorchainTransfer({
      memo: Ye(qe.LEAVE, { address: n }),
      assetAmount: Dt(S.THORChain)
    }));
    /**
     * Wallet connection methods
     */
    L(this, "connectXDEFI", async (n) => {
      throw new F("core_wallet_xdefi_not_installed");
    });
    L(this, "connectEVMWallet", async (n, a) => {
      throw new F("core_wallet_evmwallet_not_installed");
    });
    L(this, "connectWalletconnect", async (n, a) => {
      throw new F("core_wallet_walletconnect_not_installed");
    });
    L(this, "connectKeystore", async (n, a) => {
      throw new F("core_wallet_keystore_not_installed");
    });
    L(this, "connectLedger", async (n, a) => {
      throw new F("core_wallet_ledger_not_installed");
    });
    L(this, "connectTrezor", async (n, a) => {
      throw new F("core_wallet_trezor_not_installed");
    });
    L(this, "connectKeplr", async () => {
      throw new F("core_wallet_keplr_not_installed");
    });
    L(this, "connectOkx", async (n) => {
      throw new F("core_wallet_okx_not_installed");
    });
    L(this, "disconnectChain", (n) => {
      this.connectedChains[n] = null, this.connectedWallets[n] = null;
    });
    L(this, "extend", ({ wallets: n, config: a, apis: o = {}, rpcUrls: m = {} }) => {
      try {
        n.forEach((f) => {
          this[f.connectMethodName] = f.connect({
            addChain: this._addConnectedChain,
            config: a || {},
            apis: o,
            rpcUrls: m
          });
        });
      } catch (f) {
        throw new F("core_extend_error", f);
      }
    });
    L(this, "estimateMaxSendableAmount", async ({
      chain: n,
      params: a
    }) => {
      const o = this.getWallet(n);
      switch (n) {
        case S.Arbitrum:
        case S.Avalanche:
        case S.BinanceSmartChain:
        case S.Ethereum:
        case S.Optimism:
        case S.Polygon: {
          const { estimateMaxSendableAmount: m } = await import("@pioneer-platform/toolbox-evm");
          return m({ ...a, toolbox: o });
        }
        case S.Bitcoin:
        case S.BitcoinCash:
        case S.Dogecoin:
        case S.Litecoin:
          return o.estimateMaxSendableAmount(a);
        case S.Binance:
        case S.THORChain:
        case S.Cosmos: {
          const { estimateMaxSendableAmount: m } = await import("@pioneer-platform/toolbox-cosmos");
          return m({
            ...a,
            toolbox: o
          });
        }
        default:
          throw new F("core_estimated_max_spendable_chain_not_supported");
      }
    });
    /**
     * Private methods (internal use only \_()_/)
     */
    L(this, "_getInboundDataByChain", async (n) => {
      if (n === S.THORChain)
        return { gas_rate: "0", router: "0", address: "", halted: !1, chain: S.THORChain };
      const o = (await Pr(this.stagenet)).find((m) => m.chain === n);
      if (!o)
        throw new F("core_inbound_data_not_found");
      if (o != null && o.halted)
        throw new F("core_chain_halted");
      return o;
    });
    L(this, "_addConnectedChain", ({ chain: n, wallet: a, walletMethods: o }) => {
      this.connectedChains[n] = a, this.connectedWallets[n] = o;
    });
    L(this, "_approve", async ({
      asset: n,
      contractAddress: a,
      amount: o
    }, m = "checkOnly") => {
      const f = [S.Ethereum, S.Avalanche, S.BinanceSmartChain].includes(
        n.chain
      );
      if (f && Qn(n) || !f || n.isSynth)
        return !0;
      const v = this.connectedWallets[n.L1Chain], O = m === "checkOnly" ? v == null ? void 0 : v.isApproved : v == null ? void 0 : v.approve;
      if (!O)
        throw new F("core_wallet_connection_not_found");
      const { getTokenAddress: b } = await import("@pioneer-platform/toolbox-evm"), D = b(n, n.L1Chain), U = this.getAddress(n.L1Chain);
      if (!D || !U)
        throw new F("core_approve_asset_address_or_from_not_found");
      return O({
        amount: o == null ? void 0 : o.amount(),
        assetAddress: D,
        from: U,
        spenderAddress: a || (await this._getInboundDataByChain(n.L1Chain)).router
      });
    });
    L(this, "_depositToPool", async ({
      assetAmount: n,
      memo: a,
      feeOptionKey: o = Nt.Fast
    }) => {
      const {
        gas_rate: m,
        router: f,
        address: A
      } = await this._getInboundDataByChain(n.asset.chain), v = (parseInt(m) || 0) * Ki[o];
      return this.deposit({ assetAmount: n, recipient: A, memo: a, router: f, feeRate: v });
    });
    L(this, "_thorchainTransfer", async ({
      memo: n,
      assetAmount: a
    }) => {
      const o = await Br(this.stagenet);
      if (o.HALTCHAINGLOBAL === 1 || o.HALTTHORCHAIN === 1)
        throw new F("core_chain_halted");
      return this.deposit({ assetAmount: a, recipient: "", memo: n });
    });
    L(this, "_prepareTxParams", ({
      assetAmount: {
        asset: { L1Chain: n, isSynth: a, chain: o, symbol: m, decimal: f },
        amount: A
      },
      ...v
    }) => {
      const O = At(A.baseAmount.toString(10), f), b = Ni(
        a ? `${S.THORChain}.${o.toLowerCase()}/${m.toLowerCase()}` : `${o.toUpperCase()}.${m.toUpperCase()}`
      );
      return {
        ...v,
        memo: v.memo || "",
        from: this.getAddress(n),
        amount: O,
        asset: b
      };
    });
    this.stagenet = !!n;
  }
}
export {
  Ui as AGG_SWAP,
  C as Amount,
  dt as AmountType,
  Fr as ApiError,
  bt as ApiUrl,
  st as AssetAmount,
  Xe as AssetEntity,
  Pi as AssetSymbol,
  wt as BN_FORMAT,
  oi as BaseDecimal,
  S as Chain,
  gn as ChainId,
  Yr as ChainIdToChain,
  Wi as ChainToChainId,
  li as ChainToExplorerUrl,
  Xr as ChainToHexChainId,
  Wr as ChainToRPC,
  ki as ContractAddress,
  qr as CosmosChainList,
  $i as DerivationPath,
  tr as EMPTY_FORMAT,
  P as ERROR_CODE,
  Vi as ERROR_MODULE,
  ai as ERROR_TYPE,
  Gr as EVMChainList,
  Xi as ErrorCode,
  Nt as FeeOption,
  zr as MOCK_PHRASE,
  qe as MemoType,
  kr as NetworkDerivationPath,
  Gi as NetworkId,
  hi as Pool,
  pr as Price,
  Bi as QuoteMode,
  ui as RPCUrl,
  Ut as Rounding,
  Li as SWAP_IN,
  Hi as SWAP_OUT,
  ia as SwapKitCore,
  Ci as TCAvalancheDepositABI,
  Di as TCBscDepositABI,
  xi as TCEthereumVaultAbi,
  $r as UTXOChainList,
  zi as WalletOption,
  Yi as WalletStatus,
  Vr as erc20ABI,
  Kr as formatBigNumber,
  ir as getAssetShare,
  er as getAssetType,
  ar as getAsymmetricAssetShare,
  Qr as getAsymmetricAssetWithdrawAmount,
  rr as getAsymmetricRuneShare,
  Zr as getAsymmetricRuneWithdrawAmount,
  jr as getEstimatedPoolShare,
  ea as getLiquiditySlippage,
  Ye as getMemoFor,
  Dt as getMinAmountByChain,
  or as getNetworkName,
  nr as getRuneShare,
  _t as getSignatureAssetFor,
  Jr as getSymmetricWithdraw,
  ta as getTHORNameCost,
  Qn as isGasAsset,
  na as validateTHORName
};
