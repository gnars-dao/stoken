var C = Object.defineProperty;
var B = (e, a, s) => a in e ? C(e, a, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[a] = s;
var r = (e, a, s) => (B(e, typeof a != "symbol" ? a + "" : a, s), s);
const F = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !0, internalType: "address", name: "spender", type: "address" },
      { indexed: !1, internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "from", type: "address" },
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "success", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "success", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "success", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  }
], K = [
  {
    inputs: [{ internalType: "address", name: "rune", type: "address" }],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !0, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "Deposit",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferAllowance",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOut",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !1, internalType: "address", name: "target", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "address", name: "finalAsset", type: "address" },
      { indexed: !1, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOutAndCall",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        indexed: !1,
        internalType: "struct THORChain_Router.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "VaultTransfer",
    type: "event"
  },
  {
    inputs: [],
    name: "RUNE",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "deposit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" },
      { internalType: "uint256", name: "expiration", type: "uint256" }
    ],
    name: "depositWithExpiry",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address payable", name: "asgard", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        internalType: "struct THORChain_Router.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "returnVaultAssets",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address", name: "newVault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferAllowance",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "to", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "aggregator", type: "address" },
      { internalType: "address", name: "finalToken", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOutAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "vault", type: "address" },
      { internalType: "address", name: "token", type: "address" }
    ],
    name: "vaultAllowance",
    outputs: [{ internalType: "uint256", name: "amount", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  }
], k = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !0, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "Deposit",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferAllowance",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOut",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !1, internalType: "address", name: "target", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "address", name: "finalAsset", type: "address" },
      { indexed: !1, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOutAndCall",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        indexed: !1,
        internalType: "struct AvaxRouter.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "VaultTransfer",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "deposit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" },
      { internalType: "uint256", name: "expiration", type: "uint256" }
    ],
    name: "depositWithExpiry",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address payable", name: "asgard", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        internalType: "struct AvaxRouter.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "returnVaultAssets",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address", name: "newVault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferAllowance",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "to", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "target", type: "address" },
      { internalType: "address", name: "finalToken", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOutAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "vault", type: "address" },
      { internalType: "address", name: "token", type: "address" }
    ],
    name: "vaultAllowance",
    outputs: [{ internalType: "uint256", name: "amount", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  }
], Y = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !0, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "Deposit",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferAllowance",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOut",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !1, internalType: "address", name: "target", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "address", name: "finalAsset", type: "address" },
      { indexed: !1, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOutAndCall",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        indexed: !1,
        internalType: "struct THORChain_Router.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "VaultTransfer",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" },
      { internalType: "uint256", name: "expiration", type: "uint256" }
    ],
    name: "depositWithExpiry",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address payable", name: "asgard", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        internalType: "struct THORChain_Router.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "returnVaultAssets",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address", name: "newVault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferAllowance",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "to", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "target", type: "address" },
      { internalType: "address", name: "finalToken", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOutAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "vault", type: "address" },
      { internalType: "address", name: "token", type: "address" }
    ],
    name: "vaultAllowance",
    outputs: [{ internalType: "uint256", name: "amount", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  }
];
var g = /* @__PURE__ */ ((e) => (e.TC_SUPPORTED_TO_TC_SUPPORTED = "TC-TC", e.TC_SUPPORTED_TO_ETH = "TC-ERC20", e.TC_SUPPORTED_TO_AVAX = "TC-ARC20", e.TC_SUPPORTED_TO_BSC = "TC-BEP20", e.ETH_TO_TC_SUPPORTED = "ERC20-TC", e.ETH_TO_ETH = "ERC20-ERC20", e.ETH_TO_AVAX = "ERC20-ARC20", e.ETH_TO_BSC = "ERC20-BEP20", e.AVAX_TO_TC_SUPPORTED = "ARC20-TC", e.AVAX_TO_ETH = "ARC20-ERC20", e.AVAX_TO_AVAX = "ARC20-ARC20", e.AVAX_TO_BSC = "ARC20-BEP20", e.BSC_TO_TC_SUPPORTED = "BEP20-TC", e.BSC_TO_ETH = "BEP20-ERC20", e.BSC_TO_AVAX = "BEP20-ARC20", e.BSC_TO_BSC = "BEP20-BEP20", e))(g || {});
const W = [
  "ERC20-ERC20",
  "ARC20-ARC20",
  "BEP20-BEP20"
  /* BSC_TO_BSC */
], Z = [
  "ERC20-TC",
  "ERC20-ARC20",
  "ERC20-BEP20",
  "ARC20-TC",
  "ARC20-ERC20",
  "ARC20-BEP20",
  "BEP20-TC",
  "BEP20-ERC20",
  "BEP20-ARC20"
  /* BSC_TO_AVAX */
], J = [
  "TC-TC",
  "TC-ERC20",
  "TC-ARC20",
  "TC-BEP20"
  /* TC_SUPPORTED_TO_BSC */
];
var S = /* @__PURE__ */ ((e) => (e.VALIDATION_ERROR = "VALIDATION_ERROR", e.REQUEST_PARAMETER_ERROR = "REQUEST_PARAMETER_ERROR", e.RESPONSE_PARSING_ERROR = "RESPONSE_PARSING_ERROR", e.UNSUPPORTED = "UNSUPPORTED", e.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", e.INCOMPATIBLE_ASSETS_OPERATIONS = "INCOMPATIBLE_ASSETS_OPERATIONS", e.SERVICE_UNAVAILABLE = "SERVICE_UNAVAILABLE", e.DOWN_FOR_MAINTENANCE = "DOWN_FOR_MAINTENANCE", e.MISSING_INBOUND_INFO = "MISSING_INBOUND_INFO", e.QUOTE_FETCHING_ERROR = "QUOTE_FETCHING_ERROR", e.AIRDROP_ERROR = "AIRDROP_ERROR", e.UNHANDLED_ERROR = "UNHANDLED_ERROR", e))(S || {}), b = /* @__PURE__ */ ((e) => (e.HEALTH_CONTROLLER = "1000", e.LIQUIDITY_CONTROLLER = "1001", e.PROVIDER_CONTROLLER = "1002", e.QUOTE_CONTROLLER = "1003", e.SWAP_CONTROLLER = "1004", e.UTIL_CONTROLLER = "1005", e.AIRDROP_CONTROLLER = "1006", e.PROVIDER = "2000", e.ASSET = "2001", e.TOKEN_LIST = "2002", e.QUOTE = "2100", e.QUOTE_TXN_DETAILS = "2101", e.THORCHAIN_PROVIDER = "3000", e.UNISWAPV2_ETH_PROVIDER = "3001", e.UNISWAPV3_ETH_PROVIDER = "3002", e.SUSHISWAP_ETH_PROVIDER = "3003", e.PANCAKESWAP_BSC_PROVIDER = "3004", e.PANCAKESWAP_ETH_PROVIDER = "3005", e.ONEINCH_ETH_PROVIDER = "3006", e.ONEINCH_BSC_PROVIDER = "3007", e.ONEINCH_AVAX_PROVIDER = "3008", e.ZEROX_ETH_PROVIDER = "3009", e.WOOFI_AVAX_PROVIDER = "3010", e.PANGOLIN_AVAX_PROVIDER = "3011", e.TRADERJOE_AVAX_PROVIDER = "3012", e.KYBER_ETH_PROVIDER = "3013", e.KYBER_AVAX_PROVIDER = "3014", e.WOOFI_BSC_PROVIDER = "3015", e.STARGATE_PROVIDER = "3016", e.PROVIDER_UTIL = "4000", e.TXN_DETAILS = "5000", e.AIRDROP_UTIL = "6000", e))(b || {}), t = /* @__PURE__ */ ((e) => (e.INVALID_INPUT_PARAMETERS = "1000", e.UNKNOWN_PROVIDERS = "1001", e.CANNOT_FIND_INBOUND_ADDRESS = "1002", e.NO_INBOUND_ADDRESSES = "1003", e.CHAIN_HALTED_OR_UNSUPPORTED = "1004", e.MISSING_INPUT_PARAMETER = "1005", e.INVALID_TYPE_GENERIC = "1100", e.INVALID_NUMBER_STRING = "1101", e.INVALID_NUMBER = "1102", e.INVALID_BOOLEAN = "1103", e.INVALID_OBJECT = "1104", e.INVALID_ARRAY = "1105", e.SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2000", e.SELL_BUY_ASSETS_ARE_THE_SAME = "2001", e.MISSING_SOURCE_ADDRESS_FOR_SYNTH = "2002", e.AFF_ADDRESS_AND_BPS_OR_NEITHER = "2003", e.AFF_ADDRESS_TOO_LONG = "2004", e.AFF_BPS_INTEGER_0_100 = "2005", e.SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN = "2006", e.DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN = "2007", e.PREFERRED_PROFVIDER_NOT_SUPPORTED = "2008", e.DESTINATION_ADDRESS_SMART_CONTRACT = "2009", e.BUY_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2010", e.SOURCE_ADDRESS_SMART_CONTRACT = "2011", e.INVALID_PROVIDER = "2100", e.MISSING_CROSS_CHAIN_PROVIDER = "2101", e.MISSING_AVAX_PROVIDER = "2102", e.MISSING_BSC_PROVIDER = "2103", e.MISSING_ETH_PROVIDER = "2104", e.INVALID_PROVIDER_FOR_SWAP_OUT = "2105", e.MISSING_ARB_PROVIDER = "2106", e.INVALID_CHAIN = "2200", e.INVALID_ASSET = "2201", e.INVALID_ASSET_IDENTIFIER = "2202", e.UNSUPPORTED_CHAIN = "2204", e.UNSUPPORTED_ASSET = "2203", e.UNSUPPORTED_ASSET_FOR_SWAPOUT = "2205", e.INVALID_SOURCE_ADDRESS = "2300", e.INVALID_DESTINATION_ADDRESS = "2301", e.THORNODE_QUOTE_GENERIC_ERROR = "3000", e.NOT_ENOUGH_SYNTH_BALANCE = "3001", e.SYNTH_MINTING_CAP_REACHED = "3002", e.INVALID_QUOTE_MODE = "4000", e.NO_QUOTES = "4001", e.SERVICE_UNAVAILABLE_GENERIC = "5000", e.MISSING_GAS_DATA_GENERIC = "5100", e.MISSING_TOKEN_INFO_GENERIC = "5200", e.CANT_FIND_TOKEN_LIST = "5201", e.NO_PRICE = "5202", e.PRICE_IS_STALE = "5203", e.ADDRESS_NOT_WHITELISTED = "6000", e.ADDRESS_ALREADY_CLAIMED = "6001", e.TEMPORARY_ERROR = "9999", e))(t || {});
const V = {
  [t.INVALID_INPUT_PARAMETERS]: "Invalid input parameters: {0}.",
  [t.UNKNOWN_PROVIDERS]: "Unknown providers: {0}.",
  [t.CANNOT_FIND_INBOUND_ADDRESS]: "Cannot find inbound address.",
  [t.NO_INBOUND_ADDRESSES]: "No inbound addresses.",
  [t.CHAIN_HALTED_OR_UNSUPPORTED]: "Chain {0} halted or unsupported.",
  [t.MISSING_INPUT_PARAMETER]: "Missing input parameter: {0}.",
  [t.INVALID_TYPE_GENERIC]: "Invalid type",
  [t.INVALID_NUMBER_STRING]: "Invalid number string.",
  [t.INVALID_NUMBER]: "Invalid number.",
  [t.INVALID_BOOLEAN]: "Invalid boolean.",
  [t.INVALID_OBJECT]: "Invalid object.",
  [t.INVALID_ARRAY]: "Invalid array.",
  [t.SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER]: "Sell amount must be a positive integer.",
  [t.SELL_BUY_ASSETS_ARE_THE_SAME]: "Sell and buy assets are the same.",
  [t.MISSING_SOURCE_ADDRESS_FOR_SYNTH]: "Source address is required for synth quote.",
  [t.AFF_ADDRESS_AND_BPS_OR_NEITHER]: "Must provide affiliateAddress and affiliateBasisPoints params, or neither.",
  [t.AFF_ADDRESS_TOO_LONG]: "affiliateAddress too long: 3 characters max.",
  [t.AFF_BPS_INTEGER_0_100]: "affiliateBasisPoints must be an integer between 0 and 100.",
  [t.SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN]: "Source address {0} invalid for sell chain.",
  [t.DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN]: "Destination address {0} invalid for buy chain.",
  [t.PREFERRED_PROFVIDER_NOT_SUPPORTED]: "Preferred provider not supported.",
  [t.DESTINATION_ADDRESS_SMART_CONTRACT]: "Destination address is a smart contract.",
  [t.BUY_AMOUNT_MUST_BE_POSITIVE_INTEGER]: "Buy amount must be a positive integer.",
  [t.INVALID_PROVIDER]: "Invalid provider {0}.",
  [t.MISSING_CROSS_CHAIN_PROVIDER]: "Missing cross-chain provider.",
  [t.MISSING_AVAX_PROVIDER]: "Missing AVAX provider.",
  [t.MISSING_BSC_PROVIDER]: "Missing BSC provider.",
  [t.MISSING_ETH_PROVIDER]: "Missing ETH provider.",
  [t.MISSING_ARB_PROVIDER]: "Missing ARB provider.",
  [t.INVALID_PROVIDER_FOR_SWAP_OUT]: "Invalid provider for swap out.",
  [t.INVALID_CHAIN]: "Invalid chain {0}.",
  [t.INVALID_ASSET]: "Invalid asset {0}.",
  [t.UNSUPPORTED_CHAIN]: "Unsupported chain {0}.",
  [t.UNSUPPORTED_ASSET]: "Unsupported asset {0}.",
  [t.UNSUPPORTED_ASSET_FOR_SWAPOUT]: "Unsupported asset {0} for swap out.",
  [t.THORNODE_QUOTE_GENERIC_ERROR]: "ThorNode quote generic error.",
  [t.INVALID_SOURCE_ADDRESS]: "Invalid source address {0}",
  [t.INVALID_DESTINATION_ADDRESS]: "Invalid destination address {0}",
  [t.NOT_ENOUGH_SYNTH_BALANCE]: "Source address doesn't have enough synth balance for this quote.",
  [t.SYNTH_MINTING_CAP_REACHED]: "Synth minting cap reached.",
  [t.INVALID_QUOTE_MODE]: "Invalid quote mode.",
  [t.NO_QUOTES]: "No quotes to service this request.",
  [t.SERVICE_UNAVAILABLE_GENERIC]: "Service unavailable.",
  [t.MISSING_GAS_DATA_GENERIC]: "Missing gas data.",
  [t.MISSING_TOKEN_INFO_GENERIC]: "Missing token info.",
  [t.CANT_FIND_TOKEN_LIST]: "Can't find tokenlist {0}.",
  [t.NO_PRICE]: "No price for asset {0}.",
  [t.PRICE_IS_STALE]: "Price is stale for asset {0}.",
  [t.ADDRESS_NOT_WHITELISTED]: "Address {0} not whitelisted for airdrop.",
  [t.ADDRESS_ALREADY_CLAIMED]: "Address {0} already claimed the airdrop."
}, y = (e, a) => {
  let s = V[e];
  for (let i = 0; i < a.length; i++)
    s = s.replace(`{${i}}`, a[i]);
  return a.length === 0 ? s.replace("{0}", "") : s;
};
class I extends Error {
  constructor({
    status: s,
    revision: i,
    module: _,
    code: o,
    message: N,
    type: c,
    options: { shouldLog: O, shouldThrow: f, shouldTrace: h } = {
      shouldLog: !0,
      shouldThrow: !0,
      shouldTrace: !0
    },
    displayMessageParams: u
  }) {
    const A = N || y(o, u || []) || "";
    super(A);
    r(this, "status");
    r(this, "revision");
    r(this, "type");
    r(this, "module");
    r(this, "code");
    r(this, "message");
    r(this, "display");
    r(this, "stack");
    r(this, "options");
    r(this, "displayMessageParams");
    this.status = s, this.revision = i || "NO_REVISION", this.module = _, this.message = A, this.display = y(o, u || []), this.code = o, this.type = c || S.UNHANDLED_ERROR, this.options = {
      shouldLog: O || !0,
      shouldTrace: h || !0,
      shouldThrow: f || !1
    }, this.displayMessageParams = u || [], this.options.shouldTrace && Error.captureStackTrace(this);
  }
  static fromErrorInfo(s) {
    return new I(s);
  }
  toErrorInfo() {
    return { ...this, identifier: this.identifier };
  }
  get identifier() {
    return `${this.revision}-${this.type || "NO_TYPE"}-${this.module}-${this.code}`;
  }
  get displayMessage() {
    return y(this.code, this.displayMessageParams || []);
  }
  handle() {
    const s = `[${this.identifier}]: ${this.message}`;
    if (this.options.shouldLog && console.error(s, `
`, this.stack || ""), this.options.shouldThrow)
      throw Error(s, { cause: this.stack });
    return this.toErrorInfo();
  }
}
var n = /* @__PURE__ */ ((e) => (e.Arbitrum = "ARB", e.Avalanche = "AVAX", e.Base = "BASE", e.Binance = "BNB", e.BinanceSmartChain = "BSC", e.Bitcoin = "BTC", e.BitcoinCash = "BCH", e.Cosmos = "GAIA", e.Dash = "DASH", e.Digibyte = "DGB", e.Dogecoin = "DOGE", e.EOS = "EOS", e.Ethereum = "ETH", e.Kujira = "KUJI", e.Litecoin = "LTC", e.Maya = "MAYA", e.Optimism = "OP", e.Osmosis = "OSMO", e.Polygon = "MATIC", e.Ripple = "XRP", e.THORChain = "THOR", e.Zcash = "ZEC", e))(n || {});
function j(e) {
  switch (e) {
    case "ARB":
      return "ARB";
    case "AVAX":
      return "AVAX";
    case "BASE":
      return "BASE";
    case "BNB":
      return "BNB";
    case "BSC":
      return "BSC";
    case "BTC":
      return "BTC";
    case "BCH":
      return "BCH";
    case "GAIA":
      return "GAIA";
    case "DASH":
      return "DASH";
    case "DGB":
      return "DGB";
    case "DOGE":
      return "DOGE";
    case "EOS":
      return "EOS";
    case "ETH":
      return "ETH";
    case "KUJI":
      return "KUJI";
    case "LTC":
      return "LTC";
    case "MAYA":
      return "MAYA";
    case "OP":
      return "OP";
    case "OSMO":
      return "OSMO";
    case "MATIC":
      return "MATIC";
    case "XRP":
      return "XRP";
    case "THOR":
      return "THOR";
    case "ZEC":
      return "ZEC";
    default:
      return;
  }
}
const P = {
  ARB: "eip155:42161",
  AVAX: "eip155:43114",
  BSC: "eip155:56",
  BNB: "binance:bnb-beacon-chain",
  BCH: "bip122:000000000000000000651ef99cb9fcbe",
  BTC: "bip122:000000000019d6689c085ae165831e93",
  BASE: "eip155:8453",
  GAIA: "cosmos:cosmoshub-4",
  DASH: "bip122:dash-hash",
  DGB: "bip122:digibytes-hash",
  DOGE: "bip122:00000000001a91e3dace36e2be3bf030",
  KUJI: "cosmos:kaiyo-1",
  EOS: "eos:cf057bbfb72640471fd910bcb67639c2",
  ETH: "eip155:1",
  LTC: "bip122:12a765e31ffd4059bada1e25190f6e98",
  MAYA: "cosmos:maya-mainnet-v1",
  OP: "eip155:10",
  OSMO: "cosmos:osmosis-1",
  MATIC: "eip155:137",
  XRP: "ripple:unknown",
  THOR: "cosmos:thorchain-mainnet-v1",
  ZEC: "bip122:0000000000196a45"
}, H = {};
for (const e in n) {
  const a = P[n[e]];
  H[a] = n[e];
}
var x = /* @__PURE__ */ ((e) => (e.ARB = "0x0000000000000000000000000000000000000000", e.AVAX = "0x0000000000000000000000000000000000000000", e.ETH = "0x0000000000000000000000000000000000000000", e.BSC = "0x0000000000000000000000000000000000000000", e.MATIC = "0x0000000000000000000000000000000000001010", e.OP = "0x4200000000000000000000000000000000000042", e))(x || {}), R = /* @__PURE__ */ ((e) => (e.ARB = "m/44'/60'/0'/0", e.AVAX = "m/44'/60'/0'/0", e.BASE = "m/44'/60'/0'/0", e.BCH = "m/44'/145'/0'/0", e.BNB = "m/44'/714'/0'/0", e.BSC = "m/44'/60'/0'/0", e.BTC = "m/84'/0'/0'/0", e.DOGE = "m/44'/3'/0'/0", e.DASH = "m/44'/5'/0'/0", e.DGB = "m/44'/20'/0'/0", e.ETH = "m/44'/60'/0'/0", e.EOS = "m/44'/194'/0'/0", e.GAIA = "m/44'/118'/0'/0", e.KUJI = "m/44'/118'/0'/0", e.LTC = "m/84'/2'/0'/0", e.MATIC = "m/44'/60'/0'/0", e.MAYA = "m/44'/931'/0'/0", e.OP = "m/44'/60'/0'/0", e.OSMO = "m/44'/118'/0'/0", e.XRP = "m/44'/144'/0'/0", e.THOR = "m/44'/931'/0'/0", e.ZEC = "m/44'/133'/0'/0", e))(R || {});
const $ = {
  ARB: [44, 60, 0, 0, 0],
  AVAX: [44, 60, 0, 0, 0],
  BASE: [44, 60, 0, 0, 0],
  BCH: [44, 145, 0, 0, 0],
  BNB: [44, 714, 0, 0, 0],
  BSC: [44, 60, 0, 0, 0],
  BTC: [84, 0, 0, 0, 0],
  DASH: [44, 5, 0, 0, 0],
  DGB: [44, 20, 0, 0, 0],
  DOGE: [44, 3, 0, 0, 0],
  EOS: [44, 194, 0, 0, 0],
  ETH: [44, 60, 0, 0, 0],
  GAIA: [44, 118, 0, 0, 0],
  KUJI: [44, 118, 0, 0, 0],
  LTC: [84, 2, 0, 0, 0],
  MATIC: [44, 60, 0, 0, 0],
  MAYA: [44, 931, 0, 0, 0],
  OP: [44, 60, 0, 0, 0],
  OSMO: [44, 118, 0, 0, 0],
  XRP: [44, 144, 0, 0, 0],
  THOR: [44, 931, 0, 0, 0],
  ZEC: [44, 133, 0, 0, 0]
};
var L = /* @__PURE__ */ ((e) => (e[e.ARB = 18] = "ARB", e[e.AVAX = 18] = "AVAX", e[e.BCH = 8] = "BCH", e[e.BNB = 8] = "BNB", e[e.BSC = 18] = "BSC", e[e.BTC = 8] = "BTC", e[e.DASH = 8] = "DASH", e[e.DGB = 8] = "DGB", e[e.DOGE = 8] = "DOGE", e[e.ETH = 18] = "ETH", e[e.EOS = 6] = "EOS", e[e.GAIA = 6] = "GAIA", e[e.KUJI = 6] = "KUJI", e[e.LTC = 8] = "LTC", e[e.MATIC = 18] = "MATIC", e[e.MAYA = 10] = "MAYA", e[e.OP = 18] = "OP", e[e.OSMO = 6] = "OSMO", e[e.XRP = 6] = "XRP", e[e.THOR = 8] = "THOR", e[e.ZEC = 8] = "ZEC", e))(L || {});
const T = [
  "ETH",
  "AVAX",
  "BSC",
  "ARB",
  // Chain.Base,
  "OP",
  "MATIC"
  /* Polygon */
], q = [
  "BTC",
  "BCH",
  "DASH",
  "DGB",
  "DOGE",
  "LTC",
  "ZEC"
  /* Zcash */
], z = [
  "GAIA",
  "THOR",
  "BNB",
  "OSMO"
  /* Osmosis */
], Q = [
  "AVAX",
  "BNB",
  "BSC",
  "BTC",
  "BCH",
  "GAIA",
  "DOGE",
  "ETH",
  "LTC",
  "THOR"
  /* THORChain */
];
var m = /* @__PURE__ */ ((e) => (e.Arbitrum = "42161", e.ArbitrumHex = "0xa4b1", e.Avalanche = "43114", e.AvalancheHex = "0xa86a", e.Base = "8453", e.Binance = "Binance-Chain-Tigris", e.BinanceSmartChain = "56", e.BinanceSmartChainHex = "0x38", e.Bitcoin = "bitcoin", e.BitcoinCash = "bitcoincash", e.Cosmos = "cosmoshub-4", e.Dash = "dash", e.Dogecoin = "dogecoin", e.Kujira = "kaiyo-1", e.Ethereum = "1", e.EthereumHex = "0x1", e.Litecoin = "litecoin", e.Maya = "mayachain-mainnet-v1", e.MayaStagenet = "mayachain-stagenet-v1", e.Optimism = "10", e.OptimismHex = "0xa", e.Osmosis = "osmosis-1", e.Polygon = "137", e.PolygonHex = "0x89", e.THORChain = "thorchain-mainnet-v1", e.THORChainStagenet = "thorchain-stagenet-v2", e))(m || {}), E = /* @__PURE__ */ ((e) => (e.Arbitrum = "https://arb1.arbitrum.io/rpc", e.Avalanche = "https://node-router.thorswap.net/avalanche-c", e.Binance = "https://base.llamarpc.com", e.BinanceSmartChain = "https://bsc-dataseed.binance.org", e.Bitcoin = "https://node-router.thorswap.net/bitcoin", e.BitcoinCash = "https://node-router.thorswap.net/bitcoin-cash", e.Cosmos = "https://node-router.thorswap.net/cosmos/rpc", e.Kujira = "https://rpc-kujira.synergynodes.com/", e.Dash = "https://dash.nownodes.io", e.Dogecoin = "https://node-router.thorswap.net/dogecoin", e.Ethereum = "https://node-router.thorswap.net/ethereum", e.Litecoin = "https://node-router.thorswap.net/litecoin", e.Maya = "https://tendermint.mayachain.info", e.MayaStagenet = "https://stagenet.tendermint.mayachain.info", e.Optimism = "https://mainnet.optimism.io", e.Osmosis = "https://rpc-osmosis.keplr.app", e.Polygon = "https://polygon-rpc.com", e.THORChain = "https://rpc.thorswap.net", e.THORChainStagenet = "https://stagenet-rpc.ninerealms.com", e))(E || {}), D = /* @__PURE__ */ ((e) => (e.Cosmos = "https://node-router.thorswap.net/cosmos/rest", e.Kujira = "https://lcd-kujira.synergynodes.com/", e.MayanodeMainnet = "https://mayanode.mayachain.info", e.MayanodeStagenet = "https://stagenet.mayanode.mayachain.info", e.ThornodeMainnet = "https://thornode.thorswap.net", e.ThornodeStagenet = "https://stagenet-thornode.ninerealms.com", e.ThorswapApi = "https://api.thorswap.net", e.ThorswapStatic = "https://static.thorswap.net", e))(D || {});
const d = Object.values(n), M = Object.keys(n), l = d.reduce(
  (e, a) => {
    const s = M.find((i) => n[i] === a);
    return s && (e[a] = s), e;
  },
  {}
), ee = d.reduce(
  (e, a) => (e[a] = m[l[a]], e),
  {}
), te = d.reduce(
  (e, a) => (e[a] = E[l[a]], e),
  {}
), ne = d.reduce(
  (e, a) => {
    const s = `${l[a]}Hex`;
    return e[a] = m[s], e;
  },
  {}
), ae = {
  "0xa4b1": "ARB",
  42161: "ARB",
  "0xa86a": "AVAX",
  43114: "AVAX",
  "0x38": "BSC",
  56: "BSC",
  "Binance-Chain-Tigris": "BNB",
  bitcoincash: "BCH",
  bitcoin: "BTC",
  "cosmoshub-4": "GAIA",
  8453: "BASE",
  dash: "DASH",
  dogecoin: "DOGE",
  "0x1": "ETH",
  "kaiyo-1": "KUJI",
  1: "ETH",
  litecoin: "LTC",
  "mayachain-stagenet-v1": "MAYA",
  "mayachain-mainnet-v1": "MAYA",
  "0xa": "OP",
  10: "OP",
  "osmosis-1": "OSMO",
  "0x89": "MATIC",
  137: "MATIC",
  "thorchain-stagenet-v2": "THOR",
  "thorchain-mainnet-v1": "THOR"
  /* THORChain */
}, se = {
  ARB: "https://arbiscan.io",
  AVAX: "https://snowtrace.io",
  BSC: "https://bscscan.com",
  BNB: "https://explorer.binance.org",
  BCH: "https://www.blockchain.com/bch",
  BTC: "https://blockstream.info",
  BASE: "https://basescan.org",
  GAIA: "https://cosmos.bigdipper.live",
  DASH: "https://blockchair.com/dash",
  DGB: "https://chainz.cryptoid.info/dgb",
  DOGE: "https://blockchair.com/dogecoin",
  KUJI: "https://finder.kujira.network/kaiyo-1",
  EOS: "https://eosauthority.com/",
  ETH: "https://etherscan.io",
  LTC: "https://ltc.bitaps.com",
  MAYA: "https://www.mayascan.org",
  OP: "https://optimistic.etherscan.io",
  OSMO: "https://www.mintscan.io/osmosis",
  MATIC: "https://polygonscan.com",
  XRP: "https://xrpscan.com",
  THOR: "https://runescan.io",
  ZEC: "https://z.cash/ecosystem/zcash-explorer"
};
var v = /* @__PURE__ */ ((e) => (e[e.NoError = 36864] = "NoError", e))(v || {}), G = /* @__PURE__ */ ((e) => (e.BOND = "BOND", e.DEPOSIT = "+", e.LEAVE = "LEAVE", e.THORNAME_REGISTER = "~", e.UNBOND = "UNBOND", e.WITHDRAW = "-", e.OPEN_LOAN = "$+", e.CLOSE_LOAN = "$-", e))(G || {}), w = /* @__PURE__ */ ((e) => (e.Average = "average", e.Fast = "fast", e.Fastest = "fastest", e))(w || {}), U = /* @__PURE__ */ ((e) => (e.KEYSTORE = "KEYSTORE", e.KEEPKEY = "KEEPKEY", e.XDEFI = "XDEFI", e.METAMASK = "METAMASK", e.COINBASE_WEB = "COINBASE_WEB", e.TREZOR = "TREZOR", e.TRUSTWALLET_WEB = "TRUSTWALLET_WEB", e.LEDGER = "LEDGER", e.KEPLR = "KEPLR", e.OKX = "OKX", e.BRAVE = "BRAVE", e.WALLETCONNECT = "WALLETCONNECT", e))(U || {});
const p = [
  n.Arbitrum,
  n.Avalanche,
  n.Binance,
  n.BinanceSmartChain,
  n.Bitcoin,
  n.BitcoinCash,
  n.Cosmos,
  n.Dogecoin,
  n.Ethereum,
  n.Litecoin,
  n.Optimism,
  n.Polygon,
  n.THORChain
], re = {
  BRAVE: T,
  COINBASE_WEB: T,
  KEPLR: [n.Cosmos],
  KEYSTORE: p,
  LEDGER: p,
  TREZOR: [
    n.Bitcoin,
    n.BitcoinCash,
    n.Litecoin,
    n.Dogecoin,
    n.Ethereum
  ],
  KEEPKEY: p,
  METAMASK: [
    n.Arbitrum,
    n.Avalanche,
    n.BinanceSmartChain,
    n.Bitcoin,
    n.BitcoinCash,
    n.Cosmos,
    n.Dogecoin,
    n.Ethereum,
    n.Litecoin,
    n.Optimism,
    n.Polygon,
    n.THORChain
  ],
  TRUSTWALLET_WEB: T,
  XDEFI: p,
  WALLETCONNECT: [
    n.Ethereum,
    n.Binance,
    n.BinanceSmartChain,
    n.Avalanche,
    n.THORChain
  ],
  OKX: [
    n.Ethereum,
    n.Avalanche,
    n.BinanceSmartChain,
    n.Bitcoin,
    n.Cosmos
  ]
};
export {
  W as AGG_SWAP,
  I as ApiError,
  D as ApiUrl,
  L as BaseDecimal,
  n as Chain,
  m as ChainId,
  ae as ChainIdToChain,
  ee as ChainToChainId,
  se as ChainToExplorerUrl,
  ne as ChainToHexChainId,
  P as ChainToNetworkId,
  te as ChainToRPC,
  x as ContractAddress,
  z as CosmosChainList,
  R as DerivationPath,
  t as ERROR_CODE,
  b as ERROR_MODULE,
  S as ERROR_TYPE,
  T as EVMChainList,
  v as ErrorCode,
  w as FeeOption,
  G as MemoType,
  $ as NetworkDerivationPath,
  H as NetworkIdToChain,
  g as QuoteMode,
  E as RPCUrl,
  Z as SWAP_IN,
  J as SWAP_OUT,
  k as TCAvalancheDepositABI,
  Y as TCBscDepositABI,
  K as TCEthereumVaultAbi,
  Q as TCSupportedChainList,
  q as UTXOChainList,
  U as WalletOption,
  re as availableChainsByWallet,
  F as erc20ABI,
  j as getChainEnumValue
};
