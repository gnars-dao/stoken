"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetaMaskHDWallet = exports.MetaMaskHDWalletInfo = exports.isMetaMask = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const lodash_1 = __importDefault(require("lodash"));
const eth = __importStar(require("./ethereum"));
function isMetaMask(wallet) {
    return lodash_1.default.isObject(wallet) && wallet._isMetaMask;
}
exports.isMetaMask = isMetaMask;
class MetaMaskHDWalletInfo {
    constructor() {
        this._supportsBTCInfo = false;
        this._supportsETHInfo = true;
        this._supportsCosmosInfo = false;
        this._supportsBinanceInfo = false;
        this._supportsRippleInfo = false;
        this._supportsEosInfo = false;
        this._supportsFioInfo = false;
        this._supportsThorchainInfo = false;
        this._supportsSecretInfo = false;
        this._supportsKavaInfo = false;
        this._supportsTerraInfo = false;
    }
    getVendor() {
        return "MetaMask";
    }
    hasOnDevicePinEntry() {
        return false;
    }
    hasOnDevicePassphrase() {
        return true;
    }
    hasOnDeviceDisplay() {
        return true;
    }
    hasOnDeviceRecovery() {
        return true;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    hasNativeShapeShift(srcCoin, dstCoin) {
        return false;
    }
    supportsBip44Accounts() {
        return false;
    }
    supportsOfflineSigning() {
        return false;
    }
    supportsBroadcast() {
        return true;
    }
    describePath(msg) {
        switch (msg.coin) {
            case "Ethereum":
                return eth.describeETHPath(msg.path);
            default:
                throw new Error("Unsupported path");
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ethNextAccountPath(msg) {
        // TODO: What do we do here?
        return undefined;
    }
    ethSupportsNetwork(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            return chainId === 1;
        });
    }
    ethSupportsSecureTransfer() {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    ethSupportsNativeShapeShift() {
        return false;
    }
    ethSupportsEIP1559() {
        return __awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    ethGetAccountPaths(msg) {
        return eth.ethGetAccountPaths(msg);
    }
}
exports.MetaMaskHDWalletInfo = MetaMaskHDWalletInfo;
class MetaMaskHDWallet {
    constructor(provider) {
        this._supportsETH = true;
        this._supportsETHInfo = true;
        this._supportsBTCInfo = false;
        this._supportsBTC = false;
        this._supportsCosmosInfo = false;
        this._supportsCosmos = false;
        this._supportsEthSwitchChain = true;
        this._supportsAvalanche = true;
        this._supportsOptimism = true;
        this._supportsBSC = true;
        this._supportsPolygon = true;
        this._supportsGnosis = true;
        this._supportsArbitrum = true;
        this._supportsArbitrumNova = true;
        this._supportsOsmosisInfo = false;
        this._supportsOsmosis = false;
        this._supportsBinanceInfo = false;
        this._supportsBinance = false;
        this._supportsDebugLink = false;
        this._isPortis = false;
        this._isMetaMask = true;
        this._supportsRippleInfo = false;
        this._supportsRipple = false;
        this._supportsEosInfo = false;
        this._supportsEos = false;
        this._supportsFioInfo = false;
        this._supportsFio = false;
        this._supportsThorchainInfo = false;
        this._supportsThorchain = false;
        this._supportsSecretInfo = false;
        this._supportsSecret = false;
        this._supportsKava = false;
        this._supportsKavaInfo = false;
        this._supportsTerra = false;
        this._supportsTerraInfo = false;
        this.info = new MetaMaskHDWalletInfo();
        this.provider = provider;
    }
    getFeatures() {
        return __awaiter(this, void 0, void 0, function* () {
            return {};
        });
    }
    isLocked() {
        return __awaiter(this, void 0, void 0, function* () {
            return !this.provider._metamask.isUnlocked();
        });
    }
    getVendor() {
        return "MetaMask";
    }
    getModel() {
        return __awaiter(this, void 0, void 0, function* () {
            return "MetaMask";
        });
    }
    getLabel() {
        return __awaiter(this, void 0, void 0, function* () {
            return "MetaMask";
        });
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            // nothing to initialize
        });
    }
    hasOnDevicePinEntry() {
        return this.info.hasOnDevicePinEntry();
    }
    hasOnDevicePassphrase() {
        return this.info.hasOnDevicePassphrase();
    }
    hasOnDeviceDisplay() {
        return this.info.hasOnDeviceDisplay();
    }
    hasOnDeviceRecovery() {
        return this.info.hasOnDeviceRecovery();
    }
    hasNativeShapeShift(srcCoin, dstCoin) {
        return this.info.hasNativeShapeShift(srcCoin, dstCoin);
    }
    supportsBip44Accounts() {
        return this.info.supportsBip44Accounts();
    }
    supportsOfflineSigning() {
        return false;
    }
    supportsBroadcast() {
        return true;
    }
    clearSession() {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Can we lock MetaMask from here?
        });
    }
    ping(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            // no ping function for MetaMask, so just returning Core.Pong
            return { msg: msg.msg };
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sendPin(pin) {
        return __awaiter(this, void 0, void 0, function* () {
            // no concept of pin in MetaMask
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sendPassphrase(passphrase) {
        return __awaiter(this, void 0, void 0, function* () {
            // cannot send passphrase to MetaMask. Could show the widget?
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sendCharacter(charater) {
        return __awaiter(this, void 0, void 0, function* () {
            // no concept of sendCharacter in MetaMask
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sendWord(word) {
        return __awaiter(this, void 0, void 0, function* () {
            // no concept of sendWord in MetaMask
        });
    }
    cancel() {
        return __awaiter(this, void 0, void 0, function* () {
            // no concept of cancel in MetaMask
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    wipe() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
    reset(msg) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    recover(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            // no concept of recover in MetaMask
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    loadDevice(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Does MetaMask allow this to be done programatically?
        });
    }
    describePath(msg) {
        return this.info.describePath(msg);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getPublicKeys(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ethereum public keys are not exposed by the RPC API
            return [];
        });
    }
    isInitialized() {
        return __awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    ethSupportsNetwork(chainId = 1) {
        return __awaiter(this, void 0, void 0, function* () {
            return chainId === 1;
        });
    }
    ethGetChainId() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // chainId as hex string
                const chainId = yield this.provider.request({ method: "eth_chainId" });
                return parseInt(chainId, 16);
            }
            catch (e) {
                console.error(e);
                return null;
            }
        });
    }
    ethAddChain(params) {
        return __awaiter(this, void 0, void 0, function* () {
            // at this point, we know that we're in the context of a valid MetaMask provider
            yield this.provider.request({ method: "wallet_addEthereumChain", params: [params] });
        });
    }
    ethSwitchChain(params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // at this point, we know that we're in the context of a valid MetaMask provider
                yield this.provider.request({ method: "wallet_switchEthereumChain", params: [{ chainId: params.chainId }] });
            }
            catch (e) {
                const error = (0, eth_rpc_errors_1.serializeError)(e);
                // https://docs.metamask.io/guide/ethereum-provider.html#errors
                // Internal error, which in the case of wallet_switchEthereumChain call means the chain isn't currently added to the wallet
                if (error.code === -32603) {
                    // We only support Avalanche C-Chain currently. It is supported natively in XDEFI, and unsupported in Tally, both with no capabilities to add a new chain
                    // TODO(gomes): Find a better home for these. When that's done, we'll want to call ethSwitchChain with (params: AddEthereumChainParameter) instead
                    try {
                        yield this.ethAddChain(params);
                        return;
                    }
                    catch (addChainE) {
                        const addChainError = (0, eth_rpc_errors_1.serializeError)(addChainE);
                        if (addChainError.code === 4001) {
                            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest();
                        }
                        throw addChainError.data.originalError;
                    }
                }
                if (error.code === 4001) {
                    throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest();
                }
                throw error.data.originalError;
            }
        });
    }
    ethSupportsSecureTransfer() {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    ethSupportsNativeShapeShift() {
        return false;
    }
    ethSupportsEIP1559() {
        return __awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    ethGetAccountPaths(msg) {
        return eth.ethGetAccountPaths(msg);
    }
    ethNextAccountPath(msg) {
        return this.info.ethNextAccountPath(msg);
    }
    // TODO: Respect msg.addressNList!
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ethGetAddress(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.ethAddress) {
                return this.ethAddress;
            }
            const address = yield eth.ethGetAddress(this.provider);
            if (address) {
                this.ethAddress = address;
                return address;
            }
            else {
                this.ethAddress = null;
                return null;
            }
        });
    }
    ethSignTx(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.ethGetAddress(this.provider);
            return address ? eth.ethSignTx(msg, this.provider, address) : null;
        });
    }
    ethSendTx(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.ethGetAddress(this.provider);
            return address ? eth.ethSendTx(msg, this.provider, address) : null;
        });
    }
    ethSignMessage(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.ethGetAddress(this.provider);
            return address ? eth.ethSignMessage(msg, this.provider, address) : null;
        });
    }
    ethVerifyMessage(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return eth.ethVerifyMessage(msg, this.provider);
        });
    }
    getDeviceID() {
        return __awaiter(this, void 0, void 0, function* () {
            return "metaMask:" + (yield this.ethGetAddress(this.provider));
        });
    }
    getFirmwareVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            return "metaMask";
        });
    }
}
exports.MetaMaskHDWallet = MetaMaskHDWallet;
//# sourceMappingURL=metamask.js.map