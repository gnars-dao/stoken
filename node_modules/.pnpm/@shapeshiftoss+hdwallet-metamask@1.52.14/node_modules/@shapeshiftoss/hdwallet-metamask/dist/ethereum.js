"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ethGetAddress = exports.ethSignMessage = exports.ethSendTx = exports.ethSignTx = exports.ethGetAccountPaths = exports.ethVerifyMessage = exports.describeETHPath = void 0;
const core = __importStar(require("@shapeshiftoss/hdwallet-core"));
const utils_1 = require("ethers/lib/utils");
function describeETHPath(path) {
    const pathStr = core.addressNListToBIP32(path);
    const unknown = {
        verbose: pathStr,
        coin: "Ethereum",
        isKnown: false,
    };
    if (path.length !== 5)
        return unknown;
    if (path[0] !== 0x80000000 + 44)
        return unknown;
    if (path[1] !== 0x80000000 + core.slip44ByCoin("Ethereum"))
        return unknown;
    if ((path[2] & 0x80000000) >>> 0 !== 0x80000000)
        return unknown;
    if (path[3] !== 0)
        return unknown;
    if (path[4] !== 0)
        return unknown;
    const index = path[2] & 0x7fffffff;
    return {
        verbose: `Ethereum Account #${index}`,
        accountIdx: index,
        wholeAccount: true,
        coin: "Ethereum",
        isKnown: true,
    };
}
exports.describeETHPath = describeETHPath;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function ethVerifyMessage(msg, ethereum) {
    return __awaiter(this, void 0, void 0, function* () {
        console.error("Method ethVerifyMessage unsupported for MetaMask wallet!");
        return null;
    });
}
exports.ethVerifyMessage = ethVerifyMessage;
function ethGetAccountPaths(msg) {
    const slip44 = core.slip44ByCoin(msg.coin);
    if (slip44 === undefined)
        return [];
    return [
        {
            addressNList: [0x80000000 + 44, 0x80000000 + slip44, 0x80000000 + msg.accountIdx, 0, 0],
            hardenedPath: [0x80000000 + 44, 0x80000000 + slip44, 0x80000000 + msg.accountIdx],
            relPath: [0, 0],
            description: "MetaMask",
        },
    ];
}
exports.ethGetAccountPaths = ethGetAccountPaths;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function ethSignTx(msg, ethereum, from) {
    return __awaiter(this, void 0, void 0, function* () {
        console.error("Method ethSignTx unsupported for MetaMask wallet!");
        return null;
    });
}
exports.ethSignTx = ethSignTx;
function ethSendTx(msg, ethereum, from) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const utxBase = {
                from: from,
                to: msg.to,
                value: msg.value,
                data: msg.data,
                chainId: msg.chainId,
                nonce: msg.nonce,
                // MetaMask, like other Web3 libraries, derives its transaction schema from Ethereum's official JSON-RPC API specification
                // (https://github.com/ethereum/execution-apis/blob/d63d2a02bcd2a8cef54ae2fc5bbff8b4fac944eb/src/schemas/transaction.json).
                // That schema defines the use of the label `gas` to set the transaction's gas limit and not `gasLimit` as used in other
                // libraries and as stated in the official yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf).
                gas: msg.gasLimit,
            };
            const utx = msg.maxFeePerGas
                ? Object.assign(Object.assign({}, utxBase), { maxFeePerGas: msg.maxFeePerGas, maxPriorityFeePerGas: msg.maxPriorityFeePerGas }) : Object.assign(Object.assign({}, utxBase), { gasPrice: msg.gasPrice });
            const signedTx = yield ethereum.request({
                method: "eth_sendTransaction",
                params: [utx],
            });
            return {
                hash: signedTx,
            };
        }
        catch (error) {
            console.error(error);
            return null;
        }
    });
}
exports.ethSendTx = ethSendTx;
function ethSignMessage(msg, ethereum, address) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (!(0, utils_1.isHexString)(msg.message))
                throw new Error("data is not an hex string");
            const signedMsg = yield ethereum.request({
                method: "personal_sign",
                params: [msg.message, address],
            });
            return {
                address: address,
                signature: signedMsg,
            };
        }
        catch (error) {
            console.error(error);
            return null;
        }
    });
}
exports.ethSignMessage = ethSignMessage;
function ethGetAddress(ethereum) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!(ethereum && ethereum.request)) {
            return null;
        }
        try {
            const ethAccounts = yield ethereum.request({
                method: "eth_accounts",
            });
            return ethAccounts[0];
        }
        catch (error) {
            console.error(error);
            return null;
        }
    });
}
exports.ethGetAddress = ethGetAddress;
//# sourceMappingURL=ethereum.js.map