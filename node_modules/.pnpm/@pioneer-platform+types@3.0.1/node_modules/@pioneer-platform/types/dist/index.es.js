var C = Object.defineProperty;
var O = (e, n, a) => n in e ? C(e, n, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[n] = a;
var s = (e, n, a) => (O(e, typeof n != "symbol" ? n + "" : n, a), a);
const F = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !0, internalType: "address", name: "spender", type: "address" },
      { indexed: !1, internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "from", type: "address" },
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "success", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "success", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "success", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  }
], X = [
  {
    inputs: [{ internalType: "address", name: "rune", type: "address" }],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !0, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "Deposit",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferAllowance",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOut",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !1, internalType: "address", name: "target", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "address", name: "finalAsset", type: "address" },
      { indexed: !1, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOutAndCall",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        indexed: !1,
        internalType: "struct THORChain_Router.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "VaultTransfer",
    type: "event"
  },
  {
    inputs: [],
    name: "RUNE",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "deposit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" },
      { internalType: "uint256", name: "expiration", type: "uint256" }
    ],
    name: "depositWithExpiry",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address payable", name: "asgard", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        internalType: "struct THORChain_Router.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "returnVaultAssets",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address", name: "newVault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferAllowance",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "to", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "aggregator", type: "address" },
      { internalType: "address", name: "finalToken", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOutAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "vault", type: "address" },
      { internalType: "address", name: "token", type: "address" }
    ],
    name: "vaultAllowance",
    outputs: [{ internalType: "uint256", name: "amount", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  }
], K = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !0, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "Deposit",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferAllowance",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOut",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !1, internalType: "address", name: "target", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "address", name: "finalAsset", type: "address" },
      { indexed: !1, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOutAndCall",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        indexed: !1,
        internalType: "struct AvaxRouter.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "VaultTransfer",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "deposit",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" },
      { internalType: "uint256", name: "expiration", type: "uint256" }
    ],
    name: "depositWithExpiry",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address payable", name: "asgard", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        internalType: "struct AvaxRouter.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "returnVaultAssets",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address", name: "newVault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferAllowance",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "to", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "target", type: "address" },
      { internalType: "address", name: "finalToken", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOutAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "vault", type: "address" },
      { internalType: "address", name: "token", type: "address" }
    ],
    name: "vaultAllowance",
    outputs: [{ internalType: "uint256", name: "amount", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  }
], W = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !0, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "Deposit",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferAllowance",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "address", name: "asset", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOut",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "vault", type: "address" },
      { indexed: !1, internalType: "address", name: "target", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amount", type: "uint256" },
      { indexed: !1, internalType: "address", name: "finalAsset", type: "address" },
      { indexed: !1, internalType: "address", name: "to", type: "address" },
      { indexed: !1, internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "TransferOutAndCall",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "oldVault", type: "address" },
      { indexed: !0, internalType: "address", name: "newVault", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        indexed: !1,
        internalType: "struct THORChain_Router.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { indexed: !1, internalType: "string", name: "memo", type: "string" }
    ],
    name: "VaultTransfer",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address payable", name: "vault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" },
      { internalType: "uint256", name: "expiration", type: "uint256" }
    ],
    name: "depositWithExpiry",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address payable", name: "asgard", type: "address" },
      {
        components: [
          { internalType: "address", name: "asset", type: "address" },
          { internalType: "uint256", name: "amount", type: "uint256" }
        ],
        internalType: "struct THORChain_Router.Coin[]",
        name: "coins",
        type: "tuple[]"
      },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "returnVaultAssets",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "router", type: "address" },
      { internalType: "address", name: "newVault", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferAllowance",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "to", type: "address" },
      { internalType: "address", name: "asset", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOut",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address payable", name: "target", type: "address" },
      { internalType: "address", name: "finalToken", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "string", name: "memo", type: "string" }
    ],
    name: "transferOutAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "vault", type: "address" },
      { internalType: "address", name: "token", type: "address" }
    ],
    name: "vaultAllowance",
    outputs: [{ internalType: "uint256", name: "amount", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  }
];
var P = /* @__PURE__ */ ((e) => (e.THOR = "THOR", e.RUNE = "RUNE", e.ATOM = "ATOM", e.MUON = "MUON", e.USDC = "USDC", e))(P || {}), g = /* @__PURE__ */ ((e) => (e.TC_SUPPORTED_TO_TC_SUPPORTED = "TC-TC", e.TC_SUPPORTED_TO_ETH = "TC-ERC20", e.TC_SUPPORTED_TO_AVAX = "TC-ARC20", e.TC_SUPPORTED_TO_BSC = "TC-BEP20", e.ETH_TO_TC_SUPPORTED = "ERC20-TC", e.ETH_TO_ETH = "ERC20-ERC20", e.ETH_TO_AVAX = "ERC20-ARC20", e.ETH_TO_BSC = "ERC20-BEP20", e.AVAX_TO_TC_SUPPORTED = "ARC20-TC", e.AVAX_TO_ETH = "ARC20-ERC20", e.AVAX_TO_AVAX = "ARC20-ARC20", e.AVAX_TO_BSC = "ARC20-BEP20", e.BSC_TO_TC_SUPPORTED = "BEP20-TC", e.BSC_TO_ETH = "BEP20-ERC20", e.BSC_TO_AVAX = "BEP20-ARC20", e.BSC_TO_BSC = "BEP20-BEP20", e))(g || {});
const Y = [
  "ERC20-ERC20",
  "ARC20-ARC20",
  "BEP20-BEP20"
  /* BSC_TO_BSC */
], k = [
  "ERC20-TC",
  "ERC20-ARC20",
  "ERC20-BEP20",
  "ARC20-TC",
  "ARC20-ERC20",
  "ARC20-BEP20",
  "BEP20-TC",
  "BEP20-ERC20",
  "BEP20-ARC20"
  /* BSC_TO_AVAX */
], $ = [
  "TC-TC",
  "TC-ERC20",
  "TC-ARC20",
  "TC-BEP20"
  /* TC_SUPPORTED_TO_BSC */
];
var m = /* @__PURE__ */ ((e) => (e.VALIDATION_ERROR = "VALIDATION_ERROR", e.REQUEST_PARAMETER_ERROR = "REQUEST_PARAMETER_ERROR", e.RESPONSE_PARSING_ERROR = "RESPONSE_PARSING_ERROR", e.UNSUPPORTED = "UNSUPPORTED", e.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", e.INCOMPATIBLE_ASSETS_OPERATIONS = "INCOMPATIBLE_ASSETS_OPERATIONS", e.SERVICE_UNAVAILABLE = "SERVICE_UNAVAILABLE", e.DOWN_FOR_MAINTENANCE = "DOWN_FOR_MAINTENANCE", e.MISSING_INBOUND_INFO = "MISSING_INBOUND_INFO", e.QUOTE_FETCHING_ERROR = "QUOTE_FETCHING_ERROR", e.AIRDROP_ERROR = "AIRDROP_ERROR", e.UNHANDLED_ERROR = "UNHANDLED_ERROR", e))(m || {}), B = /* @__PURE__ */ ((e) => (e.HEALTH_CONTROLLER = "1000", e.LIQUIDITY_CONTROLLER = "1001", e.PROVIDER_CONTROLLER = "1002", e.QUOTE_CONTROLLER = "1003", e.SWAP_CONTROLLER = "1004", e.UTIL_CONTROLLER = "1005", e.AIRDROP_CONTROLLER = "1006", e.PROVIDER = "2000", e.ASSET = "2001", e.TOKEN_LIST = "2002", e.QUOTE = "2100", e.QUOTE_TXN_DETAILS = "2101", e.THORCHAIN_PROVIDER = "3000", e.UNISWAPV2_ETH_PROVIDER = "3001", e.UNISWAPV3_ETH_PROVIDER = "3002", e.SUSHISWAP_ETH_PROVIDER = "3003", e.PANCAKESWAP_BSC_PROVIDER = "3004", e.PANCAKESWAP_ETH_PROVIDER = "3005", e.ONEINCH_ETH_PROVIDER = "3006", e.ONEINCH_BSC_PROVIDER = "3007", e.ONEINCH_AVAX_PROVIDER = "3008", e.ZEROX_ETH_PROVIDER = "3009", e.WOOFI_AVAX_PROVIDER = "3010", e.PANGOLIN_AVAX_PROVIDER = "3011", e.TRADERJOE_AVAX_PROVIDER = "3012", e.KYBER_ETH_PROVIDER = "3013", e.KYBER_AVAX_PROVIDER = "3014", e.WOOFI_BSC_PROVIDER = "3015", e.STARGATE_PROVIDER = "3016", e.PROVIDER_UTIL = "4000", e.TXN_DETAILS = "5000", e.AIRDROP_UTIL = "6000", e))(B || {}), t = /* @__PURE__ */ ((e) => (e.INVALID_INPUT_PARAMETERS = "1000", e.UNKNOWN_PROVIDERS = "1001", e.CANNOT_FIND_INBOUND_ADDRESS = "1002", e.NO_INBOUND_ADDRESSES = "1003", e.CHAIN_HALTED_OR_UNSUPPORTED = "1004", e.MISSING_INPUT_PARAMETER = "1005", e.INVALID_TYPE_GENERIC = "1100", e.INVALID_NUMBER_STRING = "1101", e.INVALID_NUMBER = "1102", e.INVALID_BOOLEAN = "1103", e.INVALID_OBJECT = "1104", e.INVALID_ARRAY = "1105", e.SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2000", e.SELL_BUY_ASSETS_ARE_THE_SAME = "2001", e.MISSING_SOURCE_ADDRESS_FOR_SYNTH = "2002", e.AFF_ADDRESS_AND_BPS_OR_NEITHER = "2003", e.AFF_ADDRESS_TOO_LONG = "2004", e.AFF_BPS_INTEGER_0_100 = "2005", e.SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN = "2006", e.DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN = "2007", e.PREFERRED_PROFVIDER_NOT_SUPPORTED = "2008", e.DESTINATION_ADDRESS_SMART_CONTRACT = "2009", e.BUY_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2010", e.SOURCE_ADDRESS_SMART_CONTRACT = "2011", e.INVALID_PROVIDER = "2100", e.MISSING_CROSS_CHAIN_PROVIDER = "2101", e.MISSING_AVAX_PROVIDER = "2102", e.MISSING_BSC_PROVIDER = "2103", e.MISSING_ETH_PROVIDER = "2104", e.INVALID_PROVIDER_FOR_SWAP_OUT = "2105", e.MISSING_ARB_PROVIDER = "2106", e.INVALID_CHAIN = "2200", e.INVALID_ASSET = "2201", e.INVALID_ASSET_IDENTIFIER = "2202", e.UNSUPPORTED_CHAIN = "2204", e.UNSUPPORTED_ASSET = "2203", e.UNSUPPORTED_ASSET_FOR_SWAPOUT = "2205", e.THORNODE_QUOTE_GENERIC_ERROR = "3000", e.NOT_ENOUGH_SYNTH_BALANCE = "3001", e.SYNTH_MINTING_CAP_REACHED = "3002", e.INVALID_QUOTE_MODE = "4000", e.NO_QUOTES = "4001", e.SERVICE_UNAVAILABLE_GENERIC = "5000", e.MISSING_GAS_DATA_GENERIC = "5100", e.MISSING_TOKEN_INFO_GENERIC = "5200", e.CANT_FIND_TOKEN_LIST = "5201", e.NO_PRICE = "5202", e.PRICE_IS_STALE = "5203", e.ADDRESS_NOT_WHITELISTED = "6000", e.ADDRESS_ALREADY_CLAIMED = "6001", e.TEMPORARY_ERROR = "9999", e))(t || {});
const V = {
  [t.INVALID_INPUT_PARAMETERS]: "Invalid input parameters: {0}.",
  [t.UNKNOWN_PROVIDERS]: "Unknown providers: {0}.",
  [t.CANNOT_FIND_INBOUND_ADDRESS]: "Cannot find inbound address.",
  [t.NO_INBOUND_ADDRESSES]: "No inbound addresses.",
  [t.CHAIN_HALTED_OR_UNSUPPORTED]: "Chain {0} halted or unsupported.",
  [t.MISSING_INPUT_PARAMETER]: "Missing input parameter: {0}.",
  [t.INVALID_TYPE_GENERIC]: "Invalid type",
  [t.INVALID_NUMBER_STRING]: "Invalid number string.",
  [t.INVALID_NUMBER]: "Invalid number.",
  [t.INVALID_BOOLEAN]: "Invalid boolean.",
  [t.INVALID_OBJECT]: "Invalid object.",
  [t.INVALID_ARRAY]: "Invalid array.",
  [t.SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER]: "Sell amount must be a positive integer.",
  [t.SELL_BUY_ASSETS_ARE_THE_SAME]: "Sell and buy assets are the same.",
  [t.MISSING_SOURCE_ADDRESS_FOR_SYNTH]: "Source address is required for synth quote.",
  [t.AFF_ADDRESS_AND_BPS_OR_NEITHER]: "Must provide affiliateAddress and affiliateBasisPoints params, or neither.",
  [t.AFF_ADDRESS_TOO_LONG]: "affiliateAddress too long: 3 characters max.",
  [t.AFF_BPS_INTEGER_0_100]: "affiliateBasisPoints must be an integer between 0 and 100.",
  [t.SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN]: "Source address {0} invalid for sell chain.",
  [t.DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN]: "Destination address {0} invalid for buy chain.",
  [t.PREFERRED_PROFVIDER_NOT_SUPPORTED]: "Preferred provider not supported.",
  [t.DESTINATION_ADDRESS_SMART_CONTRACT]: "Destination address is a smart contract.",
  [t.BUY_AMOUNT_MUST_BE_POSITIVE_INTEGER]: "Buy amount must be a positive integer.",
  [t.INVALID_PROVIDER]: "Invalid provider {0}.",
  [t.MISSING_CROSS_CHAIN_PROVIDER]: "Missing cross-chain provider.",
  [t.MISSING_AVAX_PROVIDER]: "Missing AVAX provider.",
  [t.MISSING_BSC_PROVIDER]: "Missing BSC provider.",
  [t.MISSING_ETH_PROVIDER]: "Missing ETH provider.",
  [t.MISSING_ARB_PROVIDER]: "Missing ARB provider.",
  [t.INVALID_PROVIDER_FOR_SWAP_OUT]: "Invalid provider for swap out.",
  [t.INVALID_CHAIN]: "Invalid chain {0}.",
  [t.INVALID_ASSET]: "Invalid asset {0}.",
  [t.UNSUPPORTED_CHAIN]: "Unsupported chain {0}.",
  [t.UNSUPPORTED_ASSET]: "Unsupported asset {0}.",
  [t.UNSUPPORTED_ASSET_FOR_SWAPOUT]: "Unsupported asset {0} for swap out.",
  [t.THORNODE_QUOTE_GENERIC_ERROR]: "ThorNode quote generic error.",
  [t.NOT_ENOUGH_SYNTH_BALANCE]: "Source address doesn't have enough synth balance for this quote.",
  [t.SYNTH_MINTING_CAP_REACHED]: "Synth minting cap reached.",
  [t.INVALID_QUOTE_MODE]: "Invalid quote mode.",
  [t.NO_QUOTES]: "No quotes to service this request.",
  [t.SERVICE_UNAVAILABLE_GENERIC]: "Service unavailable.",
  [t.MISSING_GAS_DATA_GENERIC]: "Missing gas data.",
  [t.MISSING_TOKEN_INFO_GENERIC]: "Missing token info.",
  [t.CANT_FIND_TOKEN_LIST]: "Can't find tokenlist {0}.",
  [t.NO_PRICE]: "No price for asset {0}.",
  [t.PRICE_IS_STALE]: "Price is stale for asset {0}.",
  [t.ADDRESS_NOT_WHITELISTED]: "Address {0} not whitelisted for airdrop.",
  [t.ADDRESS_ALREADY_CLAIMED]: "Address {0} already claimed the airdrop."
}, u = (e, n) => {
  let a = V[e];
  for (let r = 0; r < n.length; r++)
    a = a.replace(`{${r}}`, n[r]);
  return n.length === 0 ? a.replace("{0}", "") : a;
};
class A extends Error {
  constructor({
    status: a,
    revision: r,
    module: I,
    code: d,
    message: N,
    type: S,
    options: { shouldLog: E, shouldThrow: c, shouldTrace: f } = {
      shouldLog: !0,
      shouldThrow: !0,
      shouldTrace: !0
    },
    displayMessageParams: y
  }) {
    const l = N || u(d, y || []) || "";
    super(l);
    s(this, "status");
    s(this, "revision");
    s(this, "type");
    s(this, "module");
    s(this, "code");
    s(this, "message");
    s(this, "display");
    s(this, "stack");
    s(this, "options");
    s(this, "displayMessageParams");
    this.status = a, this.revision = r || "NO_REVISION", this.module = I, this.message = l, this.display = u(d, y || []), this.code = d, this.type = S || m.UNHANDLED_ERROR, this.options = {
      shouldLog: E || !0,
      shouldTrace: f || !0,
      shouldThrow: c || !1
    }, this.displayMessageParams = y || [], this.options.shouldTrace && Error.captureStackTrace(this);
  }
  static fromErrorInfo(a) {
    return new A(a);
  }
  toErrorInfo() {
    return { ...this, identifier: this.identifier };
  }
  get identifier() {
    return `${this.revision}-${this.type || "NO_TYPE"}-${this.module}-${this.code}`;
  }
  get displayMessage() {
    return u(this.code, this.displayMessageParams || []);
  }
  handle() {
    const a = `[${this.identifier}]: ${this.message}`;
    if (this.options.shouldLog && console.error(a, `
`, this.stack || ""), this.options.shouldThrow)
      throw Error(a, { cause: this.stack });
    return this.toErrorInfo();
  }
}
var i = /* @__PURE__ */ ((e) => (e.Arbitrum = "ARB", e.Avalanche = "AVAX", e.Binance = "BNB", e.BinanceSmartChain = "BSC", e.Bitcoin = "BTC", e.BitcoinCash = "BCH", e.Cosmos = "GAIA", e.Dogecoin = "DOGE", e.Ethereum = "ETH", e.Litecoin = "LTC", e.Optimism = "OP", e.Polygon = "MATIC", e.THORChain = "THOR", e))(i || {}), h = /* @__PURE__ */ ((e) => (e.ARB = "0x0000000000000000000000000000000000000000", e.AVAX = "0x0000000000000000000000000000000000000000", e.ETH = "0x0000000000000000000000000000000000000000", e.BSC = "0x0000000000000000000000000000000000000000", e.MATIC = "0x0000000000000000000000000000000000001010", e.OP = "0x4200000000000000000000000000000000000042", e))(h || {}), x = /* @__PURE__ */ ((e) => (e[e.Ethereum = 60] = "Ethereum", e[e.Binance = 714] = "Binance", e[e.THORChain = 931] = "THORChain", e))(x || {}), H = /* @__PURE__ */ ((e) => (e.ARB = "m/44'/60'/0'/0", e.AVAX = "m/44'/60'/0'/0", e.BCH = "m/44'/145'/0'/0", e.BNB = "m/44'/714'/0'/0", e.BSC = "m/44'/60'/0'/0", e.BTC = "m/84'/0'/0'/0", e.DOGE = "m/44'/3'/0'/0", e.ETH = "m/44'/60'/0'/0", e.GAIA = "m/44'/118'/0'/0", e.LTC = "m/84'/2'/0'/0", e.MATIC = "m/44'/60'/0'/0", e.OP = "m/44'/60'/0'/0", e.THOR = "m/44'/931'/0'/0", e))(H || {});
const q = {
  ARB: [44, 60, 0, 0, 0],
  AVAX: [44, 60, 0, 0, 0],
  BCH: [44, 145, 0, 0, 0],
  BNB: [44, 714, 0, 0, 0],
  BSC: [44, 60, 0, 0, 0],
  BTC: [84, 0, 0, 0, 0],
  DOGE: [44, 3, 0, 0, 0],
  ETH: [44, 60, 0, 0, 0],
  GAIA: [44, 118, 0, 0, 0],
  LTC: [84, 2, 0, 0, 0],
  MATIC: [44, 60, 0, 0, 0],
  OP: [44, 60, 0, 0, 0],
  THOR: [44, 931, 0, 0, 0]
};
var b = /* @__PURE__ */ ((e) => (e[e.ARB = 18] = "ARB", e[e.AVAX = 18] = "AVAX", e[e.BCH = 8] = "BCH", e[e.BNB = 8] = "BNB", e[e.BSC = 18] = "BSC", e[e.BTC = 8] = "BTC", e[e.DOGE = 8] = "DOGE", e[e.ETH = 18] = "ETH", e[e.GAIA = 6] = "GAIA", e[e.LTC = 8] = "LTC", e[e.MATIC = 18] = "MATIC", e[e.OP = 18] = "OP", e[e.THOR = 8] = "THOR", e))(b || {});
const j = [
  "ETH",
  "AVAX",
  "BSC",
  "ARB",
  "OP",
  "MATIC"
  /* Polygon */
], J = [
  "BTC",
  "BCH",
  "DOGE",
  "LTC"
  /* Litecoin */
], Z = [
  "GAIA",
  "THOR",
  "BNB"
  /* Binance */
];
var T = /* @__PURE__ */ ((e) => (e.Arbitrum = "42161", e.ArbitrumHex = "0xa4b1", e.Avalanche = "43114", e.AvalancheHex = "0xa86a", e.Binance = "Binance-Chain-Tigris", e.BinanceHex = "", e.BinanceSmartChain = "56", e.BinanceSmartChainHex = "0x38", e.Bitcoin = "bitcoin", e.BitcoinHex = "", e.BitcoinCash = "bitcoincash", e.BitcoinCashHex = "", e.Cosmos = "cosmoshub-4", e.CosmosHex = "", e.Dogecoin = "dogecoin", e.DogecoinHex = "", e.Ethereum = "1", e.EthereumHex = "0x1", e.Litecoin = "litecoin", e.LitecoinHex = "", e.Optimism = "10", e.OptimismHex = "0xa", e.Polygon = "137", e.PolygonHex = "0x89", e.THORChain = "thorchain-mainnet-v1", e.THORChainHex = "", e.THORChainStagenet = "thorchain-stagenet-v2", e))(T || {}), _ = /* @__PURE__ */ ((e) => (e.Arbitrum = "https://arb1.arbitrum.io/rpc", e.Avalanche = "https://node-router.thorswap.net/avalanche-c", e.Binance = "", e.BinanceSmartChain = "https://bsc-dataseed.binance.org", e.Bitcoin = "https://node-router.thorswap.net/bitcoin", e.BitcoinCash = "https://node-router.thorswap.net/bitcoin-cash", e.Cosmos = "https://node-router.thorswap.net/cosmos/rpc", e.Dogecoin = "https://node-router.thorswap.net/dogecoin", e.Ethereum = "https://node-router.thorswap.net/ethereum", e.Litecoin = "https://node-router.thorswap.net/litecoin", e.Optimism = "https://mainnet.optimism.io", e.Polygon = "https://polygon-rpc.com", e.THORChain = "https://rpc.thorswap.net", e.THORChainStagenet = "https://stagenet-rpc.ninerealms.com", e))(_ || {}), R = /* @__PURE__ */ ((e) => (e.Cosmos = "https://node-router.thorswap.net/cosmos/rest", e.ThornodeMainnet = "https://thornode.thorswap.net", e.ThornodeStagenet = "https://stagenet-thornode.ninerealms.com", e.ThorswapApi = "https://api.thorswap.finance", e.ThorswapStatic = "https://static.thorswap.net", e))(R || {});
const p = Object.values(i), v = Object.keys(i), o = p.reduce(
  (e, n) => {
    const a = v.find((r) => i[r] === n);
    return a && (e[n] = a), e;
  },
  {}
), z = p.reduce(
  (e, n) => (e[n] = T[o[n]], e),
  {}
), Q = p.reduce(
  (e, n) => (e[n] = _[o[n]], e),
  {}
), ee = p.reduce(
  (e, n) => (e[n] = T[`${o[n]}Hex`], e),
  {}
), te = {
  42161: "ARB",
  "0xa4b1": "ARB",
  "0xa86a": "AVAX",
  43114: "AVAX",
  "Binance-Chain-Tigris": "BNB",
  56: "BSC",
  "0x38": "BSC",
  bitcoin: "BTC",
  bitcoincash: "BCH",
  "cosmoshub-4": "GAIA",
  dogecoin: "DOGE",
  "0x1": "ETH",
  1: "ETH",
  litecoin: "LTC",
  "thorchain-mainnet-v1": "THOR",
  "": "THOR",
  "thorchain-stagenet-v2": "THOR",
  10: "OP",
  "0xa": "OP",
  137: "MATIC",
  "0x89": "MATIC"
  /* Polygon */
}, ne = {
  ARB: "https://arbiscan.io",
  AVAX: "https://snowtrace.io",
  BSC: "https://bscscan.com",
  BNB: "https://explorer.binance.org",
  BCH: "https://www.blockchain.com/bch",
  BTC: "https://blockstream.info",
  GAIA: "https://cosmos.bigdipper.live",
  DOGE: "https://blockchair.com/dogecoin",
  ETH: "https://etherscan.io",
  LTC: "https://ltc.bitaps.com",
  OP: "https://optimistic.etherscan.io",
  MATIC: "https://polygonscan.com",
  THOR: "https://viewblock.io/thorchain"
};
var L = /* @__PURE__ */ ((e) => (e[e.NoError = 36864] = "NoError", e))(L || {}), D = /* @__PURE__ */ ((e) => (e.BOND = "BOND", e.DEPOSIT = "+", e.LEAVE = "LEAVE", e.THORNAME_REGISTER = "~", e.UNBOND = "UNBOND", e.WITHDRAW = "-", e.OPEN_LOAN = "$+", e.CLOSE_LOAN = "$-", e))(D || {});
const ae = "image rally need wedding health address purse army antenna leopard sea gain";
var M = /* @__PURE__ */ ((e) => (e[e.NotInstalled = 0] = "NotInstalled", e[e.Detected = 1] = "Detected", e))(M || {}), G = /* @__PURE__ */ ((e) => (e.Average = "average", e.Fast = "fast", e.Fastest = "fastest", e))(G || {}), U = /* @__PURE__ */ ((e) => (e.KEYSTORE = "KEYSTORE", e.XDEFI = "XDEFI", e.METAMASK = "METAMASK", e.COINBASE_WEB = "COINBASE_WEB", e.TREZOR = "TREZOR", e.KEEPKEY = "KEEPKEY", e.TRUSTWALLET_WEB = "TRUSTWALLET_WEB", e.LEDGER = "LEDGER", e.KEPLR = "KEPLR", e.OKX = "OKX", e.BRAVE = "BRAVE", e.WALLETCONNECT = "WALLETCONNECT", e))(U || {});
export {
  Y as AGG_SWAP,
  A as ApiError,
  R as ApiUrl,
  P as AssetSymbol,
  b as BaseDecimal,
  i as Chain,
  T as ChainId,
  te as ChainIdToChain,
  z as ChainToChainId,
  ne as ChainToExplorerUrl,
  ee as ChainToHexChainId,
  Q as ChainToRPC,
  h as ContractAddress,
  Z as CosmosChainList,
  H as DerivationPath,
  t as ERROR_CODE,
  B as ERROR_MODULE,
  m as ERROR_TYPE,
  j as EVMChainList,
  L as ErrorCode,
  G as FeeOption,
  ae as MOCK_PHRASE,
  D as MemoType,
  q as NetworkDerivationPath,
  x as NetworkId,
  g as QuoteMode,
  _ as RPCUrl,
  k as SWAP_IN,
  $ as SWAP_OUT,
  K as TCAvalancheDepositABI,
  W as TCBscDepositABI,
  X as TCEthereumVaultAbi,
  J as UTXOChainList,
  U as WalletOption,
  M as WalletStatus,
  F as erc20ABI
};
