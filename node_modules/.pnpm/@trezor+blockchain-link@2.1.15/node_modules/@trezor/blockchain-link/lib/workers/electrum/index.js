"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("@trezor/blockchain-link-types/lib/constants/errors");
const constants_1 = require("@trezor/blockchain-link-types/lib/constants");
const baseWorker_1 = require("../baseWorker");
const M = __importStar(require("./methods"));
const L = __importStar(require("./listeners"));
const sockets_1 = require("./sockets");
const caching_1 = require("./client/caching");
const onRequest = async (request) => {
    const client = await request.connect();
    switch (request.type) {
        case constants_1.MESSAGES.GET_INFO:
            return {
                type: constants_1.RESPONSES.GET_INFO,
                payload: await M.getInfo(client),
            };
        case constants_1.MESSAGES.GET_BLOCK_HASH:
            return {
                type: constants_1.RESPONSES.GET_BLOCK_HASH,
                payload: await M.getBlockHash(client, request.payload),
            };
        case constants_1.MESSAGES.GET_ACCOUNT_INFO:
            return {
                type: constants_1.RESPONSES.GET_ACCOUNT_INFO,
                payload: await M.getAccountInfo(client, request.payload),
            };
        case constants_1.MESSAGES.GET_ACCOUNT_UTXO:
            return {
                type: constants_1.RESPONSES.GET_ACCOUNT_UTXO,
                payload: await M.getAccountUtxo(client, request.payload),
            };
        case constants_1.MESSAGES.GET_TRANSACTION:
            return {
                type: constants_1.RESPONSES.GET_TRANSACTION,
                payload: await M.getTransaction(client, request.payload),
            };
        case constants_1.MESSAGES.GET_ACCOUNT_BALANCE_HISTORY:
            return {
                type: constants_1.RESPONSES.GET_ACCOUNT_BALANCE_HISTORY,
                payload: await M.getAccountBalanceHistory(client, request.payload),
            };
        case constants_1.MESSAGES.ESTIMATE_FEE:
            return {
                type: constants_1.RESPONSES.ESTIMATE_FEE,
                payload: await M.estimateFee(client, request.payload),
            };
        case constants_1.MESSAGES.PUSH_TRANSACTION:
            return {
                type: constants_1.RESPONSES.PUSH_TRANSACTION,
                payload: await M.pushTransaction(client, request.payload),
            };
        case constants_1.MESSAGES.SUBSCRIBE:
            switch (request.payload.type) {
                case 'block':
                    return {
                        type: constants_1.RESPONSES.SUBSCRIBE,
                        payload: request.blockListener.subscribe(),
                    };
                case 'addresses':
                case 'accounts':
                    return {
                        type: constants_1.RESPONSES.SUBSCRIBE,
                        payload: await request.txListener.subscribe(request.payload),
                    };
                default:
                    throw new errors_1.CustomError(`Subscription ${request.payload.type} not implemented`);
            }
        case constants_1.MESSAGES.UNSUBSCRIBE:
            switch (request.payload.type) {
                case 'block':
                    return {
                        type: constants_1.RESPONSES.UNSUBSCRIBE,
                        payload: request.blockListener.unsubscribe(),
                    };
                case 'addresses':
                case 'accounts':
                    return {
                        type: constants_1.RESPONSES.UNSUBSCRIBE,
                        payload: await request.txListener.unsubscribe(request.payload),
                    };
                default:
                    throw new errors_1.CustomError(`Subscription ${request.payload.type} not implemented`);
            }
        case 'raw':
            const { method, params } = request.payload;
            return client
                .request(method, ...params)
                .then((res) => ({ type: method, payload: res }));
        default:
            throw new errors_1.CustomError('worker_unknown_request', `+${request.type}`);
    }
};
class ElectrumWorker extends baseWorker_1.BaseWorker {
    constructor() {
        super();
        this.blockListener = L.blockListener(this);
        this.txListener = L.txListener(this);
    }
    isConnected(api) {
        var _a;
        return (_a = api === null || api === void 0 ? void 0 : api.isConnected()) !== null && _a !== void 0 ? _a : false;
    }
    async tryConnect(url) {
        const { debug, timeout, keepAlive, name } = this.settings;
        const socket = (0, sockets_1.createSocket)(url, {
            timeout,
            keepAlive,
            proxyAgent: this.proxyAgent,
        });
        const api = new caching_1.CachingElectrumClient();
        await api.connect(socket, {
            url,
            coin: name !== null && name !== void 0 ? name : 'BTC',
            debug,
            client: {
                name: 'blockchain-link',
                protocolVersion: '1.4',
            },
        });
        this.post({
            id: -1,
            type: constants_1.RESPONSES.CONNECTED,
        });
        return api;
    }
    disconnect() {
        var _a;
        if ((_a = this.api) === null || _a === void 0 ? void 0 : _a.isConnected()) {
            this.api.close();
        }
    }
    cleanup() {
        if (this.api) {
            this.api.close();
        }
        super.cleanup();
    }
    async messageHandler(event) {
        try {
            if (await super.messageHandler(event))
                return true;
            const request = Object.assign(Object.assign({}, event.data), { connect: () => this.connect(), post: (data) => this.post(data), state: this.state, blockListener: this.blockListener, txListener: this.txListener });
            const response = await onRequest(request);
            this.post(Object.assign({ id: event.data.id }, response));
        }
        catch (error) {
            this.errorResponse(event.data.id, error);
        }
    }
}
function Electrum() {
    return new ElectrumWorker();
}
exports.default = Electrum;
if (baseWorker_1.CONTEXT === 'worker') {
    const module = new ElectrumWorker();
    onmessage = module.messageHandler.bind(module);
}
//# sourceMappingURL=index.js.map