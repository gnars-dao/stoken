"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ripple_lib_1 = require("ripple-lib");
const errors_1 = require("ripple-lib/dist/npm/common/errors");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const errors_2 = require("@trezor/blockchain-link-types/lib/constants/errors");
const constants_1 = require("@trezor/blockchain-link-types/lib/constants");
const baseWorker_1 = require("../baseWorker");
const utils = __importStar(require("@trezor/blockchain-link-utils/lib/ripple"));
const DEFAULT_TIMEOUT = 20 * 1000;
const DEFAULT_PING_TIMEOUT = 3 * 60 * 1000;
const RESERVE = {
    BASE: '10000000',
    OWNER: '2000000',
};
const transformError = (error) => {
    if (error instanceof errors_1.RippleError) {
        const code = error.name === 'TimeoutError' ? 'websocket_timeout' : 'websocket_error_message';
        if (error.data) {
            return new errors_2.CustomError(code, `${error.name} ${error.data.error_message}`);
        }
        return new errors_2.CustomError(code, error.toString());
    }
    return error;
};
const getInfo = async (request) => {
    const api = await request.connect();
    const info = await api.getServerInfo();
    RESERVE.BASE = api.xrpToDrops(info.validatedLedger.reserveBaseXRP);
    RESERVE.OWNER = api.xrpToDrops(info.validatedLedger.reserveIncrementXRP);
    return {
        type: constants_1.RESPONSES.GET_INFO,
        payload: Object.assign({ url: api.connection.getUrl() }, utils.transformServerInfo(info)),
    };
};
const getMempoolAccountInfo = async (api, account) => {
    const info = await api.request('account_info', {
        account,
        ledger_index: 'current',
        queue: true,
    });
    return {
        xrpBalance: info.account_data.Balance,
        sequence: info.account_data.Sequence,
        txs: info.queue_data ? info.queue_data.txn_count : 0,
    };
};
const getAccountInfo = async (request) => {
    const { payload } = request;
    const account = {
        descriptor: payload.descriptor,
        balance: '0',
        availableBalance: '0',
        empty: true,
        history: {
            total: -1,
            unconfirmed: 0,
            transactions: undefined,
        },
        misc: {
            sequence: 0,
            reserve: RESERVE.BASE,
        },
    };
    try {
        const api = await request.connect();
        const info = await api.getAccountInfo(payload.descriptor);
        const ownersReserve = info.ownerCount > 0
            ? new bignumber_js_1.default(info.ownerCount).times(RESERVE.OWNER).toString()
            : '0';
        const reserve = new bignumber_js_1.default(RESERVE.BASE).plus(ownersReserve).toString();
        const misc = {
            sequence: info.sequence,
            reserve,
        };
        account.misc = misc;
        account.balance = api.xrpToDrops(info.xrpBalance);
        account.availableBalance = new bignumber_js_1.default(account.balance).minus(reserve).toString();
        account.empty = false;
    }
    catch (error) {
        if (error instanceof errors_1.RippleError && error.data && error.data.error === 'actNotFound') {
            return {
                type: constants_1.RESPONSES.GET_ACCOUNT_INFO,
                payload: account,
            };
        }
        throw error;
    }
    try {
        const api = await request.connect();
        const mempoolInfo = await getMempoolAccountInfo(api, payload.descriptor);
        const { misc } = account;
        const reserve = misc && typeof misc.reserve === 'string' ? misc.reserve : RESERVE.BASE;
        account.availableBalance = new bignumber_js_1.default(mempoolInfo.xrpBalance).minus(reserve).toString();
        account.misc.sequence = mempoolInfo.sequence;
        account.history.unconfirmed = mempoolInfo.txs;
    }
    catch (error) {
    }
    if (payload.details !== 'txs') {
        return {
            type: constants_1.RESPONSES.GET_ACCOUNT_INFO,
            payload: account,
        };
    }
    const requestOptions = {
        account: payload.descriptor,
        ledger_index_min: payload.from ? payload.from : undefined,
        ledger_index_max: payload.to ? payload.to : undefined,
        limit: payload.pageSize || 25,
        marker: payload.marker,
    };
    const api = await request.connect();
    const transactionsData = await api.request('account_tx', requestOptions);
    account.history.transactions = transactionsData.transactions.map(raw => utils.transformTransaction(payload.descriptor, raw.tx));
    return {
        type: constants_1.RESPONSES.GET_ACCOUNT_INFO,
        payload: Object.assign(Object.assign({}, account), { marker: transactionsData.marker }),
    };
};
const getTransaction = async ({ connect, payload }) => {
    const api = await connect();
    const tx = await api.getTransaction(payload);
    return {
        type: constants_1.RESPONSES.GET_TRANSACTION,
        payload: {
            type: 'ripple',
            tx,
        },
    };
};
const pushTransaction = async ({ connect, payload }) => {
    const api = await connect();
    const info = await api.submit(payload.toUpperCase());
    if (info.resultCode === 'tesSUCCESS') {
        return {
            type: constants_1.RESPONSES.PUSH_TRANSACTION,
            payload: info.tx_json.hash,
        };
    }
    throw new Error(info.resultMessage);
};
const estimateFee = async (request) => {
    const api = await request.connect();
    const fee = await api.getFee();
    let drops = api.xrpToDrops(fee);
    if (new bignumber_js_1.default(drops).gt('2000')) {
        drops = '12';
    }
    const payload = request.payload && Array.isArray(request.payload.blocks)
        ? request.payload.blocks.map(() => ({ feePerUnit: drops }))
        : [{ feePerUnit: drops }];
    return {
        type: constants_1.RESPONSES.ESTIMATE_FEE,
        payload,
    };
};
const onNewBlock = ({ post }, event) => {
    post({
        id: -1,
        type: constants_1.RESPONSES.NOTIFICATION,
        payload: {
            type: 'block',
            payload: {
                blockHeight: event.ledgerVersion,
                blockHash: event.ledgerHash,
            },
        },
    });
};
const onTransaction = ({ state, post }, event) => {
    if (event.type !== 'transaction')
        return;
    const tx = event.transaction;
    if (event.transaction.TransactionType !== 'Payment')
        return;
    const notify = (descriptor) => {
        post({
            id: -1,
            type: constants_1.RESPONSES.NOTIFICATION,
            payload: {
                type: 'notification',
                payload: {
                    descriptor,
                    tx: utils.transformTransaction(descriptor, Object.assign(Object.assign({}, event), tx)),
                },
            },
        });
    };
    const subscribed = state.getAddresses();
    const sent = subscribed.find(a => a === tx.Account);
    if (sent)
        notify(sent);
    const recv = subscribed.find(a => a === tx.Destination);
    if (recv)
        notify(recv);
};
const subscribeAccounts = async (ctx, accounts) => {
    const api = await ctx.connect();
    const { state } = ctx;
    const prevAddresses = state.getAddresses();
    state.addAccounts(accounts);
    const uniqueAddresses = state.getAddresses().filter(a => prevAddresses.indexOf(a) < 0);
    if (uniqueAddresses.length > 0) {
        if (!state.getSubscription('notification')) {
            api.connection.on('transaction', ev => onTransaction(ctx, ev));
            state.addSubscription('notification');
        }
        await api.request('subscribe', {
            accounts_proposed: uniqueAddresses,
        });
    }
    return { subscribed: state.getAddresses().length > 0 };
};
const subscribeAddresses = async (ctx, addresses) => {
    const api = await ctx.connect();
    const { state } = ctx;
    const uniqueAddresses = state.addAddresses(addresses);
    if (uniqueAddresses.length > 0) {
        if (!state.getSubscription('transaction')) {
            api.connection.on('transaction', ev => onTransaction(ctx, ev));
            state.addSubscription('transaction');
        }
        const request = {
            accounts_proposed: uniqueAddresses,
        };
        await api.request('subscribe', request);
    }
    return { subscribed: state.getAddresses().length > 0 };
};
const subscribeBlock = async (ctx) => {
    if (!ctx.state.getSubscription('ledger')) {
        const api = await ctx.connect();
        api.on('ledger', ev => onNewBlock(ctx, ev));
        ctx.state.addSubscription('ledger');
    }
    return { subscribed: true };
};
const subscribe = async (request) => {
    const { payload } = request;
    let response;
    if (payload.type === 'accounts') {
        response = await subscribeAccounts(request, payload.accounts);
    }
    else if (payload.type === 'addresses') {
        response = await subscribeAddresses(request, payload.addresses);
    }
    else if (payload.type === 'block') {
        response = await subscribeBlock(request);
    }
    else {
        throw new errors_2.CustomError('invalid_param', '+type');
    }
    return {
        type: constants_1.RESPONSES.SUBSCRIBE,
        payload: response,
    };
};
const unsubscribeAddresses = async ({ state, connect }, addresses) => {
    const api = await connect();
    if (!addresses) {
        const all = state.getAddresses();
        state.removeAccounts(state.getAccounts());
        state.removeAddresses(all);
        await api.request('unsubscribe', {
            accounts_proposed: all,
        });
    }
    else {
        state.removeAddresses(addresses);
        await api.request('unsubscribe', {
            accounts_proposed: addresses,
        });
    }
    if (state.getAccounts().length < 1) {
        api.connection.removeAllListeners('transaction');
        state.removeSubscription('transaction');
    }
};
const unsubscribeAccounts = async (ctx, accounts) => {
    const { state } = ctx;
    const prevAddresses = state.getAddresses();
    state.removeAccounts(accounts || state.getAccounts());
    const addresses = state.getAddresses();
    const uniqueAddresses = prevAddresses.filter(a => addresses.indexOf(a) < 0);
    await unsubscribeAddresses(ctx, uniqueAddresses);
};
const unsubscribeBlock = async ({ state, connect }) => {
    if (!state.getSubscription('ledger'))
        return;
    const api = await connect();
    api.removeAllListeners('ledger');
    state.removeSubscription('ledger');
};
const unsubscribe = async (request) => {
    const { payload } = request;
    if (payload.type === 'accounts') {
        await unsubscribeAccounts(request, payload.accounts);
    }
    else if (payload.type === 'addresses') {
        await unsubscribeAddresses(request, payload.addresses);
    }
    else if (payload.type === 'block') {
        await unsubscribeBlock(request);
    }
    return {
        type: constants_1.RESPONSES.UNSUBSCRIBE,
        payload: { subscribed: request.state.getAddresses().length > 0 },
    };
};
const onRequest = (request) => {
    switch (request.type) {
        case constants_1.MESSAGES.GET_INFO:
            return getInfo(request);
        case constants_1.MESSAGES.GET_ACCOUNT_INFO:
            return getAccountInfo(request);
        case constants_1.MESSAGES.GET_TRANSACTION:
            return getTransaction(request);
        case constants_1.MESSAGES.ESTIMATE_FEE:
            return estimateFee(request);
        case constants_1.MESSAGES.PUSH_TRANSACTION:
            return pushTransaction(request);
        case constants_1.MESSAGES.SUBSCRIBE:
            return subscribe(request);
        case constants_1.MESSAGES.UNSUBSCRIBE:
            return unsubscribe(request);
        default:
            throw new errors_2.CustomError('worker_unknown_request', `+${request.type}`);
    }
};
class RippleWorker extends baseWorker_1.BaseWorker {
    cleanup() {
        if (this.pingTimeout) {
            clearTimeout(this.pingTimeout);
        }
        if (this.api) {
            this.api.removeAllListeners();
        }
        super.cleanup();
    }
    isConnected(api) {
        var _a;
        return (_a = api === null || api === void 0 ? void 0 : api.isConnected()) !== null && _a !== void 0 ? _a : false;
    }
    async tryConnect(url) {
        const options = {
            server: url,
            connectionTimeout: this.settings.timeout || DEFAULT_TIMEOUT,
        };
        if (ripple_lib_1.RippleAPI._ALLOW_AGENT) {
            options.agent = this.proxyAgent;
        }
        const api = new ripple_lib_1.RippleAPI(options);
        api.connection.reconnect = () => new Promise(() => { });
        await api.connect();
        api.on('ledger', ledger => {
            RESERVE.BASE = api.xrpToDrops(ledger.reserveBaseXRP);
            RESERVE.OWNER = api.xrpToDrops(ledger.reserveIncrementXRP);
        });
        api.on('disconnected', () => {
            this.post({ id: -1, type: constants_1.RESPONSES.DISCONNECTED, payload: true });
            this.cleanup();
        });
        this.post({ id: -1, type: constants_1.RESPONSES.CONNECTED });
        return api;
    }
    disconnect() {
        if (this.api) {
            this.api.disconnect();
        }
    }
    async messageHandler(event) {
        try {
            if (await super.messageHandler(event))
                return true;
            const request = Object.assign(Object.assign({}, event.data), { connect: () => this.connect(), post: (data) => this.post(data), state: this.state });
            const response = await onRequest(request);
            this.post(Object.assign({ id: event.data.id }, response));
        }
        catch (error) {
            this.errorResponse(event.data.id, transformError(error));
        }
        finally {
            if (event.data.type !== constants_1.MESSAGES.DISCONNECT) {
                this.setPingTimeout();
            }
        }
    }
    setPingTimeout() {
        if (this.pingTimeout) {
            clearTimeout(this.pingTimeout);
        }
        this.pingTimeout = setTimeout(() => this.onPing(), this.settings.pingTimeout || DEFAULT_PING_TIMEOUT);
    }
    async onPing() {
        if (!this.api || !this.api.isConnected())
            return;
        if (this.state.hasSubscriptions() || this.settings.keepAlive) {
            try {
                await this.api.getServerInfo();
            }
            catch (error) {
                this.debug(`Error in timeout ping request: ${error}`);
            }
            this.setPingTimeout();
        }
        else {
            this.api.disconnect();
        }
    }
}
function Ripple() {
    return new RippleWorker();
}
exports.default = Ripple;
if (baseWorker_1.CONTEXT === 'worker') {
    const module = new RippleWorker();
    onmessage = module.messageHandler.bind(module);
}
//# sourceMappingURL=index.js.map