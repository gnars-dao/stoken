"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const utxo_lib_1 = require("@trezor/utxo-lib");
const blockchain_link_utils_1 = require("@trezor/blockchain-link-utils");
const utils_1 = require("../utils");
const blockbook_1 = require("@trezor/blockchain-link-utils/lib/blockbook");
const transformAddress = (addr) => ({
    address: addr.address,
    path: addr.path,
    transfers: addr.history.length,
});
const aggregateTransactions = (txs, groupBy = 3600) => {
    const result = [];
    let i = 0;
    while (i < txs.length) {
        const time = Math.floor(txs[i].blockTime / groupBy) * groupBy;
        let j = i;
        let received = 0;
        let sent = 0;
        let sentToSelf = 0;
        while (j < txs.length && txs[j].blockTime < time + groupBy) {
            const { type, amount, fee, details: { vin, vout, totalInput, totalOutput }, } = txs[j];
            if (type === 'recv')
                received += Number.parseInt(amount, 10);
            else if (type === 'sent')
                sent += Number.parseInt(amount, 10) + Number.parseInt(fee, 10);
            else if (type === 'self') {
                sentToSelf += Number.parseInt(totalOutput, 10);
                sent += Number.parseInt(totalInput, 10);
                received += Number.parseInt(totalOutput, 10);
            }
            else if (type === 'joint') {
                const myTotalInput = new bignumber_js_1.default(vin.filter(vin => vin.isAccountOwned).reduce(blockchain_link_utils_1.sumVinVout, 0)).toNumber();
                const myTotalOutput = new bignumber_js_1.default(vout.filter(vout => vout.isAccountOwned).reduce(blockchain_link_utils_1.sumVinVout, 0)).toNumber();
                sent += myTotalInput;
                received += myTotalOutput;
                sentToSelf += Math.min(myTotalInput, myTotalOutput);
            }
            j++;
        }
        result.push({
            time,
            txs: j - i,
            received: received.toString(),
            sent: sent.toString(),
            sentToSelf: sentToSelf.toString(),
            rates: {},
        });
        i = j;
    }
    return result;
};
const getAccountBalanceHistory = async (client, { descriptor, from, to, groupBy }) => {
    var _a;
    let history;
    let addresses;
    const network = (_a = client.getInfo()) === null || _a === void 0 ? void 0 : _a.network;
    const parsed = (0, utils_1.tryGetScripthash)(descriptor, network);
    if (parsed.valid) {
        history = await client.request('blockchain.scripthash.get_history', parsed.scripthash);
        addresses = undefined;
    }
    else {
        const discover = (0, utils_1.discoverAddress)(client);
        const receive = await (0, utxo_lib_1.discovery)(discover, descriptor, 'receive', network);
        const change = await (0, utxo_lib_1.discovery)(discover, descriptor, 'change', network);
        addresses = {
            change: change.map(transformAddress),
            used: receive.filter(({ history }) => history.length).map(transformAddress),
            unused: receive.filter(({ history }) => !history.length).map(transformAddress),
        };
        history = receive
            .map(({ history }) => history)
            .concat(change.map(({ history }) => history))
            .flat();
    }
    const txs = await (0, utils_1.getTransactions)(client, history).then(txs => txs
        .filter(({ blockTime }) => (from || 0) <= blockTime && blockTime <= (to || Number.MAX_SAFE_INTEGER))
        .sort((a, b) => a.blockTime - b.blockTime)
        .map(tx => (Object.assign({ blockTime: -1 }, (0, blockbook_1.transformTransaction)(descriptor, addresses, tx)))));
    return aggregateTransactions(txs, groupBy);
};
exports.default = getAccountBalanceHistory;
//# sourceMappingURL=getAccountBalanceHistory.js.map