"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const typedEventEmitter_1 = require("@trezor/utils/lib/typedEventEmitter");
const createDeferred_1 = require("@trezor/utils/lib/createDeferred");
const errors_1 = require("@trezor/blockchain-link-types/lib/constants/errors");
const constants_1 = require("@trezor/blockchain-link-types/lib/constants");
const throttler_1 = require("./workers/throttler");
const workerWrapper = (factory) => {
    if (typeof factory === 'function')
        return factory();
    if (typeof factory === 'string' && typeof Worker !== 'undefined')
        return new Worker(factory);
    throw new errors_1.CustomError('worker_not_found');
};
const initWorker = (settings) => {
    const dfd = (0, createDeferred_1.createDeferred)(-1);
    const worker = workerWrapper(settings.worker);
    if (typeof worker !== 'object' || typeof worker.postMessage !== 'function') {
        throw new errors_1.CustomError('worker_invalid');
    }
    const timeout = setTimeout(() => {
        worker.onmessage = null;
        worker.onerror = null;
        dfd.reject(new errors_1.CustomError('worker_timeout'));
    }, settings.timeout || 30000);
    worker.onmessage = (message) => {
        if (message.data.type !== constants_1.MESSAGES.HANDSHAKE)
            return;
        clearTimeout(timeout);
        worker.postMessage({
            type: constants_1.MESSAGES.HANDSHAKE,
            settings: Object.assign(settings, { worker: undefined }),
        });
        dfd.resolve(worker);
    };
    worker.onerror = (error) => {
        clearTimeout(timeout);
        worker.onmessage = null;
        worker.onerror = null;
        try {
            worker.terminate();
        }
        catch (error) {
        }
        const message = error.message
            ? `Worker runtime error: Line ${error.lineno} in ${error.filename}: ${error.message}`
            : 'Worker handshake error';
        dfd.reject(new errors_1.CustomError('worker_runtime', message));
    };
    return dfd.promise;
};
class BlockchainLink extends typedEventEmitter_1.TypedEmitter {
    constructor(settings) {
        super();
        this.messageId = 0;
        this.deferred = [];
        this.onMessage = event => {
            if (!event.data)
                return;
            const { data } = event;
            if (data.id === -1) {
                this.onEvent(data);
                return;
            }
            const dfd = this.deferred.find(d => d.id === data.id);
            if (!dfd) {
                return;
            }
            if (data.type === constants_1.RESPONSES.ERROR) {
                dfd.reject(new errors_1.CustomError(data.payload.code, data.payload.message));
            }
            else {
                dfd.resolve(data.payload);
            }
            this.deferred = this.deferred.filter(d => d !== dfd);
        };
        this.onEvent = data => {
            if (data.type === constants_1.RESPONSES.CONNECTED) {
                this.emit('connected');
            }
            if (data.type === constants_1.RESPONSES.DISCONNECTED) {
                this.emit('disconnected');
            }
            if (data.type === constants_1.RESPONSES.NOTIFICATION) {
                const notification = data.payload;
                if (notification.type === 'block') {
                    this.throttler.throttle('block', () => {
                        this.emit(notification.type, notification.payload);
                    });
                }
                else if (notification.type === 'notification') {
                    const txAccountId = `${notification.payload.descriptor}:${notification.payload.tx.txid}`;
                    this.throttler.throttle(txAccountId, () => {
                        this.emit(notification.type, notification.payload);
                    });
                }
                else {
                    this.emit(notification.type, notification.payload);
                }
            }
        };
        this.onError = error => {
            const message = error.message
                ? `Worker runtime error: Line ${error.lineno} in ${error.filename}: ${error.message}`
                : 'Worker handshake error';
            const e = new errors_1.CustomError('worker_runtime', message);
            this.deferred.forEach(d => {
                d.reject(e);
            });
            this.deferred = [];
        };
        this.settings = settings;
        const throttleBlockEventTimeout = typeof settings.throttleBlockEvent === 'number' ? settings.throttleBlockEvent : 500;
        this.throttler = new throttler_1.Throttler(throttleBlockEventTimeout);
    }
    async getWorker() {
        if (!this.worker) {
            this.worker = await initWorker(this.settings);
            this.worker.onmessage = this.onMessage.bind(this);
            this.worker.onerror = this.onError.bind(this);
        }
        return this.worker;
    }
    async sendMessage(message) {
        const worker = await this.getWorker();
        const dfd = (0, createDeferred_1.createDeferred)(this.messageId);
        this.deferred.push(dfd);
        worker.postMessage(Object.assign({ id: this.messageId }, message));
        this.messageId++;
        return dfd.promise;
    }
    connect() {
        return this.sendMessage({
            type: constants_1.MESSAGES.CONNECT,
        });
    }
    getInfo() {
        return this.sendMessage({
            type: constants_1.MESSAGES.GET_INFO,
        });
    }
    getBlockHash(payload) {
        return this.sendMessage({
            type: constants_1.MESSAGES.GET_BLOCK_HASH,
            payload,
        });
    }
    getBlock(payload) {
        return this.sendMessage({
            type: constants_1.MESSAGES.GET_BLOCK,
            payload,
        });
    }
    getAccountInfo(payload) {
        return this.sendMessage({
            type: constants_1.MESSAGES.GET_ACCOUNT_INFO,
            payload,
        });
    }
    getAccountUtxo(payload) {
        return this.sendMessage({
            type: constants_1.MESSAGES.GET_ACCOUNT_UTXO,
            payload,
        });
    }
    getTransaction(payload) {
        return this.sendMessage({
            type: constants_1.MESSAGES.GET_TRANSACTION,
            payload,
        });
    }
    getAccountBalanceHistory(payload) {
        return this.sendMessage({
            type: constants_1.MESSAGES.GET_ACCOUNT_BALANCE_HISTORY,
            payload,
        });
    }
    getCurrentFiatRates(payload) {
        return this.sendMessage({
            type: constants_1.MESSAGES.GET_CURRENT_FIAT_RATES,
            payload,
        });
    }
    getFiatRatesForTimestamps(payload) {
        return this.sendMessage({
            type: constants_1.MESSAGES.GET_FIAT_RATES_FOR_TIMESTAMPS,
            payload,
        });
    }
    getFiatRatesTickersList(payload) {
        return this.sendMessage({
            type: constants_1.MESSAGES.GET_FIAT_RATES_TICKERS_LIST,
            payload,
        });
    }
    estimateFee(payload) {
        return this.sendMessage({
            type: constants_1.MESSAGES.ESTIMATE_FEE,
            payload,
        });
    }
    subscribe(payload) {
        return this.sendMessage({
            type: constants_1.MESSAGES.SUBSCRIBE,
            payload,
        });
    }
    unsubscribe(payload) {
        return this.sendMessage({
            type: constants_1.MESSAGES.UNSUBSCRIBE,
            payload,
        });
    }
    pushTransaction(payload) {
        return this.sendMessage({
            type: constants_1.MESSAGES.PUSH_TRANSACTION,
            payload,
        });
    }
    async disconnect() {
        if (!this.worker)
            return true;
        return this.sendMessage({
            type: constants_1.MESSAGES.DISCONNECT,
        });
    }
    dispose() {
        this.removeAllListeners();
        this.throttler.dispose();
        const { worker } = this;
        if (worker) {
            worker.terminate();
            delete this.worker;
        }
    }
}
exports.default = BlockchainLink;
//# sourceMappingURL=index.js.map