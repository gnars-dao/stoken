import { b as ne, d as j, a as N } from "./index-005ea00d-8256b49b.js";
import { d as k } from "./index-2b41ecf2.js";
import "fs";
import "path";
import "assert";
import "buffer";
import "events";
import "util";
import "string_decoder";
function le(e, t) {
  for (var r = 0; r < t.length; r++) {
    const n = t[r];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const o in n)
        if (o !== "default" && !(o in e)) {
          const i = Object.getOwnPropertyDescriptor(n, o);
          i && Object.defineProperty(e, o, i.get ? i : {
            enumerable: !0,
            get: () => n[o]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var oe = {}, y = {}, d = {}, B = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isMultisigThresholdPubkey = e.isSinglePubkey = e.pubkeyType = e.isSecp256k1Pubkey = e.isEd25519Pubkey = void 0;
  function t(i) {
    return i.type === "tendermint/PubKeyEd25519";
  }
  e.isEd25519Pubkey = t;
  function r(i) {
    return i.type === "tendermint/PubKeySecp256k1";
  }
  e.isSecp256k1Pubkey = r, e.pubkeyType = {
    /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/ed25519/ed25519.go#L22 */
    secp256k1: "tendermint/PubKeySecp256k1",
    /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/secp256k1/secp256k1.go#L23 */
    ed25519: "tendermint/PubKeyEd25519",
    /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/sr25519/codec.go#L12 */
    sr25519: "tendermint/PubKeySr25519",
    multisigThreshold: "tendermint/PubKeyMultisigThreshold"
  };
  function n(i) {
    return [e.pubkeyType.ed25519, e.pubkeyType.secp256k1, e.pubkeyType.sr25519].includes(i.type);
  }
  e.isSinglePubkey = n;
  function o(i) {
    return i.type === "tendermint/PubKeyMultisigThreshold";
  }
  e.isMultisigThresholdPubkey = o;
})(B);
Object.defineProperty(d, "__esModule", { value: !0 });
d.encodeBech32Pubkey = d.encodeAminoPubkey = d.decodeBech32Pubkey = d.decodeAminoPubkey = d.encodeEd25519Pubkey = d.encodeSecp256k1Pubkey = void 0;
const p = k, fe = N, O = ne, b = B;
function he(e) {
  if (e.length !== 33 || e[0] !== 2 && e[0] !== 3)
    throw new Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");
  return {
    type: b.pubkeyType.secp256k1,
    value: (0, p.toBase64)(e)
  };
}
d.encodeSecp256k1Pubkey = he;
function be(e) {
  if (e.length !== 32)
    throw new Error("Ed25519 public key must be 32 bytes long");
  return {
    type: b.pubkeyType.ed25519,
    value: (0, p.toBase64)(e)
  };
}
d.encodeEd25519Pubkey = be;
const W = (0, p.fromHex)(
  "eb5ae98721"
  /* fixed length */
), D = (0, p.fromHex)(
  "1624de6420"
  /* fixed length */
), q = (0, p.fromHex)(
  "0dfb100520"
  /* fixed length */
), _ = (0, p.fromHex)(
  "22c1f7e2"
  /* variable length not included */
);
function G(e) {
  if ((0, O.arrayContentStartsWith)(e, W)) {
    const t = e.slice(W.length);
    if (t.length !== 33)
      throw new Error("Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).");
    return {
      type: b.pubkeyType.secp256k1,
      value: (0, p.toBase64)(t)
    };
  } else if ((0, O.arrayContentStartsWith)(e, D)) {
    const t = e.slice(D.length);
    if (t.length !== 32)
      throw new Error("Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).");
    return {
      type: b.pubkeyType.ed25519,
      value: (0, p.toBase64)(t)
    };
  } else if ((0, O.arrayContentStartsWith)(e, q)) {
    const t = e.slice(q.length);
    if (t.length !== 32)
      throw new Error("Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).");
    return {
      type: b.pubkeyType.sr25519,
      value: (0, p.toBase64)(t)
    };
  } else {
    if ((0, O.arrayContentStartsWith)(e, _))
      return ge(e);
    throw new Error("Unsupported public key type. Amino data starts with: " + (0, p.toHex)(e.slice(0, 5)));
  }
}
d.decodeAminoPubkey = G;
function me(e) {
  const { data: t } = (0, p.fromBech32)(e);
  return G(t);
}
d.decodeBech32Pubkey = me;
function X(e) {
  if (e.length < 1)
    throw new Error("Can't decode varint. EOF");
  if (e[0] > 127)
    throw new Error("Decoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.Varint implementation from the Go standard library and write some tests.");
  return [e[0], 1];
}
function ge(e) {
  const t = Array.from(e), r = t.splice(0, _.length);
  if (!(0, O.arrayContentStartsWith)(r, _))
    throw new Error("Invalid multisig prefix.");
  if (t.shift() != 8)
    throw new Error("Invalid multisig data. Expecting 0x08 prefix before threshold.");
  const [n, o] = X(t);
  t.splice(0, o);
  const i = [];
  for (; t.length > 0; ) {
    if (t.shift() != 18)
      throw new Error("Invalid multisig data. Expecting 0x12 prefix before participant pubkey length.");
    const [a, c] = X(t);
    if (t.splice(0, c), t.length < a)
      throw new Error("Invalid multisig data length.");
    const s = t.splice(0, a), u = G(Uint8Array.from(s));
    i.push(u);
  }
  return {
    type: b.pubkeyType.multisigThreshold,
    value: {
      threshold: n.toString(),
      pubkeys: i
    }
  };
}
function Q(e) {
  const t = fe.Uint53.fromString(e.toString()).toNumber();
  if (t > 127)
    throw new Error("Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.");
  return [t];
}
function V(e) {
  if ((0, b.isMultisigThresholdPubkey)(e)) {
    const t = Array.from(_);
    t.push(8), t.push(...Q(e.value.threshold));
    for (const r of e.value.pubkeys.map((n) => V(n)))
      t.push(18), t.push(...Q(r.length)), t.push(...r);
    return new Uint8Array(t);
  } else {
    if ((0, b.isEd25519Pubkey)(e))
      return new Uint8Array([...D, ...(0, p.fromBase64)(e.value)]);
    if ((0, b.isSecp256k1Pubkey)(e))
      return new Uint8Array([...W, ...(0, p.fromBase64)(e.value)]);
    throw new Error("Unsupported pubkey type");
  }
}
d.encodeAminoPubkey = V;
function ke(e, t) {
  return (0, p.toBech32)(t, V(e));
}
d.encodeBech32Pubkey = ke;
Object.defineProperty(y, "__esModule", { value: !0 });
y.pubkeyToAddress = y.pubkeyToRawAddress = y.rawSecp256k1PubkeyToRawAddress = y.rawEd25519PubkeyToRawAddress = void 0;
const U = j, J = k, we = d, I = B;
function ie(e) {
  if (e.length !== 32)
    throw new Error(`Invalid Ed25519 pubkey length: ${e.length}`);
  return (0, U.sha256)(e).slice(0, 20);
}
y.rawEd25519PubkeyToRawAddress = ie;
function se(e) {
  if (e.length !== 33)
    throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${e.length}`);
  return (0, U.ripemd160)((0, U.sha256)(e));
}
y.rawSecp256k1PubkeyToRawAddress = se;
function ae(e) {
  if ((0, I.isSecp256k1Pubkey)(e)) {
    const t = (0, J.fromBase64)(e.value);
    return se(t);
  } else if ((0, I.isEd25519Pubkey)(e)) {
    const t = (0, J.fromBase64)(e.value);
    return ie(t);
  } else if ((0, I.isMultisigThresholdPubkey)(e)) {
    const t = (0, we.encodeAminoPubkey)(e);
    return (0, U.sha256)(t).slice(0, 20);
  } else
    throw new Error("Unsupported public key type");
}
y.pubkeyToRawAddress = ae;
function Pe(e, t) {
  return (0, J.toBech32)(t, ae(e));
}
y.pubkeyToAddress = Pe;
var h = {};
Object.defineProperty(h, "__esModule", { value: !0 });
h.addCoins = h.parseCoins = h.coins = h.coin = void 0;
const H = N;
function ce(e, t) {
  let r;
  if (typeof e == "number")
    try {
      r = new H.Uint53(e).toString();
    } catch {
      throw new Error("Given amount is not a safe integer. Consider using a string instead to overcome the limitations of JS numbers.");
    }
  else {
    if (!e.match(/^[0-9]+$/))
      throw new Error("Invalid unsigned integer string format");
    r = e.replace(/^0*/, "") || "0";
  }
  return {
    amount: r,
    denom: t
  };
}
h.coin = ce;
function Se(e, t) {
  return [ce(e, t)];
}
h.coins = Se;
function ve(e) {
  return e.replace(/\s/g, "").split(",").filter(Boolean).map((t) => {
    const r = t.match(/^([0-9]+)([a-zA-Z]+)/);
    if (!r)
      throw new Error("Got an invalid coin string");
    return {
      amount: r[1].replace(/^0+/, "") || "0",
      denom: r[2]
    };
  });
}
h.parseCoins = ve;
function Ae(e, t) {
  if (e.denom !== t.denom)
    throw new Error("Trying to add two coins with different denoms");
  return {
    amount: H.Decimal.fromAtomics(e.amount, 0).plus(H.Decimal.fromAtomics(t.amount, 0)).atomics,
    denom: e.denom
  };
}
h.addCoins = Ae;
var S = {};
Object.defineProperty(S, "__esModule", { value: !0 });
S.createMultisigThresholdPubkey = S.compareArrays = void 0;
const Y = k, Te = N, ee = y;
function ue(e, t) {
  const r = (0, Y.toHex)(e), n = (0, Y.toHex)(t);
  return r === n ? 0 : r < n ? -1 : 1;
}
S.compareArrays = ue;
function Ee(e, t, r = !1) {
  const n = new Te.Uint53(t);
  if (n.toNumber() > e.length)
    throw new Error(`Threshold k = ${n.toNumber()} exceeds number of keys n = ${e.length}`);
  const o = r ? e : Array.from(e).sort((i, a) => {
    const c = (0, ee.pubkeyToRawAddress)(i), s = (0, ee.pubkeyToRawAddress)(a);
    return ue(c, s);
  });
  return {
    type: "tendermint/PubKeyMultisigThreshold",
    value: {
      threshold: n.toString(),
      pubkeys: o
    }
  };
}
S.createMultisigThresholdPubkey = Ee;
var C = {};
Object.defineProperty(C, "__esModule", { value: !0 });
C.makeCosmoshubPath = void 0;
const T = j;
function xe(e) {
  return [
    T.Slip10RawIndex.hardened(44),
    T.Slip10RawIndex.hardened(118),
    T.Slip10RawIndex.hardened(0),
    T.Slip10RawIndex.normal(0),
    T.Slip10RawIndex.normal(e)
  ];
}
C.makeCosmoshubPath = xe;
var v = {}, g = {};
Object.defineProperty(g, "__esModule", { value: !0 });
g.decodeSignature = g.encodeSecp256k1Signature = void 0;
const $ = k, Oe = d, je = B;
function Be(e, t) {
  if (t.length !== 64)
    throw new Error("Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.");
  return {
    pub_key: (0, Oe.encodeSecp256k1Pubkey)(e),
    signature: (0, $.toBase64)(t)
  };
}
g.encodeSecp256k1Signature = Be;
function Ce(e) {
  switch (e.pub_key.type) {
    case je.pubkeyType.secp256k1:
      return {
        pubkey: (0, $.fromBase64)(e.pub_key.value),
        signature: (0, $.fromBase64)(e.signature)
      };
    default:
      throw new Error("Unsupported pubkey type");
  }
}
g.decodeSignature = Ce;
var f = {};
Object.defineProperty(f, "__esModule", { value: !0 });
f.serializeSignDoc = f.escapeCharacters = f.makeSignDoc = f.sortedJsonStringify = void 0;
const Me = k, te = N;
function L(e) {
  if (typeof e != "object" || e === null)
    return e;
  if (Array.isArray(e))
    return e.map(L);
  const t = Object.keys(e).sort(), r = {};
  return t.forEach((n) => {
    r[n] = L(e[n]);
  }), r;
}
function de(e) {
  return JSON.stringify(L(e));
}
f.sortedJsonStringify = de;
function Ke(e, t, r, n, o, i) {
  return {
    chain_id: r,
    account_number: te.Uint53.fromString(o.toString()).toString(),
    sequence: te.Uint53.fromString(i.toString()).toString(),
    fee: t,
    msgs: e,
    memo: n || ""
  };
}
f.makeSignDoc = Ke;
function pe(e) {
  const t = /&/g, r = /</g, n = />/g;
  return e.replace(t, "\\u0026").replace(r, "\\u003c").replace(n, "\\u003e");
}
f.escapeCharacters = pe;
function Re(e) {
  const t = pe(de(e));
  return (0, Me.toUtf8)(t);
}
f.serializeSignDoc = Re;
var F = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.decrypt = e.encrypt = e.supportedAlgorithms = e.executeKdf = e.cosmjsSalt = void 0;
  const t = j, r = k;
  e.cosmjsSalt = (0, r.toAscii)("The CosmJS salt.");
  async function n(a, c) {
    switch (c.algorithm) {
      case "argon2id": {
        const s = c.params;
        if (!(0, t.isArgon2idOptions)(s))
          throw new Error("Invalid format of argon2id params");
        return t.Argon2id.execute(a, e.cosmjsSalt, s);
      }
      default:
        throw new Error("Unsupported KDF algorithm");
    }
  }
  e.executeKdf = n, e.supportedAlgorithms = {
    xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
  };
  async function o(a, c, s) {
    switch (s.algorithm) {
      case e.supportedAlgorithms.xchacha20poly1305Ietf: {
        const u = t.Random.getBytes(t.xchacha20NonceLength);
        return new Uint8Array([
          ...u,
          ...await t.Xchacha20poly1305Ietf.encrypt(a, c, u)
        ]);
      }
      default:
        throw new Error(`Unsupported encryption algorithm: '${s.algorithm}'`);
    }
  }
  e.encrypt = o;
  async function i(a, c, s) {
    switch (s.algorithm) {
      case e.supportedAlgorithms.xchacha20poly1305Ietf: {
        const u = a.slice(0, t.xchacha20NonceLength);
        return t.Xchacha20poly1305Ietf.decrypt(a.slice(t.xchacha20NonceLength), c, u);
      }
      default:
        throw new Error(`Unsupported encryption algorithm: '${s.algorithm}'`);
    }
  }
  e.decrypt = i;
})(F);
Object.defineProperty(v, "__esModule", { value: !0 });
v.Secp256k1HdWallet = v.extractKdfConfiguration = void 0;
const l = j, E = k, P = ne, _e = y, Ue = C, Ne = g, ze = f, x = F, R = "secp256k1wallet-v1", Ie = {
  algorithm: "argon2id",
  params: {
    outputLength: 32,
    opsLimit: 24,
    memLimitKib: 12 * 1024
  }
};
function We(e) {
  return !(!(0, P.isNonNullObject)(e) || typeof e.hdPath != "string" || typeof e.prefix != "string");
}
function De(e) {
  return e.kdf;
}
function Je(e) {
  const t = JSON.parse(e);
  if (!(0, P.isNonNullObject)(t))
    throw new Error("Root document is not an object.");
  switch (t.type) {
    case R:
      return De(t);
    default:
      throw new Error("Unsupported serialization type");
  }
}
v.extractKdfConfiguration = Je;
const re = {
  bip39Password: "",
  hdPaths: [(0, Ue.makeCosmoshubPath)(0)],
  prefix: "cosmos"
};
class w {
  /**
   * Restores a wallet from the given BIP39 mnemonic.
   *
   * @param mnemonic Any valid English mnemonic.
   * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
   */
  static async fromMnemonic(t, r = {}) {
    const n = new l.EnglishMnemonic(t), o = await l.Bip39.mnemonicToSeed(n, r.bip39Password);
    return new w(n, {
      ...r,
      seed: o
    });
  }
  /**
   * Generates a new wallet with a BIP39 mnemonic of the given length.
   *
   * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
   * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
   */
  static async generate(t = 12, r = {}) {
    const n = 4 * Math.floor(11 * t / 33), o = l.Random.getBytes(n), i = l.Bip39.encode(o);
    return w.fromMnemonic(i.toString(), r);
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * @param password The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  static async deserialize(t, r) {
    const n = JSON.parse(t);
    if (!(0, P.isNonNullObject)(n))
      throw new Error("Root document is not an object.");
    switch (n.type) {
      case R:
        return w.deserializeTypeV1(t, r);
      default:
        throw new Error("Unsupported serialization type");
    }
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
   * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
   * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
   */
  static async deserializeWithEncryptionKey(t, r) {
    const n = JSON.parse(t);
    if (!(0, P.isNonNullObject)(n))
      throw new Error("Root document is not an object.");
    const o = n;
    switch (o.type) {
      case R: {
        const i = await (0, x.decrypt)((0, E.fromBase64)(o.data), r, o.encryption), a = JSON.parse((0, E.fromUtf8)(i)), { mnemonic: c, accounts: s } = a;
        if ((0, P.assert)(typeof c == "string"), !Array.isArray(s))
          throw new Error("Property 'accounts' is not an array");
        if (!s.every((m) => We(m)))
          throw new Error("Account is not in the correct format.");
        const u = s[0].prefix;
        if (!s.every(({ prefix: m }) => m === u))
          throw new Error("Accounts do not all have the same prefix");
        const M = s.map(({ hdPath: m }) => (0, l.stringToPath)(m));
        return w.fromMnemonic(c, {
          hdPaths: M,
          prefix: u
        });
      }
      default:
        throw new Error("Unsupported serialization type");
    }
  }
  static async deserializeTypeV1(t, r) {
    const n = JSON.parse(t);
    if (!(0, P.isNonNullObject)(n))
      throw new Error("Root document is not an object.");
    const o = await (0, x.executeKdf)(r, n.kdf);
    return w.deserializeWithEncryptionKey(t, o);
  }
  constructor(t, r) {
    const n = r.hdPaths ?? re.hdPaths, o = r.prefix ?? re.prefix;
    this.secret = t, this.seed = r.seed, this.accounts = n.map((i) => ({
      hdPath: i,
      prefix: o
    }));
  }
  get mnemonic() {
    return this.secret.toString();
  }
  async getAccounts() {
    return (await this.getAccountsWithPrivkeys()).map(({ algo: t, pubkey: r, address: n }) => ({
      algo: t,
      pubkey: r,
      address: n
    }));
  }
  async signAmino(t, r) {
    const n = (await this.getAccountsWithPrivkeys()).find(({ address: u }) => u === t);
    if (n === void 0)
      throw new Error(`Address ${t} not found in wallet`);
    const { privkey: o, pubkey: i } = n, a = (0, l.sha256)((0, ze.serializeSignDoc)(r)), c = await l.Secp256k1.createSignature(a, o), s = new Uint8Array([...c.r(32), ...c.s(32)]);
    return {
      signed: r,
      signature: (0, Ne.encodeSecp256k1Signature)(i, s)
    };
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * @param password The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  async serialize(t) {
    const r = Ie, n = await (0, x.executeKdf)(t, r);
    return this.serializeWithEncryptionKey(n, r);
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
   * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF options. If this
   * is not the case, the wallet cannot be restored with the original password.
   */
  async serializeWithEncryptionKey(t, r) {
    const n = {
      mnemonic: this.mnemonic,
      accounts: this.accounts.map(({ hdPath: s, prefix: u }) => ({
        hdPath: (0, l.pathToString)(s),
        prefix: u
      }))
    }, o = (0, E.toUtf8)(JSON.stringify(n)), i = {
      algorithm: x.supportedAlgorithms.xchacha20poly1305Ietf
    }, a = await (0, x.encrypt)(o, t, i), c = {
      type: R,
      kdf: r,
      encryption: i,
      data: (0, E.toBase64)(a)
    };
    return JSON.stringify(c);
  }
  async getKeyPair(t) {
    const { privkey: r } = l.Slip10.derivePath(l.Slip10Curve.Secp256k1, this.seed, t), { pubkey: n } = await l.Secp256k1.makeKeypair(r);
    return {
      privkey: r,
      pubkey: l.Secp256k1.compressPubkey(n)
    };
  }
  async getAccountsWithPrivkeys() {
    return Promise.all(this.accounts.map(async ({ hdPath: t, prefix: r }) => {
      const { privkey: n, pubkey: o } = await this.getKeyPair(t), i = (0, E.toBech32)(r, (0, _e.rawSecp256k1PubkeyToRawAddress)(o));
      return {
        algo: "secp256k1",
        privkey: n,
        pubkey: o,
        address: i
      };
    }));
  }
}
v.Secp256k1HdWallet = w;
var z = {};
Object.defineProperty(z, "__esModule", { value: !0 });
z.Secp256k1Wallet = void 0;
const K = j, He = k, $e = y, Le = g, Ge = f;
class Z {
  /**
   * Creates a Secp256k1Wallet from the given private key
   *
   * @param privkey The private key.
   * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
   */
  static async fromKey(t, r = "cosmos") {
    const n = (await K.Secp256k1.makeKeypair(t)).pubkey;
    return new Z(t, K.Secp256k1.compressPubkey(n), r);
  }
  constructor(t, r, n) {
    this.privkey = t, this.pubkey = r, this.prefix = n;
  }
  get address() {
    return (0, He.toBech32)(this.prefix, (0, $e.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
  }
  async getAccounts() {
    return [
      {
        algo: "secp256k1",
        address: this.address,
        pubkey: this.pubkey
      }
    ];
  }
  async signAmino(t, r) {
    if (t !== this.address)
      throw new Error(`Address ${t} not found in wallet`);
    const n = new K.Sha256((0, Ge.serializeSignDoc)(r)).digest(), o = await K.Secp256k1.createSignature(n, this.privkey), i = new Uint8Array([...o.r(32), ...o.s(32)]);
    return {
      signed: r,
      signature: (0, Le.encodeSecp256k1Signature)(this.pubkey, i)
    };
  }
}
z.Secp256k1Wallet = Z;
var A = {};
Object.defineProperty(A, "__esModule", { value: !0 });
A.makeStdTx = A.isStdTx = void 0;
function Ve(e) {
  const { memo: t, msg: r, fee: n, signatures: o } = e;
  return typeof t == "string" && Array.isArray(r) && typeof n == "object" && Array.isArray(o);
}
A.isStdTx = Ve;
function Fe(e, t) {
  return {
    msg: e.msgs,
    fee: e.fee,
    memo: e.memo,
    signatures: Array.isArray(t) ? t : [t]
  };
}
A.makeStdTx = Fe;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.executeKdf = e.makeStdTx = e.isStdTx = e.serializeSignDoc = e.makeSignDoc = e.encodeSecp256k1Signature = e.decodeSignature = e.Secp256k1Wallet = e.Secp256k1HdWallet = e.extractKdfConfiguration = e.pubkeyType = e.isSinglePubkey = e.isSecp256k1Pubkey = e.isMultisigThresholdPubkey = e.isEd25519Pubkey = e.makeCosmoshubPath = e.createMultisigThresholdPubkey = e.encodeSecp256k1Pubkey = e.encodeEd25519Pubkey = e.encodeBech32Pubkey = e.encodeAminoPubkey = e.decodeBech32Pubkey = e.decodeAminoPubkey = e.parseCoins = e.coins = e.coin = e.addCoins = e.rawSecp256k1PubkeyToRawAddress = e.rawEd25519PubkeyToRawAddress = e.pubkeyToRawAddress = e.pubkeyToAddress = void 0;
  var t = y;
  Object.defineProperty(e, "pubkeyToAddress", { enumerable: !0, get: function() {
    return t.pubkeyToAddress;
  } }), Object.defineProperty(e, "pubkeyToRawAddress", { enumerable: !0, get: function() {
    return t.pubkeyToRawAddress;
  } }), Object.defineProperty(e, "rawEd25519PubkeyToRawAddress", { enumerable: !0, get: function() {
    return t.rawEd25519PubkeyToRawAddress;
  } }), Object.defineProperty(e, "rawSecp256k1PubkeyToRawAddress", { enumerable: !0, get: function() {
    return t.rawSecp256k1PubkeyToRawAddress;
  } });
  var r = h;
  Object.defineProperty(e, "addCoins", { enumerable: !0, get: function() {
    return r.addCoins;
  } }), Object.defineProperty(e, "coin", { enumerable: !0, get: function() {
    return r.coin;
  } }), Object.defineProperty(e, "coins", { enumerable: !0, get: function() {
    return r.coins;
  } }), Object.defineProperty(e, "parseCoins", { enumerable: !0, get: function() {
    return r.parseCoins;
  } });
  var n = d;
  Object.defineProperty(e, "decodeAminoPubkey", { enumerable: !0, get: function() {
    return n.decodeAminoPubkey;
  } }), Object.defineProperty(e, "decodeBech32Pubkey", { enumerable: !0, get: function() {
    return n.decodeBech32Pubkey;
  } }), Object.defineProperty(e, "encodeAminoPubkey", { enumerable: !0, get: function() {
    return n.encodeAminoPubkey;
  } }), Object.defineProperty(e, "encodeBech32Pubkey", { enumerable: !0, get: function() {
    return n.encodeBech32Pubkey;
  } }), Object.defineProperty(e, "encodeEd25519Pubkey", { enumerable: !0, get: function() {
    return n.encodeEd25519Pubkey;
  } }), Object.defineProperty(e, "encodeSecp256k1Pubkey", { enumerable: !0, get: function() {
    return n.encodeSecp256k1Pubkey;
  } });
  var o = S;
  Object.defineProperty(e, "createMultisigThresholdPubkey", { enumerable: !0, get: function() {
    return o.createMultisigThresholdPubkey;
  } });
  var i = C;
  Object.defineProperty(e, "makeCosmoshubPath", { enumerable: !0, get: function() {
    return i.makeCosmoshubPath;
  } });
  var a = B;
  Object.defineProperty(e, "isEd25519Pubkey", { enumerable: !0, get: function() {
    return a.isEd25519Pubkey;
  } }), Object.defineProperty(e, "isMultisigThresholdPubkey", { enumerable: !0, get: function() {
    return a.isMultisigThresholdPubkey;
  } }), Object.defineProperty(e, "isSecp256k1Pubkey", { enumerable: !0, get: function() {
    return a.isSecp256k1Pubkey;
  } }), Object.defineProperty(e, "isSinglePubkey", { enumerable: !0, get: function() {
    return a.isSinglePubkey;
  } }), Object.defineProperty(e, "pubkeyType", { enumerable: !0, get: function() {
    return a.pubkeyType;
  } });
  var c = v;
  Object.defineProperty(e, "extractKdfConfiguration", { enumerable: !0, get: function() {
    return c.extractKdfConfiguration;
  } }), Object.defineProperty(e, "Secp256k1HdWallet", { enumerable: !0, get: function() {
    return c.Secp256k1HdWallet;
  } });
  var s = z;
  Object.defineProperty(e, "Secp256k1Wallet", { enumerable: !0, get: function() {
    return s.Secp256k1Wallet;
  } });
  var u = g;
  Object.defineProperty(e, "decodeSignature", { enumerable: !0, get: function() {
    return u.decodeSignature;
  } }), Object.defineProperty(e, "encodeSecp256k1Signature", { enumerable: !0, get: function() {
    return u.encodeSecp256k1Signature;
  } });
  var M = f;
  Object.defineProperty(e, "makeSignDoc", { enumerable: !0, get: function() {
    return M.makeSignDoc;
  } }), Object.defineProperty(e, "serializeSignDoc", { enumerable: !0, get: function() {
    return M.serializeSignDoc;
  } });
  var m = A;
  Object.defineProperty(e, "isStdTx", { enumerable: !0, get: function() {
    return m.isStdTx;
  } }), Object.defineProperty(e, "makeStdTx", { enumerable: !0, get: function() {
    return m.makeStdTx;
  } });
  var ye = F;
  Object.defineProperty(e, "executeKdf", { enumerable: !0, get: function() {
    return ye.executeKdf;
  } });
})(oe);
const ot = /* @__PURE__ */ le({
  __proto__: null
}, [oe]);
export {
  oe as b,
  ot as i
};
