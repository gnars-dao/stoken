import { c as Q, m as re, l as Pt, a as ye, h as ie, b as Le, t as eo, d as Be, s as Bi, e as Zu } from "./index-2b41ecf2.js";
import { a as Rt, b as ht, r as Qu, s as Fu, c as Gu, d as Vi } from "./index-005ea00d-8256b49b.js";
import { t as Ku, a as zu, b as tn } from "./index-a345f105-7d82abd5.js";
import { b as Mi } from "./index-8e30cada-47650c3c.js";
import "assert";
import "fs";
import "path";
import "buffer";
import "events";
import "util";
import "string_decoder";
function Yu(e, o) {
  for (var t = 0; t < o.length; t++) {
    const u = o[t];
    if (typeof u != "string" && !Array.isArray(u)) {
      for (const r in u)
        if (r !== "default" && !(r in e)) {
          const m = Object.getOwnPropertyDescriptor(u, r);
          m && Object.defineProperty(e, r, m.get ? m : {
            enumerable: !0,
            get: () => u[r]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var xd = {}, to = {}, Mo = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(D, B, U, C) {
    C === void 0 && (C = U);
    var l = Object.getOwnPropertyDescriptor(B, U);
    (!l || ("get" in l ? !B.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
      return B[U];
    } }), Object.defineProperty(D, C, l);
  } : function(D, B, U, C) {
    C === void 0 && (C = U), D[C] = B[U];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(D, B) {
    Object.defineProperty(D, "default", { enumerable: !0, value: B });
  } : function(D, B) {
    D.default = B;
  }), u = Q && Q.__importStar || function(D) {
    if (D && D.__esModule)
      return D;
    var B = {};
    if (D != null)
      for (var U in D)
        U !== "default" && Object.prototype.hasOwnProperty.call(D, U) && o(B, D, U);
    return t(B, D), B;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Params = e.ModuleCredential = e.ModuleAccount = e.BaseAccount = e.protobufPackage = void 0;
  const r = ye, m = ie, f = u(re);
  e.protobufPackage = "cosmos.auth.v1beta1";
  function b() {
    return {
      address: "",
      pubKey: void 0,
      accountNumber: m.Long.UZERO,
      sequence: m.Long.UZERO
    };
  }
  e.BaseAccount = {
    encode(D, B = f.Writer.create()) {
      return D.address !== "" && B.uint32(10).string(D.address), D.pubKey !== void 0 && r.Any.encode(D.pubKey, B.uint32(18).fork()).ldelim(), D.accountNumber.isZero() || B.uint32(24).uint64(D.accountNumber), D.sequence.isZero() || B.uint32(32).uint64(D.sequence), B;
    },
    decode(D, B) {
      const U = D instanceof f.Reader ? D : new f.Reader(D);
      let C = B === void 0 ? U.len : U.pos + B;
      const l = b();
      for (; U.pos < C; ) {
        const S = U.uint32();
        switch (S >>> 3) {
          case 1:
            l.address = U.string();
            break;
          case 2:
            l.pubKey = r.Any.decode(U, U.uint32());
            break;
          case 3:
            l.accountNumber = U.uint64();
            break;
          case 4:
            l.sequence = U.uint64();
            break;
          default:
            U.skipType(S & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(D) {
      return {
        address: (0, m.isSet)(D.address) ? String(D.address) : "",
        pubKey: (0, m.isSet)(D.pubKey) ? r.Any.fromJSON(D.pubKey) : void 0,
        accountNumber: (0, m.isSet)(D.accountNumber) ? m.Long.fromValue(D.accountNumber) : m.Long.UZERO,
        sequence: (0, m.isSet)(D.sequence) ? m.Long.fromValue(D.sequence) : m.Long.UZERO
      };
    },
    toJSON(D) {
      const B = {};
      return D.address !== void 0 && (B.address = D.address), D.pubKey !== void 0 && (B.pubKey = D.pubKey ? r.Any.toJSON(D.pubKey) : void 0), D.accountNumber !== void 0 && (B.accountNumber = (D.accountNumber || m.Long.UZERO).toString()), D.sequence !== void 0 && (B.sequence = (D.sequence || m.Long.UZERO).toString()), B;
    },
    fromPartial(D) {
      const B = b();
      return B.address = D.address ?? "", B.pubKey = D.pubKey !== void 0 && D.pubKey !== null ? r.Any.fromPartial(D.pubKey) : void 0, B.accountNumber = D.accountNumber !== void 0 && D.accountNumber !== null ? m.Long.fromValue(D.accountNumber) : m.Long.UZERO, B.sequence = D.sequence !== void 0 && D.sequence !== null ? m.Long.fromValue(D.sequence) : m.Long.UZERO, B;
    }
  };
  function R() {
    return {
      baseAccount: void 0,
      name: "",
      permissions: []
    };
  }
  e.ModuleAccount = {
    encode(D, B = f.Writer.create()) {
      D.baseAccount !== void 0 && e.BaseAccount.encode(D.baseAccount, B.uint32(10).fork()).ldelim(), D.name !== "" && B.uint32(18).string(D.name);
      for (const U of D.permissions)
        B.uint32(26).string(U);
      return B;
    },
    decode(D, B) {
      const U = D instanceof f.Reader ? D : new f.Reader(D);
      let C = B === void 0 ? U.len : U.pos + B;
      const l = R();
      for (; U.pos < C; ) {
        const S = U.uint32();
        switch (S >>> 3) {
          case 1:
            l.baseAccount = e.BaseAccount.decode(U, U.uint32());
            break;
          case 2:
            l.name = U.string();
            break;
          case 3:
            l.permissions.push(U.string());
            break;
          default:
            U.skipType(S & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(D) {
      return {
        baseAccount: (0, m.isSet)(D.baseAccount) ? e.BaseAccount.fromJSON(D.baseAccount) : void 0,
        name: (0, m.isSet)(D.name) ? String(D.name) : "",
        permissions: Array.isArray(D == null ? void 0 : D.permissions) ? D.permissions.map((B) => String(B)) : []
      };
    },
    toJSON(D) {
      const B = {};
      return D.baseAccount !== void 0 && (B.baseAccount = D.baseAccount ? e.BaseAccount.toJSON(D.baseAccount) : void 0), D.name !== void 0 && (B.name = D.name), D.permissions ? B.permissions = D.permissions.map((U) => U) : B.permissions = [], B;
    },
    fromPartial(D) {
      var B;
      const U = R();
      return U.baseAccount = D.baseAccount !== void 0 && D.baseAccount !== null ? e.BaseAccount.fromPartial(D.baseAccount) : void 0, U.name = D.name ?? "", U.permissions = ((B = D.permissions) == null ? void 0 : B.map((C) => C)) || [], U;
    }
  };
  function T() {
    return {
      moduleName: "",
      derivationKeys: []
    };
  }
  e.ModuleCredential = {
    encode(D, B = f.Writer.create()) {
      D.moduleName !== "" && B.uint32(10).string(D.moduleName);
      for (const U of D.derivationKeys)
        B.uint32(18).bytes(U);
      return B;
    },
    decode(D, B) {
      const U = D instanceof f.Reader ? D : new f.Reader(D);
      let C = B === void 0 ? U.len : U.pos + B;
      const l = T();
      for (; U.pos < C; ) {
        const S = U.uint32();
        switch (S >>> 3) {
          case 1:
            l.moduleName = U.string();
            break;
          case 2:
            l.derivationKeys.push(U.bytes());
            break;
          default:
            U.skipType(S & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(D) {
      return {
        moduleName: (0, m.isSet)(D.moduleName) ? String(D.moduleName) : "",
        derivationKeys: Array.isArray(D == null ? void 0 : D.derivationKeys) ? D.derivationKeys.map((B) => (0, m.bytesFromBase64)(B)) : []
      };
    },
    toJSON(D) {
      const B = {};
      return D.moduleName !== void 0 && (B.moduleName = D.moduleName), D.derivationKeys ? B.derivationKeys = D.derivationKeys.map((U) => (0, m.base64FromBytes)(U !== void 0 ? U : new Uint8Array())) : B.derivationKeys = [], B;
    },
    fromPartial(D) {
      var B;
      const U = T();
      return U.moduleName = D.moduleName ?? "", U.derivationKeys = ((B = D.derivationKeys) == null ? void 0 : B.map((C) => C)) || [], U;
    }
  };
  function V() {
    return {
      maxMemoCharacters: m.Long.UZERO,
      txSigLimit: m.Long.UZERO,
      txSizeCostPerByte: m.Long.UZERO,
      sigVerifyCostEd25519: m.Long.UZERO,
      sigVerifyCostSecp256k1: m.Long.UZERO
    };
  }
  e.Params = {
    encode(D, B = f.Writer.create()) {
      return D.maxMemoCharacters.isZero() || B.uint32(8).uint64(D.maxMemoCharacters), D.txSigLimit.isZero() || B.uint32(16).uint64(D.txSigLimit), D.txSizeCostPerByte.isZero() || B.uint32(24).uint64(D.txSizeCostPerByte), D.sigVerifyCostEd25519.isZero() || B.uint32(32).uint64(D.sigVerifyCostEd25519), D.sigVerifyCostSecp256k1.isZero() || B.uint32(40).uint64(D.sigVerifyCostSecp256k1), B;
    },
    decode(D, B) {
      const U = D instanceof f.Reader ? D : new f.Reader(D);
      let C = B === void 0 ? U.len : U.pos + B;
      const l = V();
      for (; U.pos < C; ) {
        const S = U.uint32();
        switch (S >>> 3) {
          case 1:
            l.maxMemoCharacters = U.uint64();
            break;
          case 2:
            l.txSigLimit = U.uint64();
            break;
          case 3:
            l.txSizeCostPerByte = U.uint64();
            break;
          case 4:
            l.sigVerifyCostEd25519 = U.uint64();
            break;
          case 5:
            l.sigVerifyCostSecp256k1 = U.uint64();
            break;
          default:
            U.skipType(S & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(D) {
      return {
        maxMemoCharacters: (0, m.isSet)(D.maxMemoCharacters) ? m.Long.fromValue(D.maxMemoCharacters) : m.Long.UZERO,
        txSigLimit: (0, m.isSet)(D.txSigLimit) ? m.Long.fromValue(D.txSigLimit) : m.Long.UZERO,
        txSizeCostPerByte: (0, m.isSet)(D.txSizeCostPerByte) ? m.Long.fromValue(D.txSizeCostPerByte) : m.Long.UZERO,
        sigVerifyCostEd25519: (0, m.isSet)(D.sigVerifyCostEd25519) ? m.Long.fromValue(D.sigVerifyCostEd25519) : m.Long.UZERO,
        sigVerifyCostSecp256k1: (0, m.isSet)(D.sigVerifyCostSecp256k1) ? m.Long.fromValue(D.sigVerifyCostSecp256k1) : m.Long.UZERO
      };
    },
    toJSON(D) {
      const B = {};
      return D.maxMemoCharacters !== void 0 && (B.maxMemoCharacters = (D.maxMemoCharacters || m.Long.UZERO).toString()), D.txSigLimit !== void 0 && (B.txSigLimit = (D.txSigLimit || m.Long.UZERO).toString()), D.txSizeCostPerByte !== void 0 && (B.txSizeCostPerByte = (D.txSizeCostPerByte || m.Long.UZERO).toString()), D.sigVerifyCostEd25519 !== void 0 && (B.sigVerifyCostEd25519 = (D.sigVerifyCostEd25519 || m.Long.UZERO).toString()), D.sigVerifyCostSecp256k1 !== void 0 && (B.sigVerifyCostSecp256k1 = (D.sigVerifyCostSecp256k1 || m.Long.UZERO).toString()), B;
    },
    fromPartial(D) {
      const B = V();
      return B.maxMemoCharacters = D.maxMemoCharacters !== void 0 && D.maxMemoCharacters !== null ? m.Long.fromValue(D.maxMemoCharacters) : m.Long.UZERO, B.txSigLimit = D.txSigLimit !== void 0 && D.txSigLimit !== null ? m.Long.fromValue(D.txSigLimit) : m.Long.UZERO, B.txSizeCostPerByte = D.txSizeCostPerByte !== void 0 && D.txSizeCostPerByte !== null ? m.Long.fromValue(D.txSizeCostPerByte) : m.Long.UZERO, B.sigVerifyCostEd25519 = D.sigVerifyCostEd25519 !== void 0 && D.sigVerifyCostEd25519 !== null ? m.Long.fromValue(D.sigVerifyCostEd25519) : m.Long.UZERO, B.sigVerifyCostSecp256k1 = D.sigVerifyCostSecp256k1 !== void 0 && D.sigVerifyCostSecp256k1 !== null ? m.Long.fromValue(D.sigVerifyCostSecp256k1) : m.Long.UZERO, B;
    }
  };
})(Mo);
var Hi = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(C, l, S, A) {
    A === void 0 && (A = S);
    var d = Object.getOwnPropertyDescriptor(l, S);
    (!d || ("get" in d ? !l.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return l[S];
    } }), Object.defineProperty(C, A, d);
  } : function(C, l, S, A) {
    A === void 0 && (A = S), C[A] = l[S];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(C, l) {
    Object.defineProperty(C, "default", { enumerable: !0, value: l });
  } : function(C, l) {
    C.default = l;
  }), u = Q && Q.__importStar || function(C) {
    if (C && C.__esModule)
      return C;
    var l = {};
    if (C != null)
      for (var S in C)
        S !== "default" && Object.prototype.hasOwnProperty.call(C, S) && o(l, C, S);
    return t(l, C), l;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.PermanentLockedAccount = e.PeriodicVestingAccount = e.Period = e.DelayedVestingAccount = e.ContinuousVestingAccount = e.BaseVestingAccount = e.protobufPackage = void 0;
  const r = Mo, m = Le, f = ie, b = u(re);
  e.protobufPackage = "cosmos.vesting.v1beta1";
  function R() {
    return {
      baseAccount: void 0,
      originalVesting: [],
      delegatedFree: [],
      delegatedVesting: [],
      endTime: f.Long.ZERO
    };
  }
  e.BaseVestingAccount = {
    encode(C, l = b.Writer.create()) {
      C.baseAccount !== void 0 && r.BaseAccount.encode(C.baseAccount, l.uint32(10).fork()).ldelim();
      for (const S of C.originalVesting)
        m.Coin.encode(S, l.uint32(18).fork()).ldelim();
      for (const S of C.delegatedFree)
        m.Coin.encode(S, l.uint32(26).fork()).ldelim();
      for (const S of C.delegatedVesting)
        m.Coin.encode(S, l.uint32(34).fork()).ldelim();
      return C.endTime.isZero() || l.uint32(40).int64(C.endTime), l;
    },
    decode(C, l) {
      const S = C instanceof b.Reader ? C : new b.Reader(C);
      let A = l === void 0 ? S.len : S.pos + l;
      const d = R();
      for (; S.pos < A; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.baseAccount = r.BaseAccount.decode(S, S.uint32());
            break;
          case 2:
            d.originalVesting.push(m.Coin.decode(S, S.uint32()));
            break;
          case 3:
            d.delegatedFree.push(m.Coin.decode(S, S.uint32()));
            break;
          case 4:
            d.delegatedVesting.push(m.Coin.decode(S, S.uint32()));
            break;
          case 5:
            d.endTime = S.int64();
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(C) {
      return {
        baseAccount: (0, f.isSet)(C.baseAccount) ? r.BaseAccount.fromJSON(C.baseAccount) : void 0,
        originalVesting: Array.isArray(C == null ? void 0 : C.originalVesting) ? C.originalVesting.map((l) => m.Coin.fromJSON(l)) : [],
        delegatedFree: Array.isArray(C == null ? void 0 : C.delegatedFree) ? C.delegatedFree.map((l) => m.Coin.fromJSON(l)) : [],
        delegatedVesting: Array.isArray(C == null ? void 0 : C.delegatedVesting) ? C.delegatedVesting.map((l) => m.Coin.fromJSON(l)) : [],
        endTime: (0, f.isSet)(C.endTime) ? f.Long.fromValue(C.endTime) : f.Long.ZERO
      };
    },
    toJSON(C) {
      const l = {};
      return C.baseAccount !== void 0 && (l.baseAccount = C.baseAccount ? r.BaseAccount.toJSON(C.baseAccount) : void 0), C.originalVesting ? l.originalVesting = C.originalVesting.map((S) => S ? m.Coin.toJSON(S) : void 0) : l.originalVesting = [], C.delegatedFree ? l.delegatedFree = C.delegatedFree.map((S) => S ? m.Coin.toJSON(S) : void 0) : l.delegatedFree = [], C.delegatedVesting ? l.delegatedVesting = C.delegatedVesting.map((S) => S ? m.Coin.toJSON(S) : void 0) : l.delegatedVesting = [], C.endTime !== void 0 && (l.endTime = (C.endTime || f.Long.ZERO).toString()), l;
    },
    fromPartial(C) {
      var l, S, A;
      const d = R();
      return d.baseAccount = C.baseAccount !== void 0 && C.baseAccount !== null ? r.BaseAccount.fromPartial(C.baseAccount) : void 0, d.originalVesting = ((l = C.originalVesting) == null ? void 0 : l.map((p) => m.Coin.fromPartial(p))) || [], d.delegatedFree = ((S = C.delegatedFree) == null ? void 0 : S.map((p) => m.Coin.fromPartial(p))) || [], d.delegatedVesting = ((A = C.delegatedVesting) == null ? void 0 : A.map((p) => m.Coin.fromPartial(p))) || [], d.endTime = C.endTime !== void 0 && C.endTime !== null ? f.Long.fromValue(C.endTime) : f.Long.ZERO, d;
    }
  };
  function T() {
    return {
      baseVestingAccount: void 0,
      startTime: f.Long.ZERO
    };
  }
  e.ContinuousVestingAccount = {
    encode(C, l = b.Writer.create()) {
      return C.baseVestingAccount !== void 0 && e.BaseVestingAccount.encode(C.baseVestingAccount, l.uint32(10).fork()).ldelim(), C.startTime.isZero() || l.uint32(16).int64(C.startTime), l;
    },
    decode(C, l) {
      const S = C instanceof b.Reader ? C : new b.Reader(C);
      let A = l === void 0 ? S.len : S.pos + l;
      const d = T();
      for (; S.pos < A; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.baseVestingAccount = e.BaseVestingAccount.decode(S, S.uint32());
            break;
          case 2:
            d.startTime = S.int64();
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(C) {
      return {
        baseVestingAccount: (0, f.isSet)(C.baseVestingAccount) ? e.BaseVestingAccount.fromJSON(C.baseVestingAccount) : void 0,
        startTime: (0, f.isSet)(C.startTime) ? f.Long.fromValue(C.startTime) : f.Long.ZERO
      };
    },
    toJSON(C) {
      const l = {};
      return C.baseVestingAccount !== void 0 && (l.baseVestingAccount = C.baseVestingAccount ? e.BaseVestingAccount.toJSON(C.baseVestingAccount) : void 0), C.startTime !== void 0 && (l.startTime = (C.startTime || f.Long.ZERO).toString()), l;
    },
    fromPartial(C) {
      const l = T();
      return l.baseVestingAccount = C.baseVestingAccount !== void 0 && C.baseVestingAccount !== null ? e.BaseVestingAccount.fromPartial(C.baseVestingAccount) : void 0, l.startTime = C.startTime !== void 0 && C.startTime !== null ? f.Long.fromValue(C.startTime) : f.Long.ZERO, l;
    }
  };
  function V() {
    return {
      baseVestingAccount: void 0
    };
  }
  e.DelayedVestingAccount = {
    encode(C, l = b.Writer.create()) {
      return C.baseVestingAccount !== void 0 && e.BaseVestingAccount.encode(C.baseVestingAccount, l.uint32(10).fork()).ldelim(), l;
    },
    decode(C, l) {
      const S = C instanceof b.Reader ? C : new b.Reader(C);
      let A = l === void 0 ? S.len : S.pos + l;
      const d = V();
      for (; S.pos < A; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.baseVestingAccount = e.BaseVestingAccount.decode(S, S.uint32());
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(C) {
      return {
        baseVestingAccount: (0, f.isSet)(C.baseVestingAccount) ? e.BaseVestingAccount.fromJSON(C.baseVestingAccount) : void 0
      };
    },
    toJSON(C) {
      const l = {};
      return C.baseVestingAccount !== void 0 && (l.baseVestingAccount = C.baseVestingAccount ? e.BaseVestingAccount.toJSON(C.baseVestingAccount) : void 0), l;
    },
    fromPartial(C) {
      const l = V();
      return l.baseVestingAccount = C.baseVestingAccount !== void 0 && C.baseVestingAccount !== null ? e.BaseVestingAccount.fromPartial(C.baseVestingAccount) : void 0, l;
    }
  };
  function D() {
    return {
      length: f.Long.ZERO,
      amount: []
    };
  }
  e.Period = {
    encode(C, l = b.Writer.create()) {
      C.length.isZero() || l.uint32(8).int64(C.length);
      for (const S of C.amount)
        m.Coin.encode(S, l.uint32(18).fork()).ldelim();
      return l;
    },
    decode(C, l) {
      const S = C instanceof b.Reader ? C : new b.Reader(C);
      let A = l === void 0 ? S.len : S.pos + l;
      const d = D();
      for (; S.pos < A; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.length = S.int64();
            break;
          case 2:
            d.amount.push(m.Coin.decode(S, S.uint32()));
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(C) {
      return {
        length: (0, f.isSet)(C.length) ? f.Long.fromValue(C.length) : f.Long.ZERO,
        amount: Array.isArray(C == null ? void 0 : C.amount) ? C.amount.map((l) => m.Coin.fromJSON(l)) : []
      };
    },
    toJSON(C) {
      const l = {};
      return C.length !== void 0 && (l.length = (C.length || f.Long.ZERO).toString()), C.amount ? l.amount = C.amount.map((S) => S ? m.Coin.toJSON(S) : void 0) : l.amount = [], l;
    },
    fromPartial(C) {
      var l;
      const S = D();
      return S.length = C.length !== void 0 && C.length !== null ? f.Long.fromValue(C.length) : f.Long.ZERO, S.amount = ((l = C.amount) == null ? void 0 : l.map((A) => m.Coin.fromPartial(A))) || [], S;
    }
  };
  function B() {
    return {
      baseVestingAccount: void 0,
      startTime: f.Long.ZERO,
      vestingPeriods: []
    };
  }
  e.PeriodicVestingAccount = {
    encode(C, l = b.Writer.create()) {
      C.baseVestingAccount !== void 0 && e.BaseVestingAccount.encode(C.baseVestingAccount, l.uint32(10).fork()).ldelim(), C.startTime.isZero() || l.uint32(16).int64(C.startTime);
      for (const S of C.vestingPeriods)
        e.Period.encode(S, l.uint32(26).fork()).ldelim();
      return l;
    },
    decode(C, l) {
      const S = C instanceof b.Reader ? C : new b.Reader(C);
      let A = l === void 0 ? S.len : S.pos + l;
      const d = B();
      for (; S.pos < A; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.baseVestingAccount = e.BaseVestingAccount.decode(S, S.uint32());
            break;
          case 2:
            d.startTime = S.int64();
            break;
          case 3:
            d.vestingPeriods.push(e.Period.decode(S, S.uint32()));
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(C) {
      return {
        baseVestingAccount: (0, f.isSet)(C.baseVestingAccount) ? e.BaseVestingAccount.fromJSON(C.baseVestingAccount) : void 0,
        startTime: (0, f.isSet)(C.startTime) ? f.Long.fromValue(C.startTime) : f.Long.ZERO,
        vestingPeriods: Array.isArray(C == null ? void 0 : C.vestingPeriods) ? C.vestingPeriods.map((l) => e.Period.fromJSON(l)) : []
      };
    },
    toJSON(C) {
      const l = {};
      return C.baseVestingAccount !== void 0 && (l.baseVestingAccount = C.baseVestingAccount ? e.BaseVestingAccount.toJSON(C.baseVestingAccount) : void 0), C.startTime !== void 0 && (l.startTime = (C.startTime || f.Long.ZERO).toString()), C.vestingPeriods ? l.vestingPeriods = C.vestingPeriods.map((S) => S ? e.Period.toJSON(S) : void 0) : l.vestingPeriods = [], l;
    },
    fromPartial(C) {
      var l;
      const S = B();
      return S.baseVestingAccount = C.baseVestingAccount !== void 0 && C.baseVestingAccount !== null ? e.BaseVestingAccount.fromPartial(C.baseVestingAccount) : void 0, S.startTime = C.startTime !== void 0 && C.startTime !== null ? f.Long.fromValue(C.startTime) : f.Long.ZERO, S.vestingPeriods = ((l = C.vestingPeriods) == null ? void 0 : l.map((A) => e.Period.fromPartial(A))) || [], S;
    }
  };
  function U() {
    return {
      baseVestingAccount: void 0
    };
  }
  e.PermanentLockedAccount = {
    encode(C, l = b.Writer.create()) {
      return C.baseVestingAccount !== void 0 && e.BaseVestingAccount.encode(C.baseVestingAccount, l.uint32(10).fork()).ldelim(), l;
    },
    decode(C, l) {
      const S = C instanceof b.Reader ? C : new b.Reader(C);
      let A = l === void 0 ? S.len : S.pos + l;
      const d = U();
      for (; S.pos < A; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.baseVestingAccount = e.BaseVestingAccount.decode(S, S.uint32());
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(C) {
      return {
        baseVestingAccount: (0, f.isSet)(C.baseVestingAccount) ? e.BaseVestingAccount.fromJSON(C.baseVestingAccount) : void 0
      };
    },
    toJSON(C) {
      const l = {};
      return C.baseVestingAccount !== void 0 && (l.baseVestingAccount = C.baseVestingAccount ? e.BaseVestingAccount.toJSON(C.baseVestingAccount) : void 0), l;
    },
    fromPartial(C) {
      const l = U();
      return l.baseVestingAccount = C.baseVestingAccount !== void 0 && C.baseVestingAccount !== null ? e.BaseVestingAccount.fromPartial(C.baseVestingAccount) : void 0, l;
    }
  };
})(Hi);
Object.defineProperty(to, "__esModule", { value: !0 });
to.accountFromAny = void 0;
const $u = Rt, Xu = tn, Mn = ht, Ks = Mo, lo = Hi;
function zs(e) {
  return $u.Uint64.fromString(e.toString());
}
function dn(e) {
  const { address: o, pubKey: t, accountNumber: u, sequence: r } = e, m = t ? (0, Xu.decodePubkey)(t) : null;
  return {
    address: o,
    pubkey: m,
    accountNumber: zs(u).toNumber(),
    sequence: zs(r).toNumber()
  };
}
function el(e) {
  var o, t, u, r, m, f, b;
  const { typeUrl: R, value: T } = e;
  switch (R) {
    case "/cosmos.auth.v1beta1.BaseAccount":
      return dn(Ks.BaseAccount.decode(T));
    case "/cosmos.auth.v1beta1.ModuleAccount": {
      const V = Ks.ModuleAccount.decode(T).baseAccount;
      return (0, Mn.assert)(V), dn(V);
    }
    case "/cosmos.vesting.v1beta1.BaseVestingAccount": {
      const V = (o = lo.BaseVestingAccount.decode(T)) == null ? void 0 : o.baseAccount;
      return (0, Mn.assert)(V), dn(V);
    }
    case "/cosmos.vesting.v1beta1.ContinuousVestingAccount": {
      const V = (u = (t = lo.ContinuousVestingAccount.decode(T)) == null ? void 0 : t.baseVestingAccount) == null ? void 0 : u.baseAccount;
      return (0, Mn.assert)(V), dn(V);
    }
    case "/cosmos.vesting.v1beta1.DelayedVestingAccount": {
      const V = (m = (r = lo.DelayedVestingAccount.decode(T)) == null ? void 0 : r.baseVestingAccount) == null ? void 0 : m.baseAccount;
      return (0, Mn.assert)(V), dn(V);
    }
    case "/cosmos.vesting.v1beta1.PeriodicVestingAccount": {
      const V = (b = (f = lo.PeriodicVestingAccount.decode(T)) == null ? void 0 : f.baseVestingAccount) == null ? void 0 : b.baseAccount;
      return (0, Mn.assert)(V), dn(V);
    }
    default:
      throw new Error(`Unsupported type: '${R}'`);
  }
}
to.accountFromAny = el;
var no = {};
Object.defineProperty(no, "__esModule", { value: !0 });
no.AminoTypes = void 0;
class tl {
  constructor(o) {
    this.register = o;
  }
  toAmino({ typeUrl: o, value: t }) {
    const u = this.register[o];
    if (!u)
      throw new Error(`Type URL '${o}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
    return {
      type: u.aminoType,
      value: u.toAmino(t)
    };
  }
  fromAmino({ type: o, value: t }) {
    const u = Object.entries(this.register).filter(([r, { aminoType: m }]) => m === o);
    switch (u.length) {
      case 0:
        throw new Error(`Amino type identifier '${o}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
      case 1: {
        const [r, m] = u[0];
        return {
          typeUrl: r,
          value: m.fromAmino(t)
        };
      }
      default:
        throw new Error(`Multiple types are registered with Amino type identifier '${o}': '` + u.map(([r, m]) => r).sort().join("', '") + "'. Thus fromAmino cannot be performed.");
    }
  }
}
no.AminoTypes = tl;
var oo = {};
Object.defineProperty(oo, "__esModule", { value: !0 });
oo.fromTendermintEvent = void 0;
const Ys = Be;
function nl(e) {
  return {
    type: e.type,
    attributes: e.attributes.map((o) => ({
      key: typeof o.key == "string" ? o.key : (0, Ys.fromUtf8)(o.key, !0),
      value: typeof o.value == "string" ? o.value : (0, Ys.fromUtf8)(o.value, !0)
    }))
  };
}
oo.fromTendermintEvent = nl;
var Yt = {};
Object.defineProperty(Yt, "__esModule", { value: !0 });
Yt.calculateFee = Yt.GasPrice = void 0;
const _d = Rt, ol = tn;
function rl(e) {
  if (e.length < 3 || e.length > 128)
    throw new Error("Denom must be between 3 and 128 characters");
}
class Ho {
  constructor(o, t) {
    this.amount = o, this.denom = t;
  }
  /**
   * Parses a gas price formatted as `<amount><denom>`, e.g. `GasPrice.fromString("0.012utoken")`.
   *
   * The denom must match the Cosmos SDK 0.42 pattern (https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/types/coin.go#L599-L601).
   * See `GasPrice` in @cosmjs/stargate for a more generic matcher.
   *
   * Separators are not yet supported.
   */
  static fromString(o) {
    const t = o.match(/^([0-9.]+)([a-z][a-z0-9]*)$/i);
    if (!t)
      throw new Error("Invalid gas price string");
    const [u, r, m] = t;
    rl(m);
    const f = 18, b = _d.Decimal.fromUserInput(r, f);
    return new Ho(b, m);
  }
  /**
   * Returns a string representation of this gas price, e.g. "0.025uatom".
   * This can be used as an input to `GasPrice.fromString`.
   */
  toString() {
    return this.amount.toString() + this.denom;
  }
}
Yt.GasPrice = Ho;
function il(e, o) {
  const t = typeof o == "string" ? Ho.fromString(o) : o, { denom: u, amount: r } = t, m = r.multiply(new _d.Uint53(e)).ceil().toString();
  return {
    amount: (0, ol.coins)(m, u),
    gas: e.toString()
  };
}
Yt.calculateFee = il;
var Ze = {};
Object.defineProperty(Ze, "__esModule", { value: !0 });
Ze.findAttribute = Ze.parseRawLog = Ze.parseLogs = Ze.parseLog = Ze.parseEvent = Ze.parseAttribute = void 0;
const ji = ht;
function Jd(e) {
  if (!(0, ji.isNonNullObject)(e))
    throw new Error("Attribute must be a non-null object");
  const { key: o, value: t } = e;
  if (typeof o != "string" || !o)
    throw new Error("Attribute's key must be a non-empty string");
  if (typeof t != "string" && typeof t < "u")
    throw new Error("Attribute's value must be a string or unset");
  return {
    key: o,
    value: t || ""
  };
}
Ze.parseAttribute = Jd;
function Ud(e) {
  if (!(0, ji.isNonNullObject)(e))
    throw new Error("Event must be a non-null object");
  const { type: o, attributes: t } = e;
  if (typeof o != "string" || o === "")
    throw new Error("Event type must be a non-empty string");
  if (!Array.isArray(t))
    throw new Error("Event's attributes must be an array");
  return {
    type: o,
    attributes: t.map(Jd)
  };
}
Ze.parseEvent = Ud;
function Dd(e) {
  if (!(0, ji.isNonNullObject)(e))
    throw new Error("Log must be a non-null object");
  const { msg_index: o, log: t, events: u } = e;
  if (typeof o != "number")
    throw new Error("Log's msg_index must be a number");
  if (typeof t != "string")
    throw new Error("Log's log must be a string");
  if (!Array.isArray(u))
    throw new Error("Log's events must be an array");
  return {
    msg_index: o,
    log: t,
    events: u.map(Ud)
  };
}
Ze.parseLog = Dd;
function Ld(e) {
  if (!Array.isArray(e))
    throw new Error("Logs must be an array");
  return e.map(Dd);
}
Ze.parseLogs = Ld;
function sl(e = "[]") {
  const o = JSON.parse(e).map(({ events: t }, u) => ({
    msg_index: u,
    events: t,
    log: ""
  }));
  return Ld(o);
}
Ze.parseRawLog = sl;
function al(e, o, t) {
  var u;
  const r = e.find(() => !0), m = (u = r == null ? void 0 : r.events.find((f) => f.type === o)) == null ? void 0 : u.attributes.find((f) => f.key === t);
  if (!m)
    throw new Error(`Could not find attribute '${t}' in first event of type '${o}' in first log.`);
  return m;
}
Ze.findAttribute = al;
var Yn = {}, jo = {}, Bd = {}, be = {}, dl = Q && Q.__createBinding || (Object.create ? function(e, o, t, u) {
  u === void 0 && (u = t);
  var r = Object.getOwnPropertyDescriptor(o, t);
  (!r || ("get" in r ? !o.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return o[t];
  } }), Object.defineProperty(e, u, r);
} : function(e, o, t, u) {
  u === void 0 && (u = t), e[u] = o[t];
}), cl = Q && Q.__setModuleDefault || (Object.create ? function(e, o) {
  Object.defineProperty(e, "default", { enumerable: !0, value: o });
} : function(e, o) {
  e.default = o;
}), ul = Q && Q.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var o = {};
  if (e != null)
    for (var t in e)
      t !== "default" && Object.prototype.hasOwnProperty.call(e, t) && dl(o, e, t);
  return cl(o, e), o;
};
Object.defineProperty(be, "__esModule", { value: !0 });
be.PageResponse = be.PageRequest = be.protobufPackage = void 0;
const ge = ie, hn = ul(re);
be.protobufPackage = "cosmos.base.query.v1beta1";
function $s() {
  return {
    key: new Uint8Array(),
    offset: ge.Long.UZERO,
    limit: ge.Long.UZERO,
    countTotal: !1,
    reverse: !1
  };
}
be.PageRequest = {
  encode(e, o = hn.Writer.create()) {
    return e.key.length !== 0 && o.uint32(10).bytes(e.key), e.offset.isZero() || o.uint32(16).uint64(e.offset), e.limit.isZero() || o.uint32(24).uint64(e.limit), e.countTotal === !0 && o.uint32(32).bool(e.countTotal), e.reverse === !0 && o.uint32(40).bool(e.reverse), o;
  },
  decode(e, o) {
    const t = e instanceof hn.Reader ? e : new hn.Reader(e);
    let u = o === void 0 ? t.len : t.pos + o;
    const r = $s();
    for (; t.pos < u; ) {
      const m = t.uint32();
      switch (m >>> 3) {
        case 1:
          r.key = t.bytes();
          break;
        case 2:
          r.offset = t.uint64();
          break;
        case 3:
          r.limit = t.uint64();
          break;
        case 4:
          r.countTotal = t.bool();
          break;
        case 5:
          r.reverse = t.bool();
          break;
        default:
          t.skipType(m & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      key: (0, ge.isSet)(e.key) ? (0, ge.bytesFromBase64)(e.key) : new Uint8Array(),
      offset: (0, ge.isSet)(e.offset) ? ge.Long.fromValue(e.offset) : ge.Long.UZERO,
      limit: (0, ge.isSet)(e.limit) ? ge.Long.fromValue(e.limit) : ge.Long.UZERO,
      countTotal: (0, ge.isSet)(e.countTotal) ? !!e.countTotal : !1,
      reverse: (0, ge.isSet)(e.reverse) ? !!e.reverse : !1
    };
  },
  toJSON(e) {
    const o = {};
    return e.key !== void 0 && (o.key = (0, ge.base64FromBytes)(e.key !== void 0 ? e.key : new Uint8Array())), e.offset !== void 0 && (o.offset = (e.offset || ge.Long.UZERO).toString()), e.limit !== void 0 && (o.limit = (e.limit || ge.Long.UZERO).toString()), e.countTotal !== void 0 && (o.countTotal = e.countTotal), e.reverse !== void 0 && (o.reverse = e.reverse), o;
  },
  fromPartial(e) {
    const o = $s();
    return o.key = e.key ?? new Uint8Array(), o.offset = e.offset !== void 0 && e.offset !== null ? ge.Long.fromValue(e.offset) : ge.Long.UZERO, o.limit = e.limit !== void 0 && e.limit !== null ? ge.Long.fromValue(e.limit) : ge.Long.UZERO, o.countTotal = e.countTotal ?? !1, o.reverse = e.reverse ?? !1, o;
  }
};
function Xs() {
  return {
    nextKey: new Uint8Array(),
    total: ge.Long.UZERO
  };
}
be.PageResponse = {
  encode(e, o = hn.Writer.create()) {
    return e.nextKey.length !== 0 && o.uint32(10).bytes(e.nextKey), e.total.isZero() || o.uint32(16).uint64(e.total), o;
  },
  decode(e, o) {
    const t = e instanceof hn.Reader ? e : new hn.Reader(e);
    let u = o === void 0 ? t.len : t.pos + o;
    const r = Xs();
    for (; t.pos < u; ) {
      const m = t.uint32();
      switch (m >>> 3) {
        case 1:
          r.nextKey = t.bytes();
          break;
        case 2:
          r.total = t.uint64();
          break;
        default:
          t.skipType(m & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      nextKey: (0, ge.isSet)(e.nextKey) ? (0, ge.bytesFromBase64)(e.nextKey) : new Uint8Array(),
      total: (0, ge.isSet)(e.total) ? ge.Long.fromValue(e.total) : ge.Long.UZERO
    };
  },
  toJSON(e) {
    const o = {};
    return e.nextKey !== void 0 && (o.nextKey = (0, ge.base64FromBytes)(e.nextKey !== void 0 ? e.nextKey : new Uint8Array())), e.total !== void 0 && (o.total = (e.total || ge.Long.UZERO).toString()), o;
  },
  fromPartial(e) {
    const o = Xs();
    return o.nextKey = e.nextKey ?? new Uint8Array(), o.total = e.total !== void 0 && e.total !== null ? ge.Long.fromValue(e.total) : ge.Long.UZERO, o;
  }
};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(c, E, k, O) {
    O === void 0 && (O = k);
    var L = Object.getOwnPropertyDescriptor(E, k);
    (!L || ("get" in L ? !E.__esModule : L.writable || L.configurable)) && (L = { enumerable: !0, get: function() {
      return E[k];
    } }), Object.defineProperty(c, O, L);
  } : function(c, E, k, O) {
    O === void 0 && (O = k), c[O] = E[k];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(c, E) {
    Object.defineProperty(c, "default", { enumerable: !0, value: E });
  } : function(c, E) {
    c.default = E;
  }), u = Q && Q.__importStar || function(c) {
    if (c && c.__esModule)
      return c;
    var E = {};
    if (c != null)
      for (var k in c)
        k !== "default" && Object.prototype.hasOwnProperty.call(c, k) && o(E, c, k);
    return t(E, c), E;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryAccountInfoResponse = e.QueryAccountInfoRequest = e.QueryAccountAddressByIDResponse = e.QueryAccountAddressByIDRequest = e.AddressStringToBytesResponse = e.AddressStringToBytesRequest = e.AddressBytesToStringResponse = e.AddressBytesToStringRequest = e.Bech32PrefixResponse = e.Bech32PrefixRequest = e.QueryModuleAccountByNameResponse = e.QueryModuleAccountByNameRequest = e.QueryModuleAccountsResponse = e.QueryModuleAccountsRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.QueryAccountResponse = e.QueryAccountRequest = e.QueryAccountsResponse = e.QueryAccountsRequest = e.protobufPackage = void 0;
  const r = be, m = ye, f = Mo, b = ie, R = u(re);
  e.protobufPackage = "cosmos.auth.v1beta1";
  function T() {
    return {
      pagination: void 0
    };
  }
  e.QueryAccountsRequest = {
    encode(c, E = R.Writer.create()) {
      return c.pagination !== void 0 && r.PageRequest.encode(c.pagination, E.uint32(10).fork()).ldelim(), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = T();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.pagination = r.PageRequest.decode(k, k.uint32());
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        pagination: (0, b.isSet)(c.pagination) ? r.PageRequest.fromJSON(c.pagination) : void 0
      };
    },
    toJSON(c) {
      const E = {};
      return c.pagination !== void 0 && (E.pagination = c.pagination ? r.PageRequest.toJSON(c.pagination) : void 0), E;
    },
    fromPartial(c) {
      const E = T();
      return E.pagination = c.pagination !== void 0 && c.pagination !== null ? r.PageRequest.fromPartial(c.pagination) : void 0, E;
    }
  };
  function V() {
    return {
      accounts: [],
      pagination: void 0
    };
  }
  e.QueryAccountsResponse = {
    encode(c, E = R.Writer.create()) {
      for (const k of c.accounts)
        m.Any.encode(k, E.uint32(10).fork()).ldelim();
      return c.pagination !== void 0 && r.PageResponse.encode(c.pagination, E.uint32(18).fork()).ldelim(), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = V();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.accounts.push(m.Any.decode(k, k.uint32()));
            break;
          case 2:
            L.pagination = r.PageResponse.decode(k, k.uint32());
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        accounts: Array.isArray(c == null ? void 0 : c.accounts) ? c.accounts.map((E) => m.Any.fromJSON(E)) : [],
        pagination: (0, b.isSet)(c.pagination) ? r.PageResponse.fromJSON(c.pagination) : void 0
      };
    },
    toJSON(c) {
      const E = {};
      return c.accounts ? E.accounts = c.accounts.map((k) => k ? m.Any.toJSON(k) : void 0) : E.accounts = [], c.pagination !== void 0 && (E.pagination = c.pagination ? r.PageResponse.toJSON(c.pagination) : void 0), E;
    },
    fromPartial(c) {
      var E;
      const k = V();
      return k.accounts = ((E = c.accounts) == null ? void 0 : E.map((O) => m.Any.fromPartial(O))) || [], k.pagination = c.pagination !== void 0 && c.pagination !== null ? r.PageResponse.fromPartial(c.pagination) : void 0, k;
    }
  };
  function D() {
    return {
      address: ""
    };
  }
  e.QueryAccountRequest = {
    encode(c, E = R.Writer.create()) {
      return c.address !== "" && E.uint32(10).string(c.address), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = D();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.address = k.string();
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        address: (0, b.isSet)(c.address) ? String(c.address) : ""
      };
    },
    toJSON(c) {
      const E = {};
      return c.address !== void 0 && (E.address = c.address), E;
    },
    fromPartial(c) {
      const E = D();
      return E.address = c.address ?? "", E;
    }
  };
  function B() {
    return {
      account: void 0
    };
  }
  e.QueryAccountResponse = {
    encode(c, E = R.Writer.create()) {
      return c.account !== void 0 && m.Any.encode(c.account, E.uint32(10).fork()).ldelim(), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = B();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.account = m.Any.decode(k, k.uint32());
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        account: (0, b.isSet)(c.account) ? m.Any.fromJSON(c.account) : void 0
      };
    },
    toJSON(c) {
      const E = {};
      return c.account !== void 0 && (E.account = c.account ? m.Any.toJSON(c.account) : void 0), E;
    },
    fromPartial(c) {
      const E = B();
      return E.account = c.account !== void 0 && c.account !== null ? m.Any.fromPartial(c.account) : void 0, E;
    }
  };
  function U() {
    return {};
  }
  e.QueryParamsRequest = {
    encode(c, E = R.Writer.create()) {
      return E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = U();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {};
    },
    toJSON(c) {
      return {};
    },
    fromPartial(c) {
      return U();
    }
  };
  function C() {
    return {
      params: void 0
    };
  }
  e.QueryParamsResponse = {
    encode(c, E = R.Writer.create()) {
      return c.params !== void 0 && f.Params.encode(c.params, E.uint32(10).fork()).ldelim(), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = C();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.params = f.Params.decode(k, k.uint32());
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        params: (0, b.isSet)(c.params) ? f.Params.fromJSON(c.params) : void 0
      };
    },
    toJSON(c) {
      const E = {};
      return c.params !== void 0 && (E.params = c.params ? f.Params.toJSON(c.params) : void 0), E;
    },
    fromPartial(c) {
      const E = C();
      return E.params = c.params !== void 0 && c.params !== null ? f.Params.fromPartial(c.params) : void 0, E;
    }
  };
  function l() {
    return {};
  }
  e.QueryModuleAccountsRequest = {
    encode(c, E = R.Writer.create()) {
      return E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = l();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {};
    },
    toJSON(c) {
      return {};
    },
    fromPartial(c) {
      return l();
    }
  };
  function S() {
    return {
      accounts: []
    };
  }
  e.QueryModuleAccountsResponse = {
    encode(c, E = R.Writer.create()) {
      for (const k of c.accounts)
        m.Any.encode(k, E.uint32(10).fork()).ldelim();
      return E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = S();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.accounts.push(m.Any.decode(k, k.uint32()));
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        accounts: Array.isArray(c == null ? void 0 : c.accounts) ? c.accounts.map((E) => m.Any.fromJSON(E)) : []
      };
    },
    toJSON(c) {
      const E = {};
      return c.accounts ? E.accounts = c.accounts.map((k) => k ? m.Any.toJSON(k) : void 0) : E.accounts = [], E;
    },
    fromPartial(c) {
      var E;
      const k = S();
      return k.accounts = ((E = c.accounts) == null ? void 0 : E.map((O) => m.Any.fromPartial(O))) || [], k;
    }
  };
  function A() {
    return {
      name: ""
    };
  }
  e.QueryModuleAccountByNameRequest = {
    encode(c, E = R.Writer.create()) {
      return c.name !== "" && E.uint32(10).string(c.name), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = A();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.name = k.string();
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        name: (0, b.isSet)(c.name) ? String(c.name) : ""
      };
    },
    toJSON(c) {
      const E = {};
      return c.name !== void 0 && (E.name = c.name), E;
    },
    fromPartial(c) {
      const E = A();
      return E.name = c.name ?? "", E;
    }
  };
  function d() {
    return {
      account: void 0
    };
  }
  e.QueryModuleAccountByNameResponse = {
    encode(c, E = R.Writer.create()) {
      return c.account !== void 0 && m.Any.encode(c.account, E.uint32(10).fork()).ldelim(), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = d();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.account = m.Any.decode(k, k.uint32());
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        account: (0, b.isSet)(c.account) ? m.Any.fromJSON(c.account) : void 0
      };
    },
    toJSON(c) {
      const E = {};
      return c.account !== void 0 && (E.account = c.account ? m.Any.toJSON(c.account) : void 0), E;
    },
    fromPartial(c) {
      const E = d();
      return E.account = c.account !== void 0 && c.account !== null ? m.Any.fromPartial(c.account) : void 0, E;
    }
  };
  function p() {
    return {};
  }
  e.Bech32PrefixRequest = {
    encode(c, E = R.Writer.create()) {
      return E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = p();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {};
    },
    toJSON(c) {
      return {};
    },
    fromPartial(c) {
      return p();
    }
  };
  function h() {
    return {
      bech32Prefix: ""
    };
  }
  e.Bech32PrefixResponse = {
    encode(c, E = R.Writer.create()) {
      return c.bech32Prefix !== "" && E.uint32(10).string(c.bech32Prefix), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = h();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.bech32Prefix = k.string();
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        bech32Prefix: (0, b.isSet)(c.bech32Prefix) ? String(c.bech32Prefix) : ""
      };
    },
    toJSON(c) {
      const E = {};
      return c.bech32Prefix !== void 0 && (E.bech32Prefix = c.bech32Prefix), E;
    },
    fromPartial(c) {
      const E = h();
      return E.bech32Prefix = c.bech32Prefix ?? "", E;
    }
  };
  function x() {
    return {
      addressBytes: new Uint8Array()
    };
  }
  e.AddressBytesToStringRequest = {
    encode(c, E = R.Writer.create()) {
      return c.addressBytes.length !== 0 && E.uint32(10).bytes(c.addressBytes), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = x();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.addressBytes = k.bytes();
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        addressBytes: (0, b.isSet)(c.addressBytes) ? (0, b.bytesFromBase64)(c.addressBytes) : new Uint8Array()
      };
    },
    toJSON(c) {
      const E = {};
      return c.addressBytes !== void 0 && (E.addressBytes = (0, b.base64FromBytes)(c.addressBytes !== void 0 ? c.addressBytes : new Uint8Array())), E;
    },
    fromPartial(c) {
      const E = x();
      return E.addressBytes = c.addressBytes ?? new Uint8Array(), E;
    }
  };
  function _() {
    return {
      addressString: ""
    };
  }
  e.AddressBytesToStringResponse = {
    encode(c, E = R.Writer.create()) {
      return c.addressString !== "" && E.uint32(10).string(c.addressString), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = _();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.addressString = k.string();
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        addressString: (0, b.isSet)(c.addressString) ? String(c.addressString) : ""
      };
    },
    toJSON(c) {
      const E = {};
      return c.addressString !== void 0 && (E.addressString = c.addressString), E;
    },
    fromPartial(c) {
      const E = _();
      return E.addressString = c.addressString ?? "", E;
    }
  };
  function I() {
    return {
      addressString: ""
    };
  }
  e.AddressStringToBytesRequest = {
    encode(c, E = R.Writer.create()) {
      return c.addressString !== "" && E.uint32(10).string(c.addressString), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = I();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.addressString = k.string();
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        addressString: (0, b.isSet)(c.addressString) ? String(c.addressString) : ""
      };
    },
    toJSON(c) {
      const E = {};
      return c.addressString !== void 0 && (E.addressString = c.addressString), E;
    },
    fromPartial(c) {
      const E = I();
      return E.addressString = c.addressString ?? "", E;
    }
  };
  function W() {
    return {
      addressBytes: new Uint8Array()
    };
  }
  e.AddressStringToBytesResponse = {
    encode(c, E = R.Writer.create()) {
      return c.addressBytes.length !== 0 && E.uint32(10).bytes(c.addressBytes), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = W();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.addressBytes = k.bytes();
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        addressBytes: (0, b.isSet)(c.addressBytes) ? (0, b.bytesFromBase64)(c.addressBytes) : new Uint8Array()
      };
    },
    toJSON(c) {
      const E = {};
      return c.addressBytes !== void 0 && (E.addressBytes = (0, b.base64FromBytes)(c.addressBytes !== void 0 ? c.addressBytes : new Uint8Array())), E;
    },
    fromPartial(c) {
      const E = W();
      return E.addressBytes = c.addressBytes ?? new Uint8Array(), E;
    }
  };
  function n() {
    return {
      id: b.Long.ZERO,
      accountId: b.Long.UZERO
    };
  }
  e.QueryAccountAddressByIDRequest = {
    encode(c, E = R.Writer.create()) {
      return c.id.isZero() || E.uint32(8).int64(c.id), c.accountId.isZero() || E.uint32(16).uint64(c.accountId), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = n();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.id = k.int64();
            break;
          case 2:
            L.accountId = k.uint64();
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        id: (0, b.isSet)(c.id) ? b.Long.fromValue(c.id) : b.Long.ZERO,
        accountId: (0, b.isSet)(c.accountId) ? b.Long.fromValue(c.accountId) : b.Long.UZERO
      };
    },
    toJSON(c) {
      const E = {};
      return c.id !== void 0 && (E.id = (c.id || b.Long.ZERO).toString()), c.accountId !== void 0 && (E.accountId = (c.accountId || b.Long.UZERO).toString()), E;
    },
    fromPartial(c) {
      const E = n();
      return E.id = c.id !== void 0 && c.id !== null ? b.Long.fromValue(c.id) : b.Long.ZERO, E.accountId = c.accountId !== void 0 && c.accountId !== null ? b.Long.fromValue(c.accountId) : b.Long.UZERO, E;
    }
  };
  function y() {
    return {
      accountAddress: ""
    };
  }
  e.QueryAccountAddressByIDResponse = {
    encode(c, E = R.Writer.create()) {
      return c.accountAddress !== "" && E.uint32(10).string(c.accountAddress), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = y();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.accountAddress = k.string();
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        accountAddress: (0, b.isSet)(c.accountAddress) ? String(c.accountAddress) : ""
      };
    },
    toJSON(c) {
      const E = {};
      return c.accountAddress !== void 0 && (E.accountAddress = c.accountAddress), E;
    },
    fromPartial(c) {
      const E = y();
      return E.accountAddress = c.accountAddress ?? "", E;
    }
  };
  function w() {
    return {
      address: ""
    };
  }
  e.QueryAccountInfoRequest = {
    encode(c, E = R.Writer.create()) {
      return c.address !== "" && E.uint32(10).string(c.address), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = w();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.address = k.string();
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        address: (0, b.isSet)(c.address) ? String(c.address) : ""
      };
    },
    toJSON(c) {
      const E = {};
      return c.address !== void 0 && (E.address = c.address), E;
    },
    fromPartial(c) {
      const E = w();
      return E.address = c.address ?? "", E;
    }
  };
  function M() {
    return {
      info: void 0
    };
  }
  e.QueryAccountInfoResponse = {
    encode(c, E = R.Writer.create()) {
      return c.info !== void 0 && f.BaseAccount.encode(c.info, E.uint32(10).fork()).ldelim(), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = M();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.info = f.BaseAccount.decode(k, k.uint32());
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        info: (0, b.isSet)(c.info) ? f.BaseAccount.fromJSON(c.info) : void 0
      };
    },
    toJSON(c) {
      const E = {};
      return c.info !== void 0 && (E.info = c.info ? f.BaseAccount.toJSON(c.info) : void 0), E;
    },
    fromPartial(c) {
      const E = M();
      return E.info = c.info !== void 0 && c.info !== null ? f.BaseAccount.fromPartial(c.info) : void 0, E;
    }
  };
  class s {
    constructor(E) {
      this.rpc = E, this.Accounts = this.Accounts.bind(this), this.Account = this.Account.bind(this), this.AccountAddressByID = this.AccountAddressByID.bind(this), this.Params = this.Params.bind(this), this.ModuleAccounts = this.ModuleAccounts.bind(this), this.ModuleAccountByName = this.ModuleAccountByName.bind(this), this.Bech32Prefix = this.Bech32Prefix.bind(this), this.AddressBytesToString = this.AddressBytesToString.bind(this), this.AddressStringToBytes = this.AddressStringToBytes.bind(this), this.AccountInfo = this.AccountInfo.bind(this);
    }
    Accounts(E = {
      pagination: void 0
    }) {
      const k = e.QueryAccountsRequest.encode(E).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "Accounts", k).then((O) => e.QueryAccountsResponse.decode(new R.Reader(O)));
    }
    Account(E) {
      const k = e.QueryAccountRequest.encode(E).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "Account", k).then((O) => e.QueryAccountResponse.decode(new R.Reader(O)));
    }
    AccountAddressByID(E) {
      const k = e.QueryAccountAddressByIDRequest.encode(E).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "AccountAddressByID", k).then((O) => e.QueryAccountAddressByIDResponse.decode(new R.Reader(O)));
    }
    Params(E = {}) {
      const k = e.QueryParamsRequest.encode(E).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "Params", k).then((O) => e.QueryParamsResponse.decode(new R.Reader(O)));
    }
    ModuleAccounts(E = {}) {
      const k = e.QueryModuleAccountsRequest.encode(E).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "ModuleAccounts", k).then((O) => e.QueryModuleAccountsResponse.decode(new R.Reader(O)));
    }
    ModuleAccountByName(E) {
      const k = e.QueryModuleAccountByNameRequest.encode(E).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "ModuleAccountByName", k).then((O) => e.QueryModuleAccountByNameResponse.decode(new R.Reader(O)));
    }
    Bech32Prefix(E = {}) {
      const k = e.Bech32PrefixRequest.encode(E).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "Bech32Prefix", k).then((O) => e.Bech32PrefixResponse.decode(new R.Reader(O)));
    }
    AddressBytesToString(E) {
      const k = e.AddressBytesToStringRequest.encode(E).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "AddressBytesToString", k).then((O) => e.AddressBytesToStringResponse.decode(new R.Reader(O)));
    }
    AddressStringToBytes(E) {
      const k = e.AddressStringToBytesRequest.encode(E).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "AddressStringToBytes", k).then((O) => e.AddressStringToBytesResponse.decode(new R.Reader(O)));
    }
    AccountInfo(E) {
      const k = e.QueryAccountInfoRequest.encode(E).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "AccountInfo", k).then((O) => e.QueryAccountInfoResponse.decode(new R.Reader(O)));
    }
  }
  e.QueryClientImpl = s;
})(Bd);
var Ve = {}, Wo = {}, Vd = {}, Pe = re, se = Pe.Reader, ze = Pe.Writer, ne = Pe.util, Y = Pe.roots.default || (Pe.roots.default = {});
Y.ics23 = function() {
  var e = {};
  return e.HashOp = function() {
    var o = {}, t = Object.create(o);
    return t[o[0] = "NO_HASH"] = 0, t[o[1] = "SHA256"] = 1, t[o[2] = "SHA512"] = 2, t[o[3] = "KECCAK"] = 3, t[o[4] = "RIPEMD160"] = 4, t[o[5] = "BITCOIN"] = 5, t[o[6] = "SHA512_256"] = 6, t;
  }(), e.LengthOp = function() {
    var o = {}, t = Object.create(o);
    return t[o[0] = "NO_PREFIX"] = 0, t[o[1] = "VAR_PROTO"] = 1, t[o[2] = "VAR_RLP"] = 2, t[o[3] = "FIXED32_BIG"] = 3, t[o[4] = "FIXED32_LITTLE"] = 4, t[o[5] = "FIXED64_BIG"] = 5, t[o[6] = "FIXED64_LITTLE"] = 6, t[o[7] = "REQUIRE_32_BYTES"] = 7, t[o[8] = "REQUIRE_64_BYTES"] = 8, t;
  }(), e.ExistenceProof = function() {
    function o(t) {
      if (this.path = [], t)
        for (var u = Object.keys(t), r = 0; r < u.length; ++r)
          t[u[r]] != null && (this[u[r]] = t[u[r]]);
    }
    return o.prototype.key = ne.newBuffer([]), o.prototype.value = ne.newBuffer([]), o.prototype.leaf = null, o.prototype.path = ne.emptyArray, o.create = function(t) {
      return new o(t);
    }, o.encode = function(t, u) {
      if (u || (u = ze.create()), t.key != null && t.hasOwnProperty("key") && u.uint32(
        /* id 1, wireType 2 =*/
        10
      ).bytes(t.key), t.value != null && t.hasOwnProperty("value") && u.uint32(
        /* id 2, wireType 2 =*/
        18
      ).bytes(t.value), t.leaf != null && t.hasOwnProperty("leaf") && Y.ics23.LeafOp.encode(t.leaf, u.uint32(
        /* id 3, wireType 2 =*/
        26
      ).fork()).ldelim(), t.path != null && t.path.length)
        for (var r = 0; r < t.path.length; ++r)
          Y.ics23.InnerOp.encode(t.path[r], u.uint32(
            /* id 4, wireType 2 =*/
            34
          ).fork()).ldelim();
      return u;
    }, o.encodeDelimited = function(t, u) {
      return this.encode(t, u).ldelim();
    }, o.decode = function(t, u) {
      t instanceof se || (t = se.create(t));
      for (var r = u === void 0 ? t.len : t.pos + u, m = new Y.ics23.ExistenceProof(); t.pos < r; ) {
        var f = t.uint32();
        switch (f >>> 3) {
          case 1:
            m.key = t.bytes();
            break;
          case 2:
            m.value = t.bytes();
            break;
          case 3:
            m.leaf = Y.ics23.LeafOp.decode(t, t.uint32());
            break;
          case 4:
            m.path && m.path.length || (m.path = []), m.path.push(Y.ics23.InnerOp.decode(t, t.uint32()));
            break;
          default:
            t.skipType(f & 7);
            break;
        }
      }
      return m;
    }, o.decodeDelimited = function(t) {
      return t instanceof se || (t = new se(t)), this.decode(t, t.uint32());
    }, o.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.key != null && t.hasOwnProperty("key") && !(t.key && typeof t.key.length == "number" || ne.isString(t.key)))
        return "key: buffer expected";
      if (t.value != null && t.hasOwnProperty("value") && !(t.value && typeof t.value.length == "number" || ne.isString(t.value)))
        return "value: buffer expected";
      if (t.leaf != null && t.hasOwnProperty("leaf")) {
        var u = Y.ics23.LeafOp.verify(t.leaf);
        if (u)
          return "leaf." + u;
      }
      if (t.path != null && t.hasOwnProperty("path")) {
        if (!Array.isArray(t.path))
          return "path: array expected";
        for (var r = 0; r < t.path.length; ++r) {
          var u = Y.ics23.InnerOp.verify(t.path[r]);
          if (u)
            return "path." + u;
        }
      }
      return null;
    }, o.fromObject = function(t) {
      if (t instanceof Y.ics23.ExistenceProof)
        return t;
      var u = new Y.ics23.ExistenceProof();
      if (t.key != null && (typeof t.key == "string" ? ne.base64.decode(t.key, u.key = ne.newBuffer(ne.base64.length(t.key)), 0) : t.key.length && (u.key = t.key)), t.value != null && (typeof t.value == "string" ? ne.base64.decode(t.value, u.value = ne.newBuffer(ne.base64.length(t.value)), 0) : t.value.length && (u.value = t.value)), t.leaf != null) {
        if (typeof t.leaf != "object")
          throw TypeError(".ics23.ExistenceProof.leaf: object expected");
        u.leaf = Y.ics23.LeafOp.fromObject(t.leaf);
      }
      if (t.path) {
        if (!Array.isArray(t.path))
          throw TypeError(".ics23.ExistenceProof.path: array expected");
        u.path = [];
        for (var r = 0; r < t.path.length; ++r) {
          if (typeof t.path[r] != "object")
            throw TypeError(".ics23.ExistenceProof.path: object expected");
          u.path[r] = Y.ics23.InnerOp.fromObject(t.path[r]);
        }
      }
      return u;
    }, o.toObject = function(t, u) {
      u || (u = {});
      var r = {};
      if ((u.arrays || u.defaults) && (r.path = []), u.defaults && (u.bytes === String ? r.key = "" : (r.key = [], u.bytes !== Array && (r.key = ne.newBuffer(r.key))), u.bytes === String ? r.value = "" : (r.value = [], u.bytes !== Array && (r.value = ne.newBuffer(r.value))), r.leaf = null), t.key != null && t.hasOwnProperty("key") && (r.key = u.bytes === String ? ne.base64.encode(t.key, 0, t.key.length) : u.bytes === Array ? Array.prototype.slice.call(t.key) : t.key), t.value != null && t.hasOwnProperty("value") && (r.value = u.bytes === String ? ne.base64.encode(t.value, 0, t.value.length) : u.bytes === Array ? Array.prototype.slice.call(t.value) : t.value), t.leaf != null && t.hasOwnProperty("leaf") && (r.leaf = Y.ics23.LeafOp.toObject(t.leaf, u)), t.path && t.path.length) {
        r.path = [];
        for (var m = 0; m < t.path.length; ++m)
          r.path[m] = Y.ics23.InnerOp.toObject(t.path[m], u);
      }
      return r;
    }, o.prototype.toJSON = function() {
      return this.constructor.toObject(this, Pe.util.toJSONOptions);
    }, o;
  }(), e.NonExistenceProof = function() {
    function o(t) {
      if (t)
        for (var u = Object.keys(t), r = 0; r < u.length; ++r)
          t[u[r]] != null && (this[u[r]] = t[u[r]]);
    }
    return o.prototype.key = ne.newBuffer([]), o.prototype.left = null, o.prototype.right = null, o.create = function(t) {
      return new o(t);
    }, o.encode = function(t, u) {
      return u || (u = ze.create()), t.key != null && t.hasOwnProperty("key") && u.uint32(
        /* id 1, wireType 2 =*/
        10
      ).bytes(t.key), t.left != null && t.hasOwnProperty("left") && Y.ics23.ExistenceProof.encode(t.left, u.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), t.right != null && t.hasOwnProperty("right") && Y.ics23.ExistenceProof.encode(t.right, u.uint32(
        /* id 3, wireType 2 =*/
        26
      ).fork()).ldelim(), u;
    }, o.encodeDelimited = function(t, u) {
      return this.encode(t, u).ldelim();
    }, o.decode = function(t, u) {
      t instanceof se || (t = se.create(t));
      for (var r = u === void 0 ? t.len : t.pos + u, m = new Y.ics23.NonExistenceProof(); t.pos < r; ) {
        var f = t.uint32();
        switch (f >>> 3) {
          case 1:
            m.key = t.bytes();
            break;
          case 2:
            m.left = Y.ics23.ExistenceProof.decode(t, t.uint32());
            break;
          case 3:
            m.right = Y.ics23.ExistenceProof.decode(t, t.uint32());
            break;
          default:
            t.skipType(f & 7);
            break;
        }
      }
      return m;
    }, o.decodeDelimited = function(t) {
      return t instanceof se || (t = new se(t)), this.decode(t, t.uint32());
    }, o.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.key != null && t.hasOwnProperty("key") && !(t.key && typeof t.key.length == "number" || ne.isString(t.key)))
        return "key: buffer expected";
      if (t.left != null && t.hasOwnProperty("left")) {
        var u = Y.ics23.ExistenceProof.verify(t.left);
        if (u)
          return "left." + u;
      }
      if (t.right != null && t.hasOwnProperty("right")) {
        var u = Y.ics23.ExistenceProof.verify(t.right);
        if (u)
          return "right." + u;
      }
      return null;
    }, o.fromObject = function(t) {
      if (t instanceof Y.ics23.NonExistenceProof)
        return t;
      var u = new Y.ics23.NonExistenceProof();
      if (t.key != null && (typeof t.key == "string" ? ne.base64.decode(t.key, u.key = ne.newBuffer(ne.base64.length(t.key)), 0) : t.key.length && (u.key = t.key)), t.left != null) {
        if (typeof t.left != "object")
          throw TypeError(".ics23.NonExistenceProof.left: object expected");
        u.left = Y.ics23.ExistenceProof.fromObject(t.left);
      }
      if (t.right != null) {
        if (typeof t.right != "object")
          throw TypeError(".ics23.NonExistenceProof.right: object expected");
        u.right = Y.ics23.ExistenceProof.fromObject(t.right);
      }
      return u;
    }, o.toObject = function(t, u) {
      u || (u = {});
      var r = {};
      return u.defaults && (u.bytes === String ? r.key = "" : (r.key = [], u.bytes !== Array && (r.key = ne.newBuffer(r.key))), r.left = null, r.right = null), t.key != null && t.hasOwnProperty("key") && (r.key = u.bytes === String ? ne.base64.encode(t.key, 0, t.key.length) : u.bytes === Array ? Array.prototype.slice.call(t.key) : t.key), t.left != null && t.hasOwnProperty("left") && (r.left = Y.ics23.ExistenceProof.toObject(t.left, u)), t.right != null && t.hasOwnProperty("right") && (r.right = Y.ics23.ExistenceProof.toObject(t.right, u)), r;
    }, o.prototype.toJSON = function() {
      return this.constructor.toObject(this, Pe.util.toJSONOptions);
    }, o;
  }(), e.CommitmentProof = function() {
    function o(u) {
      if (u)
        for (var r = Object.keys(u), m = 0; m < r.length; ++m)
          u[r[m]] != null && (this[r[m]] = u[r[m]]);
    }
    o.prototype.exist = null, o.prototype.nonexist = null, o.prototype.batch = null, o.prototype.compressed = null;
    var t;
    return Object.defineProperty(o.prototype, "proof", {
      get: ne.oneOfGetter(t = ["exist", "nonexist", "batch", "compressed"]),
      set: ne.oneOfSetter(t)
    }), o.create = function(u) {
      return new o(u);
    }, o.encode = function(u, r) {
      return r || (r = ze.create()), u.exist != null && u.hasOwnProperty("exist") && Y.ics23.ExistenceProof.encode(u.exist, r.uint32(
        /* id 1, wireType 2 =*/
        10
      ).fork()).ldelim(), u.nonexist != null && u.hasOwnProperty("nonexist") && Y.ics23.NonExistenceProof.encode(u.nonexist, r.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), u.batch != null && u.hasOwnProperty("batch") && Y.ics23.BatchProof.encode(u.batch, r.uint32(
        /* id 3, wireType 2 =*/
        26
      ).fork()).ldelim(), u.compressed != null && u.hasOwnProperty("compressed") && Y.ics23.CompressedBatchProof.encode(u.compressed, r.uint32(
        /* id 4, wireType 2 =*/
        34
      ).fork()).ldelim(), r;
    }, o.encodeDelimited = function(u, r) {
      return this.encode(u, r).ldelim();
    }, o.decode = function(u, r) {
      u instanceof se || (u = se.create(u));
      for (var m = r === void 0 ? u.len : u.pos + r, f = new Y.ics23.CommitmentProof(); u.pos < m; ) {
        var b = u.uint32();
        switch (b >>> 3) {
          case 1:
            f.exist = Y.ics23.ExistenceProof.decode(u, u.uint32());
            break;
          case 2:
            f.nonexist = Y.ics23.NonExistenceProof.decode(u, u.uint32());
            break;
          case 3:
            f.batch = Y.ics23.BatchProof.decode(u, u.uint32());
            break;
          case 4:
            f.compressed = Y.ics23.CompressedBatchProof.decode(u, u.uint32());
            break;
          default:
            u.skipType(b & 7);
            break;
        }
      }
      return f;
    }, o.decodeDelimited = function(u) {
      return u instanceof se || (u = new se(u)), this.decode(u, u.uint32());
    }, o.verify = function(u) {
      if (typeof u != "object" || u === null)
        return "object expected";
      var r = {};
      if (u.exist != null && u.hasOwnProperty("exist")) {
        r.proof = 1;
        {
          var m = Y.ics23.ExistenceProof.verify(u.exist);
          if (m)
            return "exist." + m;
        }
      }
      if (u.nonexist != null && u.hasOwnProperty("nonexist")) {
        if (r.proof === 1)
          return "proof: multiple values";
        r.proof = 1;
        {
          var m = Y.ics23.NonExistenceProof.verify(u.nonexist);
          if (m)
            return "nonexist." + m;
        }
      }
      if (u.batch != null && u.hasOwnProperty("batch")) {
        if (r.proof === 1)
          return "proof: multiple values";
        r.proof = 1;
        {
          var m = Y.ics23.BatchProof.verify(u.batch);
          if (m)
            return "batch." + m;
        }
      }
      if (u.compressed != null && u.hasOwnProperty("compressed")) {
        if (r.proof === 1)
          return "proof: multiple values";
        r.proof = 1;
        {
          var m = Y.ics23.CompressedBatchProof.verify(u.compressed);
          if (m)
            return "compressed." + m;
        }
      }
      return null;
    }, o.fromObject = function(u) {
      if (u instanceof Y.ics23.CommitmentProof)
        return u;
      var r = new Y.ics23.CommitmentProof();
      if (u.exist != null) {
        if (typeof u.exist != "object")
          throw TypeError(".ics23.CommitmentProof.exist: object expected");
        r.exist = Y.ics23.ExistenceProof.fromObject(u.exist);
      }
      if (u.nonexist != null) {
        if (typeof u.nonexist != "object")
          throw TypeError(".ics23.CommitmentProof.nonexist: object expected");
        r.nonexist = Y.ics23.NonExistenceProof.fromObject(u.nonexist);
      }
      if (u.batch != null) {
        if (typeof u.batch != "object")
          throw TypeError(".ics23.CommitmentProof.batch: object expected");
        r.batch = Y.ics23.BatchProof.fromObject(u.batch);
      }
      if (u.compressed != null) {
        if (typeof u.compressed != "object")
          throw TypeError(".ics23.CommitmentProof.compressed: object expected");
        r.compressed = Y.ics23.CompressedBatchProof.fromObject(u.compressed);
      }
      return r;
    }, o.toObject = function(u, r) {
      r || (r = {});
      var m = {};
      return u.exist != null && u.hasOwnProperty("exist") && (m.exist = Y.ics23.ExistenceProof.toObject(u.exist, r), r.oneofs && (m.proof = "exist")), u.nonexist != null && u.hasOwnProperty("nonexist") && (m.nonexist = Y.ics23.NonExistenceProof.toObject(u.nonexist, r), r.oneofs && (m.proof = "nonexist")), u.batch != null && u.hasOwnProperty("batch") && (m.batch = Y.ics23.BatchProof.toObject(u.batch, r), r.oneofs && (m.proof = "batch")), u.compressed != null && u.hasOwnProperty("compressed") && (m.compressed = Y.ics23.CompressedBatchProof.toObject(u.compressed, r), r.oneofs && (m.proof = "compressed")), m;
    }, o.prototype.toJSON = function() {
      return this.constructor.toObject(this, Pe.util.toJSONOptions);
    }, o;
  }(), e.LeafOp = function() {
    function o(t) {
      if (t)
        for (var u = Object.keys(t), r = 0; r < u.length; ++r)
          t[u[r]] != null && (this[u[r]] = t[u[r]]);
    }
    return o.prototype.hash = 0, o.prototype.prehashKey = 0, o.prototype.prehashValue = 0, o.prototype.length = 0, o.prototype.prefix = ne.newBuffer([]), o.create = function(t) {
      return new o(t);
    }, o.encode = function(t, u) {
      return u || (u = ze.create()), t.hash != null && t.hasOwnProperty("hash") && u.uint32(
        /* id 1, wireType 0 =*/
        8
      ).int32(t.hash), t.prehashKey != null && t.hasOwnProperty("prehashKey") && u.uint32(
        /* id 2, wireType 0 =*/
        16
      ).int32(t.prehashKey), t.prehashValue != null && t.hasOwnProperty("prehashValue") && u.uint32(
        /* id 3, wireType 0 =*/
        24
      ).int32(t.prehashValue), t.length != null && t.hasOwnProperty("length") && u.uint32(
        /* id 4, wireType 0 =*/
        32
      ).int32(t.length), t.prefix != null && t.hasOwnProperty("prefix") && u.uint32(
        /* id 5, wireType 2 =*/
        42
      ).bytes(t.prefix), u;
    }, o.encodeDelimited = function(t, u) {
      return this.encode(t, u).ldelim();
    }, o.decode = function(t, u) {
      t instanceof se || (t = se.create(t));
      for (var r = u === void 0 ? t.len : t.pos + u, m = new Y.ics23.LeafOp(); t.pos < r; ) {
        var f = t.uint32();
        switch (f >>> 3) {
          case 1:
            m.hash = t.int32();
            break;
          case 2:
            m.prehashKey = t.int32();
            break;
          case 3:
            m.prehashValue = t.int32();
            break;
          case 4:
            m.length = t.int32();
            break;
          case 5:
            m.prefix = t.bytes();
            break;
          default:
            t.skipType(f & 7);
            break;
        }
      }
      return m;
    }, o.decodeDelimited = function(t) {
      return t instanceof se || (t = new se(t)), this.decode(t, t.uint32());
    }, o.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.hash != null && t.hasOwnProperty("hash"))
        switch (t.hash) {
          default:
            return "hash: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      if (t.prehashKey != null && t.hasOwnProperty("prehashKey"))
        switch (t.prehashKey) {
          default:
            return "prehashKey: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      if (t.prehashValue != null && t.hasOwnProperty("prehashValue"))
        switch (t.prehashValue) {
          default:
            return "prehashValue: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      if (t.length != null && t.hasOwnProperty("length"))
        switch (t.length) {
          default:
            return "length: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
            break;
        }
      return t.prefix != null && t.hasOwnProperty("prefix") && !(t.prefix && typeof t.prefix.length == "number" || ne.isString(t.prefix)) ? "prefix: buffer expected" : null;
    }, o.fromObject = function(t) {
      if (t instanceof Y.ics23.LeafOp)
        return t;
      var u = new Y.ics23.LeafOp();
      switch (t.hash) {
        case "NO_HASH":
        case 0:
          u.hash = 0;
          break;
        case "SHA256":
        case 1:
          u.hash = 1;
          break;
        case "SHA512":
        case 2:
          u.hash = 2;
          break;
        case "KECCAK":
        case 3:
          u.hash = 3;
          break;
        case "RIPEMD160":
        case 4:
          u.hash = 4;
          break;
        case "BITCOIN":
        case 5:
          u.hash = 5;
          break;
        case "SHA512_256":
        case 6:
          u.hash = 6;
          break;
      }
      switch (t.prehashKey) {
        case "NO_HASH":
        case 0:
          u.prehashKey = 0;
          break;
        case "SHA256":
        case 1:
          u.prehashKey = 1;
          break;
        case "SHA512":
        case 2:
          u.prehashKey = 2;
          break;
        case "KECCAK":
        case 3:
          u.prehashKey = 3;
          break;
        case "RIPEMD160":
        case 4:
          u.prehashKey = 4;
          break;
        case "BITCOIN":
        case 5:
          u.prehashKey = 5;
          break;
        case "SHA512_256":
        case 6:
          u.prehashKey = 6;
          break;
      }
      switch (t.prehashValue) {
        case "NO_HASH":
        case 0:
          u.prehashValue = 0;
          break;
        case "SHA256":
        case 1:
          u.prehashValue = 1;
          break;
        case "SHA512":
        case 2:
          u.prehashValue = 2;
          break;
        case "KECCAK":
        case 3:
          u.prehashValue = 3;
          break;
        case "RIPEMD160":
        case 4:
          u.prehashValue = 4;
          break;
        case "BITCOIN":
        case 5:
          u.prehashValue = 5;
          break;
        case "SHA512_256":
        case 6:
          u.prehashValue = 6;
          break;
      }
      switch (t.length) {
        case "NO_PREFIX":
        case 0:
          u.length = 0;
          break;
        case "VAR_PROTO":
        case 1:
          u.length = 1;
          break;
        case "VAR_RLP":
        case 2:
          u.length = 2;
          break;
        case "FIXED32_BIG":
        case 3:
          u.length = 3;
          break;
        case "FIXED32_LITTLE":
        case 4:
          u.length = 4;
          break;
        case "FIXED64_BIG":
        case 5:
          u.length = 5;
          break;
        case "FIXED64_LITTLE":
        case 6:
          u.length = 6;
          break;
        case "REQUIRE_32_BYTES":
        case 7:
          u.length = 7;
          break;
        case "REQUIRE_64_BYTES":
        case 8:
          u.length = 8;
          break;
      }
      return t.prefix != null && (typeof t.prefix == "string" ? ne.base64.decode(t.prefix, u.prefix = ne.newBuffer(ne.base64.length(t.prefix)), 0) : t.prefix.length && (u.prefix = t.prefix)), u;
    }, o.toObject = function(t, u) {
      u || (u = {});
      var r = {};
      return u.defaults && (r.hash = u.enums === String ? "NO_HASH" : 0, r.prehashKey = u.enums === String ? "NO_HASH" : 0, r.prehashValue = u.enums === String ? "NO_HASH" : 0, r.length = u.enums === String ? "NO_PREFIX" : 0, u.bytes === String ? r.prefix = "" : (r.prefix = [], u.bytes !== Array && (r.prefix = ne.newBuffer(r.prefix)))), t.hash != null && t.hasOwnProperty("hash") && (r.hash = u.enums === String ? Y.ics23.HashOp[t.hash] : t.hash), t.prehashKey != null && t.hasOwnProperty("prehashKey") && (r.prehashKey = u.enums === String ? Y.ics23.HashOp[t.prehashKey] : t.prehashKey), t.prehashValue != null && t.hasOwnProperty("prehashValue") && (r.prehashValue = u.enums === String ? Y.ics23.HashOp[t.prehashValue] : t.prehashValue), t.length != null && t.hasOwnProperty("length") && (r.length = u.enums === String ? Y.ics23.LengthOp[t.length] : t.length), t.prefix != null && t.hasOwnProperty("prefix") && (r.prefix = u.bytes === String ? ne.base64.encode(t.prefix, 0, t.prefix.length) : u.bytes === Array ? Array.prototype.slice.call(t.prefix) : t.prefix), r;
    }, o.prototype.toJSON = function() {
      return this.constructor.toObject(this, Pe.util.toJSONOptions);
    }, o;
  }(), e.InnerOp = function() {
    function o(t) {
      if (t)
        for (var u = Object.keys(t), r = 0; r < u.length; ++r)
          t[u[r]] != null && (this[u[r]] = t[u[r]]);
    }
    return o.prototype.hash = 0, o.prototype.prefix = ne.newBuffer([]), o.prototype.suffix = ne.newBuffer([]), o.create = function(t) {
      return new o(t);
    }, o.encode = function(t, u) {
      return u || (u = ze.create()), t.hash != null && t.hasOwnProperty("hash") && u.uint32(
        /* id 1, wireType 0 =*/
        8
      ).int32(t.hash), t.prefix != null && t.hasOwnProperty("prefix") && u.uint32(
        /* id 2, wireType 2 =*/
        18
      ).bytes(t.prefix), t.suffix != null && t.hasOwnProperty("suffix") && u.uint32(
        /* id 3, wireType 2 =*/
        26
      ).bytes(t.suffix), u;
    }, o.encodeDelimited = function(t, u) {
      return this.encode(t, u).ldelim();
    }, o.decode = function(t, u) {
      t instanceof se || (t = se.create(t));
      for (var r = u === void 0 ? t.len : t.pos + u, m = new Y.ics23.InnerOp(); t.pos < r; ) {
        var f = t.uint32();
        switch (f >>> 3) {
          case 1:
            m.hash = t.int32();
            break;
          case 2:
            m.prefix = t.bytes();
            break;
          case 3:
            m.suffix = t.bytes();
            break;
          default:
            t.skipType(f & 7);
            break;
        }
      }
      return m;
    }, o.decodeDelimited = function(t) {
      return t instanceof se || (t = new se(t)), this.decode(t, t.uint32());
    }, o.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.hash != null && t.hasOwnProperty("hash"))
        switch (t.hash) {
          default:
            return "hash: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      return t.prefix != null && t.hasOwnProperty("prefix") && !(t.prefix && typeof t.prefix.length == "number" || ne.isString(t.prefix)) ? "prefix: buffer expected" : t.suffix != null && t.hasOwnProperty("suffix") && !(t.suffix && typeof t.suffix.length == "number" || ne.isString(t.suffix)) ? "suffix: buffer expected" : null;
    }, o.fromObject = function(t) {
      if (t instanceof Y.ics23.InnerOp)
        return t;
      var u = new Y.ics23.InnerOp();
      switch (t.hash) {
        case "NO_HASH":
        case 0:
          u.hash = 0;
          break;
        case "SHA256":
        case 1:
          u.hash = 1;
          break;
        case "SHA512":
        case 2:
          u.hash = 2;
          break;
        case "KECCAK":
        case 3:
          u.hash = 3;
          break;
        case "RIPEMD160":
        case 4:
          u.hash = 4;
          break;
        case "BITCOIN":
        case 5:
          u.hash = 5;
          break;
        case "SHA512_256":
        case 6:
          u.hash = 6;
          break;
      }
      return t.prefix != null && (typeof t.prefix == "string" ? ne.base64.decode(t.prefix, u.prefix = ne.newBuffer(ne.base64.length(t.prefix)), 0) : t.prefix.length && (u.prefix = t.prefix)), t.suffix != null && (typeof t.suffix == "string" ? ne.base64.decode(t.suffix, u.suffix = ne.newBuffer(ne.base64.length(t.suffix)), 0) : t.suffix.length && (u.suffix = t.suffix)), u;
    }, o.toObject = function(t, u) {
      u || (u = {});
      var r = {};
      return u.defaults && (r.hash = u.enums === String ? "NO_HASH" : 0, u.bytes === String ? r.prefix = "" : (r.prefix = [], u.bytes !== Array && (r.prefix = ne.newBuffer(r.prefix))), u.bytes === String ? r.suffix = "" : (r.suffix = [], u.bytes !== Array && (r.suffix = ne.newBuffer(r.suffix)))), t.hash != null && t.hasOwnProperty("hash") && (r.hash = u.enums === String ? Y.ics23.HashOp[t.hash] : t.hash), t.prefix != null && t.hasOwnProperty("prefix") && (r.prefix = u.bytes === String ? ne.base64.encode(t.prefix, 0, t.prefix.length) : u.bytes === Array ? Array.prototype.slice.call(t.prefix) : t.prefix), t.suffix != null && t.hasOwnProperty("suffix") && (r.suffix = u.bytes === String ? ne.base64.encode(t.suffix, 0, t.suffix.length) : u.bytes === Array ? Array.prototype.slice.call(t.suffix) : t.suffix), r;
    }, o.prototype.toJSON = function() {
      return this.constructor.toObject(this, Pe.util.toJSONOptions);
    }, o;
  }(), e.ProofSpec = function() {
    function o(t) {
      if (t)
        for (var u = Object.keys(t), r = 0; r < u.length; ++r)
          t[u[r]] != null && (this[u[r]] = t[u[r]]);
    }
    return o.prototype.leafSpec = null, o.prototype.innerSpec = null, o.prototype.maxDepth = 0, o.prototype.minDepth = 0, o.create = function(t) {
      return new o(t);
    }, o.encode = function(t, u) {
      return u || (u = ze.create()), t.leafSpec != null && t.hasOwnProperty("leafSpec") && Y.ics23.LeafOp.encode(t.leafSpec, u.uint32(
        /* id 1, wireType 2 =*/
        10
      ).fork()).ldelim(), t.innerSpec != null && t.hasOwnProperty("innerSpec") && Y.ics23.InnerSpec.encode(t.innerSpec, u.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), t.maxDepth != null && t.hasOwnProperty("maxDepth") && u.uint32(
        /* id 3, wireType 0 =*/
        24
      ).int32(t.maxDepth), t.minDepth != null && t.hasOwnProperty("minDepth") && u.uint32(
        /* id 4, wireType 0 =*/
        32
      ).int32(t.minDepth), u;
    }, o.encodeDelimited = function(t, u) {
      return this.encode(t, u).ldelim();
    }, o.decode = function(t, u) {
      t instanceof se || (t = se.create(t));
      for (var r = u === void 0 ? t.len : t.pos + u, m = new Y.ics23.ProofSpec(); t.pos < r; ) {
        var f = t.uint32();
        switch (f >>> 3) {
          case 1:
            m.leafSpec = Y.ics23.LeafOp.decode(t, t.uint32());
            break;
          case 2:
            m.innerSpec = Y.ics23.InnerSpec.decode(t, t.uint32());
            break;
          case 3:
            m.maxDepth = t.int32();
            break;
          case 4:
            m.minDepth = t.int32();
            break;
          default:
            t.skipType(f & 7);
            break;
        }
      }
      return m;
    }, o.decodeDelimited = function(t) {
      return t instanceof se || (t = new se(t)), this.decode(t, t.uint32());
    }, o.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.leafSpec != null && t.hasOwnProperty("leafSpec")) {
        var u = Y.ics23.LeafOp.verify(t.leafSpec);
        if (u)
          return "leafSpec." + u;
      }
      if (t.innerSpec != null && t.hasOwnProperty("innerSpec")) {
        var u = Y.ics23.InnerSpec.verify(t.innerSpec);
        if (u)
          return "innerSpec." + u;
      }
      return t.maxDepth != null && t.hasOwnProperty("maxDepth") && !ne.isInteger(t.maxDepth) ? "maxDepth: integer expected" : t.minDepth != null && t.hasOwnProperty("minDepth") && !ne.isInteger(t.minDepth) ? "minDepth: integer expected" : null;
    }, o.fromObject = function(t) {
      if (t instanceof Y.ics23.ProofSpec)
        return t;
      var u = new Y.ics23.ProofSpec();
      if (t.leafSpec != null) {
        if (typeof t.leafSpec != "object")
          throw TypeError(".ics23.ProofSpec.leafSpec: object expected");
        u.leafSpec = Y.ics23.LeafOp.fromObject(t.leafSpec);
      }
      if (t.innerSpec != null) {
        if (typeof t.innerSpec != "object")
          throw TypeError(".ics23.ProofSpec.innerSpec: object expected");
        u.innerSpec = Y.ics23.InnerSpec.fromObject(t.innerSpec);
      }
      return t.maxDepth != null && (u.maxDepth = t.maxDepth | 0), t.minDepth != null && (u.minDepth = t.minDepth | 0), u;
    }, o.toObject = function(t, u) {
      u || (u = {});
      var r = {};
      return u.defaults && (r.leafSpec = null, r.innerSpec = null, r.maxDepth = 0, r.minDepth = 0), t.leafSpec != null && t.hasOwnProperty("leafSpec") && (r.leafSpec = Y.ics23.LeafOp.toObject(t.leafSpec, u)), t.innerSpec != null && t.hasOwnProperty("innerSpec") && (r.innerSpec = Y.ics23.InnerSpec.toObject(t.innerSpec, u)), t.maxDepth != null && t.hasOwnProperty("maxDepth") && (r.maxDepth = t.maxDepth), t.minDepth != null && t.hasOwnProperty("minDepth") && (r.minDepth = t.minDepth), r;
    }, o.prototype.toJSON = function() {
      return this.constructor.toObject(this, Pe.util.toJSONOptions);
    }, o;
  }(), e.InnerSpec = function() {
    function o(t) {
      if (this.childOrder = [], t)
        for (var u = Object.keys(t), r = 0; r < u.length; ++r)
          t[u[r]] != null && (this[u[r]] = t[u[r]]);
    }
    return o.prototype.childOrder = ne.emptyArray, o.prototype.childSize = 0, o.prototype.minPrefixLength = 0, o.prototype.maxPrefixLength = 0, o.prototype.emptyChild = ne.newBuffer([]), o.prototype.hash = 0, o.create = function(t) {
      return new o(t);
    }, o.encode = function(t, u) {
      if (u || (u = ze.create()), t.childOrder != null && t.childOrder.length) {
        u.uint32(
          /* id 1, wireType 2 =*/
          10
        ).fork();
        for (var r = 0; r < t.childOrder.length; ++r)
          u.int32(t.childOrder[r]);
        u.ldelim();
      }
      return t.childSize != null && t.hasOwnProperty("childSize") && u.uint32(
        /* id 2, wireType 0 =*/
        16
      ).int32(t.childSize), t.minPrefixLength != null && t.hasOwnProperty("minPrefixLength") && u.uint32(
        /* id 3, wireType 0 =*/
        24
      ).int32(t.minPrefixLength), t.maxPrefixLength != null && t.hasOwnProperty("maxPrefixLength") && u.uint32(
        /* id 4, wireType 0 =*/
        32
      ).int32(t.maxPrefixLength), t.emptyChild != null && t.hasOwnProperty("emptyChild") && u.uint32(
        /* id 5, wireType 2 =*/
        42
      ).bytes(t.emptyChild), t.hash != null && t.hasOwnProperty("hash") && u.uint32(
        /* id 6, wireType 0 =*/
        48
      ).int32(t.hash), u;
    }, o.encodeDelimited = function(t, u) {
      return this.encode(t, u).ldelim();
    }, o.decode = function(t, u) {
      t instanceof se || (t = se.create(t));
      for (var r = u === void 0 ? t.len : t.pos + u, m = new Y.ics23.InnerSpec(); t.pos < r; ) {
        var f = t.uint32();
        switch (f >>> 3) {
          case 1:
            if (m.childOrder && m.childOrder.length || (m.childOrder = []), (f & 7) === 2)
              for (var b = t.uint32() + t.pos; t.pos < b; )
                m.childOrder.push(t.int32());
            else
              m.childOrder.push(t.int32());
            break;
          case 2:
            m.childSize = t.int32();
            break;
          case 3:
            m.minPrefixLength = t.int32();
            break;
          case 4:
            m.maxPrefixLength = t.int32();
            break;
          case 5:
            m.emptyChild = t.bytes();
            break;
          case 6:
            m.hash = t.int32();
            break;
          default:
            t.skipType(f & 7);
            break;
        }
      }
      return m;
    }, o.decodeDelimited = function(t) {
      return t instanceof se || (t = new se(t)), this.decode(t, t.uint32());
    }, o.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.childOrder != null && t.hasOwnProperty("childOrder")) {
        if (!Array.isArray(t.childOrder))
          return "childOrder: array expected";
        for (var u = 0; u < t.childOrder.length; ++u)
          if (!ne.isInteger(t.childOrder[u]))
            return "childOrder: integer[] expected";
      }
      if (t.childSize != null && t.hasOwnProperty("childSize") && !ne.isInteger(t.childSize))
        return "childSize: integer expected";
      if (t.minPrefixLength != null && t.hasOwnProperty("minPrefixLength") && !ne.isInteger(t.minPrefixLength))
        return "minPrefixLength: integer expected";
      if (t.maxPrefixLength != null && t.hasOwnProperty("maxPrefixLength") && !ne.isInteger(t.maxPrefixLength))
        return "maxPrefixLength: integer expected";
      if (t.emptyChild != null && t.hasOwnProperty("emptyChild") && !(t.emptyChild && typeof t.emptyChild.length == "number" || ne.isString(t.emptyChild)))
        return "emptyChild: buffer expected";
      if (t.hash != null && t.hasOwnProperty("hash"))
        switch (t.hash) {
          default:
            return "hash: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      return null;
    }, o.fromObject = function(t) {
      if (t instanceof Y.ics23.InnerSpec)
        return t;
      var u = new Y.ics23.InnerSpec();
      if (t.childOrder) {
        if (!Array.isArray(t.childOrder))
          throw TypeError(".ics23.InnerSpec.childOrder: array expected");
        u.childOrder = [];
        for (var r = 0; r < t.childOrder.length; ++r)
          u.childOrder[r] = t.childOrder[r] | 0;
      }
      switch (t.childSize != null && (u.childSize = t.childSize | 0), t.minPrefixLength != null && (u.minPrefixLength = t.minPrefixLength | 0), t.maxPrefixLength != null && (u.maxPrefixLength = t.maxPrefixLength | 0), t.emptyChild != null && (typeof t.emptyChild == "string" ? ne.base64.decode(t.emptyChild, u.emptyChild = ne.newBuffer(ne.base64.length(t.emptyChild)), 0) : t.emptyChild.length && (u.emptyChild = t.emptyChild)), t.hash) {
        case "NO_HASH":
        case 0:
          u.hash = 0;
          break;
        case "SHA256":
        case 1:
          u.hash = 1;
          break;
        case "SHA512":
        case 2:
          u.hash = 2;
          break;
        case "KECCAK":
        case 3:
          u.hash = 3;
          break;
        case "RIPEMD160":
        case 4:
          u.hash = 4;
          break;
        case "BITCOIN":
        case 5:
          u.hash = 5;
          break;
        case "SHA512_256":
        case 6:
          u.hash = 6;
          break;
      }
      return u;
    }, o.toObject = function(t, u) {
      u || (u = {});
      var r = {};
      if ((u.arrays || u.defaults) && (r.childOrder = []), u.defaults && (r.childSize = 0, r.minPrefixLength = 0, r.maxPrefixLength = 0, u.bytes === String ? r.emptyChild = "" : (r.emptyChild = [], u.bytes !== Array && (r.emptyChild = ne.newBuffer(r.emptyChild))), r.hash = u.enums === String ? "NO_HASH" : 0), t.childOrder && t.childOrder.length) {
        r.childOrder = [];
        for (var m = 0; m < t.childOrder.length; ++m)
          r.childOrder[m] = t.childOrder[m];
      }
      return t.childSize != null && t.hasOwnProperty("childSize") && (r.childSize = t.childSize), t.minPrefixLength != null && t.hasOwnProperty("minPrefixLength") && (r.minPrefixLength = t.minPrefixLength), t.maxPrefixLength != null && t.hasOwnProperty("maxPrefixLength") && (r.maxPrefixLength = t.maxPrefixLength), t.emptyChild != null && t.hasOwnProperty("emptyChild") && (r.emptyChild = u.bytes === String ? ne.base64.encode(t.emptyChild, 0, t.emptyChild.length) : u.bytes === Array ? Array.prototype.slice.call(t.emptyChild) : t.emptyChild), t.hash != null && t.hasOwnProperty("hash") && (r.hash = u.enums === String ? Y.ics23.HashOp[t.hash] : t.hash), r;
    }, o.prototype.toJSON = function() {
      return this.constructor.toObject(this, Pe.util.toJSONOptions);
    }, o;
  }(), e.BatchProof = function() {
    function o(t) {
      if (this.entries = [], t)
        for (var u = Object.keys(t), r = 0; r < u.length; ++r)
          t[u[r]] != null && (this[u[r]] = t[u[r]]);
    }
    return o.prototype.entries = ne.emptyArray, o.create = function(t) {
      return new o(t);
    }, o.encode = function(t, u) {
      if (u || (u = ze.create()), t.entries != null && t.entries.length)
        for (var r = 0; r < t.entries.length; ++r)
          Y.ics23.BatchEntry.encode(t.entries[r], u.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
      return u;
    }, o.encodeDelimited = function(t, u) {
      return this.encode(t, u).ldelim();
    }, o.decode = function(t, u) {
      t instanceof se || (t = se.create(t));
      for (var r = u === void 0 ? t.len : t.pos + u, m = new Y.ics23.BatchProof(); t.pos < r; ) {
        var f = t.uint32();
        switch (f >>> 3) {
          case 1:
            m.entries && m.entries.length || (m.entries = []), m.entries.push(Y.ics23.BatchEntry.decode(t, t.uint32()));
            break;
          default:
            t.skipType(f & 7);
            break;
        }
      }
      return m;
    }, o.decodeDelimited = function(t) {
      return t instanceof se || (t = new se(t)), this.decode(t, t.uint32());
    }, o.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.entries != null && t.hasOwnProperty("entries")) {
        if (!Array.isArray(t.entries))
          return "entries: array expected";
        for (var u = 0; u < t.entries.length; ++u) {
          var r = Y.ics23.BatchEntry.verify(t.entries[u]);
          if (r)
            return "entries." + r;
        }
      }
      return null;
    }, o.fromObject = function(t) {
      if (t instanceof Y.ics23.BatchProof)
        return t;
      var u = new Y.ics23.BatchProof();
      if (t.entries) {
        if (!Array.isArray(t.entries))
          throw TypeError(".ics23.BatchProof.entries: array expected");
        u.entries = [];
        for (var r = 0; r < t.entries.length; ++r) {
          if (typeof t.entries[r] != "object")
            throw TypeError(".ics23.BatchProof.entries: object expected");
          u.entries[r] = Y.ics23.BatchEntry.fromObject(t.entries[r]);
        }
      }
      return u;
    }, o.toObject = function(t, u) {
      u || (u = {});
      var r = {};
      if ((u.arrays || u.defaults) && (r.entries = []), t.entries && t.entries.length) {
        r.entries = [];
        for (var m = 0; m < t.entries.length; ++m)
          r.entries[m] = Y.ics23.BatchEntry.toObject(t.entries[m], u);
      }
      return r;
    }, o.prototype.toJSON = function() {
      return this.constructor.toObject(this, Pe.util.toJSONOptions);
    }, o;
  }(), e.BatchEntry = function() {
    function o(u) {
      if (u)
        for (var r = Object.keys(u), m = 0; m < r.length; ++m)
          u[r[m]] != null && (this[r[m]] = u[r[m]]);
    }
    o.prototype.exist = null, o.prototype.nonexist = null;
    var t;
    return Object.defineProperty(o.prototype, "proof", {
      get: ne.oneOfGetter(t = ["exist", "nonexist"]),
      set: ne.oneOfSetter(t)
    }), o.create = function(u) {
      return new o(u);
    }, o.encode = function(u, r) {
      return r || (r = ze.create()), u.exist != null && u.hasOwnProperty("exist") && Y.ics23.ExistenceProof.encode(u.exist, r.uint32(
        /* id 1, wireType 2 =*/
        10
      ).fork()).ldelim(), u.nonexist != null && u.hasOwnProperty("nonexist") && Y.ics23.NonExistenceProof.encode(u.nonexist, r.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), r;
    }, o.encodeDelimited = function(u, r) {
      return this.encode(u, r).ldelim();
    }, o.decode = function(u, r) {
      u instanceof se || (u = se.create(u));
      for (var m = r === void 0 ? u.len : u.pos + r, f = new Y.ics23.BatchEntry(); u.pos < m; ) {
        var b = u.uint32();
        switch (b >>> 3) {
          case 1:
            f.exist = Y.ics23.ExistenceProof.decode(u, u.uint32());
            break;
          case 2:
            f.nonexist = Y.ics23.NonExistenceProof.decode(u, u.uint32());
            break;
          default:
            u.skipType(b & 7);
            break;
        }
      }
      return f;
    }, o.decodeDelimited = function(u) {
      return u instanceof se || (u = new se(u)), this.decode(u, u.uint32());
    }, o.verify = function(u) {
      if (typeof u != "object" || u === null)
        return "object expected";
      var r = {};
      if (u.exist != null && u.hasOwnProperty("exist")) {
        r.proof = 1;
        {
          var m = Y.ics23.ExistenceProof.verify(u.exist);
          if (m)
            return "exist." + m;
        }
      }
      if (u.nonexist != null && u.hasOwnProperty("nonexist")) {
        if (r.proof === 1)
          return "proof: multiple values";
        r.proof = 1;
        {
          var m = Y.ics23.NonExistenceProof.verify(u.nonexist);
          if (m)
            return "nonexist." + m;
        }
      }
      return null;
    }, o.fromObject = function(u) {
      if (u instanceof Y.ics23.BatchEntry)
        return u;
      var r = new Y.ics23.BatchEntry();
      if (u.exist != null) {
        if (typeof u.exist != "object")
          throw TypeError(".ics23.BatchEntry.exist: object expected");
        r.exist = Y.ics23.ExistenceProof.fromObject(u.exist);
      }
      if (u.nonexist != null) {
        if (typeof u.nonexist != "object")
          throw TypeError(".ics23.BatchEntry.nonexist: object expected");
        r.nonexist = Y.ics23.NonExistenceProof.fromObject(u.nonexist);
      }
      return r;
    }, o.toObject = function(u, r) {
      r || (r = {});
      var m = {};
      return u.exist != null && u.hasOwnProperty("exist") && (m.exist = Y.ics23.ExistenceProof.toObject(u.exist, r), r.oneofs && (m.proof = "exist")), u.nonexist != null && u.hasOwnProperty("nonexist") && (m.nonexist = Y.ics23.NonExistenceProof.toObject(u.nonexist, r), r.oneofs && (m.proof = "nonexist")), m;
    }, o.prototype.toJSON = function() {
      return this.constructor.toObject(this, Pe.util.toJSONOptions);
    }, o;
  }(), e.CompressedBatchProof = function() {
    function o(t) {
      if (this.entries = [], this.lookupInners = [], t)
        for (var u = Object.keys(t), r = 0; r < u.length; ++r)
          t[u[r]] != null && (this[u[r]] = t[u[r]]);
    }
    return o.prototype.entries = ne.emptyArray, o.prototype.lookupInners = ne.emptyArray, o.create = function(t) {
      return new o(t);
    }, o.encode = function(t, u) {
      if (u || (u = ze.create()), t.entries != null && t.entries.length)
        for (var r = 0; r < t.entries.length; ++r)
          Y.ics23.CompressedBatchEntry.encode(t.entries[r], u.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
      if (t.lookupInners != null && t.lookupInners.length)
        for (var r = 0; r < t.lookupInners.length; ++r)
          Y.ics23.InnerOp.encode(t.lookupInners[r], u.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
      return u;
    }, o.encodeDelimited = function(t, u) {
      return this.encode(t, u).ldelim();
    }, o.decode = function(t, u) {
      t instanceof se || (t = se.create(t));
      for (var r = u === void 0 ? t.len : t.pos + u, m = new Y.ics23.CompressedBatchProof(); t.pos < r; ) {
        var f = t.uint32();
        switch (f >>> 3) {
          case 1:
            m.entries && m.entries.length || (m.entries = []), m.entries.push(Y.ics23.CompressedBatchEntry.decode(t, t.uint32()));
            break;
          case 2:
            m.lookupInners && m.lookupInners.length || (m.lookupInners = []), m.lookupInners.push(Y.ics23.InnerOp.decode(t, t.uint32()));
            break;
          default:
            t.skipType(f & 7);
            break;
        }
      }
      return m;
    }, o.decodeDelimited = function(t) {
      return t instanceof se || (t = new se(t)), this.decode(t, t.uint32());
    }, o.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.entries != null && t.hasOwnProperty("entries")) {
        if (!Array.isArray(t.entries))
          return "entries: array expected";
        for (var u = 0; u < t.entries.length; ++u) {
          var r = Y.ics23.CompressedBatchEntry.verify(t.entries[u]);
          if (r)
            return "entries." + r;
        }
      }
      if (t.lookupInners != null && t.hasOwnProperty("lookupInners")) {
        if (!Array.isArray(t.lookupInners))
          return "lookupInners: array expected";
        for (var u = 0; u < t.lookupInners.length; ++u) {
          var r = Y.ics23.InnerOp.verify(t.lookupInners[u]);
          if (r)
            return "lookupInners." + r;
        }
      }
      return null;
    }, o.fromObject = function(t) {
      if (t instanceof Y.ics23.CompressedBatchProof)
        return t;
      var u = new Y.ics23.CompressedBatchProof();
      if (t.entries) {
        if (!Array.isArray(t.entries))
          throw TypeError(".ics23.CompressedBatchProof.entries: array expected");
        u.entries = [];
        for (var r = 0; r < t.entries.length; ++r) {
          if (typeof t.entries[r] != "object")
            throw TypeError(".ics23.CompressedBatchProof.entries: object expected");
          u.entries[r] = Y.ics23.CompressedBatchEntry.fromObject(t.entries[r]);
        }
      }
      if (t.lookupInners) {
        if (!Array.isArray(t.lookupInners))
          throw TypeError(".ics23.CompressedBatchProof.lookupInners: array expected");
        u.lookupInners = [];
        for (var r = 0; r < t.lookupInners.length; ++r) {
          if (typeof t.lookupInners[r] != "object")
            throw TypeError(".ics23.CompressedBatchProof.lookupInners: object expected");
          u.lookupInners[r] = Y.ics23.InnerOp.fromObject(t.lookupInners[r]);
        }
      }
      return u;
    }, o.toObject = function(t, u) {
      u || (u = {});
      var r = {};
      if ((u.arrays || u.defaults) && (r.entries = [], r.lookupInners = []), t.entries && t.entries.length) {
        r.entries = [];
        for (var m = 0; m < t.entries.length; ++m)
          r.entries[m] = Y.ics23.CompressedBatchEntry.toObject(t.entries[m], u);
      }
      if (t.lookupInners && t.lookupInners.length) {
        r.lookupInners = [];
        for (var m = 0; m < t.lookupInners.length; ++m)
          r.lookupInners[m] = Y.ics23.InnerOp.toObject(t.lookupInners[m], u);
      }
      return r;
    }, o.prototype.toJSON = function() {
      return this.constructor.toObject(this, Pe.util.toJSONOptions);
    }, o;
  }(), e.CompressedBatchEntry = function() {
    function o(u) {
      if (u)
        for (var r = Object.keys(u), m = 0; m < r.length; ++m)
          u[r[m]] != null && (this[r[m]] = u[r[m]]);
    }
    o.prototype.exist = null, o.prototype.nonexist = null;
    var t;
    return Object.defineProperty(o.prototype, "proof", {
      get: ne.oneOfGetter(t = ["exist", "nonexist"]),
      set: ne.oneOfSetter(t)
    }), o.create = function(u) {
      return new o(u);
    }, o.encode = function(u, r) {
      return r || (r = ze.create()), u.exist != null && u.hasOwnProperty("exist") && Y.ics23.CompressedExistenceProof.encode(u.exist, r.uint32(
        /* id 1, wireType 2 =*/
        10
      ).fork()).ldelim(), u.nonexist != null && u.hasOwnProperty("nonexist") && Y.ics23.CompressedNonExistenceProof.encode(u.nonexist, r.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), r;
    }, o.encodeDelimited = function(u, r) {
      return this.encode(u, r).ldelim();
    }, o.decode = function(u, r) {
      u instanceof se || (u = se.create(u));
      for (var m = r === void 0 ? u.len : u.pos + r, f = new Y.ics23.CompressedBatchEntry(); u.pos < m; ) {
        var b = u.uint32();
        switch (b >>> 3) {
          case 1:
            f.exist = Y.ics23.CompressedExistenceProof.decode(u, u.uint32());
            break;
          case 2:
            f.nonexist = Y.ics23.CompressedNonExistenceProof.decode(u, u.uint32());
            break;
          default:
            u.skipType(b & 7);
            break;
        }
      }
      return f;
    }, o.decodeDelimited = function(u) {
      return u instanceof se || (u = new se(u)), this.decode(u, u.uint32());
    }, o.verify = function(u) {
      if (typeof u != "object" || u === null)
        return "object expected";
      var r = {};
      if (u.exist != null && u.hasOwnProperty("exist")) {
        r.proof = 1;
        {
          var m = Y.ics23.CompressedExistenceProof.verify(u.exist);
          if (m)
            return "exist." + m;
        }
      }
      if (u.nonexist != null && u.hasOwnProperty("nonexist")) {
        if (r.proof === 1)
          return "proof: multiple values";
        r.proof = 1;
        {
          var m = Y.ics23.CompressedNonExistenceProof.verify(u.nonexist);
          if (m)
            return "nonexist." + m;
        }
      }
      return null;
    }, o.fromObject = function(u) {
      if (u instanceof Y.ics23.CompressedBatchEntry)
        return u;
      var r = new Y.ics23.CompressedBatchEntry();
      if (u.exist != null) {
        if (typeof u.exist != "object")
          throw TypeError(".ics23.CompressedBatchEntry.exist: object expected");
        r.exist = Y.ics23.CompressedExistenceProof.fromObject(u.exist);
      }
      if (u.nonexist != null) {
        if (typeof u.nonexist != "object")
          throw TypeError(".ics23.CompressedBatchEntry.nonexist: object expected");
        r.nonexist = Y.ics23.CompressedNonExistenceProof.fromObject(u.nonexist);
      }
      return r;
    }, o.toObject = function(u, r) {
      r || (r = {});
      var m = {};
      return u.exist != null && u.hasOwnProperty("exist") && (m.exist = Y.ics23.CompressedExistenceProof.toObject(u.exist, r), r.oneofs && (m.proof = "exist")), u.nonexist != null && u.hasOwnProperty("nonexist") && (m.nonexist = Y.ics23.CompressedNonExistenceProof.toObject(u.nonexist, r), r.oneofs && (m.proof = "nonexist")), m;
    }, o.prototype.toJSON = function() {
      return this.constructor.toObject(this, Pe.util.toJSONOptions);
    }, o;
  }(), e.CompressedExistenceProof = function() {
    function o(t) {
      if (this.path = [], t)
        for (var u = Object.keys(t), r = 0; r < u.length; ++r)
          t[u[r]] != null && (this[u[r]] = t[u[r]]);
    }
    return o.prototype.key = ne.newBuffer([]), o.prototype.value = ne.newBuffer([]), o.prototype.leaf = null, o.prototype.path = ne.emptyArray, o.create = function(t) {
      return new o(t);
    }, o.encode = function(t, u) {
      if (u || (u = ze.create()), t.key != null && t.hasOwnProperty("key") && u.uint32(
        /* id 1, wireType 2 =*/
        10
      ).bytes(t.key), t.value != null && t.hasOwnProperty("value") && u.uint32(
        /* id 2, wireType 2 =*/
        18
      ).bytes(t.value), t.leaf != null && t.hasOwnProperty("leaf") && Y.ics23.LeafOp.encode(t.leaf, u.uint32(
        /* id 3, wireType 2 =*/
        26
      ).fork()).ldelim(), t.path != null && t.path.length) {
        u.uint32(
          /* id 4, wireType 2 =*/
          34
        ).fork();
        for (var r = 0; r < t.path.length; ++r)
          u.int32(t.path[r]);
        u.ldelim();
      }
      return u;
    }, o.encodeDelimited = function(t, u) {
      return this.encode(t, u).ldelim();
    }, o.decode = function(t, u) {
      t instanceof se || (t = se.create(t));
      for (var r = u === void 0 ? t.len : t.pos + u, m = new Y.ics23.CompressedExistenceProof(); t.pos < r; ) {
        var f = t.uint32();
        switch (f >>> 3) {
          case 1:
            m.key = t.bytes();
            break;
          case 2:
            m.value = t.bytes();
            break;
          case 3:
            m.leaf = Y.ics23.LeafOp.decode(t, t.uint32());
            break;
          case 4:
            if (m.path && m.path.length || (m.path = []), (f & 7) === 2)
              for (var b = t.uint32() + t.pos; t.pos < b; )
                m.path.push(t.int32());
            else
              m.path.push(t.int32());
            break;
          default:
            t.skipType(f & 7);
            break;
        }
      }
      return m;
    }, o.decodeDelimited = function(t) {
      return t instanceof se || (t = new se(t)), this.decode(t, t.uint32());
    }, o.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.key != null && t.hasOwnProperty("key") && !(t.key && typeof t.key.length == "number" || ne.isString(t.key)))
        return "key: buffer expected";
      if (t.value != null && t.hasOwnProperty("value") && !(t.value && typeof t.value.length == "number" || ne.isString(t.value)))
        return "value: buffer expected";
      if (t.leaf != null && t.hasOwnProperty("leaf")) {
        var u = Y.ics23.LeafOp.verify(t.leaf);
        if (u)
          return "leaf." + u;
      }
      if (t.path != null && t.hasOwnProperty("path")) {
        if (!Array.isArray(t.path))
          return "path: array expected";
        for (var r = 0; r < t.path.length; ++r)
          if (!ne.isInteger(t.path[r]))
            return "path: integer[] expected";
      }
      return null;
    }, o.fromObject = function(t) {
      if (t instanceof Y.ics23.CompressedExistenceProof)
        return t;
      var u = new Y.ics23.CompressedExistenceProof();
      if (t.key != null && (typeof t.key == "string" ? ne.base64.decode(t.key, u.key = ne.newBuffer(ne.base64.length(t.key)), 0) : t.key.length && (u.key = t.key)), t.value != null && (typeof t.value == "string" ? ne.base64.decode(t.value, u.value = ne.newBuffer(ne.base64.length(t.value)), 0) : t.value.length && (u.value = t.value)), t.leaf != null) {
        if (typeof t.leaf != "object")
          throw TypeError(".ics23.CompressedExistenceProof.leaf: object expected");
        u.leaf = Y.ics23.LeafOp.fromObject(t.leaf);
      }
      if (t.path) {
        if (!Array.isArray(t.path))
          throw TypeError(".ics23.CompressedExistenceProof.path: array expected");
        u.path = [];
        for (var r = 0; r < t.path.length; ++r)
          u.path[r] = t.path[r] | 0;
      }
      return u;
    }, o.toObject = function(t, u) {
      u || (u = {});
      var r = {};
      if ((u.arrays || u.defaults) && (r.path = []), u.defaults && (u.bytes === String ? r.key = "" : (r.key = [], u.bytes !== Array && (r.key = ne.newBuffer(r.key))), u.bytes === String ? r.value = "" : (r.value = [], u.bytes !== Array && (r.value = ne.newBuffer(r.value))), r.leaf = null), t.key != null && t.hasOwnProperty("key") && (r.key = u.bytes === String ? ne.base64.encode(t.key, 0, t.key.length) : u.bytes === Array ? Array.prototype.slice.call(t.key) : t.key), t.value != null && t.hasOwnProperty("value") && (r.value = u.bytes === String ? ne.base64.encode(t.value, 0, t.value.length) : u.bytes === Array ? Array.prototype.slice.call(t.value) : t.value), t.leaf != null && t.hasOwnProperty("leaf") && (r.leaf = Y.ics23.LeafOp.toObject(t.leaf, u)), t.path && t.path.length) {
        r.path = [];
        for (var m = 0; m < t.path.length; ++m)
          r.path[m] = t.path[m];
      }
      return r;
    }, o.prototype.toJSON = function() {
      return this.constructor.toObject(this, Pe.util.toJSONOptions);
    }, o;
  }(), e.CompressedNonExistenceProof = function() {
    function o(t) {
      if (t)
        for (var u = Object.keys(t), r = 0; r < u.length; ++r)
          t[u[r]] != null && (this[u[r]] = t[u[r]]);
    }
    return o.prototype.key = ne.newBuffer([]), o.prototype.left = null, o.prototype.right = null, o.create = function(t) {
      return new o(t);
    }, o.encode = function(t, u) {
      return u || (u = ze.create()), t.key != null && t.hasOwnProperty("key") && u.uint32(
        /* id 1, wireType 2 =*/
        10
      ).bytes(t.key), t.left != null && t.hasOwnProperty("left") && Y.ics23.CompressedExistenceProof.encode(t.left, u.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), t.right != null && t.hasOwnProperty("right") && Y.ics23.CompressedExistenceProof.encode(t.right, u.uint32(
        /* id 3, wireType 2 =*/
        26
      ).fork()).ldelim(), u;
    }, o.encodeDelimited = function(t, u) {
      return this.encode(t, u).ldelim();
    }, o.decode = function(t, u) {
      t instanceof se || (t = se.create(t));
      for (var r = u === void 0 ? t.len : t.pos + u, m = new Y.ics23.CompressedNonExistenceProof(); t.pos < r; ) {
        var f = t.uint32();
        switch (f >>> 3) {
          case 1:
            m.key = t.bytes();
            break;
          case 2:
            m.left = Y.ics23.CompressedExistenceProof.decode(t, t.uint32());
            break;
          case 3:
            m.right = Y.ics23.CompressedExistenceProof.decode(t, t.uint32());
            break;
          default:
            t.skipType(f & 7);
            break;
        }
      }
      return m;
    }, o.decodeDelimited = function(t) {
      return t instanceof se || (t = new se(t)), this.decode(t, t.uint32());
    }, o.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.key != null && t.hasOwnProperty("key") && !(t.key && typeof t.key.length == "number" || ne.isString(t.key)))
        return "key: buffer expected";
      if (t.left != null && t.hasOwnProperty("left")) {
        var u = Y.ics23.CompressedExistenceProof.verify(t.left);
        if (u)
          return "left." + u;
      }
      if (t.right != null && t.hasOwnProperty("right")) {
        var u = Y.ics23.CompressedExistenceProof.verify(t.right);
        if (u)
          return "right." + u;
      }
      return null;
    }, o.fromObject = function(t) {
      if (t instanceof Y.ics23.CompressedNonExistenceProof)
        return t;
      var u = new Y.ics23.CompressedNonExistenceProof();
      if (t.key != null && (typeof t.key == "string" ? ne.base64.decode(t.key, u.key = ne.newBuffer(ne.base64.length(t.key)), 0) : t.key.length && (u.key = t.key)), t.left != null) {
        if (typeof t.left != "object")
          throw TypeError(".ics23.CompressedNonExistenceProof.left: object expected");
        u.left = Y.ics23.CompressedExistenceProof.fromObject(t.left);
      }
      if (t.right != null) {
        if (typeof t.right != "object")
          throw TypeError(".ics23.CompressedNonExistenceProof.right: object expected");
        u.right = Y.ics23.CompressedExistenceProof.fromObject(t.right);
      }
      return u;
    }, o.toObject = function(t, u) {
      u || (u = {});
      var r = {};
      return u.defaults && (u.bytes === String ? r.key = "" : (r.key = [], u.bytes !== Array && (r.key = ne.newBuffer(r.key))), r.left = null, r.right = null), t.key != null && t.hasOwnProperty("key") && (r.key = u.bytes === String ? ne.base64.encode(t.key, 0, t.key.length) : u.bytes === Array ? Array.prototype.slice.call(t.key) : t.key), t.left != null && t.hasOwnProperty("left") && (r.left = Y.ics23.CompressedExistenceProof.toObject(t.left, u)), t.right != null && t.hasOwnProperty("right") && (r.right = Y.ics23.CompressedExistenceProof.toObject(t.right, u)), r;
    }, o.prototype.toJSON = function() {
      return this.constructor.toObject(this, Pe.util.toJSONOptions);
    }, o;
  }(), e;
}();
var qo = Y, bt = {}, Rn = {};
Object.defineProperty(Rn, "__esModule", { value: !0 });
Rn.decompress = Rn.compress = void 0;
const ll = qo;
function pl(e) {
  return e.batch ? { compressed: ml(e.batch) } : e;
}
Rn.compress = pl;
function fl(e) {
  return e.compressed ? { batch: gl(e.compressed) } : e;
}
Rn.decompress = fl;
function ml(e) {
  const o = [], t = [], u = /* @__PURE__ */ new Map();
  for (const r of e.entries)
    if (r.exist) {
      const m = { exist: Wr(r.exist, t, u) };
      o.push(m);
    } else if (r.nonexist) {
      const m = r.nonexist, f = {
        nonexist: {
          key: m.key,
          left: Wr(m.left, t, u),
          right: Wr(m.right, t, u)
        }
      };
      o.push(f);
    } else
      throw new Error("Unexpected batch entry during compress");
  return {
    entries: o,
    lookupInners: t
  };
}
function Wr(e, o, t) {
  if (!e)
    return;
  const u = e.path.map((r) => {
    const m = ll.ics23.InnerOp.encode(r).finish();
    let f = t.get(m);
    return f === void 0 && (f = o.length, o.push(r), t.set(m, f)), f;
  });
  return {
    key: e.key,
    value: e.value,
    leaf: e.leaf,
    path: u
  };
}
function gl(e) {
  const o = e.lookupInners;
  return {
    entries: e.entries.map((t) => {
      if (t.exist)
        return { exist: qr(t.exist, o) };
      if (t.nonexist) {
        const u = t.nonexist;
        return {
          nonexist: {
            key: u.key,
            left: qr(u.left, o),
            right: qr(u.right, o)
          }
        };
      } else
        throw new Error("Unexpected batch entry during compress");
    })
  };
}
function qr(e, o) {
  if (!e)
    return;
  const { key: t, value: u, leaf: r, path: m } = e, f = (m || []).map((b) => o[b]);
  return { key: t, value: u, leaf: r, path: f };
}
var ke = {}, Ut = {};
Object.defineProperty(Ut, "__esModule", { value: !0 });
Ut.doHash = Ut.applyInner = Ut.applyLeaf = void 0;
const ea = Qu, ta = Fu, na = Gu, Ye = qo;
function hl(e, o, t) {
  if (o.length === 0)
    throw new Error("Missing key");
  if (t.length === 0)
    throw new Error("Missing value");
  const u = ra(Ao(e.prehashKey), oa(e.length), o), r = ra(Ao(e.prehashValue), oa(e.length), t), m = new Uint8Array([
    ...Ri(e.prefix),
    ...u,
    ...r
  ]);
  return Zo(Ao(e.hash), m);
}
Ut.applyLeaf = hl;
function vl(e, o) {
  if (o.length === 0)
    throw new Error("Inner op needs child value");
  const t = new Uint8Array([
    ...Ri(e.prefix),
    ...o,
    ...Ri(e.suffix)
  ]);
  return Zo(Ao(e.hash), t);
}
Ut.applyInner = vl;
function Wi(e, o) {
  return e ?? o;
}
const Ao = (e) => Wi(e, Ye.ics23.HashOp.NO_HASH), oa = (e) => Wi(e, Ye.ics23.LengthOp.NO_PREFIX), Ri = (e) => Wi(e, new Uint8Array([]));
function ra(e, o, t) {
  const u = yl(e, t);
  return Sl(o, u);
}
function yl(e, o) {
  return e === Ye.ics23.HashOp.NO_HASH ? o : Zo(e, o);
}
function Zo(e, o) {
  switch (e) {
    case Ye.ics23.HashOp.SHA256:
      return (0, ta.sha256)(o);
    case Ye.ics23.HashOp.SHA512:
      return (0, na.sha512)(o);
    case Ye.ics23.HashOp.RIPEMD160:
      return (0, ea.ripemd160)(o);
    case Ye.ics23.HashOp.BITCOIN:
      return (0, ea.ripemd160)((0, ta.sha256)(o));
    case Ye.ics23.HashOp.SHA512_256:
      return (0, na.sha512_256)(o);
  }
  throw new Error(`Unsupported hashop: ${e}`);
}
Ut.doHash = Zo;
function Sl(e, o) {
  switch (e) {
    case Ye.ics23.LengthOp.NO_PREFIX:
      return o;
    case Ye.ics23.LengthOp.VAR_PROTO:
      return new Uint8Array([...bl(o.length), ...o]);
    case Ye.ics23.LengthOp.REQUIRE_32_BYTES:
      if (o.length !== 32)
        throw new Error(`Length is ${o.length}, not 32 bytes`);
      return o;
    case Ye.ics23.LengthOp.REQUIRE_64_BYTES:
      if (o.length !== 64)
        throw new Error(`Length is ${o.length}, not 64 bytes`);
      return o;
    case Ye.ics23.LengthOp.FIXED32_LITTLE:
      return new Uint8Array([...Ol(o.length), ...o]);
  }
  throw new Error(`Unsupported lengthop: ${e}`);
}
function bl(e) {
  let o = [], t = e;
  for (; t >= 128; ) {
    const u = t % 128 + 128;
    o = [...o, u], t = t / 128;
  }
  return o = [...o, t], new Uint8Array(o);
}
function Ol(e) {
  const o = new Uint8Array(4);
  let t = e;
  for (let u = o.length; u > 0; u--)
    o[Math.abs(u - o.length)] = t % 256, t = Math.floor(t / 256);
  return o;
}
var Ue = {};
Object.defineProperty(Ue, "__esModule", { value: !0 });
Ue.bytesBefore = Ue.ensureBytesBefore = Ue.bytesEqual = Ue.ensureBytesEqual = Ue.ensureInner = Ue.ensureLeaf = void 0;
function kl(e, o) {
  if (e.hash !== o.hash)
    throw new Error(`Unexpected hashOp: ${e.hash}`);
  if (e.prehashKey !== o.prehashKey)
    throw new Error(`Unexpected prehashKey: ${e.prehashKey}`);
  if (e.prehashValue !== o.prehashValue)
    throw new Error(`Unexpected prehashValue: ${e.prehashValue}`);
  if (e.length !== o.length)
    throw new Error(`Unexpected length op: ${e.length}`);
  Rl(e.prefix, o.prefix);
}
Ue.ensureLeaf = kl;
function Pl(e, o, t) {
  if (e.hash !== t.hash)
    throw new Error(`Unexpected hashOp: ${e.hash}`);
  if (!e.prefix)
    throw new Error("No prefix set for inner node");
  if (wl(e.prefix, o))
    throw new Error("Inner node has leaf prefix");
  if (e.prefix.length < (t.minPrefixLength || 0))
    throw new Error(`Prefix too short: ${e.prefix.length} bytes`);
  const u = (t.childOrder.length - 1) * t.childSize;
  if (e.prefix.length > (t.maxPrefixLength || 0) + u)
    throw new Error(`Prefix too long: ${e.prefix.length} bytes`);
}
Ue.ensureInner = Pl;
function Rl(e, o) {
  if (!(!o || o.length === 0)) {
    if (!e)
      throw new Error("Target bytes missing");
    Md(o, e.slice(0, o.length));
  }
}
function Md(e, o) {
  if (e.length !== o.length)
    throw new Error(`Different lengths ${e.length} vs ${o.length}`);
  for (let t = 0; t < e.length; t++)
    if (e[t] !== o[t])
      throw new Error(`Arrays differ at index ${t}: ${e[t]} vs ${o[t]}`);
}
Ue.ensureBytesEqual = Md;
function Al(e, o) {
  if (e.length !== o.length)
    return !1;
  for (let t = 0; t < e.length; t++)
    if (e[t] !== o[t])
      return !1;
  return !0;
}
Ue.bytesEqual = Al;
function wl(e, o) {
  if (!o || o.length === 0 || !e || e.length <= o.length)
    return !1;
  for (let t = 0; t < o.length; t++)
    if (e[t] !== o[t])
      return !1;
  throw !0;
}
function Nl(e, o) {
  if (!Hd(e, o))
    throw new Error("first is after last");
}
Ue.ensureBytesBefore = Nl;
function Hd(e, o) {
  const t = e.length < o.length ? e.length : o.length;
  for (let u = 0; u < t; u++) {
    if (e[u] < o[u])
      return !0;
    if (e[u] > o[u])
      return !1;
  }
  return e.length < o.length;
}
Ue.bytesBefore = Hd;
Object.defineProperty(ke, "__esModule", { value: !0 });
ke.ensureLeftNeighbor = ke.ensureSpec = ke.calculateExistenceRoot = ke.verifyNonExistence = ke.verifyExistence = ke.smtSpec = ke.tendermintSpec = ke.iavlSpec = void 0;
const De = qo, ia = Ut, wt = Ue;
ke.iavlSpec = {
  leafSpec: {
    prefix: Uint8Array.from([0]),
    hash: De.ics23.HashOp.SHA256,
    prehashValue: De.ics23.HashOp.SHA256,
    prehashKey: De.ics23.HashOp.NO_HASH,
    length: De.ics23.LengthOp.VAR_PROTO
  },
  innerSpec: {
    childOrder: [0, 1],
    minPrefixLength: 4,
    maxPrefixLength: 12,
    childSize: 33,
    hash: De.ics23.HashOp.SHA256
  }
};
ke.tendermintSpec = {
  leafSpec: {
    prefix: Uint8Array.from([0]),
    hash: De.ics23.HashOp.SHA256,
    prehashValue: De.ics23.HashOp.SHA256,
    prehashKey: De.ics23.HashOp.NO_HASH,
    length: De.ics23.LengthOp.VAR_PROTO
  },
  innerSpec: {
    childOrder: [0, 1],
    minPrefixLength: 1,
    maxPrefixLength: 1,
    childSize: 32,
    hash: De.ics23.HashOp.SHA256
  }
};
ke.smtSpec = {
  leafSpec: {
    hash: De.ics23.HashOp.SHA256,
    prehashKey: De.ics23.HashOp.NO_HASH,
    prehashValue: De.ics23.HashOp.SHA256,
    length: De.ics23.LengthOp.NO_PREFIX,
    prefix: Uint8Array.from([0])
  },
  innerSpec: {
    childOrder: [0, 1],
    childSize: 32,
    minPrefixLength: 1,
    maxPrefixLength: 1,
    emptyChild: new Uint8Array(32),
    hash: De.ics23.HashOp.SHA256
  },
  maxDepth: 256
};
function Ai(e, o, t, u, r) {
  Wd(e, o);
  const m = jd(e);
  (0, wt.ensureBytesEqual)(m, t), (0, wt.ensureBytesEqual)(u, e.key), (0, wt.ensureBytesEqual)(r, e.value);
}
ke.verifyExistence = Ai;
function El(e, o, t, u) {
  let r, m;
  if (e.left && (Ai(e.left, o, t, e.left.key, e.left.value), r = e.left.key), e.right && (Ai(e.right, o, t, e.right.key, e.right.value), m = e.right.key), !r && !m)
    throw new Error("neither left nor right proof defined");
  if (r && (0, wt.ensureBytesBefore)(r, u), m && (0, wt.ensureBytesBefore)(u, m), !o.innerSpec)
    throw new Error("no inner spec");
  r ? m ? Qd(o.innerSpec, e.left.path, e.right.path) : Zd(o.innerSpec, e.left.path) : qd(o.innerSpec, e.right.path);
}
ke.verifyNonExistence = El;
function jd(e) {
  if (!e.key || !e.value)
    throw new Error("Existence proof needs key and value set");
  if (!e.leaf)
    throw new Error("Existence proof must start with a leaf operation");
  const o = e.path || [];
  let t = (0, ia.applyLeaf)(e.leaf, e.key, e.value);
  for (const u of o)
    t = (0, ia.applyInner)(u, t);
  return t;
}
ke.calculateExistenceRoot = jd;
function Wd(e, o) {
  if (!e.leaf)
    throw new Error("Existence proof must start with a leaf operation");
  if (!o.leafSpec)
    throw new Error("Spec must include leafSpec");
  if (!o.innerSpec)
    throw new Error("Spec must include innerSpec");
  (0, wt.ensureLeaf)(e.leaf, o.leafSpec);
  const t = e.path || [];
  if (o.minDepth && t.length < o.minDepth)
    throw new Error(`Too few inner nodes ${t.length}`);
  if (o.maxDepth && t.length > o.maxDepth)
    throw new Error(`Too many inner nodes ${t.length}`);
  for (const u of t)
    (0, wt.ensureInner)(u, o.leafSpec.prefix, o.innerSpec);
}
ke.ensureSpec = Wd;
function qd(e, o) {
  const { minPrefix: t, maxPrefix: u, suffix: r } = Zi(e, 0);
  for (const m of o)
    if (!qi(m, t, u, r))
      throw new Error("Step not leftmost");
}
function Zd(e, o) {
  const t = e.childOrder.length - 1, { minPrefix: u, maxPrefix: r, suffix: m } = Zi(e, t);
  for (const f of o)
    if (!qi(f, u, r, m))
      throw new Error("Step not leftmost");
}
function Qd(e, o, t) {
  const u = [...o], r = [...t];
  let m = u.pop(), f = r.pop();
  for (; (0, wt.bytesEqual)(m.prefix, f.prefix) && (0, wt.bytesEqual)(m.suffix, f.suffix); )
    m = u.pop(), f = r.pop();
  if (!Tl(e, m, f))
    throw new Error("Not left neightbor at first divergent step");
  Zd(e, u), qd(e, r);
}
ke.ensureLeftNeighbor = Qd;
function Tl(e, o, t) {
  const u = sa(e, o);
  return sa(e, t) === u + 1;
}
function sa(e, o) {
  for (let t = 0; t < e.childOrder.length; t++) {
    const { minPrefix: u, maxPrefix: r, suffix: m } = Zi(e, t);
    if (qi(o, u, r, m))
      return t;
  }
  throw new Error("Cannot find any valid spacing for this node");
}
function qi(e, o, t, u) {
  return (e.prefix || []).length < o || (e.prefix || []).length > t ? !1 : (e.suffix || []).length === u;
}
function Zi(e, o) {
  const t = Cl(e.childOrder, o), u = t * e.childSize, r = u + e.minPrefixLength, m = u + e.maxPrefixLength, f = (e.childOrder.length - 1 - t) * e.childSize;
  return { minPrefix: r, maxPrefix: m, suffix: f };
}
function Cl(e, o) {
  if (o < 0 || o >= e.length)
    throw new Error(`Invalid branch: ${o}`);
  return e.findIndex((t) => t === o);
}
Object.defineProperty(bt, "__esModule", { value: !0 });
bt.batchVerifyNonMembership = bt.batchVerifyMembership = bt.verifyNonMembership = bt.verifyMembership = void 0;
const Qo = Rn, Fd = ke, wi = Ue;
function Gd(e, o, t, u, r) {
  const m = (0, Qo.decompress)(e), f = _l(m, u);
  if (!f)
    return !1;
  try {
    return (0, Fd.verifyExistence)(f, o, t, u, r), !0;
  } catch {
    return !1;
  }
}
bt.verifyMembership = Gd;
function Kd(e, o, t, u) {
  const r = (0, Qo.decompress)(e), m = Jl(r, u);
  if (!m)
    return !1;
  try {
    return (0, Fd.verifyNonExistence)(m, o, t, u), !0;
  } catch {
    return !1;
  }
}
bt.verifyNonMembership = Kd;
function Il(e, o, t, u) {
  const r = (0, Qo.decompress)(e);
  for (const [m, f] of u.entries())
    if (!Gd(r, o, t, m, f))
      return !1;
  return !0;
}
bt.batchVerifyMembership = Il;
function xl(e, o, t, u) {
  const r = (0, Qo.decompress)(e);
  for (const m of u)
    if (!Kd(r, o, t, m))
      return !1;
  return !0;
}
bt.batchVerifyNonMembership = xl;
function _l(e, o) {
  const t = (u) => !!u && (0, wi.bytesEqual)(o, u.key);
  if (t(e.exist))
    return e.exist;
  if (e.batch)
    return e.batch.entries.map((u) => u.exist || null).find(t);
}
function Jl(e, o) {
  const t = (u) => !!u && (!u.left || (0, wi.bytesBefore)(u.left.key, o)) && (!u.right || (0, wi.bytesBefore)(o, u.right.key));
  if (t(e.nonexist))
    return e.nonexist;
  if (e.batch)
    return e.batch.entries.map((u) => u.nonexist || null).find(t);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.verifyNonExistence = e.verifyExistence = e.tendermintSpec = e.iavlSpec = e.calculateExistenceRoot = e.verifyNonMembership = e.verifyMembership = e.ics23 = void 0;
  var o = qo;
  Object.defineProperty(e, "ics23", { enumerable: !0, get: function() {
    return o.ics23;
  } });
  var t = bt;
  Object.defineProperty(e, "verifyMembership", { enumerable: !0, get: function() {
    return t.verifyMembership;
  } }), Object.defineProperty(e, "verifyNonMembership", { enumerable: !0, get: function() {
    return t.verifyNonMembership;
  } });
  var u = ke;
  Object.defineProperty(e, "calculateExistenceRoot", { enumerable: !0, get: function() {
    return u.calculateExistenceRoot;
  } }), Object.defineProperty(e, "iavlSpec", { enumerable: !0, get: function() {
    return u.iavlSpec;
  } }), Object.defineProperty(e, "tendermintSpec", { enumerable: !0, get: function() {
    return u.tendermintSpec;
  } }), Object.defineProperty(e, "verifyExistence", { enumerable: !0, get: function() {
    return u.verifyExistence;
  } }), Object.defineProperty(e, "verifyNonExistence", { enumerable: !0, get: function() {
    return u.verifyNonExistence;
  } });
})(Vd);
var ro = {}, Fo = {}, Ee = {}, zd = {};
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.default = o;
  function o(t) {
    var u, r = t.Symbol;
    if (typeof r == "function")
      if (r.observable)
        u = r.observable;
      else {
        u = r.for("https://github.com/benlesh/symbol-observable");
        try {
          r.observable = u;
        } catch {
        }
      }
    else
      u = "@@observable";
    return u;
  }
})(zd);
var Ul = zd, aa = Object.prototype.toString, Yd = function(e) {
  var o = aa.call(e), t = o === "[object Arguments]";
  return t || (t = o !== "[object Array]" && e !== null && typeof e == "object" && typeof e.length == "number" && e.length >= 0 && aa.call(e.callee) === "[object Function]"), t;
}, Zr, da;
function Dl() {
  if (da)
    return Zr;
  da = 1;
  var e;
  if (!Object.keys) {
    var o = Object.prototype.hasOwnProperty, t = Object.prototype.toString, u = Yd, r = Object.prototype.propertyIsEnumerable, m = !r.call({ toString: null }, "toString"), f = r.call(function() {
    }, "prototype"), b = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], R = function(B) {
      var U = B.constructor;
      return U && U.prototype === B;
    }, T = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, V = function() {
      if (typeof window > "u")
        return !1;
      for (var B in window)
        try {
          if (!T["$" + B] && o.call(window, B) && window[B] !== null && typeof window[B] == "object")
            try {
              R(window[B]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    }(), D = function(B) {
      if (typeof window > "u" || !V)
        return R(B);
      try {
        return R(B);
      } catch {
        return !1;
      }
    };
    e = function(B) {
      var U = B !== null && typeof B == "object", C = t.call(B) === "[object Function]", l = u(B), S = U && t.call(B) === "[object String]", A = [];
      if (!U && !C && !l)
        throw new TypeError("Object.keys called on a non-object");
      var d = f && C;
      if (S && B.length > 0 && !o.call(B, 0))
        for (var p = 0; p < B.length; ++p)
          A.push(String(p));
      if (l && B.length > 0)
        for (var h = 0; h < B.length; ++h)
          A.push(String(h));
      else
        for (var x in B)
          !(d && x === "prototype") && o.call(B, x) && A.push(String(x));
      if (m)
        for (var _ = D(B), I = 0; I < b.length; ++I)
          !(_ && b[I] === "constructor") && o.call(B, b[I]) && A.push(b[I]);
      return A;
    };
  }
  return Zr = e, Zr;
}
var Ll = Array.prototype.slice, Bl = Yd, ca = Object.keys, wo = ca ? function(e) {
  return ca(e);
} : Dl(), ua = Object.keys;
wo.shim = function() {
  if (Object.keys) {
    var e = function() {
      var o = Object.keys(arguments);
      return o && o.length === arguments.length;
    }(1, 2);
    e || (Object.keys = function(o) {
      return Bl(o) ? ua(Ll.call(o)) : ua(o);
    });
  } else
    Object.keys = wo;
  return Object.keys || wo;
};
var Vl = wo, Ml = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var e = {}, o = Symbol("test"), t = Object(o);
  if (typeof o == "string" || Object.prototype.toString.call(o) !== "[object Symbol]" || Object.prototype.toString.call(t) !== "[object Symbol]")
    return !1;
  var u = 42;
  e[o] = u;
  for (o in e)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
    return !1;
  var r = Object.getOwnPropertySymbols(e);
  if (r.length !== 1 || r[0] !== o || !Object.prototype.propertyIsEnumerable.call(e, o))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var m = Object.getOwnPropertyDescriptor(e, o);
    if (m.value !== u || m.enumerable !== !0)
      return !1;
  }
  return !0;
}, la = typeof Symbol < "u" && Symbol, Hl = Ml, jl = function() {
  return typeof la != "function" || typeof Symbol != "function" || typeof la("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : Hl();
}, pa = {
  foo: {}
}, Wl = Object, ql = function() {
  return { __proto__: pa }.foo === pa.foo && !({ __proto__: null } instanceof Wl);
}, Zl = "Function.prototype.bind called on incompatible ", Qr = Array.prototype.slice, Ql = Object.prototype.toString, Fl = "[object Function]", Gl = function(e) {
  var o = this;
  if (typeof o != "function" || Ql.call(o) !== Fl)
    throw new TypeError(Zl + o);
  for (var t = Qr.call(arguments, 1), u, r = function() {
    if (this instanceof u) {
      var T = o.apply(
        this,
        t.concat(Qr.call(arguments))
      );
      return Object(T) === T ? T : this;
    } else
      return o.apply(
        e,
        t.concat(Qr.call(arguments))
      );
  }, m = Math.max(0, o.length - t.length), f = [], b = 0; b < m; b++)
    f.push("$" + b);
  if (u = Function("binder", "return function (" + f.join(",") + "){ return binder.apply(this,arguments); }")(r), o.prototype) {
    var R = function() {
    };
    R.prototype = o.prototype, u.prototype = new R(), R.prototype = null;
  }
  return u;
}, Kl = Gl, $d = Function.prototype.bind || Kl, zl = $d, Yl = zl.call(Function.call, Object.prototype.hasOwnProperty), pe, An = SyntaxError, Xd = Function, vn = TypeError, Fr = function(e) {
  try {
    return Xd('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, Kt = Object.getOwnPropertyDescriptor;
if (Kt)
  try {
    Kt({}, "");
  } catch {
    Kt = null;
  }
var Gr = function() {
  throw new vn();
}, $l = Kt ? function() {
  try {
    return arguments.callee, Gr;
  } catch {
    try {
      return Kt(arguments, "callee").get;
    } catch {
      return Gr;
    }
  }
}() : Gr, cn = jl(), Xl = ql(), Re = Object.getPrototypeOf || (Xl ? function(e) {
  return e.__proto__;
} : null), mn = {}, ep = typeof Uint8Array > "u" || !Re ? pe : Re(Uint8Array), zt = {
  "%AggregateError%": typeof AggregateError > "u" ? pe : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? pe : ArrayBuffer,
  "%ArrayIteratorPrototype%": cn && Re ? Re([][Symbol.iterator]()) : pe,
  "%AsyncFromSyncIteratorPrototype%": pe,
  "%AsyncFunction%": mn,
  "%AsyncGenerator%": mn,
  "%AsyncGeneratorFunction%": mn,
  "%AsyncIteratorPrototype%": mn,
  "%Atomics%": typeof Atomics > "u" ? pe : Atomics,
  "%BigInt%": typeof BigInt > "u" ? pe : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? pe : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? pe : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? pe : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? pe : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? pe : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? pe : FinalizationRegistry,
  "%Function%": Xd,
  "%GeneratorFunction%": mn,
  "%Int8Array%": typeof Int8Array > "u" ? pe : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? pe : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? pe : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": cn && Re ? Re(Re([][Symbol.iterator]())) : pe,
  "%JSON%": typeof JSON == "object" ? JSON : pe,
  "%Map%": typeof Map > "u" ? pe : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !cn || !Re ? pe : Re((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? pe : Promise,
  "%Proxy%": typeof Proxy > "u" ? pe : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? pe : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? pe : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !cn || !Re ? pe : Re((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? pe : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": cn && Re ? Re(""[Symbol.iterator]()) : pe,
  "%Symbol%": cn ? Symbol : pe,
  "%SyntaxError%": An,
  "%ThrowTypeError%": $l,
  "%TypedArray%": ep,
  "%TypeError%": vn,
  "%Uint8Array%": typeof Uint8Array > "u" ? pe : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? pe : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? pe : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? pe : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap > "u" ? pe : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? pe : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? pe : WeakSet
};
if (Re)
  try {
    null.error;
  } catch (e) {
    var tp = Re(Re(e));
    zt["%Error.prototype%"] = tp;
  }
var np = function e(o) {
  var t;
  if (o === "%AsyncFunction%")
    t = Fr("async function () {}");
  else if (o === "%GeneratorFunction%")
    t = Fr("function* () {}");
  else if (o === "%AsyncGeneratorFunction%")
    t = Fr("async function* () {}");
  else if (o === "%AsyncGenerator%") {
    var u = e("%AsyncGeneratorFunction%");
    u && (t = u.prototype);
  } else if (o === "%AsyncIteratorPrototype%") {
    var r = e("%AsyncGenerator%");
    r && Re && (t = Re(r.prototype));
  }
  return zt[o] = t, t;
}, fa = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, io = $d, xo = Yl, op = io.call(Function.call, Array.prototype.concat), rp = io.call(Function.apply, Array.prototype.splice), ma = io.call(Function.call, String.prototype.replace), _o = io.call(Function.call, String.prototype.slice), ip = io.call(Function.call, RegExp.prototype.exec), sp = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, ap = /\\(\\)?/g, dp = function(e) {
  var o = _o(e, 0, 1), t = _o(e, -1);
  if (o === "%" && t !== "%")
    throw new An("invalid intrinsic syntax, expected closing `%`");
  if (t === "%" && o !== "%")
    throw new An("invalid intrinsic syntax, expected opening `%`");
  var u = [];
  return ma(e, sp, function(r, m, f, b) {
    u[u.length] = f ? ma(b, ap, "$1") : m || r;
  }), u;
}, cp = function(e, o) {
  var t = e, u;
  if (xo(fa, t) && (u = fa[t], t = "%" + u[0] + "%"), xo(zt, t)) {
    var r = zt[t];
    if (r === mn && (r = np(t)), typeof r > "u" && !o)
      throw new vn("intrinsic " + e + " exists, but is not available. Please file an issue!");
    return {
      alias: u,
      name: t,
      value: r
    };
  }
  throw new An("intrinsic " + e + " does not exist!");
}, up = function(e, o) {
  if (typeof e != "string" || e.length === 0)
    throw new vn("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof o != "boolean")
    throw new vn('"allowMissing" argument must be a boolean');
  if (ip(/^%?[^%]*%?$/, e) === null)
    throw new An("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var t = dp(e), u = t.length > 0 ? t[0] : "", r = cp("%" + u + "%", o), m = r.name, f = r.value, b = !1, R = r.alias;
  R && (u = R[0], rp(t, op([0, 1], R)));
  for (var T = 1, V = !0; T < t.length; T += 1) {
    var D = t[T], B = _o(D, 0, 1), U = _o(D, -1);
    if ((B === '"' || B === "'" || B === "`" || U === '"' || U === "'" || U === "`") && B !== U)
      throw new An("property names with quotes must have matching quotes");
    if ((D === "constructor" || !V) && (b = !0), u += "." + D, m = "%" + u + "%", xo(zt, m))
      f = zt[m];
    else if (f != null) {
      if (!(D in f)) {
        if (!o)
          throw new vn("base intrinsic for " + e + " exists, but the property is not available.");
        return;
      }
      if (Kt && T + 1 >= t.length) {
        var C = Kt(f, D);
        V = !!C, V && "get" in C && !("originalValue" in C.get) ? f = C.get : f = f[D];
      } else
        V = xo(f, D), f = f[D];
      V && !b && (zt[m] = f);
    }
  }
  return f;
}, lp = up, Ni = lp("%Object.defineProperty%", !0), Ei = function() {
  if (Ni)
    try {
      return Ni({}, "a", { value: 1 }), !0;
    } catch {
      return !1;
    }
  return !1;
};
Ei.hasArrayLengthDefineBug = function() {
  if (!Ei())
    return null;
  try {
    return Ni([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var pp = Ei, fp = Vl, mp = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", gp = Object.prototype.toString, hp = Array.prototype.concat, ec = Object.defineProperty, vp = function(e) {
  return typeof e == "function" && gp.call(e) === "[object Function]";
}, yp = pp(), tc = ec && yp, Sp = function(e, o, t, u) {
  if (o in e) {
    if (u === !0) {
      if (e[o] === t)
        return;
    } else if (!vp(u) || !u())
      return;
  }
  tc ? ec(e, o, {
    configurable: !0,
    enumerable: !1,
    value: t,
    writable: !0
  }) : e[o] = t;
}, nc = function(e, o) {
  var t = arguments.length > 2 ? arguments[2] : {}, u = fp(o);
  mp && (u = hp.call(u, Object.getOwnPropertySymbols(o)));
  for (var r = 0; r < u.length; r += 1)
    Sp(e, u[r], o[u[r]], t[u[r]]);
};
nc.supportsDescriptors = !!tc;
var oc = nc, No = { exports: {} };
typeof self < "u" ? No.exports = self : typeof window < "u" ? No.exports = window : No.exports = Function("return this")();
var rc = No.exports, bp = rc, ic = function() {
  return typeof Q != "object" || !Q || Q.Math !== Math || Q.Array !== Array ? bp : Q;
}, Op = oc, kp = ic, Pp = function() {
  var e = kp();
  if (Op.supportsDescriptors) {
    var o = Object.getOwnPropertyDescriptor(e, "globalThis");
    (!o || o.configurable && (o.enumerable || !o.writable || globalThis !== e)) && Object.defineProperty(e, "globalThis", {
      configurable: !0,
      enumerable: !1,
      value: e,
      writable: !0
    });
  } else
    (typeof globalThis != "object" || globalThis !== e) && (e.globalThis = e);
  return e;
}, Rp = oc, Ap = rc, sc = ic, wp = Pp, Np = sc(), ac = function() {
  return Np;
};
Rp(ac, {
  getPolyfill: sc,
  implementation: Ap,
  shim: wp
});
var Ep = ac, Tp = Q && Q.__extends || function() {
  var e = function(o, t) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(u, r) {
      u.__proto__ = r;
    } || function(u, r) {
      for (var m in r)
        r.hasOwnProperty(m) && (u[m] = r[m]);
    }, e(o, t);
  };
  return function(o, t) {
    e(o, t);
    function u() {
      this.constructor = o;
    }
    o.prototype = t === null ? Object.create(t) : (u.prototype = t.prototype, new u());
  };
}();
Object.defineProperty(Ee, "__esModule", { value: !0 });
Ee.NO_IL = Ee.NO = Ee.MemoryStream = Ee.Stream = void 0;
var Cp = Ul, Ip = Ep, po = Cp.default(Ip.getPolyfill()), te = {};
Ee.NO = te;
function xe() {
}
function Eo(e) {
  for (var o = e.length, t = Array(o), u = 0; u < o; ++u)
    t[u] = e[u];
  return t;
}
function xp(e, o) {
  return function(t) {
    return e(t) && o(t);
  };
}
function Qi(e, o, t) {
  try {
    return e.f(o);
  } catch (u) {
    return t._e(u), te;
  }
}
var Gt = {
  _n: xe,
  _e: xe,
  _c: xe
};
Ee.NO_IL = Gt;
function ga(e) {
  e._start = function(o) {
    o.next = o._n, o.error = o._e, o.complete = o._c, this.start(o);
  }, e._stop = e.stop;
}
var _p = (
  /** @class */
  function() {
    function e(o, t) {
      this._stream = o, this._listener = t;
    }
    return e.prototype.unsubscribe = function() {
      this._stream._remove(this._listener);
    }, e;
  }()
), Jp = (
  /** @class */
  function() {
    function e(o) {
      this._listener = o;
    }
    return e.prototype.next = function(o) {
      this._listener._n(o);
    }, e.prototype.error = function(o) {
      this._listener._e(o);
    }, e.prototype.complete = function() {
      this._listener._c();
    }, e;
  }()
), Up = (
  /** @class */
  function() {
    function e(o) {
      this.type = "fromObservable", this.ins = o, this.active = !1;
    }
    return e.prototype._start = function(o) {
      this.out = o, this.active = !0, this._sub = this.ins.subscribe(new Jp(o)), this.active || this._sub.unsubscribe();
    }, e.prototype._stop = function() {
      this._sub && this._sub.unsubscribe(), this.active = !1;
    }, e;
  }()
), Dp = (
  /** @class */
  function() {
    function e(o) {
      this.type = "merge", this.insArr = o, this.out = te, this.ac = 0;
    }
    return e.prototype._start = function(o) {
      this.out = o;
      var t = this.insArr, u = t.length;
      this.ac = u;
      for (var r = 0; r < u; r++)
        t[r]._add(this);
    }, e.prototype._stop = function() {
      for (var o = this.insArr, t = o.length, u = 0; u < t; u++)
        o[u]._remove(this);
      this.out = te;
    }, e.prototype._n = function(o) {
      var t = this.out;
      t !== te && t._n(o);
    }, e.prototype._e = function(o) {
      var t = this.out;
      t !== te && t._e(o);
    }, e.prototype._c = function() {
      if (--this.ac <= 0) {
        var o = this.out;
        if (o === te)
          return;
        o._c();
      }
    }, e;
  }()
), Lp = (
  /** @class */
  function() {
    function e(o, t, u) {
      this.i = o, this.out = t, this.p = u, u.ils.push(this);
    }
    return e.prototype._n = function(o) {
      var t = this.p, u = this.out;
      if (u !== te && t.up(o, this.i)) {
        var r = Eo(t.vals);
        u._n(r);
      }
    }, e.prototype._e = function(o) {
      var t = this.out;
      t !== te && t._e(o);
    }, e.prototype._c = function() {
      var o = this.p;
      o.out !== te && --o.Nc === 0 && o.out._c();
    }, e;
  }()
), Bp = (
  /** @class */
  function() {
    function e(o) {
      this.type = "combine", this.insArr = o, this.out = te, this.ils = [], this.Nc = this.Nn = 0, this.vals = [];
    }
    return e.prototype.up = function(o, t) {
      var u = this.vals[t], r = this.Nn ? u === te ? --this.Nn : this.Nn : 0;
      return this.vals[t] = o, r === 0;
    }, e.prototype._start = function(o) {
      this.out = o;
      var t = this.insArr, u = this.Nc = this.Nn = t.length, r = this.vals = new Array(u);
      if (u === 0)
        o._n([]), o._c();
      else
        for (var m = 0; m < u; m++)
          r[m] = te, t[m]._add(new Lp(m, o, this));
    }, e.prototype._stop = function() {
      for (var o = this.insArr, t = o.length, u = this.ils, r = 0; r < t; r++)
        o[r]._remove(u[r]);
      this.out = te, this.ils = [], this.vals = [];
    }, e;
  }()
), Vp = (
  /** @class */
  function() {
    function e(o) {
      this.type = "fromArray", this.a = o;
    }
    return e.prototype._start = function(o) {
      for (var t = this.a, u = 0, r = t.length; u < r; u++)
        o._n(t[u]);
      o._c();
    }, e.prototype._stop = function() {
    }, e;
  }()
), Mp = (
  /** @class */
  function() {
    function e(o) {
      this.type = "fromPromise", this.on = !1, this.p = o;
    }
    return e.prototype._start = function(o) {
      var t = this;
      this.on = !0, this.p.then(function(u) {
        t.on && (o._n(u), o._c());
      }, function(u) {
        o._e(u);
      }).then(xe, function(u) {
        setTimeout(function() {
          throw u;
        });
      });
    }, e.prototype._stop = function() {
      this.on = !1;
    }, e;
  }()
), Hp = (
  /** @class */
  function() {
    function e(o) {
      this.type = "periodic", this.period = o, this.intervalID = -1, this.i = 0;
    }
    return e.prototype._start = function(o) {
      var t = this;
      function u() {
        o._n(t.i++);
      }
      this.intervalID = setInterval(u, this.period);
    }, e.prototype._stop = function() {
      this.intervalID !== -1 && clearInterval(this.intervalID), this.intervalID = -1, this.i = 0;
    }, e;
  }()
), jp = (
  /** @class */
  function() {
    function e(o, t) {
      this.type = "debug", this.ins = o, this.out = te, this.s = xe, this.l = "", typeof t == "string" ? this.l = t : typeof t == "function" && (this.s = t);
    }
    return e.prototype._start = function(o) {
      this.out = o, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = te;
    }, e.prototype._n = function(o) {
      var t = this.out;
      if (t !== te) {
        var u = this.s, r = this.l;
        if (u !== xe)
          try {
            u(o);
          } catch (m) {
            t._e(m);
          }
        else
          r ? console.log(r + ":", o) : console.log(o);
        t._n(o);
      }
    }, e.prototype._e = function(o) {
      var t = this.out;
      t !== te && t._e(o);
    }, e.prototype._c = function() {
      var o = this.out;
      o !== te && o._c();
    }, e;
  }()
), Wp = (
  /** @class */
  function() {
    function e(o, t) {
      this.type = "drop", this.ins = t, this.out = te, this.max = o, this.dropped = 0;
    }
    return e.prototype._start = function(o) {
      this.out = o, this.dropped = 0, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = te;
    }, e.prototype._n = function(o) {
      var t = this.out;
      t !== te && this.dropped++ >= this.max && t._n(o);
    }, e.prototype._e = function(o) {
      var t = this.out;
      t !== te && t._e(o);
    }, e.prototype._c = function() {
      var o = this.out;
      o !== te && o._c();
    }, e;
  }()
), qp = (
  /** @class */
  function() {
    function e(o, t) {
      this.out = o, this.op = t;
    }
    return e.prototype._n = function() {
      this.op.end();
    }, e.prototype._e = function(o) {
      this.out._e(o);
    }, e.prototype._c = function() {
      this.op.end();
    }, e;
  }()
), Zp = (
  /** @class */
  function() {
    function e(o, t) {
      this.type = "endWhen", this.ins = t, this.out = te, this.o = o, this.oil = Gt;
    }
    return e.prototype._start = function(o) {
      this.out = o, this.o._add(this.oil = new qp(o, this)), this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.o._remove(this.oil), this.out = te, this.oil = Gt;
    }, e.prototype.end = function() {
      var o = this.out;
      o !== te && o._c();
    }, e.prototype._n = function(o) {
      var t = this.out;
      t !== te && t._n(o);
    }, e.prototype._e = function(o) {
      var t = this.out;
      t !== te && t._e(o);
    }, e.prototype._c = function() {
      this.end();
    }, e;
  }()
), Kr = (
  /** @class */
  function() {
    function e(o, t) {
      this.type = "filter", this.ins = t, this.out = te, this.f = o;
    }
    return e.prototype._start = function(o) {
      this.out = o, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = te;
    }, e.prototype._n = function(o) {
      var t = this.out;
      if (t !== te) {
        var u = Qi(this, o, t);
        u === te || !u || t._n(o);
      }
    }, e.prototype._e = function(o) {
      var t = this.out;
      t !== te && t._e(o);
    }, e.prototype._c = function() {
      var o = this.out;
      o !== te && o._c();
    }, e;
  }()
), Qp = (
  /** @class */
  function() {
    function e(o, t) {
      this.out = o, this.op = t;
    }
    return e.prototype._n = function(o) {
      this.out._n(o);
    }, e.prototype._e = function(o) {
      this.out._e(o);
    }, e.prototype._c = function() {
      this.op.inner = te, this.op.less();
    }, e;
  }()
), Fp = (
  /** @class */
  function() {
    function e(o) {
      this.type = "flatten", this.ins = o, this.out = te, this.open = !0, this.inner = te, this.il = Gt;
    }
    return e.prototype._start = function(o) {
      this.out = o, this.open = !0, this.inner = te, this.il = Gt, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.inner !== te && this.inner._remove(this.il), this.out = te, this.open = !0, this.inner = te, this.il = Gt;
    }, e.prototype.less = function() {
      var o = this.out;
      o !== te && !this.open && this.inner === te && o._c();
    }, e.prototype._n = function(o) {
      var t = this.out;
      if (t !== te) {
        var u = this, r = u.inner, m = u.il;
        r !== te && m !== Gt && r._remove(m), (this.inner = o)._add(this.il = new Qp(t, this));
      }
    }, e.prototype._e = function(o) {
      var t = this.out;
      t !== te && t._e(o);
    }, e.prototype._c = function() {
      this.open = !1, this.less();
    }, e;
  }()
), Gp = (
  /** @class */
  function() {
    function e(o, t, u) {
      var r = this;
      this.type = "fold", this.ins = u, this.out = te, this.f = function(m) {
        return o(r.acc, m);
      }, this.acc = this.seed = t;
    }
    return e.prototype._start = function(o) {
      this.out = o, this.acc = this.seed, o._n(this.acc), this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = te, this.acc = this.seed;
    }, e.prototype._n = function(o) {
      var t = this.out;
      if (t !== te) {
        var u = Qi(this, o, t);
        u !== te && t._n(this.acc = u);
      }
    }, e.prototype._e = function(o) {
      var t = this.out;
      t !== te && t._e(o);
    }, e.prototype._c = function() {
      var o = this.out;
      o !== te && o._c();
    }, e;
  }()
), Kp = (
  /** @class */
  function() {
    function e(o) {
      this.type = "last", this.ins = o, this.out = te, this.has = !1, this.val = te;
    }
    return e.prototype._start = function(o) {
      this.out = o, this.has = !1, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = te, this.val = te;
    }, e.prototype._n = function(o) {
      this.has = !0, this.val = o;
    }, e.prototype._e = function(o) {
      var t = this.out;
      t !== te && t._e(o);
    }, e.prototype._c = function() {
      var o = this.out;
      o !== te && (this.has ? (o._n(this.val), o._c()) : o._e(new Error("last() failed because input stream completed")));
    }, e;
  }()
), zp = (
  /** @class */
  function() {
    function e(o, t) {
      this.type = "map", this.ins = t, this.out = te, this.f = o;
    }
    return e.prototype._start = function(o) {
      this.out = o, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = te;
    }, e.prototype._n = function(o) {
      var t = this.out;
      if (t !== te) {
        var u = Qi(this, o, t);
        u !== te && t._n(u);
      }
    }, e.prototype._e = function(o) {
      var t = this.out;
      t !== te && t._e(o);
    }, e.prototype._c = function() {
      var o = this.out;
      o !== te && o._c();
    }, e;
  }()
), Yp = (
  /** @class */
  function() {
    function e(o) {
      this.type = "remember", this.ins = o, this.out = te;
    }
    return e.prototype._start = function(o) {
      this.out = o, this.ins._add(o);
    }, e.prototype._stop = function() {
      this.ins._remove(this.out), this.out = te;
    }, e;
  }()
), $p = (
  /** @class */
  function() {
    function e(o, t) {
      this.type = "replaceError", this.ins = t, this.out = te, this.f = o;
    }
    return e.prototype._start = function(o) {
      this.out = o, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = te;
    }, e.prototype._n = function(o) {
      var t = this.out;
      t !== te && t._n(o);
    }, e.prototype._e = function(o) {
      var t = this.out;
      if (t !== te)
        try {
          this.ins._remove(this), (this.ins = this.f(o))._add(this);
        } catch (u) {
          t._e(u);
        }
    }, e.prototype._c = function() {
      var o = this.out;
      o !== te && o._c();
    }, e;
  }()
), Xp = (
  /** @class */
  function() {
    function e(o, t) {
      this.type = "startWith", this.ins = o, this.out = te, this.val = t;
    }
    return e.prototype._start = function(o) {
      this.out = o, this.out._n(this.val), this.ins._add(o);
    }, e.prototype._stop = function() {
      this.ins._remove(this.out), this.out = te;
    }, e;
  }()
), ef = (
  /** @class */
  function() {
    function e(o, t) {
      this.type = "take", this.ins = t, this.out = te, this.max = o, this.taken = 0;
    }
    return e.prototype._start = function(o) {
      this.out = o, this.taken = 0, this.max <= 0 ? o._c() : this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = te;
    }, e.prototype._n = function(o) {
      var t = this.out;
      if (t !== te) {
        var u = ++this.taken;
        u < this.max ? t._n(o) : u === this.max && (t._n(o), t._c());
      }
    }, e.prototype._e = function(o) {
      var t = this.out;
      t !== te && t._e(o);
    }, e.prototype._c = function() {
      var o = this.out;
      o !== te && o._c();
    }, e;
  }()
), Fi = (
  /** @class */
  function() {
    function e(o) {
      this._prod = o || te, this._ils = [], this._stopID = te, this._dl = te, this._d = !1, this._target = null, this._err = te;
    }
    return e.prototype._n = function(o) {
      var t = this._ils, u = t.length;
      if (this._d && this._dl._n(o), u == 1)
        t[0]._n(o);
      else {
        if (u == 0)
          return;
        for (var r = Eo(t), m = 0; m < u; m++)
          r[m]._n(o);
      }
    }, e.prototype._e = function(o) {
      if (this._err === te) {
        this._err = o;
        var t = this._ils, u = t.length;
        if (this._x(), this._d && this._dl._e(o), u == 1)
          t[0]._e(o);
        else {
          if (u == 0)
            return;
          for (var r = Eo(t), m = 0; m < u; m++)
            r[m]._e(o);
        }
        if (!this._d && u == 0)
          throw this._err;
      }
    }, e.prototype._c = function() {
      var o = this._ils, t = o.length;
      if (this._x(), this._d && this._dl._c(), t == 1)
        o[0]._c();
      else {
        if (t == 0)
          return;
        for (var u = Eo(o), r = 0; r < t; r++)
          u[r]._c();
      }
    }, e.prototype._x = function() {
      this._ils.length !== 0 && (this._prod !== te && this._prod._stop(), this._err = te, this._ils = []);
    }, e.prototype._stopNow = function() {
      this._prod._stop(), this._err = te, this._stopID = te;
    }, e.prototype._add = function(o) {
      var t = this._target;
      if (t)
        return t._add(o);
      var u = this._ils;
      if (u.push(o), !(u.length > 1))
        if (this._stopID !== te)
          clearTimeout(this._stopID), this._stopID = te;
        else {
          var r = this._prod;
          r !== te && r._start(this);
        }
    }, e.prototype._remove = function(o) {
      var t = this, u = this._target;
      if (u)
        return u._remove(o);
      var r = this._ils, m = r.indexOf(o);
      m > -1 && (r.splice(m, 1), this._prod !== te && r.length <= 0 ? (this._err = te, this._stopID = setTimeout(function() {
        return t._stopNow();
      })) : r.length === 1 && this._pruneCycles());
    }, e.prototype._pruneCycles = function() {
      this._hasNoSinks(this, []) && this._remove(this._ils[0]);
    }, e.prototype._hasNoSinks = function(o, t) {
      if (t.indexOf(o) !== -1 || o.out === this)
        return !0;
      if (o.out && o.out !== te)
        return this._hasNoSinks(o.out, t.concat(o));
      if (o._ils) {
        for (var u = 0, r = o._ils.length; u < r; u++)
          if (!this._hasNoSinks(o._ils[u], t.concat(o)))
            return !1;
        return !0;
      } else
        return !1;
    }, e.prototype.ctor = function() {
      return this instanceof xt ? xt : e;
    }, e.prototype.addListener = function(o) {
      o._n = o.next || xe, o._e = o.error || xe, o._c = o.complete || xe, this._add(o);
    }, e.prototype.removeListener = function(o) {
      this._remove(o);
    }, e.prototype.subscribe = function(o) {
      return this.addListener(o), new _p(this, o);
    }, e.prototype[po] = function() {
      return this;
    }, e.create = function(o) {
      if (o) {
        if (typeof o.start != "function" || typeof o.stop != "function")
          throw new Error("producer requires both start and stop functions");
        ga(o);
      }
      return new e(o);
    }, e.createWithMemory = function(o) {
      return o && ga(o), new xt(o);
    }, e.never = function() {
      return new e({ _start: xe, _stop: xe });
    }, e.empty = function() {
      return new e({
        _start: function(o) {
          o._c();
        },
        _stop: xe
      });
    }, e.throw = function(o) {
      return new e({
        _start: function(t) {
          t._e(o);
        },
        _stop: xe
      });
    }, e.from = function(o) {
      if (typeof o[po] == "function")
        return e.fromObservable(o);
      if (typeof o.then == "function")
        return e.fromPromise(o);
      if (Array.isArray(o))
        return e.fromArray(o);
      throw new TypeError("Type of input to from() must be an Array, Promise, or Observable");
    }, e.of = function() {
      for (var o = [], t = 0; t < arguments.length; t++)
        o[t] = arguments[t];
      return e.fromArray(o);
    }, e.fromArray = function(o) {
      return new e(new Vp(o));
    }, e.fromPromise = function(o) {
      return new e(new Mp(o));
    }, e.fromObservable = function(o) {
      if (o.endWhen !== void 0)
        return o;
      var t = typeof o[po] == "function" ? o[po]() : o;
      return new e(new Up(t));
    }, e.periodic = function(o) {
      return new e(new Hp(o));
    }, e.prototype._map = function(o) {
      return new (this.ctor())(new zp(o, this));
    }, e.prototype.map = function(o) {
      return this._map(o);
    }, e.prototype.mapTo = function(o) {
      var t = this.map(function() {
        return o;
      }), u = t._prod;
      return u.type = "mapTo", t;
    }, e.prototype.filter = function(o) {
      var t = this._prod;
      return t instanceof Kr ? new e(new Kr(xp(t.f, o), t.ins)) : new e(new Kr(o, this));
    }, e.prototype.take = function(o) {
      return new (this.ctor())(new ef(o, this));
    }, e.prototype.drop = function(o) {
      return new e(new Wp(o, this));
    }, e.prototype.last = function() {
      return new e(new Kp(this));
    }, e.prototype.startWith = function(o) {
      return new xt(new Xp(this, o));
    }, e.prototype.endWhen = function(o) {
      return new (this.ctor())(new Zp(o, this));
    }, e.prototype.fold = function(o, t) {
      return new xt(new Gp(o, t, this));
    }, e.prototype.replaceError = function(o) {
      return new (this.ctor())(new $p(o, this));
    }, e.prototype.flatten = function() {
      return new e(new Fp(this));
    }, e.prototype.compose = function(o) {
      return o(this);
    }, e.prototype.remember = function() {
      return new xt(new Yp(this));
    }, e.prototype.debug = function(o) {
      return new (this.ctor())(new jp(this, o));
    }, e.prototype.imitate = function(o) {
      if (o instanceof xt)
        throw new Error("A MemoryStream was given to imitate(), but it only supports a Stream. Read more about this restriction here: https://github.com/staltz/xstream#faq");
      this._target = o;
      for (var t = this._ils, u = t.length, r = 0; r < u; r++)
        o._add(t[r]);
      this._ils = [];
    }, e.prototype.shamefullySendNext = function(o) {
      this._n(o);
    }, e.prototype.shamefullySendError = function(o) {
      this._e(o);
    }, e.prototype.shamefullySendComplete = function() {
      this._c();
    }, e.prototype.setDebugListener = function(o) {
      o ? (this._d = !0, o._n = o.next || xe, o._e = o.error || xe, o._c = o.complete || xe, this._dl = o) : (this._d = !1, this._dl = te);
    }, e.merge = function() {
      for (var o = [], t = 0; t < arguments.length; t++)
        o[t] = arguments[t];
      return new e(new Dp(o));
    }, e.combine = function() {
      for (var o = [], t = 0; t < arguments.length; t++)
        o[t] = arguments[t];
      return new e(new Bp(o));
    }, e;
  }()
);
Ee.Stream = Fi;
var xt = (
  /** @class */
  function(e) {
    Tp(o, e);
    function o(t) {
      var u = e.call(this, t) || this;
      return u._has = !1, u;
    }
    return o.prototype._n = function(t) {
      this._v = t, this._has = !0, e.prototype._n.call(this, t);
    }, o.prototype._add = function(t) {
      var u = this._target;
      if (u)
        return u._add(t);
      var r = this._ils;
      if (r.push(t), r.length > 1) {
        this._has && t._n(this._v);
        return;
      }
      if (this._stopID !== te)
        this._has && t._n(this._v), clearTimeout(this._stopID), this._stopID = te;
      else if (this._has)
        t._n(this._v);
      else {
        var m = this._prod;
        m !== te && m._start(this);
      }
    }, o.prototype._stopNow = function() {
      this._has = !1, e.prototype._stopNow.call(this);
    }, o.prototype._x = function() {
      this._has = !1, e.prototype._x.call(this);
    }, o.prototype.map = function(t) {
      return this._map(t);
    }, o.prototype.mapTo = function(t) {
      return e.prototype.mapTo.call(this, t);
    }, o.prototype.take = function(t) {
      return e.prototype.take.call(this, t);
    }, o.prototype.endWhen = function(t) {
      return e.prototype.endWhen.call(this, t);
    }, o.prototype.replaceError = function(t) {
      return e.prototype.replaceError.call(this, t);
    }, o.prototype.remember = function() {
      return this;
    }, o.prototype.debug = function(t) {
      return e.prototype.debug.call(this, t);
    }, o;
  }(Fi)
);
Ee.MemoryStream = xt;
var tf = Fi;
Ee.default = tf;
Object.defineProperty(Fo, "__esModule", { value: !0 });
Fo.concat = void 0;
const nf = Ee;
function of(...e) {
  const o = new Array(), t = new Array(), u = /* @__PURE__ */ new Set();
  let r = 0;
  function m() {
    for (; o.length > 0; )
      o.shift().unsubscribe();
    t.length = 0, u.clear(), r = 0;
  }
  const f = {
    start: (b) => {
      e.forEach((V) => t.push([]));
      function R(V) {
        for (; ; ) {
          const D = t[V].shift();
          if (D === void 0)
            return;
          b.next(D);
        }
      }
      function T() {
        return r >= e.length;
      }
      if (T()) {
        b.complete();
        return;
      }
      e.forEach((V, D) => {
        o.push(V.subscribe({
          next: (B) => {
            D === r ? b.next(B) : t[D].push(B);
          },
          complete: () => {
            for (u.add(D); u.has(r); )
              R(r), r++;
            T() ? b.complete() : R(r);
          },
          error: (B) => {
            b.error(B), m();
          }
        }));
      });
    },
    stop: () => {
      m();
    }
  };
  return nf.Stream.create(f);
}
Fo.concat = of;
var Go = {};
Object.defineProperty(Go, "__esModule", { value: !0 });
Go.DefaultValueProducer = void 0;
class rf {
  get value() {
    return this.internalValue;
  }
  constructor(o, t) {
    this.callbacks = t, this.internalValue = o;
  }
  /**
   * Update the current value.
   *
   * If producer is active (i.e. someone is listening), this emits an event.
   * If not, just the current value is updated.
   */
  update(o) {
    this.internalValue = o, this.listener && this.listener.next(o);
  }
  /**
   * Produce an error
   */
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  error(o) {
    this.listener && this.listener.error(o);
  }
  /**
   * Called by the stream. Do not call this directly.
   */
  start(o) {
    this.listener = o, o.next(this.internalValue), this.callbacks && this.callbacks.onStarted();
  }
  /**
   * Called by the stream. Do not call this directly.
   */
  stop() {
    this.callbacks && this.callbacks.onStop(), this.listener = void 0;
  }
}
Go.DefaultValueProducer = rf;
var Ko = {};
Object.defineProperty(Ko, "__esModule", { value: !0 });
Ko.dropDuplicates = void 0;
function sf(e) {
  return (o) => {
    const t = /* @__PURE__ */ new Set();
    return o.filter((u) => !t.has(e(u))).debug((u) => t.add(e(u)));
  };
}
Ko.dropDuplicates = sf;
var Dt = {};
Object.defineProperty(Dt, "__esModule", { value: !0 });
Dt.firstEvent = Dt.toListPromise = Dt.fromListPromise = void 0;
const af = Ee;
function df(e) {
  const o = {
    start: (t) => {
      e.then((u) => {
        for (const r of u)
          t.next(r);
        t.complete();
      }).catch((u) => t.error(u));
    },
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    stop: () => {
    }
  };
  return af.Stream.create(o);
}
Dt.fromListPromise = df;
async function dc(e, o) {
  return new Promise((t, u) => {
    if (o === 0) {
      t([]);
      return;
    }
    const r = new Array();
    e.take(o).subscribe({
      next: (m) => {
        r.push(m), r.length === o && t(r);
      },
      complete: () => {
        u(`Stream completed before all events could be collected. Collected ${r.length}, expected ${o}`);
      },
      error: (m) => u(m)
    });
  });
}
Dt.toListPromise = dc;
async function cf(e) {
  return (await dc(e, 1))[0];
}
Dt.firstEvent = cf;
var Ot = {};
Object.defineProperty(Ot, "__esModule", { value: !0 });
Ot.lastValue = Ot.asArray = Ot.countStream = Ot.Reducer = void 0;
class zo {
  constructor(o, t, u) {
    this.stream = o, this.reducer = t, this.state = u, this.completed = new Promise((r, m) => {
      const f = this.stream.subscribe({
        next: (b) => {
          this.state = this.reducer(this.state, b);
        },
        complete: () => {
          r(), f.unsubscribe();
        },
        error: (b) => {
          m(b), f.unsubscribe();
        }
      });
    });
  }
  // value returns current materialized state
  value() {
    return this.state;
  }
  // finished resolves on completed stream, rejects on stream error
  async finished() {
    return this.completed;
  }
}
Ot.Reducer = zo;
function uf(e, o) {
  return e + 1;
}
function lf(e) {
  return new zo(e, uf, 0);
}
Ot.countStream = lf;
function pf(e, o) {
  return [...e, o];
}
function ff(e) {
  return new zo(e, pf, []);
}
Ot.asArray = ff;
function mf(e, o) {
  return o;
}
function gf(e) {
  return new zo(e, mf, void 0);
}
Ot.lastValue = gf;
var Yo = {};
Object.defineProperty(Yo, "__esModule", { value: !0 });
Yo.ValueAndUpdates = void 0;
const hf = Ee;
class vf {
  get value() {
    return this.producer.value;
  }
  constructor(o) {
    this.producer = o, this.updates = hf.MemoryStream.createWithMemory(this.producer);
  }
  /**
   * Resolves as soon as search value is found.
   *
   * @param search either a value or a function that must return true when found
   * @returns the value of the update that caused the search match
   */
  async waitFor(o) {
    const t = typeof o == "function" ? o : (u) => u === o;
    return new Promise((u, r) => {
      const m = this.updates.subscribe({
        next: (f) => {
          t(f) && (u(f), setTimeout(() => m.unsubscribe(), 0));
        },
        complete: () => {
          m.unsubscribe(), r("Update stream completed without expected value");
        },
        error: (f) => {
          r(f);
        }
      });
    });
  }
}
Yo.ValueAndUpdates = vf;
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(R, T, V, D) {
    D === void 0 && (D = V);
    var B = Object.getOwnPropertyDescriptor(T, V);
    (!B || ("get" in B ? !T.__esModule : B.writable || B.configurable)) && (B = { enumerable: !0, get: function() {
      return T[V];
    } }), Object.defineProperty(R, D, B);
  } : function(R, T, V, D) {
    D === void 0 && (D = V), R[D] = T[V];
  }), t = Q && Q.__exportStar || function(R, T) {
    for (var V in R)
      V !== "default" && !Object.prototype.hasOwnProperty.call(T, V) && o(T, R, V);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueAndUpdates = e.toListPromise = e.fromListPromise = e.firstEvent = e.dropDuplicates = e.DefaultValueProducer = e.concat = void 0;
  var u = Fo;
  Object.defineProperty(e, "concat", { enumerable: !0, get: function() {
    return u.concat;
  } });
  var r = Go;
  Object.defineProperty(e, "DefaultValueProducer", { enumerable: !0, get: function() {
    return r.DefaultValueProducer;
  } });
  var m = Ko;
  Object.defineProperty(e, "dropDuplicates", { enumerable: !0, get: function() {
    return m.dropDuplicates;
  } });
  var f = Dt;
  Object.defineProperty(e, "firstEvent", { enumerable: !0, get: function() {
    return f.firstEvent;
  } }), Object.defineProperty(e, "fromListPromise", { enumerable: !0, get: function() {
    return f.fromListPromise;
  } }), Object.defineProperty(e, "toListPromise", { enumerable: !0, get: function() {
    return f.toListPromise;
  } }), t(Ot, e);
  var b = Yo;
  Object.defineProperty(e, "ValueAndUpdates", { enumerable: !0, get: function() {
    return b.ValueAndUpdates;
  } });
})(ro);
Object.defineProperty(Wo, "__esModule", { value: !0 });
Wo.QueryClient = void 0;
const Qt = Vd, Ft = Be, yf = ro, We = ht;
function fo(e, o, t) {
  if (e.type !== o)
    throw new Error(`Op expected to be ${o}, got "${e.type}`);
  if (!(0, We.arrayContentEquals)(t, e.key))
    throw new Error(`Proven key different than queried key.
Query: ${(0, Ft.toHex)(t)}
Proven: ${(0, Ft.toHex)(e.key)}`);
  return Qt.ics23.CommitmentProof.decode(e.data);
}
class Gi {
  static withExtensions(o, ...t) {
    const u = new Gi(o), r = t.map((m) => m(u));
    for (const m of r) {
      (0, We.assert)((0, We.isNonNullObject)(m), "Extension must be a non-null object");
      for (const [f, b] of Object.entries(m)) {
        (0, We.assert)((0, We.isNonNullObject)(b), `Module must be a non-null object. Found type ${typeof b} for module "${f}".`);
        const R = u[f] || {};
        u[f] = {
          ...R,
          ...b
        };
      }
    }
    return u;
  }
  constructor(o) {
    this.tmClient = o;
  }
  /**
   * Queries the database store with a proof, which is then verified.
   *
   * Please note: the current implementation trusts block headers it gets from the PRC endpoint.
   */
  async queryStoreVerified(o, t, u) {
    const { height: r, proof: m, key: f, value: b } = await this.queryRawProof(o, t, u), R = fo(m.ops[0], "ics23:iavl", t), T = fo(m.ops[1], "ics23:simple", (0, Ft.toAscii)(o));
    (0, We.assert)(T.exist), (0, We.assert)(T.exist.value), !b || b.length === 0 ? ((0, We.assert)(R.nonexist), (0, Qt.verifyNonExistence)(R.nonexist, Qt.iavlSpec, T.exist.value, t)) : ((0, We.assert)(R.exist), (0, We.assert)(R.exist.value), (0, Qt.verifyExistence)(R.exist, Qt.iavlSpec, T.exist.value, t, b));
    const V = await this.getNextHeader(r);
    return (0, Qt.verifyExistence)(T.exist, Qt.tendermintSpec, V.appHash, (0, Ft.toAscii)(o), T.exist.value), { key: f, value: b, height: r };
  }
  async queryRawProof(o, t, u) {
    const { key: r, value: m, height: f, proof: b, code: R, log: T } = await this.tmClient.abciQuery({
      // we need the StoreKey for the module, not the module name
      // https://github.com/cosmos/cosmos-sdk/blob/8cab43c8120fec5200c3459cbf4a92017bb6f287/x/auth/types/keys.go#L12
      path: `/store/${o}/key`,
      data: t,
      prove: !0,
      height: u
    });
    if (R)
      throw new Error(`Query failed with (${R}): ${T}`);
    if (!(0, We.arrayContentEquals)(t, r))
      throw new Error(`Response key ${(0, Ft.toHex)(r)} doesn't match query key ${(0, Ft.toHex)(t)}`);
    if (!f)
      throw new Error("No query height returned");
    if (!b || b.ops.length !== 2)
      throw new Error(`Expected 2 proof ops, got ${(b == null ? void 0 : b.ops.length) ?? 0}. Are you using stargate?`);
    return fo(b.ops[0], "ics23:iavl", r), fo(b.ops[1], "ics23:simple", (0, Ft.toAscii)(o)), {
      key: r,
      value: m,
      height: f,
      // need to clone this: readonly input / writeable output
      proof: {
        ops: [...b.ops]
      }
    };
  }
  /**
   * Performs an ABCI query to Tendermint without requesting a proof.
   *
   * If the `desiredHeight` is set, a particular height is requested. Otherwise
   * the latest height is requested. The response contains the actual height of
   * the query.
   */
  async queryAbci(o, t, u) {
    const r = await this.tmClient.abciQuery({
      path: o,
      data: t,
      prove: !1,
      height: u
    });
    if (r.code)
      throw new Error(`Query failed with (${r.code}): ${r.log}`);
    if (!r.height)
      throw new Error("No query height returned");
    return {
      value: r.value,
      height: r.height
    };
  }
  // this must return the header for height+1
  // throws an error if height is 0 or undefined
  async getNextHeader(o) {
    if ((0, We.assertDefined)(o), o === 0)
      throw new Error("Query returned height 0, cannot prove it");
    const t = o + 1;
    let u, r;
    try {
      r = this.tmClient.subscribeNewBlockHeader();
    } catch {
    }
    if (r) {
      const m = await (0, yf.firstEvent)(r);
      m.height === t && (u = m);
    }
    for (; !u; ) {
      const m = (await this.tmClient.blockchain(o, t)).blockMetas.map((f) => f.header).find((f) => f.height === t);
      m ? u = m : await (0, We.sleep)(1e3);
    }
    return (0, We.assert)(u.height === t, "Got wrong header. This is a bug in the logic above."), u;
  }
}
Wo.QueryClient = Gi;
var nt = {}, Sf = Q && Q.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(nt, "__esModule", { value: !0 });
nt.decodeCosmosSdkDecFromProto = nt.longify = nt.createProtobufRpcClient = nt.createPagination = nt.toAccAddress = void 0;
const cc = Be, uc = Rt, bf = be, Of = Sf(Pt);
function kf(e) {
  return (0, cc.fromBech32)(e).data;
}
nt.toAccAddress = kf;
function Pf(e) {
  return e ? bf.PageRequest.fromPartial({ key: e }) : void 0;
}
nt.createPagination = Pf;
function Rf(e) {
  return {
    request: async (o, t, u) => {
      const r = `/${o}/${t}`;
      return (await e.queryAbci(r, u, void 0)).value;
    }
  };
}
nt.createProtobufRpcClient = Rf;
function Af(e) {
  const o = uc.Uint64.fromString(e.toString());
  return Of.default.fromBytesBE([...o.toBytesBigEndian()], !0);
}
nt.longify = Af;
function wf(e) {
  const o = typeof e == "string" ? e : (0, cc.fromAscii)(e);
  return uc.Decimal.fromAtomics(o, 18);
}
nt.decodeCosmosSdkDecFromProto = wf;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.longify = e.decodeCosmosSdkDecFromProto = e.createProtobufRpcClient = e.createPagination = e.QueryClient = void 0;
  var o = Wo;
  Object.defineProperty(e, "QueryClient", { enumerable: !0, get: function() {
    return o.QueryClient;
  } });
  var t = nt;
  Object.defineProperty(e, "createPagination", { enumerable: !0, get: function() {
    return t.createPagination;
  } }), Object.defineProperty(e, "createProtobufRpcClient", { enumerable: !0, get: function() {
    return t.createProtobufRpcClient;
  } }), Object.defineProperty(e, "decodeCosmosSdkDecFromProto", { enumerable: !0, get: function() {
    return t.decodeCosmosSdkDecFromProto;
  } }), Object.defineProperty(e, "longify", { enumerable: !0, get: function() {
    return t.longify;
  } });
})(Ve);
Object.defineProperty(jo, "__esModule", { value: !0 });
jo.setupAuthExtension = void 0;
const Nf = Bd, Ef = Ve;
function Tf(e) {
  const o = (0, Ef.createProtobufRpcClient)(e), t = new Nf.QueryClientImpl(o);
  return {
    auth: {
      account: async (u) => {
        const { account: r } = await t.Account({ address: u });
        return r ?? null;
      }
    }
  };
}
jo.setupAuthExtension = Tf;
var $o = {};
Object.defineProperty($o, "__esModule", { value: !0 });
$o.createAuthzAminoConverters = void 0;
function Cf() {
  return {
    // For Cosmos SDK < 0.46 the Amino JSON codec was broken on chain and thus inaccessible.
    // Now this can be implemented for 0.46+ chains, see
    // https://github.com/cosmos/cosmjs/issues/1092
    //
    // "/cosmos.authz.v1beta1.MsgGrant": IMPLEMENT ME,
    // "/cosmos.authz.v1beta1.MsgExec": IMPLEMENT ME,
    // "/cosmos.authz.v1beta1.MsgRevoke": IMPLEMENT ME,
  };
}
$o.createAuthzAminoConverters = Cf;
var Xo = {}, lc = {}, $e = {}, Ae = {}, If = Q && Q.__createBinding || (Object.create ? function(e, o, t, u) {
  u === void 0 && (u = t);
  var r = Object.getOwnPropertyDescriptor(o, t);
  (!r || ("get" in r ? !o.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return o[t];
  } }), Object.defineProperty(e, u, r);
} : function(e, o, t, u) {
  u === void 0 && (u = t), e[u] = o[t];
}), xf = Q && Q.__setModuleDefault || (Object.create ? function(e, o) {
  Object.defineProperty(e, "default", { enumerable: !0, value: o });
} : function(e, o) {
  e.default = o;
}), _f = Q && Q.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var o = {};
  if (e != null)
    for (var t in e)
      t !== "default" && Object.prototype.hasOwnProperty.call(e, t) && If(o, e, t);
  return xf(o, e), o;
};
Object.defineProperty(Ae, "__esModule", { value: !0 });
Ae.Timestamp = Ae.protobufPackage = void 0;
const _t = ie, zr = _f(re);
Ae.protobufPackage = "google.protobuf";
function ha() {
  return {
    seconds: _t.Long.ZERO,
    nanos: 0
  };
}
Ae.Timestamp = {
  encode(e, o = zr.Writer.create()) {
    return e.seconds.isZero() || o.uint32(8).int64(e.seconds), e.nanos !== 0 && o.uint32(16).int32(e.nanos), o;
  },
  decode(e, o) {
    const t = e instanceof zr.Reader ? e : new zr.Reader(e);
    let u = o === void 0 ? t.len : t.pos + o;
    const r = ha();
    for (; t.pos < u; ) {
      const m = t.uint32();
      switch (m >>> 3) {
        case 1:
          r.seconds = t.int64();
          break;
        case 2:
          r.nanos = t.int32();
          break;
        default:
          t.skipType(m & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      seconds: (0, _t.isSet)(e.seconds) ? _t.Long.fromValue(e.seconds) : _t.Long.ZERO,
      nanos: (0, _t.isSet)(e.nanos) ? Number(e.nanos) : 0
    };
  },
  toJSON(e) {
    const o = {};
    return e.seconds !== void 0 && (o.seconds = (e.seconds || _t.Long.ZERO).toString()), e.nanos !== void 0 && (o.nanos = Math.round(e.nanos)), o;
  },
  fromPartial(e) {
    const o = ha();
    return o.seconds = e.seconds !== void 0 && e.seconds !== null ? _t.Long.fromValue(e.seconds) : _t.Long.ZERO, o.nanos = e.nanos ?? 0, o;
  }
};
var Jf = Q && Q.__createBinding || (Object.create ? function(e, o, t, u) {
  u === void 0 && (u = t);
  var r = Object.getOwnPropertyDescriptor(o, t);
  (!r || ("get" in r ? !o.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return o[t];
  } }), Object.defineProperty(e, u, r);
} : function(e, o, t, u) {
  u === void 0 && (u = t), e[u] = o[t];
}), Uf = Q && Q.__setModuleDefault || (Object.create ? function(e, o) {
  Object.defineProperty(e, "default", { enumerable: !0, value: o });
} : function(e, o) {
  e.default = o;
}), Df = Q && Q.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var o = {};
  if (e != null)
    for (var t in e)
      t !== "default" && Object.prototype.hasOwnProperty.call(e, t) && Jf(o, e, t);
  return Uf(o, e), o;
};
Object.defineProperty($e, "__esModule", { value: !0 });
$e.GrantQueueItem = $e.GrantAuthorization = $e.Grant = $e.GenericAuthorization = $e.protobufPackage = void 0;
const St = ye, yn = Ae, ct = Df(re), lt = ie;
$e.protobufPackage = "cosmos.authz.v1beta1";
function va() {
  return {
    msg: ""
  };
}
$e.GenericAuthorization = {
  encode(e, o = ct.Writer.create()) {
    return e.msg !== "" && o.uint32(10).string(e.msg), o;
  },
  decode(e, o) {
    const t = e instanceof ct.Reader ? e : new ct.Reader(e);
    let u = o === void 0 ? t.len : t.pos + o;
    const r = va();
    for (; t.pos < u; ) {
      const m = t.uint32();
      switch (m >>> 3) {
        case 1:
          r.msg = t.string();
          break;
        default:
          t.skipType(m & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      msg: (0, lt.isSet)(e.msg) ? String(e.msg) : ""
    };
  },
  toJSON(e) {
    const o = {};
    return e.msg !== void 0 && (o.msg = e.msg), o;
  },
  fromPartial(e) {
    const o = va();
    return o.msg = e.msg ?? "", o;
  }
};
function ya() {
  return {
    authorization: void 0,
    expiration: void 0
  };
}
$e.Grant = {
  encode(e, o = ct.Writer.create()) {
    return e.authorization !== void 0 && St.Any.encode(e.authorization, o.uint32(10).fork()).ldelim(), e.expiration !== void 0 && yn.Timestamp.encode(e.expiration, o.uint32(18).fork()).ldelim(), o;
  },
  decode(e, o) {
    const t = e instanceof ct.Reader ? e : new ct.Reader(e);
    let u = o === void 0 ? t.len : t.pos + o;
    const r = ya();
    for (; t.pos < u; ) {
      const m = t.uint32();
      switch (m >>> 3) {
        case 1:
          r.authorization = St.Any.decode(t, t.uint32());
          break;
        case 2:
          r.expiration = yn.Timestamp.decode(t, t.uint32());
          break;
        default:
          t.skipType(m & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      authorization: (0, lt.isSet)(e.authorization) ? St.Any.fromJSON(e.authorization) : void 0,
      expiration: (0, lt.isSet)(e.expiration) ? (0, lt.fromJsonTimestamp)(e.expiration) : void 0
    };
  },
  toJSON(e) {
    const o = {};
    return e.authorization !== void 0 && (o.authorization = e.authorization ? St.Any.toJSON(e.authorization) : void 0), e.expiration !== void 0 && (o.expiration = (0, lt.fromTimestamp)(e.expiration).toISOString()), o;
  },
  fromPartial(e) {
    const o = ya();
    return o.authorization = e.authorization !== void 0 && e.authorization !== null ? St.Any.fromPartial(e.authorization) : void 0, o.expiration = e.expiration !== void 0 && e.expiration !== null ? yn.Timestamp.fromPartial(e.expiration) : void 0, o;
  }
};
function Sa() {
  return {
    granter: "",
    grantee: "",
    authorization: void 0,
    expiration: void 0
  };
}
$e.GrantAuthorization = {
  encode(e, o = ct.Writer.create()) {
    return e.granter !== "" && o.uint32(10).string(e.granter), e.grantee !== "" && o.uint32(18).string(e.grantee), e.authorization !== void 0 && St.Any.encode(e.authorization, o.uint32(26).fork()).ldelim(), e.expiration !== void 0 && yn.Timestamp.encode(e.expiration, o.uint32(34).fork()).ldelim(), o;
  },
  decode(e, o) {
    const t = e instanceof ct.Reader ? e : new ct.Reader(e);
    let u = o === void 0 ? t.len : t.pos + o;
    const r = Sa();
    for (; t.pos < u; ) {
      const m = t.uint32();
      switch (m >>> 3) {
        case 1:
          r.granter = t.string();
          break;
        case 2:
          r.grantee = t.string();
          break;
        case 3:
          r.authorization = St.Any.decode(t, t.uint32());
          break;
        case 4:
          r.expiration = yn.Timestamp.decode(t, t.uint32());
          break;
        default:
          t.skipType(m & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      granter: (0, lt.isSet)(e.granter) ? String(e.granter) : "",
      grantee: (0, lt.isSet)(e.grantee) ? String(e.grantee) : "",
      authorization: (0, lt.isSet)(e.authorization) ? St.Any.fromJSON(e.authorization) : void 0,
      expiration: (0, lt.isSet)(e.expiration) ? (0, lt.fromJsonTimestamp)(e.expiration) : void 0
    };
  },
  toJSON(e) {
    const o = {};
    return e.granter !== void 0 && (o.granter = e.granter), e.grantee !== void 0 && (o.grantee = e.grantee), e.authorization !== void 0 && (o.authorization = e.authorization ? St.Any.toJSON(e.authorization) : void 0), e.expiration !== void 0 && (o.expiration = (0, lt.fromTimestamp)(e.expiration).toISOString()), o;
  },
  fromPartial(e) {
    const o = Sa();
    return o.granter = e.granter ?? "", o.grantee = e.grantee ?? "", o.authorization = e.authorization !== void 0 && e.authorization !== null ? St.Any.fromPartial(e.authorization) : void 0, o.expiration = e.expiration !== void 0 && e.expiration !== null ? yn.Timestamp.fromPartial(e.expiration) : void 0, o;
  }
};
function ba() {
  return {
    msgTypeUrls: []
  };
}
$e.GrantQueueItem = {
  encode(e, o = ct.Writer.create()) {
    for (const t of e.msgTypeUrls)
      o.uint32(10).string(t);
    return o;
  },
  decode(e, o) {
    const t = e instanceof ct.Reader ? e : new ct.Reader(e);
    let u = o === void 0 ? t.len : t.pos + o;
    const r = ba();
    for (; t.pos < u; ) {
      const m = t.uint32();
      switch (m >>> 3) {
        case 1:
          r.msgTypeUrls.push(t.string());
          break;
        default:
          t.skipType(m & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      msgTypeUrls: Array.isArray(e == null ? void 0 : e.msgTypeUrls) ? e.msgTypeUrls.map((o) => String(o)) : []
    };
  },
  toJSON(e) {
    const o = {};
    return e.msgTypeUrls ? o.msgTypeUrls = e.msgTypeUrls.map((t) => t) : o.msgTypeUrls = [], o;
  },
  fromPartial(e) {
    var o;
    const t = ba();
    return t.msgTypeUrls = ((o = e.msgTypeUrls) == null ? void 0 : o.map((u) => u)) || [], t;
  }
};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(l, S, A, d) {
    d === void 0 && (d = A);
    var p = Object.getOwnPropertyDescriptor(S, A);
    (!p || ("get" in p ? !S.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return S[A];
    } }), Object.defineProperty(l, d, p);
  } : function(l, S, A, d) {
    d === void 0 && (d = A), l[d] = S[A];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(l, S) {
    Object.defineProperty(l, "default", { enumerable: !0, value: S });
  } : function(l, S) {
    l.default = S;
  }), u = Q && Q.__importStar || function(l) {
    if (l && l.__esModule)
      return l;
    var S = {};
    if (l != null)
      for (var A in l)
        A !== "default" && Object.prototype.hasOwnProperty.call(l, A) && o(S, l, A);
    return t(S, l), S;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgRevokeResponse = e.MsgRevoke = e.MsgGrantResponse = e.MsgExec = e.MsgExecResponse = e.MsgGrant = e.protobufPackage = void 0;
  const r = $e, m = ye, f = u(re), b = ie;
  e.protobufPackage = "cosmos.authz.v1beta1";
  function R() {
    return {
      granter: "",
      grantee: "",
      grant: void 0
    };
  }
  e.MsgGrant = {
    encode(l, S = f.Writer.create()) {
      return l.granter !== "" && S.uint32(10).string(l.granter), l.grantee !== "" && S.uint32(18).string(l.grantee), l.grant !== void 0 && r.Grant.encode(l.grant, S.uint32(26).fork()).ldelim(), S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = R();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.granter = A.string();
            break;
          case 2:
            p.grantee = A.string();
            break;
          case 3:
            p.grant = r.Grant.decode(A, A.uint32());
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        granter: (0, b.isSet)(l.granter) ? String(l.granter) : "",
        grantee: (0, b.isSet)(l.grantee) ? String(l.grantee) : "",
        grant: (0, b.isSet)(l.grant) ? r.Grant.fromJSON(l.grant) : void 0
      };
    },
    toJSON(l) {
      const S = {};
      return l.granter !== void 0 && (S.granter = l.granter), l.grantee !== void 0 && (S.grantee = l.grantee), l.grant !== void 0 && (S.grant = l.grant ? r.Grant.toJSON(l.grant) : void 0), S;
    },
    fromPartial(l) {
      const S = R();
      return S.granter = l.granter ?? "", S.grantee = l.grantee ?? "", S.grant = l.grant !== void 0 && l.grant !== null ? r.Grant.fromPartial(l.grant) : void 0, S;
    }
  };
  function T() {
    return {
      results: []
    };
  }
  e.MsgExecResponse = {
    encode(l, S = f.Writer.create()) {
      for (const A of l.results)
        S.uint32(10).bytes(A);
      return S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = T();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.results.push(A.bytes());
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        results: Array.isArray(l == null ? void 0 : l.results) ? l.results.map((S) => (0, b.bytesFromBase64)(S)) : []
      };
    },
    toJSON(l) {
      const S = {};
      return l.results ? S.results = l.results.map((A) => (0, b.base64FromBytes)(A !== void 0 ? A : new Uint8Array())) : S.results = [], S;
    },
    fromPartial(l) {
      var S;
      const A = T();
      return A.results = ((S = l.results) == null ? void 0 : S.map((d) => d)) || [], A;
    }
  };
  function V() {
    return {
      grantee: "",
      msgs: []
    };
  }
  e.MsgExec = {
    encode(l, S = f.Writer.create()) {
      l.grantee !== "" && S.uint32(10).string(l.grantee);
      for (const A of l.msgs)
        m.Any.encode(A, S.uint32(18).fork()).ldelim();
      return S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = V();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.grantee = A.string();
            break;
          case 2:
            p.msgs.push(m.Any.decode(A, A.uint32()));
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        grantee: (0, b.isSet)(l.grantee) ? String(l.grantee) : "",
        msgs: Array.isArray(l == null ? void 0 : l.msgs) ? l.msgs.map((S) => m.Any.fromJSON(S)) : []
      };
    },
    toJSON(l) {
      const S = {};
      return l.grantee !== void 0 && (S.grantee = l.grantee), l.msgs ? S.msgs = l.msgs.map((A) => A ? m.Any.toJSON(A) : void 0) : S.msgs = [], S;
    },
    fromPartial(l) {
      var S;
      const A = V();
      return A.grantee = l.grantee ?? "", A.msgs = ((S = l.msgs) == null ? void 0 : S.map((d) => m.Any.fromPartial(d))) || [], A;
    }
  };
  function D() {
    return {};
  }
  e.MsgGrantResponse = {
    encode(l, S = f.Writer.create()) {
      return S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = D();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {};
    },
    toJSON(l) {
      return {};
    },
    fromPartial(l) {
      return D();
    }
  };
  function B() {
    return {
      granter: "",
      grantee: "",
      msgTypeUrl: ""
    };
  }
  e.MsgRevoke = {
    encode(l, S = f.Writer.create()) {
      return l.granter !== "" && S.uint32(10).string(l.granter), l.grantee !== "" && S.uint32(18).string(l.grantee), l.msgTypeUrl !== "" && S.uint32(26).string(l.msgTypeUrl), S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = B();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.granter = A.string();
            break;
          case 2:
            p.grantee = A.string();
            break;
          case 3:
            p.msgTypeUrl = A.string();
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        granter: (0, b.isSet)(l.granter) ? String(l.granter) : "",
        grantee: (0, b.isSet)(l.grantee) ? String(l.grantee) : "",
        msgTypeUrl: (0, b.isSet)(l.msgTypeUrl) ? String(l.msgTypeUrl) : ""
      };
    },
    toJSON(l) {
      const S = {};
      return l.granter !== void 0 && (S.granter = l.granter), l.grantee !== void 0 && (S.grantee = l.grantee), l.msgTypeUrl !== void 0 && (S.msgTypeUrl = l.msgTypeUrl), S;
    },
    fromPartial(l) {
      const S = B();
      return S.granter = l.granter ?? "", S.grantee = l.grantee ?? "", S.msgTypeUrl = l.msgTypeUrl ?? "", S;
    }
  };
  function U() {
    return {};
  }
  e.MsgRevokeResponse = {
    encode(l, S = f.Writer.create()) {
      return S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = U();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {};
    },
    toJSON(l) {
      return {};
    },
    fromPartial(l) {
      return U();
    }
  };
  class C {
    constructor(S) {
      this.rpc = S, this.Grant = this.Grant.bind(this), this.Exec = this.Exec.bind(this), this.Revoke = this.Revoke.bind(this);
    }
    Grant(S) {
      const A = e.MsgGrant.encode(S).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Msg", "Grant", A).then((d) => e.MsgGrantResponse.decode(new f.Reader(d)));
    }
    Exec(S) {
      const A = e.MsgExec.encode(S).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Msg", "Exec", A).then((d) => e.MsgExecResponse.decode(new f.Reader(d)));
    }
    Revoke(S) {
      const A = e.MsgRevoke.encode(S).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Msg", "Revoke", A).then((d) => e.MsgRevokeResponse.decode(new f.Reader(d)));
    }
  }
  e.MsgClientImpl = C;
})(lc);
Object.defineProperty(Xo, "__esModule", { value: !0 });
Xo.authzTypes = void 0;
const Yr = lc;
Xo.authzTypes = [
  ["/cosmos.authz.v1beta1.MsgExec", Yr.MsgExec],
  ["/cosmos.authz.v1beta1.MsgGrant", Yr.MsgGrant],
  ["/cosmos.authz.v1beta1.MsgRevoke", Yr.MsgRevoke]
];
var er = {}, pc = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(l, S, A, d) {
    d === void 0 && (d = A);
    var p = Object.getOwnPropertyDescriptor(S, A);
    (!p || ("get" in p ? !S.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return S[A];
    } }), Object.defineProperty(l, d, p);
  } : function(l, S, A, d) {
    d === void 0 && (d = A), l[d] = S[A];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(l, S) {
    Object.defineProperty(l, "default", { enumerable: !0, value: S });
  } : function(l, S) {
    l.default = S;
  }), u = Q && Q.__importStar || function(l) {
    if (l && l.__esModule)
      return l;
    var S = {};
    if (l != null)
      for (var A in l)
        A !== "default" && Object.prototype.hasOwnProperty.call(l, A) && o(S, l, A);
    return t(S, l), S;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryGranteeGrantsResponse = e.QueryGranteeGrantsRequest = e.QueryGranterGrantsResponse = e.QueryGranterGrantsRequest = e.QueryGrantsResponse = e.QueryGrantsRequest = e.protobufPackage = void 0;
  const r = be, m = $e, f = u(re), b = ie;
  e.protobufPackage = "cosmos.authz.v1beta1";
  function R() {
    return {
      granter: "",
      grantee: "",
      msgTypeUrl: "",
      pagination: void 0
    };
  }
  e.QueryGrantsRequest = {
    encode(l, S = f.Writer.create()) {
      return l.granter !== "" && S.uint32(10).string(l.granter), l.grantee !== "" && S.uint32(18).string(l.grantee), l.msgTypeUrl !== "" && S.uint32(26).string(l.msgTypeUrl), l.pagination !== void 0 && r.PageRequest.encode(l.pagination, S.uint32(34).fork()).ldelim(), S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = R();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.granter = A.string();
            break;
          case 2:
            p.grantee = A.string();
            break;
          case 3:
            p.msgTypeUrl = A.string();
            break;
          case 4:
            p.pagination = r.PageRequest.decode(A, A.uint32());
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        granter: (0, b.isSet)(l.granter) ? String(l.granter) : "",
        grantee: (0, b.isSet)(l.grantee) ? String(l.grantee) : "",
        msgTypeUrl: (0, b.isSet)(l.msgTypeUrl) ? String(l.msgTypeUrl) : "",
        pagination: (0, b.isSet)(l.pagination) ? r.PageRequest.fromJSON(l.pagination) : void 0
      };
    },
    toJSON(l) {
      const S = {};
      return l.granter !== void 0 && (S.granter = l.granter), l.grantee !== void 0 && (S.grantee = l.grantee), l.msgTypeUrl !== void 0 && (S.msgTypeUrl = l.msgTypeUrl), l.pagination !== void 0 && (S.pagination = l.pagination ? r.PageRequest.toJSON(l.pagination) : void 0), S;
    },
    fromPartial(l) {
      const S = R();
      return S.granter = l.granter ?? "", S.grantee = l.grantee ?? "", S.msgTypeUrl = l.msgTypeUrl ?? "", S.pagination = l.pagination !== void 0 && l.pagination !== null ? r.PageRequest.fromPartial(l.pagination) : void 0, S;
    }
  };
  function T() {
    return {
      grants: [],
      pagination: void 0
    };
  }
  e.QueryGrantsResponse = {
    encode(l, S = f.Writer.create()) {
      for (const A of l.grants)
        m.Grant.encode(A, S.uint32(10).fork()).ldelim();
      return l.pagination !== void 0 && r.PageResponse.encode(l.pagination, S.uint32(18).fork()).ldelim(), S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = T();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.grants.push(m.Grant.decode(A, A.uint32()));
            break;
          case 2:
            p.pagination = r.PageResponse.decode(A, A.uint32());
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        grants: Array.isArray(l == null ? void 0 : l.grants) ? l.grants.map((S) => m.Grant.fromJSON(S)) : [],
        pagination: (0, b.isSet)(l.pagination) ? r.PageResponse.fromJSON(l.pagination) : void 0
      };
    },
    toJSON(l) {
      const S = {};
      return l.grants ? S.grants = l.grants.map((A) => A ? m.Grant.toJSON(A) : void 0) : S.grants = [], l.pagination !== void 0 && (S.pagination = l.pagination ? r.PageResponse.toJSON(l.pagination) : void 0), S;
    },
    fromPartial(l) {
      var S;
      const A = T();
      return A.grants = ((S = l.grants) == null ? void 0 : S.map((d) => m.Grant.fromPartial(d))) || [], A.pagination = l.pagination !== void 0 && l.pagination !== null ? r.PageResponse.fromPartial(l.pagination) : void 0, A;
    }
  };
  function V() {
    return {
      granter: "",
      pagination: void 0
    };
  }
  e.QueryGranterGrantsRequest = {
    encode(l, S = f.Writer.create()) {
      return l.granter !== "" && S.uint32(10).string(l.granter), l.pagination !== void 0 && r.PageRequest.encode(l.pagination, S.uint32(18).fork()).ldelim(), S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = V();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.granter = A.string();
            break;
          case 2:
            p.pagination = r.PageRequest.decode(A, A.uint32());
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        granter: (0, b.isSet)(l.granter) ? String(l.granter) : "",
        pagination: (0, b.isSet)(l.pagination) ? r.PageRequest.fromJSON(l.pagination) : void 0
      };
    },
    toJSON(l) {
      const S = {};
      return l.granter !== void 0 && (S.granter = l.granter), l.pagination !== void 0 && (S.pagination = l.pagination ? r.PageRequest.toJSON(l.pagination) : void 0), S;
    },
    fromPartial(l) {
      const S = V();
      return S.granter = l.granter ?? "", S.pagination = l.pagination !== void 0 && l.pagination !== null ? r.PageRequest.fromPartial(l.pagination) : void 0, S;
    }
  };
  function D() {
    return {
      grants: [],
      pagination: void 0
    };
  }
  e.QueryGranterGrantsResponse = {
    encode(l, S = f.Writer.create()) {
      for (const A of l.grants)
        m.GrantAuthorization.encode(A, S.uint32(10).fork()).ldelim();
      return l.pagination !== void 0 && r.PageResponse.encode(l.pagination, S.uint32(18).fork()).ldelim(), S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = D();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.grants.push(m.GrantAuthorization.decode(A, A.uint32()));
            break;
          case 2:
            p.pagination = r.PageResponse.decode(A, A.uint32());
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        grants: Array.isArray(l == null ? void 0 : l.grants) ? l.grants.map((S) => m.GrantAuthorization.fromJSON(S)) : [],
        pagination: (0, b.isSet)(l.pagination) ? r.PageResponse.fromJSON(l.pagination) : void 0
      };
    },
    toJSON(l) {
      const S = {};
      return l.grants ? S.grants = l.grants.map((A) => A ? m.GrantAuthorization.toJSON(A) : void 0) : S.grants = [], l.pagination !== void 0 && (S.pagination = l.pagination ? r.PageResponse.toJSON(l.pagination) : void 0), S;
    },
    fromPartial(l) {
      var S;
      const A = D();
      return A.grants = ((S = l.grants) == null ? void 0 : S.map((d) => m.GrantAuthorization.fromPartial(d))) || [], A.pagination = l.pagination !== void 0 && l.pagination !== null ? r.PageResponse.fromPartial(l.pagination) : void 0, A;
    }
  };
  function B() {
    return {
      grantee: "",
      pagination: void 0
    };
  }
  e.QueryGranteeGrantsRequest = {
    encode(l, S = f.Writer.create()) {
      return l.grantee !== "" && S.uint32(10).string(l.grantee), l.pagination !== void 0 && r.PageRequest.encode(l.pagination, S.uint32(18).fork()).ldelim(), S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = B();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.grantee = A.string();
            break;
          case 2:
            p.pagination = r.PageRequest.decode(A, A.uint32());
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        grantee: (0, b.isSet)(l.grantee) ? String(l.grantee) : "",
        pagination: (0, b.isSet)(l.pagination) ? r.PageRequest.fromJSON(l.pagination) : void 0
      };
    },
    toJSON(l) {
      const S = {};
      return l.grantee !== void 0 && (S.grantee = l.grantee), l.pagination !== void 0 && (S.pagination = l.pagination ? r.PageRequest.toJSON(l.pagination) : void 0), S;
    },
    fromPartial(l) {
      const S = B();
      return S.grantee = l.grantee ?? "", S.pagination = l.pagination !== void 0 && l.pagination !== null ? r.PageRequest.fromPartial(l.pagination) : void 0, S;
    }
  };
  function U() {
    return {
      grants: [],
      pagination: void 0
    };
  }
  e.QueryGranteeGrantsResponse = {
    encode(l, S = f.Writer.create()) {
      for (const A of l.grants)
        m.GrantAuthorization.encode(A, S.uint32(10).fork()).ldelim();
      return l.pagination !== void 0 && r.PageResponse.encode(l.pagination, S.uint32(18).fork()).ldelim(), S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = U();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.grants.push(m.GrantAuthorization.decode(A, A.uint32()));
            break;
          case 2:
            p.pagination = r.PageResponse.decode(A, A.uint32());
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        grants: Array.isArray(l == null ? void 0 : l.grants) ? l.grants.map((S) => m.GrantAuthorization.fromJSON(S)) : [],
        pagination: (0, b.isSet)(l.pagination) ? r.PageResponse.fromJSON(l.pagination) : void 0
      };
    },
    toJSON(l) {
      const S = {};
      return l.grants ? S.grants = l.grants.map((A) => A ? m.GrantAuthorization.toJSON(A) : void 0) : S.grants = [], l.pagination !== void 0 && (S.pagination = l.pagination ? r.PageResponse.toJSON(l.pagination) : void 0), S;
    },
    fromPartial(l) {
      var S;
      const A = U();
      return A.grants = ((S = l.grants) == null ? void 0 : S.map((d) => m.GrantAuthorization.fromPartial(d))) || [], A.pagination = l.pagination !== void 0 && l.pagination !== null ? r.PageResponse.fromPartial(l.pagination) : void 0, A;
    }
  };
  class C {
    constructor(S) {
      this.rpc = S, this.Grants = this.Grants.bind(this), this.GranterGrants = this.GranterGrants.bind(this), this.GranteeGrants = this.GranteeGrants.bind(this);
    }
    Grants(S) {
      const A = e.QueryGrantsRequest.encode(S).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Query", "Grants", A).then((d) => e.QueryGrantsResponse.decode(new f.Reader(d)));
    }
    GranterGrants(S) {
      const A = e.QueryGranterGrantsRequest.encode(S).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Query", "GranterGrants", A).then((d) => e.QueryGranterGrantsResponse.decode(new f.Reader(d)));
    }
    GranteeGrants(S) {
      const A = e.QueryGranteeGrantsRequest.encode(S).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Query", "GranteeGrants", A).then((d) => e.QueryGranteeGrantsResponse.decode(new f.Reader(d)));
    }
  }
  e.QueryClientImpl = C;
})(pc);
Object.defineProperty(er, "__esModule", { value: !0 });
er.setupAuthzExtension = void 0;
const Lf = pc, mo = Ve;
function Bf(e) {
  const o = (0, mo.createProtobufRpcClient)(e), t = new Lf.QueryClientImpl(o);
  return {
    authz: {
      grants: async (u, r, m, f) => await t.Grants({
        granter: u,
        grantee: r,
        msgTypeUrl: m,
        pagination: (0, mo.createPagination)(f)
      }),
      granteeGrants: async (u, r) => await t.GranteeGrants({
        grantee: u,
        pagination: (0, mo.createPagination)(r)
      }),
      granterGrants: async (u, r) => await t.GranterGrants({
        granter: u,
        pagination: (0, mo.createPagination)(r)
      })
    }
  };
}
er.setupAuthzExtension = Bf;
var Lt = {};
Object.defineProperty(Lt, "__esModule", { value: !0 });
Lt.createBankAminoConverters = Lt.isAminoMsgMultiSend = Lt.isAminoMsgSend = void 0;
function Vf(e) {
  return e.type === "cosmos-sdk/MsgSend";
}
Lt.isAminoMsgSend = Vf;
function Mf(e) {
  return e.type === "cosmos-sdk/MsgMultiSend";
}
Lt.isAminoMsgMultiSend = Mf;
function Hf() {
  return {
    "/cosmos.bank.v1beta1.MsgSend": {
      aminoType: "cosmos-sdk/MsgSend",
      toAmino: ({ fromAddress: e, toAddress: o, amount: t }) => ({
        from_address: e,
        to_address: o,
        amount: [...t]
      }),
      fromAmino: ({ from_address: e, to_address: o, amount: t }) => ({
        fromAddress: e,
        toAddress: o,
        amount: [...t]
      })
    },
    "/cosmos.bank.v1beta1.MsgMultiSend": {
      aminoType: "cosmos-sdk/MsgMultiSend",
      toAmino: ({ inputs: e, outputs: o }) => ({
        inputs: e.map((t) => ({
          address: t.address,
          coins: [...t.coins]
        })),
        outputs: o.map((t) => ({
          address: t.address,
          coins: [...t.coins]
        }))
      }),
      fromAmino: ({ inputs: e, outputs: o }) => ({
        inputs: e.map((t) => ({
          address: t.address,
          coins: [...t.coins]
        })),
        outputs: o.map((t) => ({
          address: t.address,
          coins: [...t.coins]
        }))
      })
    }
  };
}
Lt.createBankAminoConverters = Hf;
var wn = {};
Object.defineProperty(wn, "__esModule", { value: !0 });
wn.isMsgSendEncodeObject = wn.bankTypes = void 0;
const Oa = Ku;
wn.bankTypes = [
  ["/cosmos.bank.v1beta1.MsgMultiSend", Oa.MsgMultiSend],
  ["/cosmos.bank.v1beta1.MsgSend", Oa.MsgSend]
];
function jf(e) {
  return e.typeUrl === "/cosmos.bank.v1beta1.MsgSend";
}
wn.isMsgSendEncodeObject = jf;
var tr = {}, fc = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(O, L, Z, j) {
    j === void 0 && (j = Z);
    var i = Object.getOwnPropertyDescriptor(L, Z);
    (!i || ("get" in i ? !L.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
      return L[Z];
    } }), Object.defineProperty(O, j, i);
  } : function(O, L, Z, j) {
    j === void 0 && (j = Z), O[j] = L[Z];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(O, L) {
    Object.defineProperty(O, "default", { enumerable: !0, value: L });
  } : function(O, L) {
    O.default = L;
  }), u = Q && Q.__importStar || function(O) {
    if (O && O.__esModule)
      return O;
    var L = {};
    if (O != null)
      for (var Z in O)
        Z !== "default" && Object.prototype.hasOwnProperty.call(O, Z) && o(L, O, Z);
    return t(L, O), L;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QuerySendEnabledResponse = e.QuerySendEnabledRequest = e.QueryDenomOwnersResponse = e.DenomOwner = e.QueryDenomOwnersRequest = e.QueryDenomMetadataResponse = e.QueryDenomMetadataRequest = e.QueryDenomsMetadataResponse = e.QueryDenomsMetadataRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.QuerySupplyOfResponse = e.QuerySupplyOfRequest = e.QueryTotalSupplyResponse = e.QueryTotalSupplyRequest = e.QuerySpendableBalanceByDenomResponse = e.QuerySpendableBalanceByDenomRequest = e.QuerySpendableBalancesResponse = e.QuerySpendableBalancesRequest = e.QueryAllBalancesResponse = e.QueryAllBalancesRequest = e.QueryBalanceResponse = e.QueryBalanceRequest = e.protobufPackage = void 0;
  const r = be, m = Le, f = zu, b = u(re), R = ie;
  e.protobufPackage = "cosmos.bank.v1beta1";
  function T() {
    return {
      address: "",
      denom: ""
    };
  }
  e.QueryBalanceRequest = {
    encode(O, L = b.Writer.create()) {
      return O.address !== "" && L.uint32(10).string(O.address), O.denom !== "" && L.uint32(18).string(O.denom), L;
    },
    decode(O, L) {
      const Z = O instanceof b.Reader ? O : new b.Reader(O);
      let j = L === void 0 ? Z.len : Z.pos + L;
      const i = T();
      for (; Z.pos < j; ) {
        const P = Z.uint32();
        switch (P >>> 3) {
          case 1:
            i.address = Z.string();
            break;
          case 2:
            i.denom = Z.string();
            break;
          default:
            Z.skipType(P & 7);
            break;
        }
      }
      return i;
    },
    fromJSON(O) {
      return {
        address: (0, R.isSet)(O.address) ? String(O.address) : "",
        denom: (0, R.isSet)(O.denom) ? String(O.denom) : ""
      };
    },
    toJSON(O) {
      const L = {};
      return O.address !== void 0 && (L.address = O.address), O.denom !== void 0 && (L.denom = O.denom), L;
    },
    fromPartial(O) {
      const L = T();
      return L.address = O.address ?? "", L.denom = O.denom ?? "", L;
    }
  };
  function V() {
    return {
      balance: void 0
    };
  }
  e.QueryBalanceResponse = {
    encode(O, L = b.Writer.create()) {
      return O.balance !== void 0 && m.Coin.encode(O.balance, L.uint32(10).fork()).ldelim(), L;
    },
    decode(O, L) {
      const Z = O instanceof b.Reader ? O : new b.Reader(O);
      let j = L === void 0 ? Z.len : Z.pos + L;
      const i = V();
      for (; Z.pos < j; ) {
        const P = Z.uint32();
        switch (P >>> 3) {
          case 1:
            i.balance = m.Coin.decode(Z, Z.uint32());
            break;
          default:
            Z.skipType(P & 7);
            break;
        }
      }
      return i;
    },
    fromJSON(O) {
      return {
        balance: (0, R.isSet)(O.balance) ? m.Coin.fromJSON(O.balance) : void 0
      };
    },
    toJSON(O) {
      const L = {};
      return O.balance !== void 0 && (L.balance = O.balance ? m.Coin.toJSON(O.balance) : void 0), L;
    },
    fromPartial(O) {
      const L = V();
      return L.balance = O.balance !== void 0 && O.balance !== null ? m.Coin.fromPartial(O.balance) : void 0, L;
    }
  };
  function D() {
    return {
      address: "",
      pagination: void 0
    };
  }
  e.QueryAllBalancesRequest = {
    encode(O, L = b.Writer.create()) {
      return O.address !== "" && L.uint32(10).string(O.address), O.pagination !== void 0 && r.PageRequest.encode(O.pagination, L.uint32(18).fork()).ldelim(), L;
    },
    decode(O, L) {
      const Z = O instanceof b.Reader ? O : new b.Reader(O);
      let j = L === void 0 ? Z.len : Z.pos + L;
      const i = D();
      for (; Z.pos < j; ) {
        const P = Z.uint32();
        switch (P >>> 3) {
          case 1:
            i.address = Z.string();
            break;
          case 2:
            i.pagination = r.PageRequest.decode(Z, Z.uint32());
            break;
          default:
            Z.skipType(P & 7);
            break;
        }
      }
      return i;
    },
    fromJSON(O) {
      return {
        address: (0, R.isSet)(O.address) ? String(O.address) : "",
        pagination: (0, R.isSet)(O.pagination) ? r.PageRequest.fromJSON(O.pagination) : void 0
      };
    },
    toJSON(O) {
      const L = {};
      return O.address !== void 0 && (L.address = O.address), O.pagination !== void 0 && (L.pagination = O.pagination ? r.PageRequest.toJSON(O.pagination) : void 0), L;
    },
    fromPartial(O) {
      const L = D();
      return L.address = O.address ?? "", L.pagination = O.pagination !== void 0 && O.pagination !== null ? r.PageRequest.fromPartial(O.pagination) : void 0, L;
    }
  };
  function B() {
    return {
      balances: [],
      pagination: void 0
    };
  }
  e.QueryAllBalancesResponse = {
    encode(O, L = b.Writer.create()) {
      for (const Z of O.balances)
        m.Coin.encode(Z, L.uint32(10).fork()).ldelim();
      return O.pagination !== void 0 && r.PageResponse.encode(O.pagination, L.uint32(18).fork()).ldelim(), L;
    },
    decode(O, L) {
      const Z = O instanceof b.Reader ? O : new b.Reader(O);
      let j = L === void 0 ? Z.len : Z.pos + L;
      const i = B();
      for (; Z.pos < j; ) {
        const P = Z.uint32();
        switch (P >>> 3) {
          case 1:
            i.balances.push(m.Coin.decode(Z, Z.uint32()));
            break;
          case 2:
            i.pagination = r.PageResponse.decode(Z, Z.uint32());
            break;
          default:
            Z.skipType(P & 7);
            break;
        }
      }
      return i;
    },
    fromJSON(O) {
      return {
        balances: Array.isArray(O == null ? void 0 : O.balances) ? O.balances.map((L) => m.Coin.fromJSON(L)) : [],
        pagination: (0, R.isSet)(O.pagination) ? r.PageResponse.fromJSON(O.pagination) : void 0
      };
    },
    toJSON(O) {
      const L = {};
      return O.balances ? L.balances = O.balances.map((Z) => Z ? m.Coin.toJSON(Z) : void 0) : L.balances = [], O.pagination !== void 0 && (L.pagination = O.pagination ? r.PageResponse.toJSON(O.pagination) : void 0), L;
    },
    fromPartial(O) {
      var L;
      const Z = B();
      return Z.balances = ((L = O.balances) == null ? void 0 : L.map((j) => m.Coin.fromPartial(j))) || [], Z.pagination = O.pagination !== void 0 && O.pagination !== null ? r.PageResponse.fromPartial(O.pagination) : void 0, Z;
    }
  };
  function U() {
    return {
      address: "",
      pagination: void 0
    };
  }
  e.QuerySpendableBalancesRequest = {
    encode(O, L = b.Writer.create()) {
      return O.address !== "" && L.uint32(10).string(O.address), O.pagination !== void 0 && r.PageRequest.encode(O.pagination, L.uint32(18).fork()).ldelim(), L;
    },
    decode(O, L) {
      const Z = O instanceof b.Reader ? O : new b.Reader(O);
      let j = L === void 0 ? Z.len : Z.pos + L;
      const i = U();
      for (; Z.pos < j; ) {
        const P = Z.uint32();
        switch (P >>> 3) {
          case 1:
            i.address = Z.string();
            break;
          case 2:
            i.pagination = r.PageRequest.decode(Z, Z.uint32());
            break;
          default:
            Z.skipType(P & 7);
            break;
        }
      }
      return i;
    },
    fromJSON(O) {
      return {
        address: (0, R.isSet)(O.address) ? String(O.address) : "",
        pagination: (0, R.isSet)(O.pagination) ? r.PageRequest.fromJSON(O.pagination) : void 0
      };
    },
    toJSON(O) {
      const L = {};
      return O.address !== void 0 && (L.address = O.address), O.pagination !== void 0 && (L.pagination = O.pagination ? r.PageRequest.toJSON(O.pagination) : void 0), L;
    },
    fromPartial(O) {
      const L = U();
      return L.address = O.address ?? "", L.pagination = O.pagination !== void 0 && O.pagination !== null ? r.PageRequest.fromPartial(O.pagination) : void 0, L;
    }
  };
  function C() {
    return {
      balances: [],
      pagination: void 0
    };
  }
  e.QuerySpendableBalancesResponse = {
    encode(O, L = b.Writer.create()) {
      for (const Z of O.balances)
        m.Coin.encode(Z, L.uint32(10).fork()).ldelim();
      return O.pagination !== void 0 && r.PageResponse.encode(O.pagination, L.uint32(18).fork()).ldelim(), L;
    },
    decode(O, L) {
      const Z = O instanceof b.Reader ? O : new b.Reader(O);
      let j = L === void 0 ? Z.len : Z.pos + L;
      const i = C();
      for (; Z.pos < j; ) {
        const P = Z.uint32();
        switch (P >>> 3) {
          case 1:
            i.balances.push(m.Coin.decode(Z, Z.uint32()));
            break;
          case 2:
            i.pagination = r.PageResponse.decode(Z, Z.uint32());
            break;
          default:
            Z.skipType(P & 7);
            break;
        }
      }
      return i;
    },
    fromJSON(O) {
      return {
        balances: Array.isArray(O == null ? void 0 : O.balances) ? O.balances.map((L) => m.Coin.fromJSON(L)) : [],
        pagination: (0, R.isSet)(O.pagination) ? r.PageResponse.fromJSON(O.pagination) : void 0
      };
    },
    toJSON(O) {
      const L = {};
      return O.balances ? L.balances = O.balances.map((Z) => Z ? m.Coin.toJSON(Z) : void 0) : L.balances = [], O.pagination !== void 0 && (L.pagination = O.pagination ? r.PageResponse.toJSON(O.pagination) : void 0), L;
    },
    fromPartial(O) {
      var L;
      const Z = C();
      return Z.balances = ((L = O.balances) == null ? void 0 : L.map((j) => m.Coin.fromPartial(j))) || [], Z.pagination = O.pagination !== void 0 && O.pagination !== null ? r.PageResponse.fromPartial(O.pagination) : void 0, Z;
    }
  };
  function l() {
    return {
      address: "",
      denom: ""
    };
  }
  e.QuerySpendableBalanceByDenomRequest = {
    encode(O, L = b.Writer.create()) {
      return O.address !== "" && L.uint32(10).string(O.address), O.denom !== "" && L.uint32(18).string(O.denom), L;
    },
    decode(O, L) {
      const Z = O instanceof b.Reader ? O : new b.Reader(O);
      let j = L === void 0 ? Z.len : Z.pos + L;
      const i = l();
      for (; Z.pos < j; ) {
        const P = Z.uint32();
        switch (P >>> 3) {
          case 1:
            i.address = Z.string();
            break;
          case 2:
            i.denom = Z.string();
            break;
          default:
            Z.skipType(P & 7);
            break;
        }
      }
      return i;
    },
    fromJSON(O) {
      return {
        address: (0, R.isSet)(O.address) ? String(O.address) : "",
        denom: (0, R.isSet)(O.denom) ? String(O.denom) : ""
      };
    },
    toJSON(O) {
      const L = {};
      return O.address !== void 0 && (L.address = O.address), O.denom !== void 0 && (L.denom = O.denom), L;
    },
    fromPartial(O) {
      const L = l();
      return L.address = O.address ?? "", L.denom = O.denom ?? "", L;
    }
  };
  function S() {
    return {
      balance: void 0
    };
  }
  e.QuerySpendableBalanceByDenomResponse = {
    encode(O, L = b.Writer.create()) {
      return O.balance !== void 0 && m.Coin.encode(O.balance, L.uint32(10).fork()).ldelim(), L;
    },
    decode(O, L) {
      const Z = O instanceof b.Reader ? O : new b.Reader(O);
      let j = L === void 0 ? Z.len : Z.pos + L;
      const i = S();
      for (; Z.pos < j; ) {
        const P = Z.uint32();
        switch (P >>> 3) {
          case 1:
            i.balance = m.Coin.decode(Z, Z.uint32());
            break;
          default:
            Z.skipType(P & 7);
            break;
        }
      }
      return i;
    },
    fromJSON(O) {
      return {
        balance: (0, R.isSet)(O.balance) ? m.Coin.fromJSON(O.balance) : void 0
      };
    },
    toJSON(O) {
      const L = {};
      return O.balance !== void 0 && (L.balance = O.balance ? m.Coin.toJSON(O.balance) : void 0), L;
    },
    fromPartial(O) {
      const L = S();
      return L.balance = O.balance !== void 0 && O.balance !== null ? m.Coin.fromPartial(O.balance) : void 0, L;
    }
  };
  function A() {
    return {
      pagination: void 0
    };
  }
  e.QueryTotalSupplyRequest = {
    encode(O, L = b.Writer.create()) {
      return O.pagination !== void 0 && r.PageRequest.encode(O.pagination, L.uint32(10).fork()).ldelim(), L;
    },
    decode(O, L) {
      const Z = O instanceof b.Reader ? O : new b.Reader(O);
      let j = L === void 0 ? Z.len : Z.pos + L;
      const i = A();
      for (; Z.pos < j; ) {
        const P = Z.uint32();
        switch (P >>> 3) {
          case 1:
            i.pagination = r.PageRequest.decode(Z, Z.uint32());
            break;
          default:
            Z.skipType(P & 7);
            break;
        }
      }
      return i;
    },
    fromJSON(O) {
      return {
        pagination: (0, R.isSet)(O.pagination) ? r.PageRequest.fromJSON(O.pagination) : void 0
      };
    },
    toJSON(O) {
      const L = {};
      return O.pagination !== void 0 && (L.pagination = O.pagination ? r.PageRequest.toJSON(O.pagination) : void 0), L;
    },
    fromPartial(O) {
      const L = A();
      return L.pagination = O.pagination !== void 0 && O.pagination !== null ? r.PageRequest.fromPartial(O.pagination) : void 0, L;
    }
  };
  function d() {
    return {
      supply: [],
      pagination: void 0
    };
  }
  e.QueryTotalSupplyResponse = {
    encode(O, L = b.Writer.create()) {
      for (const Z of O.supply)
        m.Coin.encode(Z, L.uint32(10).fork()).ldelim();
      return O.pagination !== void 0 && r.PageResponse.encode(O.pagination, L.uint32(18).fork()).ldelim(), L;
    },
    decode(O, L) {
      const Z = O instanceof b.Reader ? O : new b.Reader(O);
      let j = L === void 0 ? Z.len : Z.pos + L;
      const i = d();
      for (; Z.pos < j; ) {
        const P = Z.uint32();
        switch (P >>> 3) {
          case 1:
            i.supply.push(m.Coin.decode(Z, Z.uint32()));
            break;
          case 2:
            i.pagination = r.PageResponse.decode(Z, Z.uint32());
            break;
          default:
            Z.skipType(P & 7);
            break;
        }
      }
      return i;
    },
    fromJSON(O) {
      return {
        supply: Array.isArray(O == null ? void 0 : O.supply) ? O.supply.map((L) => m.Coin.fromJSON(L)) : [],
        pagination: (0, R.isSet)(O.pagination) ? r.PageResponse.fromJSON(O.pagination) : void 0
      };
    },
    toJSON(O) {
      const L = {};
      return O.supply ? L.supply = O.supply.map((Z) => Z ? m.Coin.toJSON(Z) : void 0) : L.supply = [], O.pagination !== void 0 && (L.pagination = O.pagination ? r.PageResponse.toJSON(O.pagination) : void 0), L;
    },
    fromPartial(O) {
      var L;
      const Z = d();
      return Z.supply = ((L = O.supply) == null ? void 0 : L.map((j) => m.Coin.fromPartial(j))) || [], Z.pagination = O.pagination !== void 0 && O.pagination !== null ? r.PageResponse.fromPartial(O.pagination) : void 0, Z;
    }
  };
  function p() {
    return {
      denom: ""
    };
  }
  e.QuerySupplyOfRequest = {
    encode(O, L = b.Writer.create()) {
      return O.denom !== "" && L.uint32(10).string(O.denom), L;
    },
    decode(O, L) {
      const Z = O instanceof b.Reader ? O : new b.Reader(O);
      let j = L === void 0 ? Z.len : Z.pos + L;
      const i = p();
      for (; Z.pos < j; ) {
        const P = Z.uint32();
        switch (P >>> 3) {
          case 1:
            i.denom = Z.string();
            break;
          default:
            Z.skipType(P & 7);
            break;
        }
      }
      return i;
    },
    fromJSON(O) {
      return {
        denom: (0, R.isSet)(O.denom) ? String(O.denom) : ""
      };
    },
    toJSON(O) {
      const L = {};
      return O.denom !== void 0 && (L.denom = O.denom), L;
    },
    fromPartial(O) {
      const L = p();
      return L.denom = O.denom ?? "", L;
    }
  };
  function h() {
    return {
      amount: void 0
    };
  }
  e.QuerySupplyOfResponse = {
    encode(O, L = b.Writer.create()) {
      return O.amount !== void 0 && m.Coin.encode(O.amount, L.uint32(10).fork()).ldelim(), L;
    },
    decode(O, L) {
      const Z = O instanceof b.Reader ? O : new b.Reader(O);
      let j = L === void 0 ? Z.len : Z.pos + L;
      const i = h();
      for (; Z.pos < j; ) {
        const P = Z.uint32();
        switch (P >>> 3) {
          case 1:
            i.amount = m.Coin.decode(Z, Z.uint32());
            break;
          default:
            Z.skipType(P & 7);
            break;
        }
      }
      return i;
    },
    fromJSON(O) {
      return {
        amount: (0, R.isSet)(O.amount) ? m.Coin.fromJSON(O.amount) : void 0
      };
    },
    toJSON(O) {
      const L = {};
      return O.amount !== void 0 && (L.amount = O.amount ? m.Coin.toJSON(O.amount) : void 0), L;
    },
    fromPartial(O) {
      const L = h();
      return L.amount = O.amount !== void 0 && O.amount !== null ? m.Coin.fromPartial(O.amount) : void 0, L;
    }
  };
  function x() {
    return {};
  }
  e.QueryParamsRequest = {
    encode(O, L = b.Writer.create()) {
      return L;
    },
    decode(O, L) {
      const Z = O instanceof b.Reader ? O : new b.Reader(O);
      let j = L === void 0 ? Z.len : Z.pos + L;
      const i = x();
      for (; Z.pos < j; ) {
        const P = Z.uint32();
        switch (P >>> 3) {
          default:
            Z.skipType(P & 7);
            break;
        }
      }
      return i;
    },
    fromJSON(O) {
      return {};
    },
    toJSON(O) {
      return {};
    },
    fromPartial(O) {
      return x();
    }
  };
  function _() {
    return {
      params: void 0
    };
  }
  e.QueryParamsResponse = {
    encode(O, L = b.Writer.create()) {
      return O.params !== void 0 && f.Params.encode(O.params, L.uint32(10).fork()).ldelim(), L;
    },
    decode(O, L) {
      const Z = O instanceof b.Reader ? O : new b.Reader(O);
      let j = L === void 0 ? Z.len : Z.pos + L;
      const i = _();
      for (; Z.pos < j; ) {
        const P = Z.uint32();
        switch (P >>> 3) {
          case 1:
            i.params = f.Params.decode(Z, Z.uint32());
            break;
          default:
            Z.skipType(P & 7);
            break;
        }
      }
      return i;
    },
    fromJSON(O) {
      return {
        params: (0, R.isSet)(O.params) ? f.Params.fromJSON(O.params) : void 0
      };
    },
    toJSON(O) {
      const L = {};
      return O.params !== void 0 && (L.params = O.params ? f.Params.toJSON(O.params) : void 0), L;
    },
    fromPartial(O) {
      const L = _();
      return L.params = O.params !== void 0 && O.params !== null ? f.Params.fromPartial(O.params) : void 0, L;
    }
  };
  function I() {
    return {
      pagination: void 0
    };
  }
  e.QueryDenomsMetadataRequest = {
    encode(O, L = b.Writer.create()) {
      return O.pagination !== void 0 && r.PageRequest.encode(O.pagination, L.uint32(10).fork()).ldelim(), L;
    },
    decode(O, L) {
      const Z = O instanceof b.Reader ? O : new b.Reader(O);
      let j = L === void 0 ? Z.len : Z.pos + L;
      const i = I();
      for (; Z.pos < j; ) {
        const P = Z.uint32();
        switch (P >>> 3) {
          case 1:
            i.pagination = r.PageRequest.decode(Z, Z.uint32());
            break;
          default:
            Z.skipType(P & 7);
            break;
        }
      }
      return i;
    },
    fromJSON(O) {
      return {
        pagination: (0, R.isSet)(O.pagination) ? r.PageRequest.fromJSON(O.pagination) : void 0
      };
    },
    toJSON(O) {
      const L = {};
      return O.pagination !== void 0 && (L.pagination = O.pagination ? r.PageRequest.toJSON(O.pagination) : void 0), L;
    },
    fromPartial(O) {
      const L = I();
      return L.pagination = O.pagination !== void 0 && O.pagination !== null ? r.PageRequest.fromPartial(O.pagination) : void 0, L;
    }
  };
  function W() {
    return {
      metadatas: [],
      pagination: void 0
    };
  }
  e.QueryDenomsMetadataResponse = {
    encode(O, L = b.Writer.create()) {
      for (const Z of O.metadatas)
        f.Metadata.encode(Z, L.uint32(10).fork()).ldelim();
      return O.pagination !== void 0 && r.PageResponse.encode(O.pagination, L.uint32(18).fork()).ldelim(), L;
    },
    decode(O, L) {
      const Z = O instanceof b.Reader ? O : new b.Reader(O);
      let j = L === void 0 ? Z.len : Z.pos + L;
      const i = W();
      for (; Z.pos < j; ) {
        const P = Z.uint32();
        switch (P >>> 3) {
          case 1:
            i.metadatas.push(f.Metadata.decode(Z, Z.uint32()));
            break;
          case 2:
            i.pagination = r.PageResponse.decode(Z, Z.uint32());
            break;
          default:
            Z.skipType(P & 7);
            break;
        }
      }
      return i;
    },
    fromJSON(O) {
      return {
        metadatas: Array.isArray(O == null ? void 0 : O.metadatas) ? O.metadatas.map((L) => f.Metadata.fromJSON(L)) : [],
        pagination: (0, R.isSet)(O.pagination) ? r.PageResponse.fromJSON(O.pagination) : void 0
      };
    },
    toJSON(O) {
      const L = {};
      return O.metadatas ? L.metadatas = O.metadatas.map((Z) => Z ? f.Metadata.toJSON(Z) : void 0) : L.metadatas = [], O.pagination !== void 0 && (L.pagination = O.pagination ? r.PageResponse.toJSON(O.pagination) : void 0), L;
    },
    fromPartial(O) {
      var L;
      const Z = W();
      return Z.metadatas = ((L = O.metadatas) == null ? void 0 : L.map((j) => f.Metadata.fromPartial(j))) || [], Z.pagination = O.pagination !== void 0 && O.pagination !== null ? r.PageResponse.fromPartial(O.pagination) : void 0, Z;
    }
  };
  function n() {
    return {
      denom: ""
    };
  }
  e.QueryDenomMetadataRequest = {
    encode(O, L = b.Writer.create()) {
      return O.denom !== "" && L.uint32(10).string(O.denom), L;
    },
    decode(O, L) {
      const Z = O instanceof b.Reader ? O : new b.Reader(O);
      let j = L === void 0 ? Z.len : Z.pos + L;
      const i = n();
      for (; Z.pos < j; ) {
        const P = Z.uint32();
        switch (P >>> 3) {
          case 1:
            i.denom = Z.string();
            break;
          default:
            Z.skipType(P & 7);
            break;
        }
      }
      return i;
    },
    fromJSON(O) {
      return {
        denom: (0, R.isSet)(O.denom) ? String(O.denom) : ""
      };
    },
    toJSON(O) {
      const L = {};
      return O.denom !== void 0 && (L.denom = O.denom), L;
    },
    fromPartial(O) {
      const L = n();
      return L.denom = O.denom ?? "", L;
    }
  };
  function y() {
    return {
      metadata: void 0
    };
  }
  e.QueryDenomMetadataResponse = {
    encode(O, L = b.Writer.create()) {
      return O.metadata !== void 0 && f.Metadata.encode(O.metadata, L.uint32(10).fork()).ldelim(), L;
    },
    decode(O, L) {
      const Z = O instanceof b.Reader ? O : new b.Reader(O);
      let j = L === void 0 ? Z.len : Z.pos + L;
      const i = y();
      for (; Z.pos < j; ) {
        const P = Z.uint32();
        switch (P >>> 3) {
          case 1:
            i.metadata = f.Metadata.decode(Z, Z.uint32());
            break;
          default:
            Z.skipType(P & 7);
            break;
        }
      }
      return i;
    },
    fromJSON(O) {
      return {
        metadata: (0, R.isSet)(O.metadata) ? f.Metadata.fromJSON(O.metadata) : void 0
      };
    },
    toJSON(O) {
      const L = {};
      return O.metadata !== void 0 && (L.metadata = O.metadata ? f.Metadata.toJSON(O.metadata) : void 0), L;
    },
    fromPartial(O) {
      const L = y();
      return L.metadata = O.metadata !== void 0 && O.metadata !== null ? f.Metadata.fromPartial(O.metadata) : void 0, L;
    }
  };
  function w() {
    return {
      denom: "",
      pagination: void 0
    };
  }
  e.QueryDenomOwnersRequest = {
    encode(O, L = b.Writer.create()) {
      return O.denom !== "" && L.uint32(10).string(O.denom), O.pagination !== void 0 && r.PageRequest.encode(O.pagination, L.uint32(18).fork()).ldelim(), L;
    },
    decode(O, L) {
      const Z = O instanceof b.Reader ? O : new b.Reader(O);
      let j = L === void 0 ? Z.len : Z.pos + L;
      const i = w();
      for (; Z.pos < j; ) {
        const P = Z.uint32();
        switch (P >>> 3) {
          case 1:
            i.denom = Z.string();
            break;
          case 2:
            i.pagination = r.PageRequest.decode(Z, Z.uint32());
            break;
          default:
            Z.skipType(P & 7);
            break;
        }
      }
      return i;
    },
    fromJSON(O) {
      return {
        denom: (0, R.isSet)(O.denom) ? String(O.denom) : "",
        pagination: (0, R.isSet)(O.pagination) ? r.PageRequest.fromJSON(O.pagination) : void 0
      };
    },
    toJSON(O) {
      const L = {};
      return O.denom !== void 0 && (L.denom = O.denom), O.pagination !== void 0 && (L.pagination = O.pagination ? r.PageRequest.toJSON(O.pagination) : void 0), L;
    },
    fromPartial(O) {
      const L = w();
      return L.denom = O.denom ?? "", L.pagination = O.pagination !== void 0 && O.pagination !== null ? r.PageRequest.fromPartial(O.pagination) : void 0, L;
    }
  };
  function M() {
    return {
      address: "",
      balance: void 0
    };
  }
  e.DenomOwner = {
    encode(O, L = b.Writer.create()) {
      return O.address !== "" && L.uint32(10).string(O.address), O.balance !== void 0 && m.Coin.encode(O.balance, L.uint32(18).fork()).ldelim(), L;
    },
    decode(O, L) {
      const Z = O instanceof b.Reader ? O : new b.Reader(O);
      let j = L === void 0 ? Z.len : Z.pos + L;
      const i = M();
      for (; Z.pos < j; ) {
        const P = Z.uint32();
        switch (P >>> 3) {
          case 1:
            i.address = Z.string();
            break;
          case 2:
            i.balance = m.Coin.decode(Z, Z.uint32());
            break;
          default:
            Z.skipType(P & 7);
            break;
        }
      }
      return i;
    },
    fromJSON(O) {
      return {
        address: (0, R.isSet)(O.address) ? String(O.address) : "",
        balance: (0, R.isSet)(O.balance) ? m.Coin.fromJSON(O.balance) : void 0
      };
    },
    toJSON(O) {
      const L = {};
      return O.address !== void 0 && (L.address = O.address), O.balance !== void 0 && (L.balance = O.balance ? m.Coin.toJSON(O.balance) : void 0), L;
    },
    fromPartial(O) {
      const L = M();
      return L.address = O.address ?? "", L.balance = O.balance !== void 0 && O.balance !== null ? m.Coin.fromPartial(O.balance) : void 0, L;
    }
  };
  function s() {
    return {
      denomOwners: [],
      pagination: void 0
    };
  }
  e.QueryDenomOwnersResponse = {
    encode(O, L = b.Writer.create()) {
      for (const Z of O.denomOwners)
        e.DenomOwner.encode(Z, L.uint32(10).fork()).ldelim();
      return O.pagination !== void 0 && r.PageResponse.encode(O.pagination, L.uint32(18).fork()).ldelim(), L;
    },
    decode(O, L) {
      const Z = O instanceof b.Reader ? O : new b.Reader(O);
      let j = L === void 0 ? Z.len : Z.pos + L;
      const i = s();
      for (; Z.pos < j; ) {
        const P = Z.uint32();
        switch (P >>> 3) {
          case 1:
            i.denomOwners.push(e.DenomOwner.decode(Z, Z.uint32()));
            break;
          case 2:
            i.pagination = r.PageResponse.decode(Z, Z.uint32());
            break;
          default:
            Z.skipType(P & 7);
            break;
        }
      }
      return i;
    },
    fromJSON(O) {
      return {
        denomOwners: Array.isArray(O == null ? void 0 : O.denomOwners) ? O.denomOwners.map((L) => e.DenomOwner.fromJSON(L)) : [],
        pagination: (0, R.isSet)(O.pagination) ? r.PageResponse.fromJSON(O.pagination) : void 0
      };
    },
    toJSON(O) {
      const L = {};
      return O.denomOwners ? L.denomOwners = O.denomOwners.map((Z) => Z ? e.DenomOwner.toJSON(Z) : void 0) : L.denomOwners = [], O.pagination !== void 0 && (L.pagination = O.pagination ? r.PageResponse.toJSON(O.pagination) : void 0), L;
    },
    fromPartial(O) {
      var L;
      const Z = s();
      return Z.denomOwners = ((L = O.denomOwners) == null ? void 0 : L.map((j) => e.DenomOwner.fromPartial(j))) || [], Z.pagination = O.pagination !== void 0 && O.pagination !== null ? r.PageResponse.fromPartial(O.pagination) : void 0, Z;
    }
  };
  function c() {
    return {
      denoms: [],
      pagination: void 0
    };
  }
  e.QuerySendEnabledRequest = {
    encode(O, L = b.Writer.create()) {
      for (const Z of O.denoms)
        L.uint32(10).string(Z);
      return O.pagination !== void 0 && r.PageRequest.encode(O.pagination, L.uint32(794).fork()).ldelim(), L;
    },
    decode(O, L) {
      const Z = O instanceof b.Reader ? O : new b.Reader(O);
      let j = L === void 0 ? Z.len : Z.pos + L;
      const i = c();
      for (; Z.pos < j; ) {
        const P = Z.uint32();
        switch (P >>> 3) {
          case 1:
            i.denoms.push(Z.string());
            break;
          case 99:
            i.pagination = r.PageRequest.decode(Z, Z.uint32());
            break;
          default:
            Z.skipType(P & 7);
            break;
        }
      }
      return i;
    },
    fromJSON(O) {
      return {
        denoms: Array.isArray(O == null ? void 0 : O.denoms) ? O.denoms.map((L) => String(L)) : [],
        pagination: (0, R.isSet)(O.pagination) ? r.PageRequest.fromJSON(O.pagination) : void 0
      };
    },
    toJSON(O) {
      const L = {};
      return O.denoms ? L.denoms = O.denoms.map((Z) => Z) : L.denoms = [], O.pagination !== void 0 && (L.pagination = O.pagination ? r.PageRequest.toJSON(O.pagination) : void 0), L;
    },
    fromPartial(O) {
      var L;
      const Z = c();
      return Z.denoms = ((L = O.denoms) == null ? void 0 : L.map((j) => j)) || [], Z.pagination = O.pagination !== void 0 && O.pagination !== null ? r.PageRequest.fromPartial(O.pagination) : void 0, Z;
    }
  };
  function E() {
    return {
      sendEnabled: [],
      pagination: void 0
    };
  }
  e.QuerySendEnabledResponse = {
    encode(O, L = b.Writer.create()) {
      for (const Z of O.sendEnabled)
        f.SendEnabled.encode(Z, L.uint32(10).fork()).ldelim();
      return O.pagination !== void 0 && r.PageResponse.encode(O.pagination, L.uint32(794).fork()).ldelim(), L;
    },
    decode(O, L) {
      const Z = O instanceof b.Reader ? O : new b.Reader(O);
      let j = L === void 0 ? Z.len : Z.pos + L;
      const i = E();
      for (; Z.pos < j; ) {
        const P = Z.uint32();
        switch (P >>> 3) {
          case 1:
            i.sendEnabled.push(f.SendEnabled.decode(Z, Z.uint32()));
            break;
          case 99:
            i.pagination = r.PageResponse.decode(Z, Z.uint32());
            break;
          default:
            Z.skipType(P & 7);
            break;
        }
      }
      return i;
    },
    fromJSON(O) {
      return {
        sendEnabled: Array.isArray(O == null ? void 0 : O.sendEnabled) ? O.sendEnabled.map((L) => f.SendEnabled.fromJSON(L)) : [],
        pagination: (0, R.isSet)(O.pagination) ? r.PageResponse.fromJSON(O.pagination) : void 0
      };
    },
    toJSON(O) {
      const L = {};
      return O.sendEnabled ? L.sendEnabled = O.sendEnabled.map((Z) => Z ? f.SendEnabled.toJSON(Z) : void 0) : L.sendEnabled = [], O.pagination !== void 0 && (L.pagination = O.pagination ? r.PageResponse.toJSON(O.pagination) : void 0), L;
    },
    fromPartial(O) {
      var L;
      const Z = E();
      return Z.sendEnabled = ((L = O.sendEnabled) == null ? void 0 : L.map((j) => f.SendEnabled.fromPartial(j))) || [], Z.pagination = O.pagination !== void 0 && O.pagination !== null ? r.PageResponse.fromPartial(O.pagination) : void 0, Z;
    }
  };
  class k {
    constructor(L) {
      this.rpc = L, this.Balance = this.Balance.bind(this), this.AllBalances = this.AllBalances.bind(this), this.SpendableBalances = this.SpendableBalances.bind(this), this.SpendableBalanceByDenom = this.SpendableBalanceByDenom.bind(this), this.TotalSupply = this.TotalSupply.bind(this), this.SupplyOf = this.SupplyOf.bind(this), this.Params = this.Params.bind(this), this.DenomMetadata = this.DenomMetadata.bind(this), this.DenomsMetadata = this.DenomsMetadata.bind(this), this.DenomOwners = this.DenomOwners.bind(this), this.SendEnabled = this.SendEnabled.bind(this);
    }
    Balance(L) {
      const Z = e.QueryBalanceRequest.encode(L).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "Balance", Z).then((j) => e.QueryBalanceResponse.decode(new b.Reader(j)));
    }
    AllBalances(L) {
      const Z = e.QueryAllBalancesRequest.encode(L).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "AllBalances", Z).then((j) => e.QueryAllBalancesResponse.decode(new b.Reader(j)));
    }
    SpendableBalances(L) {
      const Z = e.QuerySpendableBalancesRequest.encode(L).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "SpendableBalances", Z).then((j) => e.QuerySpendableBalancesResponse.decode(new b.Reader(j)));
    }
    SpendableBalanceByDenom(L) {
      const Z = e.QuerySpendableBalanceByDenomRequest.encode(L).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "SpendableBalanceByDenom", Z).then((j) => e.QuerySpendableBalanceByDenomResponse.decode(new b.Reader(j)));
    }
    TotalSupply(L = {
      pagination: void 0
    }) {
      const Z = e.QueryTotalSupplyRequest.encode(L).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "TotalSupply", Z).then((j) => e.QueryTotalSupplyResponse.decode(new b.Reader(j)));
    }
    SupplyOf(L) {
      const Z = e.QuerySupplyOfRequest.encode(L).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "SupplyOf", Z).then((j) => e.QuerySupplyOfResponse.decode(new b.Reader(j)));
    }
    Params(L = {}) {
      const Z = e.QueryParamsRequest.encode(L).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "Params", Z).then((j) => e.QueryParamsResponse.decode(new b.Reader(j)));
    }
    DenomMetadata(L) {
      const Z = e.QueryDenomMetadataRequest.encode(L).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "DenomMetadata", Z).then((j) => e.QueryDenomMetadataResponse.decode(new b.Reader(j)));
    }
    DenomsMetadata(L = {
      pagination: void 0
    }) {
      const Z = e.QueryDenomsMetadataRequest.encode(L).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "DenomsMetadata", Z).then((j) => e.QueryDenomsMetadataResponse.decode(new b.Reader(j)));
    }
    DenomOwners(L) {
      const Z = e.QueryDenomOwnersRequest.encode(L).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "DenomOwners", Z).then((j) => e.QueryDenomOwnersResponse.decode(new b.Reader(j)));
    }
    SendEnabled(L) {
      const Z = e.QuerySendEnabledRequest.encode(L).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "SendEnabled", Z).then((j) => e.QuerySendEnabledResponse.decode(new b.Reader(j)));
    }
  }
  e.QueryClientImpl = k;
})(fc);
Object.defineProperty(tr, "__esModule", { value: !0 });
tr.setupBankExtension = void 0;
const $r = ht, Wf = fc, ka = Ve;
function qf(e) {
  const o = (0, ka.createProtobufRpcClient)(e), t = new Wf.QueryClientImpl(o);
  return {
    bank: {
      balance: async (u, r) => {
        const { balance: m } = await t.Balance({ address: u, denom: r });
        return (0, $r.assert)(m), m;
      },
      allBalances: async (u) => {
        const { balances: r } = await t.AllBalances({ address: u });
        return r;
      },
      totalSupply: async (u) => await t.TotalSupply({
        pagination: (0, ka.createPagination)(u)
      }),
      supplyOf: async (u) => {
        const { amount: r } = await t.SupplyOf({ denom: u });
        return (0, $r.assert)(r), r;
      },
      denomMetadata: async (u) => {
        const { metadata: r } = await t.DenomMetadata({ denom: u });
        return (0, $r.assert)(r), r;
      },
      denomsMetadata: async () => {
        const { metadatas: u } = await t.DenomsMetadata({
          pagination: void 0
          // Not implemented
        });
        return u;
      }
    }
  };
}
tr.setupBankExtension = qf;
var Nn = {};
Object.defineProperty(Nn, "__esModule", { value: !0 });
Nn.createCrysisAminoConverters = Nn.isAminoMsgVerifyInvariant = void 0;
function Zf(e) {
  return e.type === "cosmos-sdk/MsgVerifyInvariant";
}
Nn.isAminoMsgVerifyInvariant = Zf;
function Qf() {
  throw new Error("Not implemented");
}
Nn.createCrysisAminoConverters = Qf;
var ot = {};
Object.defineProperty(ot, "__esModule", { value: !0 });
ot.createDistributionAminoConverters = ot.isAminoMsgFundCommunityPool = ot.isAminoMsgWithdrawValidatorCommission = ot.isAminoMsgWithdrawDelegatorReward = ot.isAminoMsgSetWithdrawAddress = void 0;
function Ff(e) {
  return e.type === "cosmos-sdk/MsgModifyWithdrawAddress";
}
ot.isAminoMsgSetWithdrawAddress = Ff;
function Gf(e) {
  return e.type === "cosmos-sdk/MsgWithdrawDelegationReward";
}
ot.isAminoMsgWithdrawDelegatorReward = Gf;
function Kf(e) {
  return e.type === "cosmos-sdk/MsgWithdrawValidatorCommission";
}
ot.isAminoMsgWithdrawValidatorCommission = Kf;
function zf(e) {
  return e.type === "cosmos-sdk/MsgFundCommunityPool";
}
ot.isAminoMsgFundCommunityPool = zf;
function Yf() {
  return {
    "/cosmos.distribution.v1beta1.MsgFundCommunityPool": {
      aminoType: "cosmos-sdk/MsgFundCommunityPool",
      toAmino: ({ amount: e, depositor: o }) => ({
        amount: [...e],
        depositor: o
      }),
      fromAmino: ({ amount: e, depositor: o }) => ({
        amount: [...e],
        depositor: o
      })
    },
    "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress": {
      aminoType: "cosmos-sdk/MsgModifyWithdrawAddress",
      toAmino: ({ delegatorAddress: e, withdrawAddress: o }) => ({
        delegator_address: e,
        withdraw_address: o
      }),
      fromAmino: ({ delegator_address: e, withdraw_address: o }) => ({
        delegatorAddress: e,
        withdrawAddress: o
      })
    },
    "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward": {
      aminoType: "cosmos-sdk/MsgWithdrawDelegationReward",
      toAmino: ({ delegatorAddress: e, validatorAddress: o }) => ({
        delegator_address: e,
        validator_address: o
      }),
      fromAmino: ({ delegator_address: e, validator_address: o }) => ({
        delegatorAddress: e,
        validatorAddress: o
      })
    },
    "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission": {
      aminoType: "cosmos-sdk/MsgWithdrawValidatorCommission",
      toAmino: ({ validatorAddress: e }) => ({
        validator_address: e
      }),
      fromAmino: ({ validator_address: e }) => ({
        validatorAddress: e
      })
    }
  };
}
ot.createDistributionAminoConverters = Yf;
var En = {}, Ki = {}, zi = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(p, h, x, _) {
    _ === void 0 && (_ = x);
    var I = Object.getOwnPropertyDescriptor(h, x);
    (!I || ("get" in I ? !h.__esModule : I.writable || I.configurable)) && (I = { enumerable: !0, get: function() {
      return h[x];
    } }), Object.defineProperty(p, _, I);
  } : function(p, h, x, _) {
    _ === void 0 && (_ = x), p[_] = h[x];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(p, h) {
    Object.defineProperty(p, "default", { enumerable: !0, value: h });
  } : function(p, h) {
    p.default = h;
  }), u = Q && Q.__importStar || function(p) {
    if (p && p.__esModule)
      return p;
    var h = {};
    if (p != null)
      for (var x in p)
        x !== "default" && Object.prototype.hasOwnProperty.call(p, x) && o(h, p, x);
    return t(h, p), h;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CommunityPoolSpendProposalWithDeposit = e.DelegationDelegatorReward = e.DelegatorStartingInfo = e.CommunityPoolSpendProposal = e.FeePool = e.ValidatorSlashEvents = e.ValidatorSlashEvent = e.ValidatorOutstandingRewards = e.ValidatorAccumulatedCommission = e.ValidatorCurrentRewards = e.ValidatorHistoricalRewards = e.Params = e.protobufPackage = void 0;
  const r = Le, m = ie, f = u(re);
  e.protobufPackage = "cosmos.distribution.v1beta1";
  function b() {
    return {
      communityTax: "",
      baseProposerReward: "",
      bonusProposerReward: "",
      withdrawAddrEnabled: !1
    };
  }
  e.Params = {
    encode(p, h = f.Writer.create()) {
      return p.communityTax !== "" && h.uint32(10).string(p.communityTax), p.baseProposerReward !== "" && h.uint32(18).string(p.baseProposerReward), p.bonusProposerReward !== "" && h.uint32(26).string(p.bonusProposerReward), p.withdrawAddrEnabled === !0 && h.uint32(32).bool(p.withdrawAddrEnabled), h;
    },
    decode(p, h) {
      const x = p instanceof f.Reader ? p : new f.Reader(p);
      let _ = h === void 0 ? x.len : x.pos + h;
      const I = b();
      for (; x.pos < _; ) {
        const W = x.uint32();
        switch (W >>> 3) {
          case 1:
            I.communityTax = x.string();
            break;
          case 2:
            I.baseProposerReward = x.string();
            break;
          case 3:
            I.bonusProposerReward = x.string();
            break;
          case 4:
            I.withdrawAddrEnabled = x.bool();
            break;
          default:
            x.skipType(W & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        communityTax: (0, m.isSet)(p.communityTax) ? String(p.communityTax) : "",
        baseProposerReward: (0, m.isSet)(p.baseProposerReward) ? String(p.baseProposerReward) : "",
        bonusProposerReward: (0, m.isSet)(p.bonusProposerReward) ? String(p.bonusProposerReward) : "",
        withdrawAddrEnabled: (0, m.isSet)(p.withdrawAddrEnabled) ? !!p.withdrawAddrEnabled : !1
      };
    },
    toJSON(p) {
      const h = {};
      return p.communityTax !== void 0 && (h.communityTax = p.communityTax), p.baseProposerReward !== void 0 && (h.baseProposerReward = p.baseProposerReward), p.bonusProposerReward !== void 0 && (h.bonusProposerReward = p.bonusProposerReward), p.withdrawAddrEnabled !== void 0 && (h.withdrawAddrEnabled = p.withdrawAddrEnabled), h;
    },
    fromPartial(p) {
      const h = b();
      return h.communityTax = p.communityTax ?? "", h.baseProposerReward = p.baseProposerReward ?? "", h.bonusProposerReward = p.bonusProposerReward ?? "", h.withdrawAddrEnabled = p.withdrawAddrEnabled ?? !1, h;
    }
  };
  function R() {
    return {
      cumulativeRewardRatio: [],
      referenceCount: 0
    };
  }
  e.ValidatorHistoricalRewards = {
    encode(p, h = f.Writer.create()) {
      for (const x of p.cumulativeRewardRatio)
        r.DecCoin.encode(x, h.uint32(10).fork()).ldelim();
      return p.referenceCount !== 0 && h.uint32(16).uint32(p.referenceCount), h;
    },
    decode(p, h) {
      const x = p instanceof f.Reader ? p : new f.Reader(p);
      let _ = h === void 0 ? x.len : x.pos + h;
      const I = R();
      for (; x.pos < _; ) {
        const W = x.uint32();
        switch (W >>> 3) {
          case 1:
            I.cumulativeRewardRatio.push(r.DecCoin.decode(x, x.uint32()));
            break;
          case 2:
            I.referenceCount = x.uint32();
            break;
          default:
            x.skipType(W & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        cumulativeRewardRatio: Array.isArray(p == null ? void 0 : p.cumulativeRewardRatio) ? p.cumulativeRewardRatio.map((h) => r.DecCoin.fromJSON(h)) : [],
        referenceCount: (0, m.isSet)(p.referenceCount) ? Number(p.referenceCount) : 0
      };
    },
    toJSON(p) {
      const h = {};
      return p.cumulativeRewardRatio ? h.cumulativeRewardRatio = p.cumulativeRewardRatio.map((x) => x ? r.DecCoin.toJSON(x) : void 0) : h.cumulativeRewardRatio = [], p.referenceCount !== void 0 && (h.referenceCount = Math.round(p.referenceCount)), h;
    },
    fromPartial(p) {
      var h;
      const x = R();
      return x.cumulativeRewardRatio = ((h = p.cumulativeRewardRatio) == null ? void 0 : h.map((_) => r.DecCoin.fromPartial(_))) || [], x.referenceCount = p.referenceCount ?? 0, x;
    }
  };
  function T() {
    return {
      rewards: [],
      period: m.Long.UZERO
    };
  }
  e.ValidatorCurrentRewards = {
    encode(p, h = f.Writer.create()) {
      for (const x of p.rewards)
        r.DecCoin.encode(x, h.uint32(10).fork()).ldelim();
      return p.period.isZero() || h.uint32(16).uint64(p.period), h;
    },
    decode(p, h) {
      const x = p instanceof f.Reader ? p : new f.Reader(p);
      let _ = h === void 0 ? x.len : x.pos + h;
      const I = T();
      for (; x.pos < _; ) {
        const W = x.uint32();
        switch (W >>> 3) {
          case 1:
            I.rewards.push(r.DecCoin.decode(x, x.uint32()));
            break;
          case 2:
            I.period = x.uint64();
            break;
          default:
            x.skipType(W & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        rewards: Array.isArray(p == null ? void 0 : p.rewards) ? p.rewards.map((h) => r.DecCoin.fromJSON(h)) : [],
        period: (0, m.isSet)(p.period) ? m.Long.fromValue(p.period) : m.Long.UZERO
      };
    },
    toJSON(p) {
      const h = {};
      return p.rewards ? h.rewards = p.rewards.map((x) => x ? r.DecCoin.toJSON(x) : void 0) : h.rewards = [], p.period !== void 0 && (h.period = (p.period || m.Long.UZERO).toString()), h;
    },
    fromPartial(p) {
      var h;
      const x = T();
      return x.rewards = ((h = p.rewards) == null ? void 0 : h.map((_) => r.DecCoin.fromPartial(_))) || [], x.period = p.period !== void 0 && p.period !== null ? m.Long.fromValue(p.period) : m.Long.UZERO, x;
    }
  };
  function V() {
    return {
      commission: []
    };
  }
  e.ValidatorAccumulatedCommission = {
    encode(p, h = f.Writer.create()) {
      for (const x of p.commission)
        r.DecCoin.encode(x, h.uint32(10).fork()).ldelim();
      return h;
    },
    decode(p, h) {
      const x = p instanceof f.Reader ? p : new f.Reader(p);
      let _ = h === void 0 ? x.len : x.pos + h;
      const I = V();
      for (; x.pos < _; ) {
        const W = x.uint32();
        switch (W >>> 3) {
          case 1:
            I.commission.push(r.DecCoin.decode(x, x.uint32()));
            break;
          default:
            x.skipType(W & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        commission: Array.isArray(p == null ? void 0 : p.commission) ? p.commission.map((h) => r.DecCoin.fromJSON(h)) : []
      };
    },
    toJSON(p) {
      const h = {};
      return p.commission ? h.commission = p.commission.map((x) => x ? r.DecCoin.toJSON(x) : void 0) : h.commission = [], h;
    },
    fromPartial(p) {
      var h;
      const x = V();
      return x.commission = ((h = p.commission) == null ? void 0 : h.map((_) => r.DecCoin.fromPartial(_))) || [], x;
    }
  };
  function D() {
    return {
      rewards: []
    };
  }
  e.ValidatorOutstandingRewards = {
    encode(p, h = f.Writer.create()) {
      for (const x of p.rewards)
        r.DecCoin.encode(x, h.uint32(10).fork()).ldelim();
      return h;
    },
    decode(p, h) {
      const x = p instanceof f.Reader ? p : new f.Reader(p);
      let _ = h === void 0 ? x.len : x.pos + h;
      const I = D();
      for (; x.pos < _; ) {
        const W = x.uint32();
        switch (W >>> 3) {
          case 1:
            I.rewards.push(r.DecCoin.decode(x, x.uint32()));
            break;
          default:
            x.skipType(W & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        rewards: Array.isArray(p == null ? void 0 : p.rewards) ? p.rewards.map((h) => r.DecCoin.fromJSON(h)) : []
      };
    },
    toJSON(p) {
      const h = {};
      return p.rewards ? h.rewards = p.rewards.map((x) => x ? r.DecCoin.toJSON(x) : void 0) : h.rewards = [], h;
    },
    fromPartial(p) {
      var h;
      const x = D();
      return x.rewards = ((h = p.rewards) == null ? void 0 : h.map((_) => r.DecCoin.fromPartial(_))) || [], x;
    }
  };
  function B() {
    return {
      validatorPeriod: m.Long.UZERO,
      fraction: ""
    };
  }
  e.ValidatorSlashEvent = {
    encode(p, h = f.Writer.create()) {
      return p.validatorPeriod.isZero() || h.uint32(8).uint64(p.validatorPeriod), p.fraction !== "" && h.uint32(18).string(p.fraction), h;
    },
    decode(p, h) {
      const x = p instanceof f.Reader ? p : new f.Reader(p);
      let _ = h === void 0 ? x.len : x.pos + h;
      const I = B();
      for (; x.pos < _; ) {
        const W = x.uint32();
        switch (W >>> 3) {
          case 1:
            I.validatorPeriod = x.uint64();
            break;
          case 2:
            I.fraction = x.string();
            break;
          default:
            x.skipType(W & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        validatorPeriod: (0, m.isSet)(p.validatorPeriod) ? m.Long.fromValue(p.validatorPeriod) : m.Long.UZERO,
        fraction: (0, m.isSet)(p.fraction) ? String(p.fraction) : ""
      };
    },
    toJSON(p) {
      const h = {};
      return p.validatorPeriod !== void 0 && (h.validatorPeriod = (p.validatorPeriod || m.Long.UZERO).toString()), p.fraction !== void 0 && (h.fraction = p.fraction), h;
    },
    fromPartial(p) {
      const h = B();
      return h.validatorPeriod = p.validatorPeriod !== void 0 && p.validatorPeriod !== null ? m.Long.fromValue(p.validatorPeriod) : m.Long.UZERO, h.fraction = p.fraction ?? "", h;
    }
  };
  function U() {
    return {
      validatorSlashEvents: []
    };
  }
  e.ValidatorSlashEvents = {
    encode(p, h = f.Writer.create()) {
      for (const x of p.validatorSlashEvents)
        e.ValidatorSlashEvent.encode(x, h.uint32(10).fork()).ldelim();
      return h;
    },
    decode(p, h) {
      const x = p instanceof f.Reader ? p : new f.Reader(p);
      let _ = h === void 0 ? x.len : x.pos + h;
      const I = U();
      for (; x.pos < _; ) {
        const W = x.uint32();
        switch (W >>> 3) {
          case 1:
            I.validatorSlashEvents.push(e.ValidatorSlashEvent.decode(x, x.uint32()));
            break;
          default:
            x.skipType(W & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        validatorSlashEvents: Array.isArray(p == null ? void 0 : p.validatorSlashEvents) ? p.validatorSlashEvents.map((h) => e.ValidatorSlashEvent.fromJSON(h)) : []
      };
    },
    toJSON(p) {
      const h = {};
      return p.validatorSlashEvents ? h.validatorSlashEvents = p.validatorSlashEvents.map((x) => x ? e.ValidatorSlashEvent.toJSON(x) : void 0) : h.validatorSlashEvents = [], h;
    },
    fromPartial(p) {
      var h;
      const x = U();
      return x.validatorSlashEvents = ((h = p.validatorSlashEvents) == null ? void 0 : h.map((_) => e.ValidatorSlashEvent.fromPartial(_))) || [], x;
    }
  };
  function C() {
    return {
      communityPool: []
    };
  }
  e.FeePool = {
    encode(p, h = f.Writer.create()) {
      for (const x of p.communityPool)
        r.DecCoin.encode(x, h.uint32(10).fork()).ldelim();
      return h;
    },
    decode(p, h) {
      const x = p instanceof f.Reader ? p : new f.Reader(p);
      let _ = h === void 0 ? x.len : x.pos + h;
      const I = C();
      for (; x.pos < _; ) {
        const W = x.uint32();
        switch (W >>> 3) {
          case 1:
            I.communityPool.push(r.DecCoin.decode(x, x.uint32()));
            break;
          default:
            x.skipType(W & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        communityPool: Array.isArray(p == null ? void 0 : p.communityPool) ? p.communityPool.map((h) => r.DecCoin.fromJSON(h)) : []
      };
    },
    toJSON(p) {
      const h = {};
      return p.communityPool ? h.communityPool = p.communityPool.map((x) => x ? r.DecCoin.toJSON(x) : void 0) : h.communityPool = [], h;
    },
    fromPartial(p) {
      var h;
      const x = C();
      return x.communityPool = ((h = p.communityPool) == null ? void 0 : h.map((_) => r.DecCoin.fromPartial(_))) || [], x;
    }
  };
  function l() {
    return {
      title: "",
      description: "",
      recipient: "",
      amount: []
    };
  }
  e.CommunityPoolSpendProposal = {
    encode(p, h = f.Writer.create()) {
      p.title !== "" && h.uint32(10).string(p.title), p.description !== "" && h.uint32(18).string(p.description), p.recipient !== "" && h.uint32(26).string(p.recipient);
      for (const x of p.amount)
        r.Coin.encode(x, h.uint32(34).fork()).ldelim();
      return h;
    },
    decode(p, h) {
      const x = p instanceof f.Reader ? p : new f.Reader(p);
      let _ = h === void 0 ? x.len : x.pos + h;
      const I = l();
      for (; x.pos < _; ) {
        const W = x.uint32();
        switch (W >>> 3) {
          case 1:
            I.title = x.string();
            break;
          case 2:
            I.description = x.string();
            break;
          case 3:
            I.recipient = x.string();
            break;
          case 4:
            I.amount.push(r.Coin.decode(x, x.uint32()));
            break;
          default:
            x.skipType(W & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        title: (0, m.isSet)(p.title) ? String(p.title) : "",
        description: (0, m.isSet)(p.description) ? String(p.description) : "",
        recipient: (0, m.isSet)(p.recipient) ? String(p.recipient) : "",
        amount: Array.isArray(p == null ? void 0 : p.amount) ? p.amount.map((h) => r.Coin.fromJSON(h)) : []
      };
    },
    toJSON(p) {
      const h = {};
      return p.title !== void 0 && (h.title = p.title), p.description !== void 0 && (h.description = p.description), p.recipient !== void 0 && (h.recipient = p.recipient), p.amount ? h.amount = p.amount.map((x) => x ? r.Coin.toJSON(x) : void 0) : h.amount = [], h;
    },
    fromPartial(p) {
      var h;
      const x = l();
      return x.title = p.title ?? "", x.description = p.description ?? "", x.recipient = p.recipient ?? "", x.amount = ((h = p.amount) == null ? void 0 : h.map((_) => r.Coin.fromPartial(_))) || [], x;
    }
  };
  function S() {
    return {
      previousPeriod: m.Long.UZERO,
      stake: "",
      height: m.Long.UZERO
    };
  }
  e.DelegatorStartingInfo = {
    encode(p, h = f.Writer.create()) {
      return p.previousPeriod.isZero() || h.uint32(8).uint64(p.previousPeriod), p.stake !== "" && h.uint32(18).string(p.stake), p.height.isZero() || h.uint32(24).uint64(p.height), h;
    },
    decode(p, h) {
      const x = p instanceof f.Reader ? p : new f.Reader(p);
      let _ = h === void 0 ? x.len : x.pos + h;
      const I = S();
      for (; x.pos < _; ) {
        const W = x.uint32();
        switch (W >>> 3) {
          case 1:
            I.previousPeriod = x.uint64();
            break;
          case 2:
            I.stake = x.string();
            break;
          case 3:
            I.height = x.uint64();
            break;
          default:
            x.skipType(W & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        previousPeriod: (0, m.isSet)(p.previousPeriod) ? m.Long.fromValue(p.previousPeriod) : m.Long.UZERO,
        stake: (0, m.isSet)(p.stake) ? String(p.stake) : "",
        height: (0, m.isSet)(p.height) ? m.Long.fromValue(p.height) : m.Long.UZERO
      };
    },
    toJSON(p) {
      const h = {};
      return p.previousPeriod !== void 0 && (h.previousPeriod = (p.previousPeriod || m.Long.UZERO).toString()), p.stake !== void 0 && (h.stake = p.stake), p.height !== void 0 && (h.height = (p.height || m.Long.UZERO).toString()), h;
    },
    fromPartial(p) {
      const h = S();
      return h.previousPeriod = p.previousPeriod !== void 0 && p.previousPeriod !== null ? m.Long.fromValue(p.previousPeriod) : m.Long.UZERO, h.stake = p.stake ?? "", h.height = p.height !== void 0 && p.height !== null ? m.Long.fromValue(p.height) : m.Long.UZERO, h;
    }
  };
  function A() {
    return {
      validatorAddress: "",
      reward: []
    };
  }
  e.DelegationDelegatorReward = {
    encode(p, h = f.Writer.create()) {
      p.validatorAddress !== "" && h.uint32(10).string(p.validatorAddress);
      for (const x of p.reward)
        r.DecCoin.encode(x, h.uint32(18).fork()).ldelim();
      return h;
    },
    decode(p, h) {
      const x = p instanceof f.Reader ? p : new f.Reader(p);
      let _ = h === void 0 ? x.len : x.pos + h;
      const I = A();
      for (; x.pos < _; ) {
        const W = x.uint32();
        switch (W >>> 3) {
          case 1:
            I.validatorAddress = x.string();
            break;
          case 2:
            I.reward.push(r.DecCoin.decode(x, x.uint32()));
            break;
          default:
            x.skipType(W & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        validatorAddress: (0, m.isSet)(p.validatorAddress) ? String(p.validatorAddress) : "",
        reward: Array.isArray(p == null ? void 0 : p.reward) ? p.reward.map((h) => r.DecCoin.fromJSON(h)) : []
      };
    },
    toJSON(p) {
      const h = {};
      return p.validatorAddress !== void 0 && (h.validatorAddress = p.validatorAddress), p.reward ? h.reward = p.reward.map((x) => x ? r.DecCoin.toJSON(x) : void 0) : h.reward = [], h;
    },
    fromPartial(p) {
      var h;
      const x = A();
      return x.validatorAddress = p.validatorAddress ?? "", x.reward = ((h = p.reward) == null ? void 0 : h.map((_) => r.DecCoin.fromPartial(_))) || [], x;
    }
  };
  function d() {
    return {
      title: "",
      description: "",
      recipient: "",
      amount: "",
      deposit: ""
    };
  }
  e.CommunityPoolSpendProposalWithDeposit = {
    encode(p, h = f.Writer.create()) {
      return p.title !== "" && h.uint32(10).string(p.title), p.description !== "" && h.uint32(18).string(p.description), p.recipient !== "" && h.uint32(26).string(p.recipient), p.amount !== "" && h.uint32(34).string(p.amount), p.deposit !== "" && h.uint32(42).string(p.deposit), h;
    },
    decode(p, h) {
      const x = p instanceof f.Reader ? p : new f.Reader(p);
      let _ = h === void 0 ? x.len : x.pos + h;
      const I = d();
      for (; x.pos < _; ) {
        const W = x.uint32();
        switch (W >>> 3) {
          case 1:
            I.title = x.string();
            break;
          case 2:
            I.description = x.string();
            break;
          case 3:
            I.recipient = x.string();
            break;
          case 4:
            I.amount = x.string();
            break;
          case 5:
            I.deposit = x.string();
            break;
          default:
            x.skipType(W & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        title: (0, m.isSet)(p.title) ? String(p.title) : "",
        description: (0, m.isSet)(p.description) ? String(p.description) : "",
        recipient: (0, m.isSet)(p.recipient) ? String(p.recipient) : "",
        amount: (0, m.isSet)(p.amount) ? String(p.amount) : "",
        deposit: (0, m.isSet)(p.deposit) ? String(p.deposit) : ""
      };
    },
    toJSON(p) {
      const h = {};
      return p.title !== void 0 && (h.title = p.title), p.description !== void 0 && (h.description = p.description), p.recipient !== void 0 && (h.recipient = p.recipient), p.amount !== void 0 && (h.amount = p.amount), p.deposit !== void 0 && (h.deposit = p.deposit), h;
    },
    fromPartial(p) {
      const h = d();
      return h.title = p.title ?? "", h.description = p.description ?? "", h.recipient = p.recipient ?? "", h.amount = p.amount ?? "", h.deposit = p.deposit ?? "", h;
    }
  };
})(zi);
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(x, _, I, W) {
    W === void 0 && (W = I);
    var n = Object.getOwnPropertyDescriptor(_, I);
    (!n || ("get" in n ? !_.__esModule : n.writable || n.configurable)) && (n = { enumerable: !0, get: function() {
      return _[I];
    } }), Object.defineProperty(x, W, n);
  } : function(x, _, I, W) {
    W === void 0 && (W = I), x[W] = _[I];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(x, _) {
    Object.defineProperty(x, "default", { enumerable: !0, value: _ });
  } : function(x, _) {
    x.default = _;
  }), u = Q && Q.__importStar || function(x) {
    if (x && x.__esModule)
      return x;
    var _ = {};
    if (x != null)
      for (var I in x)
        I !== "default" && Object.prototype.hasOwnProperty.call(x, I) && o(_, x, I);
    return t(_, x), _;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgCommunityPoolSpendResponse = e.MsgCommunityPoolSpend = e.MsgUpdateParamsResponse = e.MsgUpdateParams = e.MsgFundCommunityPoolResponse = e.MsgFundCommunityPool = e.MsgWithdrawValidatorCommissionResponse = e.MsgWithdrawValidatorCommission = e.MsgWithdrawDelegatorRewardResponse = e.MsgWithdrawDelegatorReward = e.MsgSetWithdrawAddressResponse = e.MsgSetWithdrawAddress = e.protobufPackage = void 0;
  const r = Le, m = zi, f = u(re), b = ie;
  e.protobufPackage = "cosmos.distribution.v1beta1";
  function R() {
    return {
      delegatorAddress: "",
      withdrawAddress: ""
    };
  }
  e.MsgSetWithdrawAddress = {
    encode(x, _ = f.Writer.create()) {
      return x.delegatorAddress !== "" && _.uint32(10).string(x.delegatorAddress), x.withdrawAddress !== "" && _.uint32(18).string(x.withdrawAddress), _;
    },
    decode(x, _) {
      const I = x instanceof f.Reader ? x : new f.Reader(x);
      let W = _ === void 0 ? I.len : I.pos + _;
      const n = R();
      for (; I.pos < W; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          case 1:
            n.delegatorAddress = I.string();
            break;
          case 2:
            n.withdrawAddress = I.string();
            break;
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return n;
    },
    fromJSON(x) {
      return {
        delegatorAddress: (0, b.isSet)(x.delegatorAddress) ? String(x.delegatorAddress) : "",
        withdrawAddress: (0, b.isSet)(x.withdrawAddress) ? String(x.withdrawAddress) : ""
      };
    },
    toJSON(x) {
      const _ = {};
      return x.delegatorAddress !== void 0 && (_.delegatorAddress = x.delegatorAddress), x.withdrawAddress !== void 0 && (_.withdrawAddress = x.withdrawAddress), _;
    },
    fromPartial(x) {
      const _ = R();
      return _.delegatorAddress = x.delegatorAddress ?? "", _.withdrawAddress = x.withdrawAddress ?? "", _;
    }
  };
  function T() {
    return {};
  }
  e.MsgSetWithdrawAddressResponse = {
    encode(x, _ = f.Writer.create()) {
      return _;
    },
    decode(x, _) {
      const I = x instanceof f.Reader ? x : new f.Reader(x);
      let W = _ === void 0 ? I.len : I.pos + _;
      const n = T();
      for (; I.pos < W; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return n;
    },
    fromJSON(x) {
      return {};
    },
    toJSON(x) {
      return {};
    },
    fromPartial(x) {
      return T();
    }
  };
  function V() {
    return {
      delegatorAddress: "",
      validatorAddress: ""
    };
  }
  e.MsgWithdrawDelegatorReward = {
    encode(x, _ = f.Writer.create()) {
      return x.delegatorAddress !== "" && _.uint32(10).string(x.delegatorAddress), x.validatorAddress !== "" && _.uint32(18).string(x.validatorAddress), _;
    },
    decode(x, _) {
      const I = x instanceof f.Reader ? x : new f.Reader(x);
      let W = _ === void 0 ? I.len : I.pos + _;
      const n = V();
      for (; I.pos < W; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          case 1:
            n.delegatorAddress = I.string();
            break;
          case 2:
            n.validatorAddress = I.string();
            break;
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return n;
    },
    fromJSON(x) {
      return {
        delegatorAddress: (0, b.isSet)(x.delegatorAddress) ? String(x.delegatorAddress) : "",
        validatorAddress: (0, b.isSet)(x.validatorAddress) ? String(x.validatorAddress) : ""
      };
    },
    toJSON(x) {
      const _ = {};
      return x.delegatorAddress !== void 0 && (_.delegatorAddress = x.delegatorAddress), x.validatorAddress !== void 0 && (_.validatorAddress = x.validatorAddress), _;
    },
    fromPartial(x) {
      const _ = V();
      return _.delegatorAddress = x.delegatorAddress ?? "", _.validatorAddress = x.validatorAddress ?? "", _;
    }
  };
  function D() {
    return {
      amount: []
    };
  }
  e.MsgWithdrawDelegatorRewardResponse = {
    encode(x, _ = f.Writer.create()) {
      for (const I of x.amount)
        r.Coin.encode(I, _.uint32(10).fork()).ldelim();
      return _;
    },
    decode(x, _) {
      const I = x instanceof f.Reader ? x : new f.Reader(x);
      let W = _ === void 0 ? I.len : I.pos + _;
      const n = D();
      for (; I.pos < W; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          case 1:
            n.amount.push(r.Coin.decode(I, I.uint32()));
            break;
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return n;
    },
    fromJSON(x) {
      return {
        amount: Array.isArray(x == null ? void 0 : x.amount) ? x.amount.map((_) => r.Coin.fromJSON(_)) : []
      };
    },
    toJSON(x) {
      const _ = {};
      return x.amount ? _.amount = x.amount.map((I) => I ? r.Coin.toJSON(I) : void 0) : _.amount = [], _;
    },
    fromPartial(x) {
      var _;
      const I = D();
      return I.amount = ((_ = x.amount) == null ? void 0 : _.map((W) => r.Coin.fromPartial(W))) || [], I;
    }
  };
  function B() {
    return {
      validatorAddress: ""
    };
  }
  e.MsgWithdrawValidatorCommission = {
    encode(x, _ = f.Writer.create()) {
      return x.validatorAddress !== "" && _.uint32(10).string(x.validatorAddress), _;
    },
    decode(x, _) {
      const I = x instanceof f.Reader ? x : new f.Reader(x);
      let W = _ === void 0 ? I.len : I.pos + _;
      const n = B();
      for (; I.pos < W; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          case 1:
            n.validatorAddress = I.string();
            break;
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return n;
    },
    fromJSON(x) {
      return {
        validatorAddress: (0, b.isSet)(x.validatorAddress) ? String(x.validatorAddress) : ""
      };
    },
    toJSON(x) {
      const _ = {};
      return x.validatorAddress !== void 0 && (_.validatorAddress = x.validatorAddress), _;
    },
    fromPartial(x) {
      const _ = B();
      return _.validatorAddress = x.validatorAddress ?? "", _;
    }
  };
  function U() {
    return {
      amount: []
    };
  }
  e.MsgWithdrawValidatorCommissionResponse = {
    encode(x, _ = f.Writer.create()) {
      for (const I of x.amount)
        r.Coin.encode(I, _.uint32(10).fork()).ldelim();
      return _;
    },
    decode(x, _) {
      const I = x instanceof f.Reader ? x : new f.Reader(x);
      let W = _ === void 0 ? I.len : I.pos + _;
      const n = U();
      for (; I.pos < W; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          case 1:
            n.amount.push(r.Coin.decode(I, I.uint32()));
            break;
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return n;
    },
    fromJSON(x) {
      return {
        amount: Array.isArray(x == null ? void 0 : x.amount) ? x.amount.map((_) => r.Coin.fromJSON(_)) : []
      };
    },
    toJSON(x) {
      const _ = {};
      return x.amount ? _.amount = x.amount.map((I) => I ? r.Coin.toJSON(I) : void 0) : _.amount = [], _;
    },
    fromPartial(x) {
      var _;
      const I = U();
      return I.amount = ((_ = x.amount) == null ? void 0 : _.map((W) => r.Coin.fromPartial(W))) || [], I;
    }
  };
  function C() {
    return {
      amount: [],
      depositor: ""
    };
  }
  e.MsgFundCommunityPool = {
    encode(x, _ = f.Writer.create()) {
      for (const I of x.amount)
        r.Coin.encode(I, _.uint32(10).fork()).ldelim();
      return x.depositor !== "" && _.uint32(18).string(x.depositor), _;
    },
    decode(x, _) {
      const I = x instanceof f.Reader ? x : new f.Reader(x);
      let W = _ === void 0 ? I.len : I.pos + _;
      const n = C();
      for (; I.pos < W; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          case 1:
            n.amount.push(r.Coin.decode(I, I.uint32()));
            break;
          case 2:
            n.depositor = I.string();
            break;
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return n;
    },
    fromJSON(x) {
      return {
        amount: Array.isArray(x == null ? void 0 : x.amount) ? x.amount.map((_) => r.Coin.fromJSON(_)) : [],
        depositor: (0, b.isSet)(x.depositor) ? String(x.depositor) : ""
      };
    },
    toJSON(x) {
      const _ = {};
      return x.amount ? _.amount = x.amount.map((I) => I ? r.Coin.toJSON(I) : void 0) : _.amount = [], x.depositor !== void 0 && (_.depositor = x.depositor), _;
    },
    fromPartial(x) {
      var _;
      const I = C();
      return I.amount = ((_ = x.amount) == null ? void 0 : _.map((W) => r.Coin.fromPartial(W))) || [], I.depositor = x.depositor ?? "", I;
    }
  };
  function l() {
    return {};
  }
  e.MsgFundCommunityPoolResponse = {
    encode(x, _ = f.Writer.create()) {
      return _;
    },
    decode(x, _) {
      const I = x instanceof f.Reader ? x : new f.Reader(x);
      let W = _ === void 0 ? I.len : I.pos + _;
      const n = l();
      for (; I.pos < W; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return n;
    },
    fromJSON(x) {
      return {};
    },
    toJSON(x) {
      return {};
    },
    fromPartial(x) {
      return l();
    }
  };
  function S() {
    return {
      authority: "",
      params: void 0
    };
  }
  e.MsgUpdateParams = {
    encode(x, _ = f.Writer.create()) {
      return x.authority !== "" && _.uint32(10).string(x.authority), x.params !== void 0 && m.Params.encode(x.params, _.uint32(18).fork()).ldelim(), _;
    },
    decode(x, _) {
      const I = x instanceof f.Reader ? x : new f.Reader(x);
      let W = _ === void 0 ? I.len : I.pos + _;
      const n = S();
      for (; I.pos < W; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          case 1:
            n.authority = I.string();
            break;
          case 2:
            n.params = m.Params.decode(I, I.uint32());
            break;
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return n;
    },
    fromJSON(x) {
      return {
        authority: (0, b.isSet)(x.authority) ? String(x.authority) : "",
        params: (0, b.isSet)(x.params) ? m.Params.fromJSON(x.params) : void 0
      };
    },
    toJSON(x) {
      const _ = {};
      return x.authority !== void 0 && (_.authority = x.authority), x.params !== void 0 && (_.params = x.params ? m.Params.toJSON(x.params) : void 0), _;
    },
    fromPartial(x) {
      const _ = S();
      return _.authority = x.authority ?? "", _.params = x.params !== void 0 && x.params !== null ? m.Params.fromPartial(x.params) : void 0, _;
    }
  };
  function A() {
    return {};
  }
  e.MsgUpdateParamsResponse = {
    encode(x, _ = f.Writer.create()) {
      return _;
    },
    decode(x, _) {
      const I = x instanceof f.Reader ? x : new f.Reader(x);
      let W = _ === void 0 ? I.len : I.pos + _;
      const n = A();
      for (; I.pos < W; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return n;
    },
    fromJSON(x) {
      return {};
    },
    toJSON(x) {
      return {};
    },
    fromPartial(x) {
      return A();
    }
  };
  function d() {
    return {
      authority: "",
      recipient: "",
      amount: []
    };
  }
  e.MsgCommunityPoolSpend = {
    encode(x, _ = f.Writer.create()) {
      x.authority !== "" && _.uint32(10).string(x.authority), x.recipient !== "" && _.uint32(18).string(x.recipient);
      for (const I of x.amount)
        r.Coin.encode(I, _.uint32(26).fork()).ldelim();
      return _;
    },
    decode(x, _) {
      const I = x instanceof f.Reader ? x : new f.Reader(x);
      let W = _ === void 0 ? I.len : I.pos + _;
      const n = d();
      for (; I.pos < W; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          case 1:
            n.authority = I.string();
            break;
          case 2:
            n.recipient = I.string();
            break;
          case 3:
            n.amount.push(r.Coin.decode(I, I.uint32()));
            break;
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return n;
    },
    fromJSON(x) {
      return {
        authority: (0, b.isSet)(x.authority) ? String(x.authority) : "",
        recipient: (0, b.isSet)(x.recipient) ? String(x.recipient) : "",
        amount: Array.isArray(x == null ? void 0 : x.amount) ? x.amount.map((_) => r.Coin.fromJSON(_)) : []
      };
    },
    toJSON(x) {
      const _ = {};
      return x.authority !== void 0 && (_.authority = x.authority), x.recipient !== void 0 && (_.recipient = x.recipient), x.amount ? _.amount = x.amount.map((I) => I ? r.Coin.toJSON(I) : void 0) : _.amount = [], _;
    },
    fromPartial(x) {
      var _;
      const I = d();
      return I.authority = x.authority ?? "", I.recipient = x.recipient ?? "", I.amount = ((_ = x.amount) == null ? void 0 : _.map((W) => r.Coin.fromPartial(W))) || [], I;
    }
  };
  function p() {
    return {};
  }
  e.MsgCommunityPoolSpendResponse = {
    encode(x, _ = f.Writer.create()) {
      return _;
    },
    decode(x, _) {
      const I = x instanceof f.Reader ? x : new f.Reader(x);
      let W = _ === void 0 ? I.len : I.pos + _;
      const n = p();
      for (; I.pos < W; ) {
        const y = I.uint32();
        switch (y >>> 3) {
          default:
            I.skipType(y & 7);
            break;
        }
      }
      return n;
    },
    fromJSON(x) {
      return {};
    },
    toJSON(x) {
      return {};
    },
    fromPartial(x) {
      return p();
    }
  };
  class h {
    constructor(_) {
      this.rpc = _, this.SetWithdrawAddress = this.SetWithdrawAddress.bind(this), this.WithdrawDelegatorReward = this.WithdrawDelegatorReward.bind(this), this.WithdrawValidatorCommission = this.WithdrawValidatorCommission.bind(this), this.FundCommunityPool = this.FundCommunityPool.bind(this), this.UpdateParams = this.UpdateParams.bind(this), this.CommunityPoolSpend = this.CommunityPoolSpend.bind(this);
    }
    SetWithdrawAddress(_) {
      const I = e.MsgSetWithdrawAddress.encode(_).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "SetWithdrawAddress", I).then((W) => e.MsgSetWithdrawAddressResponse.decode(new f.Reader(W)));
    }
    WithdrawDelegatorReward(_) {
      const I = e.MsgWithdrawDelegatorReward.encode(_).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawDelegatorReward", I).then((W) => e.MsgWithdrawDelegatorRewardResponse.decode(new f.Reader(W)));
    }
    WithdrawValidatorCommission(_) {
      const I = e.MsgWithdrawValidatorCommission.encode(_).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawValidatorCommission", I).then((W) => e.MsgWithdrawValidatorCommissionResponse.decode(new f.Reader(W)));
    }
    FundCommunityPool(_) {
      const I = e.MsgFundCommunityPool.encode(_).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "FundCommunityPool", I).then((W) => e.MsgFundCommunityPoolResponse.decode(new f.Reader(W)));
    }
    UpdateParams(_) {
      const I = e.MsgUpdateParams.encode(_).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "UpdateParams", I).then((W) => e.MsgUpdateParamsResponse.decode(new f.Reader(W)));
    }
    CommunityPoolSpend(_) {
      const I = e.MsgCommunityPoolSpend.encode(_).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "CommunityPoolSpend", I).then((W) => e.MsgCommunityPoolSpendResponse.decode(new f.Reader(W)));
    }
  }
  e.MsgClientImpl = h;
})(Ki);
Object.defineProperty(En, "__esModule", { value: !0 });
En.isMsgWithdrawDelegatorRewardEncodeObject = En.distributionTypes = void 0;
const go = Ki;
En.distributionTypes = [
  ["/cosmos.distribution.v1beta1.MsgFundCommunityPool", go.MsgFundCommunityPool],
  ["/cosmos.distribution.v1beta1.MsgSetWithdrawAddress", go.MsgSetWithdrawAddress],
  ["/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward", go.MsgWithdrawDelegatorReward],
  ["/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission", go.MsgWithdrawValidatorCommission]
];
function $f(e) {
  return e.typeUrl === "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward";
}
En.isMsgWithdrawDelegatorRewardEncodeObject = $f;
var nr = {}, mc = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(c, E, k, O) {
    O === void 0 && (O = k);
    var L = Object.getOwnPropertyDescriptor(E, k);
    (!L || ("get" in L ? !E.__esModule : L.writable || L.configurable)) && (L = { enumerable: !0, get: function() {
      return E[k];
    } }), Object.defineProperty(c, O, L);
  } : function(c, E, k, O) {
    O === void 0 && (O = k), c[O] = E[k];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(c, E) {
    Object.defineProperty(c, "default", { enumerable: !0, value: E });
  } : function(c, E) {
    c.default = E;
  }), u = Q && Q.__importStar || function(c) {
    if (c && c.__esModule)
      return c;
    var E = {};
    if (c != null)
      for (var k in c)
        k !== "default" && Object.prototype.hasOwnProperty.call(c, k) && o(E, c, k);
    return t(E, c), E;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryCommunityPoolResponse = e.QueryCommunityPoolRequest = e.QueryDelegatorWithdrawAddressResponse = e.QueryDelegatorWithdrawAddressRequest = e.QueryDelegatorValidatorsResponse = e.QueryDelegatorValidatorsRequest = e.QueryDelegationTotalRewardsResponse = e.QueryDelegationTotalRewardsRequest = e.QueryDelegationRewardsResponse = e.QueryDelegationRewardsRequest = e.QueryValidatorSlashesResponse = e.QueryValidatorSlashesRequest = e.QueryValidatorCommissionResponse = e.QueryValidatorCommissionRequest = e.QueryValidatorOutstandingRewardsResponse = e.QueryValidatorOutstandingRewardsRequest = e.QueryValidatorDistributionInfoResponse = e.QueryValidatorDistributionInfoRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.protobufPackage = void 0;
  const r = be, m = zi, f = Le, b = ie, R = u(re);
  e.protobufPackage = "cosmos.distribution.v1beta1";
  function T() {
    return {};
  }
  e.QueryParamsRequest = {
    encode(c, E = R.Writer.create()) {
      return E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = T();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {};
    },
    toJSON(c) {
      return {};
    },
    fromPartial(c) {
      return T();
    }
  };
  function V() {
    return {
      params: void 0
    };
  }
  e.QueryParamsResponse = {
    encode(c, E = R.Writer.create()) {
      return c.params !== void 0 && m.Params.encode(c.params, E.uint32(10).fork()).ldelim(), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = V();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.params = m.Params.decode(k, k.uint32());
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        params: (0, b.isSet)(c.params) ? m.Params.fromJSON(c.params) : void 0
      };
    },
    toJSON(c) {
      const E = {};
      return c.params !== void 0 && (E.params = c.params ? m.Params.toJSON(c.params) : void 0), E;
    },
    fromPartial(c) {
      const E = V();
      return E.params = c.params !== void 0 && c.params !== null ? m.Params.fromPartial(c.params) : void 0, E;
    }
  };
  function D() {
    return {
      validatorAddress: ""
    };
  }
  e.QueryValidatorDistributionInfoRequest = {
    encode(c, E = R.Writer.create()) {
      return c.validatorAddress !== "" && E.uint32(10).string(c.validatorAddress), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = D();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.validatorAddress = k.string();
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        validatorAddress: (0, b.isSet)(c.validatorAddress) ? String(c.validatorAddress) : ""
      };
    },
    toJSON(c) {
      const E = {};
      return c.validatorAddress !== void 0 && (E.validatorAddress = c.validatorAddress), E;
    },
    fromPartial(c) {
      const E = D();
      return E.validatorAddress = c.validatorAddress ?? "", E;
    }
  };
  function B() {
    return {
      operatorAddress: "",
      selfBondRewards: [],
      commission: []
    };
  }
  e.QueryValidatorDistributionInfoResponse = {
    encode(c, E = R.Writer.create()) {
      c.operatorAddress !== "" && E.uint32(10).string(c.operatorAddress);
      for (const k of c.selfBondRewards)
        f.DecCoin.encode(k, E.uint32(18).fork()).ldelim();
      for (const k of c.commission)
        f.DecCoin.encode(k, E.uint32(26).fork()).ldelim();
      return E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = B();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.operatorAddress = k.string();
            break;
          case 2:
            L.selfBondRewards.push(f.DecCoin.decode(k, k.uint32()));
            break;
          case 3:
            L.commission.push(f.DecCoin.decode(k, k.uint32()));
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        operatorAddress: (0, b.isSet)(c.operatorAddress) ? String(c.operatorAddress) : "",
        selfBondRewards: Array.isArray(c == null ? void 0 : c.selfBondRewards) ? c.selfBondRewards.map((E) => f.DecCoin.fromJSON(E)) : [],
        commission: Array.isArray(c == null ? void 0 : c.commission) ? c.commission.map((E) => f.DecCoin.fromJSON(E)) : []
      };
    },
    toJSON(c) {
      const E = {};
      return c.operatorAddress !== void 0 && (E.operatorAddress = c.operatorAddress), c.selfBondRewards ? E.selfBondRewards = c.selfBondRewards.map((k) => k ? f.DecCoin.toJSON(k) : void 0) : E.selfBondRewards = [], c.commission ? E.commission = c.commission.map((k) => k ? f.DecCoin.toJSON(k) : void 0) : E.commission = [], E;
    },
    fromPartial(c) {
      var E, k;
      const O = B();
      return O.operatorAddress = c.operatorAddress ?? "", O.selfBondRewards = ((E = c.selfBondRewards) == null ? void 0 : E.map((L) => f.DecCoin.fromPartial(L))) || [], O.commission = ((k = c.commission) == null ? void 0 : k.map((L) => f.DecCoin.fromPartial(L))) || [], O;
    }
  };
  function U() {
    return {
      validatorAddress: ""
    };
  }
  e.QueryValidatorOutstandingRewardsRequest = {
    encode(c, E = R.Writer.create()) {
      return c.validatorAddress !== "" && E.uint32(10).string(c.validatorAddress), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = U();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.validatorAddress = k.string();
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        validatorAddress: (0, b.isSet)(c.validatorAddress) ? String(c.validatorAddress) : ""
      };
    },
    toJSON(c) {
      const E = {};
      return c.validatorAddress !== void 0 && (E.validatorAddress = c.validatorAddress), E;
    },
    fromPartial(c) {
      const E = U();
      return E.validatorAddress = c.validatorAddress ?? "", E;
    }
  };
  function C() {
    return {
      rewards: void 0
    };
  }
  e.QueryValidatorOutstandingRewardsResponse = {
    encode(c, E = R.Writer.create()) {
      return c.rewards !== void 0 && m.ValidatorOutstandingRewards.encode(c.rewards, E.uint32(10).fork()).ldelim(), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = C();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.rewards = m.ValidatorOutstandingRewards.decode(k, k.uint32());
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        rewards: (0, b.isSet)(c.rewards) ? m.ValidatorOutstandingRewards.fromJSON(c.rewards) : void 0
      };
    },
    toJSON(c) {
      const E = {};
      return c.rewards !== void 0 && (E.rewards = c.rewards ? m.ValidatorOutstandingRewards.toJSON(c.rewards) : void 0), E;
    },
    fromPartial(c) {
      const E = C();
      return E.rewards = c.rewards !== void 0 && c.rewards !== null ? m.ValidatorOutstandingRewards.fromPartial(c.rewards) : void 0, E;
    }
  };
  function l() {
    return {
      validatorAddress: ""
    };
  }
  e.QueryValidatorCommissionRequest = {
    encode(c, E = R.Writer.create()) {
      return c.validatorAddress !== "" && E.uint32(10).string(c.validatorAddress), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = l();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.validatorAddress = k.string();
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        validatorAddress: (0, b.isSet)(c.validatorAddress) ? String(c.validatorAddress) : ""
      };
    },
    toJSON(c) {
      const E = {};
      return c.validatorAddress !== void 0 && (E.validatorAddress = c.validatorAddress), E;
    },
    fromPartial(c) {
      const E = l();
      return E.validatorAddress = c.validatorAddress ?? "", E;
    }
  };
  function S() {
    return {
      commission: void 0
    };
  }
  e.QueryValidatorCommissionResponse = {
    encode(c, E = R.Writer.create()) {
      return c.commission !== void 0 && m.ValidatorAccumulatedCommission.encode(c.commission, E.uint32(10).fork()).ldelim(), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = S();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.commission = m.ValidatorAccumulatedCommission.decode(k, k.uint32());
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        commission: (0, b.isSet)(c.commission) ? m.ValidatorAccumulatedCommission.fromJSON(c.commission) : void 0
      };
    },
    toJSON(c) {
      const E = {};
      return c.commission !== void 0 && (E.commission = c.commission ? m.ValidatorAccumulatedCommission.toJSON(c.commission) : void 0), E;
    },
    fromPartial(c) {
      const E = S();
      return E.commission = c.commission !== void 0 && c.commission !== null ? m.ValidatorAccumulatedCommission.fromPartial(c.commission) : void 0, E;
    }
  };
  function A() {
    return {
      validatorAddress: "",
      startingHeight: b.Long.UZERO,
      endingHeight: b.Long.UZERO,
      pagination: void 0
    };
  }
  e.QueryValidatorSlashesRequest = {
    encode(c, E = R.Writer.create()) {
      return c.validatorAddress !== "" && E.uint32(10).string(c.validatorAddress), c.startingHeight.isZero() || E.uint32(16).uint64(c.startingHeight), c.endingHeight.isZero() || E.uint32(24).uint64(c.endingHeight), c.pagination !== void 0 && r.PageRequest.encode(c.pagination, E.uint32(34).fork()).ldelim(), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = A();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.validatorAddress = k.string();
            break;
          case 2:
            L.startingHeight = k.uint64();
            break;
          case 3:
            L.endingHeight = k.uint64();
            break;
          case 4:
            L.pagination = r.PageRequest.decode(k, k.uint32());
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        validatorAddress: (0, b.isSet)(c.validatorAddress) ? String(c.validatorAddress) : "",
        startingHeight: (0, b.isSet)(c.startingHeight) ? b.Long.fromValue(c.startingHeight) : b.Long.UZERO,
        endingHeight: (0, b.isSet)(c.endingHeight) ? b.Long.fromValue(c.endingHeight) : b.Long.UZERO,
        pagination: (0, b.isSet)(c.pagination) ? r.PageRequest.fromJSON(c.pagination) : void 0
      };
    },
    toJSON(c) {
      const E = {};
      return c.validatorAddress !== void 0 && (E.validatorAddress = c.validatorAddress), c.startingHeight !== void 0 && (E.startingHeight = (c.startingHeight || b.Long.UZERO).toString()), c.endingHeight !== void 0 && (E.endingHeight = (c.endingHeight || b.Long.UZERO).toString()), c.pagination !== void 0 && (E.pagination = c.pagination ? r.PageRequest.toJSON(c.pagination) : void 0), E;
    },
    fromPartial(c) {
      const E = A();
      return E.validatorAddress = c.validatorAddress ?? "", E.startingHeight = c.startingHeight !== void 0 && c.startingHeight !== null ? b.Long.fromValue(c.startingHeight) : b.Long.UZERO, E.endingHeight = c.endingHeight !== void 0 && c.endingHeight !== null ? b.Long.fromValue(c.endingHeight) : b.Long.UZERO, E.pagination = c.pagination !== void 0 && c.pagination !== null ? r.PageRequest.fromPartial(c.pagination) : void 0, E;
    }
  };
  function d() {
    return {
      slashes: [],
      pagination: void 0
    };
  }
  e.QueryValidatorSlashesResponse = {
    encode(c, E = R.Writer.create()) {
      for (const k of c.slashes)
        m.ValidatorSlashEvent.encode(k, E.uint32(10).fork()).ldelim();
      return c.pagination !== void 0 && r.PageResponse.encode(c.pagination, E.uint32(18).fork()).ldelim(), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = d();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.slashes.push(m.ValidatorSlashEvent.decode(k, k.uint32()));
            break;
          case 2:
            L.pagination = r.PageResponse.decode(k, k.uint32());
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        slashes: Array.isArray(c == null ? void 0 : c.slashes) ? c.slashes.map((E) => m.ValidatorSlashEvent.fromJSON(E)) : [],
        pagination: (0, b.isSet)(c.pagination) ? r.PageResponse.fromJSON(c.pagination) : void 0
      };
    },
    toJSON(c) {
      const E = {};
      return c.slashes ? E.slashes = c.slashes.map((k) => k ? m.ValidatorSlashEvent.toJSON(k) : void 0) : E.slashes = [], c.pagination !== void 0 && (E.pagination = c.pagination ? r.PageResponse.toJSON(c.pagination) : void 0), E;
    },
    fromPartial(c) {
      var E;
      const k = d();
      return k.slashes = ((E = c.slashes) == null ? void 0 : E.map((O) => m.ValidatorSlashEvent.fromPartial(O))) || [], k.pagination = c.pagination !== void 0 && c.pagination !== null ? r.PageResponse.fromPartial(c.pagination) : void 0, k;
    }
  };
  function p() {
    return {
      delegatorAddress: "",
      validatorAddress: ""
    };
  }
  e.QueryDelegationRewardsRequest = {
    encode(c, E = R.Writer.create()) {
      return c.delegatorAddress !== "" && E.uint32(10).string(c.delegatorAddress), c.validatorAddress !== "" && E.uint32(18).string(c.validatorAddress), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = p();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.delegatorAddress = k.string();
            break;
          case 2:
            L.validatorAddress = k.string();
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        delegatorAddress: (0, b.isSet)(c.delegatorAddress) ? String(c.delegatorAddress) : "",
        validatorAddress: (0, b.isSet)(c.validatorAddress) ? String(c.validatorAddress) : ""
      };
    },
    toJSON(c) {
      const E = {};
      return c.delegatorAddress !== void 0 && (E.delegatorAddress = c.delegatorAddress), c.validatorAddress !== void 0 && (E.validatorAddress = c.validatorAddress), E;
    },
    fromPartial(c) {
      const E = p();
      return E.delegatorAddress = c.delegatorAddress ?? "", E.validatorAddress = c.validatorAddress ?? "", E;
    }
  };
  function h() {
    return {
      rewards: []
    };
  }
  e.QueryDelegationRewardsResponse = {
    encode(c, E = R.Writer.create()) {
      for (const k of c.rewards)
        f.DecCoin.encode(k, E.uint32(10).fork()).ldelim();
      return E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = h();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.rewards.push(f.DecCoin.decode(k, k.uint32()));
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        rewards: Array.isArray(c == null ? void 0 : c.rewards) ? c.rewards.map((E) => f.DecCoin.fromJSON(E)) : []
      };
    },
    toJSON(c) {
      const E = {};
      return c.rewards ? E.rewards = c.rewards.map((k) => k ? f.DecCoin.toJSON(k) : void 0) : E.rewards = [], E;
    },
    fromPartial(c) {
      var E;
      const k = h();
      return k.rewards = ((E = c.rewards) == null ? void 0 : E.map((O) => f.DecCoin.fromPartial(O))) || [], k;
    }
  };
  function x() {
    return {
      delegatorAddress: ""
    };
  }
  e.QueryDelegationTotalRewardsRequest = {
    encode(c, E = R.Writer.create()) {
      return c.delegatorAddress !== "" && E.uint32(10).string(c.delegatorAddress), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = x();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.delegatorAddress = k.string();
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        delegatorAddress: (0, b.isSet)(c.delegatorAddress) ? String(c.delegatorAddress) : ""
      };
    },
    toJSON(c) {
      const E = {};
      return c.delegatorAddress !== void 0 && (E.delegatorAddress = c.delegatorAddress), E;
    },
    fromPartial(c) {
      const E = x();
      return E.delegatorAddress = c.delegatorAddress ?? "", E;
    }
  };
  function _() {
    return {
      rewards: [],
      total: []
    };
  }
  e.QueryDelegationTotalRewardsResponse = {
    encode(c, E = R.Writer.create()) {
      for (const k of c.rewards)
        m.DelegationDelegatorReward.encode(k, E.uint32(10).fork()).ldelim();
      for (const k of c.total)
        f.DecCoin.encode(k, E.uint32(18).fork()).ldelim();
      return E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = _();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.rewards.push(m.DelegationDelegatorReward.decode(k, k.uint32()));
            break;
          case 2:
            L.total.push(f.DecCoin.decode(k, k.uint32()));
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        rewards: Array.isArray(c == null ? void 0 : c.rewards) ? c.rewards.map((E) => m.DelegationDelegatorReward.fromJSON(E)) : [],
        total: Array.isArray(c == null ? void 0 : c.total) ? c.total.map((E) => f.DecCoin.fromJSON(E)) : []
      };
    },
    toJSON(c) {
      const E = {};
      return c.rewards ? E.rewards = c.rewards.map((k) => k ? m.DelegationDelegatorReward.toJSON(k) : void 0) : E.rewards = [], c.total ? E.total = c.total.map((k) => k ? f.DecCoin.toJSON(k) : void 0) : E.total = [], E;
    },
    fromPartial(c) {
      var E, k;
      const O = _();
      return O.rewards = ((E = c.rewards) == null ? void 0 : E.map((L) => m.DelegationDelegatorReward.fromPartial(L))) || [], O.total = ((k = c.total) == null ? void 0 : k.map((L) => f.DecCoin.fromPartial(L))) || [], O;
    }
  };
  function I() {
    return {
      delegatorAddress: ""
    };
  }
  e.QueryDelegatorValidatorsRequest = {
    encode(c, E = R.Writer.create()) {
      return c.delegatorAddress !== "" && E.uint32(10).string(c.delegatorAddress), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = I();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.delegatorAddress = k.string();
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        delegatorAddress: (0, b.isSet)(c.delegatorAddress) ? String(c.delegatorAddress) : ""
      };
    },
    toJSON(c) {
      const E = {};
      return c.delegatorAddress !== void 0 && (E.delegatorAddress = c.delegatorAddress), E;
    },
    fromPartial(c) {
      const E = I();
      return E.delegatorAddress = c.delegatorAddress ?? "", E;
    }
  };
  function W() {
    return {
      validators: []
    };
  }
  e.QueryDelegatorValidatorsResponse = {
    encode(c, E = R.Writer.create()) {
      for (const k of c.validators)
        E.uint32(10).string(k);
      return E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = W();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.validators.push(k.string());
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        validators: Array.isArray(c == null ? void 0 : c.validators) ? c.validators.map((E) => String(E)) : []
      };
    },
    toJSON(c) {
      const E = {};
      return c.validators ? E.validators = c.validators.map((k) => k) : E.validators = [], E;
    },
    fromPartial(c) {
      var E;
      const k = W();
      return k.validators = ((E = c.validators) == null ? void 0 : E.map((O) => O)) || [], k;
    }
  };
  function n() {
    return {
      delegatorAddress: ""
    };
  }
  e.QueryDelegatorWithdrawAddressRequest = {
    encode(c, E = R.Writer.create()) {
      return c.delegatorAddress !== "" && E.uint32(10).string(c.delegatorAddress), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = n();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.delegatorAddress = k.string();
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        delegatorAddress: (0, b.isSet)(c.delegatorAddress) ? String(c.delegatorAddress) : ""
      };
    },
    toJSON(c) {
      const E = {};
      return c.delegatorAddress !== void 0 && (E.delegatorAddress = c.delegatorAddress), E;
    },
    fromPartial(c) {
      const E = n();
      return E.delegatorAddress = c.delegatorAddress ?? "", E;
    }
  };
  function y() {
    return {
      withdrawAddress: ""
    };
  }
  e.QueryDelegatorWithdrawAddressResponse = {
    encode(c, E = R.Writer.create()) {
      return c.withdrawAddress !== "" && E.uint32(10).string(c.withdrawAddress), E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = y();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.withdrawAddress = k.string();
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        withdrawAddress: (0, b.isSet)(c.withdrawAddress) ? String(c.withdrawAddress) : ""
      };
    },
    toJSON(c) {
      const E = {};
      return c.withdrawAddress !== void 0 && (E.withdrawAddress = c.withdrawAddress), E;
    },
    fromPartial(c) {
      const E = y();
      return E.withdrawAddress = c.withdrawAddress ?? "", E;
    }
  };
  function w() {
    return {};
  }
  e.QueryCommunityPoolRequest = {
    encode(c, E = R.Writer.create()) {
      return E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = w();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {};
    },
    toJSON(c) {
      return {};
    },
    fromPartial(c) {
      return w();
    }
  };
  function M() {
    return {
      pool: []
    };
  }
  e.QueryCommunityPoolResponse = {
    encode(c, E = R.Writer.create()) {
      for (const k of c.pool)
        f.DecCoin.encode(k, E.uint32(10).fork()).ldelim();
      return E;
    },
    decode(c, E) {
      const k = c instanceof R.Reader ? c : new R.Reader(c);
      let O = E === void 0 ? k.len : k.pos + E;
      const L = M();
      for (; k.pos < O; ) {
        const Z = k.uint32();
        switch (Z >>> 3) {
          case 1:
            L.pool.push(f.DecCoin.decode(k, k.uint32()));
            break;
          default:
            k.skipType(Z & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(c) {
      return {
        pool: Array.isArray(c == null ? void 0 : c.pool) ? c.pool.map((E) => f.DecCoin.fromJSON(E)) : []
      };
    },
    toJSON(c) {
      const E = {};
      return c.pool ? E.pool = c.pool.map((k) => k ? f.DecCoin.toJSON(k) : void 0) : E.pool = [], E;
    },
    fromPartial(c) {
      var E;
      const k = M();
      return k.pool = ((E = c.pool) == null ? void 0 : E.map((O) => f.DecCoin.fromPartial(O))) || [], k;
    }
  };
  class s {
    constructor(E) {
      this.rpc = E, this.Params = this.Params.bind(this), this.ValidatorDistributionInfo = this.ValidatorDistributionInfo.bind(this), this.ValidatorOutstandingRewards = this.ValidatorOutstandingRewards.bind(this), this.ValidatorCommission = this.ValidatorCommission.bind(this), this.ValidatorSlashes = this.ValidatorSlashes.bind(this), this.DelegationRewards = this.DelegationRewards.bind(this), this.DelegationTotalRewards = this.DelegationTotalRewards.bind(this), this.DelegatorValidators = this.DelegatorValidators.bind(this), this.DelegatorWithdrawAddress = this.DelegatorWithdrawAddress.bind(this), this.CommunityPool = this.CommunityPool.bind(this);
    }
    Params(E = {}) {
      const k = e.QueryParamsRequest.encode(E).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "Params", k).then((O) => e.QueryParamsResponse.decode(new R.Reader(O)));
    }
    ValidatorDistributionInfo(E) {
      const k = e.QueryValidatorDistributionInfoRequest.encode(E).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorDistributionInfo", k).then((O) => e.QueryValidatorDistributionInfoResponse.decode(new R.Reader(O)));
    }
    ValidatorOutstandingRewards(E) {
      const k = e.QueryValidatorOutstandingRewardsRequest.encode(E).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorOutstandingRewards", k).then((O) => e.QueryValidatorOutstandingRewardsResponse.decode(new R.Reader(O)));
    }
    ValidatorCommission(E) {
      const k = e.QueryValidatorCommissionRequest.encode(E).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorCommission", k).then((O) => e.QueryValidatorCommissionResponse.decode(new R.Reader(O)));
    }
    ValidatorSlashes(E) {
      const k = e.QueryValidatorSlashesRequest.encode(E).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorSlashes", k).then((O) => e.QueryValidatorSlashesResponse.decode(new R.Reader(O)));
    }
    DelegationRewards(E) {
      const k = e.QueryDelegationRewardsRequest.encode(E).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationRewards", k).then((O) => e.QueryDelegationRewardsResponse.decode(new R.Reader(O)));
    }
    DelegationTotalRewards(E) {
      const k = e.QueryDelegationTotalRewardsRequest.encode(E).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationTotalRewards", k).then((O) => e.QueryDelegationTotalRewardsResponse.decode(new R.Reader(O)));
    }
    DelegatorValidators(E) {
      const k = e.QueryDelegatorValidatorsRequest.encode(E).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorValidators", k).then((O) => e.QueryDelegatorValidatorsResponse.decode(new R.Reader(O)));
    }
    DelegatorWithdrawAddress(E) {
      const k = e.QueryDelegatorWithdrawAddressRequest.encode(E).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorWithdrawAddress", k).then((O) => e.QueryDelegatorWithdrawAddressResponse.decode(new R.Reader(O)));
    }
    CommunityPool(E = {}) {
      const k = e.QueryCommunityPoolRequest.encode(E).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "CommunityPool", k).then((O) => e.QueryCommunityPoolResponse.decode(new R.Reader(O)));
    }
  }
  e.QueryClientImpl = s;
})(mc);
var Xf = Q && Q.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(nr, "__esModule", { value: !0 });
nr.setupDistributionExtension = void 0;
const em = mc, Pa = Xf(Pt), Ra = Ve;
function tm(e) {
  const o = (0, Ra.createProtobufRpcClient)(e), t = new em.QueryClientImpl(o);
  return {
    distribution: {
      communityPool: async () => await t.CommunityPool({}),
      delegationRewards: async (u, r) => await t.DelegationRewards({
        delegatorAddress: u,
        validatorAddress: r
      }),
      delegationTotalRewards: async (u) => await t.DelegationTotalRewards({
        delegatorAddress: u
      }),
      delegatorValidators: async (u) => await t.DelegatorValidators({
        delegatorAddress: u
      }),
      delegatorWithdrawAddress: async (u) => await t.DelegatorWithdrawAddress({
        delegatorAddress: u
      }),
      params: async () => await t.Params({}),
      validatorCommission: async (u) => await t.ValidatorCommission({
        validatorAddress: u
      }),
      validatorOutstandingRewards: async (u) => await t.ValidatorOutstandingRewards({
        validatorAddress: u
      }),
      validatorSlashes: async (u, r, m, f) => await t.ValidatorSlashes({
        validatorAddress: u,
        startingHeight: Pa.default.fromNumber(r, !0),
        endingHeight: Pa.default.fromNumber(m, !0),
        pagination: (0, Ra.createPagination)(f)
      })
    }
  };
}
nr.setupDistributionExtension = tm;
var Tn = {};
Object.defineProperty(Tn, "__esModule", { value: !0 });
Tn.createEvidenceAminoConverters = Tn.isAminoMsgSubmitEvidence = void 0;
function nm(e) {
  return e.type === "cosmos-sdk/MsgSubmitEvidence";
}
Tn.isAminoMsgSubmitEvidence = nm;
function om() {
  throw new Error("Not implemented");
}
Tn.createEvidenceAminoConverters = om;
var or = {};
Object.defineProperty(or, "__esModule", { value: !0 });
or.createFeegrantAminoConverters = void 0;
function rm() {
  return {
    // For Cosmos SDK < 0.46 the Amino JSON codec was broken on chain and thus inaccessible.
    // Now this can be implemented for 0.46+ chains, see
    // https://github.com/cosmos/cosmjs/issues/1092
    //
    // "/cosmos.feegrant.v1beta1.MsgGrantAllowance": IMPLEMENT_ME,
    // "/cosmos.feegrant.v1beta1.MsgRevokeAllowance": IMPLEMENT_ME,
  };
}
or.createFeegrantAminoConverters = rm;
var rr = {}, gc = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(B, U, C, l) {
    l === void 0 && (l = C);
    var S = Object.getOwnPropertyDescriptor(U, C);
    (!S || ("get" in S ? !U.__esModule : S.writable || S.configurable)) && (S = { enumerable: !0, get: function() {
      return U[C];
    } }), Object.defineProperty(B, l, S);
  } : function(B, U, C, l) {
    l === void 0 && (l = C), B[l] = U[C];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(B, U) {
    Object.defineProperty(B, "default", { enumerable: !0, value: U });
  } : function(B, U) {
    B.default = U;
  }), u = Q && Q.__importStar || function(B) {
    if (B && B.__esModule)
      return B;
    var U = {};
    if (B != null)
      for (var C in B)
        C !== "default" && Object.prototype.hasOwnProperty.call(B, C) && o(U, B, C);
    return t(U, B), U;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgRevokeAllowanceResponse = e.MsgRevokeAllowance = e.MsgGrantAllowanceResponse = e.MsgGrantAllowance = e.protobufPackage = void 0;
  const r = ye, m = u(re), f = ie;
  e.protobufPackage = "cosmos.feegrant.v1beta1";
  function b() {
    return {
      granter: "",
      grantee: "",
      allowance: void 0
    };
  }
  e.MsgGrantAllowance = {
    encode(B, U = m.Writer.create()) {
      return B.granter !== "" && U.uint32(10).string(B.granter), B.grantee !== "" && U.uint32(18).string(B.grantee), B.allowance !== void 0 && r.Any.encode(B.allowance, U.uint32(26).fork()).ldelim(), U;
    },
    decode(B, U) {
      const C = B instanceof m.Reader ? B : new m.Reader(B);
      let l = U === void 0 ? C.len : C.pos + U;
      const S = b();
      for (; C.pos < l; ) {
        const A = C.uint32();
        switch (A >>> 3) {
          case 1:
            S.granter = C.string();
            break;
          case 2:
            S.grantee = C.string();
            break;
          case 3:
            S.allowance = r.Any.decode(C, C.uint32());
            break;
          default:
            C.skipType(A & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(B) {
      return {
        granter: (0, f.isSet)(B.granter) ? String(B.granter) : "",
        grantee: (0, f.isSet)(B.grantee) ? String(B.grantee) : "",
        allowance: (0, f.isSet)(B.allowance) ? r.Any.fromJSON(B.allowance) : void 0
      };
    },
    toJSON(B) {
      const U = {};
      return B.granter !== void 0 && (U.granter = B.granter), B.grantee !== void 0 && (U.grantee = B.grantee), B.allowance !== void 0 && (U.allowance = B.allowance ? r.Any.toJSON(B.allowance) : void 0), U;
    },
    fromPartial(B) {
      const U = b();
      return U.granter = B.granter ?? "", U.grantee = B.grantee ?? "", U.allowance = B.allowance !== void 0 && B.allowance !== null ? r.Any.fromPartial(B.allowance) : void 0, U;
    }
  };
  function R() {
    return {};
  }
  e.MsgGrantAllowanceResponse = {
    encode(B, U = m.Writer.create()) {
      return U;
    },
    decode(B, U) {
      const C = B instanceof m.Reader ? B : new m.Reader(B);
      let l = U === void 0 ? C.len : C.pos + U;
      const S = R();
      for (; C.pos < l; ) {
        const A = C.uint32();
        switch (A >>> 3) {
          default:
            C.skipType(A & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(B) {
      return {};
    },
    toJSON(B) {
      return {};
    },
    fromPartial(B) {
      return R();
    }
  };
  function T() {
    return {
      granter: "",
      grantee: ""
    };
  }
  e.MsgRevokeAllowance = {
    encode(B, U = m.Writer.create()) {
      return B.granter !== "" && U.uint32(10).string(B.granter), B.grantee !== "" && U.uint32(18).string(B.grantee), U;
    },
    decode(B, U) {
      const C = B instanceof m.Reader ? B : new m.Reader(B);
      let l = U === void 0 ? C.len : C.pos + U;
      const S = T();
      for (; C.pos < l; ) {
        const A = C.uint32();
        switch (A >>> 3) {
          case 1:
            S.granter = C.string();
            break;
          case 2:
            S.grantee = C.string();
            break;
          default:
            C.skipType(A & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(B) {
      return {
        granter: (0, f.isSet)(B.granter) ? String(B.granter) : "",
        grantee: (0, f.isSet)(B.grantee) ? String(B.grantee) : ""
      };
    },
    toJSON(B) {
      const U = {};
      return B.granter !== void 0 && (U.granter = B.granter), B.grantee !== void 0 && (U.grantee = B.grantee), U;
    },
    fromPartial(B) {
      const U = T();
      return U.granter = B.granter ?? "", U.grantee = B.grantee ?? "", U;
    }
  };
  function V() {
    return {};
  }
  e.MsgRevokeAllowanceResponse = {
    encode(B, U = m.Writer.create()) {
      return U;
    },
    decode(B, U) {
      const C = B instanceof m.Reader ? B : new m.Reader(B);
      let l = U === void 0 ? C.len : C.pos + U;
      const S = V();
      for (; C.pos < l; ) {
        const A = C.uint32();
        switch (A >>> 3) {
          default:
            C.skipType(A & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(B) {
      return {};
    },
    toJSON(B) {
      return {};
    },
    fromPartial(B) {
      return V();
    }
  };
  class D {
    constructor(U) {
      this.rpc = U, this.GrantAllowance = this.GrantAllowance.bind(this), this.RevokeAllowance = this.RevokeAllowance.bind(this);
    }
    GrantAllowance(U) {
      const C = e.MsgGrantAllowance.encode(U).finish();
      return this.rpc.request("cosmos.feegrant.v1beta1.Msg", "GrantAllowance", C).then((l) => e.MsgGrantAllowanceResponse.decode(new m.Reader(l)));
    }
    RevokeAllowance(U) {
      const C = e.MsgRevokeAllowance.encode(U).finish();
      return this.rpc.request("cosmos.feegrant.v1beta1.Msg", "RevokeAllowance", C).then((l) => e.MsgRevokeAllowanceResponse.decode(new m.Reader(l)));
    }
  }
  e.MsgClientImpl = D;
})(gc);
Object.defineProperty(rr, "__esModule", { value: !0 });
rr.feegrantTypes = void 0;
const Aa = gc;
rr.feegrantTypes = [
  ["/cosmos.feegrant.v1beta1.MsgGrantAllowance", Aa.MsgGrantAllowance],
  ["/cosmos.feegrant.v1beta1.MsgRevokeAllowance", Aa.MsgRevokeAllowance]
];
var ir = {}, hc = {}, vc = {}, et = {}, im = Q && Q.__createBinding || (Object.create ? function(e, o, t, u) {
  u === void 0 && (u = t);
  var r = Object.getOwnPropertyDescriptor(o, t);
  (!r || ("get" in r ? !o.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return o[t];
  } }), Object.defineProperty(e, u, r);
} : function(e, o, t, u) {
  u === void 0 && (u = t), e[u] = o[t];
}), sm = Q && Q.__setModuleDefault || (Object.create ? function(e, o) {
  Object.defineProperty(e, "default", { enumerable: !0, value: o });
} : function(e, o) {
  e.default = o;
}), am = Q && Q.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var o = {};
  if (e != null)
    for (var t in e)
      t !== "default" && Object.prototype.hasOwnProperty.call(e, t) && im(o, e, t);
  return sm(o, e), o;
};
Object.defineProperty(et, "__esModule", { value: !0 });
et.Duration = et.protobufPackage = void 0;
const Jt = ie, Xr = am(re);
et.protobufPackage = "google.protobuf";
function wa() {
  return {
    seconds: Jt.Long.ZERO,
    nanos: 0
  };
}
et.Duration = {
  encode(e, o = Xr.Writer.create()) {
    return e.seconds.isZero() || o.uint32(8).int64(e.seconds), e.nanos !== 0 && o.uint32(16).int32(e.nanos), o;
  },
  decode(e, o) {
    const t = e instanceof Xr.Reader ? e : new Xr.Reader(e);
    let u = o === void 0 ? t.len : t.pos + o;
    const r = wa();
    for (; t.pos < u; ) {
      const m = t.uint32();
      switch (m >>> 3) {
        case 1:
          r.seconds = t.int64();
          break;
        case 2:
          r.nanos = t.int32();
          break;
        default:
          t.skipType(m & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      seconds: (0, Jt.isSet)(e.seconds) ? Jt.Long.fromValue(e.seconds) : Jt.Long.ZERO,
      nanos: (0, Jt.isSet)(e.nanos) ? Number(e.nanos) : 0
    };
  },
  toJSON(e) {
    const o = {};
    return e.seconds !== void 0 && (o.seconds = (e.seconds || Jt.Long.ZERO).toString()), e.nanos !== void 0 && (o.nanos = Math.round(e.nanos)), o;
  },
  fromPartial(e) {
    const o = wa();
    return o.seconds = e.seconds !== void 0 && e.seconds !== null ? Jt.Long.fromValue(e.seconds) : Jt.Long.ZERO, o.nanos = e.nanos ?? 0, o;
  }
};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(C, l, S, A) {
    A === void 0 && (A = S);
    var d = Object.getOwnPropertyDescriptor(l, S);
    (!d || ("get" in d ? !l.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return l[S];
    } }), Object.defineProperty(C, A, d);
  } : function(C, l, S, A) {
    A === void 0 && (A = S), C[A] = l[S];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(C, l) {
    Object.defineProperty(C, "default", { enumerable: !0, value: l });
  } : function(C, l) {
    C.default = l;
  }), u = Q && Q.__importStar || function(C) {
    if (C && C.__esModule)
      return C;
    var l = {};
    if (C != null)
      for (var S in C)
        S !== "default" && Object.prototype.hasOwnProperty.call(C, S) && o(l, C, S);
    return t(l, C), l;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Grant = e.AllowedMsgAllowance = e.PeriodicAllowance = e.BasicAllowance = e.protobufPackage = void 0;
  const r = Le, m = Ae, f = et, b = ye, R = u(re), T = ie;
  e.protobufPackage = "cosmos.feegrant.v1beta1";
  function V() {
    return {
      spendLimit: [],
      expiration: void 0
    };
  }
  e.BasicAllowance = {
    encode(C, l = R.Writer.create()) {
      for (const S of C.spendLimit)
        r.Coin.encode(S, l.uint32(10).fork()).ldelim();
      return C.expiration !== void 0 && m.Timestamp.encode(C.expiration, l.uint32(18).fork()).ldelim(), l;
    },
    decode(C, l) {
      const S = C instanceof R.Reader ? C : new R.Reader(C);
      let A = l === void 0 ? S.len : S.pos + l;
      const d = V();
      for (; S.pos < A; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.spendLimit.push(r.Coin.decode(S, S.uint32()));
            break;
          case 2:
            d.expiration = m.Timestamp.decode(S, S.uint32());
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(C) {
      return {
        spendLimit: Array.isArray(C == null ? void 0 : C.spendLimit) ? C.spendLimit.map((l) => r.Coin.fromJSON(l)) : [],
        expiration: (0, T.isSet)(C.expiration) ? (0, T.fromJsonTimestamp)(C.expiration) : void 0
      };
    },
    toJSON(C) {
      const l = {};
      return C.spendLimit ? l.spendLimit = C.spendLimit.map((S) => S ? r.Coin.toJSON(S) : void 0) : l.spendLimit = [], C.expiration !== void 0 && (l.expiration = (0, T.fromTimestamp)(C.expiration).toISOString()), l;
    },
    fromPartial(C) {
      var l;
      const S = V();
      return S.spendLimit = ((l = C.spendLimit) == null ? void 0 : l.map((A) => r.Coin.fromPartial(A))) || [], S.expiration = C.expiration !== void 0 && C.expiration !== null ? m.Timestamp.fromPartial(C.expiration) : void 0, S;
    }
  };
  function D() {
    return {
      basic: void 0,
      period: void 0,
      periodSpendLimit: [],
      periodCanSpend: [],
      periodReset: void 0
    };
  }
  e.PeriodicAllowance = {
    encode(C, l = R.Writer.create()) {
      C.basic !== void 0 && e.BasicAllowance.encode(C.basic, l.uint32(10).fork()).ldelim(), C.period !== void 0 && f.Duration.encode(C.period, l.uint32(18).fork()).ldelim();
      for (const S of C.periodSpendLimit)
        r.Coin.encode(S, l.uint32(26).fork()).ldelim();
      for (const S of C.periodCanSpend)
        r.Coin.encode(S, l.uint32(34).fork()).ldelim();
      return C.periodReset !== void 0 && m.Timestamp.encode(C.periodReset, l.uint32(42).fork()).ldelim(), l;
    },
    decode(C, l) {
      const S = C instanceof R.Reader ? C : new R.Reader(C);
      let A = l === void 0 ? S.len : S.pos + l;
      const d = D();
      for (; S.pos < A; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.basic = e.BasicAllowance.decode(S, S.uint32());
            break;
          case 2:
            d.period = f.Duration.decode(S, S.uint32());
            break;
          case 3:
            d.periodSpendLimit.push(r.Coin.decode(S, S.uint32()));
            break;
          case 4:
            d.periodCanSpend.push(r.Coin.decode(S, S.uint32()));
            break;
          case 5:
            d.periodReset = m.Timestamp.decode(S, S.uint32());
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(C) {
      return {
        basic: (0, T.isSet)(C.basic) ? e.BasicAllowance.fromJSON(C.basic) : void 0,
        period: (0, T.isSet)(C.period) ? f.Duration.fromJSON(C.period) : void 0,
        periodSpendLimit: Array.isArray(C == null ? void 0 : C.periodSpendLimit) ? C.periodSpendLimit.map((l) => r.Coin.fromJSON(l)) : [],
        periodCanSpend: Array.isArray(C == null ? void 0 : C.periodCanSpend) ? C.periodCanSpend.map((l) => r.Coin.fromJSON(l)) : [],
        periodReset: (0, T.isSet)(C.periodReset) ? (0, T.fromJsonTimestamp)(C.periodReset) : void 0
      };
    },
    toJSON(C) {
      const l = {};
      return C.basic !== void 0 && (l.basic = C.basic ? e.BasicAllowance.toJSON(C.basic) : void 0), C.period !== void 0 && (l.period = C.period ? f.Duration.toJSON(C.period) : void 0), C.periodSpendLimit ? l.periodSpendLimit = C.periodSpendLimit.map((S) => S ? r.Coin.toJSON(S) : void 0) : l.periodSpendLimit = [], C.periodCanSpend ? l.periodCanSpend = C.periodCanSpend.map((S) => S ? r.Coin.toJSON(S) : void 0) : l.periodCanSpend = [], C.periodReset !== void 0 && (l.periodReset = (0, T.fromTimestamp)(C.periodReset).toISOString()), l;
    },
    fromPartial(C) {
      var l, S;
      const A = D();
      return A.basic = C.basic !== void 0 && C.basic !== null ? e.BasicAllowance.fromPartial(C.basic) : void 0, A.period = C.period !== void 0 && C.period !== null ? f.Duration.fromPartial(C.period) : void 0, A.periodSpendLimit = ((l = C.periodSpendLimit) == null ? void 0 : l.map((d) => r.Coin.fromPartial(d))) || [], A.periodCanSpend = ((S = C.periodCanSpend) == null ? void 0 : S.map((d) => r.Coin.fromPartial(d))) || [], A.periodReset = C.periodReset !== void 0 && C.periodReset !== null ? m.Timestamp.fromPartial(C.periodReset) : void 0, A;
    }
  };
  function B() {
    return {
      allowance: void 0,
      allowedMessages: []
    };
  }
  e.AllowedMsgAllowance = {
    encode(C, l = R.Writer.create()) {
      C.allowance !== void 0 && b.Any.encode(C.allowance, l.uint32(10).fork()).ldelim();
      for (const S of C.allowedMessages)
        l.uint32(18).string(S);
      return l;
    },
    decode(C, l) {
      const S = C instanceof R.Reader ? C : new R.Reader(C);
      let A = l === void 0 ? S.len : S.pos + l;
      const d = B();
      for (; S.pos < A; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.allowance = b.Any.decode(S, S.uint32());
            break;
          case 2:
            d.allowedMessages.push(S.string());
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(C) {
      return {
        allowance: (0, T.isSet)(C.allowance) ? b.Any.fromJSON(C.allowance) : void 0,
        allowedMessages: Array.isArray(C == null ? void 0 : C.allowedMessages) ? C.allowedMessages.map((l) => String(l)) : []
      };
    },
    toJSON(C) {
      const l = {};
      return C.allowance !== void 0 && (l.allowance = C.allowance ? b.Any.toJSON(C.allowance) : void 0), C.allowedMessages ? l.allowedMessages = C.allowedMessages.map((S) => S) : l.allowedMessages = [], l;
    },
    fromPartial(C) {
      var l;
      const S = B();
      return S.allowance = C.allowance !== void 0 && C.allowance !== null ? b.Any.fromPartial(C.allowance) : void 0, S.allowedMessages = ((l = C.allowedMessages) == null ? void 0 : l.map((A) => A)) || [], S;
    }
  };
  function U() {
    return {
      granter: "",
      grantee: "",
      allowance: void 0
    };
  }
  e.Grant = {
    encode(C, l = R.Writer.create()) {
      return C.granter !== "" && l.uint32(10).string(C.granter), C.grantee !== "" && l.uint32(18).string(C.grantee), C.allowance !== void 0 && b.Any.encode(C.allowance, l.uint32(26).fork()).ldelim(), l;
    },
    decode(C, l) {
      const S = C instanceof R.Reader ? C : new R.Reader(C);
      let A = l === void 0 ? S.len : S.pos + l;
      const d = U();
      for (; S.pos < A; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.granter = S.string();
            break;
          case 2:
            d.grantee = S.string();
            break;
          case 3:
            d.allowance = b.Any.decode(S, S.uint32());
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(C) {
      return {
        granter: (0, T.isSet)(C.granter) ? String(C.granter) : "",
        grantee: (0, T.isSet)(C.grantee) ? String(C.grantee) : "",
        allowance: (0, T.isSet)(C.allowance) ? b.Any.fromJSON(C.allowance) : void 0
      };
    },
    toJSON(C) {
      const l = {};
      return C.granter !== void 0 && (l.granter = C.granter), C.grantee !== void 0 && (l.grantee = C.grantee), C.allowance !== void 0 && (l.allowance = C.allowance ? b.Any.toJSON(C.allowance) : void 0), l;
    },
    fromPartial(C) {
      const l = U();
      return l.granter = C.granter ?? "", l.grantee = C.grantee ?? "", l.allowance = C.allowance !== void 0 && C.allowance !== null ? b.Any.fromPartial(C.allowance) : void 0, l;
    }
  };
})(vc);
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(l, S, A, d) {
    d === void 0 && (d = A);
    var p = Object.getOwnPropertyDescriptor(S, A);
    (!p || ("get" in p ? !S.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return S[A];
    } }), Object.defineProperty(l, d, p);
  } : function(l, S, A, d) {
    d === void 0 && (d = A), l[d] = S[A];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(l, S) {
    Object.defineProperty(l, "default", { enumerable: !0, value: S });
  } : function(l, S) {
    l.default = S;
  }), u = Q && Q.__importStar || function(l) {
    if (l && l.__esModule)
      return l;
    var S = {};
    if (l != null)
      for (var A in l)
        A !== "default" && Object.prototype.hasOwnProperty.call(l, A) && o(S, l, A);
    return t(S, l), S;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryAllowancesByGranterResponse = e.QueryAllowancesByGranterRequest = e.QueryAllowancesResponse = e.QueryAllowancesRequest = e.QueryAllowanceResponse = e.QueryAllowanceRequest = e.protobufPackage = void 0;
  const r = be, m = vc, f = u(re), b = ie;
  e.protobufPackage = "cosmos.feegrant.v1beta1";
  function R() {
    return {
      granter: "",
      grantee: ""
    };
  }
  e.QueryAllowanceRequest = {
    encode(l, S = f.Writer.create()) {
      return l.granter !== "" && S.uint32(10).string(l.granter), l.grantee !== "" && S.uint32(18).string(l.grantee), S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = R();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.granter = A.string();
            break;
          case 2:
            p.grantee = A.string();
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        granter: (0, b.isSet)(l.granter) ? String(l.granter) : "",
        grantee: (0, b.isSet)(l.grantee) ? String(l.grantee) : ""
      };
    },
    toJSON(l) {
      const S = {};
      return l.granter !== void 0 && (S.granter = l.granter), l.grantee !== void 0 && (S.grantee = l.grantee), S;
    },
    fromPartial(l) {
      const S = R();
      return S.granter = l.granter ?? "", S.grantee = l.grantee ?? "", S;
    }
  };
  function T() {
    return {
      allowance: void 0
    };
  }
  e.QueryAllowanceResponse = {
    encode(l, S = f.Writer.create()) {
      return l.allowance !== void 0 && m.Grant.encode(l.allowance, S.uint32(10).fork()).ldelim(), S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = T();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.allowance = m.Grant.decode(A, A.uint32());
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        allowance: (0, b.isSet)(l.allowance) ? m.Grant.fromJSON(l.allowance) : void 0
      };
    },
    toJSON(l) {
      const S = {};
      return l.allowance !== void 0 && (S.allowance = l.allowance ? m.Grant.toJSON(l.allowance) : void 0), S;
    },
    fromPartial(l) {
      const S = T();
      return S.allowance = l.allowance !== void 0 && l.allowance !== null ? m.Grant.fromPartial(l.allowance) : void 0, S;
    }
  };
  function V() {
    return {
      grantee: "",
      pagination: void 0
    };
  }
  e.QueryAllowancesRequest = {
    encode(l, S = f.Writer.create()) {
      return l.grantee !== "" && S.uint32(10).string(l.grantee), l.pagination !== void 0 && r.PageRequest.encode(l.pagination, S.uint32(18).fork()).ldelim(), S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = V();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.grantee = A.string();
            break;
          case 2:
            p.pagination = r.PageRequest.decode(A, A.uint32());
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        grantee: (0, b.isSet)(l.grantee) ? String(l.grantee) : "",
        pagination: (0, b.isSet)(l.pagination) ? r.PageRequest.fromJSON(l.pagination) : void 0
      };
    },
    toJSON(l) {
      const S = {};
      return l.grantee !== void 0 && (S.grantee = l.grantee), l.pagination !== void 0 && (S.pagination = l.pagination ? r.PageRequest.toJSON(l.pagination) : void 0), S;
    },
    fromPartial(l) {
      const S = V();
      return S.grantee = l.grantee ?? "", S.pagination = l.pagination !== void 0 && l.pagination !== null ? r.PageRequest.fromPartial(l.pagination) : void 0, S;
    }
  };
  function D() {
    return {
      allowances: [],
      pagination: void 0
    };
  }
  e.QueryAllowancesResponse = {
    encode(l, S = f.Writer.create()) {
      for (const A of l.allowances)
        m.Grant.encode(A, S.uint32(10).fork()).ldelim();
      return l.pagination !== void 0 && r.PageResponse.encode(l.pagination, S.uint32(18).fork()).ldelim(), S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = D();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.allowances.push(m.Grant.decode(A, A.uint32()));
            break;
          case 2:
            p.pagination = r.PageResponse.decode(A, A.uint32());
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        allowances: Array.isArray(l == null ? void 0 : l.allowances) ? l.allowances.map((S) => m.Grant.fromJSON(S)) : [],
        pagination: (0, b.isSet)(l.pagination) ? r.PageResponse.fromJSON(l.pagination) : void 0
      };
    },
    toJSON(l) {
      const S = {};
      return l.allowances ? S.allowances = l.allowances.map((A) => A ? m.Grant.toJSON(A) : void 0) : S.allowances = [], l.pagination !== void 0 && (S.pagination = l.pagination ? r.PageResponse.toJSON(l.pagination) : void 0), S;
    },
    fromPartial(l) {
      var S;
      const A = D();
      return A.allowances = ((S = l.allowances) == null ? void 0 : S.map((d) => m.Grant.fromPartial(d))) || [], A.pagination = l.pagination !== void 0 && l.pagination !== null ? r.PageResponse.fromPartial(l.pagination) : void 0, A;
    }
  };
  function B() {
    return {
      granter: "",
      pagination: void 0
    };
  }
  e.QueryAllowancesByGranterRequest = {
    encode(l, S = f.Writer.create()) {
      return l.granter !== "" && S.uint32(10).string(l.granter), l.pagination !== void 0 && r.PageRequest.encode(l.pagination, S.uint32(18).fork()).ldelim(), S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = B();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.granter = A.string();
            break;
          case 2:
            p.pagination = r.PageRequest.decode(A, A.uint32());
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        granter: (0, b.isSet)(l.granter) ? String(l.granter) : "",
        pagination: (0, b.isSet)(l.pagination) ? r.PageRequest.fromJSON(l.pagination) : void 0
      };
    },
    toJSON(l) {
      const S = {};
      return l.granter !== void 0 && (S.granter = l.granter), l.pagination !== void 0 && (S.pagination = l.pagination ? r.PageRequest.toJSON(l.pagination) : void 0), S;
    },
    fromPartial(l) {
      const S = B();
      return S.granter = l.granter ?? "", S.pagination = l.pagination !== void 0 && l.pagination !== null ? r.PageRequest.fromPartial(l.pagination) : void 0, S;
    }
  };
  function U() {
    return {
      allowances: [],
      pagination: void 0
    };
  }
  e.QueryAllowancesByGranterResponse = {
    encode(l, S = f.Writer.create()) {
      for (const A of l.allowances)
        m.Grant.encode(A, S.uint32(10).fork()).ldelim();
      return l.pagination !== void 0 && r.PageResponse.encode(l.pagination, S.uint32(18).fork()).ldelim(), S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = U();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.allowances.push(m.Grant.decode(A, A.uint32()));
            break;
          case 2:
            p.pagination = r.PageResponse.decode(A, A.uint32());
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        allowances: Array.isArray(l == null ? void 0 : l.allowances) ? l.allowances.map((S) => m.Grant.fromJSON(S)) : [],
        pagination: (0, b.isSet)(l.pagination) ? r.PageResponse.fromJSON(l.pagination) : void 0
      };
    },
    toJSON(l) {
      const S = {};
      return l.allowances ? S.allowances = l.allowances.map((A) => A ? m.Grant.toJSON(A) : void 0) : S.allowances = [], l.pagination !== void 0 && (S.pagination = l.pagination ? r.PageResponse.toJSON(l.pagination) : void 0), S;
    },
    fromPartial(l) {
      var S;
      const A = U();
      return A.allowances = ((S = l.allowances) == null ? void 0 : S.map((d) => m.Grant.fromPartial(d))) || [], A.pagination = l.pagination !== void 0 && l.pagination !== null ? r.PageResponse.fromPartial(l.pagination) : void 0, A;
    }
  };
  class C {
    constructor(S) {
      this.rpc = S, this.Allowance = this.Allowance.bind(this), this.Allowances = this.Allowances.bind(this), this.AllowancesByGranter = this.AllowancesByGranter.bind(this);
    }
    Allowance(S) {
      const A = e.QueryAllowanceRequest.encode(S).finish();
      return this.rpc.request("cosmos.feegrant.v1beta1.Query", "Allowance", A).then((d) => e.QueryAllowanceResponse.decode(new f.Reader(d)));
    }
    Allowances(S) {
      const A = e.QueryAllowancesRequest.encode(S).finish();
      return this.rpc.request("cosmos.feegrant.v1beta1.Query", "Allowances", A).then((d) => e.QueryAllowancesResponse.decode(new f.Reader(d)));
    }
    AllowancesByGranter(S) {
      const A = e.QueryAllowancesByGranterRequest.encode(S).finish();
      return this.rpc.request("cosmos.feegrant.v1beta1.Query", "AllowancesByGranter", A).then((d) => e.QueryAllowancesByGranterResponse.decode(new f.Reader(d)));
    }
  }
  e.QueryClientImpl = C;
})(hc);
Object.defineProperty(ir, "__esModule", { value: !0 });
ir.setupFeegrantExtension = void 0;
const dm = hc, Na = Ve;
function cm(e) {
  const o = (0, Na.createProtobufRpcClient)(e), t = new dm.QueryClientImpl(o);
  return {
    feegrant: {
      allowance: async (u, r) => await t.Allowance({
        granter: u,
        grantee: r
      }),
      allowances: async (u, r) => await t.Allowances({
        grantee: u,
        pagination: (0, Na.createPagination)(r)
      })
    }
  };
}
ir.setupFeegrantExtension = cm;
var rt = {}, sr = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(n, y, w, M) {
    M === void 0 && (M = w);
    var s = Object.getOwnPropertyDescriptor(y, w);
    (!s || ("get" in s ? !y.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
      return y[w];
    } }), Object.defineProperty(n, M, s);
  } : function(n, y, w, M) {
    M === void 0 && (M = w), n[M] = y[w];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(n, y) {
    Object.defineProperty(n, "default", { enumerable: !0, value: y });
  } : function(n, y) {
    n.default = y;
  }), u = Q && Q.__importStar || function(n) {
    if (n && n.__esModule)
      return n;
    var y = {};
    if (n != null)
      for (var w in n)
        w !== "default" && Object.prototype.hasOwnProperty.call(n, w) && o(y, n, w);
    return t(y, n), y;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.TallyParams = e.VotingParams = e.DepositParams = e.Vote = e.TallyResult = e.Proposal = e.Deposit = e.TextProposal = e.WeightedVoteOption = e.proposalStatusToJSON = e.proposalStatusFromJSON = e.ProposalStatus = e.voteOptionToJSON = e.voteOptionFromJSON = e.VoteOption = e.protobufPackage = void 0;
  const r = Le, m = ye, f = Ae, b = et, R = ie, T = u(re);
  e.protobufPackage = "cosmos.gov.v1beta1";
  var V;
  (function(n) {
    n[n.VOTE_OPTION_UNSPECIFIED = 0] = "VOTE_OPTION_UNSPECIFIED", n[n.VOTE_OPTION_YES = 1] = "VOTE_OPTION_YES", n[n.VOTE_OPTION_ABSTAIN = 2] = "VOTE_OPTION_ABSTAIN", n[n.VOTE_OPTION_NO = 3] = "VOTE_OPTION_NO", n[n.VOTE_OPTION_NO_WITH_VETO = 4] = "VOTE_OPTION_NO_WITH_VETO", n[n.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(V = e.VoteOption || (e.VoteOption = {}));
  function D(n) {
    switch (n) {
      case 0:
      case "VOTE_OPTION_UNSPECIFIED":
        return V.VOTE_OPTION_UNSPECIFIED;
      case 1:
      case "VOTE_OPTION_YES":
        return V.VOTE_OPTION_YES;
      case 2:
      case "VOTE_OPTION_ABSTAIN":
        return V.VOTE_OPTION_ABSTAIN;
      case 3:
      case "VOTE_OPTION_NO":
        return V.VOTE_OPTION_NO;
      case 4:
      case "VOTE_OPTION_NO_WITH_VETO":
        return V.VOTE_OPTION_NO_WITH_VETO;
      case -1:
      case "UNRECOGNIZED":
      default:
        return V.UNRECOGNIZED;
    }
  }
  e.voteOptionFromJSON = D;
  function B(n) {
    switch (n) {
      case V.VOTE_OPTION_UNSPECIFIED:
        return "VOTE_OPTION_UNSPECIFIED";
      case V.VOTE_OPTION_YES:
        return "VOTE_OPTION_YES";
      case V.VOTE_OPTION_ABSTAIN:
        return "VOTE_OPTION_ABSTAIN";
      case V.VOTE_OPTION_NO:
        return "VOTE_OPTION_NO";
      case V.VOTE_OPTION_NO_WITH_VETO:
        return "VOTE_OPTION_NO_WITH_VETO";
      case V.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.voteOptionToJSON = B;
  var U;
  (function(n) {
    n[n.PROPOSAL_STATUS_UNSPECIFIED = 0] = "PROPOSAL_STATUS_UNSPECIFIED", n[n.PROPOSAL_STATUS_DEPOSIT_PERIOD = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD", n[n.PROPOSAL_STATUS_VOTING_PERIOD = 2] = "PROPOSAL_STATUS_VOTING_PERIOD", n[n.PROPOSAL_STATUS_PASSED = 3] = "PROPOSAL_STATUS_PASSED", n[n.PROPOSAL_STATUS_REJECTED = 4] = "PROPOSAL_STATUS_REJECTED", n[n.PROPOSAL_STATUS_FAILED = 5] = "PROPOSAL_STATUS_FAILED", n[n.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(U = e.ProposalStatus || (e.ProposalStatus = {}));
  function C(n) {
    switch (n) {
      case 0:
      case "PROPOSAL_STATUS_UNSPECIFIED":
        return U.PROPOSAL_STATUS_UNSPECIFIED;
      case 1:
      case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
        return U.PROPOSAL_STATUS_DEPOSIT_PERIOD;
      case 2:
      case "PROPOSAL_STATUS_VOTING_PERIOD":
        return U.PROPOSAL_STATUS_VOTING_PERIOD;
      case 3:
      case "PROPOSAL_STATUS_PASSED":
        return U.PROPOSAL_STATUS_PASSED;
      case 4:
      case "PROPOSAL_STATUS_REJECTED":
        return U.PROPOSAL_STATUS_REJECTED;
      case 5:
      case "PROPOSAL_STATUS_FAILED":
        return U.PROPOSAL_STATUS_FAILED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return U.UNRECOGNIZED;
    }
  }
  e.proposalStatusFromJSON = C;
  function l(n) {
    switch (n) {
      case U.PROPOSAL_STATUS_UNSPECIFIED:
        return "PROPOSAL_STATUS_UNSPECIFIED";
      case U.PROPOSAL_STATUS_DEPOSIT_PERIOD:
        return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
      case U.PROPOSAL_STATUS_VOTING_PERIOD:
        return "PROPOSAL_STATUS_VOTING_PERIOD";
      case U.PROPOSAL_STATUS_PASSED:
        return "PROPOSAL_STATUS_PASSED";
      case U.PROPOSAL_STATUS_REJECTED:
        return "PROPOSAL_STATUS_REJECTED";
      case U.PROPOSAL_STATUS_FAILED:
        return "PROPOSAL_STATUS_FAILED";
      case U.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.proposalStatusToJSON = l;
  function S() {
    return {
      option: 0,
      weight: ""
    };
  }
  e.WeightedVoteOption = {
    encode(n, y = T.Writer.create()) {
      return n.option !== 0 && y.uint32(8).int32(n.option), n.weight !== "" && y.uint32(18).string(n.weight), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = S();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.option = w.int32();
            break;
          case 2:
            s.weight = w.string();
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        option: (0, R.isSet)(n.option) ? D(n.option) : 0,
        weight: (0, R.isSet)(n.weight) ? String(n.weight) : ""
      };
    },
    toJSON(n) {
      const y = {};
      return n.option !== void 0 && (y.option = B(n.option)), n.weight !== void 0 && (y.weight = n.weight), y;
    },
    fromPartial(n) {
      const y = S();
      return y.option = n.option ?? 0, y.weight = n.weight ?? "", y;
    }
  };
  function A() {
    return {
      title: "",
      description: ""
    };
  }
  e.TextProposal = {
    encode(n, y = T.Writer.create()) {
      return n.title !== "" && y.uint32(10).string(n.title), n.description !== "" && y.uint32(18).string(n.description), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = A();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.title = w.string();
            break;
          case 2:
            s.description = w.string();
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        title: (0, R.isSet)(n.title) ? String(n.title) : "",
        description: (0, R.isSet)(n.description) ? String(n.description) : ""
      };
    },
    toJSON(n) {
      const y = {};
      return n.title !== void 0 && (y.title = n.title), n.description !== void 0 && (y.description = n.description), y;
    },
    fromPartial(n) {
      const y = A();
      return y.title = n.title ?? "", y.description = n.description ?? "", y;
    }
  };
  function d() {
    return {
      proposalId: R.Long.UZERO,
      depositor: "",
      amount: []
    };
  }
  e.Deposit = {
    encode(n, y = T.Writer.create()) {
      n.proposalId.isZero() || y.uint32(8).uint64(n.proposalId), n.depositor !== "" && y.uint32(18).string(n.depositor);
      for (const w of n.amount)
        r.Coin.encode(w, y.uint32(26).fork()).ldelim();
      return y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = d();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.proposalId = w.uint64();
            break;
          case 2:
            s.depositor = w.string();
            break;
          case 3:
            s.amount.push(r.Coin.decode(w, w.uint32()));
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        proposalId: (0, R.isSet)(n.proposalId) ? R.Long.fromValue(n.proposalId) : R.Long.UZERO,
        depositor: (0, R.isSet)(n.depositor) ? String(n.depositor) : "",
        amount: Array.isArray(n == null ? void 0 : n.amount) ? n.amount.map((y) => r.Coin.fromJSON(y)) : []
      };
    },
    toJSON(n) {
      const y = {};
      return n.proposalId !== void 0 && (y.proposalId = (n.proposalId || R.Long.UZERO).toString()), n.depositor !== void 0 && (y.depositor = n.depositor), n.amount ? y.amount = n.amount.map((w) => w ? r.Coin.toJSON(w) : void 0) : y.amount = [], y;
    },
    fromPartial(n) {
      var y;
      const w = d();
      return w.proposalId = n.proposalId !== void 0 && n.proposalId !== null ? R.Long.fromValue(n.proposalId) : R.Long.UZERO, w.depositor = n.depositor ?? "", w.amount = ((y = n.amount) == null ? void 0 : y.map((M) => r.Coin.fromPartial(M))) || [], w;
    }
  };
  function p() {
    return {
      proposalId: R.Long.UZERO,
      content: void 0,
      status: 0,
      finalTallyResult: void 0,
      submitTime: void 0,
      depositEndTime: void 0,
      totalDeposit: [],
      votingStartTime: void 0,
      votingEndTime: void 0
    };
  }
  e.Proposal = {
    encode(n, y = T.Writer.create()) {
      n.proposalId.isZero() || y.uint32(8).uint64(n.proposalId), n.content !== void 0 && m.Any.encode(n.content, y.uint32(18).fork()).ldelim(), n.status !== 0 && y.uint32(24).int32(n.status), n.finalTallyResult !== void 0 && e.TallyResult.encode(n.finalTallyResult, y.uint32(34).fork()).ldelim(), n.submitTime !== void 0 && f.Timestamp.encode(n.submitTime, y.uint32(42).fork()).ldelim(), n.depositEndTime !== void 0 && f.Timestamp.encode(n.depositEndTime, y.uint32(50).fork()).ldelim();
      for (const w of n.totalDeposit)
        r.Coin.encode(w, y.uint32(58).fork()).ldelim();
      return n.votingStartTime !== void 0 && f.Timestamp.encode(n.votingStartTime, y.uint32(66).fork()).ldelim(), n.votingEndTime !== void 0 && f.Timestamp.encode(n.votingEndTime, y.uint32(74).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = p();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.proposalId = w.uint64();
            break;
          case 2:
            s.content = m.Any.decode(w, w.uint32());
            break;
          case 3:
            s.status = w.int32();
            break;
          case 4:
            s.finalTallyResult = e.TallyResult.decode(w, w.uint32());
            break;
          case 5:
            s.submitTime = f.Timestamp.decode(w, w.uint32());
            break;
          case 6:
            s.depositEndTime = f.Timestamp.decode(w, w.uint32());
            break;
          case 7:
            s.totalDeposit.push(r.Coin.decode(w, w.uint32()));
            break;
          case 8:
            s.votingStartTime = f.Timestamp.decode(w, w.uint32());
            break;
          case 9:
            s.votingEndTime = f.Timestamp.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        proposalId: (0, R.isSet)(n.proposalId) ? R.Long.fromValue(n.proposalId) : R.Long.UZERO,
        content: (0, R.isSet)(n.content) ? m.Any.fromJSON(n.content) : void 0,
        status: (0, R.isSet)(n.status) ? C(n.status) : 0,
        finalTallyResult: (0, R.isSet)(n.finalTallyResult) ? e.TallyResult.fromJSON(n.finalTallyResult) : void 0,
        submitTime: (0, R.isSet)(n.submitTime) ? (0, R.fromJsonTimestamp)(n.submitTime) : void 0,
        depositEndTime: (0, R.isSet)(n.depositEndTime) ? (0, R.fromJsonTimestamp)(n.depositEndTime) : void 0,
        totalDeposit: Array.isArray(n == null ? void 0 : n.totalDeposit) ? n.totalDeposit.map((y) => r.Coin.fromJSON(y)) : [],
        votingStartTime: (0, R.isSet)(n.votingStartTime) ? (0, R.fromJsonTimestamp)(n.votingStartTime) : void 0,
        votingEndTime: (0, R.isSet)(n.votingEndTime) ? (0, R.fromJsonTimestamp)(n.votingEndTime) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.proposalId !== void 0 && (y.proposalId = (n.proposalId || R.Long.UZERO).toString()), n.content !== void 0 && (y.content = n.content ? m.Any.toJSON(n.content) : void 0), n.status !== void 0 && (y.status = l(n.status)), n.finalTallyResult !== void 0 && (y.finalTallyResult = n.finalTallyResult ? e.TallyResult.toJSON(n.finalTallyResult) : void 0), n.submitTime !== void 0 && (y.submitTime = (0, R.fromTimestamp)(n.submitTime).toISOString()), n.depositEndTime !== void 0 && (y.depositEndTime = (0, R.fromTimestamp)(n.depositEndTime).toISOString()), n.totalDeposit ? y.totalDeposit = n.totalDeposit.map((w) => w ? r.Coin.toJSON(w) : void 0) : y.totalDeposit = [], n.votingStartTime !== void 0 && (y.votingStartTime = (0, R.fromTimestamp)(n.votingStartTime).toISOString()), n.votingEndTime !== void 0 && (y.votingEndTime = (0, R.fromTimestamp)(n.votingEndTime).toISOString()), y;
    },
    fromPartial(n) {
      var y;
      const w = p();
      return w.proposalId = n.proposalId !== void 0 && n.proposalId !== null ? R.Long.fromValue(n.proposalId) : R.Long.UZERO, w.content = n.content !== void 0 && n.content !== null ? m.Any.fromPartial(n.content) : void 0, w.status = n.status ?? 0, w.finalTallyResult = n.finalTallyResult !== void 0 && n.finalTallyResult !== null ? e.TallyResult.fromPartial(n.finalTallyResult) : void 0, w.submitTime = n.submitTime !== void 0 && n.submitTime !== null ? f.Timestamp.fromPartial(n.submitTime) : void 0, w.depositEndTime = n.depositEndTime !== void 0 && n.depositEndTime !== null ? f.Timestamp.fromPartial(n.depositEndTime) : void 0, w.totalDeposit = ((y = n.totalDeposit) == null ? void 0 : y.map((M) => r.Coin.fromPartial(M))) || [], w.votingStartTime = n.votingStartTime !== void 0 && n.votingStartTime !== null ? f.Timestamp.fromPartial(n.votingStartTime) : void 0, w.votingEndTime = n.votingEndTime !== void 0 && n.votingEndTime !== null ? f.Timestamp.fromPartial(n.votingEndTime) : void 0, w;
    }
  };
  function h() {
    return {
      yes: "",
      abstain: "",
      no: "",
      noWithVeto: ""
    };
  }
  e.TallyResult = {
    encode(n, y = T.Writer.create()) {
      return n.yes !== "" && y.uint32(10).string(n.yes), n.abstain !== "" && y.uint32(18).string(n.abstain), n.no !== "" && y.uint32(26).string(n.no), n.noWithVeto !== "" && y.uint32(34).string(n.noWithVeto), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = h();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.yes = w.string();
            break;
          case 2:
            s.abstain = w.string();
            break;
          case 3:
            s.no = w.string();
            break;
          case 4:
            s.noWithVeto = w.string();
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        yes: (0, R.isSet)(n.yes) ? String(n.yes) : "",
        abstain: (0, R.isSet)(n.abstain) ? String(n.abstain) : "",
        no: (0, R.isSet)(n.no) ? String(n.no) : "",
        noWithVeto: (0, R.isSet)(n.noWithVeto) ? String(n.noWithVeto) : ""
      };
    },
    toJSON(n) {
      const y = {};
      return n.yes !== void 0 && (y.yes = n.yes), n.abstain !== void 0 && (y.abstain = n.abstain), n.no !== void 0 && (y.no = n.no), n.noWithVeto !== void 0 && (y.noWithVeto = n.noWithVeto), y;
    },
    fromPartial(n) {
      const y = h();
      return y.yes = n.yes ?? "", y.abstain = n.abstain ?? "", y.no = n.no ?? "", y.noWithVeto = n.noWithVeto ?? "", y;
    }
  };
  function x() {
    return {
      proposalId: R.Long.UZERO,
      voter: "",
      option: 0,
      options: []
    };
  }
  e.Vote = {
    encode(n, y = T.Writer.create()) {
      n.proposalId.isZero() || y.uint32(8).uint64(n.proposalId), n.voter !== "" && y.uint32(18).string(n.voter), n.option !== 0 && y.uint32(24).int32(n.option);
      for (const w of n.options)
        e.WeightedVoteOption.encode(w, y.uint32(34).fork()).ldelim();
      return y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = x();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.proposalId = w.uint64();
            break;
          case 2:
            s.voter = w.string();
            break;
          case 3:
            s.option = w.int32();
            break;
          case 4:
            s.options.push(e.WeightedVoteOption.decode(w, w.uint32()));
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        proposalId: (0, R.isSet)(n.proposalId) ? R.Long.fromValue(n.proposalId) : R.Long.UZERO,
        voter: (0, R.isSet)(n.voter) ? String(n.voter) : "",
        option: (0, R.isSet)(n.option) ? D(n.option) : 0,
        options: Array.isArray(n == null ? void 0 : n.options) ? n.options.map((y) => e.WeightedVoteOption.fromJSON(y)) : []
      };
    },
    toJSON(n) {
      const y = {};
      return n.proposalId !== void 0 && (y.proposalId = (n.proposalId || R.Long.UZERO).toString()), n.voter !== void 0 && (y.voter = n.voter), n.option !== void 0 && (y.option = B(n.option)), n.options ? y.options = n.options.map((w) => w ? e.WeightedVoteOption.toJSON(w) : void 0) : y.options = [], y;
    },
    fromPartial(n) {
      var y;
      const w = x();
      return w.proposalId = n.proposalId !== void 0 && n.proposalId !== null ? R.Long.fromValue(n.proposalId) : R.Long.UZERO, w.voter = n.voter ?? "", w.option = n.option ?? 0, w.options = ((y = n.options) == null ? void 0 : y.map((M) => e.WeightedVoteOption.fromPartial(M))) || [], w;
    }
  };
  function _() {
    return {
      minDeposit: [],
      maxDepositPeriod: void 0
    };
  }
  e.DepositParams = {
    encode(n, y = T.Writer.create()) {
      for (const w of n.minDeposit)
        r.Coin.encode(w, y.uint32(10).fork()).ldelim();
      return n.maxDepositPeriod !== void 0 && b.Duration.encode(n.maxDepositPeriod, y.uint32(18).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = _();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.minDeposit.push(r.Coin.decode(w, w.uint32()));
            break;
          case 2:
            s.maxDepositPeriod = b.Duration.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        minDeposit: Array.isArray(n == null ? void 0 : n.minDeposit) ? n.minDeposit.map((y) => r.Coin.fromJSON(y)) : [],
        maxDepositPeriod: (0, R.isSet)(n.maxDepositPeriod) ? b.Duration.fromJSON(n.maxDepositPeriod) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.minDeposit ? y.minDeposit = n.minDeposit.map((w) => w ? r.Coin.toJSON(w) : void 0) : y.minDeposit = [], n.maxDepositPeriod !== void 0 && (y.maxDepositPeriod = n.maxDepositPeriod ? b.Duration.toJSON(n.maxDepositPeriod) : void 0), y;
    },
    fromPartial(n) {
      var y;
      const w = _();
      return w.minDeposit = ((y = n.minDeposit) == null ? void 0 : y.map((M) => r.Coin.fromPartial(M))) || [], w.maxDepositPeriod = n.maxDepositPeriod !== void 0 && n.maxDepositPeriod !== null ? b.Duration.fromPartial(n.maxDepositPeriod) : void 0, w;
    }
  };
  function I() {
    return {
      votingPeriod: void 0
    };
  }
  e.VotingParams = {
    encode(n, y = T.Writer.create()) {
      return n.votingPeriod !== void 0 && b.Duration.encode(n.votingPeriod, y.uint32(10).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = I();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.votingPeriod = b.Duration.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        votingPeriod: (0, R.isSet)(n.votingPeriod) ? b.Duration.fromJSON(n.votingPeriod) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.votingPeriod !== void 0 && (y.votingPeriod = n.votingPeriod ? b.Duration.toJSON(n.votingPeriod) : void 0), y;
    },
    fromPartial(n) {
      const y = I();
      return y.votingPeriod = n.votingPeriod !== void 0 && n.votingPeriod !== null ? b.Duration.fromPartial(n.votingPeriod) : void 0, y;
    }
  };
  function W() {
    return {
      quorum: new Uint8Array(),
      threshold: new Uint8Array(),
      vetoThreshold: new Uint8Array()
    };
  }
  e.TallyParams = {
    encode(n, y = T.Writer.create()) {
      return n.quorum.length !== 0 && y.uint32(10).bytes(n.quorum), n.threshold.length !== 0 && y.uint32(18).bytes(n.threshold), n.vetoThreshold.length !== 0 && y.uint32(26).bytes(n.vetoThreshold), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = W();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.quorum = w.bytes();
            break;
          case 2:
            s.threshold = w.bytes();
            break;
          case 3:
            s.vetoThreshold = w.bytes();
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        quorum: (0, R.isSet)(n.quorum) ? (0, R.bytesFromBase64)(n.quorum) : new Uint8Array(),
        threshold: (0, R.isSet)(n.threshold) ? (0, R.bytesFromBase64)(n.threshold) : new Uint8Array(),
        vetoThreshold: (0, R.isSet)(n.vetoThreshold) ? (0, R.bytesFromBase64)(n.vetoThreshold) : new Uint8Array()
      };
    },
    toJSON(n) {
      const y = {};
      return n.quorum !== void 0 && (y.quorum = (0, R.base64FromBytes)(n.quorum !== void 0 ? n.quorum : new Uint8Array())), n.threshold !== void 0 && (y.threshold = (0, R.base64FromBytes)(n.threshold !== void 0 ? n.threshold : new Uint8Array())), n.vetoThreshold !== void 0 && (y.vetoThreshold = (0, R.base64FromBytes)(n.vetoThreshold !== void 0 ? n.vetoThreshold : new Uint8Array())), y;
    },
    fromPartial(n) {
      const y = W();
      return y.quorum = n.quorum ?? new Uint8Array(), y.threshold = n.threshold ?? new Uint8Array(), y.vetoThreshold = n.vetoThreshold ?? new Uint8Array(), y;
    }
  };
})(sr);
var um = Q && Q.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(rt, "__esModule", { value: !0 });
rt.createGovAminoConverters = rt.isAminoMsgDeposit = rt.isAminoMsgVoteWeighted = rt.isAminoMsgVote = rt.isAminoMsgSubmitProposal = void 0;
const lm = Rt, Hn = ht, jn = sr, pm = ye, ei = um(Pt), fm = Ve;
function mm(e) {
  return e.type === "cosmos-sdk/MsgSubmitProposal";
}
rt.isAminoMsgSubmitProposal = mm;
function gm(e) {
  return e.type === "cosmos-sdk/MsgVote";
}
rt.isAminoMsgVote = gm;
function hm(e) {
  return e.type === "cosmos-sdk/MsgVoteWeighted";
}
rt.isAminoMsgVoteWeighted = hm;
function vm(e) {
  return e.type === "cosmos-sdk/MsgDeposit";
}
rt.isAminoMsgDeposit = vm;
function ym() {
  return {
    "/cosmos.gov.v1beta1.MsgDeposit": {
      aminoType: "cosmos-sdk/MsgDeposit",
      toAmino: ({ amount: e, depositor: o, proposalId: t }) => ({
        amount: e,
        depositor: o,
        proposal_id: t.toString()
      }),
      fromAmino: ({ amount: e, depositor: o, proposal_id: t }) => ({
        amount: Array.from(e),
        depositor: o,
        proposalId: ei.default.fromString(t)
      })
    },
    "/cosmos.gov.v1beta1.MsgVote": {
      aminoType: "cosmos-sdk/MsgVote",
      toAmino: ({ option: e, proposalId: o, voter: t }) => ({
        option: e,
        proposal_id: o.toString(),
        voter: t
      }),
      fromAmino: ({ option: e, proposal_id: o, voter: t }) => ({
        option: (0, jn.voteOptionFromJSON)(e),
        proposalId: ei.default.fromString(o),
        voter: t
      })
    },
    "/cosmos.gov.v1beta1.MsgVoteWeighted": {
      aminoType: "cosmos-sdk/MsgVoteWeighted",
      toAmino: ({ options: e, proposalId: o, voter: t }) => ({
        options: e.map((u) => ({
          option: u.option,
          // Weight is between 0 and 1, so we always have 20 characters when printing all trailing
          // zeros (e.g. "0.700000000000000000" or "1.000000000000000000")
          weight: (0, fm.decodeCosmosSdkDecFromProto)(u.weight).toString().padEnd(20, "0")
        })),
        proposal_id: o.toString(),
        voter: t
      }),
      fromAmino: ({ options: e, proposal_id: o, voter: t }) => ({
        proposalId: ei.default.fromString(o),
        voter: t,
        options: e.map((u) => ({
          option: (0, jn.voteOptionFromJSON)(u.option),
          weight: lm.Decimal.fromUserInput(u.weight, 18).atomics
        }))
      })
    },
    "/cosmos.gov.v1beta1.MsgSubmitProposal": {
      aminoType: "cosmos-sdk/MsgSubmitProposal",
      toAmino: ({ initialDeposit: e, proposer: o, content: t }) => {
        (0, Hn.assertDefinedAndNotNull)(t);
        let u;
        switch (t.typeUrl) {
          case "/cosmos.gov.v1beta1.TextProposal": {
            const r = jn.TextProposal.decode(t.value);
            u = {
              type: "cosmos-sdk/TextProposal",
              value: {
                description: r.description,
                title: r.title
              }
            };
            break;
          }
          default:
            throw new Error(`Unsupported proposal type: '${t.typeUrl}'`);
        }
        return {
          initial_deposit: e,
          proposer: o,
          content: u
        };
      },
      fromAmino: ({ initial_deposit: e, proposer: o, content: t }) => {
        let u;
        switch (t.type) {
          case "cosmos-sdk/TextProposal": {
            const { value: r } = t;
            (0, Hn.assert)((0, Hn.isNonNullObject)(r));
            const { title: m, description: f } = r;
            (0, Hn.assert)(typeof m == "string"), (0, Hn.assert)(typeof f == "string"), u = pm.Any.fromPartial({
              typeUrl: "/cosmos.gov.v1beta1.TextProposal",
              value: jn.TextProposal.encode(jn.TextProposal.fromPartial({
                title: m,
                description: f
              })).finish()
            });
            break;
          }
          default:
            throw new Error(`Unsupported proposal type: '${t.type}'`);
        }
        return {
          initialDeposit: Array.from(e),
          proposer: o,
          content: u
        };
      }
    }
  };
}
rt.createGovAminoConverters = ym;
var it = {}, yc = {}, Sc = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(n, y, w, M) {
    M === void 0 && (M = w);
    var s = Object.getOwnPropertyDescriptor(y, w);
    (!s || ("get" in s ? !y.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
      return y[w];
    } }), Object.defineProperty(n, M, s);
  } : function(n, y, w, M) {
    M === void 0 && (M = w), n[M] = y[w];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(n, y) {
    Object.defineProperty(n, "default", { enumerable: !0, value: y });
  } : function(n, y) {
    n.default = y;
  }), u = Q && Q.__importStar || function(n) {
    if (n && n.__esModule)
      return n;
    var y = {};
    if (n != null)
      for (var w in n)
        w !== "default" && Object.prototype.hasOwnProperty.call(n, w) && o(y, n, w);
    return t(y, n), y;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Params = e.TallyParams = e.VotingParams = e.DepositParams = e.Vote = e.TallyResult = e.Proposal = e.Deposit = e.WeightedVoteOption = e.proposalStatusToJSON = e.proposalStatusFromJSON = e.ProposalStatus = e.voteOptionToJSON = e.voteOptionFromJSON = e.VoteOption = e.protobufPackage = void 0;
  const r = Le, m = ye, f = Ae, b = et, R = ie, T = u(re);
  e.protobufPackage = "cosmos.gov.v1";
  var V;
  (function(n) {
    n[n.VOTE_OPTION_UNSPECIFIED = 0] = "VOTE_OPTION_UNSPECIFIED", n[n.VOTE_OPTION_YES = 1] = "VOTE_OPTION_YES", n[n.VOTE_OPTION_ABSTAIN = 2] = "VOTE_OPTION_ABSTAIN", n[n.VOTE_OPTION_NO = 3] = "VOTE_OPTION_NO", n[n.VOTE_OPTION_NO_WITH_VETO = 4] = "VOTE_OPTION_NO_WITH_VETO", n[n.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(V = e.VoteOption || (e.VoteOption = {}));
  function D(n) {
    switch (n) {
      case 0:
      case "VOTE_OPTION_UNSPECIFIED":
        return V.VOTE_OPTION_UNSPECIFIED;
      case 1:
      case "VOTE_OPTION_YES":
        return V.VOTE_OPTION_YES;
      case 2:
      case "VOTE_OPTION_ABSTAIN":
        return V.VOTE_OPTION_ABSTAIN;
      case 3:
      case "VOTE_OPTION_NO":
        return V.VOTE_OPTION_NO;
      case 4:
      case "VOTE_OPTION_NO_WITH_VETO":
        return V.VOTE_OPTION_NO_WITH_VETO;
      case -1:
      case "UNRECOGNIZED":
      default:
        return V.UNRECOGNIZED;
    }
  }
  e.voteOptionFromJSON = D;
  function B(n) {
    switch (n) {
      case V.VOTE_OPTION_UNSPECIFIED:
        return "VOTE_OPTION_UNSPECIFIED";
      case V.VOTE_OPTION_YES:
        return "VOTE_OPTION_YES";
      case V.VOTE_OPTION_ABSTAIN:
        return "VOTE_OPTION_ABSTAIN";
      case V.VOTE_OPTION_NO:
        return "VOTE_OPTION_NO";
      case V.VOTE_OPTION_NO_WITH_VETO:
        return "VOTE_OPTION_NO_WITH_VETO";
      case V.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.voteOptionToJSON = B;
  var U;
  (function(n) {
    n[n.PROPOSAL_STATUS_UNSPECIFIED = 0] = "PROPOSAL_STATUS_UNSPECIFIED", n[n.PROPOSAL_STATUS_DEPOSIT_PERIOD = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD", n[n.PROPOSAL_STATUS_VOTING_PERIOD = 2] = "PROPOSAL_STATUS_VOTING_PERIOD", n[n.PROPOSAL_STATUS_PASSED = 3] = "PROPOSAL_STATUS_PASSED", n[n.PROPOSAL_STATUS_REJECTED = 4] = "PROPOSAL_STATUS_REJECTED", n[n.PROPOSAL_STATUS_FAILED = 5] = "PROPOSAL_STATUS_FAILED", n[n.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(U = e.ProposalStatus || (e.ProposalStatus = {}));
  function C(n) {
    switch (n) {
      case 0:
      case "PROPOSAL_STATUS_UNSPECIFIED":
        return U.PROPOSAL_STATUS_UNSPECIFIED;
      case 1:
      case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
        return U.PROPOSAL_STATUS_DEPOSIT_PERIOD;
      case 2:
      case "PROPOSAL_STATUS_VOTING_PERIOD":
        return U.PROPOSAL_STATUS_VOTING_PERIOD;
      case 3:
      case "PROPOSAL_STATUS_PASSED":
        return U.PROPOSAL_STATUS_PASSED;
      case 4:
      case "PROPOSAL_STATUS_REJECTED":
        return U.PROPOSAL_STATUS_REJECTED;
      case 5:
      case "PROPOSAL_STATUS_FAILED":
        return U.PROPOSAL_STATUS_FAILED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return U.UNRECOGNIZED;
    }
  }
  e.proposalStatusFromJSON = C;
  function l(n) {
    switch (n) {
      case U.PROPOSAL_STATUS_UNSPECIFIED:
        return "PROPOSAL_STATUS_UNSPECIFIED";
      case U.PROPOSAL_STATUS_DEPOSIT_PERIOD:
        return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
      case U.PROPOSAL_STATUS_VOTING_PERIOD:
        return "PROPOSAL_STATUS_VOTING_PERIOD";
      case U.PROPOSAL_STATUS_PASSED:
        return "PROPOSAL_STATUS_PASSED";
      case U.PROPOSAL_STATUS_REJECTED:
        return "PROPOSAL_STATUS_REJECTED";
      case U.PROPOSAL_STATUS_FAILED:
        return "PROPOSAL_STATUS_FAILED";
      case U.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.proposalStatusToJSON = l;
  function S() {
    return {
      option: 0,
      weight: ""
    };
  }
  e.WeightedVoteOption = {
    encode(n, y = T.Writer.create()) {
      return n.option !== 0 && y.uint32(8).int32(n.option), n.weight !== "" && y.uint32(18).string(n.weight), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = S();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.option = w.int32();
            break;
          case 2:
            s.weight = w.string();
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        option: (0, R.isSet)(n.option) ? D(n.option) : 0,
        weight: (0, R.isSet)(n.weight) ? String(n.weight) : ""
      };
    },
    toJSON(n) {
      const y = {};
      return n.option !== void 0 && (y.option = B(n.option)), n.weight !== void 0 && (y.weight = n.weight), y;
    },
    fromPartial(n) {
      const y = S();
      return y.option = n.option ?? 0, y.weight = n.weight ?? "", y;
    }
  };
  function A() {
    return {
      proposalId: R.Long.UZERO,
      depositor: "",
      amount: []
    };
  }
  e.Deposit = {
    encode(n, y = T.Writer.create()) {
      n.proposalId.isZero() || y.uint32(8).uint64(n.proposalId), n.depositor !== "" && y.uint32(18).string(n.depositor);
      for (const w of n.amount)
        r.Coin.encode(w, y.uint32(26).fork()).ldelim();
      return y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = A();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.proposalId = w.uint64();
            break;
          case 2:
            s.depositor = w.string();
            break;
          case 3:
            s.amount.push(r.Coin.decode(w, w.uint32()));
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        proposalId: (0, R.isSet)(n.proposalId) ? R.Long.fromValue(n.proposalId) : R.Long.UZERO,
        depositor: (0, R.isSet)(n.depositor) ? String(n.depositor) : "",
        amount: Array.isArray(n == null ? void 0 : n.amount) ? n.amount.map((y) => r.Coin.fromJSON(y)) : []
      };
    },
    toJSON(n) {
      const y = {};
      return n.proposalId !== void 0 && (y.proposalId = (n.proposalId || R.Long.UZERO).toString()), n.depositor !== void 0 && (y.depositor = n.depositor), n.amount ? y.amount = n.amount.map((w) => w ? r.Coin.toJSON(w) : void 0) : y.amount = [], y;
    },
    fromPartial(n) {
      var y;
      const w = A();
      return w.proposalId = n.proposalId !== void 0 && n.proposalId !== null ? R.Long.fromValue(n.proposalId) : R.Long.UZERO, w.depositor = n.depositor ?? "", w.amount = ((y = n.amount) == null ? void 0 : y.map((M) => r.Coin.fromPartial(M))) || [], w;
    }
  };
  function d() {
    return {
      id: R.Long.UZERO,
      messages: [],
      status: 0,
      finalTallyResult: void 0,
      submitTime: void 0,
      depositEndTime: void 0,
      totalDeposit: [],
      votingStartTime: void 0,
      votingEndTime: void 0,
      metadata: "",
      title: "",
      summary: "",
      proposer: ""
    };
  }
  e.Proposal = {
    encode(n, y = T.Writer.create()) {
      n.id.isZero() || y.uint32(8).uint64(n.id);
      for (const w of n.messages)
        m.Any.encode(w, y.uint32(18).fork()).ldelim();
      n.status !== 0 && y.uint32(24).int32(n.status), n.finalTallyResult !== void 0 && e.TallyResult.encode(n.finalTallyResult, y.uint32(34).fork()).ldelim(), n.submitTime !== void 0 && f.Timestamp.encode(n.submitTime, y.uint32(42).fork()).ldelim(), n.depositEndTime !== void 0 && f.Timestamp.encode(n.depositEndTime, y.uint32(50).fork()).ldelim();
      for (const w of n.totalDeposit)
        r.Coin.encode(w, y.uint32(58).fork()).ldelim();
      return n.votingStartTime !== void 0 && f.Timestamp.encode(n.votingStartTime, y.uint32(66).fork()).ldelim(), n.votingEndTime !== void 0 && f.Timestamp.encode(n.votingEndTime, y.uint32(74).fork()).ldelim(), n.metadata !== "" && y.uint32(82).string(n.metadata), n.title !== "" && y.uint32(90).string(n.title), n.summary !== "" && y.uint32(98).string(n.summary), n.proposer !== "" && y.uint32(106).string(n.proposer), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = d();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.id = w.uint64();
            break;
          case 2:
            s.messages.push(m.Any.decode(w, w.uint32()));
            break;
          case 3:
            s.status = w.int32();
            break;
          case 4:
            s.finalTallyResult = e.TallyResult.decode(w, w.uint32());
            break;
          case 5:
            s.submitTime = f.Timestamp.decode(w, w.uint32());
            break;
          case 6:
            s.depositEndTime = f.Timestamp.decode(w, w.uint32());
            break;
          case 7:
            s.totalDeposit.push(r.Coin.decode(w, w.uint32()));
            break;
          case 8:
            s.votingStartTime = f.Timestamp.decode(w, w.uint32());
            break;
          case 9:
            s.votingEndTime = f.Timestamp.decode(w, w.uint32());
            break;
          case 10:
            s.metadata = w.string();
            break;
          case 11:
            s.title = w.string();
            break;
          case 12:
            s.summary = w.string();
            break;
          case 13:
            s.proposer = w.string();
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        id: (0, R.isSet)(n.id) ? R.Long.fromValue(n.id) : R.Long.UZERO,
        messages: Array.isArray(n == null ? void 0 : n.messages) ? n.messages.map((y) => m.Any.fromJSON(y)) : [],
        status: (0, R.isSet)(n.status) ? C(n.status) : 0,
        finalTallyResult: (0, R.isSet)(n.finalTallyResult) ? e.TallyResult.fromJSON(n.finalTallyResult) : void 0,
        submitTime: (0, R.isSet)(n.submitTime) ? (0, R.fromJsonTimestamp)(n.submitTime) : void 0,
        depositEndTime: (0, R.isSet)(n.depositEndTime) ? (0, R.fromJsonTimestamp)(n.depositEndTime) : void 0,
        totalDeposit: Array.isArray(n == null ? void 0 : n.totalDeposit) ? n.totalDeposit.map((y) => r.Coin.fromJSON(y)) : [],
        votingStartTime: (0, R.isSet)(n.votingStartTime) ? (0, R.fromJsonTimestamp)(n.votingStartTime) : void 0,
        votingEndTime: (0, R.isSet)(n.votingEndTime) ? (0, R.fromJsonTimestamp)(n.votingEndTime) : void 0,
        metadata: (0, R.isSet)(n.metadata) ? String(n.metadata) : "",
        title: (0, R.isSet)(n.title) ? String(n.title) : "",
        summary: (0, R.isSet)(n.summary) ? String(n.summary) : "",
        proposer: (0, R.isSet)(n.proposer) ? String(n.proposer) : ""
      };
    },
    toJSON(n) {
      const y = {};
      return n.id !== void 0 && (y.id = (n.id || R.Long.UZERO).toString()), n.messages ? y.messages = n.messages.map((w) => w ? m.Any.toJSON(w) : void 0) : y.messages = [], n.status !== void 0 && (y.status = l(n.status)), n.finalTallyResult !== void 0 && (y.finalTallyResult = n.finalTallyResult ? e.TallyResult.toJSON(n.finalTallyResult) : void 0), n.submitTime !== void 0 && (y.submitTime = (0, R.fromTimestamp)(n.submitTime).toISOString()), n.depositEndTime !== void 0 && (y.depositEndTime = (0, R.fromTimestamp)(n.depositEndTime).toISOString()), n.totalDeposit ? y.totalDeposit = n.totalDeposit.map((w) => w ? r.Coin.toJSON(w) : void 0) : y.totalDeposit = [], n.votingStartTime !== void 0 && (y.votingStartTime = (0, R.fromTimestamp)(n.votingStartTime).toISOString()), n.votingEndTime !== void 0 && (y.votingEndTime = (0, R.fromTimestamp)(n.votingEndTime).toISOString()), n.metadata !== void 0 && (y.metadata = n.metadata), n.title !== void 0 && (y.title = n.title), n.summary !== void 0 && (y.summary = n.summary), n.proposer !== void 0 && (y.proposer = n.proposer), y;
    },
    fromPartial(n) {
      var y, w;
      const M = d();
      return M.id = n.id !== void 0 && n.id !== null ? R.Long.fromValue(n.id) : R.Long.UZERO, M.messages = ((y = n.messages) == null ? void 0 : y.map((s) => m.Any.fromPartial(s))) || [], M.status = n.status ?? 0, M.finalTallyResult = n.finalTallyResult !== void 0 && n.finalTallyResult !== null ? e.TallyResult.fromPartial(n.finalTallyResult) : void 0, M.submitTime = n.submitTime !== void 0 && n.submitTime !== null ? f.Timestamp.fromPartial(n.submitTime) : void 0, M.depositEndTime = n.depositEndTime !== void 0 && n.depositEndTime !== null ? f.Timestamp.fromPartial(n.depositEndTime) : void 0, M.totalDeposit = ((w = n.totalDeposit) == null ? void 0 : w.map((s) => r.Coin.fromPartial(s))) || [], M.votingStartTime = n.votingStartTime !== void 0 && n.votingStartTime !== null ? f.Timestamp.fromPartial(n.votingStartTime) : void 0, M.votingEndTime = n.votingEndTime !== void 0 && n.votingEndTime !== null ? f.Timestamp.fromPartial(n.votingEndTime) : void 0, M.metadata = n.metadata ?? "", M.title = n.title ?? "", M.summary = n.summary ?? "", M.proposer = n.proposer ?? "", M;
    }
  };
  function p() {
    return {
      yesCount: "",
      abstainCount: "",
      noCount: "",
      noWithVetoCount: ""
    };
  }
  e.TallyResult = {
    encode(n, y = T.Writer.create()) {
      return n.yesCount !== "" && y.uint32(10).string(n.yesCount), n.abstainCount !== "" && y.uint32(18).string(n.abstainCount), n.noCount !== "" && y.uint32(26).string(n.noCount), n.noWithVetoCount !== "" && y.uint32(34).string(n.noWithVetoCount), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = p();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.yesCount = w.string();
            break;
          case 2:
            s.abstainCount = w.string();
            break;
          case 3:
            s.noCount = w.string();
            break;
          case 4:
            s.noWithVetoCount = w.string();
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        yesCount: (0, R.isSet)(n.yesCount) ? String(n.yesCount) : "",
        abstainCount: (0, R.isSet)(n.abstainCount) ? String(n.abstainCount) : "",
        noCount: (0, R.isSet)(n.noCount) ? String(n.noCount) : "",
        noWithVetoCount: (0, R.isSet)(n.noWithVetoCount) ? String(n.noWithVetoCount) : ""
      };
    },
    toJSON(n) {
      const y = {};
      return n.yesCount !== void 0 && (y.yesCount = n.yesCount), n.abstainCount !== void 0 && (y.abstainCount = n.abstainCount), n.noCount !== void 0 && (y.noCount = n.noCount), n.noWithVetoCount !== void 0 && (y.noWithVetoCount = n.noWithVetoCount), y;
    },
    fromPartial(n) {
      const y = p();
      return y.yesCount = n.yesCount ?? "", y.abstainCount = n.abstainCount ?? "", y.noCount = n.noCount ?? "", y.noWithVetoCount = n.noWithVetoCount ?? "", y;
    }
  };
  function h() {
    return {
      proposalId: R.Long.UZERO,
      voter: "",
      options: [],
      metadata: ""
    };
  }
  e.Vote = {
    encode(n, y = T.Writer.create()) {
      n.proposalId.isZero() || y.uint32(8).uint64(n.proposalId), n.voter !== "" && y.uint32(18).string(n.voter);
      for (const w of n.options)
        e.WeightedVoteOption.encode(w, y.uint32(34).fork()).ldelim();
      return n.metadata !== "" && y.uint32(42).string(n.metadata), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = h();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.proposalId = w.uint64();
            break;
          case 2:
            s.voter = w.string();
            break;
          case 4:
            s.options.push(e.WeightedVoteOption.decode(w, w.uint32()));
            break;
          case 5:
            s.metadata = w.string();
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        proposalId: (0, R.isSet)(n.proposalId) ? R.Long.fromValue(n.proposalId) : R.Long.UZERO,
        voter: (0, R.isSet)(n.voter) ? String(n.voter) : "",
        options: Array.isArray(n == null ? void 0 : n.options) ? n.options.map((y) => e.WeightedVoteOption.fromJSON(y)) : [],
        metadata: (0, R.isSet)(n.metadata) ? String(n.metadata) : ""
      };
    },
    toJSON(n) {
      const y = {};
      return n.proposalId !== void 0 && (y.proposalId = (n.proposalId || R.Long.UZERO).toString()), n.voter !== void 0 && (y.voter = n.voter), n.options ? y.options = n.options.map((w) => w ? e.WeightedVoteOption.toJSON(w) : void 0) : y.options = [], n.metadata !== void 0 && (y.metadata = n.metadata), y;
    },
    fromPartial(n) {
      var y;
      const w = h();
      return w.proposalId = n.proposalId !== void 0 && n.proposalId !== null ? R.Long.fromValue(n.proposalId) : R.Long.UZERO, w.voter = n.voter ?? "", w.options = ((y = n.options) == null ? void 0 : y.map((M) => e.WeightedVoteOption.fromPartial(M))) || [], w.metadata = n.metadata ?? "", w;
    }
  };
  function x() {
    return {
      minDeposit: [],
      maxDepositPeriod: void 0
    };
  }
  e.DepositParams = {
    encode(n, y = T.Writer.create()) {
      for (const w of n.minDeposit)
        r.Coin.encode(w, y.uint32(10).fork()).ldelim();
      return n.maxDepositPeriod !== void 0 && b.Duration.encode(n.maxDepositPeriod, y.uint32(18).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = x();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.minDeposit.push(r.Coin.decode(w, w.uint32()));
            break;
          case 2:
            s.maxDepositPeriod = b.Duration.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        minDeposit: Array.isArray(n == null ? void 0 : n.minDeposit) ? n.minDeposit.map((y) => r.Coin.fromJSON(y)) : [],
        maxDepositPeriod: (0, R.isSet)(n.maxDepositPeriod) ? b.Duration.fromJSON(n.maxDepositPeriod) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.minDeposit ? y.minDeposit = n.minDeposit.map((w) => w ? r.Coin.toJSON(w) : void 0) : y.minDeposit = [], n.maxDepositPeriod !== void 0 && (y.maxDepositPeriod = n.maxDepositPeriod ? b.Duration.toJSON(n.maxDepositPeriod) : void 0), y;
    },
    fromPartial(n) {
      var y;
      const w = x();
      return w.minDeposit = ((y = n.minDeposit) == null ? void 0 : y.map((M) => r.Coin.fromPartial(M))) || [], w.maxDepositPeriod = n.maxDepositPeriod !== void 0 && n.maxDepositPeriod !== null ? b.Duration.fromPartial(n.maxDepositPeriod) : void 0, w;
    }
  };
  function _() {
    return {
      votingPeriod: void 0
    };
  }
  e.VotingParams = {
    encode(n, y = T.Writer.create()) {
      return n.votingPeriod !== void 0 && b.Duration.encode(n.votingPeriod, y.uint32(10).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = _();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.votingPeriod = b.Duration.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        votingPeriod: (0, R.isSet)(n.votingPeriod) ? b.Duration.fromJSON(n.votingPeriod) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.votingPeriod !== void 0 && (y.votingPeriod = n.votingPeriod ? b.Duration.toJSON(n.votingPeriod) : void 0), y;
    },
    fromPartial(n) {
      const y = _();
      return y.votingPeriod = n.votingPeriod !== void 0 && n.votingPeriod !== null ? b.Duration.fromPartial(n.votingPeriod) : void 0, y;
    }
  };
  function I() {
    return {
      quorum: "",
      threshold: "",
      vetoThreshold: ""
    };
  }
  e.TallyParams = {
    encode(n, y = T.Writer.create()) {
      return n.quorum !== "" && y.uint32(10).string(n.quorum), n.threshold !== "" && y.uint32(18).string(n.threshold), n.vetoThreshold !== "" && y.uint32(26).string(n.vetoThreshold), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = I();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.quorum = w.string();
            break;
          case 2:
            s.threshold = w.string();
            break;
          case 3:
            s.vetoThreshold = w.string();
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        quorum: (0, R.isSet)(n.quorum) ? String(n.quorum) : "",
        threshold: (0, R.isSet)(n.threshold) ? String(n.threshold) : "",
        vetoThreshold: (0, R.isSet)(n.vetoThreshold) ? String(n.vetoThreshold) : ""
      };
    },
    toJSON(n) {
      const y = {};
      return n.quorum !== void 0 && (y.quorum = n.quorum), n.threshold !== void 0 && (y.threshold = n.threshold), n.vetoThreshold !== void 0 && (y.vetoThreshold = n.vetoThreshold), y;
    },
    fromPartial(n) {
      const y = I();
      return y.quorum = n.quorum ?? "", y.threshold = n.threshold ?? "", y.vetoThreshold = n.vetoThreshold ?? "", y;
    }
  };
  function W() {
    return {
      minDeposit: [],
      maxDepositPeriod: void 0,
      votingPeriod: void 0,
      quorum: "",
      threshold: "",
      vetoThreshold: "",
      minInitialDepositRatio: "",
      burnVoteQuorum: !1,
      burnProposalDepositPrevote: !1,
      burnVoteVeto: !1
    };
  }
  e.Params = {
    encode(n, y = T.Writer.create()) {
      for (const w of n.minDeposit)
        r.Coin.encode(w, y.uint32(10).fork()).ldelim();
      return n.maxDepositPeriod !== void 0 && b.Duration.encode(n.maxDepositPeriod, y.uint32(18).fork()).ldelim(), n.votingPeriod !== void 0 && b.Duration.encode(n.votingPeriod, y.uint32(26).fork()).ldelim(), n.quorum !== "" && y.uint32(34).string(n.quorum), n.threshold !== "" && y.uint32(42).string(n.threshold), n.vetoThreshold !== "" && y.uint32(50).string(n.vetoThreshold), n.minInitialDepositRatio !== "" && y.uint32(58).string(n.minInitialDepositRatio), n.burnVoteQuorum === !0 && y.uint32(104).bool(n.burnVoteQuorum), n.burnProposalDepositPrevote === !0 && y.uint32(112).bool(n.burnProposalDepositPrevote), n.burnVoteVeto === !0 && y.uint32(120).bool(n.burnVoteVeto), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = W();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.minDeposit.push(r.Coin.decode(w, w.uint32()));
            break;
          case 2:
            s.maxDepositPeriod = b.Duration.decode(w, w.uint32());
            break;
          case 3:
            s.votingPeriod = b.Duration.decode(w, w.uint32());
            break;
          case 4:
            s.quorum = w.string();
            break;
          case 5:
            s.threshold = w.string();
            break;
          case 6:
            s.vetoThreshold = w.string();
            break;
          case 7:
            s.minInitialDepositRatio = w.string();
            break;
          case 13:
            s.burnVoteQuorum = w.bool();
            break;
          case 14:
            s.burnProposalDepositPrevote = w.bool();
            break;
          case 15:
            s.burnVoteVeto = w.bool();
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        minDeposit: Array.isArray(n == null ? void 0 : n.minDeposit) ? n.minDeposit.map((y) => r.Coin.fromJSON(y)) : [],
        maxDepositPeriod: (0, R.isSet)(n.maxDepositPeriod) ? b.Duration.fromJSON(n.maxDepositPeriod) : void 0,
        votingPeriod: (0, R.isSet)(n.votingPeriod) ? b.Duration.fromJSON(n.votingPeriod) : void 0,
        quorum: (0, R.isSet)(n.quorum) ? String(n.quorum) : "",
        threshold: (0, R.isSet)(n.threshold) ? String(n.threshold) : "",
        vetoThreshold: (0, R.isSet)(n.vetoThreshold) ? String(n.vetoThreshold) : "",
        minInitialDepositRatio: (0, R.isSet)(n.minInitialDepositRatio) ? String(n.minInitialDepositRatio) : "",
        burnVoteQuorum: (0, R.isSet)(n.burnVoteQuorum) ? !!n.burnVoteQuorum : !1,
        burnProposalDepositPrevote: (0, R.isSet)(n.burnProposalDepositPrevote) ? !!n.burnProposalDepositPrevote : !1,
        burnVoteVeto: (0, R.isSet)(n.burnVoteVeto) ? !!n.burnVoteVeto : !1
      };
    },
    toJSON(n) {
      const y = {};
      return n.minDeposit ? y.minDeposit = n.minDeposit.map((w) => w ? r.Coin.toJSON(w) : void 0) : y.minDeposit = [], n.maxDepositPeriod !== void 0 && (y.maxDepositPeriod = n.maxDepositPeriod ? b.Duration.toJSON(n.maxDepositPeriod) : void 0), n.votingPeriod !== void 0 && (y.votingPeriod = n.votingPeriod ? b.Duration.toJSON(n.votingPeriod) : void 0), n.quorum !== void 0 && (y.quorum = n.quorum), n.threshold !== void 0 && (y.threshold = n.threshold), n.vetoThreshold !== void 0 && (y.vetoThreshold = n.vetoThreshold), n.minInitialDepositRatio !== void 0 && (y.minInitialDepositRatio = n.minInitialDepositRatio), n.burnVoteQuorum !== void 0 && (y.burnVoteQuorum = n.burnVoteQuorum), n.burnProposalDepositPrevote !== void 0 && (y.burnProposalDepositPrevote = n.burnProposalDepositPrevote), n.burnVoteVeto !== void 0 && (y.burnVoteVeto = n.burnVoteVeto), y;
    },
    fromPartial(n) {
      var y;
      const w = W();
      return w.minDeposit = ((y = n.minDeposit) == null ? void 0 : y.map((M) => r.Coin.fromPartial(M))) || [], w.maxDepositPeriod = n.maxDepositPeriod !== void 0 && n.maxDepositPeriod !== null ? b.Duration.fromPartial(n.maxDepositPeriod) : void 0, w.votingPeriod = n.votingPeriod !== void 0 && n.votingPeriod !== null ? b.Duration.fromPartial(n.votingPeriod) : void 0, w.quorum = n.quorum ?? "", w.threshold = n.threshold ?? "", w.vetoThreshold = n.vetoThreshold ?? "", w.minInitialDepositRatio = n.minInitialDepositRatio ?? "", w.burnVoteQuorum = n.burnVoteQuorum ?? !1, w.burnProposalDepositPrevote = n.burnProposalDepositPrevote ?? !1, w.burnVoteVeto = n.burnVoteVeto ?? !1, w;
    }
  };
})(Sc);
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(_, I, W, n) {
    n === void 0 && (n = W);
    var y = Object.getOwnPropertyDescriptor(I, W);
    (!y || ("get" in y ? !I.__esModule : y.writable || y.configurable)) && (y = { enumerable: !0, get: function() {
      return I[W];
    } }), Object.defineProperty(_, n, y);
  } : function(_, I, W, n) {
    n === void 0 && (n = W), _[n] = I[W];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(_, I) {
    Object.defineProperty(_, "default", { enumerable: !0, value: I });
  } : function(_, I) {
    _.default = I;
  }), u = Q && Q.__importStar || function(_) {
    if (_ && _.__esModule)
      return _;
    var I = {};
    if (_ != null)
      for (var W in _)
        W !== "default" && Object.prototype.hasOwnProperty.call(_, W) && o(I, _, W);
    return t(I, _), I;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgUpdateParamsResponse = e.MsgUpdateParams = e.MsgDepositResponse = e.MsgDeposit = e.MsgVoteWeightedResponse = e.MsgVoteWeighted = e.MsgVoteResponse = e.MsgVote = e.MsgExecLegacyContentResponse = e.MsgExecLegacyContent = e.MsgSubmitProposalResponse = e.MsgSubmitProposal = e.protobufPackage = void 0;
  const r = ye, m = Le, f = Sc, b = ie, R = u(re);
  e.protobufPackage = "cosmos.gov.v1";
  function T() {
    return {
      messages: [],
      initialDeposit: [],
      proposer: "",
      metadata: "",
      title: "",
      summary: ""
    };
  }
  e.MsgSubmitProposal = {
    encode(_, I = R.Writer.create()) {
      for (const W of _.messages)
        r.Any.encode(W, I.uint32(10).fork()).ldelim();
      for (const W of _.initialDeposit)
        m.Coin.encode(W, I.uint32(18).fork()).ldelim();
      return _.proposer !== "" && I.uint32(26).string(_.proposer), _.metadata !== "" && I.uint32(34).string(_.metadata), _.title !== "" && I.uint32(42).string(_.title), _.summary !== "" && I.uint32(50).string(_.summary), I;
    },
    decode(_, I) {
      const W = _ instanceof R.Reader ? _ : new R.Reader(_);
      let n = I === void 0 ? W.len : W.pos + I;
      const y = T();
      for (; W.pos < n; ) {
        const w = W.uint32();
        switch (w >>> 3) {
          case 1:
            y.messages.push(r.Any.decode(W, W.uint32()));
            break;
          case 2:
            y.initialDeposit.push(m.Coin.decode(W, W.uint32()));
            break;
          case 3:
            y.proposer = W.string();
            break;
          case 4:
            y.metadata = W.string();
            break;
          case 5:
            y.title = W.string();
            break;
          case 6:
            y.summary = W.string();
            break;
          default:
            W.skipType(w & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(_) {
      return {
        messages: Array.isArray(_ == null ? void 0 : _.messages) ? _.messages.map((I) => r.Any.fromJSON(I)) : [],
        initialDeposit: Array.isArray(_ == null ? void 0 : _.initialDeposit) ? _.initialDeposit.map((I) => m.Coin.fromJSON(I)) : [],
        proposer: (0, b.isSet)(_.proposer) ? String(_.proposer) : "",
        metadata: (0, b.isSet)(_.metadata) ? String(_.metadata) : "",
        title: (0, b.isSet)(_.title) ? String(_.title) : "",
        summary: (0, b.isSet)(_.summary) ? String(_.summary) : ""
      };
    },
    toJSON(_) {
      const I = {};
      return _.messages ? I.messages = _.messages.map((W) => W ? r.Any.toJSON(W) : void 0) : I.messages = [], _.initialDeposit ? I.initialDeposit = _.initialDeposit.map((W) => W ? m.Coin.toJSON(W) : void 0) : I.initialDeposit = [], _.proposer !== void 0 && (I.proposer = _.proposer), _.metadata !== void 0 && (I.metadata = _.metadata), _.title !== void 0 && (I.title = _.title), _.summary !== void 0 && (I.summary = _.summary), I;
    },
    fromPartial(_) {
      var I, W;
      const n = T();
      return n.messages = ((I = _.messages) == null ? void 0 : I.map((y) => r.Any.fromPartial(y))) || [], n.initialDeposit = ((W = _.initialDeposit) == null ? void 0 : W.map((y) => m.Coin.fromPartial(y))) || [], n.proposer = _.proposer ?? "", n.metadata = _.metadata ?? "", n.title = _.title ?? "", n.summary = _.summary ?? "", n;
    }
  };
  function V() {
    return {
      proposalId: b.Long.UZERO
    };
  }
  e.MsgSubmitProposalResponse = {
    encode(_, I = R.Writer.create()) {
      return _.proposalId.isZero() || I.uint32(8).uint64(_.proposalId), I;
    },
    decode(_, I) {
      const W = _ instanceof R.Reader ? _ : new R.Reader(_);
      let n = I === void 0 ? W.len : W.pos + I;
      const y = V();
      for (; W.pos < n; ) {
        const w = W.uint32();
        switch (w >>> 3) {
          case 1:
            y.proposalId = W.uint64();
            break;
          default:
            W.skipType(w & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(_) {
      return {
        proposalId: (0, b.isSet)(_.proposalId) ? b.Long.fromValue(_.proposalId) : b.Long.UZERO
      };
    },
    toJSON(_) {
      const I = {};
      return _.proposalId !== void 0 && (I.proposalId = (_.proposalId || b.Long.UZERO).toString()), I;
    },
    fromPartial(_) {
      const I = V();
      return I.proposalId = _.proposalId !== void 0 && _.proposalId !== null ? b.Long.fromValue(_.proposalId) : b.Long.UZERO, I;
    }
  };
  function D() {
    return {
      content: void 0,
      authority: ""
    };
  }
  e.MsgExecLegacyContent = {
    encode(_, I = R.Writer.create()) {
      return _.content !== void 0 && r.Any.encode(_.content, I.uint32(10).fork()).ldelim(), _.authority !== "" && I.uint32(18).string(_.authority), I;
    },
    decode(_, I) {
      const W = _ instanceof R.Reader ? _ : new R.Reader(_);
      let n = I === void 0 ? W.len : W.pos + I;
      const y = D();
      for (; W.pos < n; ) {
        const w = W.uint32();
        switch (w >>> 3) {
          case 1:
            y.content = r.Any.decode(W, W.uint32());
            break;
          case 2:
            y.authority = W.string();
            break;
          default:
            W.skipType(w & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(_) {
      return {
        content: (0, b.isSet)(_.content) ? r.Any.fromJSON(_.content) : void 0,
        authority: (0, b.isSet)(_.authority) ? String(_.authority) : ""
      };
    },
    toJSON(_) {
      const I = {};
      return _.content !== void 0 && (I.content = _.content ? r.Any.toJSON(_.content) : void 0), _.authority !== void 0 && (I.authority = _.authority), I;
    },
    fromPartial(_) {
      const I = D();
      return I.content = _.content !== void 0 && _.content !== null ? r.Any.fromPartial(_.content) : void 0, I.authority = _.authority ?? "", I;
    }
  };
  function B() {
    return {};
  }
  e.MsgExecLegacyContentResponse = {
    encode(_, I = R.Writer.create()) {
      return I;
    },
    decode(_, I) {
      const W = _ instanceof R.Reader ? _ : new R.Reader(_);
      let n = I === void 0 ? W.len : W.pos + I;
      const y = B();
      for (; W.pos < n; ) {
        const w = W.uint32();
        switch (w >>> 3) {
          default:
            W.skipType(w & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(_) {
      return {};
    },
    toJSON(_) {
      return {};
    },
    fromPartial(_) {
      return B();
    }
  };
  function U() {
    return {
      proposalId: b.Long.UZERO,
      voter: "",
      option: 0,
      metadata: ""
    };
  }
  e.MsgVote = {
    encode(_, I = R.Writer.create()) {
      return _.proposalId.isZero() || I.uint32(8).uint64(_.proposalId), _.voter !== "" && I.uint32(18).string(_.voter), _.option !== 0 && I.uint32(24).int32(_.option), _.metadata !== "" && I.uint32(34).string(_.metadata), I;
    },
    decode(_, I) {
      const W = _ instanceof R.Reader ? _ : new R.Reader(_);
      let n = I === void 0 ? W.len : W.pos + I;
      const y = U();
      for (; W.pos < n; ) {
        const w = W.uint32();
        switch (w >>> 3) {
          case 1:
            y.proposalId = W.uint64();
            break;
          case 2:
            y.voter = W.string();
            break;
          case 3:
            y.option = W.int32();
            break;
          case 4:
            y.metadata = W.string();
            break;
          default:
            W.skipType(w & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(_) {
      return {
        proposalId: (0, b.isSet)(_.proposalId) ? b.Long.fromValue(_.proposalId) : b.Long.UZERO,
        voter: (0, b.isSet)(_.voter) ? String(_.voter) : "",
        option: (0, b.isSet)(_.option) ? (0, f.voteOptionFromJSON)(_.option) : 0,
        metadata: (0, b.isSet)(_.metadata) ? String(_.metadata) : ""
      };
    },
    toJSON(_) {
      const I = {};
      return _.proposalId !== void 0 && (I.proposalId = (_.proposalId || b.Long.UZERO).toString()), _.voter !== void 0 && (I.voter = _.voter), _.option !== void 0 && (I.option = (0, f.voteOptionToJSON)(_.option)), _.metadata !== void 0 && (I.metadata = _.metadata), I;
    },
    fromPartial(_) {
      const I = U();
      return I.proposalId = _.proposalId !== void 0 && _.proposalId !== null ? b.Long.fromValue(_.proposalId) : b.Long.UZERO, I.voter = _.voter ?? "", I.option = _.option ?? 0, I.metadata = _.metadata ?? "", I;
    }
  };
  function C() {
    return {};
  }
  e.MsgVoteResponse = {
    encode(_, I = R.Writer.create()) {
      return I;
    },
    decode(_, I) {
      const W = _ instanceof R.Reader ? _ : new R.Reader(_);
      let n = I === void 0 ? W.len : W.pos + I;
      const y = C();
      for (; W.pos < n; ) {
        const w = W.uint32();
        switch (w >>> 3) {
          default:
            W.skipType(w & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(_) {
      return {};
    },
    toJSON(_) {
      return {};
    },
    fromPartial(_) {
      return C();
    }
  };
  function l() {
    return {
      proposalId: b.Long.UZERO,
      voter: "",
      options: [],
      metadata: ""
    };
  }
  e.MsgVoteWeighted = {
    encode(_, I = R.Writer.create()) {
      _.proposalId.isZero() || I.uint32(8).uint64(_.proposalId), _.voter !== "" && I.uint32(18).string(_.voter);
      for (const W of _.options)
        f.WeightedVoteOption.encode(W, I.uint32(26).fork()).ldelim();
      return _.metadata !== "" && I.uint32(34).string(_.metadata), I;
    },
    decode(_, I) {
      const W = _ instanceof R.Reader ? _ : new R.Reader(_);
      let n = I === void 0 ? W.len : W.pos + I;
      const y = l();
      for (; W.pos < n; ) {
        const w = W.uint32();
        switch (w >>> 3) {
          case 1:
            y.proposalId = W.uint64();
            break;
          case 2:
            y.voter = W.string();
            break;
          case 3:
            y.options.push(f.WeightedVoteOption.decode(W, W.uint32()));
            break;
          case 4:
            y.metadata = W.string();
            break;
          default:
            W.skipType(w & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(_) {
      return {
        proposalId: (0, b.isSet)(_.proposalId) ? b.Long.fromValue(_.proposalId) : b.Long.UZERO,
        voter: (0, b.isSet)(_.voter) ? String(_.voter) : "",
        options: Array.isArray(_ == null ? void 0 : _.options) ? _.options.map((I) => f.WeightedVoteOption.fromJSON(I)) : [],
        metadata: (0, b.isSet)(_.metadata) ? String(_.metadata) : ""
      };
    },
    toJSON(_) {
      const I = {};
      return _.proposalId !== void 0 && (I.proposalId = (_.proposalId || b.Long.UZERO).toString()), _.voter !== void 0 && (I.voter = _.voter), _.options ? I.options = _.options.map((W) => W ? f.WeightedVoteOption.toJSON(W) : void 0) : I.options = [], _.metadata !== void 0 && (I.metadata = _.metadata), I;
    },
    fromPartial(_) {
      var I;
      const W = l();
      return W.proposalId = _.proposalId !== void 0 && _.proposalId !== null ? b.Long.fromValue(_.proposalId) : b.Long.UZERO, W.voter = _.voter ?? "", W.options = ((I = _.options) == null ? void 0 : I.map((n) => f.WeightedVoteOption.fromPartial(n))) || [], W.metadata = _.metadata ?? "", W;
    }
  };
  function S() {
    return {};
  }
  e.MsgVoteWeightedResponse = {
    encode(_, I = R.Writer.create()) {
      return I;
    },
    decode(_, I) {
      const W = _ instanceof R.Reader ? _ : new R.Reader(_);
      let n = I === void 0 ? W.len : W.pos + I;
      const y = S();
      for (; W.pos < n; ) {
        const w = W.uint32();
        switch (w >>> 3) {
          default:
            W.skipType(w & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(_) {
      return {};
    },
    toJSON(_) {
      return {};
    },
    fromPartial(_) {
      return S();
    }
  };
  function A() {
    return {
      proposalId: b.Long.UZERO,
      depositor: "",
      amount: []
    };
  }
  e.MsgDeposit = {
    encode(_, I = R.Writer.create()) {
      _.proposalId.isZero() || I.uint32(8).uint64(_.proposalId), _.depositor !== "" && I.uint32(18).string(_.depositor);
      for (const W of _.amount)
        m.Coin.encode(W, I.uint32(26).fork()).ldelim();
      return I;
    },
    decode(_, I) {
      const W = _ instanceof R.Reader ? _ : new R.Reader(_);
      let n = I === void 0 ? W.len : W.pos + I;
      const y = A();
      for (; W.pos < n; ) {
        const w = W.uint32();
        switch (w >>> 3) {
          case 1:
            y.proposalId = W.uint64();
            break;
          case 2:
            y.depositor = W.string();
            break;
          case 3:
            y.amount.push(m.Coin.decode(W, W.uint32()));
            break;
          default:
            W.skipType(w & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(_) {
      return {
        proposalId: (0, b.isSet)(_.proposalId) ? b.Long.fromValue(_.proposalId) : b.Long.UZERO,
        depositor: (0, b.isSet)(_.depositor) ? String(_.depositor) : "",
        amount: Array.isArray(_ == null ? void 0 : _.amount) ? _.amount.map((I) => m.Coin.fromJSON(I)) : []
      };
    },
    toJSON(_) {
      const I = {};
      return _.proposalId !== void 0 && (I.proposalId = (_.proposalId || b.Long.UZERO).toString()), _.depositor !== void 0 && (I.depositor = _.depositor), _.amount ? I.amount = _.amount.map((W) => W ? m.Coin.toJSON(W) : void 0) : I.amount = [], I;
    },
    fromPartial(_) {
      var I;
      const W = A();
      return W.proposalId = _.proposalId !== void 0 && _.proposalId !== null ? b.Long.fromValue(_.proposalId) : b.Long.UZERO, W.depositor = _.depositor ?? "", W.amount = ((I = _.amount) == null ? void 0 : I.map((n) => m.Coin.fromPartial(n))) || [], W;
    }
  };
  function d() {
    return {};
  }
  e.MsgDepositResponse = {
    encode(_, I = R.Writer.create()) {
      return I;
    },
    decode(_, I) {
      const W = _ instanceof R.Reader ? _ : new R.Reader(_);
      let n = I === void 0 ? W.len : W.pos + I;
      const y = d();
      for (; W.pos < n; ) {
        const w = W.uint32();
        switch (w >>> 3) {
          default:
            W.skipType(w & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(_) {
      return {};
    },
    toJSON(_) {
      return {};
    },
    fromPartial(_) {
      return d();
    }
  };
  function p() {
    return {
      authority: "",
      params: void 0
    };
  }
  e.MsgUpdateParams = {
    encode(_, I = R.Writer.create()) {
      return _.authority !== "" && I.uint32(10).string(_.authority), _.params !== void 0 && f.Params.encode(_.params, I.uint32(18).fork()).ldelim(), I;
    },
    decode(_, I) {
      const W = _ instanceof R.Reader ? _ : new R.Reader(_);
      let n = I === void 0 ? W.len : W.pos + I;
      const y = p();
      for (; W.pos < n; ) {
        const w = W.uint32();
        switch (w >>> 3) {
          case 1:
            y.authority = W.string();
            break;
          case 2:
            y.params = f.Params.decode(W, W.uint32());
            break;
          default:
            W.skipType(w & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(_) {
      return {
        authority: (0, b.isSet)(_.authority) ? String(_.authority) : "",
        params: (0, b.isSet)(_.params) ? f.Params.fromJSON(_.params) : void 0
      };
    },
    toJSON(_) {
      const I = {};
      return _.authority !== void 0 && (I.authority = _.authority), _.params !== void 0 && (I.params = _.params ? f.Params.toJSON(_.params) : void 0), I;
    },
    fromPartial(_) {
      const I = p();
      return I.authority = _.authority ?? "", I.params = _.params !== void 0 && _.params !== null ? f.Params.fromPartial(_.params) : void 0, I;
    }
  };
  function h() {
    return {};
  }
  e.MsgUpdateParamsResponse = {
    encode(_, I = R.Writer.create()) {
      return I;
    },
    decode(_, I) {
      const W = _ instanceof R.Reader ? _ : new R.Reader(_);
      let n = I === void 0 ? W.len : W.pos + I;
      const y = h();
      for (; W.pos < n; ) {
        const w = W.uint32();
        switch (w >>> 3) {
          default:
            W.skipType(w & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(_) {
      return {};
    },
    toJSON(_) {
      return {};
    },
    fromPartial(_) {
      return h();
    }
  };
  class x {
    constructor(I) {
      this.rpc = I, this.SubmitProposal = this.SubmitProposal.bind(this), this.ExecLegacyContent = this.ExecLegacyContent.bind(this), this.Vote = this.Vote.bind(this), this.VoteWeighted = this.VoteWeighted.bind(this), this.Deposit = this.Deposit.bind(this), this.UpdateParams = this.UpdateParams.bind(this);
    }
    SubmitProposal(I) {
      const W = e.MsgSubmitProposal.encode(I).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "SubmitProposal", W).then((n) => e.MsgSubmitProposalResponse.decode(new R.Reader(n)));
    }
    ExecLegacyContent(I) {
      const W = e.MsgExecLegacyContent.encode(I).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "ExecLegacyContent", W).then((n) => e.MsgExecLegacyContentResponse.decode(new R.Reader(n)));
    }
    Vote(I) {
      const W = e.MsgVote.encode(I).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "Vote", W).then((n) => e.MsgVoteResponse.decode(new R.Reader(n)));
    }
    VoteWeighted(I) {
      const W = e.MsgVoteWeighted.encode(I).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "VoteWeighted", W).then((n) => e.MsgVoteWeightedResponse.decode(new R.Reader(n)));
    }
    Deposit(I) {
      const W = e.MsgDeposit.encode(I).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "Deposit", W).then((n) => e.MsgDepositResponse.decode(new R.Reader(n)));
    }
    UpdateParams(I) {
      const W = e.MsgUpdateParams.encode(I).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "UpdateParams", W).then((n) => e.MsgUpdateParamsResponse.decode(new R.Reader(n)));
    }
  }
  e.MsgClientImpl = x;
})(yc);
var bc = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(d, p, h, x) {
    x === void 0 && (x = h);
    var _ = Object.getOwnPropertyDescriptor(p, h);
    (!_ || ("get" in _ ? !p.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return p[h];
    } }), Object.defineProperty(d, x, _);
  } : function(d, p, h, x) {
    x === void 0 && (x = h), d[x] = p[h];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(d, p) {
    Object.defineProperty(d, "default", { enumerable: !0, value: p });
  } : function(d, p) {
    d.default = p;
  }), u = Q && Q.__importStar || function(d) {
    if (d && d.__esModule)
      return d;
    var p = {};
    if (d != null)
      for (var h in d)
        h !== "default" && Object.prototype.hasOwnProperty.call(d, h) && o(p, d, h);
    return t(p, d), p;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgDepositResponse = e.MsgDeposit = e.MsgVoteWeightedResponse = e.MsgVoteWeighted = e.MsgVoteResponse = e.MsgVote = e.MsgSubmitProposalResponse = e.MsgSubmitProposal = e.protobufPackage = void 0;
  const r = ye, m = Le, f = sr, b = ie, R = u(re);
  e.protobufPackage = "cosmos.gov.v1beta1";
  function T() {
    return {
      content: void 0,
      initialDeposit: [],
      proposer: ""
    };
  }
  e.MsgSubmitProposal = {
    encode(d, p = R.Writer.create()) {
      d.content !== void 0 && r.Any.encode(d.content, p.uint32(10).fork()).ldelim();
      for (const h of d.initialDeposit)
        m.Coin.encode(h, p.uint32(18).fork()).ldelim();
      return d.proposer !== "" && p.uint32(26).string(d.proposer), p;
    },
    decode(d, p) {
      const h = d instanceof R.Reader ? d : new R.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = T();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.content = r.Any.decode(h, h.uint32());
            break;
          case 2:
            _.initialDeposit.push(m.Coin.decode(h, h.uint32()));
            break;
          case 3:
            _.proposer = h.string();
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        content: (0, b.isSet)(d.content) ? r.Any.fromJSON(d.content) : void 0,
        initialDeposit: Array.isArray(d == null ? void 0 : d.initialDeposit) ? d.initialDeposit.map((p) => m.Coin.fromJSON(p)) : [],
        proposer: (0, b.isSet)(d.proposer) ? String(d.proposer) : ""
      };
    },
    toJSON(d) {
      const p = {};
      return d.content !== void 0 && (p.content = d.content ? r.Any.toJSON(d.content) : void 0), d.initialDeposit ? p.initialDeposit = d.initialDeposit.map((h) => h ? m.Coin.toJSON(h) : void 0) : p.initialDeposit = [], d.proposer !== void 0 && (p.proposer = d.proposer), p;
    },
    fromPartial(d) {
      var p;
      const h = T();
      return h.content = d.content !== void 0 && d.content !== null ? r.Any.fromPartial(d.content) : void 0, h.initialDeposit = ((p = d.initialDeposit) == null ? void 0 : p.map((x) => m.Coin.fromPartial(x))) || [], h.proposer = d.proposer ?? "", h;
    }
  };
  function V() {
    return {
      proposalId: b.Long.UZERO
    };
  }
  e.MsgSubmitProposalResponse = {
    encode(d, p = R.Writer.create()) {
      return d.proposalId.isZero() || p.uint32(8).uint64(d.proposalId), p;
    },
    decode(d, p) {
      const h = d instanceof R.Reader ? d : new R.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = V();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.proposalId = h.uint64();
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        proposalId: (0, b.isSet)(d.proposalId) ? b.Long.fromValue(d.proposalId) : b.Long.UZERO
      };
    },
    toJSON(d) {
      const p = {};
      return d.proposalId !== void 0 && (p.proposalId = (d.proposalId || b.Long.UZERO).toString()), p;
    },
    fromPartial(d) {
      const p = V();
      return p.proposalId = d.proposalId !== void 0 && d.proposalId !== null ? b.Long.fromValue(d.proposalId) : b.Long.UZERO, p;
    }
  };
  function D() {
    return {
      proposalId: b.Long.UZERO,
      voter: "",
      option: 0
    };
  }
  e.MsgVote = {
    encode(d, p = R.Writer.create()) {
      return d.proposalId.isZero() || p.uint32(8).uint64(d.proposalId), d.voter !== "" && p.uint32(18).string(d.voter), d.option !== 0 && p.uint32(24).int32(d.option), p;
    },
    decode(d, p) {
      const h = d instanceof R.Reader ? d : new R.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = D();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.proposalId = h.uint64();
            break;
          case 2:
            _.voter = h.string();
            break;
          case 3:
            _.option = h.int32();
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        proposalId: (0, b.isSet)(d.proposalId) ? b.Long.fromValue(d.proposalId) : b.Long.UZERO,
        voter: (0, b.isSet)(d.voter) ? String(d.voter) : "",
        option: (0, b.isSet)(d.option) ? (0, f.voteOptionFromJSON)(d.option) : 0
      };
    },
    toJSON(d) {
      const p = {};
      return d.proposalId !== void 0 && (p.proposalId = (d.proposalId || b.Long.UZERO).toString()), d.voter !== void 0 && (p.voter = d.voter), d.option !== void 0 && (p.option = (0, f.voteOptionToJSON)(d.option)), p;
    },
    fromPartial(d) {
      const p = D();
      return p.proposalId = d.proposalId !== void 0 && d.proposalId !== null ? b.Long.fromValue(d.proposalId) : b.Long.UZERO, p.voter = d.voter ?? "", p.option = d.option ?? 0, p;
    }
  };
  function B() {
    return {};
  }
  e.MsgVoteResponse = {
    encode(d, p = R.Writer.create()) {
      return p;
    },
    decode(d, p) {
      const h = d instanceof R.Reader ? d : new R.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = B();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {};
    },
    toJSON(d) {
      return {};
    },
    fromPartial(d) {
      return B();
    }
  };
  function U() {
    return {
      proposalId: b.Long.UZERO,
      voter: "",
      options: []
    };
  }
  e.MsgVoteWeighted = {
    encode(d, p = R.Writer.create()) {
      d.proposalId.isZero() || p.uint32(8).uint64(d.proposalId), d.voter !== "" && p.uint32(18).string(d.voter);
      for (const h of d.options)
        f.WeightedVoteOption.encode(h, p.uint32(26).fork()).ldelim();
      return p;
    },
    decode(d, p) {
      const h = d instanceof R.Reader ? d : new R.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = U();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.proposalId = h.uint64();
            break;
          case 2:
            _.voter = h.string();
            break;
          case 3:
            _.options.push(f.WeightedVoteOption.decode(h, h.uint32()));
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        proposalId: (0, b.isSet)(d.proposalId) ? b.Long.fromValue(d.proposalId) : b.Long.UZERO,
        voter: (0, b.isSet)(d.voter) ? String(d.voter) : "",
        options: Array.isArray(d == null ? void 0 : d.options) ? d.options.map((p) => f.WeightedVoteOption.fromJSON(p)) : []
      };
    },
    toJSON(d) {
      const p = {};
      return d.proposalId !== void 0 && (p.proposalId = (d.proposalId || b.Long.UZERO).toString()), d.voter !== void 0 && (p.voter = d.voter), d.options ? p.options = d.options.map((h) => h ? f.WeightedVoteOption.toJSON(h) : void 0) : p.options = [], p;
    },
    fromPartial(d) {
      var p;
      const h = U();
      return h.proposalId = d.proposalId !== void 0 && d.proposalId !== null ? b.Long.fromValue(d.proposalId) : b.Long.UZERO, h.voter = d.voter ?? "", h.options = ((p = d.options) == null ? void 0 : p.map((x) => f.WeightedVoteOption.fromPartial(x))) || [], h;
    }
  };
  function C() {
    return {};
  }
  e.MsgVoteWeightedResponse = {
    encode(d, p = R.Writer.create()) {
      return p;
    },
    decode(d, p) {
      const h = d instanceof R.Reader ? d : new R.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = C();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {};
    },
    toJSON(d) {
      return {};
    },
    fromPartial(d) {
      return C();
    }
  };
  function l() {
    return {
      proposalId: b.Long.UZERO,
      depositor: "",
      amount: []
    };
  }
  e.MsgDeposit = {
    encode(d, p = R.Writer.create()) {
      d.proposalId.isZero() || p.uint32(8).uint64(d.proposalId), d.depositor !== "" && p.uint32(18).string(d.depositor);
      for (const h of d.amount)
        m.Coin.encode(h, p.uint32(26).fork()).ldelim();
      return p;
    },
    decode(d, p) {
      const h = d instanceof R.Reader ? d : new R.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = l();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.proposalId = h.uint64();
            break;
          case 2:
            _.depositor = h.string();
            break;
          case 3:
            _.amount.push(m.Coin.decode(h, h.uint32()));
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        proposalId: (0, b.isSet)(d.proposalId) ? b.Long.fromValue(d.proposalId) : b.Long.UZERO,
        depositor: (0, b.isSet)(d.depositor) ? String(d.depositor) : "",
        amount: Array.isArray(d == null ? void 0 : d.amount) ? d.amount.map((p) => m.Coin.fromJSON(p)) : []
      };
    },
    toJSON(d) {
      const p = {};
      return d.proposalId !== void 0 && (p.proposalId = (d.proposalId || b.Long.UZERO).toString()), d.depositor !== void 0 && (p.depositor = d.depositor), d.amount ? p.amount = d.amount.map((h) => h ? m.Coin.toJSON(h) : void 0) : p.amount = [], p;
    },
    fromPartial(d) {
      var p;
      const h = l();
      return h.proposalId = d.proposalId !== void 0 && d.proposalId !== null ? b.Long.fromValue(d.proposalId) : b.Long.UZERO, h.depositor = d.depositor ?? "", h.amount = ((p = d.amount) == null ? void 0 : p.map((x) => m.Coin.fromPartial(x))) || [], h;
    }
  };
  function S() {
    return {};
  }
  e.MsgDepositResponse = {
    encode(d, p = R.Writer.create()) {
      return p;
    },
    decode(d, p) {
      const h = d instanceof R.Reader ? d : new R.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = S();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {};
    },
    toJSON(d) {
      return {};
    },
    fromPartial(d) {
      return S();
    }
  };
  class A {
    constructor(p) {
      this.rpc = p, this.SubmitProposal = this.SubmitProposal.bind(this), this.Vote = this.Vote.bind(this), this.VoteWeighted = this.VoteWeighted.bind(this), this.Deposit = this.Deposit.bind(this);
    }
    SubmitProposal(p) {
      const h = e.MsgSubmitProposal.encode(p).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Msg", "SubmitProposal", h).then((x) => e.MsgSubmitProposalResponse.decode(new R.Reader(x)));
    }
    Vote(p) {
      const h = e.MsgVote.encode(p).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Msg", "Vote", h).then((x) => e.MsgVoteResponse.decode(new R.Reader(x)));
    }
    VoteWeighted(p) {
      const h = e.MsgVoteWeighted.encode(p).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Msg", "VoteWeighted", h).then((x) => e.MsgVoteWeightedResponse.decode(new R.Reader(x)));
    }
    Deposit(p) {
      const h = e.MsgDeposit.encode(p).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Msg", "Deposit", h).then((x) => e.MsgDepositResponse.decode(new R.Reader(x)));
    }
  }
  e.MsgClientImpl = A;
})(bc);
Object.defineProperty(it, "__esModule", { value: !0 });
it.isMsgVoteWeightedEncodeObject = it.isMsgVoteEncodeObject = it.isMsgSubmitProposalEncodeObject = it.isMsgDepositEncodeObject = it.govTypes = void 0;
const Wn = yc, ho = bc;
it.govTypes = [
  ["/cosmos.gov.v1.MsgDeposit", Wn.MsgDeposit],
  ["/cosmos.gov.v1.MsgSubmitProposal", Wn.MsgSubmitProposal],
  ["/cosmos.gov.v1.MsgUpdateParams", Wn.MsgUpdateParams],
  ["/cosmos.gov.v1.MsgVote", Wn.MsgVote],
  ["/cosmos.gov.v1.MsgVoteWeighted", Wn.MsgVoteWeighted],
  ["/cosmos.gov.v1beta1.MsgDeposit", ho.MsgDeposit],
  ["/cosmos.gov.v1beta1.MsgSubmitProposal", ho.MsgSubmitProposal],
  ["/cosmos.gov.v1beta1.MsgVote", ho.MsgVote],
  ["/cosmos.gov.v1beta1.MsgVoteWeighted", ho.MsgVoteWeighted]
];
function Sm(e) {
  return e.typeUrl === "/cosmos.gov.v1beta1.MsgDeposit";
}
it.isMsgDepositEncodeObject = Sm;
function bm(e) {
  return e.typeUrl === "/cosmos.gov.v1beta1.MsgSubmitProposal";
}
it.isMsgSubmitProposalEncodeObject = bm;
function Om(e) {
  return e.typeUrl === "/cosmos.gov.v1beta1.MsgVote";
}
it.isMsgVoteEncodeObject = Om;
function km(e) {
  return e.typeUrl === "/cosmos.gov.v1beta1.MsgVoteWeighted";
}
it.isMsgVoteWeightedEncodeObject = km;
var ar = {}, Oc = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(n, y, w, M) {
    M === void 0 && (M = w);
    var s = Object.getOwnPropertyDescriptor(y, w);
    (!s || ("get" in s ? !y.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
      return y[w];
    } }), Object.defineProperty(n, M, s);
  } : function(n, y, w, M) {
    M === void 0 && (M = w), n[M] = y[w];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(n, y) {
    Object.defineProperty(n, "default", { enumerable: !0, value: y });
  } : function(n, y) {
    n.default = y;
  }), u = Q && Q.__importStar || function(n) {
    if (n && n.__esModule)
      return n;
    var y = {};
    if (n != null)
      for (var w in n)
        w !== "default" && Object.prototype.hasOwnProperty.call(n, w) && o(y, n, w);
    return t(y, n), y;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryTallyResultResponse = e.QueryTallyResultRequest = e.QueryDepositsResponse = e.QueryDepositsRequest = e.QueryDepositResponse = e.QueryDepositRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.QueryVotesResponse = e.QueryVotesRequest = e.QueryVoteResponse = e.QueryVoteRequest = e.QueryProposalsResponse = e.QueryProposalsRequest = e.QueryProposalResponse = e.QueryProposalRequest = e.protobufPackage = void 0;
  const r = sr, m = be, f = ie, b = u(re);
  e.protobufPackage = "cosmos.gov.v1beta1";
  function R() {
    return {
      proposalId: f.Long.UZERO
    };
  }
  e.QueryProposalRequest = {
    encode(n, y = b.Writer.create()) {
      return n.proposalId.isZero() || y.uint32(8).uint64(n.proposalId), y;
    },
    decode(n, y) {
      const w = n instanceof b.Reader ? n : new b.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = R();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.proposalId = w.uint64();
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        proposalId: (0, f.isSet)(n.proposalId) ? f.Long.fromValue(n.proposalId) : f.Long.UZERO
      };
    },
    toJSON(n) {
      const y = {};
      return n.proposalId !== void 0 && (y.proposalId = (n.proposalId || f.Long.UZERO).toString()), y;
    },
    fromPartial(n) {
      const y = R();
      return y.proposalId = n.proposalId !== void 0 && n.proposalId !== null ? f.Long.fromValue(n.proposalId) : f.Long.UZERO, y;
    }
  };
  function T() {
    return {
      proposal: void 0
    };
  }
  e.QueryProposalResponse = {
    encode(n, y = b.Writer.create()) {
      return n.proposal !== void 0 && r.Proposal.encode(n.proposal, y.uint32(10).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof b.Reader ? n : new b.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = T();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.proposal = r.Proposal.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        proposal: (0, f.isSet)(n.proposal) ? r.Proposal.fromJSON(n.proposal) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.proposal !== void 0 && (y.proposal = n.proposal ? r.Proposal.toJSON(n.proposal) : void 0), y;
    },
    fromPartial(n) {
      const y = T();
      return y.proposal = n.proposal !== void 0 && n.proposal !== null ? r.Proposal.fromPartial(n.proposal) : void 0, y;
    }
  };
  function V() {
    return {
      proposalStatus: 0,
      voter: "",
      depositor: "",
      pagination: void 0
    };
  }
  e.QueryProposalsRequest = {
    encode(n, y = b.Writer.create()) {
      return n.proposalStatus !== 0 && y.uint32(8).int32(n.proposalStatus), n.voter !== "" && y.uint32(18).string(n.voter), n.depositor !== "" && y.uint32(26).string(n.depositor), n.pagination !== void 0 && m.PageRequest.encode(n.pagination, y.uint32(34).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof b.Reader ? n : new b.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = V();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.proposalStatus = w.int32();
            break;
          case 2:
            s.voter = w.string();
            break;
          case 3:
            s.depositor = w.string();
            break;
          case 4:
            s.pagination = m.PageRequest.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        proposalStatus: (0, f.isSet)(n.proposalStatus) ? (0, r.proposalStatusFromJSON)(n.proposalStatus) : 0,
        voter: (0, f.isSet)(n.voter) ? String(n.voter) : "",
        depositor: (0, f.isSet)(n.depositor) ? String(n.depositor) : "",
        pagination: (0, f.isSet)(n.pagination) ? m.PageRequest.fromJSON(n.pagination) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.proposalStatus !== void 0 && (y.proposalStatus = (0, r.proposalStatusToJSON)(n.proposalStatus)), n.voter !== void 0 && (y.voter = n.voter), n.depositor !== void 0 && (y.depositor = n.depositor), n.pagination !== void 0 && (y.pagination = n.pagination ? m.PageRequest.toJSON(n.pagination) : void 0), y;
    },
    fromPartial(n) {
      const y = V();
      return y.proposalStatus = n.proposalStatus ?? 0, y.voter = n.voter ?? "", y.depositor = n.depositor ?? "", y.pagination = n.pagination !== void 0 && n.pagination !== null ? m.PageRequest.fromPartial(n.pagination) : void 0, y;
    }
  };
  function D() {
    return {
      proposals: [],
      pagination: void 0
    };
  }
  e.QueryProposalsResponse = {
    encode(n, y = b.Writer.create()) {
      for (const w of n.proposals)
        r.Proposal.encode(w, y.uint32(10).fork()).ldelim();
      return n.pagination !== void 0 && m.PageResponse.encode(n.pagination, y.uint32(18).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof b.Reader ? n : new b.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = D();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.proposals.push(r.Proposal.decode(w, w.uint32()));
            break;
          case 2:
            s.pagination = m.PageResponse.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        proposals: Array.isArray(n == null ? void 0 : n.proposals) ? n.proposals.map((y) => r.Proposal.fromJSON(y)) : [],
        pagination: (0, f.isSet)(n.pagination) ? m.PageResponse.fromJSON(n.pagination) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.proposals ? y.proposals = n.proposals.map((w) => w ? r.Proposal.toJSON(w) : void 0) : y.proposals = [], n.pagination !== void 0 && (y.pagination = n.pagination ? m.PageResponse.toJSON(n.pagination) : void 0), y;
    },
    fromPartial(n) {
      var y;
      const w = D();
      return w.proposals = ((y = n.proposals) == null ? void 0 : y.map((M) => r.Proposal.fromPartial(M))) || [], w.pagination = n.pagination !== void 0 && n.pagination !== null ? m.PageResponse.fromPartial(n.pagination) : void 0, w;
    }
  };
  function B() {
    return {
      proposalId: f.Long.UZERO,
      voter: ""
    };
  }
  e.QueryVoteRequest = {
    encode(n, y = b.Writer.create()) {
      return n.proposalId.isZero() || y.uint32(8).uint64(n.proposalId), n.voter !== "" && y.uint32(18).string(n.voter), y;
    },
    decode(n, y) {
      const w = n instanceof b.Reader ? n : new b.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = B();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.proposalId = w.uint64();
            break;
          case 2:
            s.voter = w.string();
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        proposalId: (0, f.isSet)(n.proposalId) ? f.Long.fromValue(n.proposalId) : f.Long.UZERO,
        voter: (0, f.isSet)(n.voter) ? String(n.voter) : ""
      };
    },
    toJSON(n) {
      const y = {};
      return n.proposalId !== void 0 && (y.proposalId = (n.proposalId || f.Long.UZERO).toString()), n.voter !== void 0 && (y.voter = n.voter), y;
    },
    fromPartial(n) {
      const y = B();
      return y.proposalId = n.proposalId !== void 0 && n.proposalId !== null ? f.Long.fromValue(n.proposalId) : f.Long.UZERO, y.voter = n.voter ?? "", y;
    }
  };
  function U() {
    return {
      vote: void 0
    };
  }
  e.QueryVoteResponse = {
    encode(n, y = b.Writer.create()) {
      return n.vote !== void 0 && r.Vote.encode(n.vote, y.uint32(10).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof b.Reader ? n : new b.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = U();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.vote = r.Vote.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        vote: (0, f.isSet)(n.vote) ? r.Vote.fromJSON(n.vote) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.vote !== void 0 && (y.vote = n.vote ? r.Vote.toJSON(n.vote) : void 0), y;
    },
    fromPartial(n) {
      const y = U();
      return y.vote = n.vote !== void 0 && n.vote !== null ? r.Vote.fromPartial(n.vote) : void 0, y;
    }
  };
  function C() {
    return {
      proposalId: f.Long.UZERO,
      pagination: void 0
    };
  }
  e.QueryVotesRequest = {
    encode(n, y = b.Writer.create()) {
      return n.proposalId.isZero() || y.uint32(8).uint64(n.proposalId), n.pagination !== void 0 && m.PageRequest.encode(n.pagination, y.uint32(18).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof b.Reader ? n : new b.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = C();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.proposalId = w.uint64();
            break;
          case 2:
            s.pagination = m.PageRequest.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        proposalId: (0, f.isSet)(n.proposalId) ? f.Long.fromValue(n.proposalId) : f.Long.UZERO,
        pagination: (0, f.isSet)(n.pagination) ? m.PageRequest.fromJSON(n.pagination) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.proposalId !== void 0 && (y.proposalId = (n.proposalId || f.Long.UZERO).toString()), n.pagination !== void 0 && (y.pagination = n.pagination ? m.PageRequest.toJSON(n.pagination) : void 0), y;
    },
    fromPartial(n) {
      const y = C();
      return y.proposalId = n.proposalId !== void 0 && n.proposalId !== null ? f.Long.fromValue(n.proposalId) : f.Long.UZERO, y.pagination = n.pagination !== void 0 && n.pagination !== null ? m.PageRequest.fromPartial(n.pagination) : void 0, y;
    }
  };
  function l() {
    return {
      votes: [],
      pagination: void 0
    };
  }
  e.QueryVotesResponse = {
    encode(n, y = b.Writer.create()) {
      for (const w of n.votes)
        r.Vote.encode(w, y.uint32(10).fork()).ldelim();
      return n.pagination !== void 0 && m.PageResponse.encode(n.pagination, y.uint32(18).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof b.Reader ? n : new b.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = l();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.votes.push(r.Vote.decode(w, w.uint32()));
            break;
          case 2:
            s.pagination = m.PageResponse.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        votes: Array.isArray(n == null ? void 0 : n.votes) ? n.votes.map((y) => r.Vote.fromJSON(y)) : [],
        pagination: (0, f.isSet)(n.pagination) ? m.PageResponse.fromJSON(n.pagination) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.votes ? y.votes = n.votes.map((w) => w ? r.Vote.toJSON(w) : void 0) : y.votes = [], n.pagination !== void 0 && (y.pagination = n.pagination ? m.PageResponse.toJSON(n.pagination) : void 0), y;
    },
    fromPartial(n) {
      var y;
      const w = l();
      return w.votes = ((y = n.votes) == null ? void 0 : y.map((M) => r.Vote.fromPartial(M))) || [], w.pagination = n.pagination !== void 0 && n.pagination !== null ? m.PageResponse.fromPartial(n.pagination) : void 0, w;
    }
  };
  function S() {
    return {
      paramsType: ""
    };
  }
  e.QueryParamsRequest = {
    encode(n, y = b.Writer.create()) {
      return n.paramsType !== "" && y.uint32(10).string(n.paramsType), y;
    },
    decode(n, y) {
      const w = n instanceof b.Reader ? n : new b.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = S();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.paramsType = w.string();
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        paramsType: (0, f.isSet)(n.paramsType) ? String(n.paramsType) : ""
      };
    },
    toJSON(n) {
      const y = {};
      return n.paramsType !== void 0 && (y.paramsType = n.paramsType), y;
    },
    fromPartial(n) {
      const y = S();
      return y.paramsType = n.paramsType ?? "", y;
    }
  };
  function A() {
    return {
      votingParams: void 0,
      depositParams: void 0,
      tallyParams: void 0
    };
  }
  e.QueryParamsResponse = {
    encode(n, y = b.Writer.create()) {
      return n.votingParams !== void 0 && r.VotingParams.encode(n.votingParams, y.uint32(10).fork()).ldelim(), n.depositParams !== void 0 && r.DepositParams.encode(n.depositParams, y.uint32(18).fork()).ldelim(), n.tallyParams !== void 0 && r.TallyParams.encode(n.tallyParams, y.uint32(26).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof b.Reader ? n : new b.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = A();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.votingParams = r.VotingParams.decode(w, w.uint32());
            break;
          case 2:
            s.depositParams = r.DepositParams.decode(w, w.uint32());
            break;
          case 3:
            s.tallyParams = r.TallyParams.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        votingParams: (0, f.isSet)(n.votingParams) ? r.VotingParams.fromJSON(n.votingParams) : void 0,
        depositParams: (0, f.isSet)(n.depositParams) ? r.DepositParams.fromJSON(n.depositParams) : void 0,
        tallyParams: (0, f.isSet)(n.tallyParams) ? r.TallyParams.fromJSON(n.tallyParams) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.votingParams !== void 0 && (y.votingParams = n.votingParams ? r.VotingParams.toJSON(n.votingParams) : void 0), n.depositParams !== void 0 && (y.depositParams = n.depositParams ? r.DepositParams.toJSON(n.depositParams) : void 0), n.tallyParams !== void 0 && (y.tallyParams = n.tallyParams ? r.TallyParams.toJSON(n.tallyParams) : void 0), y;
    },
    fromPartial(n) {
      const y = A();
      return y.votingParams = n.votingParams !== void 0 && n.votingParams !== null ? r.VotingParams.fromPartial(n.votingParams) : void 0, y.depositParams = n.depositParams !== void 0 && n.depositParams !== null ? r.DepositParams.fromPartial(n.depositParams) : void 0, y.tallyParams = n.tallyParams !== void 0 && n.tallyParams !== null ? r.TallyParams.fromPartial(n.tallyParams) : void 0, y;
    }
  };
  function d() {
    return {
      proposalId: f.Long.UZERO,
      depositor: ""
    };
  }
  e.QueryDepositRequest = {
    encode(n, y = b.Writer.create()) {
      return n.proposalId.isZero() || y.uint32(8).uint64(n.proposalId), n.depositor !== "" && y.uint32(18).string(n.depositor), y;
    },
    decode(n, y) {
      const w = n instanceof b.Reader ? n : new b.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = d();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.proposalId = w.uint64();
            break;
          case 2:
            s.depositor = w.string();
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        proposalId: (0, f.isSet)(n.proposalId) ? f.Long.fromValue(n.proposalId) : f.Long.UZERO,
        depositor: (0, f.isSet)(n.depositor) ? String(n.depositor) : ""
      };
    },
    toJSON(n) {
      const y = {};
      return n.proposalId !== void 0 && (y.proposalId = (n.proposalId || f.Long.UZERO).toString()), n.depositor !== void 0 && (y.depositor = n.depositor), y;
    },
    fromPartial(n) {
      const y = d();
      return y.proposalId = n.proposalId !== void 0 && n.proposalId !== null ? f.Long.fromValue(n.proposalId) : f.Long.UZERO, y.depositor = n.depositor ?? "", y;
    }
  };
  function p() {
    return {
      deposit: void 0
    };
  }
  e.QueryDepositResponse = {
    encode(n, y = b.Writer.create()) {
      return n.deposit !== void 0 && r.Deposit.encode(n.deposit, y.uint32(10).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof b.Reader ? n : new b.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = p();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.deposit = r.Deposit.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        deposit: (0, f.isSet)(n.deposit) ? r.Deposit.fromJSON(n.deposit) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.deposit !== void 0 && (y.deposit = n.deposit ? r.Deposit.toJSON(n.deposit) : void 0), y;
    },
    fromPartial(n) {
      const y = p();
      return y.deposit = n.deposit !== void 0 && n.deposit !== null ? r.Deposit.fromPartial(n.deposit) : void 0, y;
    }
  };
  function h() {
    return {
      proposalId: f.Long.UZERO,
      pagination: void 0
    };
  }
  e.QueryDepositsRequest = {
    encode(n, y = b.Writer.create()) {
      return n.proposalId.isZero() || y.uint32(8).uint64(n.proposalId), n.pagination !== void 0 && m.PageRequest.encode(n.pagination, y.uint32(18).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof b.Reader ? n : new b.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = h();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.proposalId = w.uint64();
            break;
          case 2:
            s.pagination = m.PageRequest.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        proposalId: (0, f.isSet)(n.proposalId) ? f.Long.fromValue(n.proposalId) : f.Long.UZERO,
        pagination: (0, f.isSet)(n.pagination) ? m.PageRequest.fromJSON(n.pagination) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.proposalId !== void 0 && (y.proposalId = (n.proposalId || f.Long.UZERO).toString()), n.pagination !== void 0 && (y.pagination = n.pagination ? m.PageRequest.toJSON(n.pagination) : void 0), y;
    },
    fromPartial(n) {
      const y = h();
      return y.proposalId = n.proposalId !== void 0 && n.proposalId !== null ? f.Long.fromValue(n.proposalId) : f.Long.UZERO, y.pagination = n.pagination !== void 0 && n.pagination !== null ? m.PageRequest.fromPartial(n.pagination) : void 0, y;
    }
  };
  function x() {
    return {
      deposits: [],
      pagination: void 0
    };
  }
  e.QueryDepositsResponse = {
    encode(n, y = b.Writer.create()) {
      for (const w of n.deposits)
        r.Deposit.encode(w, y.uint32(10).fork()).ldelim();
      return n.pagination !== void 0 && m.PageResponse.encode(n.pagination, y.uint32(18).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof b.Reader ? n : new b.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = x();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.deposits.push(r.Deposit.decode(w, w.uint32()));
            break;
          case 2:
            s.pagination = m.PageResponse.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        deposits: Array.isArray(n == null ? void 0 : n.deposits) ? n.deposits.map((y) => r.Deposit.fromJSON(y)) : [],
        pagination: (0, f.isSet)(n.pagination) ? m.PageResponse.fromJSON(n.pagination) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.deposits ? y.deposits = n.deposits.map((w) => w ? r.Deposit.toJSON(w) : void 0) : y.deposits = [], n.pagination !== void 0 && (y.pagination = n.pagination ? m.PageResponse.toJSON(n.pagination) : void 0), y;
    },
    fromPartial(n) {
      var y;
      const w = x();
      return w.deposits = ((y = n.deposits) == null ? void 0 : y.map((M) => r.Deposit.fromPartial(M))) || [], w.pagination = n.pagination !== void 0 && n.pagination !== null ? m.PageResponse.fromPartial(n.pagination) : void 0, w;
    }
  };
  function _() {
    return {
      proposalId: f.Long.UZERO
    };
  }
  e.QueryTallyResultRequest = {
    encode(n, y = b.Writer.create()) {
      return n.proposalId.isZero() || y.uint32(8).uint64(n.proposalId), y;
    },
    decode(n, y) {
      const w = n instanceof b.Reader ? n : new b.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = _();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.proposalId = w.uint64();
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        proposalId: (0, f.isSet)(n.proposalId) ? f.Long.fromValue(n.proposalId) : f.Long.UZERO
      };
    },
    toJSON(n) {
      const y = {};
      return n.proposalId !== void 0 && (y.proposalId = (n.proposalId || f.Long.UZERO).toString()), y;
    },
    fromPartial(n) {
      const y = _();
      return y.proposalId = n.proposalId !== void 0 && n.proposalId !== null ? f.Long.fromValue(n.proposalId) : f.Long.UZERO, y;
    }
  };
  function I() {
    return {
      tally: void 0
    };
  }
  e.QueryTallyResultResponse = {
    encode(n, y = b.Writer.create()) {
      return n.tally !== void 0 && r.TallyResult.encode(n.tally, y.uint32(10).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof b.Reader ? n : new b.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = I();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.tally = r.TallyResult.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        tally: (0, f.isSet)(n.tally) ? r.TallyResult.fromJSON(n.tally) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.tally !== void 0 && (y.tally = n.tally ? r.TallyResult.toJSON(n.tally) : void 0), y;
    },
    fromPartial(n) {
      const y = I();
      return y.tally = n.tally !== void 0 && n.tally !== null ? r.TallyResult.fromPartial(n.tally) : void 0, y;
    }
  };
  class W {
    constructor(y) {
      this.rpc = y, this.Proposal = this.Proposal.bind(this), this.Proposals = this.Proposals.bind(this), this.Vote = this.Vote.bind(this), this.Votes = this.Votes.bind(this), this.Params = this.Params.bind(this), this.Deposit = this.Deposit.bind(this), this.Deposits = this.Deposits.bind(this), this.TallyResult = this.TallyResult.bind(this);
    }
    Proposal(y) {
      const w = e.QueryProposalRequest.encode(y).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Proposal", w).then((M) => e.QueryProposalResponse.decode(new b.Reader(M)));
    }
    Proposals(y) {
      const w = e.QueryProposalsRequest.encode(y).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Proposals", w).then((M) => e.QueryProposalsResponse.decode(new b.Reader(M)));
    }
    Vote(y) {
      const w = e.QueryVoteRequest.encode(y).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Vote", w).then((M) => e.QueryVoteResponse.decode(new b.Reader(M)));
    }
    Votes(y) {
      const w = e.QueryVotesRequest.encode(y).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Votes", w).then((M) => e.QueryVotesResponse.decode(new b.Reader(M)));
    }
    Params(y) {
      const w = e.QueryParamsRequest.encode(y).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Params", w).then((M) => e.QueryParamsResponse.decode(new b.Reader(M)));
    }
    Deposit(y) {
      const w = e.QueryDepositRequest.encode(y).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Deposit", w).then((M) => e.QueryDepositResponse.decode(new b.Reader(M)));
    }
    Deposits(y) {
      const w = e.QueryDepositsRequest.encode(y).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Deposits", w).then((M) => e.QueryDepositsResponse.decode(new b.Reader(M)));
    }
    TallyResult(y) {
      const w = e.QueryTallyResultRequest.encode(y).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "TallyResult", w).then((M) => e.QueryTallyResultResponse.decode(new b.Reader(M)));
    }
  }
  e.QueryClientImpl = W;
})(Oc);
Object.defineProperty(ar, "__esModule", { value: !0 });
ar.setupGovExtension = void 0;
const Pm = Oc, vt = Ve;
function Rm(e) {
  const o = (0, vt.createProtobufRpcClient)(e), t = new Pm.QueryClientImpl(o);
  return {
    gov: {
      params: async (u) => await t.Params({ paramsType: u }),
      proposals: async (u, r, m, f) => await t.Proposals({
        proposalStatus: u,
        depositor: r,
        voter: m,
        pagination: (0, vt.createPagination)(f)
      }),
      proposal: async (u) => await t.Proposal({ proposalId: (0, vt.longify)(u) }),
      deposits: async (u, r) => await t.Deposits({
        proposalId: (0, vt.longify)(u),
        pagination: (0, vt.createPagination)(r)
      }),
      deposit: async (u, r) => await t.Deposit({
        proposalId: (0, vt.longify)(u),
        depositor: r
      }),
      tally: async (u) => await t.TallyResult({
        proposalId: (0, vt.longify)(u)
      }),
      votes: async (u, r) => await t.Votes({
        proposalId: (0, vt.longify)(u),
        pagination: (0, vt.createPagination)(r)
      }),
      vote: async (u, r) => await t.Vote({
        proposalId: (0, vt.longify)(u),
        voter: r
      })
    }
  };
}
ar.setupGovExtension = Rm;
var dr = {};
Object.defineProperty(dr, "__esModule", { value: !0 });
dr.createGroupAminoConverters = void 0;
function Am() {
  return {};
}
dr.createGroupAminoConverters = Am;
var cr = {}, kc = {}, Pc = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(s, c, E, k) {
    k === void 0 && (k = E);
    var O = Object.getOwnPropertyDescriptor(c, E);
    (!O || ("get" in O ? !c.__esModule : O.writable || O.configurable)) && (O = { enumerable: !0, get: function() {
      return c[E];
    } }), Object.defineProperty(s, k, O);
  } : function(s, c, E, k) {
    k === void 0 && (k = E), s[k] = c[E];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(s, c) {
    Object.defineProperty(s, "default", { enumerable: !0, value: c });
  } : function(s, c) {
    s.default = c;
  }), u = Q && Q.__importStar || function(s) {
    if (s && s.__esModule)
      return s;
    var c = {};
    if (s != null)
      for (var E in s)
        E !== "default" && Object.prototype.hasOwnProperty.call(s, E) && o(c, s, E);
    return t(c, s), c;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Vote = e.TallyResult = e.Proposal = e.GroupPolicyInfo = e.GroupMember = e.GroupInfo = e.DecisionPolicyWindows = e.PercentageDecisionPolicy = e.ThresholdDecisionPolicy = e.MemberRequest = e.Member = e.proposalExecutorResultToJSON = e.proposalExecutorResultFromJSON = e.ProposalExecutorResult = e.proposalStatusToJSON = e.proposalStatusFromJSON = e.ProposalStatus = e.voteOptionToJSON = e.voteOptionFromJSON = e.VoteOption = e.protobufPackage = void 0;
  const r = Ae, m = et, f = ye, b = ie, R = u(re);
  e.protobufPackage = "cosmos.group.v1";
  var T;
  (function(s) {
    s[s.VOTE_OPTION_UNSPECIFIED = 0] = "VOTE_OPTION_UNSPECIFIED", s[s.VOTE_OPTION_YES = 1] = "VOTE_OPTION_YES", s[s.VOTE_OPTION_ABSTAIN = 2] = "VOTE_OPTION_ABSTAIN", s[s.VOTE_OPTION_NO = 3] = "VOTE_OPTION_NO", s[s.VOTE_OPTION_NO_WITH_VETO = 4] = "VOTE_OPTION_NO_WITH_VETO", s[s.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(T = e.VoteOption || (e.VoteOption = {}));
  function V(s) {
    switch (s) {
      case 0:
      case "VOTE_OPTION_UNSPECIFIED":
        return T.VOTE_OPTION_UNSPECIFIED;
      case 1:
      case "VOTE_OPTION_YES":
        return T.VOTE_OPTION_YES;
      case 2:
      case "VOTE_OPTION_ABSTAIN":
        return T.VOTE_OPTION_ABSTAIN;
      case 3:
      case "VOTE_OPTION_NO":
        return T.VOTE_OPTION_NO;
      case 4:
      case "VOTE_OPTION_NO_WITH_VETO":
        return T.VOTE_OPTION_NO_WITH_VETO;
      case -1:
      case "UNRECOGNIZED":
      default:
        return T.UNRECOGNIZED;
    }
  }
  e.voteOptionFromJSON = V;
  function D(s) {
    switch (s) {
      case T.VOTE_OPTION_UNSPECIFIED:
        return "VOTE_OPTION_UNSPECIFIED";
      case T.VOTE_OPTION_YES:
        return "VOTE_OPTION_YES";
      case T.VOTE_OPTION_ABSTAIN:
        return "VOTE_OPTION_ABSTAIN";
      case T.VOTE_OPTION_NO:
        return "VOTE_OPTION_NO";
      case T.VOTE_OPTION_NO_WITH_VETO:
        return "VOTE_OPTION_NO_WITH_VETO";
      case T.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.voteOptionToJSON = D;
  var B;
  (function(s) {
    s[s.PROPOSAL_STATUS_UNSPECIFIED = 0] = "PROPOSAL_STATUS_UNSPECIFIED", s[s.PROPOSAL_STATUS_SUBMITTED = 1] = "PROPOSAL_STATUS_SUBMITTED", s[s.PROPOSAL_STATUS_ACCEPTED = 2] = "PROPOSAL_STATUS_ACCEPTED", s[s.PROPOSAL_STATUS_REJECTED = 3] = "PROPOSAL_STATUS_REJECTED", s[s.PROPOSAL_STATUS_ABORTED = 4] = "PROPOSAL_STATUS_ABORTED", s[s.PROPOSAL_STATUS_WITHDRAWN = 5] = "PROPOSAL_STATUS_WITHDRAWN", s[s.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(B = e.ProposalStatus || (e.ProposalStatus = {}));
  function U(s) {
    switch (s) {
      case 0:
      case "PROPOSAL_STATUS_UNSPECIFIED":
        return B.PROPOSAL_STATUS_UNSPECIFIED;
      case 1:
      case "PROPOSAL_STATUS_SUBMITTED":
        return B.PROPOSAL_STATUS_SUBMITTED;
      case 2:
      case "PROPOSAL_STATUS_ACCEPTED":
        return B.PROPOSAL_STATUS_ACCEPTED;
      case 3:
      case "PROPOSAL_STATUS_REJECTED":
        return B.PROPOSAL_STATUS_REJECTED;
      case 4:
      case "PROPOSAL_STATUS_ABORTED":
        return B.PROPOSAL_STATUS_ABORTED;
      case 5:
      case "PROPOSAL_STATUS_WITHDRAWN":
        return B.PROPOSAL_STATUS_WITHDRAWN;
      case -1:
      case "UNRECOGNIZED":
      default:
        return B.UNRECOGNIZED;
    }
  }
  e.proposalStatusFromJSON = U;
  function C(s) {
    switch (s) {
      case B.PROPOSAL_STATUS_UNSPECIFIED:
        return "PROPOSAL_STATUS_UNSPECIFIED";
      case B.PROPOSAL_STATUS_SUBMITTED:
        return "PROPOSAL_STATUS_SUBMITTED";
      case B.PROPOSAL_STATUS_ACCEPTED:
        return "PROPOSAL_STATUS_ACCEPTED";
      case B.PROPOSAL_STATUS_REJECTED:
        return "PROPOSAL_STATUS_REJECTED";
      case B.PROPOSAL_STATUS_ABORTED:
        return "PROPOSAL_STATUS_ABORTED";
      case B.PROPOSAL_STATUS_WITHDRAWN:
        return "PROPOSAL_STATUS_WITHDRAWN";
      case B.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.proposalStatusToJSON = C;
  var l;
  (function(s) {
    s[s.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED = 0] = "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED", s[s.PROPOSAL_EXECUTOR_RESULT_NOT_RUN = 1] = "PROPOSAL_EXECUTOR_RESULT_NOT_RUN", s[s.PROPOSAL_EXECUTOR_RESULT_SUCCESS = 2] = "PROPOSAL_EXECUTOR_RESULT_SUCCESS", s[s.PROPOSAL_EXECUTOR_RESULT_FAILURE = 3] = "PROPOSAL_EXECUTOR_RESULT_FAILURE", s[s.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(l = e.ProposalExecutorResult || (e.ProposalExecutorResult = {}));
  function S(s) {
    switch (s) {
      case 0:
      case "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED":
        return l.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED;
      case 1:
      case "PROPOSAL_EXECUTOR_RESULT_NOT_RUN":
        return l.PROPOSAL_EXECUTOR_RESULT_NOT_RUN;
      case 2:
      case "PROPOSAL_EXECUTOR_RESULT_SUCCESS":
        return l.PROPOSAL_EXECUTOR_RESULT_SUCCESS;
      case 3:
      case "PROPOSAL_EXECUTOR_RESULT_FAILURE":
        return l.PROPOSAL_EXECUTOR_RESULT_FAILURE;
      case -1:
      case "UNRECOGNIZED":
      default:
        return l.UNRECOGNIZED;
    }
  }
  e.proposalExecutorResultFromJSON = S;
  function A(s) {
    switch (s) {
      case l.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED:
        return "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED";
      case l.PROPOSAL_EXECUTOR_RESULT_NOT_RUN:
        return "PROPOSAL_EXECUTOR_RESULT_NOT_RUN";
      case l.PROPOSAL_EXECUTOR_RESULT_SUCCESS:
        return "PROPOSAL_EXECUTOR_RESULT_SUCCESS";
      case l.PROPOSAL_EXECUTOR_RESULT_FAILURE:
        return "PROPOSAL_EXECUTOR_RESULT_FAILURE";
      case l.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.proposalExecutorResultToJSON = A;
  function d() {
    return {
      address: "",
      weight: "",
      metadata: "",
      addedAt: void 0
    };
  }
  e.Member = {
    encode(s, c = R.Writer.create()) {
      return s.address !== "" && c.uint32(10).string(s.address), s.weight !== "" && c.uint32(18).string(s.weight), s.metadata !== "" && c.uint32(26).string(s.metadata), s.addedAt !== void 0 && r.Timestamp.encode(s.addedAt, c.uint32(34).fork()).ldelim(), c;
    },
    decode(s, c) {
      const E = s instanceof R.Reader ? s : new R.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = d();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.address = E.string();
            break;
          case 2:
            O.weight = E.string();
            break;
          case 3:
            O.metadata = E.string();
            break;
          case 4:
            O.addedAt = r.Timestamp.decode(E, E.uint32());
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        address: (0, b.isSet)(s.address) ? String(s.address) : "",
        weight: (0, b.isSet)(s.weight) ? String(s.weight) : "",
        metadata: (0, b.isSet)(s.metadata) ? String(s.metadata) : "",
        addedAt: (0, b.isSet)(s.addedAt) ? (0, b.fromJsonTimestamp)(s.addedAt) : void 0
      };
    },
    toJSON(s) {
      const c = {};
      return s.address !== void 0 && (c.address = s.address), s.weight !== void 0 && (c.weight = s.weight), s.metadata !== void 0 && (c.metadata = s.metadata), s.addedAt !== void 0 && (c.addedAt = (0, b.fromTimestamp)(s.addedAt).toISOString()), c;
    },
    fromPartial(s) {
      const c = d();
      return c.address = s.address ?? "", c.weight = s.weight ?? "", c.metadata = s.metadata ?? "", c.addedAt = s.addedAt !== void 0 && s.addedAt !== null ? r.Timestamp.fromPartial(s.addedAt) : void 0, c;
    }
  };
  function p() {
    return {
      address: "",
      weight: "",
      metadata: ""
    };
  }
  e.MemberRequest = {
    encode(s, c = R.Writer.create()) {
      return s.address !== "" && c.uint32(10).string(s.address), s.weight !== "" && c.uint32(18).string(s.weight), s.metadata !== "" && c.uint32(26).string(s.metadata), c;
    },
    decode(s, c) {
      const E = s instanceof R.Reader ? s : new R.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = p();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.address = E.string();
            break;
          case 2:
            O.weight = E.string();
            break;
          case 3:
            O.metadata = E.string();
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        address: (0, b.isSet)(s.address) ? String(s.address) : "",
        weight: (0, b.isSet)(s.weight) ? String(s.weight) : "",
        metadata: (0, b.isSet)(s.metadata) ? String(s.metadata) : ""
      };
    },
    toJSON(s) {
      const c = {};
      return s.address !== void 0 && (c.address = s.address), s.weight !== void 0 && (c.weight = s.weight), s.metadata !== void 0 && (c.metadata = s.metadata), c;
    },
    fromPartial(s) {
      const c = p();
      return c.address = s.address ?? "", c.weight = s.weight ?? "", c.metadata = s.metadata ?? "", c;
    }
  };
  function h() {
    return {
      threshold: "",
      windows: void 0
    };
  }
  e.ThresholdDecisionPolicy = {
    encode(s, c = R.Writer.create()) {
      return s.threshold !== "" && c.uint32(10).string(s.threshold), s.windows !== void 0 && e.DecisionPolicyWindows.encode(s.windows, c.uint32(18).fork()).ldelim(), c;
    },
    decode(s, c) {
      const E = s instanceof R.Reader ? s : new R.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = h();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.threshold = E.string();
            break;
          case 2:
            O.windows = e.DecisionPolicyWindows.decode(E, E.uint32());
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        threshold: (0, b.isSet)(s.threshold) ? String(s.threshold) : "",
        windows: (0, b.isSet)(s.windows) ? e.DecisionPolicyWindows.fromJSON(s.windows) : void 0
      };
    },
    toJSON(s) {
      const c = {};
      return s.threshold !== void 0 && (c.threshold = s.threshold), s.windows !== void 0 && (c.windows = s.windows ? e.DecisionPolicyWindows.toJSON(s.windows) : void 0), c;
    },
    fromPartial(s) {
      const c = h();
      return c.threshold = s.threshold ?? "", c.windows = s.windows !== void 0 && s.windows !== null ? e.DecisionPolicyWindows.fromPartial(s.windows) : void 0, c;
    }
  };
  function x() {
    return {
      percentage: "",
      windows: void 0
    };
  }
  e.PercentageDecisionPolicy = {
    encode(s, c = R.Writer.create()) {
      return s.percentage !== "" && c.uint32(10).string(s.percentage), s.windows !== void 0 && e.DecisionPolicyWindows.encode(s.windows, c.uint32(18).fork()).ldelim(), c;
    },
    decode(s, c) {
      const E = s instanceof R.Reader ? s : new R.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = x();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.percentage = E.string();
            break;
          case 2:
            O.windows = e.DecisionPolicyWindows.decode(E, E.uint32());
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        percentage: (0, b.isSet)(s.percentage) ? String(s.percentage) : "",
        windows: (0, b.isSet)(s.windows) ? e.DecisionPolicyWindows.fromJSON(s.windows) : void 0
      };
    },
    toJSON(s) {
      const c = {};
      return s.percentage !== void 0 && (c.percentage = s.percentage), s.windows !== void 0 && (c.windows = s.windows ? e.DecisionPolicyWindows.toJSON(s.windows) : void 0), c;
    },
    fromPartial(s) {
      const c = x();
      return c.percentage = s.percentage ?? "", c.windows = s.windows !== void 0 && s.windows !== null ? e.DecisionPolicyWindows.fromPartial(s.windows) : void 0, c;
    }
  };
  function _() {
    return {
      votingPeriod: void 0,
      minExecutionPeriod: void 0
    };
  }
  e.DecisionPolicyWindows = {
    encode(s, c = R.Writer.create()) {
      return s.votingPeriod !== void 0 && m.Duration.encode(s.votingPeriod, c.uint32(10).fork()).ldelim(), s.minExecutionPeriod !== void 0 && m.Duration.encode(s.minExecutionPeriod, c.uint32(18).fork()).ldelim(), c;
    },
    decode(s, c) {
      const E = s instanceof R.Reader ? s : new R.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = _();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.votingPeriod = m.Duration.decode(E, E.uint32());
            break;
          case 2:
            O.minExecutionPeriod = m.Duration.decode(E, E.uint32());
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        votingPeriod: (0, b.isSet)(s.votingPeriod) ? m.Duration.fromJSON(s.votingPeriod) : void 0,
        minExecutionPeriod: (0, b.isSet)(s.minExecutionPeriod) ? m.Duration.fromJSON(s.minExecutionPeriod) : void 0
      };
    },
    toJSON(s) {
      const c = {};
      return s.votingPeriod !== void 0 && (c.votingPeriod = s.votingPeriod ? m.Duration.toJSON(s.votingPeriod) : void 0), s.minExecutionPeriod !== void 0 && (c.minExecutionPeriod = s.minExecutionPeriod ? m.Duration.toJSON(s.minExecutionPeriod) : void 0), c;
    },
    fromPartial(s) {
      const c = _();
      return c.votingPeriod = s.votingPeriod !== void 0 && s.votingPeriod !== null ? m.Duration.fromPartial(s.votingPeriod) : void 0, c.minExecutionPeriod = s.minExecutionPeriod !== void 0 && s.minExecutionPeriod !== null ? m.Duration.fromPartial(s.minExecutionPeriod) : void 0, c;
    }
  };
  function I() {
    return {
      id: b.Long.UZERO,
      admin: "",
      metadata: "",
      version: b.Long.UZERO,
      totalWeight: "",
      createdAt: void 0
    };
  }
  e.GroupInfo = {
    encode(s, c = R.Writer.create()) {
      return s.id.isZero() || c.uint32(8).uint64(s.id), s.admin !== "" && c.uint32(18).string(s.admin), s.metadata !== "" && c.uint32(26).string(s.metadata), s.version.isZero() || c.uint32(32).uint64(s.version), s.totalWeight !== "" && c.uint32(42).string(s.totalWeight), s.createdAt !== void 0 && r.Timestamp.encode(s.createdAt, c.uint32(50).fork()).ldelim(), c;
    },
    decode(s, c) {
      const E = s instanceof R.Reader ? s : new R.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = I();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.id = E.uint64();
            break;
          case 2:
            O.admin = E.string();
            break;
          case 3:
            O.metadata = E.string();
            break;
          case 4:
            O.version = E.uint64();
            break;
          case 5:
            O.totalWeight = E.string();
            break;
          case 6:
            O.createdAt = r.Timestamp.decode(E, E.uint32());
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        id: (0, b.isSet)(s.id) ? b.Long.fromValue(s.id) : b.Long.UZERO,
        admin: (0, b.isSet)(s.admin) ? String(s.admin) : "",
        metadata: (0, b.isSet)(s.metadata) ? String(s.metadata) : "",
        version: (0, b.isSet)(s.version) ? b.Long.fromValue(s.version) : b.Long.UZERO,
        totalWeight: (0, b.isSet)(s.totalWeight) ? String(s.totalWeight) : "",
        createdAt: (0, b.isSet)(s.createdAt) ? (0, b.fromJsonTimestamp)(s.createdAt) : void 0
      };
    },
    toJSON(s) {
      const c = {};
      return s.id !== void 0 && (c.id = (s.id || b.Long.UZERO).toString()), s.admin !== void 0 && (c.admin = s.admin), s.metadata !== void 0 && (c.metadata = s.metadata), s.version !== void 0 && (c.version = (s.version || b.Long.UZERO).toString()), s.totalWeight !== void 0 && (c.totalWeight = s.totalWeight), s.createdAt !== void 0 && (c.createdAt = (0, b.fromTimestamp)(s.createdAt).toISOString()), c;
    },
    fromPartial(s) {
      const c = I();
      return c.id = s.id !== void 0 && s.id !== null ? b.Long.fromValue(s.id) : b.Long.UZERO, c.admin = s.admin ?? "", c.metadata = s.metadata ?? "", c.version = s.version !== void 0 && s.version !== null ? b.Long.fromValue(s.version) : b.Long.UZERO, c.totalWeight = s.totalWeight ?? "", c.createdAt = s.createdAt !== void 0 && s.createdAt !== null ? r.Timestamp.fromPartial(s.createdAt) : void 0, c;
    }
  };
  function W() {
    return {
      groupId: b.Long.UZERO,
      member: void 0
    };
  }
  e.GroupMember = {
    encode(s, c = R.Writer.create()) {
      return s.groupId.isZero() || c.uint32(8).uint64(s.groupId), s.member !== void 0 && e.Member.encode(s.member, c.uint32(18).fork()).ldelim(), c;
    },
    decode(s, c) {
      const E = s instanceof R.Reader ? s : new R.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = W();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.groupId = E.uint64();
            break;
          case 2:
            O.member = e.Member.decode(E, E.uint32());
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        groupId: (0, b.isSet)(s.groupId) ? b.Long.fromValue(s.groupId) : b.Long.UZERO,
        member: (0, b.isSet)(s.member) ? e.Member.fromJSON(s.member) : void 0
      };
    },
    toJSON(s) {
      const c = {};
      return s.groupId !== void 0 && (c.groupId = (s.groupId || b.Long.UZERO).toString()), s.member !== void 0 && (c.member = s.member ? e.Member.toJSON(s.member) : void 0), c;
    },
    fromPartial(s) {
      const c = W();
      return c.groupId = s.groupId !== void 0 && s.groupId !== null ? b.Long.fromValue(s.groupId) : b.Long.UZERO, c.member = s.member !== void 0 && s.member !== null ? e.Member.fromPartial(s.member) : void 0, c;
    }
  };
  function n() {
    return {
      address: "",
      groupId: b.Long.UZERO,
      admin: "",
      metadata: "",
      version: b.Long.UZERO,
      decisionPolicy: void 0,
      createdAt: void 0
    };
  }
  e.GroupPolicyInfo = {
    encode(s, c = R.Writer.create()) {
      return s.address !== "" && c.uint32(10).string(s.address), s.groupId.isZero() || c.uint32(16).uint64(s.groupId), s.admin !== "" && c.uint32(26).string(s.admin), s.metadata !== "" && c.uint32(34).string(s.metadata), s.version.isZero() || c.uint32(40).uint64(s.version), s.decisionPolicy !== void 0 && f.Any.encode(s.decisionPolicy, c.uint32(50).fork()).ldelim(), s.createdAt !== void 0 && r.Timestamp.encode(s.createdAt, c.uint32(58).fork()).ldelim(), c;
    },
    decode(s, c) {
      const E = s instanceof R.Reader ? s : new R.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = n();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.address = E.string();
            break;
          case 2:
            O.groupId = E.uint64();
            break;
          case 3:
            O.admin = E.string();
            break;
          case 4:
            O.metadata = E.string();
            break;
          case 5:
            O.version = E.uint64();
            break;
          case 6:
            O.decisionPolicy = f.Any.decode(E, E.uint32());
            break;
          case 7:
            O.createdAt = r.Timestamp.decode(E, E.uint32());
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        address: (0, b.isSet)(s.address) ? String(s.address) : "",
        groupId: (0, b.isSet)(s.groupId) ? b.Long.fromValue(s.groupId) : b.Long.UZERO,
        admin: (0, b.isSet)(s.admin) ? String(s.admin) : "",
        metadata: (0, b.isSet)(s.metadata) ? String(s.metadata) : "",
        version: (0, b.isSet)(s.version) ? b.Long.fromValue(s.version) : b.Long.UZERO,
        decisionPolicy: (0, b.isSet)(s.decisionPolicy) ? f.Any.fromJSON(s.decisionPolicy) : void 0,
        createdAt: (0, b.isSet)(s.createdAt) ? (0, b.fromJsonTimestamp)(s.createdAt) : void 0
      };
    },
    toJSON(s) {
      const c = {};
      return s.address !== void 0 && (c.address = s.address), s.groupId !== void 0 && (c.groupId = (s.groupId || b.Long.UZERO).toString()), s.admin !== void 0 && (c.admin = s.admin), s.metadata !== void 0 && (c.metadata = s.metadata), s.version !== void 0 && (c.version = (s.version || b.Long.UZERO).toString()), s.decisionPolicy !== void 0 && (c.decisionPolicy = s.decisionPolicy ? f.Any.toJSON(s.decisionPolicy) : void 0), s.createdAt !== void 0 && (c.createdAt = (0, b.fromTimestamp)(s.createdAt).toISOString()), c;
    },
    fromPartial(s) {
      const c = n();
      return c.address = s.address ?? "", c.groupId = s.groupId !== void 0 && s.groupId !== null ? b.Long.fromValue(s.groupId) : b.Long.UZERO, c.admin = s.admin ?? "", c.metadata = s.metadata ?? "", c.version = s.version !== void 0 && s.version !== null ? b.Long.fromValue(s.version) : b.Long.UZERO, c.decisionPolicy = s.decisionPolicy !== void 0 && s.decisionPolicy !== null ? f.Any.fromPartial(s.decisionPolicy) : void 0, c.createdAt = s.createdAt !== void 0 && s.createdAt !== null ? r.Timestamp.fromPartial(s.createdAt) : void 0, c;
    }
  };
  function y() {
    return {
      id: b.Long.UZERO,
      groupPolicyAddress: "",
      metadata: "",
      proposers: [],
      submitTime: void 0,
      groupVersion: b.Long.UZERO,
      groupPolicyVersion: b.Long.UZERO,
      status: 0,
      finalTallyResult: void 0,
      votingPeriodEnd: void 0,
      executorResult: 0,
      messages: [],
      title: "",
      summary: ""
    };
  }
  e.Proposal = {
    encode(s, c = R.Writer.create()) {
      s.id.isZero() || c.uint32(8).uint64(s.id), s.groupPolicyAddress !== "" && c.uint32(18).string(s.groupPolicyAddress), s.metadata !== "" && c.uint32(26).string(s.metadata);
      for (const E of s.proposers)
        c.uint32(34).string(E);
      s.submitTime !== void 0 && r.Timestamp.encode(s.submitTime, c.uint32(42).fork()).ldelim(), s.groupVersion.isZero() || c.uint32(48).uint64(s.groupVersion), s.groupPolicyVersion.isZero() || c.uint32(56).uint64(s.groupPolicyVersion), s.status !== 0 && c.uint32(64).int32(s.status), s.finalTallyResult !== void 0 && e.TallyResult.encode(s.finalTallyResult, c.uint32(74).fork()).ldelim(), s.votingPeriodEnd !== void 0 && r.Timestamp.encode(s.votingPeriodEnd, c.uint32(82).fork()).ldelim(), s.executorResult !== 0 && c.uint32(88).int32(s.executorResult);
      for (const E of s.messages)
        f.Any.encode(E, c.uint32(98).fork()).ldelim();
      return s.title !== "" && c.uint32(106).string(s.title), s.summary !== "" && c.uint32(114).string(s.summary), c;
    },
    decode(s, c) {
      const E = s instanceof R.Reader ? s : new R.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = y();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.id = E.uint64();
            break;
          case 2:
            O.groupPolicyAddress = E.string();
            break;
          case 3:
            O.metadata = E.string();
            break;
          case 4:
            O.proposers.push(E.string());
            break;
          case 5:
            O.submitTime = r.Timestamp.decode(E, E.uint32());
            break;
          case 6:
            O.groupVersion = E.uint64();
            break;
          case 7:
            O.groupPolicyVersion = E.uint64();
            break;
          case 8:
            O.status = E.int32();
            break;
          case 9:
            O.finalTallyResult = e.TallyResult.decode(E, E.uint32());
            break;
          case 10:
            O.votingPeriodEnd = r.Timestamp.decode(E, E.uint32());
            break;
          case 11:
            O.executorResult = E.int32();
            break;
          case 12:
            O.messages.push(f.Any.decode(E, E.uint32()));
            break;
          case 13:
            O.title = E.string();
            break;
          case 14:
            O.summary = E.string();
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        id: (0, b.isSet)(s.id) ? b.Long.fromValue(s.id) : b.Long.UZERO,
        groupPolicyAddress: (0, b.isSet)(s.groupPolicyAddress) ? String(s.groupPolicyAddress) : "",
        metadata: (0, b.isSet)(s.metadata) ? String(s.metadata) : "",
        proposers: Array.isArray(s == null ? void 0 : s.proposers) ? s.proposers.map((c) => String(c)) : [],
        submitTime: (0, b.isSet)(s.submitTime) ? (0, b.fromJsonTimestamp)(s.submitTime) : void 0,
        groupVersion: (0, b.isSet)(s.groupVersion) ? b.Long.fromValue(s.groupVersion) : b.Long.UZERO,
        groupPolicyVersion: (0, b.isSet)(s.groupPolicyVersion) ? b.Long.fromValue(s.groupPolicyVersion) : b.Long.UZERO,
        status: (0, b.isSet)(s.status) ? U(s.status) : 0,
        finalTallyResult: (0, b.isSet)(s.finalTallyResult) ? e.TallyResult.fromJSON(s.finalTallyResult) : void 0,
        votingPeriodEnd: (0, b.isSet)(s.votingPeriodEnd) ? (0, b.fromJsonTimestamp)(s.votingPeriodEnd) : void 0,
        executorResult: (0, b.isSet)(s.executorResult) ? S(s.executorResult) : 0,
        messages: Array.isArray(s == null ? void 0 : s.messages) ? s.messages.map((c) => f.Any.fromJSON(c)) : [],
        title: (0, b.isSet)(s.title) ? String(s.title) : "",
        summary: (0, b.isSet)(s.summary) ? String(s.summary) : ""
      };
    },
    toJSON(s) {
      const c = {};
      return s.id !== void 0 && (c.id = (s.id || b.Long.UZERO).toString()), s.groupPolicyAddress !== void 0 && (c.groupPolicyAddress = s.groupPolicyAddress), s.metadata !== void 0 && (c.metadata = s.metadata), s.proposers ? c.proposers = s.proposers.map((E) => E) : c.proposers = [], s.submitTime !== void 0 && (c.submitTime = (0, b.fromTimestamp)(s.submitTime).toISOString()), s.groupVersion !== void 0 && (c.groupVersion = (s.groupVersion || b.Long.UZERO).toString()), s.groupPolicyVersion !== void 0 && (c.groupPolicyVersion = (s.groupPolicyVersion || b.Long.UZERO).toString()), s.status !== void 0 && (c.status = C(s.status)), s.finalTallyResult !== void 0 && (c.finalTallyResult = s.finalTallyResult ? e.TallyResult.toJSON(s.finalTallyResult) : void 0), s.votingPeriodEnd !== void 0 && (c.votingPeriodEnd = (0, b.fromTimestamp)(s.votingPeriodEnd).toISOString()), s.executorResult !== void 0 && (c.executorResult = A(s.executorResult)), s.messages ? c.messages = s.messages.map((E) => E ? f.Any.toJSON(E) : void 0) : c.messages = [], s.title !== void 0 && (c.title = s.title), s.summary !== void 0 && (c.summary = s.summary), c;
    },
    fromPartial(s) {
      var c, E;
      const k = y();
      return k.id = s.id !== void 0 && s.id !== null ? b.Long.fromValue(s.id) : b.Long.UZERO, k.groupPolicyAddress = s.groupPolicyAddress ?? "", k.metadata = s.metadata ?? "", k.proposers = ((c = s.proposers) == null ? void 0 : c.map((O) => O)) || [], k.submitTime = s.submitTime !== void 0 && s.submitTime !== null ? r.Timestamp.fromPartial(s.submitTime) : void 0, k.groupVersion = s.groupVersion !== void 0 && s.groupVersion !== null ? b.Long.fromValue(s.groupVersion) : b.Long.UZERO, k.groupPolicyVersion = s.groupPolicyVersion !== void 0 && s.groupPolicyVersion !== null ? b.Long.fromValue(s.groupPolicyVersion) : b.Long.UZERO, k.status = s.status ?? 0, k.finalTallyResult = s.finalTallyResult !== void 0 && s.finalTallyResult !== null ? e.TallyResult.fromPartial(s.finalTallyResult) : void 0, k.votingPeriodEnd = s.votingPeriodEnd !== void 0 && s.votingPeriodEnd !== null ? r.Timestamp.fromPartial(s.votingPeriodEnd) : void 0, k.executorResult = s.executorResult ?? 0, k.messages = ((E = s.messages) == null ? void 0 : E.map((O) => f.Any.fromPartial(O))) || [], k.title = s.title ?? "", k.summary = s.summary ?? "", k;
    }
  };
  function w() {
    return {
      yesCount: "",
      abstainCount: "",
      noCount: "",
      noWithVetoCount: ""
    };
  }
  e.TallyResult = {
    encode(s, c = R.Writer.create()) {
      return s.yesCount !== "" && c.uint32(10).string(s.yesCount), s.abstainCount !== "" && c.uint32(18).string(s.abstainCount), s.noCount !== "" && c.uint32(26).string(s.noCount), s.noWithVetoCount !== "" && c.uint32(34).string(s.noWithVetoCount), c;
    },
    decode(s, c) {
      const E = s instanceof R.Reader ? s : new R.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = w();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.yesCount = E.string();
            break;
          case 2:
            O.abstainCount = E.string();
            break;
          case 3:
            O.noCount = E.string();
            break;
          case 4:
            O.noWithVetoCount = E.string();
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        yesCount: (0, b.isSet)(s.yesCount) ? String(s.yesCount) : "",
        abstainCount: (0, b.isSet)(s.abstainCount) ? String(s.abstainCount) : "",
        noCount: (0, b.isSet)(s.noCount) ? String(s.noCount) : "",
        noWithVetoCount: (0, b.isSet)(s.noWithVetoCount) ? String(s.noWithVetoCount) : ""
      };
    },
    toJSON(s) {
      const c = {};
      return s.yesCount !== void 0 && (c.yesCount = s.yesCount), s.abstainCount !== void 0 && (c.abstainCount = s.abstainCount), s.noCount !== void 0 && (c.noCount = s.noCount), s.noWithVetoCount !== void 0 && (c.noWithVetoCount = s.noWithVetoCount), c;
    },
    fromPartial(s) {
      const c = w();
      return c.yesCount = s.yesCount ?? "", c.abstainCount = s.abstainCount ?? "", c.noCount = s.noCount ?? "", c.noWithVetoCount = s.noWithVetoCount ?? "", c;
    }
  };
  function M() {
    return {
      proposalId: b.Long.UZERO,
      voter: "",
      option: 0,
      metadata: "",
      submitTime: void 0
    };
  }
  e.Vote = {
    encode(s, c = R.Writer.create()) {
      return s.proposalId.isZero() || c.uint32(8).uint64(s.proposalId), s.voter !== "" && c.uint32(18).string(s.voter), s.option !== 0 && c.uint32(24).int32(s.option), s.metadata !== "" && c.uint32(34).string(s.metadata), s.submitTime !== void 0 && r.Timestamp.encode(s.submitTime, c.uint32(42).fork()).ldelim(), c;
    },
    decode(s, c) {
      const E = s instanceof R.Reader ? s : new R.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = M();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.proposalId = E.uint64();
            break;
          case 2:
            O.voter = E.string();
            break;
          case 3:
            O.option = E.int32();
            break;
          case 4:
            O.metadata = E.string();
            break;
          case 5:
            O.submitTime = r.Timestamp.decode(E, E.uint32());
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        proposalId: (0, b.isSet)(s.proposalId) ? b.Long.fromValue(s.proposalId) : b.Long.UZERO,
        voter: (0, b.isSet)(s.voter) ? String(s.voter) : "",
        option: (0, b.isSet)(s.option) ? V(s.option) : 0,
        metadata: (0, b.isSet)(s.metadata) ? String(s.metadata) : "",
        submitTime: (0, b.isSet)(s.submitTime) ? (0, b.fromJsonTimestamp)(s.submitTime) : void 0
      };
    },
    toJSON(s) {
      const c = {};
      return s.proposalId !== void 0 && (c.proposalId = (s.proposalId || b.Long.UZERO).toString()), s.voter !== void 0 && (c.voter = s.voter), s.option !== void 0 && (c.option = D(s.option)), s.metadata !== void 0 && (c.metadata = s.metadata), s.submitTime !== void 0 && (c.submitTime = (0, b.fromTimestamp)(s.submitTime).toISOString()), c;
    },
    fromPartial(s) {
      const c = M();
      return c.proposalId = s.proposalId !== void 0 && s.proposalId !== null ? b.Long.fromValue(s.proposalId) : b.Long.UZERO, c.voter = s.voter ?? "", c.option = s.option ?? 0, c.metadata = s.metadata ?? "", c.submitTime = s.submitTime !== void 0 && s.submitTime !== null ? r.Timestamp.fromPartial(s.submitTime) : void 0, c;
    }
  };
})(Pc);
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(v, N, q, G) {
    G === void 0 && (G = q);
    var K = Object.getOwnPropertyDescriptor(N, q);
    (!K || ("get" in K ? !N.__esModule : K.writable || K.configurable)) && (K = { enumerable: !0, get: function() {
      return N[q];
    } }), Object.defineProperty(v, G, K);
  } : function(v, N, q, G) {
    G === void 0 && (G = q), v[G] = N[q];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(v, N) {
    Object.defineProperty(v, "default", { enumerable: !0, value: N });
  } : function(v, N) {
    v.default = N;
  }), u = Q && Q.__importStar || function(v) {
    if (v && v.__esModule)
      return v;
    var N = {};
    if (v != null)
      for (var q in v)
        q !== "default" && Object.prototype.hasOwnProperty.call(v, q) && o(N, v, q);
    return t(N, v), N;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgLeaveGroupResponse = e.MsgLeaveGroup = e.MsgExecResponse = e.MsgExec = e.MsgVoteResponse = e.MsgVote = e.MsgWithdrawProposalResponse = e.MsgWithdrawProposal = e.MsgSubmitProposalResponse = e.MsgSubmitProposal = e.MsgUpdateGroupPolicyMetadataResponse = e.MsgUpdateGroupPolicyMetadata = e.MsgUpdateGroupPolicyDecisionPolicyResponse = e.MsgUpdateGroupPolicyDecisionPolicy = e.MsgCreateGroupWithPolicyResponse = e.MsgCreateGroupWithPolicy = e.MsgUpdateGroupPolicyAdminResponse = e.MsgUpdateGroupPolicyAdmin = e.MsgCreateGroupPolicyResponse = e.MsgCreateGroupPolicy = e.MsgUpdateGroupMetadataResponse = e.MsgUpdateGroupMetadata = e.MsgUpdateGroupAdminResponse = e.MsgUpdateGroupAdmin = e.MsgUpdateGroupMembersResponse = e.MsgUpdateGroupMembers = e.MsgCreateGroupResponse = e.MsgCreateGroup = e.execToJSON = e.execFromJSON = e.Exec = e.protobufPackage = void 0;
  const r = Pc, m = ye, f = ie, b = u(re);
  e.protobufPackage = "cosmos.group.v1";
  var R;
  (function(v) {
    v[v.EXEC_UNSPECIFIED = 0] = "EXEC_UNSPECIFIED", v[v.EXEC_TRY = 1] = "EXEC_TRY", v[v.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(R = e.Exec || (e.Exec = {}));
  function T(v) {
    switch (v) {
      case 0:
      case "EXEC_UNSPECIFIED":
        return R.EXEC_UNSPECIFIED;
      case 1:
      case "EXEC_TRY":
        return R.EXEC_TRY;
      case -1:
      case "UNRECOGNIZED":
      default:
        return R.UNRECOGNIZED;
    }
  }
  e.execFromJSON = T;
  function V(v) {
    switch (v) {
      case R.EXEC_UNSPECIFIED:
        return "EXEC_UNSPECIFIED";
      case R.EXEC_TRY:
        return "EXEC_TRY";
      case R.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.execToJSON = V;
  function D() {
    return {
      admin: "",
      members: [],
      metadata: ""
    };
  }
  e.MsgCreateGroup = {
    encode(v, N = b.Writer.create()) {
      v.admin !== "" && N.uint32(10).string(v.admin);
      for (const q of v.members)
        r.MemberRequest.encode(q, N.uint32(18).fork()).ldelim();
      return v.metadata !== "" && N.uint32(26).string(v.metadata), N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = D();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          case 1:
            K.admin = q.string();
            break;
          case 2:
            K.members.push(r.MemberRequest.decode(q, q.uint32()));
            break;
          case 3:
            K.metadata = q.string();
            break;
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {
        admin: (0, f.isSet)(v.admin) ? String(v.admin) : "",
        members: Array.isArray(v == null ? void 0 : v.members) ? v.members.map((N) => r.MemberRequest.fromJSON(N)) : [],
        metadata: (0, f.isSet)(v.metadata) ? String(v.metadata) : ""
      };
    },
    toJSON(v) {
      const N = {};
      return v.admin !== void 0 && (N.admin = v.admin), v.members ? N.members = v.members.map((q) => q ? r.MemberRequest.toJSON(q) : void 0) : N.members = [], v.metadata !== void 0 && (N.metadata = v.metadata), N;
    },
    fromPartial(v) {
      var N;
      const q = D();
      return q.admin = v.admin ?? "", q.members = ((N = v.members) == null ? void 0 : N.map((G) => r.MemberRequest.fromPartial(G))) || [], q.metadata = v.metadata ?? "", q;
    }
  };
  function B() {
    return {
      groupId: f.Long.UZERO
    };
  }
  e.MsgCreateGroupResponse = {
    encode(v, N = b.Writer.create()) {
      return v.groupId.isZero() || N.uint32(8).uint64(v.groupId), N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = B();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          case 1:
            K.groupId = q.uint64();
            break;
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {
        groupId: (0, f.isSet)(v.groupId) ? f.Long.fromValue(v.groupId) : f.Long.UZERO
      };
    },
    toJSON(v) {
      const N = {};
      return v.groupId !== void 0 && (N.groupId = (v.groupId || f.Long.UZERO).toString()), N;
    },
    fromPartial(v) {
      const N = B();
      return N.groupId = v.groupId !== void 0 && v.groupId !== null ? f.Long.fromValue(v.groupId) : f.Long.UZERO, N;
    }
  };
  function U() {
    return {
      admin: "",
      groupId: f.Long.UZERO,
      memberUpdates: []
    };
  }
  e.MsgUpdateGroupMembers = {
    encode(v, N = b.Writer.create()) {
      v.admin !== "" && N.uint32(10).string(v.admin), v.groupId.isZero() || N.uint32(16).uint64(v.groupId);
      for (const q of v.memberUpdates)
        r.MemberRequest.encode(q, N.uint32(26).fork()).ldelim();
      return N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = U();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          case 1:
            K.admin = q.string();
            break;
          case 2:
            K.groupId = q.uint64();
            break;
          case 3:
            K.memberUpdates.push(r.MemberRequest.decode(q, q.uint32()));
            break;
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {
        admin: (0, f.isSet)(v.admin) ? String(v.admin) : "",
        groupId: (0, f.isSet)(v.groupId) ? f.Long.fromValue(v.groupId) : f.Long.UZERO,
        memberUpdates: Array.isArray(v == null ? void 0 : v.memberUpdates) ? v.memberUpdates.map((N) => r.MemberRequest.fromJSON(N)) : []
      };
    },
    toJSON(v) {
      const N = {};
      return v.admin !== void 0 && (N.admin = v.admin), v.groupId !== void 0 && (N.groupId = (v.groupId || f.Long.UZERO).toString()), v.memberUpdates ? N.memberUpdates = v.memberUpdates.map((q) => q ? r.MemberRequest.toJSON(q) : void 0) : N.memberUpdates = [], N;
    },
    fromPartial(v) {
      var N;
      const q = U();
      return q.admin = v.admin ?? "", q.groupId = v.groupId !== void 0 && v.groupId !== null ? f.Long.fromValue(v.groupId) : f.Long.UZERO, q.memberUpdates = ((N = v.memberUpdates) == null ? void 0 : N.map((G) => r.MemberRequest.fromPartial(G))) || [], q;
    }
  };
  function C() {
    return {};
  }
  e.MsgUpdateGroupMembersResponse = {
    encode(v, N = b.Writer.create()) {
      return N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = C();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {};
    },
    toJSON(v) {
      return {};
    },
    fromPartial(v) {
      return C();
    }
  };
  function l() {
    return {
      admin: "",
      groupId: f.Long.UZERO,
      newAdmin: ""
    };
  }
  e.MsgUpdateGroupAdmin = {
    encode(v, N = b.Writer.create()) {
      return v.admin !== "" && N.uint32(10).string(v.admin), v.groupId.isZero() || N.uint32(16).uint64(v.groupId), v.newAdmin !== "" && N.uint32(26).string(v.newAdmin), N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = l();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          case 1:
            K.admin = q.string();
            break;
          case 2:
            K.groupId = q.uint64();
            break;
          case 3:
            K.newAdmin = q.string();
            break;
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {
        admin: (0, f.isSet)(v.admin) ? String(v.admin) : "",
        groupId: (0, f.isSet)(v.groupId) ? f.Long.fromValue(v.groupId) : f.Long.UZERO,
        newAdmin: (0, f.isSet)(v.newAdmin) ? String(v.newAdmin) : ""
      };
    },
    toJSON(v) {
      const N = {};
      return v.admin !== void 0 && (N.admin = v.admin), v.groupId !== void 0 && (N.groupId = (v.groupId || f.Long.UZERO).toString()), v.newAdmin !== void 0 && (N.newAdmin = v.newAdmin), N;
    },
    fromPartial(v) {
      const N = l();
      return N.admin = v.admin ?? "", N.groupId = v.groupId !== void 0 && v.groupId !== null ? f.Long.fromValue(v.groupId) : f.Long.UZERO, N.newAdmin = v.newAdmin ?? "", N;
    }
  };
  function S() {
    return {};
  }
  e.MsgUpdateGroupAdminResponse = {
    encode(v, N = b.Writer.create()) {
      return N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = S();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {};
    },
    toJSON(v) {
      return {};
    },
    fromPartial(v) {
      return S();
    }
  };
  function A() {
    return {
      admin: "",
      groupId: f.Long.UZERO,
      metadata: ""
    };
  }
  e.MsgUpdateGroupMetadata = {
    encode(v, N = b.Writer.create()) {
      return v.admin !== "" && N.uint32(10).string(v.admin), v.groupId.isZero() || N.uint32(16).uint64(v.groupId), v.metadata !== "" && N.uint32(26).string(v.metadata), N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = A();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          case 1:
            K.admin = q.string();
            break;
          case 2:
            K.groupId = q.uint64();
            break;
          case 3:
            K.metadata = q.string();
            break;
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {
        admin: (0, f.isSet)(v.admin) ? String(v.admin) : "",
        groupId: (0, f.isSet)(v.groupId) ? f.Long.fromValue(v.groupId) : f.Long.UZERO,
        metadata: (0, f.isSet)(v.metadata) ? String(v.metadata) : ""
      };
    },
    toJSON(v) {
      const N = {};
      return v.admin !== void 0 && (N.admin = v.admin), v.groupId !== void 0 && (N.groupId = (v.groupId || f.Long.UZERO).toString()), v.metadata !== void 0 && (N.metadata = v.metadata), N;
    },
    fromPartial(v) {
      const N = A();
      return N.admin = v.admin ?? "", N.groupId = v.groupId !== void 0 && v.groupId !== null ? f.Long.fromValue(v.groupId) : f.Long.UZERO, N.metadata = v.metadata ?? "", N;
    }
  };
  function d() {
    return {};
  }
  e.MsgUpdateGroupMetadataResponse = {
    encode(v, N = b.Writer.create()) {
      return N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = d();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {};
    },
    toJSON(v) {
      return {};
    },
    fromPartial(v) {
      return d();
    }
  };
  function p() {
    return {
      admin: "",
      groupId: f.Long.UZERO,
      metadata: "",
      decisionPolicy: void 0
    };
  }
  e.MsgCreateGroupPolicy = {
    encode(v, N = b.Writer.create()) {
      return v.admin !== "" && N.uint32(10).string(v.admin), v.groupId.isZero() || N.uint32(16).uint64(v.groupId), v.metadata !== "" && N.uint32(26).string(v.metadata), v.decisionPolicy !== void 0 && m.Any.encode(v.decisionPolicy, N.uint32(34).fork()).ldelim(), N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = p();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          case 1:
            K.admin = q.string();
            break;
          case 2:
            K.groupId = q.uint64();
            break;
          case 3:
            K.metadata = q.string();
            break;
          case 4:
            K.decisionPolicy = m.Any.decode(q, q.uint32());
            break;
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {
        admin: (0, f.isSet)(v.admin) ? String(v.admin) : "",
        groupId: (0, f.isSet)(v.groupId) ? f.Long.fromValue(v.groupId) : f.Long.UZERO,
        metadata: (0, f.isSet)(v.metadata) ? String(v.metadata) : "",
        decisionPolicy: (0, f.isSet)(v.decisionPolicy) ? m.Any.fromJSON(v.decisionPolicy) : void 0
      };
    },
    toJSON(v) {
      const N = {};
      return v.admin !== void 0 && (N.admin = v.admin), v.groupId !== void 0 && (N.groupId = (v.groupId || f.Long.UZERO).toString()), v.metadata !== void 0 && (N.metadata = v.metadata), v.decisionPolicy !== void 0 && (N.decisionPolicy = v.decisionPolicy ? m.Any.toJSON(v.decisionPolicy) : void 0), N;
    },
    fromPartial(v) {
      const N = p();
      return N.admin = v.admin ?? "", N.groupId = v.groupId !== void 0 && v.groupId !== null ? f.Long.fromValue(v.groupId) : f.Long.UZERO, N.metadata = v.metadata ?? "", N.decisionPolicy = v.decisionPolicy !== void 0 && v.decisionPolicy !== null ? m.Any.fromPartial(v.decisionPolicy) : void 0, N;
    }
  };
  function h() {
    return {
      address: ""
    };
  }
  e.MsgCreateGroupPolicyResponse = {
    encode(v, N = b.Writer.create()) {
      return v.address !== "" && N.uint32(10).string(v.address), N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = h();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          case 1:
            K.address = q.string();
            break;
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {
        address: (0, f.isSet)(v.address) ? String(v.address) : ""
      };
    },
    toJSON(v) {
      const N = {};
      return v.address !== void 0 && (N.address = v.address), N;
    },
    fromPartial(v) {
      const N = h();
      return N.address = v.address ?? "", N;
    }
  };
  function x() {
    return {
      admin: "",
      groupPolicyAddress: "",
      newAdmin: ""
    };
  }
  e.MsgUpdateGroupPolicyAdmin = {
    encode(v, N = b.Writer.create()) {
      return v.admin !== "" && N.uint32(10).string(v.admin), v.groupPolicyAddress !== "" && N.uint32(18).string(v.groupPolicyAddress), v.newAdmin !== "" && N.uint32(26).string(v.newAdmin), N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = x();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          case 1:
            K.admin = q.string();
            break;
          case 2:
            K.groupPolicyAddress = q.string();
            break;
          case 3:
            K.newAdmin = q.string();
            break;
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {
        admin: (0, f.isSet)(v.admin) ? String(v.admin) : "",
        groupPolicyAddress: (0, f.isSet)(v.groupPolicyAddress) ? String(v.groupPolicyAddress) : "",
        newAdmin: (0, f.isSet)(v.newAdmin) ? String(v.newAdmin) : ""
      };
    },
    toJSON(v) {
      const N = {};
      return v.admin !== void 0 && (N.admin = v.admin), v.groupPolicyAddress !== void 0 && (N.groupPolicyAddress = v.groupPolicyAddress), v.newAdmin !== void 0 && (N.newAdmin = v.newAdmin), N;
    },
    fromPartial(v) {
      const N = x();
      return N.admin = v.admin ?? "", N.groupPolicyAddress = v.groupPolicyAddress ?? "", N.newAdmin = v.newAdmin ?? "", N;
    }
  };
  function _() {
    return {};
  }
  e.MsgUpdateGroupPolicyAdminResponse = {
    encode(v, N = b.Writer.create()) {
      return N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = _();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {};
    },
    toJSON(v) {
      return {};
    },
    fromPartial(v) {
      return _();
    }
  };
  function I() {
    return {
      admin: "",
      members: [],
      groupMetadata: "",
      groupPolicyMetadata: "",
      groupPolicyAsAdmin: !1,
      decisionPolicy: void 0
    };
  }
  e.MsgCreateGroupWithPolicy = {
    encode(v, N = b.Writer.create()) {
      v.admin !== "" && N.uint32(10).string(v.admin);
      for (const q of v.members)
        r.MemberRequest.encode(q, N.uint32(18).fork()).ldelim();
      return v.groupMetadata !== "" && N.uint32(26).string(v.groupMetadata), v.groupPolicyMetadata !== "" && N.uint32(34).string(v.groupPolicyMetadata), v.groupPolicyAsAdmin === !0 && N.uint32(40).bool(v.groupPolicyAsAdmin), v.decisionPolicy !== void 0 && m.Any.encode(v.decisionPolicy, N.uint32(50).fork()).ldelim(), N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = I();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          case 1:
            K.admin = q.string();
            break;
          case 2:
            K.members.push(r.MemberRequest.decode(q, q.uint32()));
            break;
          case 3:
            K.groupMetadata = q.string();
            break;
          case 4:
            K.groupPolicyMetadata = q.string();
            break;
          case 5:
            K.groupPolicyAsAdmin = q.bool();
            break;
          case 6:
            K.decisionPolicy = m.Any.decode(q, q.uint32());
            break;
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {
        admin: (0, f.isSet)(v.admin) ? String(v.admin) : "",
        members: Array.isArray(v == null ? void 0 : v.members) ? v.members.map((N) => r.MemberRequest.fromJSON(N)) : [],
        groupMetadata: (0, f.isSet)(v.groupMetadata) ? String(v.groupMetadata) : "",
        groupPolicyMetadata: (0, f.isSet)(v.groupPolicyMetadata) ? String(v.groupPolicyMetadata) : "",
        groupPolicyAsAdmin: (0, f.isSet)(v.groupPolicyAsAdmin) ? !!v.groupPolicyAsAdmin : !1,
        decisionPolicy: (0, f.isSet)(v.decisionPolicy) ? m.Any.fromJSON(v.decisionPolicy) : void 0
      };
    },
    toJSON(v) {
      const N = {};
      return v.admin !== void 0 && (N.admin = v.admin), v.members ? N.members = v.members.map((q) => q ? r.MemberRequest.toJSON(q) : void 0) : N.members = [], v.groupMetadata !== void 0 && (N.groupMetadata = v.groupMetadata), v.groupPolicyMetadata !== void 0 && (N.groupPolicyMetadata = v.groupPolicyMetadata), v.groupPolicyAsAdmin !== void 0 && (N.groupPolicyAsAdmin = v.groupPolicyAsAdmin), v.decisionPolicy !== void 0 && (N.decisionPolicy = v.decisionPolicy ? m.Any.toJSON(v.decisionPolicy) : void 0), N;
    },
    fromPartial(v) {
      var N;
      const q = I();
      return q.admin = v.admin ?? "", q.members = ((N = v.members) == null ? void 0 : N.map((G) => r.MemberRequest.fromPartial(G))) || [], q.groupMetadata = v.groupMetadata ?? "", q.groupPolicyMetadata = v.groupPolicyMetadata ?? "", q.groupPolicyAsAdmin = v.groupPolicyAsAdmin ?? !1, q.decisionPolicy = v.decisionPolicy !== void 0 && v.decisionPolicy !== null ? m.Any.fromPartial(v.decisionPolicy) : void 0, q;
    }
  };
  function W() {
    return {
      groupId: f.Long.UZERO,
      groupPolicyAddress: ""
    };
  }
  e.MsgCreateGroupWithPolicyResponse = {
    encode(v, N = b.Writer.create()) {
      return v.groupId.isZero() || N.uint32(8).uint64(v.groupId), v.groupPolicyAddress !== "" && N.uint32(18).string(v.groupPolicyAddress), N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = W();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          case 1:
            K.groupId = q.uint64();
            break;
          case 2:
            K.groupPolicyAddress = q.string();
            break;
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {
        groupId: (0, f.isSet)(v.groupId) ? f.Long.fromValue(v.groupId) : f.Long.UZERO,
        groupPolicyAddress: (0, f.isSet)(v.groupPolicyAddress) ? String(v.groupPolicyAddress) : ""
      };
    },
    toJSON(v) {
      const N = {};
      return v.groupId !== void 0 && (N.groupId = (v.groupId || f.Long.UZERO).toString()), v.groupPolicyAddress !== void 0 && (N.groupPolicyAddress = v.groupPolicyAddress), N;
    },
    fromPartial(v) {
      const N = W();
      return N.groupId = v.groupId !== void 0 && v.groupId !== null ? f.Long.fromValue(v.groupId) : f.Long.UZERO, N.groupPolicyAddress = v.groupPolicyAddress ?? "", N;
    }
  };
  function n() {
    return {
      admin: "",
      groupPolicyAddress: "",
      decisionPolicy: void 0
    };
  }
  e.MsgUpdateGroupPolicyDecisionPolicy = {
    encode(v, N = b.Writer.create()) {
      return v.admin !== "" && N.uint32(10).string(v.admin), v.groupPolicyAddress !== "" && N.uint32(18).string(v.groupPolicyAddress), v.decisionPolicy !== void 0 && m.Any.encode(v.decisionPolicy, N.uint32(26).fork()).ldelim(), N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = n();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          case 1:
            K.admin = q.string();
            break;
          case 2:
            K.groupPolicyAddress = q.string();
            break;
          case 3:
            K.decisionPolicy = m.Any.decode(q, q.uint32());
            break;
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {
        admin: (0, f.isSet)(v.admin) ? String(v.admin) : "",
        groupPolicyAddress: (0, f.isSet)(v.groupPolicyAddress) ? String(v.groupPolicyAddress) : "",
        decisionPolicy: (0, f.isSet)(v.decisionPolicy) ? m.Any.fromJSON(v.decisionPolicy) : void 0
      };
    },
    toJSON(v) {
      const N = {};
      return v.admin !== void 0 && (N.admin = v.admin), v.groupPolicyAddress !== void 0 && (N.groupPolicyAddress = v.groupPolicyAddress), v.decisionPolicy !== void 0 && (N.decisionPolicy = v.decisionPolicy ? m.Any.toJSON(v.decisionPolicy) : void 0), N;
    },
    fromPartial(v) {
      const N = n();
      return N.admin = v.admin ?? "", N.groupPolicyAddress = v.groupPolicyAddress ?? "", N.decisionPolicy = v.decisionPolicy !== void 0 && v.decisionPolicy !== null ? m.Any.fromPartial(v.decisionPolicy) : void 0, N;
    }
  };
  function y() {
    return {};
  }
  e.MsgUpdateGroupPolicyDecisionPolicyResponse = {
    encode(v, N = b.Writer.create()) {
      return N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = y();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {};
    },
    toJSON(v) {
      return {};
    },
    fromPartial(v) {
      return y();
    }
  };
  function w() {
    return {
      admin: "",
      groupPolicyAddress: "",
      metadata: ""
    };
  }
  e.MsgUpdateGroupPolicyMetadata = {
    encode(v, N = b.Writer.create()) {
      return v.admin !== "" && N.uint32(10).string(v.admin), v.groupPolicyAddress !== "" && N.uint32(18).string(v.groupPolicyAddress), v.metadata !== "" && N.uint32(26).string(v.metadata), N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = w();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          case 1:
            K.admin = q.string();
            break;
          case 2:
            K.groupPolicyAddress = q.string();
            break;
          case 3:
            K.metadata = q.string();
            break;
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {
        admin: (0, f.isSet)(v.admin) ? String(v.admin) : "",
        groupPolicyAddress: (0, f.isSet)(v.groupPolicyAddress) ? String(v.groupPolicyAddress) : "",
        metadata: (0, f.isSet)(v.metadata) ? String(v.metadata) : ""
      };
    },
    toJSON(v) {
      const N = {};
      return v.admin !== void 0 && (N.admin = v.admin), v.groupPolicyAddress !== void 0 && (N.groupPolicyAddress = v.groupPolicyAddress), v.metadata !== void 0 && (N.metadata = v.metadata), N;
    },
    fromPartial(v) {
      const N = w();
      return N.admin = v.admin ?? "", N.groupPolicyAddress = v.groupPolicyAddress ?? "", N.metadata = v.metadata ?? "", N;
    }
  };
  function M() {
    return {};
  }
  e.MsgUpdateGroupPolicyMetadataResponse = {
    encode(v, N = b.Writer.create()) {
      return N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = M();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {};
    },
    toJSON(v) {
      return {};
    },
    fromPartial(v) {
      return M();
    }
  };
  function s() {
    return {
      groupPolicyAddress: "",
      proposers: [],
      metadata: "",
      messages: [],
      exec: 0,
      title: "",
      summary: ""
    };
  }
  e.MsgSubmitProposal = {
    encode(v, N = b.Writer.create()) {
      v.groupPolicyAddress !== "" && N.uint32(10).string(v.groupPolicyAddress);
      for (const q of v.proposers)
        N.uint32(18).string(q);
      v.metadata !== "" && N.uint32(26).string(v.metadata);
      for (const q of v.messages)
        m.Any.encode(q, N.uint32(34).fork()).ldelim();
      return v.exec !== 0 && N.uint32(40).int32(v.exec), v.title !== "" && N.uint32(50).string(v.title), v.summary !== "" && N.uint32(58).string(v.summary), N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = s();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          case 1:
            K.groupPolicyAddress = q.string();
            break;
          case 2:
            K.proposers.push(q.string());
            break;
          case 3:
            K.metadata = q.string();
            break;
          case 4:
            K.messages.push(m.Any.decode(q, q.uint32()));
            break;
          case 5:
            K.exec = q.int32();
            break;
          case 6:
            K.title = q.string();
            break;
          case 7:
            K.summary = q.string();
            break;
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {
        groupPolicyAddress: (0, f.isSet)(v.groupPolicyAddress) ? String(v.groupPolicyAddress) : "",
        proposers: Array.isArray(v == null ? void 0 : v.proposers) ? v.proposers.map((N) => String(N)) : [],
        metadata: (0, f.isSet)(v.metadata) ? String(v.metadata) : "",
        messages: Array.isArray(v == null ? void 0 : v.messages) ? v.messages.map((N) => m.Any.fromJSON(N)) : [],
        exec: (0, f.isSet)(v.exec) ? T(v.exec) : 0,
        title: (0, f.isSet)(v.title) ? String(v.title) : "",
        summary: (0, f.isSet)(v.summary) ? String(v.summary) : ""
      };
    },
    toJSON(v) {
      const N = {};
      return v.groupPolicyAddress !== void 0 && (N.groupPolicyAddress = v.groupPolicyAddress), v.proposers ? N.proposers = v.proposers.map((q) => q) : N.proposers = [], v.metadata !== void 0 && (N.metadata = v.metadata), v.messages ? N.messages = v.messages.map((q) => q ? m.Any.toJSON(q) : void 0) : N.messages = [], v.exec !== void 0 && (N.exec = V(v.exec)), v.title !== void 0 && (N.title = v.title), v.summary !== void 0 && (N.summary = v.summary), N;
    },
    fromPartial(v) {
      var N, q;
      const G = s();
      return G.groupPolicyAddress = v.groupPolicyAddress ?? "", G.proposers = ((N = v.proposers) == null ? void 0 : N.map((K) => K)) || [], G.metadata = v.metadata ?? "", G.messages = ((q = v.messages) == null ? void 0 : q.map((K) => m.Any.fromPartial(K))) || [], G.exec = v.exec ?? 0, G.title = v.title ?? "", G.summary = v.summary ?? "", G;
    }
  };
  function c() {
    return {
      proposalId: f.Long.UZERO
    };
  }
  e.MsgSubmitProposalResponse = {
    encode(v, N = b.Writer.create()) {
      return v.proposalId.isZero() || N.uint32(8).uint64(v.proposalId), N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = c();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          case 1:
            K.proposalId = q.uint64();
            break;
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {
        proposalId: (0, f.isSet)(v.proposalId) ? f.Long.fromValue(v.proposalId) : f.Long.UZERO
      };
    },
    toJSON(v) {
      const N = {};
      return v.proposalId !== void 0 && (N.proposalId = (v.proposalId || f.Long.UZERO).toString()), N;
    },
    fromPartial(v) {
      const N = c();
      return N.proposalId = v.proposalId !== void 0 && v.proposalId !== null ? f.Long.fromValue(v.proposalId) : f.Long.UZERO, N;
    }
  };
  function E() {
    return {
      proposalId: f.Long.UZERO,
      address: ""
    };
  }
  e.MsgWithdrawProposal = {
    encode(v, N = b.Writer.create()) {
      return v.proposalId.isZero() || N.uint32(8).uint64(v.proposalId), v.address !== "" && N.uint32(18).string(v.address), N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = E();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          case 1:
            K.proposalId = q.uint64();
            break;
          case 2:
            K.address = q.string();
            break;
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {
        proposalId: (0, f.isSet)(v.proposalId) ? f.Long.fromValue(v.proposalId) : f.Long.UZERO,
        address: (0, f.isSet)(v.address) ? String(v.address) : ""
      };
    },
    toJSON(v) {
      const N = {};
      return v.proposalId !== void 0 && (N.proposalId = (v.proposalId || f.Long.UZERO).toString()), v.address !== void 0 && (N.address = v.address), N;
    },
    fromPartial(v) {
      const N = E();
      return N.proposalId = v.proposalId !== void 0 && v.proposalId !== null ? f.Long.fromValue(v.proposalId) : f.Long.UZERO, N.address = v.address ?? "", N;
    }
  };
  function k() {
    return {};
  }
  e.MsgWithdrawProposalResponse = {
    encode(v, N = b.Writer.create()) {
      return N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = k();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {};
    },
    toJSON(v) {
      return {};
    },
    fromPartial(v) {
      return k();
    }
  };
  function O() {
    return {
      proposalId: f.Long.UZERO,
      voter: "",
      option: 0,
      metadata: "",
      exec: 0
    };
  }
  e.MsgVote = {
    encode(v, N = b.Writer.create()) {
      return v.proposalId.isZero() || N.uint32(8).uint64(v.proposalId), v.voter !== "" && N.uint32(18).string(v.voter), v.option !== 0 && N.uint32(24).int32(v.option), v.metadata !== "" && N.uint32(34).string(v.metadata), v.exec !== 0 && N.uint32(40).int32(v.exec), N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = O();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          case 1:
            K.proposalId = q.uint64();
            break;
          case 2:
            K.voter = q.string();
            break;
          case 3:
            K.option = q.int32();
            break;
          case 4:
            K.metadata = q.string();
            break;
          case 5:
            K.exec = q.int32();
            break;
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {
        proposalId: (0, f.isSet)(v.proposalId) ? f.Long.fromValue(v.proposalId) : f.Long.UZERO,
        voter: (0, f.isSet)(v.voter) ? String(v.voter) : "",
        option: (0, f.isSet)(v.option) ? (0, r.voteOptionFromJSON)(v.option) : 0,
        metadata: (0, f.isSet)(v.metadata) ? String(v.metadata) : "",
        exec: (0, f.isSet)(v.exec) ? T(v.exec) : 0
      };
    },
    toJSON(v) {
      const N = {};
      return v.proposalId !== void 0 && (N.proposalId = (v.proposalId || f.Long.UZERO).toString()), v.voter !== void 0 && (N.voter = v.voter), v.option !== void 0 && (N.option = (0, r.voteOptionToJSON)(v.option)), v.metadata !== void 0 && (N.metadata = v.metadata), v.exec !== void 0 && (N.exec = V(v.exec)), N;
    },
    fromPartial(v) {
      const N = O();
      return N.proposalId = v.proposalId !== void 0 && v.proposalId !== null ? f.Long.fromValue(v.proposalId) : f.Long.UZERO, N.voter = v.voter ?? "", N.option = v.option ?? 0, N.metadata = v.metadata ?? "", N.exec = v.exec ?? 0, N;
    }
  };
  function L() {
    return {};
  }
  e.MsgVoteResponse = {
    encode(v, N = b.Writer.create()) {
      return N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = L();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {};
    },
    toJSON(v) {
      return {};
    },
    fromPartial(v) {
      return L();
    }
  };
  function Z() {
    return {
      proposalId: f.Long.UZERO,
      executor: ""
    };
  }
  e.MsgExec = {
    encode(v, N = b.Writer.create()) {
      return v.proposalId.isZero() || N.uint32(8).uint64(v.proposalId), v.executor !== "" && N.uint32(18).string(v.executor), N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = Z();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          case 1:
            K.proposalId = q.uint64();
            break;
          case 2:
            K.executor = q.string();
            break;
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {
        proposalId: (0, f.isSet)(v.proposalId) ? f.Long.fromValue(v.proposalId) : f.Long.UZERO,
        executor: (0, f.isSet)(v.executor) ? String(v.executor) : ""
      };
    },
    toJSON(v) {
      const N = {};
      return v.proposalId !== void 0 && (N.proposalId = (v.proposalId || f.Long.UZERO).toString()), v.executor !== void 0 && (N.executor = v.executor), N;
    },
    fromPartial(v) {
      const N = Z();
      return N.proposalId = v.proposalId !== void 0 && v.proposalId !== null ? f.Long.fromValue(v.proposalId) : f.Long.UZERO, N.executor = v.executor ?? "", N;
    }
  };
  function j() {
    return {
      result: 0
    };
  }
  e.MsgExecResponse = {
    encode(v, N = b.Writer.create()) {
      return v.result !== 0 && N.uint32(16).int32(v.result), N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = j();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          case 2:
            K.result = q.int32();
            break;
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {
        result: (0, f.isSet)(v.result) ? (0, r.proposalExecutorResultFromJSON)(v.result) : 0
      };
    },
    toJSON(v) {
      const N = {};
      return v.result !== void 0 && (N.result = (0, r.proposalExecutorResultToJSON)(v.result)), N;
    },
    fromPartial(v) {
      const N = j();
      return N.result = v.result ?? 0, N;
    }
  };
  function i() {
    return {
      address: "",
      groupId: f.Long.UZERO
    };
  }
  e.MsgLeaveGroup = {
    encode(v, N = b.Writer.create()) {
      return v.address !== "" && N.uint32(10).string(v.address), v.groupId.isZero() || N.uint32(16).uint64(v.groupId), N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = i();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          case 1:
            K.address = q.string();
            break;
          case 2:
            K.groupId = q.uint64();
            break;
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {
        address: (0, f.isSet)(v.address) ? String(v.address) : "",
        groupId: (0, f.isSet)(v.groupId) ? f.Long.fromValue(v.groupId) : f.Long.UZERO
      };
    },
    toJSON(v) {
      const N = {};
      return v.address !== void 0 && (N.address = v.address), v.groupId !== void 0 && (N.groupId = (v.groupId || f.Long.UZERO).toString()), N;
    },
    fromPartial(v) {
      const N = i();
      return N.address = v.address ?? "", N.groupId = v.groupId !== void 0 && v.groupId !== null ? f.Long.fromValue(v.groupId) : f.Long.UZERO, N;
    }
  };
  function P() {
    return {};
  }
  e.MsgLeaveGroupResponse = {
    encode(v, N = b.Writer.create()) {
      return N;
    },
    decode(v, N) {
      const q = v instanceof b.Reader ? v : new b.Reader(v);
      let G = N === void 0 ? q.len : q.pos + N;
      const K = P();
      for (; q.pos < G; ) {
        const oe = q.uint32();
        switch (oe >>> 3) {
          default:
            q.skipType(oe & 7);
            break;
        }
      }
      return K;
    },
    fromJSON(v) {
      return {};
    },
    toJSON(v) {
      return {};
    },
    fromPartial(v) {
      return P();
    }
  };
  class g {
    constructor(N) {
      this.rpc = N, this.CreateGroup = this.CreateGroup.bind(this), this.UpdateGroupMembers = this.UpdateGroupMembers.bind(this), this.UpdateGroupAdmin = this.UpdateGroupAdmin.bind(this), this.UpdateGroupMetadata = this.UpdateGroupMetadata.bind(this), this.CreateGroupPolicy = this.CreateGroupPolicy.bind(this), this.CreateGroupWithPolicy = this.CreateGroupWithPolicy.bind(this), this.UpdateGroupPolicyAdmin = this.UpdateGroupPolicyAdmin.bind(this), this.UpdateGroupPolicyDecisionPolicy = this.UpdateGroupPolicyDecisionPolicy.bind(this), this.UpdateGroupPolicyMetadata = this.UpdateGroupPolicyMetadata.bind(this), this.SubmitProposal = this.SubmitProposal.bind(this), this.WithdrawProposal = this.WithdrawProposal.bind(this), this.Vote = this.Vote.bind(this), this.Exec = this.Exec.bind(this), this.LeaveGroup = this.LeaveGroup.bind(this);
    }
    CreateGroup(N) {
      const q = e.MsgCreateGroup.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "CreateGroup", q).then((G) => e.MsgCreateGroupResponse.decode(new b.Reader(G)));
    }
    UpdateGroupMembers(N) {
      const q = e.MsgUpdateGroupMembers.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupMembers", q).then((G) => e.MsgUpdateGroupMembersResponse.decode(new b.Reader(G)));
    }
    UpdateGroupAdmin(N) {
      const q = e.MsgUpdateGroupAdmin.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupAdmin", q).then((G) => e.MsgUpdateGroupAdminResponse.decode(new b.Reader(G)));
    }
    UpdateGroupMetadata(N) {
      const q = e.MsgUpdateGroupMetadata.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupMetadata", q).then((G) => e.MsgUpdateGroupMetadataResponse.decode(new b.Reader(G)));
    }
    CreateGroupPolicy(N) {
      const q = e.MsgCreateGroupPolicy.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "CreateGroupPolicy", q).then((G) => e.MsgCreateGroupPolicyResponse.decode(new b.Reader(G)));
    }
    CreateGroupWithPolicy(N) {
      const q = e.MsgCreateGroupWithPolicy.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "CreateGroupWithPolicy", q).then((G) => e.MsgCreateGroupWithPolicyResponse.decode(new b.Reader(G)));
    }
    UpdateGroupPolicyAdmin(N) {
      const q = e.MsgUpdateGroupPolicyAdmin.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyAdmin", q).then((G) => e.MsgUpdateGroupPolicyAdminResponse.decode(new b.Reader(G)));
    }
    UpdateGroupPolicyDecisionPolicy(N) {
      const q = e.MsgUpdateGroupPolicyDecisionPolicy.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyDecisionPolicy", q).then((G) => e.MsgUpdateGroupPolicyDecisionPolicyResponse.decode(new b.Reader(G)));
    }
    UpdateGroupPolicyMetadata(N) {
      const q = e.MsgUpdateGroupPolicyMetadata.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyMetadata", q).then((G) => e.MsgUpdateGroupPolicyMetadataResponse.decode(new b.Reader(G)));
    }
    SubmitProposal(N) {
      const q = e.MsgSubmitProposal.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "SubmitProposal", q).then((G) => e.MsgSubmitProposalResponse.decode(new b.Reader(G)));
    }
    WithdrawProposal(N) {
      const q = e.MsgWithdrawProposal.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "WithdrawProposal", q).then((G) => e.MsgWithdrawProposalResponse.decode(new b.Reader(G)));
    }
    Vote(N) {
      const q = e.MsgVote.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "Vote", q).then((G) => e.MsgVoteResponse.decode(new b.Reader(G)));
    }
    Exec(N) {
      const q = e.MsgExec.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "Exec", q).then((G) => e.MsgExecResponse.decode(new b.Reader(G)));
    }
    LeaveGroup(N) {
      const q = e.MsgLeaveGroup.encode(N).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "LeaveGroup", q).then((G) => e.MsgLeaveGroupResponse.decode(new b.Reader(G)));
    }
  }
  e.MsgClientImpl = g;
})(kc);
Object.defineProperty(cr, "__esModule", { value: !0 });
cr.groupTypes = void 0;
const Me = kc;
cr.groupTypes = [
  ["/cosmos.group.v1.MsgCreateGroup", Me.MsgCreateGroup],
  ["/cosmos.group.v1.MsgCreateGroupPolicy", Me.MsgCreateGroupPolicy],
  ["/cosmos.group.v1.MsgCreateGroupWithPolicy", Me.MsgCreateGroupWithPolicy],
  ["/cosmos.group.v1.MsgExec", Me.MsgExec],
  ["/cosmos.group.v1.MsgLeaveGroup", Me.MsgLeaveGroup],
  ["/cosmos.group.v1.MsgSubmitProposal", Me.MsgSubmitProposal],
  ["/cosmos.group.v1.MsgUpdateGroupAdmin", Me.MsgUpdateGroupAdmin],
  ["/cosmos.group.v1.MsgUpdateGroupMembers", Me.MsgUpdateGroupMembers],
  ["/cosmos.group.v1.MsgUpdateGroupMetadata", Me.MsgUpdateGroupMetadata],
  ["/cosmos.group.v1.MsgUpdateGroupPolicyAdmin", Me.MsgUpdateGroupPolicyAdmin],
  ["/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy", Me.MsgUpdateGroupPolicyDecisionPolicy],
  ["/cosmos.group.v1.MsgUpdateGroupPolicyMetadata", Me.MsgUpdateGroupPolicyMetadata],
  ["/cosmos.group.v1.MsgVote", Me.MsgVote],
  ["/cosmos.group.v1.MsgWithdrawProposal", Me.MsgWithdrawProposal]
];
var Cn = {}, ur = {}, Tt = {}, Rc = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(B, U, C, l) {
    l === void 0 && (l = C);
    var S = Object.getOwnPropertyDescriptor(U, C);
    (!S || ("get" in S ? !U.__esModule : S.writable || S.configurable)) && (S = { enumerable: !0, get: function() {
      return U[C];
    } }), Object.defineProperty(B, l, S);
  } : function(B, U, C, l) {
    l === void 0 && (l = C), B[l] = U[C];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(B, U) {
    Object.defineProperty(B, "default", { enumerable: !0, value: U });
  } : function(B, U) {
    B.default = U;
  }), u = Q && Q.__importStar || function(B) {
    if (B && B.__esModule)
      return B;
    var U = {};
    if (B != null)
      for (var C in B)
        C !== "default" && Object.prototype.hasOwnProperty.call(B, C) && o(U, B, C);
    return t(U, B), U;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ModuleVersion = e.CancelSoftwareUpgradeProposal = e.SoftwareUpgradeProposal = e.Plan = e.protobufPackage = void 0;
  const r = Ae, m = ye, f = ie, b = u(re);
  e.protobufPackage = "cosmos.upgrade.v1beta1";
  function R() {
    return {
      name: "",
      time: void 0,
      height: f.Long.ZERO,
      info: "",
      upgradedClientState: void 0
    };
  }
  e.Plan = {
    encode(B, U = b.Writer.create()) {
      return B.name !== "" && U.uint32(10).string(B.name), B.time !== void 0 && r.Timestamp.encode(B.time, U.uint32(18).fork()).ldelim(), B.height.isZero() || U.uint32(24).int64(B.height), B.info !== "" && U.uint32(34).string(B.info), B.upgradedClientState !== void 0 && m.Any.encode(B.upgradedClientState, U.uint32(42).fork()).ldelim(), U;
    },
    decode(B, U) {
      const C = B instanceof b.Reader ? B : new b.Reader(B);
      let l = U === void 0 ? C.len : C.pos + U;
      const S = R();
      for (; C.pos < l; ) {
        const A = C.uint32();
        switch (A >>> 3) {
          case 1:
            S.name = C.string();
            break;
          case 2:
            S.time = r.Timestamp.decode(C, C.uint32());
            break;
          case 3:
            S.height = C.int64();
            break;
          case 4:
            S.info = C.string();
            break;
          case 5:
            S.upgradedClientState = m.Any.decode(C, C.uint32());
            break;
          default:
            C.skipType(A & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(B) {
      return {
        name: (0, f.isSet)(B.name) ? String(B.name) : "",
        time: (0, f.isSet)(B.time) ? (0, f.fromJsonTimestamp)(B.time) : void 0,
        height: (0, f.isSet)(B.height) ? f.Long.fromValue(B.height) : f.Long.ZERO,
        info: (0, f.isSet)(B.info) ? String(B.info) : "",
        upgradedClientState: (0, f.isSet)(B.upgradedClientState) ? m.Any.fromJSON(B.upgradedClientState) : void 0
      };
    },
    toJSON(B) {
      const U = {};
      return B.name !== void 0 && (U.name = B.name), B.time !== void 0 && (U.time = (0, f.fromTimestamp)(B.time).toISOString()), B.height !== void 0 && (U.height = (B.height || f.Long.ZERO).toString()), B.info !== void 0 && (U.info = B.info), B.upgradedClientState !== void 0 && (U.upgradedClientState = B.upgradedClientState ? m.Any.toJSON(B.upgradedClientState) : void 0), U;
    },
    fromPartial(B) {
      const U = R();
      return U.name = B.name ?? "", U.time = B.time !== void 0 && B.time !== null ? r.Timestamp.fromPartial(B.time) : void 0, U.height = B.height !== void 0 && B.height !== null ? f.Long.fromValue(B.height) : f.Long.ZERO, U.info = B.info ?? "", U.upgradedClientState = B.upgradedClientState !== void 0 && B.upgradedClientState !== null ? m.Any.fromPartial(B.upgradedClientState) : void 0, U;
    }
  };
  function T() {
    return {
      title: "",
      description: "",
      plan: void 0
    };
  }
  e.SoftwareUpgradeProposal = {
    encode(B, U = b.Writer.create()) {
      return B.title !== "" && U.uint32(10).string(B.title), B.description !== "" && U.uint32(18).string(B.description), B.plan !== void 0 && e.Plan.encode(B.plan, U.uint32(26).fork()).ldelim(), U;
    },
    decode(B, U) {
      const C = B instanceof b.Reader ? B : new b.Reader(B);
      let l = U === void 0 ? C.len : C.pos + U;
      const S = T();
      for (; C.pos < l; ) {
        const A = C.uint32();
        switch (A >>> 3) {
          case 1:
            S.title = C.string();
            break;
          case 2:
            S.description = C.string();
            break;
          case 3:
            S.plan = e.Plan.decode(C, C.uint32());
            break;
          default:
            C.skipType(A & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(B) {
      return {
        title: (0, f.isSet)(B.title) ? String(B.title) : "",
        description: (0, f.isSet)(B.description) ? String(B.description) : "",
        plan: (0, f.isSet)(B.plan) ? e.Plan.fromJSON(B.plan) : void 0
      };
    },
    toJSON(B) {
      const U = {};
      return B.title !== void 0 && (U.title = B.title), B.description !== void 0 && (U.description = B.description), B.plan !== void 0 && (U.plan = B.plan ? e.Plan.toJSON(B.plan) : void 0), U;
    },
    fromPartial(B) {
      const U = T();
      return U.title = B.title ?? "", U.description = B.description ?? "", U.plan = B.plan !== void 0 && B.plan !== null ? e.Plan.fromPartial(B.plan) : void 0, U;
    }
  };
  function V() {
    return {
      title: "",
      description: ""
    };
  }
  e.CancelSoftwareUpgradeProposal = {
    encode(B, U = b.Writer.create()) {
      return B.title !== "" && U.uint32(10).string(B.title), B.description !== "" && U.uint32(18).string(B.description), U;
    },
    decode(B, U) {
      const C = B instanceof b.Reader ? B : new b.Reader(B);
      let l = U === void 0 ? C.len : C.pos + U;
      const S = V();
      for (; C.pos < l; ) {
        const A = C.uint32();
        switch (A >>> 3) {
          case 1:
            S.title = C.string();
            break;
          case 2:
            S.description = C.string();
            break;
          default:
            C.skipType(A & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(B) {
      return {
        title: (0, f.isSet)(B.title) ? String(B.title) : "",
        description: (0, f.isSet)(B.description) ? String(B.description) : ""
      };
    },
    toJSON(B) {
      const U = {};
      return B.title !== void 0 && (U.title = B.title), B.description !== void 0 && (U.description = B.description), U;
    },
    fromPartial(B) {
      const U = V();
      return U.title = B.title ?? "", U.description = B.description ?? "", U;
    }
  };
  function D() {
    return {
      name: "",
      version: f.Long.UZERO
    };
  }
  e.ModuleVersion = {
    encode(B, U = b.Writer.create()) {
      return B.name !== "" && U.uint32(10).string(B.name), B.version.isZero() || U.uint32(16).uint64(B.version), U;
    },
    decode(B, U) {
      const C = B instanceof b.Reader ? B : new b.Reader(B);
      let l = U === void 0 ? C.len : C.pos + U;
      const S = D();
      for (; C.pos < l; ) {
        const A = C.uint32();
        switch (A >>> 3) {
          case 1:
            S.name = C.string();
            break;
          case 2:
            S.version = C.uint64();
            break;
          default:
            C.skipType(A & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(B) {
      return {
        name: (0, f.isSet)(B.name) ? String(B.name) : "",
        version: (0, f.isSet)(B.version) ? f.Long.fromValue(B.version) : f.Long.UZERO
      };
    },
    toJSON(B) {
      const U = {};
      return B.name !== void 0 && (U.name = B.name), B.version !== void 0 && (U.version = (B.version || f.Long.UZERO).toString()), U;
    },
    fromPartial(B) {
      const U = D();
      return U.name = B.name ?? "", U.version = B.version !== void 0 && B.version !== null ? f.Long.fromValue(B.version) : f.Long.UZERO, U;
    }
  };
})(Rc);
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(l, S, A, d) {
    d === void 0 && (d = A);
    var p = Object.getOwnPropertyDescriptor(S, A);
    (!p || ("get" in p ? !S.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return S[A];
    } }), Object.defineProperty(l, d, p);
  } : function(l, S, A, d) {
    d === void 0 && (d = A), l[d] = S[A];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(l, S) {
    Object.defineProperty(l, "default", { enumerable: !0, value: S });
  } : function(l, S) {
    l.default = S;
  }), u = Q && Q.__importStar || function(l) {
    if (l && l.__esModule)
      return l;
    var S = {};
    if (l != null)
      for (var A in l)
        A !== "default" && Object.prototype.hasOwnProperty.call(l, A) && o(S, l, A);
    return t(S, l), S;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Params = e.Height = e.UpgradeProposal = e.ClientUpdateProposal = e.ClientConsensusStates = e.ConsensusStateWithHeight = e.IdentifiedClientState = e.protobufPackage = void 0;
  const r = ye, m = Rc, f = ie, b = u(re);
  e.protobufPackage = "ibc.core.client.v1";
  function R() {
    return {
      clientId: "",
      clientState: void 0
    };
  }
  e.IdentifiedClientState = {
    encode(l, S = b.Writer.create()) {
      return l.clientId !== "" && S.uint32(10).string(l.clientId), l.clientState !== void 0 && r.Any.encode(l.clientState, S.uint32(18).fork()).ldelim(), S;
    },
    decode(l, S) {
      const A = l instanceof b.Reader ? l : new b.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = R();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.clientId = A.string();
            break;
          case 2:
            p.clientState = r.Any.decode(A, A.uint32());
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        clientId: (0, f.isSet)(l.clientId) ? String(l.clientId) : "",
        clientState: (0, f.isSet)(l.clientState) ? r.Any.fromJSON(l.clientState) : void 0
      };
    },
    toJSON(l) {
      const S = {};
      return l.clientId !== void 0 && (S.clientId = l.clientId), l.clientState !== void 0 && (S.clientState = l.clientState ? r.Any.toJSON(l.clientState) : void 0), S;
    },
    fromPartial(l) {
      const S = R();
      return S.clientId = l.clientId ?? "", S.clientState = l.clientState !== void 0 && l.clientState !== null ? r.Any.fromPartial(l.clientState) : void 0, S;
    }
  };
  function T() {
    return {
      height: void 0,
      consensusState: void 0
    };
  }
  e.ConsensusStateWithHeight = {
    encode(l, S = b.Writer.create()) {
      return l.height !== void 0 && e.Height.encode(l.height, S.uint32(10).fork()).ldelim(), l.consensusState !== void 0 && r.Any.encode(l.consensusState, S.uint32(18).fork()).ldelim(), S;
    },
    decode(l, S) {
      const A = l instanceof b.Reader ? l : new b.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = T();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.height = e.Height.decode(A, A.uint32());
            break;
          case 2:
            p.consensusState = r.Any.decode(A, A.uint32());
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        height: (0, f.isSet)(l.height) ? e.Height.fromJSON(l.height) : void 0,
        consensusState: (0, f.isSet)(l.consensusState) ? r.Any.fromJSON(l.consensusState) : void 0
      };
    },
    toJSON(l) {
      const S = {};
      return l.height !== void 0 && (S.height = l.height ? e.Height.toJSON(l.height) : void 0), l.consensusState !== void 0 && (S.consensusState = l.consensusState ? r.Any.toJSON(l.consensusState) : void 0), S;
    },
    fromPartial(l) {
      const S = T();
      return S.height = l.height !== void 0 && l.height !== null ? e.Height.fromPartial(l.height) : void 0, S.consensusState = l.consensusState !== void 0 && l.consensusState !== null ? r.Any.fromPartial(l.consensusState) : void 0, S;
    }
  };
  function V() {
    return {
      clientId: "",
      consensusStates: []
    };
  }
  e.ClientConsensusStates = {
    encode(l, S = b.Writer.create()) {
      l.clientId !== "" && S.uint32(10).string(l.clientId);
      for (const A of l.consensusStates)
        e.ConsensusStateWithHeight.encode(A, S.uint32(18).fork()).ldelim();
      return S;
    },
    decode(l, S) {
      const A = l instanceof b.Reader ? l : new b.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = V();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.clientId = A.string();
            break;
          case 2:
            p.consensusStates.push(e.ConsensusStateWithHeight.decode(A, A.uint32()));
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        clientId: (0, f.isSet)(l.clientId) ? String(l.clientId) : "",
        consensusStates: Array.isArray(l == null ? void 0 : l.consensusStates) ? l.consensusStates.map((S) => e.ConsensusStateWithHeight.fromJSON(S)) : []
      };
    },
    toJSON(l) {
      const S = {};
      return l.clientId !== void 0 && (S.clientId = l.clientId), l.consensusStates ? S.consensusStates = l.consensusStates.map((A) => A ? e.ConsensusStateWithHeight.toJSON(A) : void 0) : S.consensusStates = [], S;
    },
    fromPartial(l) {
      var S;
      const A = V();
      return A.clientId = l.clientId ?? "", A.consensusStates = ((S = l.consensusStates) == null ? void 0 : S.map((d) => e.ConsensusStateWithHeight.fromPartial(d))) || [], A;
    }
  };
  function D() {
    return {
      title: "",
      description: "",
      subjectClientId: "",
      substituteClientId: ""
    };
  }
  e.ClientUpdateProposal = {
    encode(l, S = b.Writer.create()) {
      return l.title !== "" && S.uint32(10).string(l.title), l.description !== "" && S.uint32(18).string(l.description), l.subjectClientId !== "" && S.uint32(26).string(l.subjectClientId), l.substituteClientId !== "" && S.uint32(34).string(l.substituteClientId), S;
    },
    decode(l, S) {
      const A = l instanceof b.Reader ? l : new b.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = D();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.title = A.string();
            break;
          case 2:
            p.description = A.string();
            break;
          case 3:
            p.subjectClientId = A.string();
            break;
          case 4:
            p.substituteClientId = A.string();
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        title: (0, f.isSet)(l.title) ? String(l.title) : "",
        description: (0, f.isSet)(l.description) ? String(l.description) : "",
        subjectClientId: (0, f.isSet)(l.subjectClientId) ? String(l.subjectClientId) : "",
        substituteClientId: (0, f.isSet)(l.substituteClientId) ? String(l.substituteClientId) : ""
      };
    },
    toJSON(l) {
      const S = {};
      return l.title !== void 0 && (S.title = l.title), l.description !== void 0 && (S.description = l.description), l.subjectClientId !== void 0 && (S.subjectClientId = l.subjectClientId), l.substituteClientId !== void 0 && (S.substituteClientId = l.substituteClientId), S;
    },
    fromPartial(l) {
      const S = D();
      return S.title = l.title ?? "", S.description = l.description ?? "", S.subjectClientId = l.subjectClientId ?? "", S.substituteClientId = l.substituteClientId ?? "", S;
    }
  };
  function B() {
    return {
      title: "",
      description: "",
      plan: void 0,
      upgradedClientState: void 0
    };
  }
  e.UpgradeProposal = {
    encode(l, S = b.Writer.create()) {
      return l.title !== "" && S.uint32(10).string(l.title), l.description !== "" && S.uint32(18).string(l.description), l.plan !== void 0 && m.Plan.encode(l.plan, S.uint32(26).fork()).ldelim(), l.upgradedClientState !== void 0 && r.Any.encode(l.upgradedClientState, S.uint32(34).fork()).ldelim(), S;
    },
    decode(l, S) {
      const A = l instanceof b.Reader ? l : new b.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = B();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.title = A.string();
            break;
          case 2:
            p.description = A.string();
            break;
          case 3:
            p.plan = m.Plan.decode(A, A.uint32());
            break;
          case 4:
            p.upgradedClientState = r.Any.decode(A, A.uint32());
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        title: (0, f.isSet)(l.title) ? String(l.title) : "",
        description: (0, f.isSet)(l.description) ? String(l.description) : "",
        plan: (0, f.isSet)(l.plan) ? m.Plan.fromJSON(l.plan) : void 0,
        upgradedClientState: (0, f.isSet)(l.upgradedClientState) ? r.Any.fromJSON(l.upgradedClientState) : void 0
      };
    },
    toJSON(l) {
      const S = {};
      return l.title !== void 0 && (S.title = l.title), l.description !== void 0 && (S.description = l.description), l.plan !== void 0 && (S.plan = l.plan ? m.Plan.toJSON(l.plan) : void 0), l.upgradedClientState !== void 0 && (S.upgradedClientState = l.upgradedClientState ? r.Any.toJSON(l.upgradedClientState) : void 0), S;
    },
    fromPartial(l) {
      const S = B();
      return S.title = l.title ?? "", S.description = l.description ?? "", S.plan = l.plan !== void 0 && l.plan !== null ? m.Plan.fromPartial(l.plan) : void 0, S.upgradedClientState = l.upgradedClientState !== void 0 && l.upgradedClientState !== null ? r.Any.fromPartial(l.upgradedClientState) : void 0, S;
    }
  };
  function U() {
    return {
      revisionNumber: f.Long.UZERO,
      revisionHeight: f.Long.UZERO
    };
  }
  e.Height = {
    encode(l, S = b.Writer.create()) {
      return l.revisionNumber.isZero() || S.uint32(8).uint64(l.revisionNumber), l.revisionHeight.isZero() || S.uint32(16).uint64(l.revisionHeight), S;
    },
    decode(l, S) {
      const A = l instanceof b.Reader ? l : new b.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = U();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.revisionNumber = A.uint64();
            break;
          case 2:
            p.revisionHeight = A.uint64();
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        revisionNumber: (0, f.isSet)(l.revisionNumber) ? f.Long.fromValue(l.revisionNumber) : f.Long.UZERO,
        revisionHeight: (0, f.isSet)(l.revisionHeight) ? f.Long.fromValue(l.revisionHeight) : f.Long.UZERO
      };
    },
    toJSON(l) {
      const S = {};
      return l.revisionNumber !== void 0 && (S.revisionNumber = (l.revisionNumber || f.Long.UZERO).toString()), l.revisionHeight !== void 0 && (S.revisionHeight = (l.revisionHeight || f.Long.UZERO).toString()), S;
    },
    fromPartial(l) {
      const S = U();
      return S.revisionNumber = l.revisionNumber !== void 0 && l.revisionNumber !== null ? f.Long.fromValue(l.revisionNumber) : f.Long.UZERO, S.revisionHeight = l.revisionHeight !== void 0 && l.revisionHeight !== null ? f.Long.fromValue(l.revisionHeight) : f.Long.UZERO, S;
    }
  };
  function C() {
    return {
      allowedClients: []
    };
  }
  e.Params = {
    encode(l, S = b.Writer.create()) {
      for (const A of l.allowedClients)
        S.uint32(10).string(A);
      return S;
    },
    decode(l, S) {
      const A = l instanceof b.Reader ? l : new b.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = C();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.allowedClients.push(A.string());
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        allowedClients: Array.isArray(l == null ? void 0 : l.allowedClients) ? l.allowedClients.map((S) => String(S)) : []
      };
    },
    toJSON(l) {
      const S = {};
      return l.allowedClients ? S.allowedClients = l.allowedClients.map((A) => A) : S.allowedClients = [], S;
    },
    fromPartial(l) {
      var S;
      const A = C();
      return A.allowedClients = ((S = l.allowedClients) == null ? void 0 : S.map((d) => d)) || [], A;
    }
  };
})(Tt);
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(D, B, U, C) {
    C === void 0 && (C = U);
    var l = Object.getOwnPropertyDescriptor(B, U);
    (!l || ("get" in l ? !B.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
      return B[U];
    } }), Object.defineProperty(D, C, l);
  } : function(D, B, U, C) {
    C === void 0 && (C = U), D[C] = B[U];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(D, B) {
    Object.defineProperty(D, "default", { enumerable: !0, value: B });
  } : function(D, B) {
    D.default = B;
  }), u = Q && Q.__importStar || function(D) {
    if (D && D.__esModule)
      return D;
    var B = {};
    if (D != null)
      for (var U in D)
        U !== "default" && Object.prototype.hasOwnProperty.call(D, U) && o(B, D, U);
    return t(B, D), B;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgTransferResponse = e.MsgTransfer = e.protobufPackage = void 0;
  const r = Le, m = Tt, f = ie, b = u(re);
  e.protobufPackage = "ibc.applications.transfer.v1";
  function R() {
    return {
      sourcePort: "",
      sourceChannel: "",
      token: void 0,
      sender: "",
      receiver: "",
      timeoutHeight: void 0,
      timeoutTimestamp: f.Long.UZERO,
      memo: ""
    };
  }
  e.MsgTransfer = {
    encode(D, B = b.Writer.create()) {
      return D.sourcePort !== "" && B.uint32(10).string(D.sourcePort), D.sourceChannel !== "" && B.uint32(18).string(D.sourceChannel), D.token !== void 0 && r.Coin.encode(D.token, B.uint32(26).fork()).ldelim(), D.sender !== "" && B.uint32(34).string(D.sender), D.receiver !== "" && B.uint32(42).string(D.receiver), D.timeoutHeight !== void 0 && m.Height.encode(D.timeoutHeight, B.uint32(50).fork()).ldelim(), D.timeoutTimestamp.isZero() || B.uint32(56).uint64(D.timeoutTimestamp), D.memo !== "" && B.uint32(66).string(D.memo), B;
    },
    decode(D, B) {
      const U = D instanceof b.Reader ? D : new b.Reader(D);
      let C = B === void 0 ? U.len : U.pos + B;
      const l = R();
      for (; U.pos < C; ) {
        const S = U.uint32();
        switch (S >>> 3) {
          case 1:
            l.sourcePort = U.string();
            break;
          case 2:
            l.sourceChannel = U.string();
            break;
          case 3:
            l.token = r.Coin.decode(U, U.uint32());
            break;
          case 4:
            l.sender = U.string();
            break;
          case 5:
            l.receiver = U.string();
            break;
          case 6:
            l.timeoutHeight = m.Height.decode(U, U.uint32());
            break;
          case 7:
            l.timeoutTimestamp = U.uint64();
            break;
          case 8:
            l.memo = U.string();
            break;
          default:
            U.skipType(S & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(D) {
      return {
        sourcePort: (0, f.isSet)(D.sourcePort) ? String(D.sourcePort) : "",
        sourceChannel: (0, f.isSet)(D.sourceChannel) ? String(D.sourceChannel) : "",
        token: (0, f.isSet)(D.token) ? r.Coin.fromJSON(D.token) : void 0,
        sender: (0, f.isSet)(D.sender) ? String(D.sender) : "",
        receiver: (0, f.isSet)(D.receiver) ? String(D.receiver) : "",
        timeoutHeight: (0, f.isSet)(D.timeoutHeight) ? m.Height.fromJSON(D.timeoutHeight) : void 0,
        timeoutTimestamp: (0, f.isSet)(D.timeoutTimestamp) ? f.Long.fromValue(D.timeoutTimestamp) : f.Long.UZERO,
        memo: (0, f.isSet)(D.memo) ? String(D.memo) : ""
      };
    },
    toJSON(D) {
      const B = {};
      return D.sourcePort !== void 0 && (B.sourcePort = D.sourcePort), D.sourceChannel !== void 0 && (B.sourceChannel = D.sourceChannel), D.token !== void 0 && (B.token = D.token ? r.Coin.toJSON(D.token) : void 0), D.sender !== void 0 && (B.sender = D.sender), D.receiver !== void 0 && (B.receiver = D.receiver), D.timeoutHeight !== void 0 && (B.timeoutHeight = D.timeoutHeight ? m.Height.toJSON(D.timeoutHeight) : void 0), D.timeoutTimestamp !== void 0 && (B.timeoutTimestamp = (D.timeoutTimestamp || f.Long.UZERO).toString()), D.memo !== void 0 && (B.memo = D.memo), B;
    },
    fromPartial(D) {
      const B = R();
      return B.sourcePort = D.sourcePort ?? "", B.sourceChannel = D.sourceChannel ?? "", B.token = D.token !== void 0 && D.token !== null ? r.Coin.fromPartial(D.token) : void 0, B.sender = D.sender ?? "", B.receiver = D.receiver ?? "", B.timeoutHeight = D.timeoutHeight !== void 0 && D.timeoutHeight !== null ? m.Height.fromPartial(D.timeoutHeight) : void 0, B.timeoutTimestamp = D.timeoutTimestamp !== void 0 && D.timeoutTimestamp !== null ? f.Long.fromValue(D.timeoutTimestamp) : f.Long.UZERO, B.memo = D.memo ?? "", B;
    }
  };
  function T() {
    return {
      sequence: f.Long.UZERO
    };
  }
  e.MsgTransferResponse = {
    encode(D, B = b.Writer.create()) {
      return D.sequence.isZero() || B.uint32(8).uint64(D.sequence), B;
    },
    decode(D, B) {
      const U = D instanceof b.Reader ? D : new b.Reader(D);
      let C = B === void 0 ? U.len : U.pos + B;
      const l = T();
      for (; U.pos < C; ) {
        const S = U.uint32();
        switch (S >>> 3) {
          case 1:
            l.sequence = U.uint64();
            break;
          default:
            U.skipType(S & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(D) {
      return {
        sequence: (0, f.isSet)(D.sequence) ? f.Long.fromValue(D.sequence) : f.Long.UZERO
      };
    },
    toJSON(D) {
      const B = {};
      return D.sequence !== void 0 && (B.sequence = (D.sequence || f.Long.UZERO).toString()), B;
    },
    fromPartial(D) {
      const B = T();
      return B.sequence = D.sequence !== void 0 && D.sequence !== null ? f.Long.fromValue(D.sequence) : f.Long.UZERO, B;
    }
  };
  class V {
    constructor(B) {
      this.rpc = B, this.Transfer = this.Transfer.bind(this);
    }
    Transfer(B) {
      const U = e.MsgTransfer.encode(B).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Msg", "Transfer", U).then((C) => e.MsgTransferResponse.decode(new b.Reader(C)));
    }
  }
  e.MsgClientImpl = V;
})(ur);
var wm = Q && Q.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Cn, "__esModule", { value: !0 });
Cn.createIbcAminoConverters = Cn.isAminoMsgTransfer = void 0;
const Nm = ur, To = wm(Pt);
function Em(e) {
  return e.type === "cosmos-sdk/MsgTransfer";
}
Cn.isAminoMsgTransfer = Em;
function ti(e) {
  if (typeof e == "string")
    return e === "" ? void 0 : e;
  if (typeof e == "number")
    return e === 0 ? void 0 : e;
  if (To.default.isLong(e))
    return e.isZero() ? void 0 : e;
  throw new Error(`Got unsupported type '${typeof e}'`);
}
function Tm() {
  return {
    "/ibc.applications.transfer.v1.MsgTransfer": {
      aminoType: "cosmos-sdk/MsgTransfer",
      toAmino: ({ sourcePort: e, sourceChannel: o, token: t, sender: u, receiver: r, timeoutHeight: m, timeoutTimestamp: f }) => {
        var b, R, T;
        return {
          source_port: e,
          source_channel: o,
          token: t,
          sender: u,
          receiver: r,
          timeout_height: m ? {
            revision_height: (b = ti(m.revisionHeight)) == null ? void 0 : b.toString(),
            revision_number: (R = ti(m.revisionNumber)) == null ? void 0 : R.toString()
          } : {},
          timeout_timestamp: (T = ti(f)) == null ? void 0 : T.toString()
        };
      },
      fromAmino: ({ source_port: e, source_channel: o, token: t, sender: u, receiver: r, timeout_height: m, timeout_timestamp: f }) => Nm.MsgTransfer.fromPartial({
        sourcePort: e,
        sourceChannel: o,
        token: t,
        sender: u,
        receiver: r,
        timeoutHeight: m ? {
          revisionHeight: To.default.fromString(m.revision_height || "0", !0),
          revisionNumber: To.default.fromString(m.revision_number || "0", !0)
        } : void 0,
        timeoutTimestamp: To.default.fromString(f || "0", !0)
      })
    }
  };
}
Cn.createIbcAminoConverters = Tm;
var In = {}, Ac = {}, lr = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(h, x, _, I) {
    I === void 0 && (I = _);
    var W = Object.getOwnPropertyDescriptor(x, _);
    (!W || ("get" in W ? !x.__esModule : W.writable || W.configurable)) && (W = { enumerable: !0, get: function() {
      return x[_];
    } }), Object.defineProperty(h, I, W);
  } : function(h, x, _, I) {
    I === void 0 && (I = _), h[I] = x[_];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(h, x) {
    Object.defineProperty(h, "default", { enumerable: !0, value: x });
  } : function(h, x) {
    h.default = x;
  }), u = Q && Q.__importStar || function(h) {
    if (h && h.__esModule)
      return h;
    var x = {};
    if (h != null)
      for (var _ in h)
        _ !== "default" && Object.prototype.hasOwnProperty.call(h, _) && o(x, h, _);
    return t(x, h), x;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Acknowledgement = e.PacketId = e.PacketState = e.Packet = e.Counterparty = e.IdentifiedChannel = e.Channel = e.orderToJSON = e.orderFromJSON = e.Order = e.stateToJSON = e.stateFromJSON = e.State = e.protobufPackage = void 0;
  const r = Tt, m = ie, f = u(re);
  e.protobufPackage = "ibc.core.channel.v1";
  var b;
  (function(h) {
    h[h.STATE_UNINITIALIZED_UNSPECIFIED = 0] = "STATE_UNINITIALIZED_UNSPECIFIED", h[h.STATE_INIT = 1] = "STATE_INIT", h[h.STATE_TRYOPEN = 2] = "STATE_TRYOPEN", h[h.STATE_OPEN = 3] = "STATE_OPEN", h[h.STATE_CLOSED = 4] = "STATE_CLOSED", h[h.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(b = e.State || (e.State = {}));
  function R(h) {
    switch (h) {
      case 0:
      case "STATE_UNINITIALIZED_UNSPECIFIED":
        return b.STATE_UNINITIALIZED_UNSPECIFIED;
      case 1:
      case "STATE_INIT":
        return b.STATE_INIT;
      case 2:
      case "STATE_TRYOPEN":
        return b.STATE_TRYOPEN;
      case 3:
      case "STATE_OPEN":
        return b.STATE_OPEN;
      case 4:
      case "STATE_CLOSED":
        return b.STATE_CLOSED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return b.UNRECOGNIZED;
    }
  }
  e.stateFromJSON = R;
  function T(h) {
    switch (h) {
      case b.STATE_UNINITIALIZED_UNSPECIFIED:
        return "STATE_UNINITIALIZED_UNSPECIFIED";
      case b.STATE_INIT:
        return "STATE_INIT";
      case b.STATE_TRYOPEN:
        return "STATE_TRYOPEN";
      case b.STATE_OPEN:
        return "STATE_OPEN";
      case b.STATE_CLOSED:
        return "STATE_CLOSED";
      case b.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.stateToJSON = T;
  var V;
  (function(h) {
    h[h.ORDER_NONE_UNSPECIFIED = 0] = "ORDER_NONE_UNSPECIFIED", h[h.ORDER_UNORDERED = 1] = "ORDER_UNORDERED", h[h.ORDER_ORDERED = 2] = "ORDER_ORDERED", h[h.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(V = e.Order || (e.Order = {}));
  function D(h) {
    switch (h) {
      case 0:
      case "ORDER_NONE_UNSPECIFIED":
        return V.ORDER_NONE_UNSPECIFIED;
      case 1:
      case "ORDER_UNORDERED":
        return V.ORDER_UNORDERED;
      case 2:
      case "ORDER_ORDERED":
        return V.ORDER_ORDERED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return V.UNRECOGNIZED;
    }
  }
  e.orderFromJSON = D;
  function B(h) {
    switch (h) {
      case V.ORDER_NONE_UNSPECIFIED:
        return "ORDER_NONE_UNSPECIFIED";
      case V.ORDER_UNORDERED:
        return "ORDER_UNORDERED";
      case V.ORDER_ORDERED:
        return "ORDER_ORDERED";
      case V.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.orderToJSON = B;
  function U() {
    return {
      state: 0,
      ordering: 0,
      counterparty: void 0,
      connectionHops: [],
      version: ""
    };
  }
  e.Channel = {
    encode(h, x = f.Writer.create()) {
      h.state !== 0 && x.uint32(8).int32(h.state), h.ordering !== 0 && x.uint32(16).int32(h.ordering), h.counterparty !== void 0 && e.Counterparty.encode(h.counterparty, x.uint32(26).fork()).ldelim();
      for (const _ of h.connectionHops)
        x.uint32(34).string(_);
      return h.version !== "" && x.uint32(42).string(h.version), x;
    },
    decode(h, x) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let I = x === void 0 ? _.len : _.pos + x;
      const W = U();
      for (; _.pos < I; ) {
        const n = _.uint32();
        switch (n >>> 3) {
          case 1:
            W.state = _.int32();
            break;
          case 2:
            W.ordering = _.int32();
            break;
          case 3:
            W.counterparty = e.Counterparty.decode(_, _.uint32());
            break;
          case 4:
            W.connectionHops.push(_.string());
            break;
          case 5:
            W.version = _.string();
            break;
          default:
            _.skipType(n & 7);
            break;
        }
      }
      return W;
    },
    fromJSON(h) {
      return {
        state: (0, m.isSet)(h.state) ? R(h.state) : 0,
        ordering: (0, m.isSet)(h.ordering) ? D(h.ordering) : 0,
        counterparty: (0, m.isSet)(h.counterparty) ? e.Counterparty.fromJSON(h.counterparty) : void 0,
        connectionHops: Array.isArray(h == null ? void 0 : h.connectionHops) ? h.connectionHops.map((x) => String(x)) : [],
        version: (0, m.isSet)(h.version) ? String(h.version) : ""
      };
    },
    toJSON(h) {
      const x = {};
      return h.state !== void 0 && (x.state = T(h.state)), h.ordering !== void 0 && (x.ordering = B(h.ordering)), h.counterparty !== void 0 && (x.counterparty = h.counterparty ? e.Counterparty.toJSON(h.counterparty) : void 0), h.connectionHops ? x.connectionHops = h.connectionHops.map((_) => _) : x.connectionHops = [], h.version !== void 0 && (x.version = h.version), x;
    },
    fromPartial(h) {
      var x;
      const _ = U();
      return _.state = h.state ?? 0, _.ordering = h.ordering ?? 0, _.counterparty = h.counterparty !== void 0 && h.counterparty !== null ? e.Counterparty.fromPartial(h.counterparty) : void 0, _.connectionHops = ((x = h.connectionHops) == null ? void 0 : x.map((I) => I)) || [], _.version = h.version ?? "", _;
    }
  };
  function C() {
    return {
      state: 0,
      ordering: 0,
      counterparty: void 0,
      connectionHops: [],
      version: "",
      portId: "",
      channelId: ""
    };
  }
  e.IdentifiedChannel = {
    encode(h, x = f.Writer.create()) {
      h.state !== 0 && x.uint32(8).int32(h.state), h.ordering !== 0 && x.uint32(16).int32(h.ordering), h.counterparty !== void 0 && e.Counterparty.encode(h.counterparty, x.uint32(26).fork()).ldelim();
      for (const _ of h.connectionHops)
        x.uint32(34).string(_);
      return h.version !== "" && x.uint32(42).string(h.version), h.portId !== "" && x.uint32(50).string(h.portId), h.channelId !== "" && x.uint32(58).string(h.channelId), x;
    },
    decode(h, x) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let I = x === void 0 ? _.len : _.pos + x;
      const W = C();
      for (; _.pos < I; ) {
        const n = _.uint32();
        switch (n >>> 3) {
          case 1:
            W.state = _.int32();
            break;
          case 2:
            W.ordering = _.int32();
            break;
          case 3:
            W.counterparty = e.Counterparty.decode(_, _.uint32());
            break;
          case 4:
            W.connectionHops.push(_.string());
            break;
          case 5:
            W.version = _.string();
            break;
          case 6:
            W.portId = _.string();
            break;
          case 7:
            W.channelId = _.string();
            break;
          default:
            _.skipType(n & 7);
            break;
        }
      }
      return W;
    },
    fromJSON(h) {
      return {
        state: (0, m.isSet)(h.state) ? R(h.state) : 0,
        ordering: (0, m.isSet)(h.ordering) ? D(h.ordering) : 0,
        counterparty: (0, m.isSet)(h.counterparty) ? e.Counterparty.fromJSON(h.counterparty) : void 0,
        connectionHops: Array.isArray(h == null ? void 0 : h.connectionHops) ? h.connectionHops.map((x) => String(x)) : [],
        version: (0, m.isSet)(h.version) ? String(h.version) : "",
        portId: (0, m.isSet)(h.portId) ? String(h.portId) : "",
        channelId: (0, m.isSet)(h.channelId) ? String(h.channelId) : ""
      };
    },
    toJSON(h) {
      const x = {};
      return h.state !== void 0 && (x.state = T(h.state)), h.ordering !== void 0 && (x.ordering = B(h.ordering)), h.counterparty !== void 0 && (x.counterparty = h.counterparty ? e.Counterparty.toJSON(h.counterparty) : void 0), h.connectionHops ? x.connectionHops = h.connectionHops.map((_) => _) : x.connectionHops = [], h.version !== void 0 && (x.version = h.version), h.portId !== void 0 && (x.portId = h.portId), h.channelId !== void 0 && (x.channelId = h.channelId), x;
    },
    fromPartial(h) {
      var x;
      const _ = C();
      return _.state = h.state ?? 0, _.ordering = h.ordering ?? 0, _.counterparty = h.counterparty !== void 0 && h.counterparty !== null ? e.Counterparty.fromPartial(h.counterparty) : void 0, _.connectionHops = ((x = h.connectionHops) == null ? void 0 : x.map((I) => I)) || [], _.version = h.version ?? "", _.portId = h.portId ?? "", _.channelId = h.channelId ?? "", _;
    }
  };
  function l() {
    return {
      portId: "",
      channelId: ""
    };
  }
  e.Counterparty = {
    encode(h, x = f.Writer.create()) {
      return h.portId !== "" && x.uint32(10).string(h.portId), h.channelId !== "" && x.uint32(18).string(h.channelId), x;
    },
    decode(h, x) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let I = x === void 0 ? _.len : _.pos + x;
      const W = l();
      for (; _.pos < I; ) {
        const n = _.uint32();
        switch (n >>> 3) {
          case 1:
            W.portId = _.string();
            break;
          case 2:
            W.channelId = _.string();
            break;
          default:
            _.skipType(n & 7);
            break;
        }
      }
      return W;
    },
    fromJSON(h) {
      return {
        portId: (0, m.isSet)(h.portId) ? String(h.portId) : "",
        channelId: (0, m.isSet)(h.channelId) ? String(h.channelId) : ""
      };
    },
    toJSON(h) {
      const x = {};
      return h.portId !== void 0 && (x.portId = h.portId), h.channelId !== void 0 && (x.channelId = h.channelId), x;
    },
    fromPartial(h) {
      const x = l();
      return x.portId = h.portId ?? "", x.channelId = h.channelId ?? "", x;
    }
  };
  function S() {
    return {
      sequence: m.Long.UZERO,
      sourcePort: "",
      sourceChannel: "",
      destinationPort: "",
      destinationChannel: "",
      data: new Uint8Array(),
      timeoutHeight: void 0,
      timeoutTimestamp: m.Long.UZERO
    };
  }
  e.Packet = {
    encode(h, x = f.Writer.create()) {
      return h.sequence.isZero() || x.uint32(8).uint64(h.sequence), h.sourcePort !== "" && x.uint32(18).string(h.sourcePort), h.sourceChannel !== "" && x.uint32(26).string(h.sourceChannel), h.destinationPort !== "" && x.uint32(34).string(h.destinationPort), h.destinationChannel !== "" && x.uint32(42).string(h.destinationChannel), h.data.length !== 0 && x.uint32(50).bytes(h.data), h.timeoutHeight !== void 0 && r.Height.encode(h.timeoutHeight, x.uint32(58).fork()).ldelim(), h.timeoutTimestamp.isZero() || x.uint32(64).uint64(h.timeoutTimestamp), x;
    },
    decode(h, x) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let I = x === void 0 ? _.len : _.pos + x;
      const W = S();
      for (; _.pos < I; ) {
        const n = _.uint32();
        switch (n >>> 3) {
          case 1:
            W.sequence = _.uint64();
            break;
          case 2:
            W.sourcePort = _.string();
            break;
          case 3:
            W.sourceChannel = _.string();
            break;
          case 4:
            W.destinationPort = _.string();
            break;
          case 5:
            W.destinationChannel = _.string();
            break;
          case 6:
            W.data = _.bytes();
            break;
          case 7:
            W.timeoutHeight = r.Height.decode(_, _.uint32());
            break;
          case 8:
            W.timeoutTimestamp = _.uint64();
            break;
          default:
            _.skipType(n & 7);
            break;
        }
      }
      return W;
    },
    fromJSON(h) {
      return {
        sequence: (0, m.isSet)(h.sequence) ? m.Long.fromValue(h.sequence) : m.Long.UZERO,
        sourcePort: (0, m.isSet)(h.sourcePort) ? String(h.sourcePort) : "",
        sourceChannel: (0, m.isSet)(h.sourceChannel) ? String(h.sourceChannel) : "",
        destinationPort: (0, m.isSet)(h.destinationPort) ? String(h.destinationPort) : "",
        destinationChannel: (0, m.isSet)(h.destinationChannel) ? String(h.destinationChannel) : "",
        data: (0, m.isSet)(h.data) ? (0, m.bytesFromBase64)(h.data) : new Uint8Array(),
        timeoutHeight: (0, m.isSet)(h.timeoutHeight) ? r.Height.fromJSON(h.timeoutHeight) : void 0,
        timeoutTimestamp: (0, m.isSet)(h.timeoutTimestamp) ? m.Long.fromValue(h.timeoutTimestamp) : m.Long.UZERO
      };
    },
    toJSON(h) {
      const x = {};
      return h.sequence !== void 0 && (x.sequence = (h.sequence || m.Long.UZERO).toString()), h.sourcePort !== void 0 && (x.sourcePort = h.sourcePort), h.sourceChannel !== void 0 && (x.sourceChannel = h.sourceChannel), h.destinationPort !== void 0 && (x.destinationPort = h.destinationPort), h.destinationChannel !== void 0 && (x.destinationChannel = h.destinationChannel), h.data !== void 0 && (x.data = (0, m.base64FromBytes)(h.data !== void 0 ? h.data : new Uint8Array())), h.timeoutHeight !== void 0 && (x.timeoutHeight = h.timeoutHeight ? r.Height.toJSON(h.timeoutHeight) : void 0), h.timeoutTimestamp !== void 0 && (x.timeoutTimestamp = (h.timeoutTimestamp || m.Long.UZERO).toString()), x;
    },
    fromPartial(h) {
      const x = S();
      return x.sequence = h.sequence !== void 0 && h.sequence !== null ? m.Long.fromValue(h.sequence) : m.Long.UZERO, x.sourcePort = h.sourcePort ?? "", x.sourceChannel = h.sourceChannel ?? "", x.destinationPort = h.destinationPort ?? "", x.destinationChannel = h.destinationChannel ?? "", x.data = h.data ?? new Uint8Array(), x.timeoutHeight = h.timeoutHeight !== void 0 && h.timeoutHeight !== null ? r.Height.fromPartial(h.timeoutHeight) : void 0, x.timeoutTimestamp = h.timeoutTimestamp !== void 0 && h.timeoutTimestamp !== null ? m.Long.fromValue(h.timeoutTimestamp) : m.Long.UZERO, x;
    }
  };
  function A() {
    return {
      portId: "",
      channelId: "",
      sequence: m.Long.UZERO,
      data: new Uint8Array()
    };
  }
  e.PacketState = {
    encode(h, x = f.Writer.create()) {
      return h.portId !== "" && x.uint32(10).string(h.portId), h.channelId !== "" && x.uint32(18).string(h.channelId), h.sequence.isZero() || x.uint32(24).uint64(h.sequence), h.data.length !== 0 && x.uint32(34).bytes(h.data), x;
    },
    decode(h, x) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let I = x === void 0 ? _.len : _.pos + x;
      const W = A();
      for (; _.pos < I; ) {
        const n = _.uint32();
        switch (n >>> 3) {
          case 1:
            W.portId = _.string();
            break;
          case 2:
            W.channelId = _.string();
            break;
          case 3:
            W.sequence = _.uint64();
            break;
          case 4:
            W.data = _.bytes();
            break;
          default:
            _.skipType(n & 7);
            break;
        }
      }
      return W;
    },
    fromJSON(h) {
      return {
        portId: (0, m.isSet)(h.portId) ? String(h.portId) : "",
        channelId: (0, m.isSet)(h.channelId) ? String(h.channelId) : "",
        sequence: (0, m.isSet)(h.sequence) ? m.Long.fromValue(h.sequence) : m.Long.UZERO,
        data: (0, m.isSet)(h.data) ? (0, m.bytesFromBase64)(h.data) : new Uint8Array()
      };
    },
    toJSON(h) {
      const x = {};
      return h.portId !== void 0 && (x.portId = h.portId), h.channelId !== void 0 && (x.channelId = h.channelId), h.sequence !== void 0 && (x.sequence = (h.sequence || m.Long.UZERO).toString()), h.data !== void 0 && (x.data = (0, m.base64FromBytes)(h.data !== void 0 ? h.data : new Uint8Array())), x;
    },
    fromPartial(h) {
      const x = A();
      return x.portId = h.portId ?? "", x.channelId = h.channelId ?? "", x.sequence = h.sequence !== void 0 && h.sequence !== null ? m.Long.fromValue(h.sequence) : m.Long.UZERO, x.data = h.data ?? new Uint8Array(), x;
    }
  };
  function d() {
    return {
      portId: "",
      channelId: "",
      sequence: m.Long.UZERO
    };
  }
  e.PacketId = {
    encode(h, x = f.Writer.create()) {
      return h.portId !== "" && x.uint32(10).string(h.portId), h.channelId !== "" && x.uint32(18).string(h.channelId), h.sequence.isZero() || x.uint32(24).uint64(h.sequence), x;
    },
    decode(h, x) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let I = x === void 0 ? _.len : _.pos + x;
      const W = d();
      for (; _.pos < I; ) {
        const n = _.uint32();
        switch (n >>> 3) {
          case 1:
            W.portId = _.string();
            break;
          case 2:
            W.channelId = _.string();
            break;
          case 3:
            W.sequence = _.uint64();
            break;
          default:
            _.skipType(n & 7);
            break;
        }
      }
      return W;
    },
    fromJSON(h) {
      return {
        portId: (0, m.isSet)(h.portId) ? String(h.portId) : "",
        channelId: (0, m.isSet)(h.channelId) ? String(h.channelId) : "",
        sequence: (0, m.isSet)(h.sequence) ? m.Long.fromValue(h.sequence) : m.Long.UZERO
      };
    },
    toJSON(h) {
      const x = {};
      return h.portId !== void 0 && (x.portId = h.portId), h.channelId !== void 0 && (x.channelId = h.channelId), h.sequence !== void 0 && (x.sequence = (h.sequence || m.Long.UZERO).toString()), x;
    },
    fromPartial(h) {
      const x = d();
      return x.portId = h.portId ?? "", x.channelId = h.channelId ?? "", x.sequence = h.sequence !== void 0 && h.sequence !== null ? m.Long.fromValue(h.sequence) : m.Long.UZERO, x;
    }
  };
  function p() {
    return {
      result: void 0,
      error: void 0
    };
  }
  e.Acknowledgement = {
    encode(h, x = f.Writer.create()) {
      return h.result !== void 0 && x.uint32(170).bytes(h.result), h.error !== void 0 && x.uint32(178).string(h.error), x;
    },
    decode(h, x) {
      const _ = h instanceof f.Reader ? h : new f.Reader(h);
      let I = x === void 0 ? _.len : _.pos + x;
      const W = p();
      for (; _.pos < I; ) {
        const n = _.uint32();
        switch (n >>> 3) {
          case 21:
            W.result = _.bytes();
            break;
          case 22:
            W.error = _.string();
            break;
          default:
            _.skipType(n & 7);
            break;
        }
      }
      return W;
    },
    fromJSON(h) {
      return {
        result: (0, m.isSet)(h.result) ? (0, m.bytesFromBase64)(h.result) : void 0,
        error: (0, m.isSet)(h.error) ? String(h.error) : void 0
      };
    },
    toJSON(h) {
      const x = {};
      return h.result !== void 0 && (x.result = h.result !== void 0 ? (0, m.base64FromBytes)(h.result) : void 0), h.error !== void 0 && (x.error = h.error), x;
    },
    fromPartial(h) {
      const x = p();
      return x.result = h.result ?? void 0, x.error = h.error ?? void 0, x;
    }
  };
})(lr);
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(k, O, L, Z) {
    Z === void 0 && (Z = L);
    var j = Object.getOwnPropertyDescriptor(O, L);
    (!j || ("get" in j ? !O.__esModule : j.writable || j.configurable)) && (j = { enumerable: !0, get: function() {
      return O[L];
    } }), Object.defineProperty(k, Z, j);
  } : function(k, O, L, Z) {
    Z === void 0 && (Z = L), k[Z] = O[L];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(k, O) {
    Object.defineProperty(k, "default", { enumerable: !0, value: O });
  } : function(k, O) {
    k.default = O;
  }), u = Q && Q.__importStar || function(k) {
    if (k && k.__esModule)
      return k;
    var O = {};
    if (k != null)
      for (var L in k)
        L !== "default" && Object.prototype.hasOwnProperty.call(k, L) && o(O, k, L);
    return t(O, k), O;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgAcknowledgementResponse = e.MsgAcknowledgement = e.MsgTimeoutOnCloseResponse = e.MsgTimeoutOnClose = e.MsgTimeoutResponse = e.MsgTimeout = e.MsgRecvPacketResponse = e.MsgRecvPacket = e.MsgChannelCloseConfirmResponse = e.MsgChannelCloseConfirm = e.MsgChannelCloseInitResponse = e.MsgChannelCloseInit = e.MsgChannelOpenConfirmResponse = e.MsgChannelOpenConfirm = e.MsgChannelOpenAckResponse = e.MsgChannelOpenAck = e.MsgChannelOpenTryResponse = e.MsgChannelOpenTry = e.MsgChannelOpenInitResponse = e.MsgChannelOpenInit = e.responseResultTypeToJSON = e.responseResultTypeFromJSON = e.ResponseResultType = e.protobufPackage = void 0;
  const r = lr, m = Tt, f = ie, b = u(re);
  e.protobufPackage = "ibc.core.channel.v1";
  var R;
  (function(k) {
    k[k.RESPONSE_RESULT_TYPE_UNSPECIFIED = 0] = "RESPONSE_RESULT_TYPE_UNSPECIFIED", k[k.RESPONSE_RESULT_TYPE_NOOP = 1] = "RESPONSE_RESULT_TYPE_NOOP", k[k.RESPONSE_RESULT_TYPE_SUCCESS = 2] = "RESPONSE_RESULT_TYPE_SUCCESS", k[k.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(R = e.ResponseResultType || (e.ResponseResultType = {}));
  function T(k) {
    switch (k) {
      case 0:
      case "RESPONSE_RESULT_TYPE_UNSPECIFIED":
        return R.RESPONSE_RESULT_TYPE_UNSPECIFIED;
      case 1:
      case "RESPONSE_RESULT_TYPE_NOOP":
        return R.RESPONSE_RESULT_TYPE_NOOP;
      case 2:
      case "RESPONSE_RESULT_TYPE_SUCCESS":
        return R.RESPONSE_RESULT_TYPE_SUCCESS;
      case -1:
      case "UNRECOGNIZED":
      default:
        return R.UNRECOGNIZED;
    }
  }
  e.responseResultTypeFromJSON = T;
  function V(k) {
    switch (k) {
      case R.RESPONSE_RESULT_TYPE_UNSPECIFIED:
        return "RESPONSE_RESULT_TYPE_UNSPECIFIED";
      case R.RESPONSE_RESULT_TYPE_NOOP:
        return "RESPONSE_RESULT_TYPE_NOOP";
      case R.RESPONSE_RESULT_TYPE_SUCCESS:
        return "RESPONSE_RESULT_TYPE_SUCCESS";
      case R.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.responseResultTypeToJSON = V;
  function D() {
    return {
      portId: "",
      channel: void 0,
      signer: ""
    };
  }
  e.MsgChannelOpenInit = {
    encode(k, O = b.Writer.create()) {
      return k.portId !== "" && O.uint32(10).string(k.portId), k.channel !== void 0 && r.Channel.encode(k.channel, O.uint32(18).fork()).ldelim(), k.signer !== "" && O.uint32(26).string(k.signer), O;
    },
    decode(k, O) {
      const L = k instanceof b.Reader ? k : new b.Reader(k);
      let Z = O === void 0 ? L.len : L.pos + O;
      const j = D();
      for (; L.pos < Z; ) {
        const i = L.uint32();
        switch (i >>> 3) {
          case 1:
            j.portId = L.string();
            break;
          case 2:
            j.channel = r.Channel.decode(L, L.uint32());
            break;
          case 3:
            j.signer = L.string();
            break;
          default:
            L.skipType(i & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(k) {
      return {
        portId: (0, f.isSet)(k.portId) ? String(k.portId) : "",
        channel: (0, f.isSet)(k.channel) ? r.Channel.fromJSON(k.channel) : void 0,
        signer: (0, f.isSet)(k.signer) ? String(k.signer) : ""
      };
    },
    toJSON(k) {
      const O = {};
      return k.portId !== void 0 && (O.portId = k.portId), k.channel !== void 0 && (O.channel = k.channel ? r.Channel.toJSON(k.channel) : void 0), k.signer !== void 0 && (O.signer = k.signer), O;
    },
    fromPartial(k) {
      const O = D();
      return O.portId = k.portId ?? "", O.channel = k.channel !== void 0 && k.channel !== null ? r.Channel.fromPartial(k.channel) : void 0, O.signer = k.signer ?? "", O;
    }
  };
  function B() {
    return {
      channelId: "",
      version: ""
    };
  }
  e.MsgChannelOpenInitResponse = {
    encode(k, O = b.Writer.create()) {
      return k.channelId !== "" && O.uint32(10).string(k.channelId), k.version !== "" && O.uint32(18).string(k.version), O;
    },
    decode(k, O) {
      const L = k instanceof b.Reader ? k : new b.Reader(k);
      let Z = O === void 0 ? L.len : L.pos + O;
      const j = B();
      for (; L.pos < Z; ) {
        const i = L.uint32();
        switch (i >>> 3) {
          case 1:
            j.channelId = L.string();
            break;
          case 2:
            j.version = L.string();
            break;
          default:
            L.skipType(i & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(k) {
      return {
        channelId: (0, f.isSet)(k.channelId) ? String(k.channelId) : "",
        version: (0, f.isSet)(k.version) ? String(k.version) : ""
      };
    },
    toJSON(k) {
      const O = {};
      return k.channelId !== void 0 && (O.channelId = k.channelId), k.version !== void 0 && (O.version = k.version), O;
    },
    fromPartial(k) {
      const O = B();
      return O.channelId = k.channelId ?? "", O.version = k.version ?? "", O;
    }
  };
  function U() {
    return {
      portId: "",
      previousChannelId: "",
      channel: void 0,
      counterpartyVersion: "",
      proofInit: new Uint8Array(),
      proofHeight: void 0,
      signer: ""
    };
  }
  e.MsgChannelOpenTry = {
    encode(k, O = b.Writer.create()) {
      return k.portId !== "" && O.uint32(10).string(k.portId), k.previousChannelId !== "" && O.uint32(18).string(k.previousChannelId), k.channel !== void 0 && r.Channel.encode(k.channel, O.uint32(26).fork()).ldelim(), k.counterpartyVersion !== "" && O.uint32(34).string(k.counterpartyVersion), k.proofInit.length !== 0 && O.uint32(42).bytes(k.proofInit), k.proofHeight !== void 0 && m.Height.encode(k.proofHeight, O.uint32(50).fork()).ldelim(), k.signer !== "" && O.uint32(58).string(k.signer), O;
    },
    decode(k, O) {
      const L = k instanceof b.Reader ? k : new b.Reader(k);
      let Z = O === void 0 ? L.len : L.pos + O;
      const j = U();
      for (; L.pos < Z; ) {
        const i = L.uint32();
        switch (i >>> 3) {
          case 1:
            j.portId = L.string();
            break;
          case 2:
            j.previousChannelId = L.string();
            break;
          case 3:
            j.channel = r.Channel.decode(L, L.uint32());
            break;
          case 4:
            j.counterpartyVersion = L.string();
            break;
          case 5:
            j.proofInit = L.bytes();
            break;
          case 6:
            j.proofHeight = m.Height.decode(L, L.uint32());
            break;
          case 7:
            j.signer = L.string();
            break;
          default:
            L.skipType(i & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(k) {
      return {
        portId: (0, f.isSet)(k.portId) ? String(k.portId) : "",
        previousChannelId: (0, f.isSet)(k.previousChannelId) ? String(k.previousChannelId) : "",
        channel: (0, f.isSet)(k.channel) ? r.Channel.fromJSON(k.channel) : void 0,
        counterpartyVersion: (0, f.isSet)(k.counterpartyVersion) ? String(k.counterpartyVersion) : "",
        proofInit: (0, f.isSet)(k.proofInit) ? (0, f.bytesFromBase64)(k.proofInit) : new Uint8Array(),
        proofHeight: (0, f.isSet)(k.proofHeight) ? m.Height.fromJSON(k.proofHeight) : void 0,
        signer: (0, f.isSet)(k.signer) ? String(k.signer) : ""
      };
    },
    toJSON(k) {
      const O = {};
      return k.portId !== void 0 && (O.portId = k.portId), k.previousChannelId !== void 0 && (O.previousChannelId = k.previousChannelId), k.channel !== void 0 && (O.channel = k.channel ? r.Channel.toJSON(k.channel) : void 0), k.counterpartyVersion !== void 0 && (O.counterpartyVersion = k.counterpartyVersion), k.proofInit !== void 0 && (O.proofInit = (0, f.base64FromBytes)(k.proofInit !== void 0 ? k.proofInit : new Uint8Array())), k.proofHeight !== void 0 && (O.proofHeight = k.proofHeight ? m.Height.toJSON(k.proofHeight) : void 0), k.signer !== void 0 && (O.signer = k.signer), O;
    },
    fromPartial(k) {
      const O = U();
      return O.portId = k.portId ?? "", O.previousChannelId = k.previousChannelId ?? "", O.channel = k.channel !== void 0 && k.channel !== null ? r.Channel.fromPartial(k.channel) : void 0, O.counterpartyVersion = k.counterpartyVersion ?? "", O.proofInit = k.proofInit ?? new Uint8Array(), O.proofHeight = k.proofHeight !== void 0 && k.proofHeight !== null ? m.Height.fromPartial(k.proofHeight) : void 0, O.signer = k.signer ?? "", O;
    }
  };
  function C() {
    return {
      version: ""
    };
  }
  e.MsgChannelOpenTryResponse = {
    encode(k, O = b.Writer.create()) {
      return k.version !== "" && O.uint32(10).string(k.version), O;
    },
    decode(k, O) {
      const L = k instanceof b.Reader ? k : new b.Reader(k);
      let Z = O === void 0 ? L.len : L.pos + O;
      const j = C();
      for (; L.pos < Z; ) {
        const i = L.uint32();
        switch (i >>> 3) {
          case 1:
            j.version = L.string();
            break;
          default:
            L.skipType(i & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(k) {
      return {
        version: (0, f.isSet)(k.version) ? String(k.version) : ""
      };
    },
    toJSON(k) {
      const O = {};
      return k.version !== void 0 && (O.version = k.version), O;
    },
    fromPartial(k) {
      const O = C();
      return O.version = k.version ?? "", O;
    }
  };
  function l() {
    return {
      portId: "",
      channelId: "",
      counterpartyChannelId: "",
      counterpartyVersion: "",
      proofTry: new Uint8Array(),
      proofHeight: void 0,
      signer: ""
    };
  }
  e.MsgChannelOpenAck = {
    encode(k, O = b.Writer.create()) {
      return k.portId !== "" && O.uint32(10).string(k.portId), k.channelId !== "" && O.uint32(18).string(k.channelId), k.counterpartyChannelId !== "" && O.uint32(26).string(k.counterpartyChannelId), k.counterpartyVersion !== "" && O.uint32(34).string(k.counterpartyVersion), k.proofTry.length !== 0 && O.uint32(42).bytes(k.proofTry), k.proofHeight !== void 0 && m.Height.encode(k.proofHeight, O.uint32(50).fork()).ldelim(), k.signer !== "" && O.uint32(58).string(k.signer), O;
    },
    decode(k, O) {
      const L = k instanceof b.Reader ? k : new b.Reader(k);
      let Z = O === void 0 ? L.len : L.pos + O;
      const j = l();
      for (; L.pos < Z; ) {
        const i = L.uint32();
        switch (i >>> 3) {
          case 1:
            j.portId = L.string();
            break;
          case 2:
            j.channelId = L.string();
            break;
          case 3:
            j.counterpartyChannelId = L.string();
            break;
          case 4:
            j.counterpartyVersion = L.string();
            break;
          case 5:
            j.proofTry = L.bytes();
            break;
          case 6:
            j.proofHeight = m.Height.decode(L, L.uint32());
            break;
          case 7:
            j.signer = L.string();
            break;
          default:
            L.skipType(i & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(k) {
      return {
        portId: (0, f.isSet)(k.portId) ? String(k.portId) : "",
        channelId: (0, f.isSet)(k.channelId) ? String(k.channelId) : "",
        counterpartyChannelId: (0, f.isSet)(k.counterpartyChannelId) ? String(k.counterpartyChannelId) : "",
        counterpartyVersion: (0, f.isSet)(k.counterpartyVersion) ? String(k.counterpartyVersion) : "",
        proofTry: (0, f.isSet)(k.proofTry) ? (0, f.bytesFromBase64)(k.proofTry) : new Uint8Array(),
        proofHeight: (0, f.isSet)(k.proofHeight) ? m.Height.fromJSON(k.proofHeight) : void 0,
        signer: (0, f.isSet)(k.signer) ? String(k.signer) : ""
      };
    },
    toJSON(k) {
      const O = {};
      return k.portId !== void 0 && (O.portId = k.portId), k.channelId !== void 0 && (O.channelId = k.channelId), k.counterpartyChannelId !== void 0 && (O.counterpartyChannelId = k.counterpartyChannelId), k.counterpartyVersion !== void 0 && (O.counterpartyVersion = k.counterpartyVersion), k.proofTry !== void 0 && (O.proofTry = (0, f.base64FromBytes)(k.proofTry !== void 0 ? k.proofTry : new Uint8Array())), k.proofHeight !== void 0 && (O.proofHeight = k.proofHeight ? m.Height.toJSON(k.proofHeight) : void 0), k.signer !== void 0 && (O.signer = k.signer), O;
    },
    fromPartial(k) {
      const O = l();
      return O.portId = k.portId ?? "", O.channelId = k.channelId ?? "", O.counterpartyChannelId = k.counterpartyChannelId ?? "", O.counterpartyVersion = k.counterpartyVersion ?? "", O.proofTry = k.proofTry ?? new Uint8Array(), O.proofHeight = k.proofHeight !== void 0 && k.proofHeight !== null ? m.Height.fromPartial(k.proofHeight) : void 0, O.signer = k.signer ?? "", O;
    }
  };
  function S() {
    return {};
  }
  e.MsgChannelOpenAckResponse = {
    encode(k, O = b.Writer.create()) {
      return O;
    },
    decode(k, O) {
      const L = k instanceof b.Reader ? k : new b.Reader(k);
      let Z = O === void 0 ? L.len : L.pos + O;
      const j = S();
      for (; L.pos < Z; ) {
        const i = L.uint32();
        switch (i >>> 3) {
          default:
            L.skipType(i & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(k) {
      return {};
    },
    toJSON(k) {
      return {};
    },
    fromPartial(k) {
      return S();
    }
  };
  function A() {
    return {
      portId: "",
      channelId: "",
      proofAck: new Uint8Array(),
      proofHeight: void 0,
      signer: ""
    };
  }
  e.MsgChannelOpenConfirm = {
    encode(k, O = b.Writer.create()) {
      return k.portId !== "" && O.uint32(10).string(k.portId), k.channelId !== "" && O.uint32(18).string(k.channelId), k.proofAck.length !== 0 && O.uint32(26).bytes(k.proofAck), k.proofHeight !== void 0 && m.Height.encode(k.proofHeight, O.uint32(34).fork()).ldelim(), k.signer !== "" && O.uint32(42).string(k.signer), O;
    },
    decode(k, O) {
      const L = k instanceof b.Reader ? k : new b.Reader(k);
      let Z = O === void 0 ? L.len : L.pos + O;
      const j = A();
      for (; L.pos < Z; ) {
        const i = L.uint32();
        switch (i >>> 3) {
          case 1:
            j.portId = L.string();
            break;
          case 2:
            j.channelId = L.string();
            break;
          case 3:
            j.proofAck = L.bytes();
            break;
          case 4:
            j.proofHeight = m.Height.decode(L, L.uint32());
            break;
          case 5:
            j.signer = L.string();
            break;
          default:
            L.skipType(i & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(k) {
      return {
        portId: (0, f.isSet)(k.portId) ? String(k.portId) : "",
        channelId: (0, f.isSet)(k.channelId) ? String(k.channelId) : "",
        proofAck: (0, f.isSet)(k.proofAck) ? (0, f.bytesFromBase64)(k.proofAck) : new Uint8Array(),
        proofHeight: (0, f.isSet)(k.proofHeight) ? m.Height.fromJSON(k.proofHeight) : void 0,
        signer: (0, f.isSet)(k.signer) ? String(k.signer) : ""
      };
    },
    toJSON(k) {
      const O = {};
      return k.portId !== void 0 && (O.portId = k.portId), k.channelId !== void 0 && (O.channelId = k.channelId), k.proofAck !== void 0 && (O.proofAck = (0, f.base64FromBytes)(k.proofAck !== void 0 ? k.proofAck : new Uint8Array())), k.proofHeight !== void 0 && (O.proofHeight = k.proofHeight ? m.Height.toJSON(k.proofHeight) : void 0), k.signer !== void 0 && (O.signer = k.signer), O;
    },
    fromPartial(k) {
      const O = A();
      return O.portId = k.portId ?? "", O.channelId = k.channelId ?? "", O.proofAck = k.proofAck ?? new Uint8Array(), O.proofHeight = k.proofHeight !== void 0 && k.proofHeight !== null ? m.Height.fromPartial(k.proofHeight) : void 0, O.signer = k.signer ?? "", O;
    }
  };
  function d() {
    return {};
  }
  e.MsgChannelOpenConfirmResponse = {
    encode(k, O = b.Writer.create()) {
      return O;
    },
    decode(k, O) {
      const L = k instanceof b.Reader ? k : new b.Reader(k);
      let Z = O === void 0 ? L.len : L.pos + O;
      const j = d();
      for (; L.pos < Z; ) {
        const i = L.uint32();
        switch (i >>> 3) {
          default:
            L.skipType(i & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(k) {
      return {};
    },
    toJSON(k) {
      return {};
    },
    fromPartial(k) {
      return d();
    }
  };
  function p() {
    return {
      portId: "",
      channelId: "",
      signer: ""
    };
  }
  e.MsgChannelCloseInit = {
    encode(k, O = b.Writer.create()) {
      return k.portId !== "" && O.uint32(10).string(k.portId), k.channelId !== "" && O.uint32(18).string(k.channelId), k.signer !== "" && O.uint32(26).string(k.signer), O;
    },
    decode(k, O) {
      const L = k instanceof b.Reader ? k : new b.Reader(k);
      let Z = O === void 0 ? L.len : L.pos + O;
      const j = p();
      for (; L.pos < Z; ) {
        const i = L.uint32();
        switch (i >>> 3) {
          case 1:
            j.portId = L.string();
            break;
          case 2:
            j.channelId = L.string();
            break;
          case 3:
            j.signer = L.string();
            break;
          default:
            L.skipType(i & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(k) {
      return {
        portId: (0, f.isSet)(k.portId) ? String(k.portId) : "",
        channelId: (0, f.isSet)(k.channelId) ? String(k.channelId) : "",
        signer: (0, f.isSet)(k.signer) ? String(k.signer) : ""
      };
    },
    toJSON(k) {
      const O = {};
      return k.portId !== void 0 && (O.portId = k.portId), k.channelId !== void 0 && (O.channelId = k.channelId), k.signer !== void 0 && (O.signer = k.signer), O;
    },
    fromPartial(k) {
      const O = p();
      return O.portId = k.portId ?? "", O.channelId = k.channelId ?? "", O.signer = k.signer ?? "", O;
    }
  };
  function h() {
    return {};
  }
  e.MsgChannelCloseInitResponse = {
    encode(k, O = b.Writer.create()) {
      return O;
    },
    decode(k, O) {
      const L = k instanceof b.Reader ? k : new b.Reader(k);
      let Z = O === void 0 ? L.len : L.pos + O;
      const j = h();
      for (; L.pos < Z; ) {
        const i = L.uint32();
        switch (i >>> 3) {
          default:
            L.skipType(i & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(k) {
      return {};
    },
    toJSON(k) {
      return {};
    },
    fromPartial(k) {
      return h();
    }
  };
  function x() {
    return {
      portId: "",
      channelId: "",
      proofInit: new Uint8Array(),
      proofHeight: void 0,
      signer: ""
    };
  }
  e.MsgChannelCloseConfirm = {
    encode(k, O = b.Writer.create()) {
      return k.portId !== "" && O.uint32(10).string(k.portId), k.channelId !== "" && O.uint32(18).string(k.channelId), k.proofInit.length !== 0 && O.uint32(26).bytes(k.proofInit), k.proofHeight !== void 0 && m.Height.encode(k.proofHeight, O.uint32(34).fork()).ldelim(), k.signer !== "" && O.uint32(42).string(k.signer), O;
    },
    decode(k, O) {
      const L = k instanceof b.Reader ? k : new b.Reader(k);
      let Z = O === void 0 ? L.len : L.pos + O;
      const j = x();
      for (; L.pos < Z; ) {
        const i = L.uint32();
        switch (i >>> 3) {
          case 1:
            j.portId = L.string();
            break;
          case 2:
            j.channelId = L.string();
            break;
          case 3:
            j.proofInit = L.bytes();
            break;
          case 4:
            j.proofHeight = m.Height.decode(L, L.uint32());
            break;
          case 5:
            j.signer = L.string();
            break;
          default:
            L.skipType(i & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(k) {
      return {
        portId: (0, f.isSet)(k.portId) ? String(k.portId) : "",
        channelId: (0, f.isSet)(k.channelId) ? String(k.channelId) : "",
        proofInit: (0, f.isSet)(k.proofInit) ? (0, f.bytesFromBase64)(k.proofInit) : new Uint8Array(),
        proofHeight: (0, f.isSet)(k.proofHeight) ? m.Height.fromJSON(k.proofHeight) : void 0,
        signer: (0, f.isSet)(k.signer) ? String(k.signer) : ""
      };
    },
    toJSON(k) {
      const O = {};
      return k.portId !== void 0 && (O.portId = k.portId), k.channelId !== void 0 && (O.channelId = k.channelId), k.proofInit !== void 0 && (O.proofInit = (0, f.base64FromBytes)(k.proofInit !== void 0 ? k.proofInit : new Uint8Array())), k.proofHeight !== void 0 && (O.proofHeight = k.proofHeight ? m.Height.toJSON(k.proofHeight) : void 0), k.signer !== void 0 && (O.signer = k.signer), O;
    },
    fromPartial(k) {
      const O = x();
      return O.portId = k.portId ?? "", O.channelId = k.channelId ?? "", O.proofInit = k.proofInit ?? new Uint8Array(), O.proofHeight = k.proofHeight !== void 0 && k.proofHeight !== null ? m.Height.fromPartial(k.proofHeight) : void 0, O.signer = k.signer ?? "", O;
    }
  };
  function _() {
    return {};
  }
  e.MsgChannelCloseConfirmResponse = {
    encode(k, O = b.Writer.create()) {
      return O;
    },
    decode(k, O) {
      const L = k instanceof b.Reader ? k : new b.Reader(k);
      let Z = O === void 0 ? L.len : L.pos + O;
      const j = _();
      for (; L.pos < Z; ) {
        const i = L.uint32();
        switch (i >>> 3) {
          default:
            L.skipType(i & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(k) {
      return {};
    },
    toJSON(k) {
      return {};
    },
    fromPartial(k) {
      return _();
    }
  };
  function I() {
    return {
      packet: void 0,
      proofCommitment: new Uint8Array(),
      proofHeight: void 0,
      signer: ""
    };
  }
  e.MsgRecvPacket = {
    encode(k, O = b.Writer.create()) {
      return k.packet !== void 0 && r.Packet.encode(k.packet, O.uint32(10).fork()).ldelim(), k.proofCommitment.length !== 0 && O.uint32(18).bytes(k.proofCommitment), k.proofHeight !== void 0 && m.Height.encode(k.proofHeight, O.uint32(26).fork()).ldelim(), k.signer !== "" && O.uint32(34).string(k.signer), O;
    },
    decode(k, O) {
      const L = k instanceof b.Reader ? k : new b.Reader(k);
      let Z = O === void 0 ? L.len : L.pos + O;
      const j = I();
      for (; L.pos < Z; ) {
        const i = L.uint32();
        switch (i >>> 3) {
          case 1:
            j.packet = r.Packet.decode(L, L.uint32());
            break;
          case 2:
            j.proofCommitment = L.bytes();
            break;
          case 3:
            j.proofHeight = m.Height.decode(L, L.uint32());
            break;
          case 4:
            j.signer = L.string();
            break;
          default:
            L.skipType(i & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(k) {
      return {
        packet: (0, f.isSet)(k.packet) ? r.Packet.fromJSON(k.packet) : void 0,
        proofCommitment: (0, f.isSet)(k.proofCommitment) ? (0, f.bytesFromBase64)(k.proofCommitment) : new Uint8Array(),
        proofHeight: (0, f.isSet)(k.proofHeight) ? m.Height.fromJSON(k.proofHeight) : void 0,
        signer: (0, f.isSet)(k.signer) ? String(k.signer) : ""
      };
    },
    toJSON(k) {
      const O = {};
      return k.packet !== void 0 && (O.packet = k.packet ? r.Packet.toJSON(k.packet) : void 0), k.proofCommitment !== void 0 && (O.proofCommitment = (0, f.base64FromBytes)(k.proofCommitment !== void 0 ? k.proofCommitment : new Uint8Array())), k.proofHeight !== void 0 && (O.proofHeight = k.proofHeight ? m.Height.toJSON(k.proofHeight) : void 0), k.signer !== void 0 && (O.signer = k.signer), O;
    },
    fromPartial(k) {
      const O = I();
      return O.packet = k.packet !== void 0 && k.packet !== null ? r.Packet.fromPartial(k.packet) : void 0, O.proofCommitment = k.proofCommitment ?? new Uint8Array(), O.proofHeight = k.proofHeight !== void 0 && k.proofHeight !== null ? m.Height.fromPartial(k.proofHeight) : void 0, O.signer = k.signer ?? "", O;
    }
  };
  function W() {
    return {
      result: 0
    };
  }
  e.MsgRecvPacketResponse = {
    encode(k, O = b.Writer.create()) {
      return k.result !== 0 && O.uint32(8).int32(k.result), O;
    },
    decode(k, O) {
      const L = k instanceof b.Reader ? k : new b.Reader(k);
      let Z = O === void 0 ? L.len : L.pos + O;
      const j = W();
      for (; L.pos < Z; ) {
        const i = L.uint32();
        switch (i >>> 3) {
          case 1:
            j.result = L.int32();
            break;
          default:
            L.skipType(i & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(k) {
      return {
        result: (0, f.isSet)(k.result) ? T(k.result) : 0
      };
    },
    toJSON(k) {
      const O = {};
      return k.result !== void 0 && (O.result = V(k.result)), O;
    },
    fromPartial(k) {
      const O = W();
      return O.result = k.result ?? 0, O;
    }
  };
  function n() {
    return {
      packet: void 0,
      proofUnreceived: new Uint8Array(),
      proofHeight: void 0,
      nextSequenceRecv: f.Long.UZERO,
      signer: ""
    };
  }
  e.MsgTimeout = {
    encode(k, O = b.Writer.create()) {
      return k.packet !== void 0 && r.Packet.encode(k.packet, O.uint32(10).fork()).ldelim(), k.proofUnreceived.length !== 0 && O.uint32(18).bytes(k.proofUnreceived), k.proofHeight !== void 0 && m.Height.encode(k.proofHeight, O.uint32(26).fork()).ldelim(), k.nextSequenceRecv.isZero() || O.uint32(32).uint64(k.nextSequenceRecv), k.signer !== "" && O.uint32(42).string(k.signer), O;
    },
    decode(k, O) {
      const L = k instanceof b.Reader ? k : new b.Reader(k);
      let Z = O === void 0 ? L.len : L.pos + O;
      const j = n();
      for (; L.pos < Z; ) {
        const i = L.uint32();
        switch (i >>> 3) {
          case 1:
            j.packet = r.Packet.decode(L, L.uint32());
            break;
          case 2:
            j.proofUnreceived = L.bytes();
            break;
          case 3:
            j.proofHeight = m.Height.decode(L, L.uint32());
            break;
          case 4:
            j.nextSequenceRecv = L.uint64();
            break;
          case 5:
            j.signer = L.string();
            break;
          default:
            L.skipType(i & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(k) {
      return {
        packet: (0, f.isSet)(k.packet) ? r.Packet.fromJSON(k.packet) : void 0,
        proofUnreceived: (0, f.isSet)(k.proofUnreceived) ? (0, f.bytesFromBase64)(k.proofUnreceived) : new Uint8Array(),
        proofHeight: (0, f.isSet)(k.proofHeight) ? m.Height.fromJSON(k.proofHeight) : void 0,
        nextSequenceRecv: (0, f.isSet)(k.nextSequenceRecv) ? f.Long.fromValue(k.nextSequenceRecv) : f.Long.UZERO,
        signer: (0, f.isSet)(k.signer) ? String(k.signer) : ""
      };
    },
    toJSON(k) {
      const O = {};
      return k.packet !== void 0 && (O.packet = k.packet ? r.Packet.toJSON(k.packet) : void 0), k.proofUnreceived !== void 0 && (O.proofUnreceived = (0, f.base64FromBytes)(k.proofUnreceived !== void 0 ? k.proofUnreceived : new Uint8Array())), k.proofHeight !== void 0 && (O.proofHeight = k.proofHeight ? m.Height.toJSON(k.proofHeight) : void 0), k.nextSequenceRecv !== void 0 && (O.nextSequenceRecv = (k.nextSequenceRecv || f.Long.UZERO).toString()), k.signer !== void 0 && (O.signer = k.signer), O;
    },
    fromPartial(k) {
      const O = n();
      return O.packet = k.packet !== void 0 && k.packet !== null ? r.Packet.fromPartial(k.packet) : void 0, O.proofUnreceived = k.proofUnreceived ?? new Uint8Array(), O.proofHeight = k.proofHeight !== void 0 && k.proofHeight !== null ? m.Height.fromPartial(k.proofHeight) : void 0, O.nextSequenceRecv = k.nextSequenceRecv !== void 0 && k.nextSequenceRecv !== null ? f.Long.fromValue(k.nextSequenceRecv) : f.Long.UZERO, O.signer = k.signer ?? "", O;
    }
  };
  function y() {
    return {
      result: 0
    };
  }
  e.MsgTimeoutResponse = {
    encode(k, O = b.Writer.create()) {
      return k.result !== 0 && O.uint32(8).int32(k.result), O;
    },
    decode(k, O) {
      const L = k instanceof b.Reader ? k : new b.Reader(k);
      let Z = O === void 0 ? L.len : L.pos + O;
      const j = y();
      for (; L.pos < Z; ) {
        const i = L.uint32();
        switch (i >>> 3) {
          case 1:
            j.result = L.int32();
            break;
          default:
            L.skipType(i & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(k) {
      return {
        result: (0, f.isSet)(k.result) ? T(k.result) : 0
      };
    },
    toJSON(k) {
      const O = {};
      return k.result !== void 0 && (O.result = V(k.result)), O;
    },
    fromPartial(k) {
      const O = y();
      return O.result = k.result ?? 0, O;
    }
  };
  function w() {
    return {
      packet: void 0,
      proofUnreceived: new Uint8Array(),
      proofClose: new Uint8Array(),
      proofHeight: void 0,
      nextSequenceRecv: f.Long.UZERO,
      signer: ""
    };
  }
  e.MsgTimeoutOnClose = {
    encode(k, O = b.Writer.create()) {
      return k.packet !== void 0 && r.Packet.encode(k.packet, O.uint32(10).fork()).ldelim(), k.proofUnreceived.length !== 0 && O.uint32(18).bytes(k.proofUnreceived), k.proofClose.length !== 0 && O.uint32(26).bytes(k.proofClose), k.proofHeight !== void 0 && m.Height.encode(k.proofHeight, O.uint32(34).fork()).ldelim(), k.nextSequenceRecv.isZero() || O.uint32(40).uint64(k.nextSequenceRecv), k.signer !== "" && O.uint32(50).string(k.signer), O;
    },
    decode(k, O) {
      const L = k instanceof b.Reader ? k : new b.Reader(k);
      let Z = O === void 0 ? L.len : L.pos + O;
      const j = w();
      for (; L.pos < Z; ) {
        const i = L.uint32();
        switch (i >>> 3) {
          case 1:
            j.packet = r.Packet.decode(L, L.uint32());
            break;
          case 2:
            j.proofUnreceived = L.bytes();
            break;
          case 3:
            j.proofClose = L.bytes();
            break;
          case 4:
            j.proofHeight = m.Height.decode(L, L.uint32());
            break;
          case 5:
            j.nextSequenceRecv = L.uint64();
            break;
          case 6:
            j.signer = L.string();
            break;
          default:
            L.skipType(i & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(k) {
      return {
        packet: (0, f.isSet)(k.packet) ? r.Packet.fromJSON(k.packet) : void 0,
        proofUnreceived: (0, f.isSet)(k.proofUnreceived) ? (0, f.bytesFromBase64)(k.proofUnreceived) : new Uint8Array(),
        proofClose: (0, f.isSet)(k.proofClose) ? (0, f.bytesFromBase64)(k.proofClose) : new Uint8Array(),
        proofHeight: (0, f.isSet)(k.proofHeight) ? m.Height.fromJSON(k.proofHeight) : void 0,
        nextSequenceRecv: (0, f.isSet)(k.nextSequenceRecv) ? f.Long.fromValue(k.nextSequenceRecv) : f.Long.UZERO,
        signer: (0, f.isSet)(k.signer) ? String(k.signer) : ""
      };
    },
    toJSON(k) {
      const O = {};
      return k.packet !== void 0 && (O.packet = k.packet ? r.Packet.toJSON(k.packet) : void 0), k.proofUnreceived !== void 0 && (O.proofUnreceived = (0, f.base64FromBytes)(k.proofUnreceived !== void 0 ? k.proofUnreceived : new Uint8Array())), k.proofClose !== void 0 && (O.proofClose = (0, f.base64FromBytes)(k.proofClose !== void 0 ? k.proofClose : new Uint8Array())), k.proofHeight !== void 0 && (O.proofHeight = k.proofHeight ? m.Height.toJSON(k.proofHeight) : void 0), k.nextSequenceRecv !== void 0 && (O.nextSequenceRecv = (k.nextSequenceRecv || f.Long.UZERO).toString()), k.signer !== void 0 && (O.signer = k.signer), O;
    },
    fromPartial(k) {
      const O = w();
      return O.packet = k.packet !== void 0 && k.packet !== null ? r.Packet.fromPartial(k.packet) : void 0, O.proofUnreceived = k.proofUnreceived ?? new Uint8Array(), O.proofClose = k.proofClose ?? new Uint8Array(), O.proofHeight = k.proofHeight !== void 0 && k.proofHeight !== null ? m.Height.fromPartial(k.proofHeight) : void 0, O.nextSequenceRecv = k.nextSequenceRecv !== void 0 && k.nextSequenceRecv !== null ? f.Long.fromValue(k.nextSequenceRecv) : f.Long.UZERO, O.signer = k.signer ?? "", O;
    }
  };
  function M() {
    return {
      result: 0
    };
  }
  e.MsgTimeoutOnCloseResponse = {
    encode(k, O = b.Writer.create()) {
      return k.result !== 0 && O.uint32(8).int32(k.result), O;
    },
    decode(k, O) {
      const L = k instanceof b.Reader ? k : new b.Reader(k);
      let Z = O === void 0 ? L.len : L.pos + O;
      const j = M();
      for (; L.pos < Z; ) {
        const i = L.uint32();
        switch (i >>> 3) {
          case 1:
            j.result = L.int32();
            break;
          default:
            L.skipType(i & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(k) {
      return {
        result: (0, f.isSet)(k.result) ? T(k.result) : 0
      };
    },
    toJSON(k) {
      const O = {};
      return k.result !== void 0 && (O.result = V(k.result)), O;
    },
    fromPartial(k) {
      const O = M();
      return O.result = k.result ?? 0, O;
    }
  };
  function s() {
    return {
      packet: void 0,
      acknowledgement: new Uint8Array(),
      proofAcked: new Uint8Array(),
      proofHeight: void 0,
      signer: ""
    };
  }
  e.MsgAcknowledgement = {
    encode(k, O = b.Writer.create()) {
      return k.packet !== void 0 && r.Packet.encode(k.packet, O.uint32(10).fork()).ldelim(), k.acknowledgement.length !== 0 && O.uint32(18).bytes(k.acknowledgement), k.proofAcked.length !== 0 && O.uint32(26).bytes(k.proofAcked), k.proofHeight !== void 0 && m.Height.encode(k.proofHeight, O.uint32(34).fork()).ldelim(), k.signer !== "" && O.uint32(42).string(k.signer), O;
    },
    decode(k, O) {
      const L = k instanceof b.Reader ? k : new b.Reader(k);
      let Z = O === void 0 ? L.len : L.pos + O;
      const j = s();
      for (; L.pos < Z; ) {
        const i = L.uint32();
        switch (i >>> 3) {
          case 1:
            j.packet = r.Packet.decode(L, L.uint32());
            break;
          case 2:
            j.acknowledgement = L.bytes();
            break;
          case 3:
            j.proofAcked = L.bytes();
            break;
          case 4:
            j.proofHeight = m.Height.decode(L, L.uint32());
            break;
          case 5:
            j.signer = L.string();
            break;
          default:
            L.skipType(i & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(k) {
      return {
        packet: (0, f.isSet)(k.packet) ? r.Packet.fromJSON(k.packet) : void 0,
        acknowledgement: (0, f.isSet)(k.acknowledgement) ? (0, f.bytesFromBase64)(k.acknowledgement) : new Uint8Array(),
        proofAcked: (0, f.isSet)(k.proofAcked) ? (0, f.bytesFromBase64)(k.proofAcked) : new Uint8Array(),
        proofHeight: (0, f.isSet)(k.proofHeight) ? m.Height.fromJSON(k.proofHeight) : void 0,
        signer: (0, f.isSet)(k.signer) ? String(k.signer) : ""
      };
    },
    toJSON(k) {
      const O = {};
      return k.packet !== void 0 && (O.packet = k.packet ? r.Packet.toJSON(k.packet) : void 0), k.acknowledgement !== void 0 && (O.acknowledgement = (0, f.base64FromBytes)(k.acknowledgement !== void 0 ? k.acknowledgement : new Uint8Array())), k.proofAcked !== void 0 && (O.proofAcked = (0, f.base64FromBytes)(k.proofAcked !== void 0 ? k.proofAcked : new Uint8Array())), k.proofHeight !== void 0 && (O.proofHeight = k.proofHeight ? m.Height.toJSON(k.proofHeight) : void 0), k.signer !== void 0 && (O.signer = k.signer), O;
    },
    fromPartial(k) {
      const O = s();
      return O.packet = k.packet !== void 0 && k.packet !== null ? r.Packet.fromPartial(k.packet) : void 0, O.acknowledgement = k.acknowledgement ?? new Uint8Array(), O.proofAcked = k.proofAcked ?? new Uint8Array(), O.proofHeight = k.proofHeight !== void 0 && k.proofHeight !== null ? m.Height.fromPartial(k.proofHeight) : void 0, O.signer = k.signer ?? "", O;
    }
  };
  function c() {
    return {
      result: 0
    };
  }
  e.MsgAcknowledgementResponse = {
    encode(k, O = b.Writer.create()) {
      return k.result !== 0 && O.uint32(8).int32(k.result), O;
    },
    decode(k, O) {
      const L = k instanceof b.Reader ? k : new b.Reader(k);
      let Z = O === void 0 ? L.len : L.pos + O;
      const j = c();
      for (; L.pos < Z; ) {
        const i = L.uint32();
        switch (i >>> 3) {
          case 1:
            j.result = L.int32();
            break;
          default:
            L.skipType(i & 7);
            break;
        }
      }
      return j;
    },
    fromJSON(k) {
      return {
        result: (0, f.isSet)(k.result) ? T(k.result) : 0
      };
    },
    toJSON(k) {
      const O = {};
      return k.result !== void 0 && (O.result = V(k.result)), O;
    },
    fromPartial(k) {
      const O = c();
      return O.result = k.result ?? 0, O;
    }
  };
  class E {
    constructor(O) {
      this.rpc = O, this.ChannelOpenInit = this.ChannelOpenInit.bind(this), this.ChannelOpenTry = this.ChannelOpenTry.bind(this), this.ChannelOpenAck = this.ChannelOpenAck.bind(this), this.ChannelOpenConfirm = this.ChannelOpenConfirm.bind(this), this.ChannelCloseInit = this.ChannelCloseInit.bind(this), this.ChannelCloseConfirm = this.ChannelCloseConfirm.bind(this), this.RecvPacket = this.RecvPacket.bind(this), this.Timeout = this.Timeout.bind(this), this.TimeoutOnClose = this.TimeoutOnClose.bind(this), this.Acknowledgement = this.Acknowledgement.bind(this);
    }
    ChannelOpenInit(O) {
      const L = e.MsgChannelOpenInit.encode(O).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenInit", L).then((Z) => e.MsgChannelOpenInitResponse.decode(new b.Reader(Z)));
    }
    ChannelOpenTry(O) {
      const L = e.MsgChannelOpenTry.encode(O).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenTry", L).then((Z) => e.MsgChannelOpenTryResponse.decode(new b.Reader(Z)));
    }
    ChannelOpenAck(O) {
      const L = e.MsgChannelOpenAck.encode(O).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenAck", L).then((Z) => e.MsgChannelOpenAckResponse.decode(new b.Reader(Z)));
    }
    ChannelOpenConfirm(O) {
      const L = e.MsgChannelOpenConfirm.encode(O).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenConfirm", L).then((Z) => e.MsgChannelOpenConfirmResponse.decode(new b.Reader(Z)));
    }
    ChannelCloseInit(O) {
      const L = e.MsgChannelCloseInit.encode(O).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseInit", L).then((Z) => e.MsgChannelCloseInitResponse.decode(new b.Reader(Z)));
    }
    ChannelCloseConfirm(O) {
      const L = e.MsgChannelCloseConfirm.encode(O).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseConfirm", L).then((Z) => e.MsgChannelCloseConfirmResponse.decode(new b.Reader(Z)));
    }
    RecvPacket(O) {
      const L = e.MsgRecvPacket.encode(O).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "RecvPacket", L).then((Z) => e.MsgRecvPacketResponse.decode(new b.Reader(Z)));
    }
    Timeout(O) {
      const L = e.MsgTimeout.encode(O).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "Timeout", L).then((Z) => e.MsgTimeoutResponse.decode(new b.Reader(Z)));
    }
    TimeoutOnClose(O) {
      const L = e.MsgTimeoutOnClose.encode(O).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "TimeoutOnClose", L).then((Z) => e.MsgTimeoutOnCloseResponse.decode(new b.Reader(Z)));
    }
    Acknowledgement(O) {
      const L = e.MsgAcknowledgement.encode(O).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "Acknowledgement", L).then((Z) => e.MsgAcknowledgementResponse.decode(new b.Reader(Z)));
    }
  }
  e.MsgClientImpl = E;
})(Ac);
var wc = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(S, A, d, p) {
    p === void 0 && (p = d);
    var h = Object.getOwnPropertyDescriptor(A, d);
    (!h || ("get" in h ? !A.__esModule : h.writable || h.configurable)) && (h = { enumerable: !0, get: function() {
      return A[d];
    } }), Object.defineProperty(S, p, h);
  } : function(S, A, d, p) {
    p === void 0 && (p = d), S[p] = A[d];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(S, A) {
    Object.defineProperty(S, "default", { enumerable: !0, value: A });
  } : function(S, A) {
    S.default = A;
  }), u = Q && Q.__importStar || function(S) {
    if (S && S.__esModule)
      return S;
    var A = {};
    if (S != null)
      for (var d in S)
        d !== "default" && Object.prototype.hasOwnProperty.call(S, d) && o(A, S, d);
    return t(A, S), A;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgSubmitMisbehaviourResponse = e.MsgSubmitMisbehaviour = e.MsgUpgradeClientResponse = e.MsgUpgradeClient = e.MsgUpdateClientResponse = e.MsgUpdateClient = e.MsgCreateClientResponse = e.MsgCreateClient = e.protobufPackage = void 0;
  const r = ye, m = u(re), f = ie;
  e.protobufPackage = "ibc.core.client.v1";
  function b() {
    return {
      clientState: void 0,
      consensusState: void 0,
      signer: ""
    };
  }
  e.MsgCreateClient = {
    encode(S, A = m.Writer.create()) {
      return S.clientState !== void 0 && r.Any.encode(S.clientState, A.uint32(10).fork()).ldelim(), S.consensusState !== void 0 && r.Any.encode(S.consensusState, A.uint32(18).fork()).ldelim(), S.signer !== "" && A.uint32(26).string(S.signer), A;
    },
    decode(S, A) {
      const d = S instanceof m.Reader ? S : new m.Reader(S);
      let p = A === void 0 ? d.len : d.pos + A;
      const h = b();
      for (; d.pos < p; ) {
        const x = d.uint32();
        switch (x >>> 3) {
          case 1:
            h.clientState = r.Any.decode(d, d.uint32());
            break;
          case 2:
            h.consensusState = r.Any.decode(d, d.uint32());
            break;
          case 3:
            h.signer = d.string();
            break;
          default:
            d.skipType(x & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(S) {
      return {
        clientState: (0, f.isSet)(S.clientState) ? r.Any.fromJSON(S.clientState) : void 0,
        consensusState: (0, f.isSet)(S.consensusState) ? r.Any.fromJSON(S.consensusState) : void 0,
        signer: (0, f.isSet)(S.signer) ? String(S.signer) : ""
      };
    },
    toJSON(S) {
      const A = {};
      return S.clientState !== void 0 && (A.clientState = S.clientState ? r.Any.toJSON(S.clientState) : void 0), S.consensusState !== void 0 && (A.consensusState = S.consensusState ? r.Any.toJSON(S.consensusState) : void 0), S.signer !== void 0 && (A.signer = S.signer), A;
    },
    fromPartial(S) {
      const A = b();
      return A.clientState = S.clientState !== void 0 && S.clientState !== null ? r.Any.fromPartial(S.clientState) : void 0, A.consensusState = S.consensusState !== void 0 && S.consensusState !== null ? r.Any.fromPartial(S.consensusState) : void 0, A.signer = S.signer ?? "", A;
    }
  };
  function R() {
    return {};
  }
  e.MsgCreateClientResponse = {
    encode(S, A = m.Writer.create()) {
      return A;
    },
    decode(S, A) {
      const d = S instanceof m.Reader ? S : new m.Reader(S);
      let p = A === void 0 ? d.len : d.pos + A;
      const h = R();
      for (; d.pos < p; ) {
        const x = d.uint32();
        switch (x >>> 3) {
          default:
            d.skipType(x & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(S) {
      return {};
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return R();
    }
  };
  function T() {
    return {
      clientId: "",
      clientMessage: void 0,
      signer: ""
    };
  }
  e.MsgUpdateClient = {
    encode(S, A = m.Writer.create()) {
      return S.clientId !== "" && A.uint32(10).string(S.clientId), S.clientMessage !== void 0 && r.Any.encode(S.clientMessage, A.uint32(18).fork()).ldelim(), S.signer !== "" && A.uint32(26).string(S.signer), A;
    },
    decode(S, A) {
      const d = S instanceof m.Reader ? S : new m.Reader(S);
      let p = A === void 0 ? d.len : d.pos + A;
      const h = T();
      for (; d.pos < p; ) {
        const x = d.uint32();
        switch (x >>> 3) {
          case 1:
            h.clientId = d.string();
            break;
          case 2:
            h.clientMessage = r.Any.decode(d, d.uint32());
            break;
          case 3:
            h.signer = d.string();
            break;
          default:
            d.skipType(x & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(S) {
      return {
        clientId: (0, f.isSet)(S.clientId) ? String(S.clientId) : "",
        clientMessage: (0, f.isSet)(S.clientMessage) ? r.Any.fromJSON(S.clientMessage) : void 0,
        signer: (0, f.isSet)(S.signer) ? String(S.signer) : ""
      };
    },
    toJSON(S) {
      const A = {};
      return S.clientId !== void 0 && (A.clientId = S.clientId), S.clientMessage !== void 0 && (A.clientMessage = S.clientMessage ? r.Any.toJSON(S.clientMessage) : void 0), S.signer !== void 0 && (A.signer = S.signer), A;
    },
    fromPartial(S) {
      const A = T();
      return A.clientId = S.clientId ?? "", A.clientMessage = S.clientMessage !== void 0 && S.clientMessage !== null ? r.Any.fromPartial(S.clientMessage) : void 0, A.signer = S.signer ?? "", A;
    }
  };
  function V() {
    return {};
  }
  e.MsgUpdateClientResponse = {
    encode(S, A = m.Writer.create()) {
      return A;
    },
    decode(S, A) {
      const d = S instanceof m.Reader ? S : new m.Reader(S);
      let p = A === void 0 ? d.len : d.pos + A;
      const h = V();
      for (; d.pos < p; ) {
        const x = d.uint32();
        switch (x >>> 3) {
          default:
            d.skipType(x & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(S) {
      return {};
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return V();
    }
  };
  function D() {
    return {
      clientId: "",
      clientState: void 0,
      consensusState: void 0,
      proofUpgradeClient: new Uint8Array(),
      proofUpgradeConsensusState: new Uint8Array(),
      signer: ""
    };
  }
  e.MsgUpgradeClient = {
    encode(S, A = m.Writer.create()) {
      return S.clientId !== "" && A.uint32(10).string(S.clientId), S.clientState !== void 0 && r.Any.encode(S.clientState, A.uint32(18).fork()).ldelim(), S.consensusState !== void 0 && r.Any.encode(S.consensusState, A.uint32(26).fork()).ldelim(), S.proofUpgradeClient.length !== 0 && A.uint32(34).bytes(S.proofUpgradeClient), S.proofUpgradeConsensusState.length !== 0 && A.uint32(42).bytes(S.proofUpgradeConsensusState), S.signer !== "" && A.uint32(50).string(S.signer), A;
    },
    decode(S, A) {
      const d = S instanceof m.Reader ? S : new m.Reader(S);
      let p = A === void 0 ? d.len : d.pos + A;
      const h = D();
      for (; d.pos < p; ) {
        const x = d.uint32();
        switch (x >>> 3) {
          case 1:
            h.clientId = d.string();
            break;
          case 2:
            h.clientState = r.Any.decode(d, d.uint32());
            break;
          case 3:
            h.consensusState = r.Any.decode(d, d.uint32());
            break;
          case 4:
            h.proofUpgradeClient = d.bytes();
            break;
          case 5:
            h.proofUpgradeConsensusState = d.bytes();
            break;
          case 6:
            h.signer = d.string();
            break;
          default:
            d.skipType(x & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(S) {
      return {
        clientId: (0, f.isSet)(S.clientId) ? String(S.clientId) : "",
        clientState: (0, f.isSet)(S.clientState) ? r.Any.fromJSON(S.clientState) : void 0,
        consensusState: (0, f.isSet)(S.consensusState) ? r.Any.fromJSON(S.consensusState) : void 0,
        proofUpgradeClient: (0, f.isSet)(S.proofUpgradeClient) ? (0, f.bytesFromBase64)(S.proofUpgradeClient) : new Uint8Array(),
        proofUpgradeConsensusState: (0, f.isSet)(S.proofUpgradeConsensusState) ? (0, f.bytesFromBase64)(S.proofUpgradeConsensusState) : new Uint8Array(),
        signer: (0, f.isSet)(S.signer) ? String(S.signer) : ""
      };
    },
    toJSON(S) {
      const A = {};
      return S.clientId !== void 0 && (A.clientId = S.clientId), S.clientState !== void 0 && (A.clientState = S.clientState ? r.Any.toJSON(S.clientState) : void 0), S.consensusState !== void 0 && (A.consensusState = S.consensusState ? r.Any.toJSON(S.consensusState) : void 0), S.proofUpgradeClient !== void 0 && (A.proofUpgradeClient = (0, f.base64FromBytes)(S.proofUpgradeClient !== void 0 ? S.proofUpgradeClient : new Uint8Array())), S.proofUpgradeConsensusState !== void 0 && (A.proofUpgradeConsensusState = (0, f.base64FromBytes)(S.proofUpgradeConsensusState !== void 0 ? S.proofUpgradeConsensusState : new Uint8Array())), S.signer !== void 0 && (A.signer = S.signer), A;
    },
    fromPartial(S) {
      const A = D();
      return A.clientId = S.clientId ?? "", A.clientState = S.clientState !== void 0 && S.clientState !== null ? r.Any.fromPartial(S.clientState) : void 0, A.consensusState = S.consensusState !== void 0 && S.consensusState !== null ? r.Any.fromPartial(S.consensusState) : void 0, A.proofUpgradeClient = S.proofUpgradeClient ?? new Uint8Array(), A.proofUpgradeConsensusState = S.proofUpgradeConsensusState ?? new Uint8Array(), A.signer = S.signer ?? "", A;
    }
  };
  function B() {
    return {};
  }
  e.MsgUpgradeClientResponse = {
    encode(S, A = m.Writer.create()) {
      return A;
    },
    decode(S, A) {
      const d = S instanceof m.Reader ? S : new m.Reader(S);
      let p = A === void 0 ? d.len : d.pos + A;
      const h = B();
      for (; d.pos < p; ) {
        const x = d.uint32();
        switch (x >>> 3) {
          default:
            d.skipType(x & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(S) {
      return {};
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return B();
    }
  };
  function U() {
    return {
      clientId: "",
      misbehaviour: void 0,
      signer: ""
    };
  }
  e.MsgSubmitMisbehaviour = {
    encode(S, A = m.Writer.create()) {
      return S.clientId !== "" && A.uint32(10).string(S.clientId), S.misbehaviour !== void 0 && r.Any.encode(S.misbehaviour, A.uint32(18).fork()).ldelim(), S.signer !== "" && A.uint32(26).string(S.signer), A;
    },
    decode(S, A) {
      const d = S instanceof m.Reader ? S : new m.Reader(S);
      let p = A === void 0 ? d.len : d.pos + A;
      const h = U();
      for (; d.pos < p; ) {
        const x = d.uint32();
        switch (x >>> 3) {
          case 1:
            h.clientId = d.string();
            break;
          case 2:
            h.misbehaviour = r.Any.decode(d, d.uint32());
            break;
          case 3:
            h.signer = d.string();
            break;
          default:
            d.skipType(x & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(S) {
      return {
        clientId: (0, f.isSet)(S.clientId) ? String(S.clientId) : "",
        misbehaviour: (0, f.isSet)(S.misbehaviour) ? r.Any.fromJSON(S.misbehaviour) : void 0,
        signer: (0, f.isSet)(S.signer) ? String(S.signer) : ""
      };
    },
    toJSON(S) {
      const A = {};
      return S.clientId !== void 0 && (A.clientId = S.clientId), S.misbehaviour !== void 0 && (A.misbehaviour = S.misbehaviour ? r.Any.toJSON(S.misbehaviour) : void 0), S.signer !== void 0 && (A.signer = S.signer), A;
    },
    fromPartial(S) {
      const A = U();
      return A.clientId = S.clientId ?? "", A.misbehaviour = S.misbehaviour !== void 0 && S.misbehaviour !== null ? r.Any.fromPartial(S.misbehaviour) : void 0, A.signer = S.signer ?? "", A;
    }
  };
  function C() {
    return {};
  }
  e.MsgSubmitMisbehaviourResponse = {
    encode(S, A = m.Writer.create()) {
      return A;
    },
    decode(S, A) {
      const d = S instanceof m.Reader ? S : new m.Reader(S);
      let p = A === void 0 ? d.len : d.pos + A;
      const h = C();
      for (; d.pos < p; ) {
        const x = d.uint32();
        switch (x >>> 3) {
          default:
            d.skipType(x & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(S) {
      return {};
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return C();
    }
  };
  class l {
    constructor(A) {
      this.rpc = A, this.CreateClient = this.CreateClient.bind(this), this.UpdateClient = this.UpdateClient.bind(this), this.UpgradeClient = this.UpgradeClient.bind(this), this.SubmitMisbehaviour = this.SubmitMisbehaviour.bind(this);
    }
    CreateClient(A) {
      const d = e.MsgCreateClient.encode(A).finish();
      return this.rpc.request("ibc.core.client.v1.Msg", "CreateClient", d).then((p) => e.MsgCreateClientResponse.decode(new m.Reader(p)));
    }
    UpdateClient(A) {
      const d = e.MsgUpdateClient.encode(A).finish();
      return this.rpc.request("ibc.core.client.v1.Msg", "UpdateClient", d).then((p) => e.MsgUpdateClientResponse.decode(new m.Reader(p)));
    }
    UpgradeClient(A) {
      const d = e.MsgUpgradeClient.encode(A).finish();
      return this.rpc.request("ibc.core.client.v1.Msg", "UpgradeClient", d).then((p) => e.MsgUpgradeClientResponse.decode(new m.Reader(p)));
    }
    SubmitMisbehaviour(A) {
      const d = e.MsgSubmitMisbehaviour.encode(A).finish();
      return this.rpc.request("ibc.core.client.v1.Msg", "SubmitMisbehaviour", d).then((p) => e.MsgSubmitMisbehaviourResponse.decode(new m.Reader(p)));
    }
  }
  e.MsgClientImpl = l;
})(wc);
var Nc = {}, Yi = {}, Xe = {}, $i = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(n, y, w, M) {
    M === void 0 && (M = w);
    var s = Object.getOwnPropertyDescriptor(y, w);
    (!s || ("get" in s ? !y.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
      return y[w];
    } }), Object.defineProperty(n, M, s);
  } : function(n, y, w, M) {
    M === void 0 && (M = w), n[M] = y[w];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(n, y) {
    Object.defineProperty(n, "default", { enumerable: !0, value: y });
  } : function(n, y) {
    n.default = y;
  }), u = Q && Q.__importStar || function(n) {
    if (n && n.__esModule)
      return n;
    var y = {};
    if (n != null)
      for (var w in n)
        w !== "default" && Object.prototype.hasOwnProperty.call(n, w) && o(y, n, w);
    return t(y, n), y;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CompressedNonExistenceProof = e.CompressedExistenceProof = e.CompressedBatchEntry = e.CompressedBatchProof = e.BatchEntry = e.BatchProof = e.InnerSpec = e.ProofSpec = e.InnerOp = e.LeafOp = e.CommitmentProof = e.NonExistenceProof = e.ExistenceProof = e.lengthOpToJSON = e.lengthOpFromJSON = e.LengthOp = e.hashOpToJSON = e.hashOpFromJSON = e.HashOp = e.protobufPackage = void 0;
  const r = u(re), m = ie;
  e.protobufPackage = "cosmos.ics23.v1";
  var f;
  (function(n) {
    n[n.NO_HASH = 0] = "NO_HASH", n[n.SHA256 = 1] = "SHA256", n[n.SHA512 = 2] = "SHA512", n[n.KECCAK = 3] = "KECCAK", n[n.RIPEMD160 = 4] = "RIPEMD160", n[n.BITCOIN = 5] = "BITCOIN", n[n.SHA512_256 = 6] = "SHA512_256", n[n.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(f = e.HashOp || (e.HashOp = {}));
  function b(n) {
    switch (n) {
      case 0:
      case "NO_HASH":
        return f.NO_HASH;
      case 1:
      case "SHA256":
        return f.SHA256;
      case 2:
      case "SHA512":
        return f.SHA512;
      case 3:
      case "KECCAK":
        return f.KECCAK;
      case 4:
      case "RIPEMD160":
        return f.RIPEMD160;
      case 5:
      case "BITCOIN":
        return f.BITCOIN;
      case 6:
      case "SHA512_256":
        return f.SHA512_256;
      case -1:
      case "UNRECOGNIZED":
      default:
        return f.UNRECOGNIZED;
    }
  }
  e.hashOpFromJSON = b;
  function R(n) {
    switch (n) {
      case f.NO_HASH:
        return "NO_HASH";
      case f.SHA256:
        return "SHA256";
      case f.SHA512:
        return "SHA512";
      case f.KECCAK:
        return "KECCAK";
      case f.RIPEMD160:
        return "RIPEMD160";
      case f.BITCOIN:
        return "BITCOIN";
      case f.SHA512_256:
        return "SHA512_256";
      case f.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.hashOpToJSON = R;
  var T;
  (function(n) {
    n[n.NO_PREFIX = 0] = "NO_PREFIX", n[n.VAR_PROTO = 1] = "VAR_PROTO", n[n.VAR_RLP = 2] = "VAR_RLP", n[n.FIXED32_BIG = 3] = "FIXED32_BIG", n[n.FIXED32_LITTLE = 4] = "FIXED32_LITTLE", n[n.FIXED64_BIG = 5] = "FIXED64_BIG", n[n.FIXED64_LITTLE = 6] = "FIXED64_LITTLE", n[n.REQUIRE_32_BYTES = 7] = "REQUIRE_32_BYTES", n[n.REQUIRE_64_BYTES = 8] = "REQUIRE_64_BYTES", n[n.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(T = e.LengthOp || (e.LengthOp = {}));
  function V(n) {
    switch (n) {
      case 0:
      case "NO_PREFIX":
        return T.NO_PREFIX;
      case 1:
      case "VAR_PROTO":
        return T.VAR_PROTO;
      case 2:
      case "VAR_RLP":
        return T.VAR_RLP;
      case 3:
      case "FIXED32_BIG":
        return T.FIXED32_BIG;
      case 4:
      case "FIXED32_LITTLE":
        return T.FIXED32_LITTLE;
      case 5:
      case "FIXED64_BIG":
        return T.FIXED64_BIG;
      case 6:
      case "FIXED64_LITTLE":
        return T.FIXED64_LITTLE;
      case 7:
      case "REQUIRE_32_BYTES":
        return T.REQUIRE_32_BYTES;
      case 8:
      case "REQUIRE_64_BYTES":
        return T.REQUIRE_64_BYTES;
      case -1:
      case "UNRECOGNIZED":
      default:
        return T.UNRECOGNIZED;
    }
  }
  e.lengthOpFromJSON = V;
  function D(n) {
    switch (n) {
      case T.NO_PREFIX:
        return "NO_PREFIX";
      case T.VAR_PROTO:
        return "VAR_PROTO";
      case T.VAR_RLP:
        return "VAR_RLP";
      case T.FIXED32_BIG:
        return "FIXED32_BIG";
      case T.FIXED32_LITTLE:
        return "FIXED32_LITTLE";
      case T.FIXED64_BIG:
        return "FIXED64_BIG";
      case T.FIXED64_LITTLE:
        return "FIXED64_LITTLE";
      case T.REQUIRE_32_BYTES:
        return "REQUIRE_32_BYTES";
      case T.REQUIRE_64_BYTES:
        return "REQUIRE_64_BYTES";
      case T.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.lengthOpToJSON = D;
  function B() {
    return {
      key: new Uint8Array(),
      value: new Uint8Array(),
      leaf: void 0,
      path: []
    };
  }
  e.ExistenceProof = {
    encode(n, y = r.Writer.create()) {
      n.key.length !== 0 && y.uint32(10).bytes(n.key), n.value.length !== 0 && y.uint32(18).bytes(n.value), n.leaf !== void 0 && e.LeafOp.encode(n.leaf, y.uint32(26).fork()).ldelim();
      for (const w of n.path)
        e.InnerOp.encode(w, y.uint32(34).fork()).ldelim();
      return y;
    },
    decode(n, y) {
      const w = n instanceof r.Reader ? n : new r.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = B();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.key = w.bytes();
            break;
          case 2:
            s.value = w.bytes();
            break;
          case 3:
            s.leaf = e.LeafOp.decode(w, w.uint32());
            break;
          case 4:
            s.path.push(e.InnerOp.decode(w, w.uint32()));
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        key: (0, m.isSet)(n.key) ? (0, m.bytesFromBase64)(n.key) : new Uint8Array(),
        value: (0, m.isSet)(n.value) ? (0, m.bytesFromBase64)(n.value) : new Uint8Array(),
        leaf: (0, m.isSet)(n.leaf) ? e.LeafOp.fromJSON(n.leaf) : void 0,
        path: Array.isArray(n == null ? void 0 : n.path) ? n.path.map((y) => e.InnerOp.fromJSON(y)) : []
      };
    },
    toJSON(n) {
      const y = {};
      return n.key !== void 0 && (y.key = (0, m.base64FromBytes)(n.key !== void 0 ? n.key : new Uint8Array())), n.value !== void 0 && (y.value = (0, m.base64FromBytes)(n.value !== void 0 ? n.value : new Uint8Array())), n.leaf !== void 0 && (y.leaf = n.leaf ? e.LeafOp.toJSON(n.leaf) : void 0), n.path ? y.path = n.path.map((w) => w ? e.InnerOp.toJSON(w) : void 0) : y.path = [], y;
    },
    fromPartial(n) {
      var y;
      const w = B();
      return w.key = n.key ?? new Uint8Array(), w.value = n.value ?? new Uint8Array(), w.leaf = n.leaf !== void 0 && n.leaf !== null ? e.LeafOp.fromPartial(n.leaf) : void 0, w.path = ((y = n.path) == null ? void 0 : y.map((M) => e.InnerOp.fromPartial(M))) || [], w;
    }
  };
  function U() {
    return {
      key: new Uint8Array(),
      left: void 0,
      right: void 0
    };
  }
  e.NonExistenceProof = {
    encode(n, y = r.Writer.create()) {
      return n.key.length !== 0 && y.uint32(10).bytes(n.key), n.left !== void 0 && e.ExistenceProof.encode(n.left, y.uint32(18).fork()).ldelim(), n.right !== void 0 && e.ExistenceProof.encode(n.right, y.uint32(26).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof r.Reader ? n : new r.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = U();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.key = w.bytes();
            break;
          case 2:
            s.left = e.ExistenceProof.decode(w, w.uint32());
            break;
          case 3:
            s.right = e.ExistenceProof.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        key: (0, m.isSet)(n.key) ? (0, m.bytesFromBase64)(n.key) : new Uint8Array(),
        left: (0, m.isSet)(n.left) ? e.ExistenceProof.fromJSON(n.left) : void 0,
        right: (0, m.isSet)(n.right) ? e.ExistenceProof.fromJSON(n.right) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.key !== void 0 && (y.key = (0, m.base64FromBytes)(n.key !== void 0 ? n.key : new Uint8Array())), n.left !== void 0 && (y.left = n.left ? e.ExistenceProof.toJSON(n.left) : void 0), n.right !== void 0 && (y.right = n.right ? e.ExistenceProof.toJSON(n.right) : void 0), y;
    },
    fromPartial(n) {
      const y = U();
      return y.key = n.key ?? new Uint8Array(), y.left = n.left !== void 0 && n.left !== null ? e.ExistenceProof.fromPartial(n.left) : void 0, y.right = n.right !== void 0 && n.right !== null ? e.ExistenceProof.fromPartial(n.right) : void 0, y;
    }
  };
  function C() {
    return {
      exist: void 0,
      nonexist: void 0,
      batch: void 0,
      compressed: void 0
    };
  }
  e.CommitmentProof = {
    encode(n, y = r.Writer.create()) {
      return n.exist !== void 0 && e.ExistenceProof.encode(n.exist, y.uint32(10).fork()).ldelim(), n.nonexist !== void 0 && e.NonExistenceProof.encode(n.nonexist, y.uint32(18).fork()).ldelim(), n.batch !== void 0 && e.BatchProof.encode(n.batch, y.uint32(26).fork()).ldelim(), n.compressed !== void 0 && e.CompressedBatchProof.encode(n.compressed, y.uint32(34).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof r.Reader ? n : new r.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = C();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.exist = e.ExistenceProof.decode(w, w.uint32());
            break;
          case 2:
            s.nonexist = e.NonExistenceProof.decode(w, w.uint32());
            break;
          case 3:
            s.batch = e.BatchProof.decode(w, w.uint32());
            break;
          case 4:
            s.compressed = e.CompressedBatchProof.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        exist: (0, m.isSet)(n.exist) ? e.ExistenceProof.fromJSON(n.exist) : void 0,
        nonexist: (0, m.isSet)(n.nonexist) ? e.NonExistenceProof.fromJSON(n.nonexist) : void 0,
        batch: (0, m.isSet)(n.batch) ? e.BatchProof.fromJSON(n.batch) : void 0,
        compressed: (0, m.isSet)(n.compressed) ? e.CompressedBatchProof.fromJSON(n.compressed) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.exist !== void 0 && (y.exist = n.exist ? e.ExistenceProof.toJSON(n.exist) : void 0), n.nonexist !== void 0 && (y.nonexist = n.nonexist ? e.NonExistenceProof.toJSON(n.nonexist) : void 0), n.batch !== void 0 && (y.batch = n.batch ? e.BatchProof.toJSON(n.batch) : void 0), n.compressed !== void 0 && (y.compressed = n.compressed ? e.CompressedBatchProof.toJSON(n.compressed) : void 0), y;
    },
    fromPartial(n) {
      const y = C();
      return y.exist = n.exist !== void 0 && n.exist !== null ? e.ExistenceProof.fromPartial(n.exist) : void 0, y.nonexist = n.nonexist !== void 0 && n.nonexist !== null ? e.NonExistenceProof.fromPartial(n.nonexist) : void 0, y.batch = n.batch !== void 0 && n.batch !== null ? e.BatchProof.fromPartial(n.batch) : void 0, y.compressed = n.compressed !== void 0 && n.compressed !== null ? e.CompressedBatchProof.fromPartial(n.compressed) : void 0, y;
    }
  };
  function l() {
    return {
      hash: 0,
      prehashKey: 0,
      prehashValue: 0,
      length: 0,
      prefix: new Uint8Array()
    };
  }
  e.LeafOp = {
    encode(n, y = r.Writer.create()) {
      return n.hash !== 0 && y.uint32(8).int32(n.hash), n.prehashKey !== 0 && y.uint32(16).int32(n.prehashKey), n.prehashValue !== 0 && y.uint32(24).int32(n.prehashValue), n.length !== 0 && y.uint32(32).int32(n.length), n.prefix.length !== 0 && y.uint32(42).bytes(n.prefix), y;
    },
    decode(n, y) {
      const w = n instanceof r.Reader ? n : new r.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = l();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.hash = w.int32();
            break;
          case 2:
            s.prehashKey = w.int32();
            break;
          case 3:
            s.prehashValue = w.int32();
            break;
          case 4:
            s.length = w.int32();
            break;
          case 5:
            s.prefix = w.bytes();
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        hash: (0, m.isSet)(n.hash) ? b(n.hash) : 0,
        prehashKey: (0, m.isSet)(n.prehashKey) ? b(n.prehashKey) : 0,
        prehashValue: (0, m.isSet)(n.prehashValue) ? b(n.prehashValue) : 0,
        length: (0, m.isSet)(n.length) ? V(n.length) : 0,
        prefix: (0, m.isSet)(n.prefix) ? (0, m.bytesFromBase64)(n.prefix) : new Uint8Array()
      };
    },
    toJSON(n) {
      const y = {};
      return n.hash !== void 0 && (y.hash = R(n.hash)), n.prehashKey !== void 0 && (y.prehashKey = R(n.prehashKey)), n.prehashValue !== void 0 && (y.prehashValue = R(n.prehashValue)), n.length !== void 0 && (y.length = D(n.length)), n.prefix !== void 0 && (y.prefix = (0, m.base64FromBytes)(n.prefix !== void 0 ? n.prefix : new Uint8Array())), y;
    },
    fromPartial(n) {
      const y = l();
      return y.hash = n.hash ?? 0, y.prehashKey = n.prehashKey ?? 0, y.prehashValue = n.prehashValue ?? 0, y.length = n.length ?? 0, y.prefix = n.prefix ?? new Uint8Array(), y;
    }
  };
  function S() {
    return {
      hash: 0,
      prefix: new Uint8Array(),
      suffix: new Uint8Array()
    };
  }
  e.InnerOp = {
    encode(n, y = r.Writer.create()) {
      return n.hash !== 0 && y.uint32(8).int32(n.hash), n.prefix.length !== 0 && y.uint32(18).bytes(n.prefix), n.suffix.length !== 0 && y.uint32(26).bytes(n.suffix), y;
    },
    decode(n, y) {
      const w = n instanceof r.Reader ? n : new r.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = S();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.hash = w.int32();
            break;
          case 2:
            s.prefix = w.bytes();
            break;
          case 3:
            s.suffix = w.bytes();
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        hash: (0, m.isSet)(n.hash) ? b(n.hash) : 0,
        prefix: (0, m.isSet)(n.prefix) ? (0, m.bytesFromBase64)(n.prefix) : new Uint8Array(),
        suffix: (0, m.isSet)(n.suffix) ? (0, m.bytesFromBase64)(n.suffix) : new Uint8Array()
      };
    },
    toJSON(n) {
      const y = {};
      return n.hash !== void 0 && (y.hash = R(n.hash)), n.prefix !== void 0 && (y.prefix = (0, m.base64FromBytes)(n.prefix !== void 0 ? n.prefix : new Uint8Array())), n.suffix !== void 0 && (y.suffix = (0, m.base64FromBytes)(n.suffix !== void 0 ? n.suffix : new Uint8Array())), y;
    },
    fromPartial(n) {
      const y = S();
      return y.hash = n.hash ?? 0, y.prefix = n.prefix ?? new Uint8Array(), y.suffix = n.suffix ?? new Uint8Array(), y;
    }
  };
  function A() {
    return {
      leafSpec: void 0,
      innerSpec: void 0,
      maxDepth: 0,
      minDepth: 0
    };
  }
  e.ProofSpec = {
    encode(n, y = r.Writer.create()) {
      return n.leafSpec !== void 0 && e.LeafOp.encode(n.leafSpec, y.uint32(10).fork()).ldelim(), n.innerSpec !== void 0 && e.InnerSpec.encode(n.innerSpec, y.uint32(18).fork()).ldelim(), n.maxDepth !== 0 && y.uint32(24).int32(n.maxDepth), n.minDepth !== 0 && y.uint32(32).int32(n.minDepth), y;
    },
    decode(n, y) {
      const w = n instanceof r.Reader ? n : new r.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = A();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.leafSpec = e.LeafOp.decode(w, w.uint32());
            break;
          case 2:
            s.innerSpec = e.InnerSpec.decode(w, w.uint32());
            break;
          case 3:
            s.maxDepth = w.int32();
            break;
          case 4:
            s.minDepth = w.int32();
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        leafSpec: (0, m.isSet)(n.leafSpec) ? e.LeafOp.fromJSON(n.leafSpec) : void 0,
        innerSpec: (0, m.isSet)(n.innerSpec) ? e.InnerSpec.fromJSON(n.innerSpec) : void 0,
        maxDepth: (0, m.isSet)(n.maxDepth) ? Number(n.maxDepth) : 0,
        minDepth: (0, m.isSet)(n.minDepth) ? Number(n.minDepth) : 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.leafSpec !== void 0 && (y.leafSpec = n.leafSpec ? e.LeafOp.toJSON(n.leafSpec) : void 0), n.innerSpec !== void 0 && (y.innerSpec = n.innerSpec ? e.InnerSpec.toJSON(n.innerSpec) : void 0), n.maxDepth !== void 0 && (y.maxDepth = Math.round(n.maxDepth)), n.minDepth !== void 0 && (y.minDepth = Math.round(n.minDepth)), y;
    },
    fromPartial(n) {
      const y = A();
      return y.leafSpec = n.leafSpec !== void 0 && n.leafSpec !== null ? e.LeafOp.fromPartial(n.leafSpec) : void 0, y.innerSpec = n.innerSpec !== void 0 && n.innerSpec !== null ? e.InnerSpec.fromPartial(n.innerSpec) : void 0, y.maxDepth = n.maxDepth ?? 0, y.minDepth = n.minDepth ?? 0, y;
    }
  };
  function d() {
    return {
      childOrder: [],
      childSize: 0,
      minPrefixLength: 0,
      maxPrefixLength: 0,
      emptyChild: new Uint8Array(),
      hash: 0
    };
  }
  e.InnerSpec = {
    encode(n, y = r.Writer.create()) {
      y.uint32(10).fork();
      for (const w of n.childOrder)
        y.int32(w);
      return y.ldelim(), n.childSize !== 0 && y.uint32(16).int32(n.childSize), n.minPrefixLength !== 0 && y.uint32(24).int32(n.minPrefixLength), n.maxPrefixLength !== 0 && y.uint32(32).int32(n.maxPrefixLength), n.emptyChild.length !== 0 && y.uint32(42).bytes(n.emptyChild), n.hash !== 0 && y.uint32(48).int32(n.hash), y;
    },
    decode(n, y) {
      const w = n instanceof r.Reader ? n : new r.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = d();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            if ((c & 7) === 2) {
              const E = w.uint32() + w.pos;
              for (; w.pos < E; )
                s.childOrder.push(w.int32());
            } else
              s.childOrder.push(w.int32());
            break;
          case 2:
            s.childSize = w.int32();
            break;
          case 3:
            s.minPrefixLength = w.int32();
            break;
          case 4:
            s.maxPrefixLength = w.int32();
            break;
          case 5:
            s.emptyChild = w.bytes();
            break;
          case 6:
            s.hash = w.int32();
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        childOrder: Array.isArray(n == null ? void 0 : n.childOrder) ? n.childOrder.map((y) => Number(y)) : [],
        childSize: (0, m.isSet)(n.childSize) ? Number(n.childSize) : 0,
        minPrefixLength: (0, m.isSet)(n.minPrefixLength) ? Number(n.minPrefixLength) : 0,
        maxPrefixLength: (0, m.isSet)(n.maxPrefixLength) ? Number(n.maxPrefixLength) : 0,
        emptyChild: (0, m.isSet)(n.emptyChild) ? (0, m.bytesFromBase64)(n.emptyChild) : new Uint8Array(),
        hash: (0, m.isSet)(n.hash) ? b(n.hash) : 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.childOrder ? y.childOrder = n.childOrder.map((w) => Math.round(w)) : y.childOrder = [], n.childSize !== void 0 && (y.childSize = Math.round(n.childSize)), n.minPrefixLength !== void 0 && (y.minPrefixLength = Math.round(n.minPrefixLength)), n.maxPrefixLength !== void 0 && (y.maxPrefixLength = Math.round(n.maxPrefixLength)), n.emptyChild !== void 0 && (y.emptyChild = (0, m.base64FromBytes)(n.emptyChild !== void 0 ? n.emptyChild : new Uint8Array())), n.hash !== void 0 && (y.hash = R(n.hash)), y;
    },
    fromPartial(n) {
      var y;
      const w = d();
      return w.childOrder = ((y = n.childOrder) == null ? void 0 : y.map((M) => M)) || [], w.childSize = n.childSize ?? 0, w.minPrefixLength = n.minPrefixLength ?? 0, w.maxPrefixLength = n.maxPrefixLength ?? 0, w.emptyChild = n.emptyChild ?? new Uint8Array(), w.hash = n.hash ?? 0, w;
    }
  };
  function p() {
    return {
      entries: []
    };
  }
  e.BatchProof = {
    encode(n, y = r.Writer.create()) {
      for (const w of n.entries)
        e.BatchEntry.encode(w, y.uint32(10).fork()).ldelim();
      return y;
    },
    decode(n, y) {
      const w = n instanceof r.Reader ? n : new r.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = p();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.entries.push(e.BatchEntry.decode(w, w.uint32()));
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        entries: Array.isArray(n == null ? void 0 : n.entries) ? n.entries.map((y) => e.BatchEntry.fromJSON(y)) : []
      };
    },
    toJSON(n) {
      const y = {};
      return n.entries ? y.entries = n.entries.map((w) => w ? e.BatchEntry.toJSON(w) : void 0) : y.entries = [], y;
    },
    fromPartial(n) {
      var y;
      const w = p();
      return w.entries = ((y = n.entries) == null ? void 0 : y.map((M) => e.BatchEntry.fromPartial(M))) || [], w;
    }
  };
  function h() {
    return {
      exist: void 0,
      nonexist: void 0
    };
  }
  e.BatchEntry = {
    encode(n, y = r.Writer.create()) {
      return n.exist !== void 0 && e.ExistenceProof.encode(n.exist, y.uint32(10).fork()).ldelim(), n.nonexist !== void 0 && e.NonExistenceProof.encode(n.nonexist, y.uint32(18).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof r.Reader ? n : new r.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = h();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.exist = e.ExistenceProof.decode(w, w.uint32());
            break;
          case 2:
            s.nonexist = e.NonExistenceProof.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        exist: (0, m.isSet)(n.exist) ? e.ExistenceProof.fromJSON(n.exist) : void 0,
        nonexist: (0, m.isSet)(n.nonexist) ? e.NonExistenceProof.fromJSON(n.nonexist) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.exist !== void 0 && (y.exist = n.exist ? e.ExistenceProof.toJSON(n.exist) : void 0), n.nonexist !== void 0 && (y.nonexist = n.nonexist ? e.NonExistenceProof.toJSON(n.nonexist) : void 0), y;
    },
    fromPartial(n) {
      const y = h();
      return y.exist = n.exist !== void 0 && n.exist !== null ? e.ExistenceProof.fromPartial(n.exist) : void 0, y.nonexist = n.nonexist !== void 0 && n.nonexist !== null ? e.NonExistenceProof.fromPartial(n.nonexist) : void 0, y;
    }
  };
  function x() {
    return {
      entries: [],
      lookupInners: []
    };
  }
  e.CompressedBatchProof = {
    encode(n, y = r.Writer.create()) {
      for (const w of n.entries)
        e.CompressedBatchEntry.encode(w, y.uint32(10).fork()).ldelim();
      for (const w of n.lookupInners)
        e.InnerOp.encode(w, y.uint32(18).fork()).ldelim();
      return y;
    },
    decode(n, y) {
      const w = n instanceof r.Reader ? n : new r.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = x();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.entries.push(e.CompressedBatchEntry.decode(w, w.uint32()));
            break;
          case 2:
            s.lookupInners.push(e.InnerOp.decode(w, w.uint32()));
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        entries: Array.isArray(n == null ? void 0 : n.entries) ? n.entries.map((y) => e.CompressedBatchEntry.fromJSON(y)) : [],
        lookupInners: Array.isArray(n == null ? void 0 : n.lookupInners) ? n.lookupInners.map((y) => e.InnerOp.fromJSON(y)) : []
      };
    },
    toJSON(n) {
      const y = {};
      return n.entries ? y.entries = n.entries.map((w) => w ? e.CompressedBatchEntry.toJSON(w) : void 0) : y.entries = [], n.lookupInners ? y.lookupInners = n.lookupInners.map((w) => w ? e.InnerOp.toJSON(w) : void 0) : y.lookupInners = [], y;
    },
    fromPartial(n) {
      var y, w;
      const M = x();
      return M.entries = ((y = n.entries) == null ? void 0 : y.map((s) => e.CompressedBatchEntry.fromPartial(s))) || [], M.lookupInners = ((w = n.lookupInners) == null ? void 0 : w.map((s) => e.InnerOp.fromPartial(s))) || [], M;
    }
  };
  function _() {
    return {
      exist: void 0,
      nonexist: void 0
    };
  }
  e.CompressedBatchEntry = {
    encode(n, y = r.Writer.create()) {
      return n.exist !== void 0 && e.CompressedExistenceProof.encode(n.exist, y.uint32(10).fork()).ldelim(), n.nonexist !== void 0 && e.CompressedNonExistenceProof.encode(n.nonexist, y.uint32(18).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof r.Reader ? n : new r.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = _();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.exist = e.CompressedExistenceProof.decode(w, w.uint32());
            break;
          case 2:
            s.nonexist = e.CompressedNonExistenceProof.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        exist: (0, m.isSet)(n.exist) ? e.CompressedExistenceProof.fromJSON(n.exist) : void 0,
        nonexist: (0, m.isSet)(n.nonexist) ? e.CompressedNonExistenceProof.fromJSON(n.nonexist) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.exist !== void 0 && (y.exist = n.exist ? e.CompressedExistenceProof.toJSON(n.exist) : void 0), n.nonexist !== void 0 && (y.nonexist = n.nonexist ? e.CompressedNonExistenceProof.toJSON(n.nonexist) : void 0), y;
    },
    fromPartial(n) {
      const y = _();
      return y.exist = n.exist !== void 0 && n.exist !== null ? e.CompressedExistenceProof.fromPartial(n.exist) : void 0, y.nonexist = n.nonexist !== void 0 && n.nonexist !== null ? e.CompressedNonExistenceProof.fromPartial(n.nonexist) : void 0, y;
    }
  };
  function I() {
    return {
      key: new Uint8Array(),
      value: new Uint8Array(),
      leaf: void 0,
      path: []
    };
  }
  e.CompressedExistenceProof = {
    encode(n, y = r.Writer.create()) {
      n.key.length !== 0 && y.uint32(10).bytes(n.key), n.value.length !== 0 && y.uint32(18).bytes(n.value), n.leaf !== void 0 && e.LeafOp.encode(n.leaf, y.uint32(26).fork()).ldelim(), y.uint32(34).fork();
      for (const w of n.path)
        y.int32(w);
      return y.ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof r.Reader ? n : new r.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = I();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.key = w.bytes();
            break;
          case 2:
            s.value = w.bytes();
            break;
          case 3:
            s.leaf = e.LeafOp.decode(w, w.uint32());
            break;
          case 4:
            if ((c & 7) === 2) {
              const E = w.uint32() + w.pos;
              for (; w.pos < E; )
                s.path.push(w.int32());
            } else
              s.path.push(w.int32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        key: (0, m.isSet)(n.key) ? (0, m.bytesFromBase64)(n.key) : new Uint8Array(),
        value: (0, m.isSet)(n.value) ? (0, m.bytesFromBase64)(n.value) : new Uint8Array(),
        leaf: (0, m.isSet)(n.leaf) ? e.LeafOp.fromJSON(n.leaf) : void 0,
        path: Array.isArray(n == null ? void 0 : n.path) ? n.path.map((y) => Number(y)) : []
      };
    },
    toJSON(n) {
      const y = {};
      return n.key !== void 0 && (y.key = (0, m.base64FromBytes)(n.key !== void 0 ? n.key : new Uint8Array())), n.value !== void 0 && (y.value = (0, m.base64FromBytes)(n.value !== void 0 ? n.value : new Uint8Array())), n.leaf !== void 0 && (y.leaf = n.leaf ? e.LeafOp.toJSON(n.leaf) : void 0), n.path ? y.path = n.path.map((w) => Math.round(w)) : y.path = [], y;
    },
    fromPartial(n) {
      var y;
      const w = I();
      return w.key = n.key ?? new Uint8Array(), w.value = n.value ?? new Uint8Array(), w.leaf = n.leaf !== void 0 && n.leaf !== null ? e.LeafOp.fromPartial(n.leaf) : void 0, w.path = ((y = n.path) == null ? void 0 : y.map((M) => M)) || [], w;
    }
  };
  function W() {
    return {
      key: new Uint8Array(),
      left: void 0,
      right: void 0
    };
  }
  e.CompressedNonExistenceProof = {
    encode(n, y = r.Writer.create()) {
      return n.key.length !== 0 && y.uint32(10).bytes(n.key), n.left !== void 0 && e.CompressedExistenceProof.encode(n.left, y.uint32(18).fork()).ldelim(), n.right !== void 0 && e.CompressedExistenceProof.encode(n.right, y.uint32(26).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof r.Reader ? n : new r.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = W();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.key = w.bytes();
            break;
          case 2:
            s.left = e.CompressedExistenceProof.decode(w, w.uint32());
            break;
          case 3:
            s.right = e.CompressedExistenceProof.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        key: (0, m.isSet)(n.key) ? (0, m.bytesFromBase64)(n.key) : new Uint8Array(),
        left: (0, m.isSet)(n.left) ? e.CompressedExistenceProof.fromJSON(n.left) : void 0,
        right: (0, m.isSet)(n.right) ? e.CompressedExistenceProof.fromJSON(n.right) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.key !== void 0 && (y.key = (0, m.base64FromBytes)(n.key !== void 0 ? n.key : new Uint8Array())), n.left !== void 0 && (y.left = n.left ? e.CompressedExistenceProof.toJSON(n.left) : void 0), n.right !== void 0 && (y.right = n.right ? e.CompressedExistenceProof.toJSON(n.right) : void 0), y;
    },
    fromPartial(n) {
      const y = W();
      return y.key = n.key ?? new Uint8Array(), y.left = n.left !== void 0 && n.left !== null ? e.CompressedExistenceProof.fromPartial(n.left) : void 0, y.right = n.right !== void 0 && n.right !== null ? e.CompressedExistenceProof.fromPartial(n.right) : void 0, y;
    }
  };
})($i);
var Cm = Q && Q.__createBinding || (Object.create ? function(e, o, t, u) {
  u === void 0 && (u = t);
  var r = Object.getOwnPropertyDescriptor(o, t);
  (!r || ("get" in r ? !o.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return o[t];
  } }), Object.defineProperty(e, u, r);
} : function(e, o, t, u) {
  u === void 0 && (u = t), e[u] = o[t];
}), Im = Q && Q.__setModuleDefault || (Object.create ? function(e, o) {
  Object.defineProperty(e, "default", { enumerable: !0, value: o });
} : function(e, o) {
  e.default = o;
}), xm = Q && Q.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var o = {};
  if (e != null)
    for (var t in e)
      t !== "default" && Object.prototype.hasOwnProperty.call(e, t) && Cm(o, e, t);
  return Im(o, e), o;
};
Object.defineProperty(Xe, "__esModule", { value: !0 });
Xe.MerkleProof = Xe.MerklePath = Xe.MerklePrefix = Xe.MerkleRoot = Xe.protobufPackage = void 0;
const qn = $i, ut = xm(re), Sn = ie;
Xe.protobufPackage = "ibc.core.commitment.v1";
function Ea() {
  return {
    hash: new Uint8Array()
  };
}
Xe.MerkleRoot = {
  encode(e, o = ut.Writer.create()) {
    return e.hash.length !== 0 && o.uint32(10).bytes(e.hash), o;
  },
  decode(e, o) {
    const t = e instanceof ut.Reader ? e : new ut.Reader(e);
    let u = o === void 0 ? t.len : t.pos + o;
    const r = Ea();
    for (; t.pos < u; ) {
      const m = t.uint32();
      switch (m >>> 3) {
        case 1:
          r.hash = t.bytes();
          break;
        default:
          t.skipType(m & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      hash: (0, Sn.isSet)(e.hash) ? (0, Sn.bytesFromBase64)(e.hash) : new Uint8Array()
    };
  },
  toJSON(e) {
    const o = {};
    return e.hash !== void 0 && (o.hash = (0, Sn.base64FromBytes)(e.hash !== void 0 ? e.hash : new Uint8Array())), o;
  },
  fromPartial(e) {
    const o = Ea();
    return o.hash = e.hash ?? new Uint8Array(), o;
  }
};
function Ta() {
  return {
    keyPrefix: new Uint8Array()
  };
}
Xe.MerklePrefix = {
  encode(e, o = ut.Writer.create()) {
    return e.keyPrefix.length !== 0 && o.uint32(10).bytes(e.keyPrefix), o;
  },
  decode(e, o) {
    const t = e instanceof ut.Reader ? e : new ut.Reader(e);
    let u = o === void 0 ? t.len : t.pos + o;
    const r = Ta();
    for (; t.pos < u; ) {
      const m = t.uint32();
      switch (m >>> 3) {
        case 1:
          r.keyPrefix = t.bytes();
          break;
        default:
          t.skipType(m & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      keyPrefix: (0, Sn.isSet)(e.keyPrefix) ? (0, Sn.bytesFromBase64)(e.keyPrefix) : new Uint8Array()
    };
  },
  toJSON(e) {
    const o = {};
    return e.keyPrefix !== void 0 && (o.keyPrefix = (0, Sn.base64FromBytes)(e.keyPrefix !== void 0 ? e.keyPrefix : new Uint8Array())), o;
  },
  fromPartial(e) {
    const o = Ta();
    return o.keyPrefix = e.keyPrefix ?? new Uint8Array(), o;
  }
};
function Ca() {
  return {
    keyPath: []
  };
}
Xe.MerklePath = {
  encode(e, o = ut.Writer.create()) {
    for (const t of e.keyPath)
      o.uint32(10).string(t);
    return o;
  },
  decode(e, o) {
    const t = e instanceof ut.Reader ? e : new ut.Reader(e);
    let u = o === void 0 ? t.len : t.pos + o;
    const r = Ca();
    for (; t.pos < u; ) {
      const m = t.uint32();
      switch (m >>> 3) {
        case 1:
          r.keyPath.push(t.string());
          break;
        default:
          t.skipType(m & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      keyPath: Array.isArray(e == null ? void 0 : e.keyPath) ? e.keyPath.map((o) => String(o)) : []
    };
  },
  toJSON(e) {
    const o = {};
    return e.keyPath ? o.keyPath = e.keyPath.map((t) => t) : o.keyPath = [], o;
  },
  fromPartial(e) {
    var o;
    const t = Ca();
    return t.keyPath = ((o = e.keyPath) == null ? void 0 : o.map((u) => u)) || [], t;
  }
};
function Ia() {
  return {
    proofs: []
  };
}
Xe.MerkleProof = {
  encode(e, o = ut.Writer.create()) {
    for (const t of e.proofs)
      qn.CommitmentProof.encode(t, o.uint32(10).fork()).ldelim();
    return o;
  },
  decode(e, o) {
    const t = e instanceof ut.Reader ? e : new ut.Reader(e);
    let u = o === void 0 ? t.len : t.pos + o;
    const r = Ia();
    for (; t.pos < u; ) {
      const m = t.uint32();
      switch (m >>> 3) {
        case 1:
          r.proofs.push(qn.CommitmentProof.decode(t, t.uint32()));
          break;
        default:
          t.skipType(m & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      proofs: Array.isArray(e == null ? void 0 : e.proofs) ? e.proofs.map((o) => qn.CommitmentProof.fromJSON(o)) : []
    };
  },
  toJSON(e) {
    const o = {};
    return e.proofs ? o.proofs = e.proofs.map((t) => t ? qn.CommitmentProof.toJSON(t) : void 0) : o.proofs = [], o;
  },
  fromPartial(e) {
    var o;
    const t = Ia();
    return t.proofs = ((o = e.proofs) == null ? void 0 : o.map((u) => qn.CommitmentProof.fromPartial(u))) || [], t;
  }
};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(A, d, p, h) {
    h === void 0 && (h = p);
    var x = Object.getOwnPropertyDescriptor(d, p);
    (!x || ("get" in x ? !d.__esModule : x.writable || x.configurable)) && (x = { enumerable: !0, get: function() {
      return d[p];
    } }), Object.defineProperty(A, h, x);
  } : function(A, d, p, h) {
    h === void 0 && (h = p), A[h] = d[p];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(A, d) {
    Object.defineProperty(A, "default", { enumerable: !0, value: d });
  } : function(A, d) {
    A.default = d;
  }), u = Q && Q.__importStar || function(A) {
    if (A && A.__esModule)
      return A;
    var d = {};
    if (A != null)
      for (var p in A)
        p !== "default" && Object.prototype.hasOwnProperty.call(A, p) && o(d, A, p);
    return t(d, A), d;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Params = e.Version = e.ConnectionPaths = e.ClientPaths = e.Counterparty = e.IdentifiedConnection = e.ConnectionEnd = e.stateToJSON = e.stateFromJSON = e.State = e.protobufPackage = void 0;
  const r = Xe, m = ie, f = u(re);
  e.protobufPackage = "ibc.core.connection.v1";
  var b;
  (function(A) {
    A[A.STATE_UNINITIALIZED_UNSPECIFIED = 0] = "STATE_UNINITIALIZED_UNSPECIFIED", A[A.STATE_INIT = 1] = "STATE_INIT", A[A.STATE_TRYOPEN = 2] = "STATE_TRYOPEN", A[A.STATE_OPEN = 3] = "STATE_OPEN", A[A.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(b = e.State || (e.State = {}));
  function R(A) {
    switch (A) {
      case 0:
      case "STATE_UNINITIALIZED_UNSPECIFIED":
        return b.STATE_UNINITIALIZED_UNSPECIFIED;
      case 1:
      case "STATE_INIT":
        return b.STATE_INIT;
      case 2:
      case "STATE_TRYOPEN":
        return b.STATE_TRYOPEN;
      case 3:
      case "STATE_OPEN":
        return b.STATE_OPEN;
      case -1:
      case "UNRECOGNIZED":
      default:
        return b.UNRECOGNIZED;
    }
  }
  e.stateFromJSON = R;
  function T(A) {
    switch (A) {
      case b.STATE_UNINITIALIZED_UNSPECIFIED:
        return "STATE_UNINITIALIZED_UNSPECIFIED";
      case b.STATE_INIT:
        return "STATE_INIT";
      case b.STATE_TRYOPEN:
        return "STATE_TRYOPEN";
      case b.STATE_OPEN:
        return "STATE_OPEN";
      case b.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.stateToJSON = T;
  function V() {
    return {
      clientId: "",
      versions: [],
      state: 0,
      counterparty: void 0,
      delayPeriod: m.Long.UZERO
    };
  }
  e.ConnectionEnd = {
    encode(A, d = f.Writer.create()) {
      A.clientId !== "" && d.uint32(10).string(A.clientId);
      for (const p of A.versions)
        e.Version.encode(p, d.uint32(18).fork()).ldelim();
      return A.state !== 0 && d.uint32(24).int32(A.state), A.counterparty !== void 0 && e.Counterparty.encode(A.counterparty, d.uint32(34).fork()).ldelim(), A.delayPeriod.isZero() || d.uint32(40).uint64(A.delayPeriod), d;
    },
    decode(A, d) {
      const p = A instanceof f.Reader ? A : new f.Reader(A);
      let h = d === void 0 ? p.len : p.pos + d;
      const x = V();
      for (; p.pos < h; ) {
        const _ = p.uint32();
        switch (_ >>> 3) {
          case 1:
            x.clientId = p.string();
            break;
          case 2:
            x.versions.push(e.Version.decode(p, p.uint32()));
            break;
          case 3:
            x.state = p.int32();
            break;
          case 4:
            x.counterparty = e.Counterparty.decode(p, p.uint32());
            break;
          case 5:
            x.delayPeriod = p.uint64();
            break;
          default:
            p.skipType(_ & 7);
            break;
        }
      }
      return x;
    },
    fromJSON(A) {
      return {
        clientId: (0, m.isSet)(A.clientId) ? String(A.clientId) : "",
        versions: Array.isArray(A == null ? void 0 : A.versions) ? A.versions.map((d) => e.Version.fromJSON(d)) : [],
        state: (0, m.isSet)(A.state) ? R(A.state) : 0,
        counterparty: (0, m.isSet)(A.counterparty) ? e.Counterparty.fromJSON(A.counterparty) : void 0,
        delayPeriod: (0, m.isSet)(A.delayPeriod) ? m.Long.fromValue(A.delayPeriod) : m.Long.UZERO
      };
    },
    toJSON(A) {
      const d = {};
      return A.clientId !== void 0 && (d.clientId = A.clientId), A.versions ? d.versions = A.versions.map((p) => p ? e.Version.toJSON(p) : void 0) : d.versions = [], A.state !== void 0 && (d.state = T(A.state)), A.counterparty !== void 0 && (d.counterparty = A.counterparty ? e.Counterparty.toJSON(A.counterparty) : void 0), A.delayPeriod !== void 0 && (d.delayPeriod = (A.delayPeriod || m.Long.UZERO).toString()), d;
    },
    fromPartial(A) {
      var d;
      const p = V();
      return p.clientId = A.clientId ?? "", p.versions = ((d = A.versions) == null ? void 0 : d.map((h) => e.Version.fromPartial(h))) || [], p.state = A.state ?? 0, p.counterparty = A.counterparty !== void 0 && A.counterparty !== null ? e.Counterparty.fromPartial(A.counterparty) : void 0, p.delayPeriod = A.delayPeriod !== void 0 && A.delayPeriod !== null ? m.Long.fromValue(A.delayPeriod) : m.Long.UZERO, p;
    }
  };
  function D() {
    return {
      id: "",
      clientId: "",
      versions: [],
      state: 0,
      counterparty: void 0,
      delayPeriod: m.Long.UZERO
    };
  }
  e.IdentifiedConnection = {
    encode(A, d = f.Writer.create()) {
      A.id !== "" && d.uint32(10).string(A.id), A.clientId !== "" && d.uint32(18).string(A.clientId);
      for (const p of A.versions)
        e.Version.encode(p, d.uint32(26).fork()).ldelim();
      return A.state !== 0 && d.uint32(32).int32(A.state), A.counterparty !== void 0 && e.Counterparty.encode(A.counterparty, d.uint32(42).fork()).ldelim(), A.delayPeriod.isZero() || d.uint32(48).uint64(A.delayPeriod), d;
    },
    decode(A, d) {
      const p = A instanceof f.Reader ? A : new f.Reader(A);
      let h = d === void 0 ? p.len : p.pos + d;
      const x = D();
      for (; p.pos < h; ) {
        const _ = p.uint32();
        switch (_ >>> 3) {
          case 1:
            x.id = p.string();
            break;
          case 2:
            x.clientId = p.string();
            break;
          case 3:
            x.versions.push(e.Version.decode(p, p.uint32()));
            break;
          case 4:
            x.state = p.int32();
            break;
          case 5:
            x.counterparty = e.Counterparty.decode(p, p.uint32());
            break;
          case 6:
            x.delayPeriod = p.uint64();
            break;
          default:
            p.skipType(_ & 7);
            break;
        }
      }
      return x;
    },
    fromJSON(A) {
      return {
        id: (0, m.isSet)(A.id) ? String(A.id) : "",
        clientId: (0, m.isSet)(A.clientId) ? String(A.clientId) : "",
        versions: Array.isArray(A == null ? void 0 : A.versions) ? A.versions.map((d) => e.Version.fromJSON(d)) : [],
        state: (0, m.isSet)(A.state) ? R(A.state) : 0,
        counterparty: (0, m.isSet)(A.counterparty) ? e.Counterparty.fromJSON(A.counterparty) : void 0,
        delayPeriod: (0, m.isSet)(A.delayPeriod) ? m.Long.fromValue(A.delayPeriod) : m.Long.UZERO
      };
    },
    toJSON(A) {
      const d = {};
      return A.id !== void 0 && (d.id = A.id), A.clientId !== void 0 && (d.clientId = A.clientId), A.versions ? d.versions = A.versions.map((p) => p ? e.Version.toJSON(p) : void 0) : d.versions = [], A.state !== void 0 && (d.state = T(A.state)), A.counterparty !== void 0 && (d.counterparty = A.counterparty ? e.Counterparty.toJSON(A.counterparty) : void 0), A.delayPeriod !== void 0 && (d.delayPeriod = (A.delayPeriod || m.Long.UZERO).toString()), d;
    },
    fromPartial(A) {
      var d;
      const p = D();
      return p.id = A.id ?? "", p.clientId = A.clientId ?? "", p.versions = ((d = A.versions) == null ? void 0 : d.map((h) => e.Version.fromPartial(h))) || [], p.state = A.state ?? 0, p.counterparty = A.counterparty !== void 0 && A.counterparty !== null ? e.Counterparty.fromPartial(A.counterparty) : void 0, p.delayPeriod = A.delayPeriod !== void 0 && A.delayPeriod !== null ? m.Long.fromValue(A.delayPeriod) : m.Long.UZERO, p;
    }
  };
  function B() {
    return {
      clientId: "",
      connectionId: "",
      prefix: void 0
    };
  }
  e.Counterparty = {
    encode(A, d = f.Writer.create()) {
      return A.clientId !== "" && d.uint32(10).string(A.clientId), A.connectionId !== "" && d.uint32(18).string(A.connectionId), A.prefix !== void 0 && r.MerklePrefix.encode(A.prefix, d.uint32(26).fork()).ldelim(), d;
    },
    decode(A, d) {
      const p = A instanceof f.Reader ? A : new f.Reader(A);
      let h = d === void 0 ? p.len : p.pos + d;
      const x = B();
      for (; p.pos < h; ) {
        const _ = p.uint32();
        switch (_ >>> 3) {
          case 1:
            x.clientId = p.string();
            break;
          case 2:
            x.connectionId = p.string();
            break;
          case 3:
            x.prefix = r.MerklePrefix.decode(p, p.uint32());
            break;
          default:
            p.skipType(_ & 7);
            break;
        }
      }
      return x;
    },
    fromJSON(A) {
      return {
        clientId: (0, m.isSet)(A.clientId) ? String(A.clientId) : "",
        connectionId: (0, m.isSet)(A.connectionId) ? String(A.connectionId) : "",
        prefix: (0, m.isSet)(A.prefix) ? r.MerklePrefix.fromJSON(A.prefix) : void 0
      };
    },
    toJSON(A) {
      const d = {};
      return A.clientId !== void 0 && (d.clientId = A.clientId), A.connectionId !== void 0 && (d.connectionId = A.connectionId), A.prefix !== void 0 && (d.prefix = A.prefix ? r.MerklePrefix.toJSON(A.prefix) : void 0), d;
    },
    fromPartial(A) {
      const d = B();
      return d.clientId = A.clientId ?? "", d.connectionId = A.connectionId ?? "", d.prefix = A.prefix !== void 0 && A.prefix !== null ? r.MerklePrefix.fromPartial(A.prefix) : void 0, d;
    }
  };
  function U() {
    return {
      paths: []
    };
  }
  e.ClientPaths = {
    encode(A, d = f.Writer.create()) {
      for (const p of A.paths)
        d.uint32(10).string(p);
      return d;
    },
    decode(A, d) {
      const p = A instanceof f.Reader ? A : new f.Reader(A);
      let h = d === void 0 ? p.len : p.pos + d;
      const x = U();
      for (; p.pos < h; ) {
        const _ = p.uint32();
        switch (_ >>> 3) {
          case 1:
            x.paths.push(p.string());
            break;
          default:
            p.skipType(_ & 7);
            break;
        }
      }
      return x;
    },
    fromJSON(A) {
      return {
        paths: Array.isArray(A == null ? void 0 : A.paths) ? A.paths.map((d) => String(d)) : []
      };
    },
    toJSON(A) {
      const d = {};
      return A.paths ? d.paths = A.paths.map((p) => p) : d.paths = [], d;
    },
    fromPartial(A) {
      var d;
      const p = U();
      return p.paths = ((d = A.paths) == null ? void 0 : d.map((h) => h)) || [], p;
    }
  };
  function C() {
    return {
      clientId: "",
      paths: []
    };
  }
  e.ConnectionPaths = {
    encode(A, d = f.Writer.create()) {
      A.clientId !== "" && d.uint32(10).string(A.clientId);
      for (const p of A.paths)
        d.uint32(18).string(p);
      return d;
    },
    decode(A, d) {
      const p = A instanceof f.Reader ? A : new f.Reader(A);
      let h = d === void 0 ? p.len : p.pos + d;
      const x = C();
      for (; p.pos < h; ) {
        const _ = p.uint32();
        switch (_ >>> 3) {
          case 1:
            x.clientId = p.string();
            break;
          case 2:
            x.paths.push(p.string());
            break;
          default:
            p.skipType(_ & 7);
            break;
        }
      }
      return x;
    },
    fromJSON(A) {
      return {
        clientId: (0, m.isSet)(A.clientId) ? String(A.clientId) : "",
        paths: Array.isArray(A == null ? void 0 : A.paths) ? A.paths.map((d) => String(d)) : []
      };
    },
    toJSON(A) {
      const d = {};
      return A.clientId !== void 0 && (d.clientId = A.clientId), A.paths ? d.paths = A.paths.map((p) => p) : d.paths = [], d;
    },
    fromPartial(A) {
      var d;
      const p = C();
      return p.clientId = A.clientId ?? "", p.paths = ((d = A.paths) == null ? void 0 : d.map((h) => h)) || [], p;
    }
  };
  function l() {
    return {
      identifier: "",
      features: []
    };
  }
  e.Version = {
    encode(A, d = f.Writer.create()) {
      A.identifier !== "" && d.uint32(10).string(A.identifier);
      for (const p of A.features)
        d.uint32(18).string(p);
      return d;
    },
    decode(A, d) {
      const p = A instanceof f.Reader ? A : new f.Reader(A);
      let h = d === void 0 ? p.len : p.pos + d;
      const x = l();
      for (; p.pos < h; ) {
        const _ = p.uint32();
        switch (_ >>> 3) {
          case 1:
            x.identifier = p.string();
            break;
          case 2:
            x.features.push(p.string());
            break;
          default:
            p.skipType(_ & 7);
            break;
        }
      }
      return x;
    },
    fromJSON(A) {
      return {
        identifier: (0, m.isSet)(A.identifier) ? String(A.identifier) : "",
        features: Array.isArray(A == null ? void 0 : A.features) ? A.features.map((d) => String(d)) : []
      };
    },
    toJSON(A) {
      const d = {};
      return A.identifier !== void 0 && (d.identifier = A.identifier), A.features ? d.features = A.features.map((p) => p) : d.features = [], d;
    },
    fromPartial(A) {
      var d;
      const p = l();
      return p.identifier = A.identifier ?? "", p.features = ((d = A.features) == null ? void 0 : d.map((h) => h)) || [], p;
    }
  };
  function S() {
    return {
      maxExpectedTimePerBlock: m.Long.UZERO
    };
  }
  e.Params = {
    encode(A, d = f.Writer.create()) {
      return A.maxExpectedTimePerBlock.isZero() || d.uint32(8).uint64(A.maxExpectedTimePerBlock), d;
    },
    decode(A, d) {
      const p = A instanceof f.Reader ? A : new f.Reader(A);
      let h = d === void 0 ? p.len : p.pos + d;
      const x = S();
      for (; p.pos < h; ) {
        const _ = p.uint32();
        switch (_ >>> 3) {
          case 1:
            x.maxExpectedTimePerBlock = p.uint64();
            break;
          default:
            p.skipType(_ & 7);
            break;
        }
      }
      return x;
    },
    fromJSON(A) {
      return {
        maxExpectedTimePerBlock: (0, m.isSet)(A.maxExpectedTimePerBlock) ? m.Long.fromValue(A.maxExpectedTimePerBlock) : m.Long.UZERO
      };
    },
    toJSON(A) {
      const d = {};
      return A.maxExpectedTimePerBlock !== void 0 && (d.maxExpectedTimePerBlock = (A.maxExpectedTimePerBlock || m.Long.UZERO).toString()), d;
    },
    fromPartial(A) {
      const d = S();
      return d.maxExpectedTimePerBlock = A.maxExpectedTimePerBlock !== void 0 && A.maxExpectedTimePerBlock !== null ? m.Long.fromValue(A.maxExpectedTimePerBlock) : m.Long.UZERO, d;
    }
  };
})(Yi);
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(d, p, h, x) {
    x === void 0 && (x = h);
    var _ = Object.getOwnPropertyDescriptor(p, h);
    (!_ || ("get" in _ ? !p.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return p[h];
    } }), Object.defineProperty(d, x, _);
  } : function(d, p, h, x) {
    x === void 0 && (x = h), d[x] = p[h];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(d, p) {
    Object.defineProperty(d, "default", { enumerable: !0, value: p });
  } : function(d, p) {
    d.default = p;
  }), u = Q && Q.__importStar || function(d) {
    if (d && d.__esModule)
      return d;
    var p = {};
    if (d != null)
      for (var h in d)
        h !== "default" && Object.prototype.hasOwnProperty.call(d, h) && o(p, d, h);
    return t(p, d), p;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgConnectionOpenConfirmResponse = e.MsgConnectionOpenConfirm = e.MsgConnectionOpenAckResponse = e.MsgConnectionOpenAck = e.MsgConnectionOpenTryResponse = e.MsgConnectionOpenTry = e.MsgConnectionOpenInitResponse = e.MsgConnectionOpenInit = e.protobufPackage = void 0;
  const r = Yi, m = ye, f = Tt, b = ie, R = u(re);
  e.protobufPackage = "ibc.core.connection.v1";
  function T() {
    return {
      clientId: "",
      counterparty: void 0,
      version: void 0,
      delayPeriod: b.Long.UZERO,
      signer: ""
    };
  }
  e.MsgConnectionOpenInit = {
    encode(d, p = R.Writer.create()) {
      return d.clientId !== "" && p.uint32(10).string(d.clientId), d.counterparty !== void 0 && r.Counterparty.encode(d.counterparty, p.uint32(18).fork()).ldelim(), d.version !== void 0 && r.Version.encode(d.version, p.uint32(26).fork()).ldelim(), d.delayPeriod.isZero() || p.uint32(32).uint64(d.delayPeriod), d.signer !== "" && p.uint32(42).string(d.signer), p;
    },
    decode(d, p) {
      const h = d instanceof R.Reader ? d : new R.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = T();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.clientId = h.string();
            break;
          case 2:
            _.counterparty = r.Counterparty.decode(h, h.uint32());
            break;
          case 3:
            _.version = r.Version.decode(h, h.uint32());
            break;
          case 4:
            _.delayPeriod = h.uint64();
            break;
          case 5:
            _.signer = h.string();
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        clientId: (0, b.isSet)(d.clientId) ? String(d.clientId) : "",
        counterparty: (0, b.isSet)(d.counterparty) ? r.Counterparty.fromJSON(d.counterparty) : void 0,
        version: (0, b.isSet)(d.version) ? r.Version.fromJSON(d.version) : void 0,
        delayPeriod: (0, b.isSet)(d.delayPeriod) ? b.Long.fromValue(d.delayPeriod) : b.Long.UZERO,
        signer: (0, b.isSet)(d.signer) ? String(d.signer) : ""
      };
    },
    toJSON(d) {
      const p = {};
      return d.clientId !== void 0 && (p.clientId = d.clientId), d.counterparty !== void 0 && (p.counterparty = d.counterparty ? r.Counterparty.toJSON(d.counterparty) : void 0), d.version !== void 0 && (p.version = d.version ? r.Version.toJSON(d.version) : void 0), d.delayPeriod !== void 0 && (p.delayPeriod = (d.delayPeriod || b.Long.UZERO).toString()), d.signer !== void 0 && (p.signer = d.signer), p;
    },
    fromPartial(d) {
      const p = T();
      return p.clientId = d.clientId ?? "", p.counterparty = d.counterparty !== void 0 && d.counterparty !== null ? r.Counterparty.fromPartial(d.counterparty) : void 0, p.version = d.version !== void 0 && d.version !== null ? r.Version.fromPartial(d.version) : void 0, p.delayPeriod = d.delayPeriod !== void 0 && d.delayPeriod !== null ? b.Long.fromValue(d.delayPeriod) : b.Long.UZERO, p.signer = d.signer ?? "", p;
    }
  };
  function V() {
    return {};
  }
  e.MsgConnectionOpenInitResponse = {
    encode(d, p = R.Writer.create()) {
      return p;
    },
    decode(d, p) {
      const h = d instanceof R.Reader ? d : new R.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = V();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {};
    },
    toJSON(d) {
      return {};
    },
    fromPartial(d) {
      return V();
    }
  };
  function D() {
    return {
      clientId: "",
      previousConnectionId: "",
      clientState: void 0,
      counterparty: void 0,
      delayPeriod: b.Long.UZERO,
      counterpartyVersions: [],
      proofHeight: void 0,
      proofInit: new Uint8Array(),
      proofClient: new Uint8Array(),
      proofConsensus: new Uint8Array(),
      consensusHeight: void 0,
      signer: "",
      hostConsensusStateProof: new Uint8Array()
    };
  }
  e.MsgConnectionOpenTry = {
    encode(d, p = R.Writer.create()) {
      d.clientId !== "" && p.uint32(10).string(d.clientId), d.previousConnectionId !== "" && p.uint32(18).string(d.previousConnectionId), d.clientState !== void 0 && m.Any.encode(d.clientState, p.uint32(26).fork()).ldelim(), d.counterparty !== void 0 && r.Counterparty.encode(d.counterparty, p.uint32(34).fork()).ldelim(), d.delayPeriod.isZero() || p.uint32(40).uint64(d.delayPeriod);
      for (const h of d.counterpartyVersions)
        r.Version.encode(h, p.uint32(50).fork()).ldelim();
      return d.proofHeight !== void 0 && f.Height.encode(d.proofHeight, p.uint32(58).fork()).ldelim(), d.proofInit.length !== 0 && p.uint32(66).bytes(d.proofInit), d.proofClient.length !== 0 && p.uint32(74).bytes(d.proofClient), d.proofConsensus.length !== 0 && p.uint32(82).bytes(d.proofConsensus), d.consensusHeight !== void 0 && f.Height.encode(d.consensusHeight, p.uint32(90).fork()).ldelim(), d.signer !== "" && p.uint32(98).string(d.signer), d.hostConsensusStateProof.length !== 0 && p.uint32(106).bytes(d.hostConsensusStateProof), p;
    },
    decode(d, p) {
      const h = d instanceof R.Reader ? d : new R.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = D();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.clientId = h.string();
            break;
          case 2:
            _.previousConnectionId = h.string();
            break;
          case 3:
            _.clientState = m.Any.decode(h, h.uint32());
            break;
          case 4:
            _.counterparty = r.Counterparty.decode(h, h.uint32());
            break;
          case 5:
            _.delayPeriod = h.uint64();
            break;
          case 6:
            _.counterpartyVersions.push(r.Version.decode(h, h.uint32()));
            break;
          case 7:
            _.proofHeight = f.Height.decode(h, h.uint32());
            break;
          case 8:
            _.proofInit = h.bytes();
            break;
          case 9:
            _.proofClient = h.bytes();
            break;
          case 10:
            _.proofConsensus = h.bytes();
            break;
          case 11:
            _.consensusHeight = f.Height.decode(h, h.uint32());
            break;
          case 12:
            _.signer = h.string();
            break;
          case 13:
            _.hostConsensusStateProof = h.bytes();
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        clientId: (0, b.isSet)(d.clientId) ? String(d.clientId) : "",
        previousConnectionId: (0, b.isSet)(d.previousConnectionId) ? String(d.previousConnectionId) : "",
        clientState: (0, b.isSet)(d.clientState) ? m.Any.fromJSON(d.clientState) : void 0,
        counterparty: (0, b.isSet)(d.counterparty) ? r.Counterparty.fromJSON(d.counterparty) : void 0,
        delayPeriod: (0, b.isSet)(d.delayPeriod) ? b.Long.fromValue(d.delayPeriod) : b.Long.UZERO,
        counterpartyVersions: Array.isArray(d == null ? void 0 : d.counterpartyVersions) ? d.counterpartyVersions.map((p) => r.Version.fromJSON(p)) : [],
        proofHeight: (0, b.isSet)(d.proofHeight) ? f.Height.fromJSON(d.proofHeight) : void 0,
        proofInit: (0, b.isSet)(d.proofInit) ? (0, b.bytesFromBase64)(d.proofInit) : new Uint8Array(),
        proofClient: (0, b.isSet)(d.proofClient) ? (0, b.bytesFromBase64)(d.proofClient) : new Uint8Array(),
        proofConsensus: (0, b.isSet)(d.proofConsensus) ? (0, b.bytesFromBase64)(d.proofConsensus) : new Uint8Array(),
        consensusHeight: (0, b.isSet)(d.consensusHeight) ? f.Height.fromJSON(d.consensusHeight) : void 0,
        signer: (0, b.isSet)(d.signer) ? String(d.signer) : "",
        hostConsensusStateProof: (0, b.isSet)(d.hostConsensusStateProof) ? (0, b.bytesFromBase64)(d.hostConsensusStateProof) : new Uint8Array()
      };
    },
    toJSON(d) {
      const p = {};
      return d.clientId !== void 0 && (p.clientId = d.clientId), d.previousConnectionId !== void 0 && (p.previousConnectionId = d.previousConnectionId), d.clientState !== void 0 && (p.clientState = d.clientState ? m.Any.toJSON(d.clientState) : void 0), d.counterparty !== void 0 && (p.counterparty = d.counterparty ? r.Counterparty.toJSON(d.counterparty) : void 0), d.delayPeriod !== void 0 && (p.delayPeriod = (d.delayPeriod || b.Long.UZERO).toString()), d.counterpartyVersions ? p.counterpartyVersions = d.counterpartyVersions.map((h) => h ? r.Version.toJSON(h) : void 0) : p.counterpartyVersions = [], d.proofHeight !== void 0 && (p.proofHeight = d.proofHeight ? f.Height.toJSON(d.proofHeight) : void 0), d.proofInit !== void 0 && (p.proofInit = (0, b.base64FromBytes)(d.proofInit !== void 0 ? d.proofInit : new Uint8Array())), d.proofClient !== void 0 && (p.proofClient = (0, b.base64FromBytes)(d.proofClient !== void 0 ? d.proofClient : new Uint8Array())), d.proofConsensus !== void 0 && (p.proofConsensus = (0, b.base64FromBytes)(d.proofConsensus !== void 0 ? d.proofConsensus : new Uint8Array())), d.consensusHeight !== void 0 && (p.consensusHeight = d.consensusHeight ? f.Height.toJSON(d.consensusHeight) : void 0), d.signer !== void 0 && (p.signer = d.signer), d.hostConsensusStateProof !== void 0 && (p.hostConsensusStateProof = (0, b.base64FromBytes)(d.hostConsensusStateProof !== void 0 ? d.hostConsensusStateProof : new Uint8Array())), p;
    },
    fromPartial(d) {
      var p;
      const h = D();
      return h.clientId = d.clientId ?? "", h.previousConnectionId = d.previousConnectionId ?? "", h.clientState = d.clientState !== void 0 && d.clientState !== null ? m.Any.fromPartial(d.clientState) : void 0, h.counterparty = d.counterparty !== void 0 && d.counterparty !== null ? r.Counterparty.fromPartial(d.counterparty) : void 0, h.delayPeriod = d.delayPeriod !== void 0 && d.delayPeriod !== null ? b.Long.fromValue(d.delayPeriod) : b.Long.UZERO, h.counterpartyVersions = ((p = d.counterpartyVersions) == null ? void 0 : p.map((x) => r.Version.fromPartial(x))) || [], h.proofHeight = d.proofHeight !== void 0 && d.proofHeight !== null ? f.Height.fromPartial(d.proofHeight) : void 0, h.proofInit = d.proofInit ?? new Uint8Array(), h.proofClient = d.proofClient ?? new Uint8Array(), h.proofConsensus = d.proofConsensus ?? new Uint8Array(), h.consensusHeight = d.consensusHeight !== void 0 && d.consensusHeight !== null ? f.Height.fromPartial(d.consensusHeight) : void 0, h.signer = d.signer ?? "", h.hostConsensusStateProof = d.hostConsensusStateProof ?? new Uint8Array(), h;
    }
  };
  function B() {
    return {};
  }
  e.MsgConnectionOpenTryResponse = {
    encode(d, p = R.Writer.create()) {
      return p;
    },
    decode(d, p) {
      const h = d instanceof R.Reader ? d : new R.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = B();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {};
    },
    toJSON(d) {
      return {};
    },
    fromPartial(d) {
      return B();
    }
  };
  function U() {
    return {
      connectionId: "",
      counterpartyConnectionId: "",
      version: void 0,
      clientState: void 0,
      proofHeight: void 0,
      proofTry: new Uint8Array(),
      proofClient: new Uint8Array(),
      proofConsensus: new Uint8Array(),
      consensusHeight: void 0,
      signer: "",
      hostConsensusStateProof: new Uint8Array()
    };
  }
  e.MsgConnectionOpenAck = {
    encode(d, p = R.Writer.create()) {
      return d.connectionId !== "" && p.uint32(10).string(d.connectionId), d.counterpartyConnectionId !== "" && p.uint32(18).string(d.counterpartyConnectionId), d.version !== void 0 && r.Version.encode(d.version, p.uint32(26).fork()).ldelim(), d.clientState !== void 0 && m.Any.encode(d.clientState, p.uint32(34).fork()).ldelim(), d.proofHeight !== void 0 && f.Height.encode(d.proofHeight, p.uint32(42).fork()).ldelim(), d.proofTry.length !== 0 && p.uint32(50).bytes(d.proofTry), d.proofClient.length !== 0 && p.uint32(58).bytes(d.proofClient), d.proofConsensus.length !== 0 && p.uint32(66).bytes(d.proofConsensus), d.consensusHeight !== void 0 && f.Height.encode(d.consensusHeight, p.uint32(74).fork()).ldelim(), d.signer !== "" && p.uint32(82).string(d.signer), d.hostConsensusStateProof.length !== 0 && p.uint32(90).bytes(d.hostConsensusStateProof), p;
    },
    decode(d, p) {
      const h = d instanceof R.Reader ? d : new R.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = U();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.connectionId = h.string();
            break;
          case 2:
            _.counterpartyConnectionId = h.string();
            break;
          case 3:
            _.version = r.Version.decode(h, h.uint32());
            break;
          case 4:
            _.clientState = m.Any.decode(h, h.uint32());
            break;
          case 5:
            _.proofHeight = f.Height.decode(h, h.uint32());
            break;
          case 6:
            _.proofTry = h.bytes();
            break;
          case 7:
            _.proofClient = h.bytes();
            break;
          case 8:
            _.proofConsensus = h.bytes();
            break;
          case 9:
            _.consensusHeight = f.Height.decode(h, h.uint32());
            break;
          case 10:
            _.signer = h.string();
            break;
          case 11:
            _.hostConsensusStateProof = h.bytes();
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        connectionId: (0, b.isSet)(d.connectionId) ? String(d.connectionId) : "",
        counterpartyConnectionId: (0, b.isSet)(d.counterpartyConnectionId) ? String(d.counterpartyConnectionId) : "",
        version: (0, b.isSet)(d.version) ? r.Version.fromJSON(d.version) : void 0,
        clientState: (0, b.isSet)(d.clientState) ? m.Any.fromJSON(d.clientState) : void 0,
        proofHeight: (0, b.isSet)(d.proofHeight) ? f.Height.fromJSON(d.proofHeight) : void 0,
        proofTry: (0, b.isSet)(d.proofTry) ? (0, b.bytesFromBase64)(d.proofTry) : new Uint8Array(),
        proofClient: (0, b.isSet)(d.proofClient) ? (0, b.bytesFromBase64)(d.proofClient) : new Uint8Array(),
        proofConsensus: (0, b.isSet)(d.proofConsensus) ? (0, b.bytesFromBase64)(d.proofConsensus) : new Uint8Array(),
        consensusHeight: (0, b.isSet)(d.consensusHeight) ? f.Height.fromJSON(d.consensusHeight) : void 0,
        signer: (0, b.isSet)(d.signer) ? String(d.signer) : "",
        hostConsensusStateProof: (0, b.isSet)(d.hostConsensusStateProof) ? (0, b.bytesFromBase64)(d.hostConsensusStateProof) : new Uint8Array()
      };
    },
    toJSON(d) {
      const p = {};
      return d.connectionId !== void 0 && (p.connectionId = d.connectionId), d.counterpartyConnectionId !== void 0 && (p.counterpartyConnectionId = d.counterpartyConnectionId), d.version !== void 0 && (p.version = d.version ? r.Version.toJSON(d.version) : void 0), d.clientState !== void 0 && (p.clientState = d.clientState ? m.Any.toJSON(d.clientState) : void 0), d.proofHeight !== void 0 && (p.proofHeight = d.proofHeight ? f.Height.toJSON(d.proofHeight) : void 0), d.proofTry !== void 0 && (p.proofTry = (0, b.base64FromBytes)(d.proofTry !== void 0 ? d.proofTry : new Uint8Array())), d.proofClient !== void 0 && (p.proofClient = (0, b.base64FromBytes)(d.proofClient !== void 0 ? d.proofClient : new Uint8Array())), d.proofConsensus !== void 0 && (p.proofConsensus = (0, b.base64FromBytes)(d.proofConsensus !== void 0 ? d.proofConsensus : new Uint8Array())), d.consensusHeight !== void 0 && (p.consensusHeight = d.consensusHeight ? f.Height.toJSON(d.consensusHeight) : void 0), d.signer !== void 0 && (p.signer = d.signer), d.hostConsensusStateProof !== void 0 && (p.hostConsensusStateProof = (0, b.base64FromBytes)(d.hostConsensusStateProof !== void 0 ? d.hostConsensusStateProof : new Uint8Array())), p;
    },
    fromPartial(d) {
      const p = U();
      return p.connectionId = d.connectionId ?? "", p.counterpartyConnectionId = d.counterpartyConnectionId ?? "", p.version = d.version !== void 0 && d.version !== null ? r.Version.fromPartial(d.version) : void 0, p.clientState = d.clientState !== void 0 && d.clientState !== null ? m.Any.fromPartial(d.clientState) : void 0, p.proofHeight = d.proofHeight !== void 0 && d.proofHeight !== null ? f.Height.fromPartial(d.proofHeight) : void 0, p.proofTry = d.proofTry ?? new Uint8Array(), p.proofClient = d.proofClient ?? new Uint8Array(), p.proofConsensus = d.proofConsensus ?? new Uint8Array(), p.consensusHeight = d.consensusHeight !== void 0 && d.consensusHeight !== null ? f.Height.fromPartial(d.consensusHeight) : void 0, p.signer = d.signer ?? "", p.hostConsensusStateProof = d.hostConsensusStateProof ?? new Uint8Array(), p;
    }
  };
  function C() {
    return {};
  }
  e.MsgConnectionOpenAckResponse = {
    encode(d, p = R.Writer.create()) {
      return p;
    },
    decode(d, p) {
      const h = d instanceof R.Reader ? d : new R.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = C();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {};
    },
    toJSON(d) {
      return {};
    },
    fromPartial(d) {
      return C();
    }
  };
  function l() {
    return {
      connectionId: "",
      proofAck: new Uint8Array(),
      proofHeight: void 0,
      signer: ""
    };
  }
  e.MsgConnectionOpenConfirm = {
    encode(d, p = R.Writer.create()) {
      return d.connectionId !== "" && p.uint32(10).string(d.connectionId), d.proofAck.length !== 0 && p.uint32(18).bytes(d.proofAck), d.proofHeight !== void 0 && f.Height.encode(d.proofHeight, p.uint32(26).fork()).ldelim(), d.signer !== "" && p.uint32(34).string(d.signer), p;
    },
    decode(d, p) {
      const h = d instanceof R.Reader ? d : new R.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = l();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.connectionId = h.string();
            break;
          case 2:
            _.proofAck = h.bytes();
            break;
          case 3:
            _.proofHeight = f.Height.decode(h, h.uint32());
            break;
          case 4:
            _.signer = h.string();
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        connectionId: (0, b.isSet)(d.connectionId) ? String(d.connectionId) : "",
        proofAck: (0, b.isSet)(d.proofAck) ? (0, b.bytesFromBase64)(d.proofAck) : new Uint8Array(),
        proofHeight: (0, b.isSet)(d.proofHeight) ? f.Height.fromJSON(d.proofHeight) : void 0,
        signer: (0, b.isSet)(d.signer) ? String(d.signer) : ""
      };
    },
    toJSON(d) {
      const p = {};
      return d.connectionId !== void 0 && (p.connectionId = d.connectionId), d.proofAck !== void 0 && (p.proofAck = (0, b.base64FromBytes)(d.proofAck !== void 0 ? d.proofAck : new Uint8Array())), d.proofHeight !== void 0 && (p.proofHeight = d.proofHeight ? f.Height.toJSON(d.proofHeight) : void 0), d.signer !== void 0 && (p.signer = d.signer), p;
    },
    fromPartial(d) {
      const p = l();
      return p.connectionId = d.connectionId ?? "", p.proofAck = d.proofAck ?? new Uint8Array(), p.proofHeight = d.proofHeight !== void 0 && d.proofHeight !== null ? f.Height.fromPartial(d.proofHeight) : void 0, p.signer = d.signer ?? "", p;
    }
  };
  function S() {
    return {};
  }
  e.MsgConnectionOpenConfirmResponse = {
    encode(d, p = R.Writer.create()) {
      return p;
    },
    decode(d, p) {
      const h = d instanceof R.Reader ? d : new R.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = S();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {};
    },
    toJSON(d) {
      return {};
    },
    fromPartial(d) {
      return S();
    }
  };
  class A {
    constructor(p) {
      this.rpc = p, this.ConnectionOpenInit = this.ConnectionOpenInit.bind(this), this.ConnectionOpenTry = this.ConnectionOpenTry.bind(this), this.ConnectionOpenAck = this.ConnectionOpenAck.bind(this), this.ConnectionOpenConfirm = this.ConnectionOpenConfirm.bind(this);
    }
    ConnectionOpenInit(p) {
      const h = e.MsgConnectionOpenInit.encode(p).finish();
      return this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenInit", h).then((x) => e.MsgConnectionOpenInitResponse.decode(new R.Reader(x)));
    }
    ConnectionOpenTry(p) {
      const h = e.MsgConnectionOpenTry.encode(p).finish();
      return this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenTry", h).then((x) => e.MsgConnectionOpenTryResponse.decode(new R.Reader(x)));
    }
    ConnectionOpenAck(p) {
      const h = e.MsgConnectionOpenAck.encode(p).finish();
      return this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenAck", h).then((x) => e.MsgConnectionOpenAckResponse.decode(new R.Reader(x)));
    }
    ConnectionOpenConfirm(p) {
      const h = e.MsgConnectionOpenConfirm.encode(p).finish();
      return this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenConfirm", h).then((x) => e.MsgConnectionOpenConfirmResponse.decode(new R.Reader(x)));
    }
  }
  e.MsgClientImpl = A;
})(Nc);
Object.defineProperty(In, "__esModule", { value: !0 });
In.isMsgTransferEncodeObject = In.ibcTypes = void 0;
const _m = ur, yt = Ac, vo = wc, yo = Nc;
In.ibcTypes = [
  ["/ibc.applications.transfer.v1.MsgTransfer", _m.MsgTransfer],
  ["/ibc.core.channel.v1.MsgAcknowledgement", yt.MsgAcknowledgement],
  ["/ibc.core.channel.v1.MsgChannelCloseConfirm", yt.MsgChannelCloseConfirm],
  ["/ibc.core.channel.v1.MsgChannelCloseInit", yt.MsgChannelCloseInit],
  ["/ibc.core.channel.v1.MsgChannelOpenAck", yt.MsgChannelOpenAck],
  ["/ibc.core.channel.v1.MsgChannelOpenConfirm", yt.MsgChannelOpenConfirm],
  ["/ibc.core.channel.v1.MsgChannelOpenInit", yt.MsgChannelOpenInit],
  ["/ibc.core.channel.v1.MsgChannelOpenTry", yt.MsgChannelOpenTry],
  ["/ibc.core.channel.v1.MsgRecvPacket", yt.MsgRecvPacket],
  ["/ibc.core.channel.v1.MsgTimeout", yt.MsgTimeout],
  ["/ibc.core.channel.v1.MsgTimeoutOnClose", yt.MsgTimeoutOnClose],
  ["/ibc.core.client.v1.MsgCreateClient", vo.MsgCreateClient],
  ["/ibc.core.client.v1.MsgSubmitMisbehaviour", vo.MsgSubmitMisbehaviour],
  ["/ibc.core.client.v1.MsgUpdateClient", vo.MsgUpdateClient],
  ["/ibc.core.client.v1.MsgUpgradeClient", vo.MsgUpgradeClient],
  ["/ibc.core.connection.v1.MsgConnectionOpenAck", yo.MsgConnectionOpenAck],
  ["/ibc.core.connection.v1.MsgConnectionOpenConfirm", yo.MsgConnectionOpenConfirm],
  ["/ibc.core.connection.v1.MsgConnectionOpenInit", yo.MsgConnectionOpenInit],
  ["/ibc.core.connection.v1.MsgConnectionOpenTry", yo.MsgConnectionOpenTry]
];
function Jm(e) {
  return e.typeUrl === "/ibc.applications.transfer.v1.MsgTransfer";
}
In.isMsgTransferEncodeObject = Jm;
var pr = {}, Ec = {}, Bt = {}, Um = Q && Q.__createBinding || (Object.create ? function(e, o, t, u) {
  u === void 0 && (u = t);
  var r = Object.getOwnPropertyDescriptor(o, t);
  (!r || ("get" in r ? !o.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return o[t];
  } }), Object.defineProperty(e, u, r);
} : function(e, o, t, u) {
  u === void 0 && (u = t), e[u] = o[t];
}), Dm = Q && Q.__setModuleDefault || (Object.create ? function(e, o) {
  Object.defineProperty(e, "default", { enumerable: !0, value: o });
} : function(e, o) {
  e.default = o;
}), Lm = Q && Q.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var o = {};
  if (e != null)
    for (var t in e)
      t !== "default" && Object.prototype.hasOwnProperty.call(e, t) && Um(o, e, t);
  return Dm(o, e), o;
};
Object.defineProperty(Bt, "__esModule", { value: !0 });
Bt.Params = Bt.DenomTrace = Bt.protobufPackage = void 0;
const bn = Lm(re), Jo = ie;
Bt.protobufPackage = "ibc.applications.transfer.v1";
function xa() {
  return {
    path: "",
    baseDenom: ""
  };
}
Bt.DenomTrace = {
  encode(e, o = bn.Writer.create()) {
    return e.path !== "" && o.uint32(10).string(e.path), e.baseDenom !== "" && o.uint32(18).string(e.baseDenom), o;
  },
  decode(e, o) {
    const t = e instanceof bn.Reader ? e : new bn.Reader(e);
    let u = o === void 0 ? t.len : t.pos + o;
    const r = xa();
    for (; t.pos < u; ) {
      const m = t.uint32();
      switch (m >>> 3) {
        case 1:
          r.path = t.string();
          break;
        case 2:
          r.baseDenom = t.string();
          break;
        default:
          t.skipType(m & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      path: (0, Jo.isSet)(e.path) ? String(e.path) : "",
      baseDenom: (0, Jo.isSet)(e.baseDenom) ? String(e.baseDenom) : ""
    };
  },
  toJSON(e) {
    const o = {};
    return e.path !== void 0 && (o.path = e.path), e.baseDenom !== void 0 && (o.baseDenom = e.baseDenom), o;
  },
  fromPartial(e) {
    const o = xa();
    return o.path = e.path ?? "", o.baseDenom = e.baseDenom ?? "", o;
  }
};
function _a() {
  return {
    sendEnabled: !1,
    receiveEnabled: !1
  };
}
Bt.Params = {
  encode(e, o = bn.Writer.create()) {
    return e.sendEnabled === !0 && o.uint32(8).bool(e.sendEnabled), e.receiveEnabled === !0 && o.uint32(16).bool(e.receiveEnabled), o;
  },
  decode(e, o) {
    const t = e instanceof bn.Reader ? e : new bn.Reader(e);
    let u = o === void 0 ? t.len : t.pos + o;
    const r = _a();
    for (; t.pos < u; ) {
      const m = t.uint32();
      switch (m >>> 3) {
        case 1:
          r.sendEnabled = t.bool();
          break;
        case 2:
          r.receiveEnabled = t.bool();
          break;
        default:
          t.skipType(m & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      sendEnabled: (0, Jo.isSet)(e.sendEnabled) ? !!e.sendEnabled : !1,
      receiveEnabled: (0, Jo.isSet)(e.receiveEnabled) ? !!e.receiveEnabled : !1
    };
  },
  toJSON(e) {
    const o = {};
    return e.sendEnabled !== void 0 && (o.sendEnabled = e.sendEnabled), e.receiveEnabled !== void 0 && (o.receiveEnabled = e.receiveEnabled), o;
  },
  fromPartial(e) {
    const o = _a();
    return o.sendEnabled = e.sendEnabled ?? !1, o.receiveEnabled = e.receiveEnabled ?? !1, o;
  }
};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(p, h, x, _) {
    _ === void 0 && (_ = x);
    var I = Object.getOwnPropertyDescriptor(h, x);
    (!I || ("get" in I ? !h.__esModule : I.writable || I.configurable)) && (I = { enumerable: !0, get: function() {
      return h[x];
    } }), Object.defineProperty(p, _, I);
  } : function(p, h, x, _) {
    _ === void 0 && (_ = x), p[_] = h[x];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(p, h) {
    Object.defineProperty(p, "default", { enumerable: !0, value: h });
  } : function(p, h) {
    p.default = h;
  }), u = Q && Q.__importStar || function(p) {
    if (p && p.__esModule)
      return p;
    var h = {};
    if (p != null)
      for (var x in p)
        x !== "default" && Object.prototype.hasOwnProperty.call(p, x) && o(h, p, x);
    return t(h, p), h;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryEscrowAddressResponse = e.QueryEscrowAddressRequest = e.QueryDenomHashResponse = e.QueryDenomHashRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.QueryDenomTracesResponse = e.QueryDenomTracesRequest = e.QueryDenomTraceResponse = e.QueryDenomTraceRequest = e.protobufPackage = void 0;
  const r = be, m = Bt, f = u(re), b = ie;
  e.protobufPackage = "ibc.applications.transfer.v1";
  function R() {
    return {
      hash: ""
    };
  }
  e.QueryDenomTraceRequest = {
    encode(p, h = f.Writer.create()) {
      return p.hash !== "" && h.uint32(10).string(p.hash), h;
    },
    decode(p, h) {
      const x = p instanceof f.Reader ? p : new f.Reader(p);
      let _ = h === void 0 ? x.len : x.pos + h;
      const I = R();
      for (; x.pos < _; ) {
        const W = x.uint32();
        switch (W >>> 3) {
          case 1:
            I.hash = x.string();
            break;
          default:
            x.skipType(W & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        hash: (0, b.isSet)(p.hash) ? String(p.hash) : ""
      };
    },
    toJSON(p) {
      const h = {};
      return p.hash !== void 0 && (h.hash = p.hash), h;
    },
    fromPartial(p) {
      const h = R();
      return h.hash = p.hash ?? "", h;
    }
  };
  function T() {
    return {
      denomTrace: void 0
    };
  }
  e.QueryDenomTraceResponse = {
    encode(p, h = f.Writer.create()) {
      return p.denomTrace !== void 0 && m.DenomTrace.encode(p.denomTrace, h.uint32(10).fork()).ldelim(), h;
    },
    decode(p, h) {
      const x = p instanceof f.Reader ? p : new f.Reader(p);
      let _ = h === void 0 ? x.len : x.pos + h;
      const I = T();
      for (; x.pos < _; ) {
        const W = x.uint32();
        switch (W >>> 3) {
          case 1:
            I.denomTrace = m.DenomTrace.decode(x, x.uint32());
            break;
          default:
            x.skipType(W & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        denomTrace: (0, b.isSet)(p.denomTrace) ? m.DenomTrace.fromJSON(p.denomTrace) : void 0
      };
    },
    toJSON(p) {
      const h = {};
      return p.denomTrace !== void 0 && (h.denomTrace = p.denomTrace ? m.DenomTrace.toJSON(p.denomTrace) : void 0), h;
    },
    fromPartial(p) {
      const h = T();
      return h.denomTrace = p.denomTrace !== void 0 && p.denomTrace !== null ? m.DenomTrace.fromPartial(p.denomTrace) : void 0, h;
    }
  };
  function V() {
    return {
      pagination: void 0
    };
  }
  e.QueryDenomTracesRequest = {
    encode(p, h = f.Writer.create()) {
      return p.pagination !== void 0 && r.PageRequest.encode(p.pagination, h.uint32(10).fork()).ldelim(), h;
    },
    decode(p, h) {
      const x = p instanceof f.Reader ? p : new f.Reader(p);
      let _ = h === void 0 ? x.len : x.pos + h;
      const I = V();
      for (; x.pos < _; ) {
        const W = x.uint32();
        switch (W >>> 3) {
          case 1:
            I.pagination = r.PageRequest.decode(x, x.uint32());
            break;
          default:
            x.skipType(W & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        pagination: (0, b.isSet)(p.pagination) ? r.PageRequest.fromJSON(p.pagination) : void 0
      };
    },
    toJSON(p) {
      const h = {};
      return p.pagination !== void 0 && (h.pagination = p.pagination ? r.PageRequest.toJSON(p.pagination) : void 0), h;
    },
    fromPartial(p) {
      const h = V();
      return h.pagination = p.pagination !== void 0 && p.pagination !== null ? r.PageRequest.fromPartial(p.pagination) : void 0, h;
    }
  };
  function D() {
    return {
      denomTraces: [],
      pagination: void 0
    };
  }
  e.QueryDenomTracesResponse = {
    encode(p, h = f.Writer.create()) {
      for (const x of p.denomTraces)
        m.DenomTrace.encode(x, h.uint32(10).fork()).ldelim();
      return p.pagination !== void 0 && r.PageResponse.encode(p.pagination, h.uint32(18).fork()).ldelim(), h;
    },
    decode(p, h) {
      const x = p instanceof f.Reader ? p : new f.Reader(p);
      let _ = h === void 0 ? x.len : x.pos + h;
      const I = D();
      for (; x.pos < _; ) {
        const W = x.uint32();
        switch (W >>> 3) {
          case 1:
            I.denomTraces.push(m.DenomTrace.decode(x, x.uint32()));
            break;
          case 2:
            I.pagination = r.PageResponse.decode(x, x.uint32());
            break;
          default:
            x.skipType(W & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        denomTraces: Array.isArray(p == null ? void 0 : p.denomTraces) ? p.denomTraces.map((h) => m.DenomTrace.fromJSON(h)) : [],
        pagination: (0, b.isSet)(p.pagination) ? r.PageResponse.fromJSON(p.pagination) : void 0
      };
    },
    toJSON(p) {
      const h = {};
      return p.denomTraces ? h.denomTraces = p.denomTraces.map((x) => x ? m.DenomTrace.toJSON(x) : void 0) : h.denomTraces = [], p.pagination !== void 0 && (h.pagination = p.pagination ? r.PageResponse.toJSON(p.pagination) : void 0), h;
    },
    fromPartial(p) {
      var h;
      const x = D();
      return x.denomTraces = ((h = p.denomTraces) == null ? void 0 : h.map((_) => m.DenomTrace.fromPartial(_))) || [], x.pagination = p.pagination !== void 0 && p.pagination !== null ? r.PageResponse.fromPartial(p.pagination) : void 0, x;
    }
  };
  function B() {
    return {};
  }
  e.QueryParamsRequest = {
    encode(p, h = f.Writer.create()) {
      return h;
    },
    decode(p, h) {
      const x = p instanceof f.Reader ? p : new f.Reader(p);
      let _ = h === void 0 ? x.len : x.pos + h;
      const I = B();
      for (; x.pos < _; ) {
        const W = x.uint32();
        switch (W >>> 3) {
          default:
            x.skipType(W & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {};
    },
    toJSON(p) {
      return {};
    },
    fromPartial(p) {
      return B();
    }
  };
  function U() {
    return {
      params: void 0
    };
  }
  e.QueryParamsResponse = {
    encode(p, h = f.Writer.create()) {
      return p.params !== void 0 && m.Params.encode(p.params, h.uint32(10).fork()).ldelim(), h;
    },
    decode(p, h) {
      const x = p instanceof f.Reader ? p : new f.Reader(p);
      let _ = h === void 0 ? x.len : x.pos + h;
      const I = U();
      for (; x.pos < _; ) {
        const W = x.uint32();
        switch (W >>> 3) {
          case 1:
            I.params = m.Params.decode(x, x.uint32());
            break;
          default:
            x.skipType(W & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        params: (0, b.isSet)(p.params) ? m.Params.fromJSON(p.params) : void 0
      };
    },
    toJSON(p) {
      const h = {};
      return p.params !== void 0 && (h.params = p.params ? m.Params.toJSON(p.params) : void 0), h;
    },
    fromPartial(p) {
      const h = U();
      return h.params = p.params !== void 0 && p.params !== null ? m.Params.fromPartial(p.params) : void 0, h;
    }
  };
  function C() {
    return {
      trace: ""
    };
  }
  e.QueryDenomHashRequest = {
    encode(p, h = f.Writer.create()) {
      return p.trace !== "" && h.uint32(10).string(p.trace), h;
    },
    decode(p, h) {
      const x = p instanceof f.Reader ? p : new f.Reader(p);
      let _ = h === void 0 ? x.len : x.pos + h;
      const I = C();
      for (; x.pos < _; ) {
        const W = x.uint32();
        switch (W >>> 3) {
          case 1:
            I.trace = x.string();
            break;
          default:
            x.skipType(W & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        trace: (0, b.isSet)(p.trace) ? String(p.trace) : ""
      };
    },
    toJSON(p) {
      const h = {};
      return p.trace !== void 0 && (h.trace = p.trace), h;
    },
    fromPartial(p) {
      const h = C();
      return h.trace = p.trace ?? "", h;
    }
  };
  function l() {
    return {
      hash: ""
    };
  }
  e.QueryDenomHashResponse = {
    encode(p, h = f.Writer.create()) {
      return p.hash !== "" && h.uint32(10).string(p.hash), h;
    },
    decode(p, h) {
      const x = p instanceof f.Reader ? p : new f.Reader(p);
      let _ = h === void 0 ? x.len : x.pos + h;
      const I = l();
      for (; x.pos < _; ) {
        const W = x.uint32();
        switch (W >>> 3) {
          case 1:
            I.hash = x.string();
            break;
          default:
            x.skipType(W & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        hash: (0, b.isSet)(p.hash) ? String(p.hash) : ""
      };
    },
    toJSON(p) {
      const h = {};
      return p.hash !== void 0 && (h.hash = p.hash), h;
    },
    fromPartial(p) {
      const h = l();
      return h.hash = p.hash ?? "", h;
    }
  };
  function S() {
    return {
      portId: "",
      channelId: ""
    };
  }
  e.QueryEscrowAddressRequest = {
    encode(p, h = f.Writer.create()) {
      return p.portId !== "" && h.uint32(10).string(p.portId), p.channelId !== "" && h.uint32(18).string(p.channelId), h;
    },
    decode(p, h) {
      const x = p instanceof f.Reader ? p : new f.Reader(p);
      let _ = h === void 0 ? x.len : x.pos + h;
      const I = S();
      for (; x.pos < _; ) {
        const W = x.uint32();
        switch (W >>> 3) {
          case 1:
            I.portId = x.string();
            break;
          case 2:
            I.channelId = x.string();
            break;
          default:
            x.skipType(W & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        portId: (0, b.isSet)(p.portId) ? String(p.portId) : "",
        channelId: (0, b.isSet)(p.channelId) ? String(p.channelId) : ""
      };
    },
    toJSON(p) {
      const h = {};
      return p.portId !== void 0 && (h.portId = p.portId), p.channelId !== void 0 && (h.channelId = p.channelId), h;
    },
    fromPartial(p) {
      const h = S();
      return h.portId = p.portId ?? "", h.channelId = p.channelId ?? "", h;
    }
  };
  function A() {
    return {
      escrowAddress: ""
    };
  }
  e.QueryEscrowAddressResponse = {
    encode(p, h = f.Writer.create()) {
      return p.escrowAddress !== "" && h.uint32(10).string(p.escrowAddress), h;
    },
    decode(p, h) {
      const x = p instanceof f.Reader ? p : new f.Reader(p);
      let _ = h === void 0 ? x.len : x.pos + h;
      const I = A();
      for (; x.pos < _; ) {
        const W = x.uint32();
        switch (W >>> 3) {
          case 1:
            I.escrowAddress = x.string();
            break;
          default:
            x.skipType(W & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(p) {
      return {
        escrowAddress: (0, b.isSet)(p.escrowAddress) ? String(p.escrowAddress) : ""
      };
    },
    toJSON(p) {
      const h = {};
      return p.escrowAddress !== void 0 && (h.escrowAddress = p.escrowAddress), h;
    },
    fromPartial(p) {
      const h = A();
      return h.escrowAddress = p.escrowAddress ?? "", h;
    }
  };
  class d {
    constructor(h) {
      this.rpc = h, this.DenomTrace = this.DenomTrace.bind(this), this.DenomTraces = this.DenomTraces.bind(this), this.Params = this.Params.bind(this), this.DenomHash = this.DenomHash.bind(this), this.EscrowAddress = this.EscrowAddress.bind(this);
    }
    DenomTrace(h) {
      const x = e.QueryDenomTraceRequest.encode(h).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTrace", x).then((_) => e.QueryDenomTraceResponse.decode(new f.Reader(_)));
    }
    DenomTraces(h = {
      pagination: void 0
    }) {
      const x = e.QueryDenomTracesRequest.encode(h).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTraces", x).then((_) => e.QueryDenomTracesResponse.decode(new f.Reader(_)));
    }
    Params(h = {}) {
      const x = e.QueryParamsRequest.encode(h).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Query", "Params", x).then((_) => e.QueryParamsResponse.decode(new f.Reader(_)));
    }
    DenomHash(h) {
      const x = e.QueryDenomHashRequest.encode(h).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Query", "DenomHash", x).then((_) => e.QueryDenomHashResponse.decode(new f.Reader(_)));
    }
    EscrowAddress(h) {
      const x = e.QueryEscrowAddressRequest.encode(h).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Query", "EscrowAddress", x).then((_) => e.QueryEscrowAddressResponse.decode(new f.Reader(_)));
    }
  }
  e.QueryClientImpl = d;
})(Ec);
var Tc = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(i, P, g, v) {
    v === void 0 && (v = g);
    var N = Object.getOwnPropertyDescriptor(P, g);
    (!N || ("get" in N ? !P.__esModule : N.writable || N.configurable)) && (N = { enumerable: !0, get: function() {
      return P[g];
    } }), Object.defineProperty(i, v, N);
  } : function(i, P, g, v) {
    v === void 0 && (v = g), i[v] = P[g];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(i, P) {
    Object.defineProperty(i, "default", { enumerable: !0, value: P });
  } : function(i, P) {
    i.default = P;
  }), u = Q && Q.__importStar || function(i) {
    if (i && i.__esModule)
      return i;
    var P = {};
    if (i != null)
      for (var g in i)
        g !== "default" && Object.prototype.hasOwnProperty.call(i, g) && o(P, i, g);
    return t(P, i), P;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryNextSequenceReceiveResponse = e.QueryNextSequenceReceiveRequest = e.QueryUnreceivedAcksResponse = e.QueryUnreceivedAcksRequest = e.QueryUnreceivedPacketsResponse = e.QueryUnreceivedPacketsRequest = e.QueryPacketAcknowledgementsResponse = e.QueryPacketAcknowledgementsRequest = e.QueryPacketAcknowledgementResponse = e.QueryPacketAcknowledgementRequest = e.QueryPacketReceiptResponse = e.QueryPacketReceiptRequest = e.QueryPacketCommitmentsResponse = e.QueryPacketCommitmentsRequest = e.QueryPacketCommitmentResponse = e.QueryPacketCommitmentRequest = e.QueryChannelConsensusStateResponse = e.QueryChannelConsensusStateRequest = e.QueryChannelClientStateResponse = e.QueryChannelClientStateRequest = e.QueryConnectionChannelsResponse = e.QueryConnectionChannelsRequest = e.QueryChannelsResponse = e.QueryChannelsRequest = e.QueryChannelResponse = e.QueryChannelRequest = e.protobufPackage = void 0;
  const r = be, m = lr, f = Tt, b = ye, R = ie, T = u(re);
  e.protobufPackage = "ibc.core.channel.v1";
  function V() {
    return {
      portId: "",
      channelId: ""
    };
  }
  e.QueryChannelRequest = {
    encode(i, P = T.Writer.create()) {
      return i.portId !== "" && P.uint32(10).string(i.portId), i.channelId !== "" && P.uint32(18).string(i.channelId), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = V();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.portId = g.string();
            break;
          case 2:
            N.channelId = g.string();
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        portId: (0, R.isSet)(i.portId) ? String(i.portId) : "",
        channelId: (0, R.isSet)(i.channelId) ? String(i.channelId) : ""
      };
    },
    toJSON(i) {
      const P = {};
      return i.portId !== void 0 && (P.portId = i.portId), i.channelId !== void 0 && (P.channelId = i.channelId), P;
    },
    fromPartial(i) {
      const P = V();
      return P.portId = i.portId ?? "", P.channelId = i.channelId ?? "", P;
    }
  };
  function D() {
    return {
      channel: void 0,
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryChannelResponse = {
    encode(i, P = T.Writer.create()) {
      return i.channel !== void 0 && m.Channel.encode(i.channel, P.uint32(10).fork()).ldelim(), i.proof.length !== 0 && P.uint32(18).bytes(i.proof), i.proofHeight !== void 0 && f.Height.encode(i.proofHeight, P.uint32(26).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = D();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.channel = m.Channel.decode(g, g.uint32());
            break;
          case 2:
            N.proof = g.bytes();
            break;
          case 3:
            N.proofHeight = f.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        channel: (0, R.isSet)(i.channel) ? m.Channel.fromJSON(i.channel) : void 0,
        proof: (0, R.isSet)(i.proof) ? (0, R.bytesFromBase64)(i.proof) : new Uint8Array(),
        proofHeight: (0, R.isSet)(i.proofHeight) ? f.Height.fromJSON(i.proofHeight) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.channel !== void 0 && (P.channel = i.channel ? m.Channel.toJSON(i.channel) : void 0), i.proof !== void 0 && (P.proof = (0, R.base64FromBytes)(i.proof !== void 0 ? i.proof : new Uint8Array())), i.proofHeight !== void 0 && (P.proofHeight = i.proofHeight ? f.Height.toJSON(i.proofHeight) : void 0), P;
    },
    fromPartial(i) {
      const P = D();
      return P.channel = i.channel !== void 0 && i.channel !== null ? m.Channel.fromPartial(i.channel) : void 0, P.proof = i.proof ?? new Uint8Array(), P.proofHeight = i.proofHeight !== void 0 && i.proofHeight !== null ? f.Height.fromPartial(i.proofHeight) : void 0, P;
    }
  };
  function B() {
    return {
      pagination: void 0
    };
  }
  e.QueryChannelsRequest = {
    encode(i, P = T.Writer.create()) {
      return i.pagination !== void 0 && r.PageRequest.encode(i.pagination, P.uint32(10).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = B();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.pagination = r.PageRequest.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        pagination: (0, R.isSet)(i.pagination) ? r.PageRequest.fromJSON(i.pagination) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.pagination !== void 0 && (P.pagination = i.pagination ? r.PageRequest.toJSON(i.pagination) : void 0), P;
    },
    fromPartial(i) {
      const P = B();
      return P.pagination = i.pagination !== void 0 && i.pagination !== null ? r.PageRequest.fromPartial(i.pagination) : void 0, P;
    }
  };
  function U() {
    return {
      channels: [],
      pagination: void 0,
      height: void 0
    };
  }
  e.QueryChannelsResponse = {
    encode(i, P = T.Writer.create()) {
      for (const g of i.channels)
        m.IdentifiedChannel.encode(g, P.uint32(10).fork()).ldelim();
      return i.pagination !== void 0 && r.PageResponse.encode(i.pagination, P.uint32(18).fork()).ldelim(), i.height !== void 0 && f.Height.encode(i.height, P.uint32(26).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = U();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.channels.push(m.IdentifiedChannel.decode(g, g.uint32()));
            break;
          case 2:
            N.pagination = r.PageResponse.decode(g, g.uint32());
            break;
          case 3:
            N.height = f.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        channels: Array.isArray(i == null ? void 0 : i.channels) ? i.channels.map((P) => m.IdentifiedChannel.fromJSON(P)) : [],
        pagination: (0, R.isSet)(i.pagination) ? r.PageResponse.fromJSON(i.pagination) : void 0,
        height: (0, R.isSet)(i.height) ? f.Height.fromJSON(i.height) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.channels ? P.channels = i.channels.map((g) => g ? m.IdentifiedChannel.toJSON(g) : void 0) : P.channels = [], i.pagination !== void 0 && (P.pagination = i.pagination ? r.PageResponse.toJSON(i.pagination) : void 0), i.height !== void 0 && (P.height = i.height ? f.Height.toJSON(i.height) : void 0), P;
    },
    fromPartial(i) {
      var P;
      const g = U();
      return g.channels = ((P = i.channels) == null ? void 0 : P.map((v) => m.IdentifiedChannel.fromPartial(v))) || [], g.pagination = i.pagination !== void 0 && i.pagination !== null ? r.PageResponse.fromPartial(i.pagination) : void 0, g.height = i.height !== void 0 && i.height !== null ? f.Height.fromPartial(i.height) : void 0, g;
    }
  };
  function C() {
    return {
      connection: "",
      pagination: void 0
    };
  }
  e.QueryConnectionChannelsRequest = {
    encode(i, P = T.Writer.create()) {
      return i.connection !== "" && P.uint32(10).string(i.connection), i.pagination !== void 0 && r.PageRequest.encode(i.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = C();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.connection = g.string();
            break;
          case 2:
            N.pagination = r.PageRequest.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        connection: (0, R.isSet)(i.connection) ? String(i.connection) : "",
        pagination: (0, R.isSet)(i.pagination) ? r.PageRequest.fromJSON(i.pagination) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.connection !== void 0 && (P.connection = i.connection), i.pagination !== void 0 && (P.pagination = i.pagination ? r.PageRequest.toJSON(i.pagination) : void 0), P;
    },
    fromPartial(i) {
      const P = C();
      return P.connection = i.connection ?? "", P.pagination = i.pagination !== void 0 && i.pagination !== null ? r.PageRequest.fromPartial(i.pagination) : void 0, P;
    }
  };
  function l() {
    return {
      channels: [],
      pagination: void 0,
      height: void 0
    };
  }
  e.QueryConnectionChannelsResponse = {
    encode(i, P = T.Writer.create()) {
      for (const g of i.channels)
        m.IdentifiedChannel.encode(g, P.uint32(10).fork()).ldelim();
      return i.pagination !== void 0 && r.PageResponse.encode(i.pagination, P.uint32(18).fork()).ldelim(), i.height !== void 0 && f.Height.encode(i.height, P.uint32(26).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = l();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.channels.push(m.IdentifiedChannel.decode(g, g.uint32()));
            break;
          case 2:
            N.pagination = r.PageResponse.decode(g, g.uint32());
            break;
          case 3:
            N.height = f.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        channels: Array.isArray(i == null ? void 0 : i.channels) ? i.channels.map((P) => m.IdentifiedChannel.fromJSON(P)) : [],
        pagination: (0, R.isSet)(i.pagination) ? r.PageResponse.fromJSON(i.pagination) : void 0,
        height: (0, R.isSet)(i.height) ? f.Height.fromJSON(i.height) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.channels ? P.channels = i.channels.map((g) => g ? m.IdentifiedChannel.toJSON(g) : void 0) : P.channels = [], i.pagination !== void 0 && (P.pagination = i.pagination ? r.PageResponse.toJSON(i.pagination) : void 0), i.height !== void 0 && (P.height = i.height ? f.Height.toJSON(i.height) : void 0), P;
    },
    fromPartial(i) {
      var P;
      const g = l();
      return g.channels = ((P = i.channels) == null ? void 0 : P.map((v) => m.IdentifiedChannel.fromPartial(v))) || [], g.pagination = i.pagination !== void 0 && i.pagination !== null ? r.PageResponse.fromPartial(i.pagination) : void 0, g.height = i.height !== void 0 && i.height !== null ? f.Height.fromPartial(i.height) : void 0, g;
    }
  };
  function S() {
    return {
      portId: "",
      channelId: ""
    };
  }
  e.QueryChannelClientStateRequest = {
    encode(i, P = T.Writer.create()) {
      return i.portId !== "" && P.uint32(10).string(i.portId), i.channelId !== "" && P.uint32(18).string(i.channelId), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = S();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.portId = g.string();
            break;
          case 2:
            N.channelId = g.string();
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        portId: (0, R.isSet)(i.portId) ? String(i.portId) : "",
        channelId: (0, R.isSet)(i.channelId) ? String(i.channelId) : ""
      };
    },
    toJSON(i) {
      const P = {};
      return i.portId !== void 0 && (P.portId = i.portId), i.channelId !== void 0 && (P.channelId = i.channelId), P;
    },
    fromPartial(i) {
      const P = S();
      return P.portId = i.portId ?? "", P.channelId = i.channelId ?? "", P;
    }
  };
  function A() {
    return {
      identifiedClientState: void 0,
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryChannelClientStateResponse = {
    encode(i, P = T.Writer.create()) {
      return i.identifiedClientState !== void 0 && f.IdentifiedClientState.encode(i.identifiedClientState, P.uint32(10).fork()).ldelim(), i.proof.length !== 0 && P.uint32(18).bytes(i.proof), i.proofHeight !== void 0 && f.Height.encode(i.proofHeight, P.uint32(26).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = A();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.identifiedClientState = f.IdentifiedClientState.decode(g, g.uint32());
            break;
          case 2:
            N.proof = g.bytes();
            break;
          case 3:
            N.proofHeight = f.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        identifiedClientState: (0, R.isSet)(i.identifiedClientState) ? f.IdentifiedClientState.fromJSON(i.identifiedClientState) : void 0,
        proof: (0, R.isSet)(i.proof) ? (0, R.bytesFromBase64)(i.proof) : new Uint8Array(),
        proofHeight: (0, R.isSet)(i.proofHeight) ? f.Height.fromJSON(i.proofHeight) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.identifiedClientState !== void 0 && (P.identifiedClientState = i.identifiedClientState ? f.IdentifiedClientState.toJSON(i.identifiedClientState) : void 0), i.proof !== void 0 && (P.proof = (0, R.base64FromBytes)(i.proof !== void 0 ? i.proof : new Uint8Array())), i.proofHeight !== void 0 && (P.proofHeight = i.proofHeight ? f.Height.toJSON(i.proofHeight) : void 0), P;
    },
    fromPartial(i) {
      const P = A();
      return P.identifiedClientState = i.identifiedClientState !== void 0 && i.identifiedClientState !== null ? f.IdentifiedClientState.fromPartial(i.identifiedClientState) : void 0, P.proof = i.proof ?? new Uint8Array(), P.proofHeight = i.proofHeight !== void 0 && i.proofHeight !== null ? f.Height.fromPartial(i.proofHeight) : void 0, P;
    }
  };
  function d() {
    return {
      portId: "",
      channelId: "",
      revisionNumber: R.Long.UZERO,
      revisionHeight: R.Long.UZERO
    };
  }
  e.QueryChannelConsensusStateRequest = {
    encode(i, P = T.Writer.create()) {
      return i.portId !== "" && P.uint32(10).string(i.portId), i.channelId !== "" && P.uint32(18).string(i.channelId), i.revisionNumber.isZero() || P.uint32(24).uint64(i.revisionNumber), i.revisionHeight.isZero() || P.uint32(32).uint64(i.revisionHeight), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = d();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.portId = g.string();
            break;
          case 2:
            N.channelId = g.string();
            break;
          case 3:
            N.revisionNumber = g.uint64();
            break;
          case 4:
            N.revisionHeight = g.uint64();
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        portId: (0, R.isSet)(i.portId) ? String(i.portId) : "",
        channelId: (0, R.isSet)(i.channelId) ? String(i.channelId) : "",
        revisionNumber: (0, R.isSet)(i.revisionNumber) ? R.Long.fromValue(i.revisionNumber) : R.Long.UZERO,
        revisionHeight: (0, R.isSet)(i.revisionHeight) ? R.Long.fromValue(i.revisionHeight) : R.Long.UZERO
      };
    },
    toJSON(i) {
      const P = {};
      return i.portId !== void 0 && (P.portId = i.portId), i.channelId !== void 0 && (P.channelId = i.channelId), i.revisionNumber !== void 0 && (P.revisionNumber = (i.revisionNumber || R.Long.UZERO).toString()), i.revisionHeight !== void 0 && (P.revisionHeight = (i.revisionHeight || R.Long.UZERO).toString()), P;
    },
    fromPartial(i) {
      const P = d();
      return P.portId = i.portId ?? "", P.channelId = i.channelId ?? "", P.revisionNumber = i.revisionNumber !== void 0 && i.revisionNumber !== null ? R.Long.fromValue(i.revisionNumber) : R.Long.UZERO, P.revisionHeight = i.revisionHeight !== void 0 && i.revisionHeight !== null ? R.Long.fromValue(i.revisionHeight) : R.Long.UZERO, P;
    }
  };
  function p() {
    return {
      consensusState: void 0,
      clientId: "",
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryChannelConsensusStateResponse = {
    encode(i, P = T.Writer.create()) {
      return i.consensusState !== void 0 && b.Any.encode(i.consensusState, P.uint32(10).fork()).ldelim(), i.clientId !== "" && P.uint32(18).string(i.clientId), i.proof.length !== 0 && P.uint32(26).bytes(i.proof), i.proofHeight !== void 0 && f.Height.encode(i.proofHeight, P.uint32(34).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = p();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.consensusState = b.Any.decode(g, g.uint32());
            break;
          case 2:
            N.clientId = g.string();
            break;
          case 3:
            N.proof = g.bytes();
            break;
          case 4:
            N.proofHeight = f.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        consensusState: (0, R.isSet)(i.consensusState) ? b.Any.fromJSON(i.consensusState) : void 0,
        clientId: (0, R.isSet)(i.clientId) ? String(i.clientId) : "",
        proof: (0, R.isSet)(i.proof) ? (0, R.bytesFromBase64)(i.proof) : new Uint8Array(),
        proofHeight: (0, R.isSet)(i.proofHeight) ? f.Height.fromJSON(i.proofHeight) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.consensusState !== void 0 && (P.consensusState = i.consensusState ? b.Any.toJSON(i.consensusState) : void 0), i.clientId !== void 0 && (P.clientId = i.clientId), i.proof !== void 0 && (P.proof = (0, R.base64FromBytes)(i.proof !== void 0 ? i.proof : new Uint8Array())), i.proofHeight !== void 0 && (P.proofHeight = i.proofHeight ? f.Height.toJSON(i.proofHeight) : void 0), P;
    },
    fromPartial(i) {
      const P = p();
      return P.consensusState = i.consensusState !== void 0 && i.consensusState !== null ? b.Any.fromPartial(i.consensusState) : void 0, P.clientId = i.clientId ?? "", P.proof = i.proof ?? new Uint8Array(), P.proofHeight = i.proofHeight !== void 0 && i.proofHeight !== null ? f.Height.fromPartial(i.proofHeight) : void 0, P;
    }
  };
  function h() {
    return {
      portId: "",
      channelId: "",
      sequence: R.Long.UZERO
    };
  }
  e.QueryPacketCommitmentRequest = {
    encode(i, P = T.Writer.create()) {
      return i.portId !== "" && P.uint32(10).string(i.portId), i.channelId !== "" && P.uint32(18).string(i.channelId), i.sequence.isZero() || P.uint32(24).uint64(i.sequence), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = h();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.portId = g.string();
            break;
          case 2:
            N.channelId = g.string();
            break;
          case 3:
            N.sequence = g.uint64();
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        portId: (0, R.isSet)(i.portId) ? String(i.portId) : "",
        channelId: (0, R.isSet)(i.channelId) ? String(i.channelId) : "",
        sequence: (0, R.isSet)(i.sequence) ? R.Long.fromValue(i.sequence) : R.Long.UZERO
      };
    },
    toJSON(i) {
      const P = {};
      return i.portId !== void 0 && (P.portId = i.portId), i.channelId !== void 0 && (P.channelId = i.channelId), i.sequence !== void 0 && (P.sequence = (i.sequence || R.Long.UZERO).toString()), P;
    },
    fromPartial(i) {
      const P = h();
      return P.portId = i.portId ?? "", P.channelId = i.channelId ?? "", P.sequence = i.sequence !== void 0 && i.sequence !== null ? R.Long.fromValue(i.sequence) : R.Long.UZERO, P;
    }
  };
  function x() {
    return {
      commitment: new Uint8Array(),
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryPacketCommitmentResponse = {
    encode(i, P = T.Writer.create()) {
      return i.commitment.length !== 0 && P.uint32(10).bytes(i.commitment), i.proof.length !== 0 && P.uint32(18).bytes(i.proof), i.proofHeight !== void 0 && f.Height.encode(i.proofHeight, P.uint32(26).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = x();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.commitment = g.bytes();
            break;
          case 2:
            N.proof = g.bytes();
            break;
          case 3:
            N.proofHeight = f.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        commitment: (0, R.isSet)(i.commitment) ? (0, R.bytesFromBase64)(i.commitment) : new Uint8Array(),
        proof: (0, R.isSet)(i.proof) ? (0, R.bytesFromBase64)(i.proof) : new Uint8Array(),
        proofHeight: (0, R.isSet)(i.proofHeight) ? f.Height.fromJSON(i.proofHeight) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.commitment !== void 0 && (P.commitment = (0, R.base64FromBytes)(i.commitment !== void 0 ? i.commitment : new Uint8Array())), i.proof !== void 0 && (P.proof = (0, R.base64FromBytes)(i.proof !== void 0 ? i.proof : new Uint8Array())), i.proofHeight !== void 0 && (P.proofHeight = i.proofHeight ? f.Height.toJSON(i.proofHeight) : void 0), P;
    },
    fromPartial(i) {
      const P = x();
      return P.commitment = i.commitment ?? new Uint8Array(), P.proof = i.proof ?? new Uint8Array(), P.proofHeight = i.proofHeight !== void 0 && i.proofHeight !== null ? f.Height.fromPartial(i.proofHeight) : void 0, P;
    }
  };
  function _() {
    return {
      portId: "",
      channelId: "",
      pagination: void 0
    };
  }
  e.QueryPacketCommitmentsRequest = {
    encode(i, P = T.Writer.create()) {
      return i.portId !== "" && P.uint32(10).string(i.portId), i.channelId !== "" && P.uint32(18).string(i.channelId), i.pagination !== void 0 && r.PageRequest.encode(i.pagination, P.uint32(26).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = _();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.portId = g.string();
            break;
          case 2:
            N.channelId = g.string();
            break;
          case 3:
            N.pagination = r.PageRequest.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        portId: (0, R.isSet)(i.portId) ? String(i.portId) : "",
        channelId: (0, R.isSet)(i.channelId) ? String(i.channelId) : "",
        pagination: (0, R.isSet)(i.pagination) ? r.PageRequest.fromJSON(i.pagination) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.portId !== void 0 && (P.portId = i.portId), i.channelId !== void 0 && (P.channelId = i.channelId), i.pagination !== void 0 && (P.pagination = i.pagination ? r.PageRequest.toJSON(i.pagination) : void 0), P;
    },
    fromPartial(i) {
      const P = _();
      return P.portId = i.portId ?? "", P.channelId = i.channelId ?? "", P.pagination = i.pagination !== void 0 && i.pagination !== null ? r.PageRequest.fromPartial(i.pagination) : void 0, P;
    }
  };
  function I() {
    return {
      commitments: [],
      pagination: void 0,
      height: void 0
    };
  }
  e.QueryPacketCommitmentsResponse = {
    encode(i, P = T.Writer.create()) {
      for (const g of i.commitments)
        m.PacketState.encode(g, P.uint32(10).fork()).ldelim();
      return i.pagination !== void 0 && r.PageResponse.encode(i.pagination, P.uint32(18).fork()).ldelim(), i.height !== void 0 && f.Height.encode(i.height, P.uint32(26).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = I();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.commitments.push(m.PacketState.decode(g, g.uint32()));
            break;
          case 2:
            N.pagination = r.PageResponse.decode(g, g.uint32());
            break;
          case 3:
            N.height = f.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        commitments: Array.isArray(i == null ? void 0 : i.commitments) ? i.commitments.map((P) => m.PacketState.fromJSON(P)) : [],
        pagination: (0, R.isSet)(i.pagination) ? r.PageResponse.fromJSON(i.pagination) : void 0,
        height: (0, R.isSet)(i.height) ? f.Height.fromJSON(i.height) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.commitments ? P.commitments = i.commitments.map((g) => g ? m.PacketState.toJSON(g) : void 0) : P.commitments = [], i.pagination !== void 0 && (P.pagination = i.pagination ? r.PageResponse.toJSON(i.pagination) : void 0), i.height !== void 0 && (P.height = i.height ? f.Height.toJSON(i.height) : void 0), P;
    },
    fromPartial(i) {
      var P;
      const g = I();
      return g.commitments = ((P = i.commitments) == null ? void 0 : P.map((v) => m.PacketState.fromPartial(v))) || [], g.pagination = i.pagination !== void 0 && i.pagination !== null ? r.PageResponse.fromPartial(i.pagination) : void 0, g.height = i.height !== void 0 && i.height !== null ? f.Height.fromPartial(i.height) : void 0, g;
    }
  };
  function W() {
    return {
      portId: "",
      channelId: "",
      sequence: R.Long.UZERO
    };
  }
  e.QueryPacketReceiptRequest = {
    encode(i, P = T.Writer.create()) {
      return i.portId !== "" && P.uint32(10).string(i.portId), i.channelId !== "" && P.uint32(18).string(i.channelId), i.sequence.isZero() || P.uint32(24).uint64(i.sequence), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = W();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.portId = g.string();
            break;
          case 2:
            N.channelId = g.string();
            break;
          case 3:
            N.sequence = g.uint64();
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        portId: (0, R.isSet)(i.portId) ? String(i.portId) : "",
        channelId: (0, R.isSet)(i.channelId) ? String(i.channelId) : "",
        sequence: (0, R.isSet)(i.sequence) ? R.Long.fromValue(i.sequence) : R.Long.UZERO
      };
    },
    toJSON(i) {
      const P = {};
      return i.portId !== void 0 && (P.portId = i.portId), i.channelId !== void 0 && (P.channelId = i.channelId), i.sequence !== void 0 && (P.sequence = (i.sequence || R.Long.UZERO).toString()), P;
    },
    fromPartial(i) {
      const P = W();
      return P.portId = i.portId ?? "", P.channelId = i.channelId ?? "", P.sequence = i.sequence !== void 0 && i.sequence !== null ? R.Long.fromValue(i.sequence) : R.Long.UZERO, P;
    }
  };
  function n() {
    return {
      received: !1,
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryPacketReceiptResponse = {
    encode(i, P = T.Writer.create()) {
      return i.received === !0 && P.uint32(16).bool(i.received), i.proof.length !== 0 && P.uint32(26).bytes(i.proof), i.proofHeight !== void 0 && f.Height.encode(i.proofHeight, P.uint32(34).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = n();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 2:
            N.received = g.bool();
            break;
          case 3:
            N.proof = g.bytes();
            break;
          case 4:
            N.proofHeight = f.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        received: (0, R.isSet)(i.received) ? !!i.received : !1,
        proof: (0, R.isSet)(i.proof) ? (0, R.bytesFromBase64)(i.proof) : new Uint8Array(),
        proofHeight: (0, R.isSet)(i.proofHeight) ? f.Height.fromJSON(i.proofHeight) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.received !== void 0 && (P.received = i.received), i.proof !== void 0 && (P.proof = (0, R.base64FromBytes)(i.proof !== void 0 ? i.proof : new Uint8Array())), i.proofHeight !== void 0 && (P.proofHeight = i.proofHeight ? f.Height.toJSON(i.proofHeight) : void 0), P;
    },
    fromPartial(i) {
      const P = n();
      return P.received = i.received ?? !1, P.proof = i.proof ?? new Uint8Array(), P.proofHeight = i.proofHeight !== void 0 && i.proofHeight !== null ? f.Height.fromPartial(i.proofHeight) : void 0, P;
    }
  };
  function y() {
    return {
      portId: "",
      channelId: "",
      sequence: R.Long.UZERO
    };
  }
  e.QueryPacketAcknowledgementRequest = {
    encode(i, P = T.Writer.create()) {
      return i.portId !== "" && P.uint32(10).string(i.portId), i.channelId !== "" && P.uint32(18).string(i.channelId), i.sequence.isZero() || P.uint32(24).uint64(i.sequence), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = y();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.portId = g.string();
            break;
          case 2:
            N.channelId = g.string();
            break;
          case 3:
            N.sequence = g.uint64();
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        portId: (0, R.isSet)(i.portId) ? String(i.portId) : "",
        channelId: (0, R.isSet)(i.channelId) ? String(i.channelId) : "",
        sequence: (0, R.isSet)(i.sequence) ? R.Long.fromValue(i.sequence) : R.Long.UZERO
      };
    },
    toJSON(i) {
      const P = {};
      return i.portId !== void 0 && (P.portId = i.portId), i.channelId !== void 0 && (P.channelId = i.channelId), i.sequence !== void 0 && (P.sequence = (i.sequence || R.Long.UZERO).toString()), P;
    },
    fromPartial(i) {
      const P = y();
      return P.portId = i.portId ?? "", P.channelId = i.channelId ?? "", P.sequence = i.sequence !== void 0 && i.sequence !== null ? R.Long.fromValue(i.sequence) : R.Long.UZERO, P;
    }
  };
  function w() {
    return {
      acknowledgement: new Uint8Array(),
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryPacketAcknowledgementResponse = {
    encode(i, P = T.Writer.create()) {
      return i.acknowledgement.length !== 0 && P.uint32(10).bytes(i.acknowledgement), i.proof.length !== 0 && P.uint32(18).bytes(i.proof), i.proofHeight !== void 0 && f.Height.encode(i.proofHeight, P.uint32(26).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = w();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.acknowledgement = g.bytes();
            break;
          case 2:
            N.proof = g.bytes();
            break;
          case 3:
            N.proofHeight = f.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        acknowledgement: (0, R.isSet)(i.acknowledgement) ? (0, R.bytesFromBase64)(i.acknowledgement) : new Uint8Array(),
        proof: (0, R.isSet)(i.proof) ? (0, R.bytesFromBase64)(i.proof) : new Uint8Array(),
        proofHeight: (0, R.isSet)(i.proofHeight) ? f.Height.fromJSON(i.proofHeight) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.acknowledgement !== void 0 && (P.acknowledgement = (0, R.base64FromBytes)(i.acknowledgement !== void 0 ? i.acknowledgement : new Uint8Array())), i.proof !== void 0 && (P.proof = (0, R.base64FromBytes)(i.proof !== void 0 ? i.proof : new Uint8Array())), i.proofHeight !== void 0 && (P.proofHeight = i.proofHeight ? f.Height.toJSON(i.proofHeight) : void 0), P;
    },
    fromPartial(i) {
      const P = w();
      return P.acknowledgement = i.acknowledgement ?? new Uint8Array(), P.proof = i.proof ?? new Uint8Array(), P.proofHeight = i.proofHeight !== void 0 && i.proofHeight !== null ? f.Height.fromPartial(i.proofHeight) : void 0, P;
    }
  };
  function M() {
    return {
      portId: "",
      channelId: "",
      pagination: void 0,
      packetCommitmentSequences: []
    };
  }
  e.QueryPacketAcknowledgementsRequest = {
    encode(i, P = T.Writer.create()) {
      i.portId !== "" && P.uint32(10).string(i.portId), i.channelId !== "" && P.uint32(18).string(i.channelId), i.pagination !== void 0 && r.PageRequest.encode(i.pagination, P.uint32(26).fork()).ldelim(), P.uint32(34).fork();
      for (const g of i.packetCommitmentSequences)
        P.uint64(g);
      return P.ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = M();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.portId = g.string();
            break;
          case 2:
            N.channelId = g.string();
            break;
          case 3:
            N.pagination = r.PageRequest.decode(g, g.uint32());
            break;
          case 4:
            if ((q & 7) === 2) {
              const G = g.uint32() + g.pos;
              for (; g.pos < G; )
                N.packetCommitmentSequences.push(g.uint64());
            } else
              N.packetCommitmentSequences.push(g.uint64());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        portId: (0, R.isSet)(i.portId) ? String(i.portId) : "",
        channelId: (0, R.isSet)(i.channelId) ? String(i.channelId) : "",
        pagination: (0, R.isSet)(i.pagination) ? r.PageRequest.fromJSON(i.pagination) : void 0,
        packetCommitmentSequences: Array.isArray(i == null ? void 0 : i.packetCommitmentSequences) ? i.packetCommitmentSequences.map((P) => R.Long.fromValue(P)) : []
      };
    },
    toJSON(i) {
      const P = {};
      return i.portId !== void 0 && (P.portId = i.portId), i.channelId !== void 0 && (P.channelId = i.channelId), i.pagination !== void 0 && (P.pagination = i.pagination ? r.PageRequest.toJSON(i.pagination) : void 0), i.packetCommitmentSequences ? P.packetCommitmentSequences = i.packetCommitmentSequences.map((g) => (g || R.Long.UZERO).toString()) : P.packetCommitmentSequences = [], P;
    },
    fromPartial(i) {
      var P;
      const g = M();
      return g.portId = i.portId ?? "", g.channelId = i.channelId ?? "", g.pagination = i.pagination !== void 0 && i.pagination !== null ? r.PageRequest.fromPartial(i.pagination) : void 0, g.packetCommitmentSequences = ((P = i.packetCommitmentSequences) == null ? void 0 : P.map((v) => R.Long.fromValue(v))) || [], g;
    }
  };
  function s() {
    return {
      acknowledgements: [],
      pagination: void 0,
      height: void 0
    };
  }
  e.QueryPacketAcknowledgementsResponse = {
    encode(i, P = T.Writer.create()) {
      for (const g of i.acknowledgements)
        m.PacketState.encode(g, P.uint32(10).fork()).ldelim();
      return i.pagination !== void 0 && r.PageResponse.encode(i.pagination, P.uint32(18).fork()).ldelim(), i.height !== void 0 && f.Height.encode(i.height, P.uint32(26).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = s();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.acknowledgements.push(m.PacketState.decode(g, g.uint32()));
            break;
          case 2:
            N.pagination = r.PageResponse.decode(g, g.uint32());
            break;
          case 3:
            N.height = f.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        acknowledgements: Array.isArray(i == null ? void 0 : i.acknowledgements) ? i.acknowledgements.map((P) => m.PacketState.fromJSON(P)) : [],
        pagination: (0, R.isSet)(i.pagination) ? r.PageResponse.fromJSON(i.pagination) : void 0,
        height: (0, R.isSet)(i.height) ? f.Height.fromJSON(i.height) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.acknowledgements ? P.acknowledgements = i.acknowledgements.map((g) => g ? m.PacketState.toJSON(g) : void 0) : P.acknowledgements = [], i.pagination !== void 0 && (P.pagination = i.pagination ? r.PageResponse.toJSON(i.pagination) : void 0), i.height !== void 0 && (P.height = i.height ? f.Height.toJSON(i.height) : void 0), P;
    },
    fromPartial(i) {
      var P;
      const g = s();
      return g.acknowledgements = ((P = i.acknowledgements) == null ? void 0 : P.map((v) => m.PacketState.fromPartial(v))) || [], g.pagination = i.pagination !== void 0 && i.pagination !== null ? r.PageResponse.fromPartial(i.pagination) : void 0, g.height = i.height !== void 0 && i.height !== null ? f.Height.fromPartial(i.height) : void 0, g;
    }
  };
  function c() {
    return {
      portId: "",
      channelId: "",
      packetCommitmentSequences: []
    };
  }
  e.QueryUnreceivedPacketsRequest = {
    encode(i, P = T.Writer.create()) {
      i.portId !== "" && P.uint32(10).string(i.portId), i.channelId !== "" && P.uint32(18).string(i.channelId), P.uint32(26).fork();
      for (const g of i.packetCommitmentSequences)
        P.uint64(g);
      return P.ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = c();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.portId = g.string();
            break;
          case 2:
            N.channelId = g.string();
            break;
          case 3:
            if ((q & 7) === 2) {
              const G = g.uint32() + g.pos;
              for (; g.pos < G; )
                N.packetCommitmentSequences.push(g.uint64());
            } else
              N.packetCommitmentSequences.push(g.uint64());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        portId: (0, R.isSet)(i.portId) ? String(i.portId) : "",
        channelId: (0, R.isSet)(i.channelId) ? String(i.channelId) : "",
        packetCommitmentSequences: Array.isArray(i == null ? void 0 : i.packetCommitmentSequences) ? i.packetCommitmentSequences.map((P) => R.Long.fromValue(P)) : []
      };
    },
    toJSON(i) {
      const P = {};
      return i.portId !== void 0 && (P.portId = i.portId), i.channelId !== void 0 && (P.channelId = i.channelId), i.packetCommitmentSequences ? P.packetCommitmentSequences = i.packetCommitmentSequences.map((g) => (g || R.Long.UZERO).toString()) : P.packetCommitmentSequences = [], P;
    },
    fromPartial(i) {
      var P;
      const g = c();
      return g.portId = i.portId ?? "", g.channelId = i.channelId ?? "", g.packetCommitmentSequences = ((P = i.packetCommitmentSequences) == null ? void 0 : P.map((v) => R.Long.fromValue(v))) || [], g;
    }
  };
  function E() {
    return {
      sequences: [],
      height: void 0
    };
  }
  e.QueryUnreceivedPacketsResponse = {
    encode(i, P = T.Writer.create()) {
      P.uint32(10).fork();
      for (const g of i.sequences)
        P.uint64(g);
      return P.ldelim(), i.height !== void 0 && f.Height.encode(i.height, P.uint32(18).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = E();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            if ((q & 7) === 2) {
              const G = g.uint32() + g.pos;
              for (; g.pos < G; )
                N.sequences.push(g.uint64());
            } else
              N.sequences.push(g.uint64());
            break;
          case 2:
            N.height = f.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        sequences: Array.isArray(i == null ? void 0 : i.sequences) ? i.sequences.map((P) => R.Long.fromValue(P)) : [],
        height: (0, R.isSet)(i.height) ? f.Height.fromJSON(i.height) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.sequences ? P.sequences = i.sequences.map((g) => (g || R.Long.UZERO).toString()) : P.sequences = [], i.height !== void 0 && (P.height = i.height ? f.Height.toJSON(i.height) : void 0), P;
    },
    fromPartial(i) {
      var P;
      const g = E();
      return g.sequences = ((P = i.sequences) == null ? void 0 : P.map((v) => R.Long.fromValue(v))) || [], g.height = i.height !== void 0 && i.height !== null ? f.Height.fromPartial(i.height) : void 0, g;
    }
  };
  function k() {
    return {
      portId: "",
      channelId: "",
      packetAckSequences: []
    };
  }
  e.QueryUnreceivedAcksRequest = {
    encode(i, P = T.Writer.create()) {
      i.portId !== "" && P.uint32(10).string(i.portId), i.channelId !== "" && P.uint32(18).string(i.channelId), P.uint32(26).fork();
      for (const g of i.packetAckSequences)
        P.uint64(g);
      return P.ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = k();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.portId = g.string();
            break;
          case 2:
            N.channelId = g.string();
            break;
          case 3:
            if ((q & 7) === 2) {
              const G = g.uint32() + g.pos;
              for (; g.pos < G; )
                N.packetAckSequences.push(g.uint64());
            } else
              N.packetAckSequences.push(g.uint64());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        portId: (0, R.isSet)(i.portId) ? String(i.portId) : "",
        channelId: (0, R.isSet)(i.channelId) ? String(i.channelId) : "",
        packetAckSequences: Array.isArray(i == null ? void 0 : i.packetAckSequences) ? i.packetAckSequences.map((P) => R.Long.fromValue(P)) : []
      };
    },
    toJSON(i) {
      const P = {};
      return i.portId !== void 0 && (P.portId = i.portId), i.channelId !== void 0 && (P.channelId = i.channelId), i.packetAckSequences ? P.packetAckSequences = i.packetAckSequences.map((g) => (g || R.Long.UZERO).toString()) : P.packetAckSequences = [], P;
    },
    fromPartial(i) {
      var P;
      const g = k();
      return g.portId = i.portId ?? "", g.channelId = i.channelId ?? "", g.packetAckSequences = ((P = i.packetAckSequences) == null ? void 0 : P.map((v) => R.Long.fromValue(v))) || [], g;
    }
  };
  function O() {
    return {
      sequences: [],
      height: void 0
    };
  }
  e.QueryUnreceivedAcksResponse = {
    encode(i, P = T.Writer.create()) {
      P.uint32(10).fork();
      for (const g of i.sequences)
        P.uint64(g);
      return P.ldelim(), i.height !== void 0 && f.Height.encode(i.height, P.uint32(18).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = O();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            if ((q & 7) === 2) {
              const G = g.uint32() + g.pos;
              for (; g.pos < G; )
                N.sequences.push(g.uint64());
            } else
              N.sequences.push(g.uint64());
            break;
          case 2:
            N.height = f.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        sequences: Array.isArray(i == null ? void 0 : i.sequences) ? i.sequences.map((P) => R.Long.fromValue(P)) : [],
        height: (0, R.isSet)(i.height) ? f.Height.fromJSON(i.height) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.sequences ? P.sequences = i.sequences.map((g) => (g || R.Long.UZERO).toString()) : P.sequences = [], i.height !== void 0 && (P.height = i.height ? f.Height.toJSON(i.height) : void 0), P;
    },
    fromPartial(i) {
      var P;
      const g = O();
      return g.sequences = ((P = i.sequences) == null ? void 0 : P.map((v) => R.Long.fromValue(v))) || [], g.height = i.height !== void 0 && i.height !== null ? f.Height.fromPartial(i.height) : void 0, g;
    }
  };
  function L() {
    return {
      portId: "",
      channelId: ""
    };
  }
  e.QueryNextSequenceReceiveRequest = {
    encode(i, P = T.Writer.create()) {
      return i.portId !== "" && P.uint32(10).string(i.portId), i.channelId !== "" && P.uint32(18).string(i.channelId), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = L();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.portId = g.string();
            break;
          case 2:
            N.channelId = g.string();
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        portId: (0, R.isSet)(i.portId) ? String(i.portId) : "",
        channelId: (0, R.isSet)(i.channelId) ? String(i.channelId) : ""
      };
    },
    toJSON(i) {
      const P = {};
      return i.portId !== void 0 && (P.portId = i.portId), i.channelId !== void 0 && (P.channelId = i.channelId), P;
    },
    fromPartial(i) {
      const P = L();
      return P.portId = i.portId ?? "", P.channelId = i.channelId ?? "", P;
    }
  };
  function Z() {
    return {
      nextSequenceReceive: R.Long.UZERO,
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryNextSequenceReceiveResponse = {
    encode(i, P = T.Writer.create()) {
      return i.nextSequenceReceive.isZero() || P.uint32(8).uint64(i.nextSequenceReceive), i.proof.length !== 0 && P.uint32(18).bytes(i.proof), i.proofHeight !== void 0 && f.Height.encode(i.proofHeight, P.uint32(26).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof T.Reader ? i : new T.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = Z();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.nextSequenceReceive = g.uint64();
            break;
          case 2:
            N.proof = g.bytes();
            break;
          case 3:
            N.proofHeight = f.Height.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        nextSequenceReceive: (0, R.isSet)(i.nextSequenceReceive) ? R.Long.fromValue(i.nextSequenceReceive) : R.Long.UZERO,
        proof: (0, R.isSet)(i.proof) ? (0, R.bytesFromBase64)(i.proof) : new Uint8Array(),
        proofHeight: (0, R.isSet)(i.proofHeight) ? f.Height.fromJSON(i.proofHeight) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.nextSequenceReceive !== void 0 && (P.nextSequenceReceive = (i.nextSequenceReceive || R.Long.UZERO).toString()), i.proof !== void 0 && (P.proof = (0, R.base64FromBytes)(i.proof !== void 0 ? i.proof : new Uint8Array())), i.proofHeight !== void 0 && (P.proofHeight = i.proofHeight ? f.Height.toJSON(i.proofHeight) : void 0), P;
    },
    fromPartial(i) {
      const P = Z();
      return P.nextSequenceReceive = i.nextSequenceReceive !== void 0 && i.nextSequenceReceive !== null ? R.Long.fromValue(i.nextSequenceReceive) : R.Long.UZERO, P.proof = i.proof ?? new Uint8Array(), P.proofHeight = i.proofHeight !== void 0 && i.proofHeight !== null ? f.Height.fromPartial(i.proofHeight) : void 0, P;
    }
  };
  class j {
    constructor(P) {
      this.rpc = P, this.Channel = this.Channel.bind(this), this.Channels = this.Channels.bind(this), this.ConnectionChannels = this.ConnectionChannels.bind(this), this.ChannelClientState = this.ChannelClientState.bind(this), this.ChannelConsensusState = this.ChannelConsensusState.bind(this), this.PacketCommitment = this.PacketCommitment.bind(this), this.PacketCommitments = this.PacketCommitments.bind(this), this.PacketReceipt = this.PacketReceipt.bind(this), this.PacketAcknowledgement = this.PacketAcknowledgement.bind(this), this.PacketAcknowledgements = this.PacketAcknowledgements.bind(this), this.UnreceivedPackets = this.UnreceivedPackets.bind(this), this.UnreceivedAcks = this.UnreceivedAcks.bind(this), this.NextSequenceReceive = this.NextSequenceReceive.bind(this);
    }
    Channel(P) {
      const g = e.QueryChannelRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "Channel", g).then((v) => e.QueryChannelResponse.decode(new T.Reader(v)));
    }
    Channels(P = {
      pagination: void 0
    }) {
      const g = e.QueryChannelsRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "Channels", g).then((v) => e.QueryChannelsResponse.decode(new T.Reader(v)));
    }
    ConnectionChannels(P) {
      const g = e.QueryConnectionChannelsRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "ConnectionChannels", g).then((v) => e.QueryConnectionChannelsResponse.decode(new T.Reader(v)));
    }
    ChannelClientState(P) {
      const g = e.QueryChannelClientStateRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "ChannelClientState", g).then((v) => e.QueryChannelClientStateResponse.decode(new T.Reader(v)));
    }
    ChannelConsensusState(P) {
      const g = e.QueryChannelConsensusStateRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "ChannelConsensusState", g).then((v) => e.QueryChannelConsensusStateResponse.decode(new T.Reader(v)));
    }
    PacketCommitment(P) {
      const g = e.QueryPacketCommitmentRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitment", g).then((v) => e.QueryPacketCommitmentResponse.decode(new T.Reader(v)));
    }
    PacketCommitments(P) {
      const g = e.QueryPacketCommitmentsRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitments", g).then((v) => e.QueryPacketCommitmentsResponse.decode(new T.Reader(v)));
    }
    PacketReceipt(P) {
      const g = e.QueryPacketReceiptRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "PacketReceipt", g).then((v) => e.QueryPacketReceiptResponse.decode(new T.Reader(v)));
    }
    PacketAcknowledgement(P) {
      const g = e.QueryPacketAcknowledgementRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgement", g).then((v) => e.QueryPacketAcknowledgementResponse.decode(new T.Reader(v)));
    }
    PacketAcknowledgements(P) {
      const g = e.QueryPacketAcknowledgementsRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgements", g).then((v) => e.QueryPacketAcknowledgementsResponse.decode(new T.Reader(v)));
    }
    UnreceivedPackets(P) {
      const g = e.QueryUnreceivedPacketsRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedPackets", g).then((v) => e.QueryUnreceivedPacketsResponse.decode(new T.Reader(v)));
    }
    UnreceivedAcks(P) {
      const g = e.QueryUnreceivedAcksRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedAcks", g).then((v) => e.QueryUnreceivedAcksResponse.decode(new T.Reader(v)));
    }
    NextSequenceReceive(P) {
      const g = e.QueryNextSequenceReceiveRequest.encode(P).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "NextSequenceReceive", g).then((v) => e.QueryNextSequenceReceiveResponse.decode(new T.Reader(v)));
    }
  }
  e.QueryClientImpl = j;
})(Tc);
var Cc = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(M, s, c, E) {
    E === void 0 && (E = c);
    var k = Object.getOwnPropertyDescriptor(s, c);
    (!k || ("get" in k ? !s.__esModule : k.writable || k.configurable)) && (k = { enumerable: !0, get: function() {
      return s[c];
    } }), Object.defineProperty(M, E, k);
  } : function(M, s, c, E) {
    E === void 0 && (E = c), M[E] = s[c];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(M, s) {
    Object.defineProperty(M, "default", { enumerable: !0, value: s });
  } : function(M, s) {
    M.default = s;
  }), u = Q && Q.__importStar || function(M) {
    if (M && M.__esModule)
      return M;
    var s = {};
    if (M != null)
      for (var c in M)
        c !== "default" && Object.prototype.hasOwnProperty.call(M, c) && o(s, M, c);
    return t(s, M), s;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryUpgradedConsensusStateResponse = e.QueryUpgradedConsensusStateRequest = e.QueryUpgradedClientStateResponse = e.QueryUpgradedClientStateRequest = e.QueryClientParamsResponse = e.QueryClientParamsRequest = e.QueryClientStatusResponse = e.QueryClientStatusRequest = e.QueryConsensusStateHeightsResponse = e.QueryConsensusStateHeightsRequest = e.QueryConsensusStatesResponse = e.QueryConsensusStatesRequest = e.QueryConsensusStateResponse = e.QueryConsensusStateRequest = e.QueryClientStatesResponse = e.QueryClientStatesRequest = e.QueryClientStateResponse = e.QueryClientStateRequest = e.protobufPackage = void 0;
  const r = be, m = ye, f = Tt, b = ie, R = u(re);
  e.protobufPackage = "ibc.core.client.v1";
  function T() {
    return {
      clientId: ""
    };
  }
  e.QueryClientStateRequest = {
    encode(M, s = R.Writer.create()) {
      return M.clientId !== "" && s.uint32(10).string(M.clientId), s;
    },
    decode(M, s) {
      const c = M instanceof R.Reader ? M : new R.Reader(M);
      let E = s === void 0 ? c.len : c.pos + s;
      const k = T();
      for (; c.pos < E; ) {
        const O = c.uint32();
        switch (O >>> 3) {
          case 1:
            k.clientId = c.string();
            break;
          default:
            c.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(M) {
      return {
        clientId: (0, b.isSet)(M.clientId) ? String(M.clientId) : ""
      };
    },
    toJSON(M) {
      const s = {};
      return M.clientId !== void 0 && (s.clientId = M.clientId), s;
    },
    fromPartial(M) {
      const s = T();
      return s.clientId = M.clientId ?? "", s;
    }
  };
  function V() {
    return {
      clientState: void 0,
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryClientStateResponse = {
    encode(M, s = R.Writer.create()) {
      return M.clientState !== void 0 && m.Any.encode(M.clientState, s.uint32(10).fork()).ldelim(), M.proof.length !== 0 && s.uint32(18).bytes(M.proof), M.proofHeight !== void 0 && f.Height.encode(M.proofHeight, s.uint32(26).fork()).ldelim(), s;
    },
    decode(M, s) {
      const c = M instanceof R.Reader ? M : new R.Reader(M);
      let E = s === void 0 ? c.len : c.pos + s;
      const k = V();
      for (; c.pos < E; ) {
        const O = c.uint32();
        switch (O >>> 3) {
          case 1:
            k.clientState = m.Any.decode(c, c.uint32());
            break;
          case 2:
            k.proof = c.bytes();
            break;
          case 3:
            k.proofHeight = f.Height.decode(c, c.uint32());
            break;
          default:
            c.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(M) {
      return {
        clientState: (0, b.isSet)(M.clientState) ? m.Any.fromJSON(M.clientState) : void 0,
        proof: (0, b.isSet)(M.proof) ? (0, b.bytesFromBase64)(M.proof) : new Uint8Array(),
        proofHeight: (0, b.isSet)(M.proofHeight) ? f.Height.fromJSON(M.proofHeight) : void 0
      };
    },
    toJSON(M) {
      const s = {};
      return M.clientState !== void 0 && (s.clientState = M.clientState ? m.Any.toJSON(M.clientState) : void 0), M.proof !== void 0 && (s.proof = (0, b.base64FromBytes)(M.proof !== void 0 ? M.proof : new Uint8Array())), M.proofHeight !== void 0 && (s.proofHeight = M.proofHeight ? f.Height.toJSON(M.proofHeight) : void 0), s;
    },
    fromPartial(M) {
      const s = V();
      return s.clientState = M.clientState !== void 0 && M.clientState !== null ? m.Any.fromPartial(M.clientState) : void 0, s.proof = M.proof ?? new Uint8Array(), s.proofHeight = M.proofHeight !== void 0 && M.proofHeight !== null ? f.Height.fromPartial(M.proofHeight) : void 0, s;
    }
  };
  function D() {
    return {
      pagination: void 0
    };
  }
  e.QueryClientStatesRequest = {
    encode(M, s = R.Writer.create()) {
      return M.pagination !== void 0 && r.PageRequest.encode(M.pagination, s.uint32(10).fork()).ldelim(), s;
    },
    decode(M, s) {
      const c = M instanceof R.Reader ? M : new R.Reader(M);
      let E = s === void 0 ? c.len : c.pos + s;
      const k = D();
      for (; c.pos < E; ) {
        const O = c.uint32();
        switch (O >>> 3) {
          case 1:
            k.pagination = r.PageRequest.decode(c, c.uint32());
            break;
          default:
            c.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(M) {
      return {
        pagination: (0, b.isSet)(M.pagination) ? r.PageRequest.fromJSON(M.pagination) : void 0
      };
    },
    toJSON(M) {
      const s = {};
      return M.pagination !== void 0 && (s.pagination = M.pagination ? r.PageRequest.toJSON(M.pagination) : void 0), s;
    },
    fromPartial(M) {
      const s = D();
      return s.pagination = M.pagination !== void 0 && M.pagination !== null ? r.PageRequest.fromPartial(M.pagination) : void 0, s;
    }
  };
  function B() {
    return {
      clientStates: [],
      pagination: void 0
    };
  }
  e.QueryClientStatesResponse = {
    encode(M, s = R.Writer.create()) {
      for (const c of M.clientStates)
        f.IdentifiedClientState.encode(c, s.uint32(10).fork()).ldelim();
      return M.pagination !== void 0 && r.PageResponse.encode(M.pagination, s.uint32(18).fork()).ldelim(), s;
    },
    decode(M, s) {
      const c = M instanceof R.Reader ? M : new R.Reader(M);
      let E = s === void 0 ? c.len : c.pos + s;
      const k = B();
      for (; c.pos < E; ) {
        const O = c.uint32();
        switch (O >>> 3) {
          case 1:
            k.clientStates.push(f.IdentifiedClientState.decode(c, c.uint32()));
            break;
          case 2:
            k.pagination = r.PageResponse.decode(c, c.uint32());
            break;
          default:
            c.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(M) {
      return {
        clientStates: Array.isArray(M == null ? void 0 : M.clientStates) ? M.clientStates.map((s) => f.IdentifiedClientState.fromJSON(s)) : [],
        pagination: (0, b.isSet)(M.pagination) ? r.PageResponse.fromJSON(M.pagination) : void 0
      };
    },
    toJSON(M) {
      const s = {};
      return M.clientStates ? s.clientStates = M.clientStates.map((c) => c ? f.IdentifiedClientState.toJSON(c) : void 0) : s.clientStates = [], M.pagination !== void 0 && (s.pagination = M.pagination ? r.PageResponse.toJSON(M.pagination) : void 0), s;
    },
    fromPartial(M) {
      var s;
      const c = B();
      return c.clientStates = ((s = M.clientStates) == null ? void 0 : s.map((E) => f.IdentifiedClientState.fromPartial(E))) || [], c.pagination = M.pagination !== void 0 && M.pagination !== null ? r.PageResponse.fromPartial(M.pagination) : void 0, c;
    }
  };
  function U() {
    return {
      clientId: "",
      revisionNumber: b.Long.UZERO,
      revisionHeight: b.Long.UZERO,
      latestHeight: !1
    };
  }
  e.QueryConsensusStateRequest = {
    encode(M, s = R.Writer.create()) {
      return M.clientId !== "" && s.uint32(10).string(M.clientId), M.revisionNumber.isZero() || s.uint32(16).uint64(M.revisionNumber), M.revisionHeight.isZero() || s.uint32(24).uint64(M.revisionHeight), M.latestHeight === !0 && s.uint32(32).bool(M.latestHeight), s;
    },
    decode(M, s) {
      const c = M instanceof R.Reader ? M : new R.Reader(M);
      let E = s === void 0 ? c.len : c.pos + s;
      const k = U();
      for (; c.pos < E; ) {
        const O = c.uint32();
        switch (O >>> 3) {
          case 1:
            k.clientId = c.string();
            break;
          case 2:
            k.revisionNumber = c.uint64();
            break;
          case 3:
            k.revisionHeight = c.uint64();
            break;
          case 4:
            k.latestHeight = c.bool();
            break;
          default:
            c.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(M) {
      return {
        clientId: (0, b.isSet)(M.clientId) ? String(M.clientId) : "",
        revisionNumber: (0, b.isSet)(M.revisionNumber) ? b.Long.fromValue(M.revisionNumber) : b.Long.UZERO,
        revisionHeight: (0, b.isSet)(M.revisionHeight) ? b.Long.fromValue(M.revisionHeight) : b.Long.UZERO,
        latestHeight: (0, b.isSet)(M.latestHeight) ? !!M.latestHeight : !1
      };
    },
    toJSON(M) {
      const s = {};
      return M.clientId !== void 0 && (s.clientId = M.clientId), M.revisionNumber !== void 0 && (s.revisionNumber = (M.revisionNumber || b.Long.UZERO).toString()), M.revisionHeight !== void 0 && (s.revisionHeight = (M.revisionHeight || b.Long.UZERO).toString()), M.latestHeight !== void 0 && (s.latestHeight = M.latestHeight), s;
    },
    fromPartial(M) {
      const s = U();
      return s.clientId = M.clientId ?? "", s.revisionNumber = M.revisionNumber !== void 0 && M.revisionNumber !== null ? b.Long.fromValue(M.revisionNumber) : b.Long.UZERO, s.revisionHeight = M.revisionHeight !== void 0 && M.revisionHeight !== null ? b.Long.fromValue(M.revisionHeight) : b.Long.UZERO, s.latestHeight = M.latestHeight ?? !1, s;
    }
  };
  function C() {
    return {
      consensusState: void 0,
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryConsensusStateResponse = {
    encode(M, s = R.Writer.create()) {
      return M.consensusState !== void 0 && m.Any.encode(M.consensusState, s.uint32(10).fork()).ldelim(), M.proof.length !== 0 && s.uint32(18).bytes(M.proof), M.proofHeight !== void 0 && f.Height.encode(M.proofHeight, s.uint32(26).fork()).ldelim(), s;
    },
    decode(M, s) {
      const c = M instanceof R.Reader ? M : new R.Reader(M);
      let E = s === void 0 ? c.len : c.pos + s;
      const k = C();
      for (; c.pos < E; ) {
        const O = c.uint32();
        switch (O >>> 3) {
          case 1:
            k.consensusState = m.Any.decode(c, c.uint32());
            break;
          case 2:
            k.proof = c.bytes();
            break;
          case 3:
            k.proofHeight = f.Height.decode(c, c.uint32());
            break;
          default:
            c.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(M) {
      return {
        consensusState: (0, b.isSet)(M.consensusState) ? m.Any.fromJSON(M.consensusState) : void 0,
        proof: (0, b.isSet)(M.proof) ? (0, b.bytesFromBase64)(M.proof) : new Uint8Array(),
        proofHeight: (0, b.isSet)(M.proofHeight) ? f.Height.fromJSON(M.proofHeight) : void 0
      };
    },
    toJSON(M) {
      const s = {};
      return M.consensusState !== void 0 && (s.consensusState = M.consensusState ? m.Any.toJSON(M.consensusState) : void 0), M.proof !== void 0 && (s.proof = (0, b.base64FromBytes)(M.proof !== void 0 ? M.proof : new Uint8Array())), M.proofHeight !== void 0 && (s.proofHeight = M.proofHeight ? f.Height.toJSON(M.proofHeight) : void 0), s;
    },
    fromPartial(M) {
      const s = C();
      return s.consensusState = M.consensusState !== void 0 && M.consensusState !== null ? m.Any.fromPartial(M.consensusState) : void 0, s.proof = M.proof ?? new Uint8Array(), s.proofHeight = M.proofHeight !== void 0 && M.proofHeight !== null ? f.Height.fromPartial(M.proofHeight) : void 0, s;
    }
  };
  function l() {
    return {
      clientId: "",
      pagination: void 0
    };
  }
  e.QueryConsensusStatesRequest = {
    encode(M, s = R.Writer.create()) {
      return M.clientId !== "" && s.uint32(10).string(M.clientId), M.pagination !== void 0 && r.PageRequest.encode(M.pagination, s.uint32(18).fork()).ldelim(), s;
    },
    decode(M, s) {
      const c = M instanceof R.Reader ? M : new R.Reader(M);
      let E = s === void 0 ? c.len : c.pos + s;
      const k = l();
      for (; c.pos < E; ) {
        const O = c.uint32();
        switch (O >>> 3) {
          case 1:
            k.clientId = c.string();
            break;
          case 2:
            k.pagination = r.PageRequest.decode(c, c.uint32());
            break;
          default:
            c.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(M) {
      return {
        clientId: (0, b.isSet)(M.clientId) ? String(M.clientId) : "",
        pagination: (0, b.isSet)(M.pagination) ? r.PageRequest.fromJSON(M.pagination) : void 0
      };
    },
    toJSON(M) {
      const s = {};
      return M.clientId !== void 0 && (s.clientId = M.clientId), M.pagination !== void 0 && (s.pagination = M.pagination ? r.PageRequest.toJSON(M.pagination) : void 0), s;
    },
    fromPartial(M) {
      const s = l();
      return s.clientId = M.clientId ?? "", s.pagination = M.pagination !== void 0 && M.pagination !== null ? r.PageRequest.fromPartial(M.pagination) : void 0, s;
    }
  };
  function S() {
    return {
      consensusStates: [],
      pagination: void 0
    };
  }
  e.QueryConsensusStatesResponse = {
    encode(M, s = R.Writer.create()) {
      for (const c of M.consensusStates)
        f.ConsensusStateWithHeight.encode(c, s.uint32(10).fork()).ldelim();
      return M.pagination !== void 0 && r.PageResponse.encode(M.pagination, s.uint32(18).fork()).ldelim(), s;
    },
    decode(M, s) {
      const c = M instanceof R.Reader ? M : new R.Reader(M);
      let E = s === void 0 ? c.len : c.pos + s;
      const k = S();
      for (; c.pos < E; ) {
        const O = c.uint32();
        switch (O >>> 3) {
          case 1:
            k.consensusStates.push(f.ConsensusStateWithHeight.decode(c, c.uint32()));
            break;
          case 2:
            k.pagination = r.PageResponse.decode(c, c.uint32());
            break;
          default:
            c.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(M) {
      return {
        consensusStates: Array.isArray(M == null ? void 0 : M.consensusStates) ? M.consensusStates.map((s) => f.ConsensusStateWithHeight.fromJSON(s)) : [],
        pagination: (0, b.isSet)(M.pagination) ? r.PageResponse.fromJSON(M.pagination) : void 0
      };
    },
    toJSON(M) {
      const s = {};
      return M.consensusStates ? s.consensusStates = M.consensusStates.map((c) => c ? f.ConsensusStateWithHeight.toJSON(c) : void 0) : s.consensusStates = [], M.pagination !== void 0 && (s.pagination = M.pagination ? r.PageResponse.toJSON(M.pagination) : void 0), s;
    },
    fromPartial(M) {
      var s;
      const c = S();
      return c.consensusStates = ((s = M.consensusStates) == null ? void 0 : s.map((E) => f.ConsensusStateWithHeight.fromPartial(E))) || [], c.pagination = M.pagination !== void 0 && M.pagination !== null ? r.PageResponse.fromPartial(M.pagination) : void 0, c;
    }
  };
  function A() {
    return {
      clientId: "",
      pagination: void 0
    };
  }
  e.QueryConsensusStateHeightsRequest = {
    encode(M, s = R.Writer.create()) {
      return M.clientId !== "" && s.uint32(10).string(M.clientId), M.pagination !== void 0 && r.PageRequest.encode(M.pagination, s.uint32(18).fork()).ldelim(), s;
    },
    decode(M, s) {
      const c = M instanceof R.Reader ? M : new R.Reader(M);
      let E = s === void 0 ? c.len : c.pos + s;
      const k = A();
      for (; c.pos < E; ) {
        const O = c.uint32();
        switch (O >>> 3) {
          case 1:
            k.clientId = c.string();
            break;
          case 2:
            k.pagination = r.PageRequest.decode(c, c.uint32());
            break;
          default:
            c.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(M) {
      return {
        clientId: (0, b.isSet)(M.clientId) ? String(M.clientId) : "",
        pagination: (0, b.isSet)(M.pagination) ? r.PageRequest.fromJSON(M.pagination) : void 0
      };
    },
    toJSON(M) {
      const s = {};
      return M.clientId !== void 0 && (s.clientId = M.clientId), M.pagination !== void 0 && (s.pagination = M.pagination ? r.PageRequest.toJSON(M.pagination) : void 0), s;
    },
    fromPartial(M) {
      const s = A();
      return s.clientId = M.clientId ?? "", s.pagination = M.pagination !== void 0 && M.pagination !== null ? r.PageRequest.fromPartial(M.pagination) : void 0, s;
    }
  };
  function d() {
    return {
      consensusStateHeights: [],
      pagination: void 0
    };
  }
  e.QueryConsensusStateHeightsResponse = {
    encode(M, s = R.Writer.create()) {
      for (const c of M.consensusStateHeights)
        f.Height.encode(c, s.uint32(10).fork()).ldelim();
      return M.pagination !== void 0 && r.PageResponse.encode(M.pagination, s.uint32(18).fork()).ldelim(), s;
    },
    decode(M, s) {
      const c = M instanceof R.Reader ? M : new R.Reader(M);
      let E = s === void 0 ? c.len : c.pos + s;
      const k = d();
      for (; c.pos < E; ) {
        const O = c.uint32();
        switch (O >>> 3) {
          case 1:
            k.consensusStateHeights.push(f.Height.decode(c, c.uint32()));
            break;
          case 2:
            k.pagination = r.PageResponse.decode(c, c.uint32());
            break;
          default:
            c.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(M) {
      return {
        consensusStateHeights: Array.isArray(M == null ? void 0 : M.consensusStateHeights) ? M.consensusStateHeights.map((s) => f.Height.fromJSON(s)) : [],
        pagination: (0, b.isSet)(M.pagination) ? r.PageResponse.fromJSON(M.pagination) : void 0
      };
    },
    toJSON(M) {
      const s = {};
      return M.consensusStateHeights ? s.consensusStateHeights = M.consensusStateHeights.map((c) => c ? f.Height.toJSON(c) : void 0) : s.consensusStateHeights = [], M.pagination !== void 0 && (s.pagination = M.pagination ? r.PageResponse.toJSON(M.pagination) : void 0), s;
    },
    fromPartial(M) {
      var s;
      const c = d();
      return c.consensusStateHeights = ((s = M.consensusStateHeights) == null ? void 0 : s.map((E) => f.Height.fromPartial(E))) || [], c.pagination = M.pagination !== void 0 && M.pagination !== null ? r.PageResponse.fromPartial(M.pagination) : void 0, c;
    }
  };
  function p() {
    return {
      clientId: ""
    };
  }
  e.QueryClientStatusRequest = {
    encode(M, s = R.Writer.create()) {
      return M.clientId !== "" && s.uint32(10).string(M.clientId), s;
    },
    decode(M, s) {
      const c = M instanceof R.Reader ? M : new R.Reader(M);
      let E = s === void 0 ? c.len : c.pos + s;
      const k = p();
      for (; c.pos < E; ) {
        const O = c.uint32();
        switch (O >>> 3) {
          case 1:
            k.clientId = c.string();
            break;
          default:
            c.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(M) {
      return {
        clientId: (0, b.isSet)(M.clientId) ? String(M.clientId) : ""
      };
    },
    toJSON(M) {
      const s = {};
      return M.clientId !== void 0 && (s.clientId = M.clientId), s;
    },
    fromPartial(M) {
      const s = p();
      return s.clientId = M.clientId ?? "", s;
    }
  };
  function h() {
    return {
      status: ""
    };
  }
  e.QueryClientStatusResponse = {
    encode(M, s = R.Writer.create()) {
      return M.status !== "" && s.uint32(10).string(M.status), s;
    },
    decode(M, s) {
      const c = M instanceof R.Reader ? M : new R.Reader(M);
      let E = s === void 0 ? c.len : c.pos + s;
      const k = h();
      for (; c.pos < E; ) {
        const O = c.uint32();
        switch (O >>> 3) {
          case 1:
            k.status = c.string();
            break;
          default:
            c.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(M) {
      return {
        status: (0, b.isSet)(M.status) ? String(M.status) : ""
      };
    },
    toJSON(M) {
      const s = {};
      return M.status !== void 0 && (s.status = M.status), s;
    },
    fromPartial(M) {
      const s = h();
      return s.status = M.status ?? "", s;
    }
  };
  function x() {
    return {};
  }
  e.QueryClientParamsRequest = {
    encode(M, s = R.Writer.create()) {
      return s;
    },
    decode(M, s) {
      const c = M instanceof R.Reader ? M : new R.Reader(M);
      let E = s === void 0 ? c.len : c.pos + s;
      const k = x();
      for (; c.pos < E; ) {
        const O = c.uint32();
        switch (O >>> 3) {
          default:
            c.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(M) {
      return {};
    },
    toJSON(M) {
      return {};
    },
    fromPartial(M) {
      return x();
    }
  };
  function _() {
    return {
      params: void 0
    };
  }
  e.QueryClientParamsResponse = {
    encode(M, s = R.Writer.create()) {
      return M.params !== void 0 && f.Params.encode(M.params, s.uint32(10).fork()).ldelim(), s;
    },
    decode(M, s) {
      const c = M instanceof R.Reader ? M : new R.Reader(M);
      let E = s === void 0 ? c.len : c.pos + s;
      const k = _();
      for (; c.pos < E; ) {
        const O = c.uint32();
        switch (O >>> 3) {
          case 1:
            k.params = f.Params.decode(c, c.uint32());
            break;
          default:
            c.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(M) {
      return {
        params: (0, b.isSet)(M.params) ? f.Params.fromJSON(M.params) : void 0
      };
    },
    toJSON(M) {
      const s = {};
      return M.params !== void 0 && (s.params = M.params ? f.Params.toJSON(M.params) : void 0), s;
    },
    fromPartial(M) {
      const s = _();
      return s.params = M.params !== void 0 && M.params !== null ? f.Params.fromPartial(M.params) : void 0, s;
    }
  };
  function I() {
    return {};
  }
  e.QueryUpgradedClientStateRequest = {
    encode(M, s = R.Writer.create()) {
      return s;
    },
    decode(M, s) {
      const c = M instanceof R.Reader ? M : new R.Reader(M);
      let E = s === void 0 ? c.len : c.pos + s;
      const k = I();
      for (; c.pos < E; ) {
        const O = c.uint32();
        switch (O >>> 3) {
          default:
            c.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(M) {
      return {};
    },
    toJSON(M) {
      return {};
    },
    fromPartial(M) {
      return I();
    }
  };
  function W() {
    return {
      upgradedClientState: void 0
    };
  }
  e.QueryUpgradedClientStateResponse = {
    encode(M, s = R.Writer.create()) {
      return M.upgradedClientState !== void 0 && m.Any.encode(M.upgradedClientState, s.uint32(10).fork()).ldelim(), s;
    },
    decode(M, s) {
      const c = M instanceof R.Reader ? M : new R.Reader(M);
      let E = s === void 0 ? c.len : c.pos + s;
      const k = W();
      for (; c.pos < E; ) {
        const O = c.uint32();
        switch (O >>> 3) {
          case 1:
            k.upgradedClientState = m.Any.decode(c, c.uint32());
            break;
          default:
            c.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(M) {
      return {
        upgradedClientState: (0, b.isSet)(M.upgradedClientState) ? m.Any.fromJSON(M.upgradedClientState) : void 0
      };
    },
    toJSON(M) {
      const s = {};
      return M.upgradedClientState !== void 0 && (s.upgradedClientState = M.upgradedClientState ? m.Any.toJSON(M.upgradedClientState) : void 0), s;
    },
    fromPartial(M) {
      const s = W();
      return s.upgradedClientState = M.upgradedClientState !== void 0 && M.upgradedClientState !== null ? m.Any.fromPartial(M.upgradedClientState) : void 0, s;
    }
  };
  function n() {
    return {};
  }
  e.QueryUpgradedConsensusStateRequest = {
    encode(M, s = R.Writer.create()) {
      return s;
    },
    decode(M, s) {
      const c = M instanceof R.Reader ? M : new R.Reader(M);
      let E = s === void 0 ? c.len : c.pos + s;
      const k = n();
      for (; c.pos < E; ) {
        const O = c.uint32();
        switch (O >>> 3) {
          default:
            c.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(M) {
      return {};
    },
    toJSON(M) {
      return {};
    },
    fromPartial(M) {
      return n();
    }
  };
  function y() {
    return {
      upgradedConsensusState: void 0
    };
  }
  e.QueryUpgradedConsensusStateResponse = {
    encode(M, s = R.Writer.create()) {
      return M.upgradedConsensusState !== void 0 && m.Any.encode(M.upgradedConsensusState, s.uint32(10).fork()).ldelim(), s;
    },
    decode(M, s) {
      const c = M instanceof R.Reader ? M : new R.Reader(M);
      let E = s === void 0 ? c.len : c.pos + s;
      const k = y();
      for (; c.pos < E; ) {
        const O = c.uint32();
        switch (O >>> 3) {
          case 1:
            k.upgradedConsensusState = m.Any.decode(c, c.uint32());
            break;
          default:
            c.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(M) {
      return {
        upgradedConsensusState: (0, b.isSet)(M.upgradedConsensusState) ? m.Any.fromJSON(M.upgradedConsensusState) : void 0
      };
    },
    toJSON(M) {
      const s = {};
      return M.upgradedConsensusState !== void 0 && (s.upgradedConsensusState = M.upgradedConsensusState ? m.Any.toJSON(M.upgradedConsensusState) : void 0), s;
    },
    fromPartial(M) {
      const s = y();
      return s.upgradedConsensusState = M.upgradedConsensusState !== void 0 && M.upgradedConsensusState !== null ? m.Any.fromPartial(M.upgradedConsensusState) : void 0, s;
    }
  };
  class w {
    constructor(s) {
      this.rpc = s, this.ClientState = this.ClientState.bind(this), this.ClientStates = this.ClientStates.bind(this), this.ConsensusState = this.ConsensusState.bind(this), this.ConsensusStates = this.ConsensusStates.bind(this), this.ConsensusStateHeights = this.ConsensusStateHeights.bind(this), this.ClientStatus = this.ClientStatus.bind(this), this.ClientParams = this.ClientParams.bind(this), this.UpgradedClientState = this.UpgradedClientState.bind(this), this.UpgradedConsensusState = this.UpgradedConsensusState.bind(this);
    }
    ClientState(s) {
      const c = e.QueryClientStateRequest.encode(s).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ClientState", c).then((E) => e.QueryClientStateResponse.decode(new R.Reader(E)));
    }
    ClientStates(s = {
      pagination: void 0
    }) {
      const c = e.QueryClientStatesRequest.encode(s).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ClientStates", c).then((E) => e.QueryClientStatesResponse.decode(new R.Reader(E)));
    }
    ConsensusState(s) {
      const c = e.QueryConsensusStateRequest.encode(s).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ConsensusState", c).then((E) => e.QueryConsensusStateResponse.decode(new R.Reader(E)));
    }
    ConsensusStates(s) {
      const c = e.QueryConsensusStatesRequest.encode(s).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ConsensusStates", c).then((E) => e.QueryConsensusStatesResponse.decode(new R.Reader(E)));
    }
    ConsensusStateHeights(s) {
      const c = e.QueryConsensusStateHeightsRequest.encode(s).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ConsensusStateHeights", c).then((E) => e.QueryConsensusStateHeightsResponse.decode(new R.Reader(E)));
    }
    ClientStatus(s) {
      const c = e.QueryClientStatusRequest.encode(s).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ClientStatus", c).then((E) => e.QueryClientStatusResponse.decode(new R.Reader(E)));
    }
    ClientParams(s = {}) {
      const c = e.QueryClientParamsRequest.encode(s).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ClientParams", c).then((E) => e.QueryClientParamsResponse.decode(new R.Reader(E)));
    }
    UpgradedClientState(s = {}) {
      const c = e.QueryUpgradedClientStateRequest.encode(s).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "UpgradedClientState", c).then((E) => e.QueryUpgradedClientStateResponse.decode(new R.Reader(E)));
    }
    UpgradedConsensusState(s = {}) {
      const c = e.QueryUpgradedConsensusStateRequest.encode(s).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "UpgradedConsensusState", c).then((E) => e.QueryUpgradedConsensusStateResponse.decode(new R.Reader(E)));
    }
  }
  e.QueryClientImpl = w;
})(Cc);
var Ic = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(I, W, n, y) {
    y === void 0 && (y = n);
    var w = Object.getOwnPropertyDescriptor(W, n);
    (!w || ("get" in w ? !W.__esModule : w.writable || w.configurable)) && (w = { enumerable: !0, get: function() {
      return W[n];
    } }), Object.defineProperty(I, y, w);
  } : function(I, W, n, y) {
    y === void 0 && (y = n), I[y] = W[n];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(I, W) {
    Object.defineProperty(I, "default", { enumerable: !0, value: W });
  } : function(I, W) {
    I.default = W;
  }), u = Q && Q.__importStar || function(I) {
    if (I && I.__esModule)
      return I;
    var W = {};
    if (I != null)
      for (var n in I)
        n !== "default" && Object.prototype.hasOwnProperty.call(I, n) && o(W, I, n);
    return t(W, I), W;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryConnectionParamsResponse = e.QueryConnectionParamsRequest = e.QueryConnectionConsensusStateResponse = e.QueryConnectionConsensusStateRequest = e.QueryConnectionClientStateResponse = e.QueryConnectionClientStateRequest = e.QueryClientConnectionsResponse = e.QueryClientConnectionsRequest = e.QueryConnectionsResponse = e.QueryConnectionsRequest = e.QueryConnectionResponse = e.QueryConnectionRequest = e.protobufPackage = void 0;
  const r = be, m = Yi, f = Tt, b = ye, R = ie, T = u(re);
  e.protobufPackage = "ibc.core.connection.v1";
  function V() {
    return {
      connectionId: ""
    };
  }
  e.QueryConnectionRequest = {
    encode(I, W = T.Writer.create()) {
      return I.connectionId !== "" && W.uint32(10).string(I.connectionId), W;
    },
    decode(I, W) {
      const n = I instanceof T.Reader ? I : new T.Reader(I);
      let y = W === void 0 ? n.len : n.pos + W;
      const w = V();
      for (; n.pos < y; ) {
        const M = n.uint32();
        switch (M >>> 3) {
          case 1:
            w.connectionId = n.string();
            break;
          default:
            n.skipType(M & 7);
            break;
        }
      }
      return w;
    },
    fromJSON(I) {
      return {
        connectionId: (0, R.isSet)(I.connectionId) ? String(I.connectionId) : ""
      };
    },
    toJSON(I) {
      const W = {};
      return I.connectionId !== void 0 && (W.connectionId = I.connectionId), W;
    },
    fromPartial(I) {
      const W = V();
      return W.connectionId = I.connectionId ?? "", W;
    }
  };
  function D() {
    return {
      connection: void 0,
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryConnectionResponse = {
    encode(I, W = T.Writer.create()) {
      return I.connection !== void 0 && m.ConnectionEnd.encode(I.connection, W.uint32(10).fork()).ldelim(), I.proof.length !== 0 && W.uint32(18).bytes(I.proof), I.proofHeight !== void 0 && f.Height.encode(I.proofHeight, W.uint32(26).fork()).ldelim(), W;
    },
    decode(I, W) {
      const n = I instanceof T.Reader ? I : new T.Reader(I);
      let y = W === void 0 ? n.len : n.pos + W;
      const w = D();
      for (; n.pos < y; ) {
        const M = n.uint32();
        switch (M >>> 3) {
          case 1:
            w.connection = m.ConnectionEnd.decode(n, n.uint32());
            break;
          case 2:
            w.proof = n.bytes();
            break;
          case 3:
            w.proofHeight = f.Height.decode(n, n.uint32());
            break;
          default:
            n.skipType(M & 7);
            break;
        }
      }
      return w;
    },
    fromJSON(I) {
      return {
        connection: (0, R.isSet)(I.connection) ? m.ConnectionEnd.fromJSON(I.connection) : void 0,
        proof: (0, R.isSet)(I.proof) ? (0, R.bytesFromBase64)(I.proof) : new Uint8Array(),
        proofHeight: (0, R.isSet)(I.proofHeight) ? f.Height.fromJSON(I.proofHeight) : void 0
      };
    },
    toJSON(I) {
      const W = {};
      return I.connection !== void 0 && (W.connection = I.connection ? m.ConnectionEnd.toJSON(I.connection) : void 0), I.proof !== void 0 && (W.proof = (0, R.base64FromBytes)(I.proof !== void 0 ? I.proof : new Uint8Array())), I.proofHeight !== void 0 && (W.proofHeight = I.proofHeight ? f.Height.toJSON(I.proofHeight) : void 0), W;
    },
    fromPartial(I) {
      const W = D();
      return W.connection = I.connection !== void 0 && I.connection !== null ? m.ConnectionEnd.fromPartial(I.connection) : void 0, W.proof = I.proof ?? new Uint8Array(), W.proofHeight = I.proofHeight !== void 0 && I.proofHeight !== null ? f.Height.fromPartial(I.proofHeight) : void 0, W;
    }
  };
  function B() {
    return {
      pagination: void 0
    };
  }
  e.QueryConnectionsRequest = {
    encode(I, W = T.Writer.create()) {
      return I.pagination !== void 0 && r.PageRequest.encode(I.pagination, W.uint32(10).fork()).ldelim(), W;
    },
    decode(I, W) {
      const n = I instanceof T.Reader ? I : new T.Reader(I);
      let y = W === void 0 ? n.len : n.pos + W;
      const w = B();
      for (; n.pos < y; ) {
        const M = n.uint32();
        switch (M >>> 3) {
          case 1:
            w.pagination = r.PageRequest.decode(n, n.uint32());
            break;
          default:
            n.skipType(M & 7);
            break;
        }
      }
      return w;
    },
    fromJSON(I) {
      return {
        pagination: (0, R.isSet)(I.pagination) ? r.PageRequest.fromJSON(I.pagination) : void 0
      };
    },
    toJSON(I) {
      const W = {};
      return I.pagination !== void 0 && (W.pagination = I.pagination ? r.PageRequest.toJSON(I.pagination) : void 0), W;
    },
    fromPartial(I) {
      const W = B();
      return W.pagination = I.pagination !== void 0 && I.pagination !== null ? r.PageRequest.fromPartial(I.pagination) : void 0, W;
    }
  };
  function U() {
    return {
      connections: [],
      pagination: void 0,
      height: void 0
    };
  }
  e.QueryConnectionsResponse = {
    encode(I, W = T.Writer.create()) {
      for (const n of I.connections)
        m.IdentifiedConnection.encode(n, W.uint32(10).fork()).ldelim();
      return I.pagination !== void 0 && r.PageResponse.encode(I.pagination, W.uint32(18).fork()).ldelim(), I.height !== void 0 && f.Height.encode(I.height, W.uint32(26).fork()).ldelim(), W;
    },
    decode(I, W) {
      const n = I instanceof T.Reader ? I : new T.Reader(I);
      let y = W === void 0 ? n.len : n.pos + W;
      const w = U();
      for (; n.pos < y; ) {
        const M = n.uint32();
        switch (M >>> 3) {
          case 1:
            w.connections.push(m.IdentifiedConnection.decode(n, n.uint32()));
            break;
          case 2:
            w.pagination = r.PageResponse.decode(n, n.uint32());
            break;
          case 3:
            w.height = f.Height.decode(n, n.uint32());
            break;
          default:
            n.skipType(M & 7);
            break;
        }
      }
      return w;
    },
    fromJSON(I) {
      return {
        connections: Array.isArray(I == null ? void 0 : I.connections) ? I.connections.map((W) => m.IdentifiedConnection.fromJSON(W)) : [],
        pagination: (0, R.isSet)(I.pagination) ? r.PageResponse.fromJSON(I.pagination) : void 0,
        height: (0, R.isSet)(I.height) ? f.Height.fromJSON(I.height) : void 0
      };
    },
    toJSON(I) {
      const W = {};
      return I.connections ? W.connections = I.connections.map((n) => n ? m.IdentifiedConnection.toJSON(n) : void 0) : W.connections = [], I.pagination !== void 0 && (W.pagination = I.pagination ? r.PageResponse.toJSON(I.pagination) : void 0), I.height !== void 0 && (W.height = I.height ? f.Height.toJSON(I.height) : void 0), W;
    },
    fromPartial(I) {
      var W;
      const n = U();
      return n.connections = ((W = I.connections) == null ? void 0 : W.map((y) => m.IdentifiedConnection.fromPartial(y))) || [], n.pagination = I.pagination !== void 0 && I.pagination !== null ? r.PageResponse.fromPartial(I.pagination) : void 0, n.height = I.height !== void 0 && I.height !== null ? f.Height.fromPartial(I.height) : void 0, n;
    }
  };
  function C() {
    return {
      clientId: ""
    };
  }
  e.QueryClientConnectionsRequest = {
    encode(I, W = T.Writer.create()) {
      return I.clientId !== "" && W.uint32(10).string(I.clientId), W;
    },
    decode(I, W) {
      const n = I instanceof T.Reader ? I : new T.Reader(I);
      let y = W === void 0 ? n.len : n.pos + W;
      const w = C();
      for (; n.pos < y; ) {
        const M = n.uint32();
        switch (M >>> 3) {
          case 1:
            w.clientId = n.string();
            break;
          default:
            n.skipType(M & 7);
            break;
        }
      }
      return w;
    },
    fromJSON(I) {
      return {
        clientId: (0, R.isSet)(I.clientId) ? String(I.clientId) : ""
      };
    },
    toJSON(I) {
      const W = {};
      return I.clientId !== void 0 && (W.clientId = I.clientId), W;
    },
    fromPartial(I) {
      const W = C();
      return W.clientId = I.clientId ?? "", W;
    }
  };
  function l() {
    return {
      connectionPaths: [],
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryClientConnectionsResponse = {
    encode(I, W = T.Writer.create()) {
      for (const n of I.connectionPaths)
        W.uint32(10).string(n);
      return I.proof.length !== 0 && W.uint32(18).bytes(I.proof), I.proofHeight !== void 0 && f.Height.encode(I.proofHeight, W.uint32(26).fork()).ldelim(), W;
    },
    decode(I, W) {
      const n = I instanceof T.Reader ? I : new T.Reader(I);
      let y = W === void 0 ? n.len : n.pos + W;
      const w = l();
      for (; n.pos < y; ) {
        const M = n.uint32();
        switch (M >>> 3) {
          case 1:
            w.connectionPaths.push(n.string());
            break;
          case 2:
            w.proof = n.bytes();
            break;
          case 3:
            w.proofHeight = f.Height.decode(n, n.uint32());
            break;
          default:
            n.skipType(M & 7);
            break;
        }
      }
      return w;
    },
    fromJSON(I) {
      return {
        connectionPaths: Array.isArray(I == null ? void 0 : I.connectionPaths) ? I.connectionPaths.map((W) => String(W)) : [],
        proof: (0, R.isSet)(I.proof) ? (0, R.bytesFromBase64)(I.proof) : new Uint8Array(),
        proofHeight: (0, R.isSet)(I.proofHeight) ? f.Height.fromJSON(I.proofHeight) : void 0
      };
    },
    toJSON(I) {
      const W = {};
      return I.connectionPaths ? W.connectionPaths = I.connectionPaths.map((n) => n) : W.connectionPaths = [], I.proof !== void 0 && (W.proof = (0, R.base64FromBytes)(I.proof !== void 0 ? I.proof : new Uint8Array())), I.proofHeight !== void 0 && (W.proofHeight = I.proofHeight ? f.Height.toJSON(I.proofHeight) : void 0), W;
    },
    fromPartial(I) {
      var W;
      const n = l();
      return n.connectionPaths = ((W = I.connectionPaths) == null ? void 0 : W.map((y) => y)) || [], n.proof = I.proof ?? new Uint8Array(), n.proofHeight = I.proofHeight !== void 0 && I.proofHeight !== null ? f.Height.fromPartial(I.proofHeight) : void 0, n;
    }
  };
  function S() {
    return {
      connectionId: ""
    };
  }
  e.QueryConnectionClientStateRequest = {
    encode(I, W = T.Writer.create()) {
      return I.connectionId !== "" && W.uint32(10).string(I.connectionId), W;
    },
    decode(I, W) {
      const n = I instanceof T.Reader ? I : new T.Reader(I);
      let y = W === void 0 ? n.len : n.pos + W;
      const w = S();
      for (; n.pos < y; ) {
        const M = n.uint32();
        switch (M >>> 3) {
          case 1:
            w.connectionId = n.string();
            break;
          default:
            n.skipType(M & 7);
            break;
        }
      }
      return w;
    },
    fromJSON(I) {
      return {
        connectionId: (0, R.isSet)(I.connectionId) ? String(I.connectionId) : ""
      };
    },
    toJSON(I) {
      const W = {};
      return I.connectionId !== void 0 && (W.connectionId = I.connectionId), W;
    },
    fromPartial(I) {
      const W = S();
      return W.connectionId = I.connectionId ?? "", W;
    }
  };
  function A() {
    return {
      identifiedClientState: void 0,
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryConnectionClientStateResponse = {
    encode(I, W = T.Writer.create()) {
      return I.identifiedClientState !== void 0 && f.IdentifiedClientState.encode(I.identifiedClientState, W.uint32(10).fork()).ldelim(), I.proof.length !== 0 && W.uint32(18).bytes(I.proof), I.proofHeight !== void 0 && f.Height.encode(I.proofHeight, W.uint32(26).fork()).ldelim(), W;
    },
    decode(I, W) {
      const n = I instanceof T.Reader ? I : new T.Reader(I);
      let y = W === void 0 ? n.len : n.pos + W;
      const w = A();
      for (; n.pos < y; ) {
        const M = n.uint32();
        switch (M >>> 3) {
          case 1:
            w.identifiedClientState = f.IdentifiedClientState.decode(n, n.uint32());
            break;
          case 2:
            w.proof = n.bytes();
            break;
          case 3:
            w.proofHeight = f.Height.decode(n, n.uint32());
            break;
          default:
            n.skipType(M & 7);
            break;
        }
      }
      return w;
    },
    fromJSON(I) {
      return {
        identifiedClientState: (0, R.isSet)(I.identifiedClientState) ? f.IdentifiedClientState.fromJSON(I.identifiedClientState) : void 0,
        proof: (0, R.isSet)(I.proof) ? (0, R.bytesFromBase64)(I.proof) : new Uint8Array(),
        proofHeight: (0, R.isSet)(I.proofHeight) ? f.Height.fromJSON(I.proofHeight) : void 0
      };
    },
    toJSON(I) {
      const W = {};
      return I.identifiedClientState !== void 0 && (W.identifiedClientState = I.identifiedClientState ? f.IdentifiedClientState.toJSON(I.identifiedClientState) : void 0), I.proof !== void 0 && (W.proof = (0, R.base64FromBytes)(I.proof !== void 0 ? I.proof : new Uint8Array())), I.proofHeight !== void 0 && (W.proofHeight = I.proofHeight ? f.Height.toJSON(I.proofHeight) : void 0), W;
    },
    fromPartial(I) {
      const W = A();
      return W.identifiedClientState = I.identifiedClientState !== void 0 && I.identifiedClientState !== null ? f.IdentifiedClientState.fromPartial(I.identifiedClientState) : void 0, W.proof = I.proof ?? new Uint8Array(), W.proofHeight = I.proofHeight !== void 0 && I.proofHeight !== null ? f.Height.fromPartial(I.proofHeight) : void 0, W;
    }
  };
  function d() {
    return {
      connectionId: "",
      revisionNumber: R.Long.UZERO,
      revisionHeight: R.Long.UZERO
    };
  }
  e.QueryConnectionConsensusStateRequest = {
    encode(I, W = T.Writer.create()) {
      return I.connectionId !== "" && W.uint32(10).string(I.connectionId), I.revisionNumber.isZero() || W.uint32(16).uint64(I.revisionNumber), I.revisionHeight.isZero() || W.uint32(24).uint64(I.revisionHeight), W;
    },
    decode(I, W) {
      const n = I instanceof T.Reader ? I : new T.Reader(I);
      let y = W === void 0 ? n.len : n.pos + W;
      const w = d();
      for (; n.pos < y; ) {
        const M = n.uint32();
        switch (M >>> 3) {
          case 1:
            w.connectionId = n.string();
            break;
          case 2:
            w.revisionNumber = n.uint64();
            break;
          case 3:
            w.revisionHeight = n.uint64();
            break;
          default:
            n.skipType(M & 7);
            break;
        }
      }
      return w;
    },
    fromJSON(I) {
      return {
        connectionId: (0, R.isSet)(I.connectionId) ? String(I.connectionId) : "",
        revisionNumber: (0, R.isSet)(I.revisionNumber) ? R.Long.fromValue(I.revisionNumber) : R.Long.UZERO,
        revisionHeight: (0, R.isSet)(I.revisionHeight) ? R.Long.fromValue(I.revisionHeight) : R.Long.UZERO
      };
    },
    toJSON(I) {
      const W = {};
      return I.connectionId !== void 0 && (W.connectionId = I.connectionId), I.revisionNumber !== void 0 && (W.revisionNumber = (I.revisionNumber || R.Long.UZERO).toString()), I.revisionHeight !== void 0 && (W.revisionHeight = (I.revisionHeight || R.Long.UZERO).toString()), W;
    },
    fromPartial(I) {
      const W = d();
      return W.connectionId = I.connectionId ?? "", W.revisionNumber = I.revisionNumber !== void 0 && I.revisionNumber !== null ? R.Long.fromValue(I.revisionNumber) : R.Long.UZERO, W.revisionHeight = I.revisionHeight !== void 0 && I.revisionHeight !== null ? R.Long.fromValue(I.revisionHeight) : R.Long.UZERO, W;
    }
  };
  function p() {
    return {
      consensusState: void 0,
      clientId: "",
      proof: new Uint8Array(),
      proofHeight: void 0
    };
  }
  e.QueryConnectionConsensusStateResponse = {
    encode(I, W = T.Writer.create()) {
      return I.consensusState !== void 0 && b.Any.encode(I.consensusState, W.uint32(10).fork()).ldelim(), I.clientId !== "" && W.uint32(18).string(I.clientId), I.proof.length !== 0 && W.uint32(26).bytes(I.proof), I.proofHeight !== void 0 && f.Height.encode(I.proofHeight, W.uint32(34).fork()).ldelim(), W;
    },
    decode(I, W) {
      const n = I instanceof T.Reader ? I : new T.Reader(I);
      let y = W === void 0 ? n.len : n.pos + W;
      const w = p();
      for (; n.pos < y; ) {
        const M = n.uint32();
        switch (M >>> 3) {
          case 1:
            w.consensusState = b.Any.decode(n, n.uint32());
            break;
          case 2:
            w.clientId = n.string();
            break;
          case 3:
            w.proof = n.bytes();
            break;
          case 4:
            w.proofHeight = f.Height.decode(n, n.uint32());
            break;
          default:
            n.skipType(M & 7);
            break;
        }
      }
      return w;
    },
    fromJSON(I) {
      return {
        consensusState: (0, R.isSet)(I.consensusState) ? b.Any.fromJSON(I.consensusState) : void 0,
        clientId: (0, R.isSet)(I.clientId) ? String(I.clientId) : "",
        proof: (0, R.isSet)(I.proof) ? (0, R.bytesFromBase64)(I.proof) : new Uint8Array(),
        proofHeight: (0, R.isSet)(I.proofHeight) ? f.Height.fromJSON(I.proofHeight) : void 0
      };
    },
    toJSON(I) {
      const W = {};
      return I.consensusState !== void 0 && (W.consensusState = I.consensusState ? b.Any.toJSON(I.consensusState) : void 0), I.clientId !== void 0 && (W.clientId = I.clientId), I.proof !== void 0 && (W.proof = (0, R.base64FromBytes)(I.proof !== void 0 ? I.proof : new Uint8Array())), I.proofHeight !== void 0 && (W.proofHeight = I.proofHeight ? f.Height.toJSON(I.proofHeight) : void 0), W;
    },
    fromPartial(I) {
      const W = p();
      return W.consensusState = I.consensusState !== void 0 && I.consensusState !== null ? b.Any.fromPartial(I.consensusState) : void 0, W.clientId = I.clientId ?? "", W.proof = I.proof ?? new Uint8Array(), W.proofHeight = I.proofHeight !== void 0 && I.proofHeight !== null ? f.Height.fromPartial(I.proofHeight) : void 0, W;
    }
  };
  function h() {
    return {};
  }
  e.QueryConnectionParamsRequest = {
    encode(I, W = T.Writer.create()) {
      return W;
    },
    decode(I, W) {
      const n = I instanceof T.Reader ? I : new T.Reader(I);
      let y = W === void 0 ? n.len : n.pos + W;
      const w = h();
      for (; n.pos < y; ) {
        const M = n.uint32();
        switch (M >>> 3) {
          default:
            n.skipType(M & 7);
            break;
        }
      }
      return w;
    },
    fromJSON(I) {
      return {};
    },
    toJSON(I) {
      return {};
    },
    fromPartial(I) {
      return h();
    }
  };
  function x() {
    return {
      params: void 0
    };
  }
  e.QueryConnectionParamsResponse = {
    encode(I, W = T.Writer.create()) {
      return I.params !== void 0 && f.Params.encode(I.params, W.uint32(10).fork()).ldelim(), W;
    },
    decode(I, W) {
      const n = I instanceof T.Reader ? I : new T.Reader(I);
      let y = W === void 0 ? n.len : n.pos + W;
      const w = x();
      for (; n.pos < y; ) {
        const M = n.uint32();
        switch (M >>> 3) {
          case 1:
            w.params = f.Params.decode(n, n.uint32());
            break;
          default:
            n.skipType(M & 7);
            break;
        }
      }
      return w;
    },
    fromJSON(I) {
      return {
        params: (0, R.isSet)(I.params) ? f.Params.fromJSON(I.params) : void 0
      };
    },
    toJSON(I) {
      const W = {};
      return I.params !== void 0 && (W.params = I.params ? f.Params.toJSON(I.params) : void 0), W;
    },
    fromPartial(I) {
      const W = x();
      return W.params = I.params !== void 0 && I.params !== null ? f.Params.fromPartial(I.params) : void 0, W;
    }
  };
  class _ {
    constructor(W) {
      this.rpc = W, this.Connection = this.Connection.bind(this), this.Connections = this.Connections.bind(this), this.ClientConnections = this.ClientConnections.bind(this), this.ConnectionClientState = this.ConnectionClientState.bind(this), this.ConnectionConsensusState = this.ConnectionConsensusState.bind(this), this.ConnectionParams = this.ConnectionParams.bind(this);
    }
    Connection(W) {
      const n = e.QueryConnectionRequest.encode(W).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "Connection", n).then((y) => e.QueryConnectionResponse.decode(new T.Reader(y)));
    }
    Connections(W = {
      pagination: void 0
    }) {
      const n = e.QueryConnectionsRequest.encode(W).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "Connections", n).then((y) => e.QueryConnectionsResponse.decode(new T.Reader(y)));
    }
    ClientConnections(W) {
      const n = e.QueryClientConnectionsRequest.encode(W).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "ClientConnections", n).then((y) => e.QueryClientConnectionsResponse.decode(new T.Reader(y)));
    }
    ConnectionClientState(W) {
      const n = e.QueryConnectionClientStateRequest.encode(W).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "ConnectionClientState", n).then((y) => e.QueryConnectionClientStateResponse.decode(new T.Reader(y)));
    }
    ConnectionConsensusState(W) {
      const n = e.QueryConnectionConsensusStateRequest.encode(W).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "ConnectionConsensusState", n).then((y) => e.QueryConnectionConsensusStateResponse.decode(new T.Reader(y)));
    }
    ConnectionParams(W = {}) {
      const n = e.QueryConnectionParamsRequest.encode(W).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "ConnectionParams", n).then((y) => e.QueryConnectionParamsResponse.decode(new T.Reader(y)));
    }
  }
  e.QueryClientImpl = _;
})(Ic);
var xc = {}, nn = {}, Xi = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(D, B, U, C) {
    C === void 0 && (C = U);
    var l = Object.getOwnPropertyDescriptor(B, U);
    (!l || ("get" in l ? !B.__esModule : l.writable || l.configurable)) && (l = { enumerable: !0, get: function() {
      return B[U];
    } }), Object.defineProperty(D, C, l);
  } : function(D, B, U, C) {
    C === void 0 && (C = U), D[C] = B[U];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(D, B) {
    Object.defineProperty(D, "default", { enumerable: !0, value: B });
  } : function(D, B) {
    D.default = B;
  }), u = Q && Q.__importStar || function(D) {
    if (D && D.__esModule)
      return D;
    var B = {};
    if (D != null)
      for (var U in D)
        U !== "default" && Object.prototype.hasOwnProperty.call(D, U) && o(B, D, U);
    return t(B, D), B;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ProofOps = e.ProofOp = e.DominoOp = e.ValueOp = e.Proof = e.protobufPackage = void 0;
  const r = ie, m = u(re);
  e.protobufPackage = "tendermint.crypto";
  function f() {
    return {
      total: r.Long.ZERO,
      index: r.Long.ZERO,
      leafHash: new Uint8Array(),
      aunts: []
    };
  }
  e.Proof = {
    encode(D, B = m.Writer.create()) {
      D.total.isZero() || B.uint32(8).int64(D.total), D.index.isZero() || B.uint32(16).int64(D.index), D.leafHash.length !== 0 && B.uint32(26).bytes(D.leafHash);
      for (const U of D.aunts)
        B.uint32(34).bytes(U);
      return B;
    },
    decode(D, B) {
      const U = D instanceof m.Reader ? D : new m.Reader(D);
      let C = B === void 0 ? U.len : U.pos + B;
      const l = f();
      for (; U.pos < C; ) {
        const S = U.uint32();
        switch (S >>> 3) {
          case 1:
            l.total = U.int64();
            break;
          case 2:
            l.index = U.int64();
            break;
          case 3:
            l.leafHash = U.bytes();
            break;
          case 4:
            l.aunts.push(U.bytes());
            break;
          default:
            U.skipType(S & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(D) {
      return {
        total: (0, r.isSet)(D.total) ? r.Long.fromValue(D.total) : r.Long.ZERO,
        index: (0, r.isSet)(D.index) ? r.Long.fromValue(D.index) : r.Long.ZERO,
        leafHash: (0, r.isSet)(D.leafHash) ? (0, r.bytesFromBase64)(D.leafHash) : new Uint8Array(),
        aunts: Array.isArray(D == null ? void 0 : D.aunts) ? D.aunts.map((B) => (0, r.bytesFromBase64)(B)) : []
      };
    },
    toJSON(D) {
      const B = {};
      return D.total !== void 0 && (B.total = (D.total || r.Long.ZERO).toString()), D.index !== void 0 && (B.index = (D.index || r.Long.ZERO).toString()), D.leafHash !== void 0 && (B.leafHash = (0, r.base64FromBytes)(D.leafHash !== void 0 ? D.leafHash : new Uint8Array())), D.aunts ? B.aunts = D.aunts.map((U) => (0, r.base64FromBytes)(U !== void 0 ? U : new Uint8Array())) : B.aunts = [], B;
    },
    fromPartial(D) {
      var B;
      const U = f();
      return U.total = D.total !== void 0 && D.total !== null ? r.Long.fromValue(D.total) : r.Long.ZERO, U.index = D.index !== void 0 && D.index !== null ? r.Long.fromValue(D.index) : r.Long.ZERO, U.leafHash = D.leafHash ?? new Uint8Array(), U.aunts = ((B = D.aunts) == null ? void 0 : B.map((C) => C)) || [], U;
    }
  };
  function b() {
    return {
      key: new Uint8Array(),
      proof: void 0
    };
  }
  e.ValueOp = {
    encode(D, B = m.Writer.create()) {
      return D.key.length !== 0 && B.uint32(10).bytes(D.key), D.proof !== void 0 && e.Proof.encode(D.proof, B.uint32(18).fork()).ldelim(), B;
    },
    decode(D, B) {
      const U = D instanceof m.Reader ? D : new m.Reader(D);
      let C = B === void 0 ? U.len : U.pos + B;
      const l = b();
      for (; U.pos < C; ) {
        const S = U.uint32();
        switch (S >>> 3) {
          case 1:
            l.key = U.bytes();
            break;
          case 2:
            l.proof = e.Proof.decode(U, U.uint32());
            break;
          default:
            U.skipType(S & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(D) {
      return {
        key: (0, r.isSet)(D.key) ? (0, r.bytesFromBase64)(D.key) : new Uint8Array(),
        proof: (0, r.isSet)(D.proof) ? e.Proof.fromJSON(D.proof) : void 0
      };
    },
    toJSON(D) {
      const B = {};
      return D.key !== void 0 && (B.key = (0, r.base64FromBytes)(D.key !== void 0 ? D.key : new Uint8Array())), D.proof !== void 0 && (B.proof = D.proof ? e.Proof.toJSON(D.proof) : void 0), B;
    },
    fromPartial(D) {
      const B = b();
      return B.key = D.key ?? new Uint8Array(), B.proof = D.proof !== void 0 && D.proof !== null ? e.Proof.fromPartial(D.proof) : void 0, B;
    }
  };
  function R() {
    return {
      key: "",
      input: "",
      output: ""
    };
  }
  e.DominoOp = {
    encode(D, B = m.Writer.create()) {
      return D.key !== "" && B.uint32(10).string(D.key), D.input !== "" && B.uint32(18).string(D.input), D.output !== "" && B.uint32(26).string(D.output), B;
    },
    decode(D, B) {
      const U = D instanceof m.Reader ? D : new m.Reader(D);
      let C = B === void 0 ? U.len : U.pos + B;
      const l = R();
      for (; U.pos < C; ) {
        const S = U.uint32();
        switch (S >>> 3) {
          case 1:
            l.key = U.string();
            break;
          case 2:
            l.input = U.string();
            break;
          case 3:
            l.output = U.string();
            break;
          default:
            U.skipType(S & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(D) {
      return {
        key: (0, r.isSet)(D.key) ? String(D.key) : "",
        input: (0, r.isSet)(D.input) ? String(D.input) : "",
        output: (0, r.isSet)(D.output) ? String(D.output) : ""
      };
    },
    toJSON(D) {
      const B = {};
      return D.key !== void 0 && (B.key = D.key), D.input !== void 0 && (B.input = D.input), D.output !== void 0 && (B.output = D.output), B;
    },
    fromPartial(D) {
      const B = R();
      return B.key = D.key ?? "", B.input = D.input ?? "", B.output = D.output ?? "", B;
    }
  };
  function T() {
    return {
      type: "",
      key: new Uint8Array(),
      data: new Uint8Array()
    };
  }
  e.ProofOp = {
    encode(D, B = m.Writer.create()) {
      return D.type !== "" && B.uint32(10).string(D.type), D.key.length !== 0 && B.uint32(18).bytes(D.key), D.data.length !== 0 && B.uint32(26).bytes(D.data), B;
    },
    decode(D, B) {
      const U = D instanceof m.Reader ? D : new m.Reader(D);
      let C = B === void 0 ? U.len : U.pos + B;
      const l = T();
      for (; U.pos < C; ) {
        const S = U.uint32();
        switch (S >>> 3) {
          case 1:
            l.type = U.string();
            break;
          case 2:
            l.key = U.bytes();
            break;
          case 3:
            l.data = U.bytes();
            break;
          default:
            U.skipType(S & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(D) {
      return {
        type: (0, r.isSet)(D.type) ? String(D.type) : "",
        key: (0, r.isSet)(D.key) ? (0, r.bytesFromBase64)(D.key) : new Uint8Array(),
        data: (0, r.isSet)(D.data) ? (0, r.bytesFromBase64)(D.data) : new Uint8Array()
      };
    },
    toJSON(D) {
      const B = {};
      return D.type !== void 0 && (B.type = D.type), D.key !== void 0 && (B.key = (0, r.base64FromBytes)(D.key !== void 0 ? D.key : new Uint8Array())), D.data !== void 0 && (B.data = (0, r.base64FromBytes)(D.data !== void 0 ? D.data : new Uint8Array())), B;
    },
    fromPartial(D) {
      const B = T();
      return B.type = D.type ?? "", B.key = D.key ?? new Uint8Array(), B.data = D.data ?? new Uint8Array(), B;
    }
  };
  function V() {
    return {
      ops: []
    };
  }
  e.ProofOps = {
    encode(D, B = m.Writer.create()) {
      for (const U of D.ops)
        e.ProofOp.encode(U, B.uint32(10).fork()).ldelim();
      return B;
    },
    decode(D, B) {
      const U = D instanceof m.Reader ? D : new m.Reader(D);
      let C = B === void 0 ? U.len : U.pos + B;
      const l = V();
      for (; U.pos < C; ) {
        const S = U.uint32();
        switch (S >>> 3) {
          case 1:
            l.ops.push(e.ProofOp.decode(U, U.uint32()));
            break;
          default:
            U.skipType(S & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(D) {
      return {
        ops: Array.isArray(D == null ? void 0 : D.ops) ? D.ops.map((B) => e.ProofOp.fromJSON(B)) : []
      };
    },
    toJSON(D) {
      const B = {};
      return D.ops ? B.ops = D.ops.map((U) => U ? e.ProofOp.toJSON(U) : void 0) : B.ops = [], B;
    },
    fromPartial(D) {
      var B;
      const U = V();
      return U.ops = ((B = D.ops) == null ? void 0 : B.map((C) => e.ProofOp.fromPartial(C))) || [], U;
    }
  };
})(Xi);
var Vt = {}, Bm = Q && Q.__createBinding || (Object.create ? function(e, o, t, u) {
  u === void 0 && (u = t);
  var r = Object.getOwnPropertyDescriptor(o, t);
  (!r || ("get" in r ? !o.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return o[t];
  } }), Object.defineProperty(e, u, r);
} : function(e, o, t, u) {
  u === void 0 && (u = t), e[u] = o[t];
}), Vm = Q && Q.__setModuleDefault || (Object.create ? function(e, o) {
  Object.defineProperty(e, "default", { enumerable: !0, value: o });
} : function(e, o) {
  e.default = o;
}), Mm = Q && Q.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var o = {};
  if (e != null)
    for (var t in e)
      t !== "default" && Object.prototype.hasOwnProperty.call(e, t) && Bm(o, e, t);
  return Vm(o, e), o;
};
Object.defineProperty(Vt, "__esModule", { value: !0 });
Vt.Consensus = Vt.App = Vt.protobufPackage = void 0;
const Se = ie, On = Mm(re);
Vt.protobufPackage = "tendermint.version";
function Ja() {
  return {
    protocol: Se.Long.UZERO,
    software: ""
  };
}
Vt.App = {
  encode(e, o = On.Writer.create()) {
    return e.protocol.isZero() || o.uint32(8).uint64(e.protocol), e.software !== "" && o.uint32(18).string(e.software), o;
  },
  decode(e, o) {
    const t = e instanceof On.Reader ? e : new On.Reader(e);
    let u = o === void 0 ? t.len : t.pos + o;
    const r = Ja();
    for (; t.pos < u; ) {
      const m = t.uint32();
      switch (m >>> 3) {
        case 1:
          r.protocol = t.uint64();
          break;
        case 2:
          r.software = t.string();
          break;
        default:
          t.skipType(m & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      protocol: (0, Se.isSet)(e.protocol) ? Se.Long.fromValue(e.protocol) : Se.Long.UZERO,
      software: (0, Se.isSet)(e.software) ? String(e.software) : ""
    };
  },
  toJSON(e) {
    const o = {};
    return e.protocol !== void 0 && (o.protocol = (e.protocol || Se.Long.UZERO).toString()), e.software !== void 0 && (o.software = e.software), o;
  },
  fromPartial(e) {
    const o = Ja();
    return o.protocol = e.protocol !== void 0 && e.protocol !== null ? Se.Long.fromValue(e.protocol) : Se.Long.UZERO, o.software = e.software ?? "", o;
  }
};
function Ua() {
  return {
    block: Se.Long.UZERO,
    app: Se.Long.UZERO
  };
}
Vt.Consensus = {
  encode(e, o = On.Writer.create()) {
    return e.block.isZero() || o.uint32(8).uint64(e.block), e.app.isZero() || o.uint32(16).uint64(e.app), o;
  },
  decode(e, o) {
    const t = e instanceof On.Reader ? e : new On.Reader(e);
    let u = o === void 0 ? t.len : t.pos + o;
    const r = Ua();
    for (; t.pos < u; ) {
      const m = t.uint32();
      switch (m >>> 3) {
        case 1:
          r.block = t.uint64();
          break;
        case 2:
          r.app = t.uint64();
          break;
        default:
          t.skipType(m & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      block: (0, Se.isSet)(e.block) ? Se.Long.fromValue(e.block) : Se.Long.UZERO,
      app: (0, Se.isSet)(e.app) ? Se.Long.fromValue(e.app) : Se.Long.UZERO
    };
  },
  toJSON(e) {
    const o = {};
    return e.block !== void 0 && (o.block = (e.block || Se.Long.UZERO).toString()), e.app !== void 0 && (o.app = (e.app || Se.Long.UZERO).toString()), o;
  },
  fromPartial(e) {
    const o = Ua();
    return o.block = e.block !== void 0 && e.block !== null ? Se.Long.fromValue(e.block) : Se.Long.UZERO, o.app = e.app !== void 0 && e.app !== null ? Se.Long.fromValue(e.app) : Se.Long.UZERO, o;
  }
};
var fr = {}, $t = {}, Hm = Q && Q.__createBinding || (Object.create ? function(e, o, t, u) {
  u === void 0 && (u = t);
  var r = Object.getOwnPropertyDescriptor(o, t);
  (!r || ("get" in r ? !o.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return o[t];
  } }), Object.defineProperty(e, u, r);
} : function(e, o, t, u) {
  u === void 0 && (u = t), e[u] = o[t];
}), jm = Q && Q.__setModuleDefault || (Object.create ? function(e, o) {
  Object.defineProperty(e, "default", { enumerable: !0, value: o });
} : function(e, o) {
  e.default = o;
}), Wm = Q && Q.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var o = {};
  if (e != null)
    for (var t in e)
      t !== "default" && Object.prototype.hasOwnProperty.call(e, t) && Hm(o, e, t);
  return jm(o, e), o;
};
Object.defineProperty($t, "__esModule", { value: !0 });
$t.PublicKey = $t.protobufPackage = void 0;
const ni = Wm(re), un = ie;
$t.protobufPackage = "tendermint.crypto";
function Da() {
  return {
    ed25519: void 0,
    secp256k1: void 0
  };
}
$t.PublicKey = {
  encode(e, o = ni.Writer.create()) {
    return e.ed25519 !== void 0 && o.uint32(10).bytes(e.ed25519), e.secp256k1 !== void 0 && o.uint32(18).bytes(e.secp256k1), o;
  },
  decode(e, o) {
    const t = e instanceof ni.Reader ? e : new ni.Reader(e);
    let u = o === void 0 ? t.len : t.pos + o;
    const r = Da();
    for (; t.pos < u; ) {
      const m = t.uint32();
      switch (m >>> 3) {
        case 1:
          r.ed25519 = t.bytes();
          break;
        case 2:
          r.secp256k1 = t.bytes();
          break;
        default:
          t.skipType(m & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      ed25519: (0, un.isSet)(e.ed25519) ? (0, un.bytesFromBase64)(e.ed25519) : void 0,
      secp256k1: (0, un.isSet)(e.secp256k1) ? (0, un.bytesFromBase64)(e.secp256k1) : void 0
    };
  },
  toJSON(e) {
    const o = {};
    return e.ed25519 !== void 0 && (o.ed25519 = e.ed25519 !== void 0 ? (0, un.base64FromBytes)(e.ed25519) : void 0), e.secp256k1 !== void 0 && (o.secp256k1 = e.secp256k1 !== void 0 ? (0, un.base64FromBytes)(e.secp256k1) : void 0), o;
  },
  fromPartial(e) {
    const o = Da();
    return o.ed25519 = e.ed25519 ?? void 0, o.secp256k1 = e.secp256k1 ?? void 0, o;
  }
};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(V, D, B, U) {
    U === void 0 && (U = B);
    var C = Object.getOwnPropertyDescriptor(D, B);
    (!C || ("get" in C ? !D.__esModule : C.writable || C.configurable)) && (C = { enumerable: !0, get: function() {
      return D[B];
    } }), Object.defineProperty(V, U, C);
  } : function(V, D, B, U) {
    U === void 0 && (U = B), V[U] = D[B];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(V, D) {
    Object.defineProperty(V, "default", { enumerable: !0, value: D });
  } : function(V, D) {
    V.default = D;
  }), u = Q && Q.__importStar || function(V) {
    if (V && V.__esModule)
      return V;
    var D = {};
    if (V != null)
      for (var B in V)
        B !== "default" && Object.prototype.hasOwnProperty.call(V, B) && o(D, V, B);
    return t(D, V), D;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.SimpleValidator = e.Validator = e.ValidatorSet = e.protobufPackage = void 0;
  const r = $t, m = ie, f = u(re);
  e.protobufPackage = "tendermint.types";
  function b() {
    return {
      validators: [],
      proposer: void 0,
      totalVotingPower: m.Long.ZERO
    };
  }
  e.ValidatorSet = {
    encode(V, D = f.Writer.create()) {
      for (const B of V.validators)
        e.Validator.encode(B, D.uint32(10).fork()).ldelim();
      return V.proposer !== void 0 && e.Validator.encode(V.proposer, D.uint32(18).fork()).ldelim(), V.totalVotingPower.isZero() || D.uint32(24).int64(V.totalVotingPower), D;
    },
    decode(V, D) {
      const B = V instanceof f.Reader ? V : new f.Reader(V);
      let U = D === void 0 ? B.len : B.pos + D;
      const C = b();
      for (; B.pos < U; ) {
        const l = B.uint32();
        switch (l >>> 3) {
          case 1:
            C.validators.push(e.Validator.decode(B, B.uint32()));
            break;
          case 2:
            C.proposer = e.Validator.decode(B, B.uint32());
            break;
          case 3:
            C.totalVotingPower = B.int64();
            break;
          default:
            B.skipType(l & 7);
            break;
        }
      }
      return C;
    },
    fromJSON(V) {
      return {
        validators: Array.isArray(V == null ? void 0 : V.validators) ? V.validators.map((D) => e.Validator.fromJSON(D)) : [],
        proposer: (0, m.isSet)(V.proposer) ? e.Validator.fromJSON(V.proposer) : void 0,
        totalVotingPower: (0, m.isSet)(V.totalVotingPower) ? m.Long.fromValue(V.totalVotingPower) : m.Long.ZERO
      };
    },
    toJSON(V) {
      const D = {};
      return V.validators ? D.validators = V.validators.map((B) => B ? e.Validator.toJSON(B) : void 0) : D.validators = [], V.proposer !== void 0 && (D.proposer = V.proposer ? e.Validator.toJSON(V.proposer) : void 0), V.totalVotingPower !== void 0 && (D.totalVotingPower = (V.totalVotingPower || m.Long.ZERO).toString()), D;
    },
    fromPartial(V) {
      var D;
      const B = b();
      return B.validators = ((D = V.validators) == null ? void 0 : D.map((U) => e.Validator.fromPartial(U))) || [], B.proposer = V.proposer !== void 0 && V.proposer !== null ? e.Validator.fromPartial(V.proposer) : void 0, B.totalVotingPower = V.totalVotingPower !== void 0 && V.totalVotingPower !== null ? m.Long.fromValue(V.totalVotingPower) : m.Long.ZERO, B;
    }
  };
  function R() {
    return {
      address: new Uint8Array(),
      pubKey: void 0,
      votingPower: m.Long.ZERO,
      proposerPriority: m.Long.ZERO
    };
  }
  e.Validator = {
    encode(V, D = f.Writer.create()) {
      return V.address.length !== 0 && D.uint32(10).bytes(V.address), V.pubKey !== void 0 && r.PublicKey.encode(V.pubKey, D.uint32(18).fork()).ldelim(), V.votingPower.isZero() || D.uint32(24).int64(V.votingPower), V.proposerPriority.isZero() || D.uint32(32).int64(V.proposerPriority), D;
    },
    decode(V, D) {
      const B = V instanceof f.Reader ? V : new f.Reader(V);
      let U = D === void 0 ? B.len : B.pos + D;
      const C = R();
      for (; B.pos < U; ) {
        const l = B.uint32();
        switch (l >>> 3) {
          case 1:
            C.address = B.bytes();
            break;
          case 2:
            C.pubKey = r.PublicKey.decode(B, B.uint32());
            break;
          case 3:
            C.votingPower = B.int64();
            break;
          case 4:
            C.proposerPriority = B.int64();
            break;
          default:
            B.skipType(l & 7);
            break;
        }
      }
      return C;
    },
    fromJSON(V) {
      return {
        address: (0, m.isSet)(V.address) ? (0, m.bytesFromBase64)(V.address) : new Uint8Array(),
        pubKey: (0, m.isSet)(V.pubKey) ? r.PublicKey.fromJSON(V.pubKey) : void 0,
        votingPower: (0, m.isSet)(V.votingPower) ? m.Long.fromValue(V.votingPower) : m.Long.ZERO,
        proposerPriority: (0, m.isSet)(V.proposerPriority) ? m.Long.fromValue(V.proposerPriority) : m.Long.ZERO
      };
    },
    toJSON(V) {
      const D = {};
      return V.address !== void 0 && (D.address = (0, m.base64FromBytes)(V.address !== void 0 ? V.address : new Uint8Array())), V.pubKey !== void 0 && (D.pubKey = V.pubKey ? r.PublicKey.toJSON(V.pubKey) : void 0), V.votingPower !== void 0 && (D.votingPower = (V.votingPower || m.Long.ZERO).toString()), V.proposerPriority !== void 0 && (D.proposerPriority = (V.proposerPriority || m.Long.ZERO).toString()), D;
    },
    fromPartial(V) {
      const D = R();
      return D.address = V.address ?? new Uint8Array(), D.pubKey = V.pubKey !== void 0 && V.pubKey !== null ? r.PublicKey.fromPartial(V.pubKey) : void 0, D.votingPower = V.votingPower !== void 0 && V.votingPower !== null ? m.Long.fromValue(V.votingPower) : m.Long.ZERO, D.proposerPriority = V.proposerPriority !== void 0 && V.proposerPriority !== null ? m.Long.fromValue(V.proposerPriority) : m.Long.ZERO, D;
    }
  };
  function T() {
    return {
      pubKey: void 0,
      votingPower: m.Long.ZERO
    };
  }
  e.SimpleValidator = {
    encode(V, D = f.Writer.create()) {
      return V.pubKey !== void 0 && r.PublicKey.encode(V.pubKey, D.uint32(10).fork()).ldelim(), V.votingPower.isZero() || D.uint32(16).int64(V.votingPower), D;
    },
    decode(V, D) {
      const B = V instanceof f.Reader ? V : new f.Reader(V);
      let U = D === void 0 ? B.len : B.pos + D;
      const C = T();
      for (; B.pos < U; ) {
        const l = B.uint32();
        switch (l >>> 3) {
          case 1:
            C.pubKey = r.PublicKey.decode(B, B.uint32());
            break;
          case 2:
            C.votingPower = B.int64();
            break;
          default:
            B.skipType(l & 7);
            break;
        }
      }
      return C;
    },
    fromJSON(V) {
      return {
        pubKey: (0, m.isSet)(V.pubKey) ? r.PublicKey.fromJSON(V.pubKey) : void 0,
        votingPower: (0, m.isSet)(V.votingPower) ? m.Long.fromValue(V.votingPower) : m.Long.ZERO
      };
    },
    toJSON(V) {
      const D = {};
      return V.pubKey !== void 0 && (D.pubKey = V.pubKey ? r.PublicKey.toJSON(V.pubKey) : void 0), V.votingPower !== void 0 && (D.votingPower = (V.votingPower || m.Long.ZERO).toString()), D;
    },
    fromPartial(V) {
      const D = T();
      return D.pubKey = V.pubKey !== void 0 && V.pubKey !== null ? r.PublicKey.fromPartial(V.pubKey) : void 0, D.votingPower = V.votingPower !== void 0 && V.votingPower !== null ? m.Long.fromValue(V.votingPower) : m.Long.ZERO, D;
    }
  };
})(fr);
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(s, c, E, k) {
    k === void 0 && (k = E);
    var O = Object.getOwnPropertyDescriptor(c, E);
    (!O || ("get" in O ? !c.__esModule : O.writable || O.configurable)) && (O = { enumerable: !0, get: function() {
      return c[E];
    } }), Object.defineProperty(s, k, O);
  } : function(s, c, E, k) {
    k === void 0 && (k = E), s[k] = c[E];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(s, c) {
    Object.defineProperty(s, "default", { enumerable: !0, value: c });
  } : function(s, c) {
    s.default = c;
  }), u = Q && Q.__importStar || function(s) {
    if (s && s.__esModule)
      return s;
    var c = {};
    if (s != null)
      for (var E in s)
        E !== "default" && Object.prototype.hasOwnProperty.call(s, E) && o(c, s, E);
    return t(c, s), c;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.TxProof = e.BlockMeta = e.LightBlock = e.SignedHeader = e.Proposal = e.CommitSig = e.Commit = e.Vote = e.Data = e.Header = e.BlockID = e.Part = e.PartSetHeader = e.signedMsgTypeToJSON = e.signedMsgTypeFromJSON = e.SignedMsgType = e.blockIDFlagToJSON = e.blockIDFlagFromJSON = e.BlockIDFlag = e.protobufPackage = void 0;
  const r = Xi, m = Vt, f = Ae, b = fr, R = ie, T = u(re);
  e.protobufPackage = "tendermint.types";
  var V;
  (function(s) {
    s[s.BLOCK_ID_FLAG_UNKNOWN = 0] = "BLOCK_ID_FLAG_UNKNOWN", s[s.BLOCK_ID_FLAG_ABSENT = 1] = "BLOCK_ID_FLAG_ABSENT", s[s.BLOCK_ID_FLAG_COMMIT = 2] = "BLOCK_ID_FLAG_COMMIT", s[s.BLOCK_ID_FLAG_NIL = 3] = "BLOCK_ID_FLAG_NIL", s[s.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(V = e.BlockIDFlag || (e.BlockIDFlag = {}));
  function D(s) {
    switch (s) {
      case 0:
      case "BLOCK_ID_FLAG_UNKNOWN":
        return V.BLOCK_ID_FLAG_UNKNOWN;
      case 1:
      case "BLOCK_ID_FLAG_ABSENT":
        return V.BLOCK_ID_FLAG_ABSENT;
      case 2:
      case "BLOCK_ID_FLAG_COMMIT":
        return V.BLOCK_ID_FLAG_COMMIT;
      case 3:
      case "BLOCK_ID_FLAG_NIL":
        return V.BLOCK_ID_FLAG_NIL;
      case -1:
      case "UNRECOGNIZED":
      default:
        return V.UNRECOGNIZED;
    }
  }
  e.blockIDFlagFromJSON = D;
  function B(s) {
    switch (s) {
      case V.BLOCK_ID_FLAG_UNKNOWN:
        return "BLOCK_ID_FLAG_UNKNOWN";
      case V.BLOCK_ID_FLAG_ABSENT:
        return "BLOCK_ID_FLAG_ABSENT";
      case V.BLOCK_ID_FLAG_COMMIT:
        return "BLOCK_ID_FLAG_COMMIT";
      case V.BLOCK_ID_FLAG_NIL:
        return "BLOCK_ID_FLAG_NIL";
      case V.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.blockIDFlagToJSON = B;
  var U;
  (function(s) {
    s[s.SIGNED_MSG_TYPE_UNKNOWN = 0] = "SIGNED_MSG_TYPE_UNKNOWN", s[s.SIGNED_MSG_TYPE_PREVOTE = 1] = "SIGNED_MSG_TYPE_PREVOTE", s[s.SIGNED_MSG_TYPE_PRECOMMIT = 2] = "SIGNED_MSG_TYPE_PRECOMMIT", s[s.SIGNED_MSG_TYPE_PROPOSAL = 32] = "SIGNED_MSG_TYPE_PROPOSAL", s[s.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(U = e.SignedMsgType || (e.SignedMsgType = {}));
  function C(s) {
    switch (s) {
      case 0:
      case "SIGNED_MSG_TYPE_UNKNOWN":
        return U.SIGNED_MSG_TYPE_UNKNOWN;
      case 1:
      case "SIGNED_MSG_TYPE_PREVOTE":
        return U.SIGNED_MSG_TYPE_PREVOTE;
      case 2:
      case "SIGNED_MSG_TYPE_PRECOMMIT":
        return U.SIGNED_MSG_TYPE_PRECOMMIT;
      case 32:
      case "SIGNED_MSG_TYPE_PROPOSAL":
        return U.SIGNED_MSG_TYPE_PROPOSAL;
      case -1:
      case "UNRECOGNIZED":
      default:
        return U.UNRECOGNIZED;
    }
  }
  e.signedMsgTypeFromJSON = C;
  function l(s) {
    switch (s) {
      case U.SIGNED_MSG_TYPE_UNKNOWN:
        return "SIGNED_MSG_TYPE_UNKNOWN";
      case U.SIGNED_MSG_TYPE_PREVOTE:
        return "SIGNED_MSG_TYPE_PREVOTE";
      case U.SIGNED_MSG_TYPE_PRECOMMIT:
        return "SIGNED_MSG_TYPE_PRECOMMIT";
      case U.SIGNED_MSG_TYPE_PROPOSAL:
        return "SIGNED_MSG_TYPE_PROPOSAL";
      case U.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.signedMsgTypeToJSON = l;
  function S() {
    return {
      total: 0,
      hash: new Uint8Array()
    };
  }
  e.PartSetHeader = {
    encode(s, c = T.Writer.create()) {
      return s.total !== 0 && c.uint32(8).uint32(s.total), s.hash.length !== 0 && c.uint32(18).bytes(s.hash), c;
    },
    decode(s, c) {
      const E = s instanceof T.Reader ? s : new T.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = S();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.total = E.uint32();
            break;
          case 2:
            O.hash = E.bytes();
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        total: (0, R.isSet)(s.total) ? Number(s.total) : 0,
        hash: (0, R.isSet)(s.hash) ? (0, R.bytesFromBase64)(s.hash) : new Uint8Array()
      };
    },
    toJSON(s) {
      const c = {};
      return s.total !== void 0 && (c.total = Math.round(s.total)), s.hash !== void 0 && (c.hash = (0, R.base64FromBytes)(s.hash !== void 0 ? s.hash : new Uint8Array())), c;
    },
    fromPartial(s) {
      const c = S();
      return c.total = s.total ?? 0, c.hash = s.hash ?? new Uint8Array(), c;
    }
  };
  function A() {
    return {
      index: 0,
      bytes: new Uint8Array(),
      proof: void 0
    };
  }
  e.Part = {
    encode(s, c = T.Writer.create()) {
      return s.index !== 0 && c.uint32(8).uint32(s.index), s.bytes.length !== 0 && c.uint32(18).bytes(s.bytes), s.proof !== void 0 && r.Proof.encode(s.proof, c.uint32(26).fork()).ldelim(), c;
    },
    decode(s, c) {
      const E = s instanceof T.Reader ? s : new T.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = A();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.index = E.uint32();
            break;
          case 2:
            O.bytes = E.bytes();
            break;
          case 3:
            O.proof = r.Proof.decode(E, E.uint32());
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        index: (0, R.isSet)(s.index) ? Number(s.index) : 0,
        bytes: (0, R.isSet)(s.bytes) ? (0, R.bytesFromBase64)(s.bytes) : new Uint8Array(),
        proof: (0, R.isSet)(s.proof) ? r.Proof.fromJSON(s.proof) : void 0
      };
    },
    toJSON(s) {
      const c = {};
      return s.index !== void 0 && (c.index = Math.round(s.index)), s.bytes !== void 0 && (c.bytes = (0, R.base64FromBytes)(s.bytes !== void 0 ? s.bytes : new Uint8Array())), s.proof !== void 0 && (c.proof = s.proof ? r.Proof.toJSON(s.proof) : void 0), c;
    },
    fromPartial(s) {
      const c = A();
      return c.index = s.index ?? 0, c.bytes = s.bytes ?? new Uint8Array(), c.proof = s.proof !== void 0 && s.proof !== null ? r.Proof.fromPartial(s.proof) : void 0, c;
    }
  };
  function d() {
    return {
      hash: new Uint8Array(),
      partSetHeader: void 0
    };
  }
  e.BlockID = {
    encode(s, c = T.Writer.create()) {
      return s.hash.length !== 0 && c.uint32(10).bytes(s.hash), s.partSetHeader !== void 0 && e.PartSetHeader.encode(s.partSetHeader, c.uint32(18).fork()).ldelim(), c;
    },
    decode(s, c) {
      const E = s instanceof T.Reader ? s : new T.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = d();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.hash = E.bytes();
            break;
          case 2:
            O.partSetHeader = e.PartSetHeader.decode(E, E.uint32());
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        hash: (0, R.isSet)(s.hash) ? (0, R.bytesFromBase64)(s.hash) : new Uint8Array(),
        partSetHeader: (0, R.isSet)(s.partSetHeader) ? e.PartSetHeader.fromJSON(s.partSetHeader) : void 0
      };
    },
    toJSON(s) {
      const c = {};
      return s.hash !== void 0 && (c.hash = (0, R.base64FromBytes)(s.hash !== void 0 ? s.hash : new Uint8Array())), s.partSetHeader !== void 0 && (c.partSetHeader = s.partSetHeader ? e.PartSetHeader.toJSON(s.partSetHeader) : void 0), c;
    },
    fromPartial(s) {
      const c = d();
      return c.hash = s.hash ?? new Uint8Array(), c.partSetHeader = s.partSetHeader !== void 0 && s.partSetHeader !== null ? e.PartSetHeader.fromPartial(s.partSetHeader) : void 0, c;
    }
  };
  function p() {
    return {
      version: void 0,
      chainId: "",
      height: R.Long.ZERO,
      time: void 0,
      lastBlockId: void 0,
      lastCommitHash: new Uint8Array(),
      dataHash: new Uint8Array(),
      validatorsHash: new Uint8Array(),
      nextValidatorsHash: new Uint8Array(),
      consensusHash: new Uint8Array(),
      appHash: new Uint8Array(),
      lastResultsHash: new Uint8Array(),
      evidenceHash: new Uint8Array(),
      proposerAddress: new Uint8Array()
    };
  }
  e.Header = {
    encode(s, c = T.Writer.create()) {
      return s.version !== void 0 && m.Consensus.encode(s.version, c.uint32(10).fork()).ldelim(), s.chainId !== "" && c.uint32(18).string(s.chainId), s.height.isZero() || c.uint32(24).int64(s.height), s.time !== void 0 && f.Timestamp.encode(s.time, c.uint32(34).fork()).ldelim(), s.lastBlockId !== void 0 && e.BlockID.encode(s.lastBlockId, c.uint32(42).fork()).ldelim(), s.lastCommitHash.length !== 0 && c.uint32(50).bytes(s.lastCommitHash), s.dataHash.length !== 0 && c.uint32(58).bytes(s.dataHash), s.validatorsHash.length !== 0 && c.uint32(66).bytes(s.validatorsHash), s.nextValidatorsHash.length !== 0 && c.uint32(74).bytes(s.nextValidatorsHash), s.consensusHash.length !== 0 && c.uint32(82).bytes(s.consensusHash), s.appHash.length !== 0 && c.uint32(90).bytes(s.appHash), s.lastResultsHash.length !== 0 && c.uint32(98).bytes(s.lastResultsHash), s.evidenceHash.length !== 0 && c.uint32(106).bytes(s.evidenceHash), s.proposerAddress.length !== 0 && c.uint32(114).bytes(s.proposerAddress), c;
    },
    decode(s, c) {
      const E = s instanceof T.Reader ? s : new T.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = p();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.version = m.Consensus.decode(E, E.uint32());
            break;
          case 2:
            O.chainId = E.string();
            break;
          case 3:
            O.height = E.int64();
            break;
          case 4:
            O.time = f.Timestamp.decode(E, E.uint32());
            break;
          case 5:
            O.lastBlockId = e.BlockID.decode(E, E.uint32());
            break;
          case 6:
            O.lastCommitHash = E.bytes();
            break;
          case 7:
            O.dataHash = E.bytes();
            break;
          case 8:
            O.validatorsHash = E.bytes();
            break;
          case 9:
            O.nextValidatorsHash = E.bytes();
            break;
          case 10:
            O.consensusHash = E.bytes();
            break;
          case 11:
            O.appHash = E.bytes();
            break;
          case 12:
            O.lastResultsHash = E.bytes();
            break;
          case 13:
            O.evidenceHash = E.bytes();
            break;
          case 14:
            O.proposerAddress = E.bytes();
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        version: (0, R.isSet)(s.version) ? m.Consensus.fromJSON(s.version) : void 0,
        chainId: (0, R.isSet)(s.chainId) ? String(s.chainId) : "",
        height: (0, R.isSet)(s.height) ? R.Long.fromValue(s.height) : R.Long.ZERO,
        time: (0, R.isSet)(s.time) ? (0, R.fromJsonTimestamp)(s.time) : void 0,
        lastBlockId: (0, R.isSet)(s.lastBlockId) ? e.BlockID.fromJSON(s.lastBlockId) : void 0,
        lastCommitHash: (0, R.isSet)(s.lastCommitHash) ? (0, R.bytesFromBase64)(s.lastCommitHash) : new Uint8Array(),
        dataHash: (0, R.isSet)(s.dataHash) ? (0, R.bytesFromBase64)(s.dataHash) : new Uint8Array(),
        validatorsHash: (0, R.isSet)(s.validatorsHash) ? (0, R.bytesFromBase64)(s.validatorsHash) : new Uint8Array(),
        nextValidatorsHash: (0, R.isSet)(s.nextValidatorsHash) ? (0, R.bytesFromBase64)(s.nextValidatorsHash) : new Uint8Array(),
        consensusHash: (0, R.isSet)(s.consensusHash) ? (0, R.bytesFromBase64)(s.consensusHash) : new Uint8Array(),
        appHash: (0, R.isSet)(s.appHash) ? (0, R.bytesFromBase64)(s.appHash) : new Uint8Array(),
        lastResultsHash: (0, R.isSet)(s.lastResultsHash) ? (0, R.bytesFromBase64)(s.lastResultsHash) : new Uint8Array(),
        evidenceHash: (0, R.isSet)(s.evidenceHash) ? (0, R.bytesFromBase64)(s.evidenceHash) : new Uint8Array(),
        proposerAddress: (0, R.isSet)(s.proposerAddress) ? (0, R.bytesFromBase64)(s.proposerAddress) : new Uint8Array()
      };
    },
    toJSON(s) {
      const c = {};
      return s.version !== void 0 && (c.version = s.version ? m.Consensus.toJSON(s.version) : void 0), s.chainId !== void 0 && (c.chainId = s.chainId), s.height !== void 0 && (c.height = (s.height || R.Long.ZERO).toString()), s.time !== void 0 && (c.time = (0, R.fromTimestamp)(s.time).toISOString()), s.lastBlockId !== void 0 && (c.lastBlockId = s.lastBlockId ? e.BlockID.toJSON(s.lastBlockId) : void 0), s.lastCommitHash !== void 0 && (c.lastCommitHash = (0, R.base64FromBytes)(s.lastCommitHash !== void 0 ? s.lastCommitHash : new Uint8Array())), s.dataHash !== void 0 && (c.dataHash = (0, R.base64FromBytes)(s.dataHash !== void 0 ? s.dataHash : new Uint8Array())), s.validatorsHash !== void 0 && (c.validatorsHash = (0, R.base64FromBytes)(s.validatorsHash !== void 0 ? s.validatorsHash : new Uint8Array())), s.nextValidatorsHash !== void 0 && (c.nextValidatorsHash = (0, R.base64FromBytes)(s.nextValidatorsHash !== void 0 ? s.nextValidatorsHash : new Uint8Array())), s.consensusHash !== void 0 && (c.consensusHash = (0, R.base64FromBytes)(s.consensusHash !== void 0 ? s.consensusHash : new Uint8Array())), s.appHash !== void 0 && (c.appHash = (0, R.base64FromBytes)(s.appHash !== void 0 ? s.appHash : new Uint8Array())), s.lastResultsHash !== void 0 && (c.lastResultsHash = (0, R.base64FromBytes)(s.lastResultsHash !== void 0 ? s.lastResultsHash : new Uint8Array())), s.evidenceHash !== void 0 && (c.evidenceHash = (0, R.base64FromBytes)(s.evidenceHash !== void 0 ? s.evidenceHash : new Uint8Array())), s.proposerAddress !== void 0 && (c.proposerAddress = (0, R.base64FromBytes)(s.proposerAddress !== void 0 ? s.proposerAddress : new Uint8Array())), c;
    },
    fromPartial(s) {
      const c = p();
      return c.version = s.version !== void 0 && s.version !== null ? m.Consensus.fromPartial(s.version) : void 0, c.chainId = s.chainId ?? "", c.height = s.height !== void 0 && s.height !== null ? R.Long.fromValue(s.height) : R.Long.ZERO, c.time = s.time !== void 0 && s.time !== null ? f.Timestamp.fromPartial(s.time) : void 0, c.lastBlockId = s.lastBlockId !== void 0 && s.lastBlockId !== null ? e.BlockID.fromPartial(s.lastBlockId) : void 0, c.lastCommitHash = s.lastCommitHash ?? new Uint8Array(), c.dataHash = s.dataHash ?? new Uint8Array(), c.validatorsHash = s.validatorsHash ?? new Uint8Array(), c.nextValidatorsHash = s.nextValidatorsHash ?? new Uint8Array(), c.consensusHash = s.consensusHash ?? new Uint8Array(), c.appHash = s.appHash ?? new Uint8Array(), c.lastResultsHash = s.lastResultsHash ?? new Uint8Array(), c.evidenceHash = s.evidenceHash ?? new Uint8Array(), c.proposerAddress = s.proposerAddress ?? new Uint8Array(), c;
    }
  };
  function h() {
    return {
      txs: []
    };
  }
  e.Data = {
    encode(s, c = T.Writer.create()) {
      for (const E of s.txs)
        c.uint32(10).bytes(E);
      return c;
    },
    decode(s, c) {
      const E = s instanceof T.Reader ? s : new T.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = h();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.txs.push(E.bytes());
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        txs: Array.isArray(s == null ? void 0 : s.txs) ? s.txs.map((c) => (0, R.bytesFromBase64)(c)) : []
      };
    },
    toJSON(s) {
      const c = {};
      return s.txs ? c.txs = s.txs.map((E) => (0, R.base64FromBytes)(E !== void 0 ? E : new Uint8Array())) : c.txs = [], c;
    },
    fromPartial(s) {
      var c;
      const E = h();
      return E.txs = ((c = s.txs) == null ? void 0 : c.map((k) => k)) || [], E;
    }
  };
  function x() {
    return {
      type: 0,
      height: R.Long.ZERO,
      round: 0,
      blockId: void 0,
      timestamp: void 0,
      validatorAddress: new Uint8Array(),
      validatorIndex: 0,
      signature: new Uint8Array()
    };
  }
  e.Vote = {
    encode(s, c = T.Writer.create()) {
      return s.type !== 0 && c.uint32(8).int32(s.type), s.height.isZero() || c.uint32(16).int64(s.height), s.round !== 0 && c.uint32(24).int32(s.round), s.blockId !== void 0 && e.BlockID.encode(s.blockId, c.uint32(34).fork()).ldelim(), s.timestamp !== void 0 && f.Timestamp.encode(s.timestamp, c.uint32(42).fork()).ldelim(), s.validatorAddress.length !== 0 && c.uint32(50).bytes(s.validatorAddress), s.validatorIndex !== 0 && c.uint32(56).int32(s.validatorIndex), s.signature.length !== 0 && c.uint32(66).bytes(s.signature), c;
    },
    decode(s, c) {
      const E = s instanceof T.Reader ? s : new T.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = x();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.type = E.int32();
            break;
          case 2:
            O.height = E.int64();
            break;
          case 3:
            O.round = E.int32();
            break;
          case 4:
            O.blockId = e.BlockID.decode(E, E.uint32());
            break;
          case 5:
            O.timestamp = f.Timestamp.decode(E, E.uint32());
            break;
          case 6:
            O.validatorAddress = E.bytes();
            break;
          case 7:
            O.validatorIndex = E.int32();
            break;
          case 8:
            O.signature = E.bytes();
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        type: (0, R.isSet)(s.type) ? C(s.type) : 0,
        height: (0, R.isSet)(s.height) ? R.Long.fromValue(s.height) : R.Long.ZERO,
        round: (0, R.isSet)(s.round) ? Number(s.round) : 0,
        blockId: (0, R.isSet)(s.blockId) ? e.BlockID.fromJSON(s.blockId) : void 0,
        timestamp: (0, R.isSet)(s.timestamp) ? (0, R.fromJsonTimestamp)(s.timestamp) : void 0,
        validatorAddress: (0, R.isSet)(s.validatorAddress) ? (0, R.bytesFromBase64)(s.validatorAddress) : new Uint8Array(),
        validatorIndex: (0, R.isSet)(s.validatorIndex) ? Number(s.validatorIndex) : 0,
        signature: (0, R.isSet)(s.signature) ? (0, R.bytesFromBase64)(s.signature) : new Uint8Array()
      };
    },
    toJSON(s) {
      const c = {};
      return s.type !== void 0 && (c.type = l(s.type)), s.height !== void 0 && (c.height = (s.height || R.Long.ZERO).toString()), s.round !== void 0 && (c.round = Math.round(s.round)), s.blockId !== void 0 && (c.blockId = s.blockId ? e.BlockID.toJSON(s.blockId) : void 0), s.timestamp !== void 0 && (c.timestamp = (0, R.fromTimestamp)(s.timestamp).toISOString()), s.validatorAddress !== void 0 && (c.validatorAddress = (0, R.base64FromBytes)(s.validatorAddress !== void 0 ? s.validatorAddress : new Uint8Array())), s.validatorIndex !== void 0 && (c.validatorIndex = Math.round(s.validatorIndex)), s.signature !== void 0 && (c.signature = (0, R.base64FromBytes)(s.signature !== void 0 ? s.signature : new Uint8Array())), c;
    },
    fromPartial(s) {
      const c = x();
      return c.type = s.type ?? 0, c.height = s.height !== void 0 && s.height !== null ? R.Long.fromValue(s.height) : R.Long.ZERO, c.round = s.round ?? 0, c.blockId = s.blockId !== void 0 && s.blockId !== null ? e.BlockID.fromPartial(s.blockId) : void 0, c.timestamp = s.timestamp !== void 0 && s.timestamp !== null ? f.Timestamp.fromPartial(s.timestamp) : void 0, c.validatorAddress = s.validatorAddress ?? new Uint8Array(), c.validatorIndex = s.validatorIndex ?? 0, c.signature = s.signature ?? new Uint8Array(), c;
    }
  };
  function _() {
    return {
      height: R.Long.ZERO,
      round: 0,
      blockId: void 0,
      signatures: []
    };
  }
  e.Commit = {
    encode(s, c = T.Writer.create()) {
      s.height.isZero() || c.uint32(8).int64(s.height), s.round !== 0 && c.uint32(16).int32(s.round), s.blockId !== void 0 && e.BlockID.encode(s.blockId, c.uint32(26).fork()).ldelim();
      for (const E of s.signatures)
        e.CommitSig.encode(E, c.uint32(34).fork()).ldelim();
      return c;
    },
    decode(s, c) {
      const E = s instanceof T.Reader ? s : new T.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = _();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.height = E.int64();
            break;
          case 2:
            O.round = E.int32();
            break;
          case 3:
            O.blockId = e.BlockID.decode(E, E.uint32());
            break;
          case 4:
            O.signatures.push(e.CommitSig.decode(E, E.uint32()));
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        height: (0, R.isSet)(s.height) ? R.Long.fromValue(s.height) : R.Long.ZERO,
        round: (0, R.isSet)(s.round) ? Number(s.round) : 0,
        blockId: (0, R.isSet)(s.blockId) ? e.BlockID.fromJSON(s.blockId) : void 0,
        signatures: Array.isArray(s == null ? void 0 : s.signatures) ? s.signatures.map((c) => e.CommitSig.fromJSON(c)) : []
      };
    },
    toJSON(s) {
      const c = {};
      return s.height !== void 0 && (c.height = (s.height || R.Long.ZERO).toString()), s.round !== void 0 && (c.round = Math.round(s.round)), s.blockId !== void 0 && (c.blockId = s.blockId ? e.BlockID.toJSON(s.blockId) : void 0), s.signatures ? c.signatures = s.signatures.map((E) => E ? e.CommitSig.toJSON(E) : void 0) : c.signatures = [], c;
    },
    fromPartial(s) {
      var c;
      const E = _();
      return E.height = s.height !== void 0 && s.height !== null ? R.Long.fromValue(s.height) : R.Long.ZERO, E.round = s.round ?? 0, E.blockId = s.blockId !== void 0 && s.blockId !== null ? e.BlockID.fromPartial(s.blockId) : void 0, E.signatures = ((c = s.signatures) == null ? void 0 : c.map((k) => e.CommitSig.fromPartial(k))) || [], E;
    }
  };
  function I() {
    return {
      blockIdFlag: 0,
      validatorAddress: new Uint8Array(),
      timestamp: void 0,
      signature: new Uint8Array()
    };
  }
  e.CommitSig = {
    encode(s, c = T.Writer.create()) {
      return s.blockIdFlag !== 0 && c.uint32(8).int32(s.blockIdFlag), s.validatorAddress.length !== 0 && c.uint32(18).bytes(s.validatorAddress), s.timestamp !== void 0 && f.Timestamp.encode(s.timestamp, c.uint32(26).fork()).ldelim(), s.signature.length !== 0 && c.uint32(34).bytes(s.signature), c;
    },
    decode(s, c) {
      const E = s instanceof T.Reader ? s : new T.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = I();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.blockIdFlag = E.int32();
            break;
          case 2:
            O.validatorAddress = E.bytes();
            break;
          case 3:
            O.timestamp = f.Timestamp.decode(E, E.uint32());
            break;
          case 4:
            O.signature = E.bytes();
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        blockIdFlag: (0, R.isSet)(s.blockIdFlag) ? D(s.blockIdFlag) : 0,
        validatorAddress: (0, R.isSet)(s.validatorAddress) ? (0, R.bytesFromBase64)(s.validatorAddress) : new Uint8Array(),
        timestamp: (0, R.isSet)(s.timestamp) ? (0, R.fromJsonTimestamp)(s.timestamp) : void 0,
        signature: (0, R.isSet)(s.signature) ? (0, R.bytesFromBase64)(s.signature) : new Uint8Array()
      };
    },
    toJSON(s) {
      const c = {};
      return s.blockIdFlag !== void 0 && (c.blockIdFlag = B(s.blockIdFlag)), s.validatorAddress !== void 0 && (c.validatorAddress = (0, R.base64FromBytes)(s.validatorAddress !== void 0 ? s.validatorAddress : new Uint8Array())), s.timestamp !== void 0 && (c.timestamp = (0, R.fromTimestamp)(s.timestamp).toISOString()), s.signature !== void 0 && (c.signature = (0, R.base64FromBytes)(s.signature !== void 0 ? s.signature : new Uint8Array())), c;
    },
    fromPartial(s) {
      const c = I();
      return c.blockIdFlag = s.blockIdFlag ?? 0, c.validatorAddress = s.validatorAddress ?? new Uint8Array(), c.timestamp = s.timestamp !== void 0 && s.timestamp !== null ? f.Timestamp.fromPartial(s.timestamp) : void 0, c.signature = s.signature ?? new Uint8Array(), c;
    }
  };
  function W() {
    return {
      type: 0,
      height: R.Long.ZERO,
      round: 0,
      polRound: 0,
      blockId: void 0,
      timestamp: void 0,
      signature: new Uint8Array()
    };
  }
  e.Proposal = {
    encode(s, c = T.Writer.create()) {
      return s.type !== 0 && c.uint32(8).int32(s.type), s.height.isZero() || c.uint32(16).int64(s.height), s.round !== 0 && c.uint32(24).int32(s.round), s.polRound !== 0 && c.uint32(32).int32(s.polRound), s.blockId !== void 0 && e.BlockID.encode(s.blockId, c.uint32(42).fork()).ldelim(), s.timestamp !== void 0 && f.Timestamp.encode(s.timestamp, c.uint32(50).fork()).ldelim(), s.signature.length !== 0 && c.uint32(58).bytes(s.signature), c;
    },
    decode(s, c) {
      const E = s instanceof T.Reader ? s : new T.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = W();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.type = E.int32();
            break;
          case 2:
            O.height = E.int64();
            break;
          case 3:
            O.round = E.int32();
            break;
          case 4:
            O.polRound = E.int32();
            break;
          case 5:
            O.blockId = e.BlockID.decode(E, E.uint32());
            break;
          case 6:
            O.timestamp = f.Timestamp.decode(E, E.uint32());
            break;
          case 7:
            O.signature = E.bytes();
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        type: (0, R.isSet)(s.type) ? C(s.type) : 0,
        height: (0, R.isSet)(s.height) ? R.Long.fromValue(s.height) : R.Long.ZERO,
        round: (0, R.isSet)(s.round) ? Number(s.round) : 0,
        polRound: (0, R.isSet)(s.polRound) ? Number(s.polRound) : 0,
        blockId: (0, R.isSet)(s.blockId) ? e.BlockID.fromJSON(s.blockId) : void 0,
        timestamp: (0, R.isSet)(s.timestamp) ? (0, R.fromJsonTimestamp)(s.timestamp) : void 0,
        signature: (0, R.isSet)(s.signature) ? (0, R.bytesFromBase64)(s.signature) : new Uint8Array()
      };
    },
    toJSON(s) {
      const c = {};
      return s.type !== void 0 && (c.type = l(s.type)), s.height !== void 0 && (c.height = (s.height || R.Long.ZERO).toString()), s.round !== void 0 && (c.round = Math.round(s.round)), s.polRound !== void 0 && (c.polRound = Math.round(s.polRound)), s.blockId !== void 0 && (c.blockId = s.blockId ? e.BlockID.toJSON(s.blockId) : void 0), s.timestamp !== void 0 && (c.timestamp = (0, R.fromTimestamp)(s.timestamp).toISOString()), s.signature !== void 0 && (c.signature = (0, R.base64FromBytes)(s.signature !== void 0 ? s.signature : new Uint8Array())), c;
    },
    fromPartial(s) {
      const c = W();
      return c.type = s.type ?? 0, c.height = s.height !== void 0 && s.height !== null ? R.Long.fromValue(s.height) : R.Long.ZERO, c.round = s.round ?? 0, c.polRound = s.polRound ?? 0, c.blockId = s.blockId !== void 0 && s.blockId !== null ? e.BlockID.fromPartial(s.blockId) : void 0, c.timestamp = s.timestamp !== void 0 && s.timestamp !== null ? f.Timestamp.fromPartial(s.timestamp) : void 0, c.signature = s.signature ?? new Uint8Array(), c;
    }
  };
  function n() {
    return {
      header: void 0,
      commit: void 0
    };
  }
  e.SignedHeader = {
    encode(s, c = T.Writer.create()) {
      return s.header !== void 0 && e.Header.encode(s.header, c.uint32(10).fork()).ldelim(), s.commit !== void 0 && e.Commit.encode(s.commit, c.uint32(18).fork()).ldelim(), c;
    },
    decode(s, c) {
      const E = s instanceof T.Reader ? s : new T.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = n();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.header = e.Header.decode(E, E.uint32());
            break;
          case 2:
            O.commit = e.Commit.decode(E, E.uint32());
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        header: (0, R.isSet)(s.header) ? e.Header.fromJSON(s.header) : void 0,
        commit: (0, R.isSet)(s.commit) ? e.Commit.fromJSON(s.commit) : void 0
      };
    },
    toJSON(s) {
      const c = {};
      return s.header !== void 0 && (c.header = s.header ? e.Header.toJSON(s.header) : void 0), s.commit !== void 0 && (c.commit = s.commit ? e.Commit.toJSON(s.commit) : void 0), c;
    },
    fromPartial(s) {
      const c = n();
      return c.header = s.header !== void 0 && s.header !== null ? e.Header.fromPartial(s.header) : void 0, c.commit = s.commit !== void 0 && s.commit !== null ? e.Commit.fromPartial(s.commit) : void 0, c;
    }
  };
  function y() {
    return {
      signedHeader: void 0,
      validatorSet: void 0
    };
  }
  e.LightBlock = {
    encode(s, c = T.Writer.create()) {
      return s.signedHeader !== void 0 && e.SignedHeader.encode(s.signedHeader, c.uint32(10).fork()).ldelim(), s.validatorSet !== void 0 && b.ValidatorSet.encode(s.validatorSet, c.uint32(18).fork()).ldelim(), c;
    },
    decode(s, c) {
      const E = s instanceof T.Reader ? s : new T.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = y();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.signedHeader = e.SignedHeader.decode(E, E.uint32());
            break;
          case 2:
            O.validatorSet = b.ValidatorSet.decode(E, E.uint32());
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        signedHeader: (0, R.isSet)(s.signedHeader) ? e.SignedHeader.fromJSON(s.signedHeader) : void 0,
        validatorSet: (0, R.isSet)(s.validatorSet) ? b.ValidatorSet.fromJSON(s.validatorSet) : void 0
      };
    },
    toJSON(s) {
      const c = {};
      return s.signedHeader !== void 0 && (c.signedHeader = s.signedHeader ? e.SignedHeader.toJSON(s.signedHeader) : void 0), s.validatorSet !== void 0 && (c.validatorSet = s.validatorSet ? b.ValidatorSet.toJSON(s.validatorSet) : void 0), c;
    },
    fromPartial(s) {
      const c = y();
      return c.signedHeader = s.signedHeader !== void 0 && s.signedHeader !== null ? e.SignedHeader.fromPartial(s.signedHeader) : void 0, c.validatorSet = s.validatorSet !== void 0 && s.validatorSet !== null ? b.ValidatorSet.fromPartial(s.validatorSet) : void 0, c;
    }
  };
  function w() {
    return {
      blockId: void 0,
      blockSize: R.Long.ZERO,
      header: void 0,
      numTxs: R.Long.ZERO
    };
  }
  e.BlockMeta = {
    encode(s, c = T.Writer.create()) {
      return s.blockId !== void 0 && e.BlockID.encode(s.blockId, c.uint32(10).fork()).ldelim(), s.blockSize.isZero() || c.uint32(16).int64(s.blockSize), s.header !== void 0 && e.Header.encode(s.header, c.uint32(26).fork()).ldelim(), s.numTxs.isZero() || c.uint32(32).int64(s.numTxs), c;
    },
    decode(s, c) {
      const E = s instanceof T.Reader ? s : new T.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = w();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.blockId = e.BlockID.decode(E, E.uint32());
            break;
          case 2:
            O.blockSize = E.int64();
            break;
          case 3:
            O.header = e.Header.decode(E, E.uint32());
            break;
          case 4:
            O.numTxs = E.int64();
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        blockId: (0, R.isSet)(s.blockId) ? e.BlockID.fromJSON(s.blockId) : void 0,
        blockSize: (0, R.isSet)(s.blockSize) ? R.Long.fromValue(s.blockSize) : R.Long.ZERO,
        header: (0, R.isSet)(s.header) ? e.Header.fromJSON(s.header) : void 0,
        numTxs: (0, R.isSet)(s.numTxs) ? R.Long.fromValue(s.numTxs) : R.Long.ZERO
      };
    },
    toJSON(s) {
      const c = {};
      return s.blockId !== void 0 && (c.blockId = s.blockId ? e.BlockID.toJSON(s.blockId) : void 0), s.blockSize !== void 0 && (c.blockSize = (s.blockSize || R.Long.ZERO).toString()), s.header !== void 0 && (c.header = s.header ? e.Header.toJSON(s.header) : void 0), s.numTxs !== void 0 && (c.numTxs = (s.numTxs || R.Long.ZERO).toString()), c;
    },
    fromPartial(s) {
      const c = w();
      return c.blockId = s.blockId !== void 0 && s.blockId !== null ? e.BlockID.fromPartial(s.blockId) : void 0, c.blockSize = s.blockSize !== void 0 && s.blockSize !== null ? R.Long.fromValue(s.blockSize) : R.Long.ZERO, c.header = s.header !== void 0 && s.header !== null ? e.Header.fromPartial(s.header) : void 0, c.numTxs = s.numTxs !== void 0 && s.numTxs !== null ? R.Long.fromValue(s.numTxs) : R.Long.ZERO, c;
    }
  };
  function M() {
    return {
      rootHash: new Uint8Array(),
      data: new Uint8Array(),
      proof: void 0
    };
  }
  e.TxProof = {
    encode(s, c = T.Writer.create()) {
      return s.rootHash.length !== 0 && c.uint32(10).bytes(s.rootHash), s.data.length !== 0 && c.uint32(18).bytes(s.data), s.proof !== void 0 && r.Proof.encode(s.proof, c.uint32(26).fork()).ldelim(), c;
    },
    decode(s, c) {
      const E = s instanceof T.Reader ? s : new T.Reader(s);
      let k = c === void 0 ? E.len : E.pos + c;
      const O = M();
      for (; E.pos < k; ) {
        const L = E.uint32();
        switch (L >>> 3) {
          case 1:
            O.rootHash = E.bytes();
            break;
          case 2:
            O.data = E.bytes();
            break;
          case 3:
            O.proof = r.Proof.decode(E, E.uint32());
            break;
          default:
            E.skipType(L & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(s) {
      return {
        rootHash: (0, R.isSet)(s.rootHash) ? (0, R.bytesFromBase64)(s.rootHash) : new Uint8Array(),
        data: (0, R.isSet)(s.data) ? (0, R.bytesFromBase64)(s.data) : new Uint8Array(),
        proof: (0, R.isSet)(s.proof) ? r.Proof.fromJSON(s.proof) : void 0
      };
    },
    toJSON(s) {
      const c = {};
      return s.rootHash !== void 0 && (c.rootHash = (0, R.base64FromBytes)(s.rootHash !== void 0 ? s.rootHash : new Uint8Array())), s.data !== void 0 && (c.data = (0, R.base64FromBytes)(s.data !== void 0 ? s.data : new Uint8Array())), s.proof !== void 0 && (c.proof = s.proof ? r.Proof.toJSON(s.proof) : void 0), c;
    },
    fromPartial(s) {
      const c = M();
      return c.rootHash = s.rootHash ?? new Uint8Array(), c.data = s.data ?? new Uint8Array(), c.proof = s.proof !== void 0 && s.proof !== null ? r.Proof.fromPartial(s.proof) : void 0, c;
    }
  };
})(nn);
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(d, p, h, x) {
    x === void 0 && (x = h);
    var _ = Object.getOwnPropertyDescriptor(p, h);
    (!_ || ("get" in _ ? !p.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return p[h];
    } }), Object.defineProperty(d, x, _);
  } : function(d, p, h, x) {
    x === void 0 && (x = h), d[x] = p[h];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(d, p) {
    Object.defineProperty(d, "default", { enumerable: !0, value: p });
  } : function(d, p) {
    d.default = p;
  }), u = Q && Q.__importStar || function(d) {
    if (d && d.__esModule)
      return d;
    var p = {};
    if (d != null)
      for (var h in d)
        h !== "default" && Object.prototype.hasOwnProperty.call(d, h) && o(p, d, h);
    return t(p, d), p;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Fraction = e.Header = e.Misbehaviour = e.ConsensusState = e.ClientState = e.protobufPackage = void 0;
  const r = et, m = Tt, f = $i, b = Ae, R = Xe, T = nn, V = fr, D = ie, B = u(re);
  e.protobufPackage = "ibc.lightclients.tendermint.v1";
  function U() {
    return {
      chainId: "",
      trustLevel: void 0,
      trustingPeriod: void 0,
      unbondingPeriod: void 0,
      maxClockDrift: void 0,
      frozenHeight: void 0,
      latestHeight: void 0,
      proofSpecs: [],
      upgradePath: [],
      allowUpdateAfterExpiry: !1,
      allowUpdateAfterMisbehaviour: !1
    };
  }
  e.ClientState = {
    encode(d, p = B.Writer.create()) {
      d.chainId !== "" && p.uint32(10).string(d.chainId), d.trustLevel !== void 0 && e.Fraction.encode(d.trustLevel, p.uint32(18).fork()).ldelim(), d.trustingPeriod !== void 0 && r.Duration.encode(d.trustingPeriod, p.uint32(26).fork()).ldelim(), d.unbondingPeriod !== void 0 && r.Duration.encode(d.unbondingPeriod, p.uint32(34).fork()).ldelim(), d.maxClockDrift !== void 0 && r.Duration.encode(d.maxClockDrift, p.uint32(42).fork()).ldelim(), d.frozenHeight !== void 0 && m.Height.encode(d.frozenHeight, p.uint32(50).fork()).ldelim(), d.latestHeight !== void 0 && m.Height.encode(d.latestHeight, p.uint32(58).fork()).ldelim();
      for (const h of d.proofSpecs)
        f.ProofSpec.encode(h, p.uint32(66).fork()).ldelim();
      for (const h of d.upgradePath)
        p.uint32(74).string(h);
      return d.allowUpdateAfterExpiry === !0 && p.uint32(80).bool(d.allowUpdateAfterExpiry), d.allowUpdateAfterMisbehaviour === !0 && p.uint32(88).bool(d.allowUpdateAfterMisbehaviour), p;
    },
    decode(d, p) {
      const h = d instanceof B.Reader ? d : new B.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = U();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.chainId = h.string();
            break;
          case 2:
            _.trustLevel = e.Fraction.decode(h, h.uint32());
            break;
          case 3:
            _.trustingPeriod = r.Duration.decode(h, h.uint32());
            break;
          case 4:
            _.unbondingPeriod = r.Duration.decode(h, h.uint32());
            break;
          case 5:
            _.maxClockDrift = r.Duration.decode(h, h.uint32());
            break;
          case 6:
            _.frozenHeight = m.Height.decode(h, h.uint32());
            break;
          case 7:
            _.latestHeight = m.Height.decode(h, h.uint32());
            break;
          case 8:
            _.proofSpecs.push(f.ProofSpec.decode(h, h.uint32()));
            break;
          case 9:
            _.upgradePath.push(h.string());
            break;
          case 10:
            _.allowUpdateAfterExpiry = h.bool();
            break;
          case 11:
            _.allowUpdateAfterMisbehaviour = h.bool();
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        chainId: (0, D.isSet)(d.chainId) ? String(d.chainId) : "",
        trustLevel: (0, D.isSet)(d.trustLevel) ? e.Fraction.fromJSON(d.trustLevel) : void 0,
        trustingPeriod: (0, D.isSet)(d.trustingPeriod) ? r.Duration.fromJSON(d.trustingPeriod) : void 0,
        unbondingPeriod: (0, D.isSet)(d.unbondingPeriod) ? r.Duration.fromJSON(d.unbondingPeriod) : void 0,
        maxClockDrift: (0, D.isSet)(d.maxClockDrift) ? r.Duration.fromJSON(d.maxClockDrift) : void 0,
        frozenHeight: (0, D.isSet)(d.frozenHeight) ? m.Height.fromJSON(d.frozenHeight) : void 0,
        latestHeight: (0, D.isSet)(d.latestHeight) ? m.Height.fromJSON(d.latestHeight) : void 0,
        proofSpecs: Array.isArray(d == null ? void 0 : d.proofSpecs) ? d.proofSpecs.map((p) => f.ProofSpec.fromJSON(p)) : [],
        upgradePath: Array.isArray(d == null ? void 0 : d.upgradePath) ? d.upgradePath.map((p) => String(p)) : [],
        allowUpdateAfterExpiry: (0, D.isSet)(d.allowUpdateAfterExpiry) ? !!d.allowUpdateAfterExpiry : !1,
        allowUpdateAfterMisbehaviour: (0, D.isSet)(d.allowUpdateAfterMisbehaviour) ? !!d.allowUpdateAfterMisbehaviour : !1
      };
    },
    toJSON(d) {
      const p = {};
      return d.chainId !== void 0 && (p.chainId = d.chainId), d.trustLevel !== void 0 && (p.trustLevel = d.trustLevel ? e.Fraction.toJSON(d.trustLevel) : void 0), d.trustingPeriod !== void 0 && (p.trustingPeriod = d.trustingPeriod ? r.Duration.toJSON(d.trustingPeriod) : void 0), d.unbondingPeriod !== void 0 && (p.unbondingPeriod = d.unbondingPeriod ? r.Duration.toJSON(d.unbondingPeriod) : void 0), d.maxClockDrift !== void 0 && (p.maxClockDrift = d.maxClockDrift ? r.Duration.toJSON(d.maxClockDrift) : void 0), d.frozenHeight !== void 0 && (p.frozenHeight = d.frozenHeight ? m.Height.toJSON(d.frozenHeight) : void 0), d.latestHeight !== void 0 && (p.latestHeight = d.latestHeight ? m.Height.toJSON(d.latestHeight) : void 0), d.proofSpecs ? p.proofSpecs = d.proofSpecs.map((h) => h ? f.ProofSpec.toJSON(h) : void 0) : p.proofSpecs = [], d.upgradePath ? p.upgradePath = d.upgradePath.map((h) => h) : p.upgradePath = [], d.allowUpdateAfterExpiry !== void 0 && (p.allowUpdateAfterExpiry = d.allowUpdateAfterExpiry), d.allowUpdateAfterMisbehaviour !== void 0 && (p.allowUpdateAfterMisbehaviour = d.allowUpdateAfterMisbehaviour), p;
    },
    fromPartial(d) {
      var p, h;
      const x = U();
      return x.chainId = d.chainId ?? "", x.trustLevel = d.trustLevel !== void 0 && d.trustLevel !== null ? e.Fraction.fromPartial(d.trustLevel) : void 0, x.trustingPeriod = d.trustingPeriod !== void 0 && d.trustingPeriod !== null ? r.Duration.fromPartial(d.trustingPeriod) : void 0, x.unbondingPeriod = d.unbondingPeriod !== void 0 && d.unbondingPeriod !== null ? r.Duration.fromPartial(d.unbondingPeriod) : void 0, x.maxClockDrift = d.maxClockDrift !== void 0 && d.maxClockDrift !== null ? r.Duration.fromPartial(d.maxClockDrift) : void 0, x.frozenHeight = d.frozenHeight !== void 0 && d.frozenHeight !== null ? m.Height.fromPartial(d.frozenHeight) : void 0, x.latestHeight = d.latestHeight !== void 0 && d.latestHeight !== null ? m.Height.fromPartial(d.latestHeight) : void 0, x.proofSpecs = ((p = d.proofSpecs) == null ? void 0 : p.map((_) => f.ProofSpec.fromPartial(_))) || [], x.upgradePath = ((h = d.upgradePath) == null ? void 0 : h.map((_) => _)) || [], x.allowUpdateAfterExpiry = d.allowUpdateAfterExpiry ?? !1, x.allowUpdateAfterMisbehaviour = d.allowUpdateAfterMisbehaviour ?? !1, x;
    }
  };
  function C() {
    return {
      timestamp: void 0,
      root: void 0,
      nextValidatorsHash: new Uint8Array()
    };
  }
  e.ConsensusState = {
    encode(d, p = B.Writer.create()) {
      return d.timestamp !== void 0 && b.Timestamp.encode(d.timestamp, p.uint32(10).fork()).ldelim(), d.root !== void 0 && R.MerkleRoot.encode(d.root, p.uint32(18).fork()).ldelim(), d.nextValidatorsHash.length !== 0 && p.uint32(26).bytes(d.nextValidatorsHash), p;
    },
    decode(d, p) {
      const h = d instanceof B.Reader ? d : new B.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = C();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.timestamp = b.Timestamp.decode(h, h.uint32());
            break;
          case 2:
            _.root = R.MerkleRoot.decode(h, h.uint32());
            break;
          case 3:
            _.nextValidatorsHash = h.bytes();
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        timestamp: (0, D.isSet)(d.timestamp) ? (0, D.fromJsonTimestamp)(d.timestamp) : void 0,
        root: (0, D.isSet)(d.root) ? R.MerkleRoot.fromJSON(d.root) : void 0,
        nextValidatorsHash: (0, D.isSet)(d.nextValidatorsHash) ? (0, D.bytesFromBase64)(d.nextValidatorsHash) : new Uint8Array()
      };
    },
    toJSON(d) {
      const p = {};
      return d.timestamp !== void 0 && (p.timestamp = (0, D.fromTimestamp)(d.timestamp).toISOString()), d.root !== void 0 && (p.root = d.root ? R.MerkleRoot.toJSON(d.root) : void 0), d.nextValidatorsHash !== void 0 && (p.nextValidatorsHash = (0, D.base64FromBytes)(d.nextValidatorsHash !== void 0 ? d.nextValidatorsHash : new Uint8Array())), p;
    },
    fromPartial(d) {
      const p = C();
      return p.timestamp = d.timestamp !== void 0 && d.timestamp !== null ? b.Timestamp.fromPartial(d.timestamp) : void 0, p.root = d.root !== void 0 && d.root !== null ? R.MerkleRoot.fromPartial(d.root) : void 0, p.nextValidatorsHash = d.nextValidatorsHash ?? new Uint8Array(), p;
    }
  };
  function l() {
    return {
      clientId: "",
      header1: void 0,
      header2: void 0
    };
  }
  e.Misbehaviour = {
    encode(d, p = B.Writer.create()) {
      return d.clientId !== "" && p.uint32(10).string(d.clientId), d.header1 !== void 0 && e.Header.encode(d.header1, p.uint32(18).fork()).ldelim(), d.header2 !== void 0 && e.Header.encode(d.header2, p.uint32(26).fork()).ldelim(), p;
    },
    decode(d, p) {
      const h = d instanceof B.Reader ? d : new B.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = l();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.clientId = h.string();
            break;
          case 2:
            _.header1 = e.Header.decode(h, h.uint32());
            break;
          case 3:
            _.header2 = e.Header.decode(h, h.uint32());
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        clientId: (0, D.isSet)(d.clientId) ? String(d.clientId) : "",
        header1: (0, D.isSet)(d.header1) ? e.Header.fromJSON(d.header1) : void 0,
        header2: (0, D.isSet)(d.header2) ? e.Header.fromJSON(d.header2) : void 0
      };
    },
    toJSON(d) {
      const p = {};
      return d.clientId !== void 0 && (p.clientId = d.clientId), d.header1 !== void 0 && (p.header1 = d.header1 ? e.Header.toJSON(d.header1) : void 0), d.header2 !== void 0 && (p.header2 = d.header2 ? e.Header.toJSON(d.header2) : void 0), p;
    },
    fromPartial(d) {
      const p = l();
      return p.clientId = d.clientId ?? "", p.header1 = d.header1 !== void 0 && d.header1 !== null ? e.Header.fromPartial(d.header1) : void 0, p.header2 = d.header2 !== void 0 && d.header2 !== null ? e.Header.fromPartial(d.header2) : void 0, p;
    }
  };
  function S() {
    return {
      signedHeader: void 0,
      validatorSet: void 0,
      trustedHeight: void 0,
      trustedValidators: void 0
    };
  }
  e.Header = {
    encode(d, p = B.Writer.create()) {
      return d.signedHeader !== void 0 && T.SignedHeader.encode(d.signedHeader, p.uint32(10).fork()).ldelim(), d.validatorSet !== void 0 && V.ValidatorSet.encode(d.validatorSet, p.uint32(18).fork()).ldelim(), d.trustedHeight !== void 0 && m.Height.encode(d.trustedHeight, p.uint32(26).fork()).ldelim(), d.trustedValidators !== void 0 && V.ValidatorSet.encode(d.trustedValidators, p.uint32(34).fork()).ldelim(), p;
    },
    decode(d, p) {
      const h = d instanceof B.Reader ? d : new B.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = S();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.signedHeader = T.SignedHeader.decode(h, h.uint32());
            break;
          case 2:
            _.validatorSet = V.ValidatorSet.decode(h, h.uint32());
            break;
          case 3:
            _.trustedHeight = m.Height.decode(h, h.uint32());
            break;
          case 4:
            _.trustedValidators = V.ValidatorSet.decode(h, h.uint32());
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        signedHeader: (0, D.isSet)(d.signedHeader) ? T.SignedHeader.fromJSON(d.signedHeader) : void 0,
        validatorSet: (0, D.isSet)(d.validatorSet) ? V.ValidatorSet.fromJSON(d.validatorSet) : void 0,
        trustedHeight: (0, D.isSet)(d.trustedHeight) ? m.Height.fromJSON(d.trustedHeight) : void 0,
        trustedValidators: (0, D.isSet)(d.trustedValidators) ? V.ValidatorSet.fromJSON(d.trustedValidators) : void 0
      };
    },
    toJSON(d) {
      const p = {};
      return d.signedHeader !== void 0 && (p.signedHeader = d.signedHeader ? T.SignedHeader.toJSON(d.signedHeader) : void 0), d.validatorSet !== void 0 && (p.validatorSet = d.validatorSet ? V.ValidatorSet.toJSON(d.validatorSet) : void 0), d.trustedHeight !== void 0 && (p.trustedHeight = d.trustedHeight ? m.Height.toJSON(d.trustedHeight) : void 0), d.trustedValidators !== void 0 && (p.trustedValidators = d.trustedValidators ? V.ValidatorSet.toJSON(d.trustedValidators) : void 0), p;
    },
    fromPartial(d) {
      const p = S();
      return p.signedHeader = d.signedHeader !== void 0 && d.signedHeader !== null ? T.SignedHeader.fromPartial(d.signedHeader) : void 0, p.validatorSet = d.validatorSet !== void 0 && d.validatorSet !== null ? V.ValidatorSet.fromPartial(d.validatorSet) : void 0, p.trustedHeight = d.trustedHeight !== void 0 && d.trustedHeight !== null ? m.Height.fromPartial(d.trustedHeight) : void 0, p.trustedValidators = d.trustedValidators !== void 0 && d.trustedValidators !== null ? V.ValidatorSet.fromPartial(d.trustedValidators) : void 0, p;
    }
  };
  function A() {
    return {
      numerator: D.Long.UZERO,
      denominator: D.Long.UZERO
    };
  }
  e.Fraction = {
    encode(d, p = B.Writer.create()) {
      return d.numerator.isZero() || p.uint32(8).uint64(d.numerator), d.denominator.isZero() || p.uint32(16).uint64(d.denominator), p;
    },
    decode(d, p) {
      const h = d instanceof B.Reader ? d : new B.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = A();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.numerator = h.uint64();
            break;
          case 2:
            _.denominator = h.uint64();
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        numerator: (0, D.isSet)(d.numerator) ? D.Long.fromValue(d.numerator) : D.Long.UZERO,
        denominator: (0, D.isSet)(d.denominator) ? D.Long.fromValue(d.denominator) : D.Long.UZERO
      };
    },
    toJSON(d) {
      const p = {};
      return d.numerator !== void 0 && (p.numerator = (d.numerator || D.Long.UZERO).toString()), d.denominator !== void 0 && (p.denominator = (d.denominator || D.Long.UZERO).toString()), p;
    },
    fromPartial(d) {
      const p = A();
      return p.numerator = d.numerator !== void 0 && d.numerator !== null ? D.Long.fromValue(d.numerator) : D.Long.UZERO, p.denominator = d.denominator !== void 0 && d.denominator !== null ? D.Long.fromValue(d.denominator) : D.Long.UZERO, p;
    }
  };
})(xc);
var qm = Q && Q.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(pr, "__esModule", { value: !0 });
pr.setupIbcExtension = void 0;
const So = Be, Zm = Rt, Qm = Ec, Fm = lr, oi = Tc, ri = Cc, La = Ic, _c = xc, At = qm(Pt), Oe = Ve;
function ii(e) {
  if ((e == null ? void 0 : e.typeUrl) !== "/ibc.lightclients.tendermint.v1.ClientState")
    throw new Error(`Unexpected client state type: ${e == null ? void 0 : e.typeUrl}`);
  return _c.ClientState.decode(e.value);
}
function Gm(e) {
  if ((e == null ? void 0 : e.typeUrl) !== "/ibc.lightclients.tendermint.v1.ConsensusState")
    throw new Error(`Unexpected client state type: ${e == null ? void 0 : e.typeUrl}`);
  return _c.ConsensusState.decode(e.value);
}
function Km(e) {
  const o = (0, Oe.createProtobufRpcClient)(e), t = new oi.QueryClientImpl(o), u = new ri.QueryClientImpl(o), r = new La.QueryClientImpl(o), m = new Qm.QueryClientImpl(o);
  return {
    ibc: {
      channel: {
        channel: async (f, b) => t.Channel({
          portId: f,
          channelId: b
        }),
        channels: async (f) => t.Channels({
          pagination: (0, Oe.createPagination)(f)
        }),
        allChannels: async () => {
          var f;
          const b = [];
          let R, T;
          do
            R = await t.Channels({
              pagination: (0, Oe.createPagination)(T)
            }), b.push(...R.channels), T = (f = R.pagination) == null ? void 0 : f.nextKey;
          while (T && T.length);
          return {
            channels: b,
            height: R.height
          };
        },
        connectionChannels: async (f, b) => t.ConnectionChannels({
          connection: f,
          pagination: (0, Oe.createPagination)(b)
        }),
        allConnectionChannels: async (f) => {
          var b;
          const R = [];
          let T, V;
          do
            T = await t.ConnectionChannels({
              connection: f,
              pagination: (0, Oe.createPagination)(V)
            }), R.push(...T.channels), V = (b = T.pagination) == null ? void 0 : b.nextKey;
          while (V && V.length);
          return {
            channels: R,
            height: T.height
          };
        },
        clientState: async (f, b) => t.ChannelClientState({
          portId: f,
          channelId: b
        }),
        consensusState: async (f, b, R, T) => t.ChannelConsensusState({
          portId: f,
          channelId: b,
          revisionNumber: At.default.fromNumber(R, !0),
          revisionHeight: At.default.fromNumber(T, !0)
        }),
        packetCommitment: async (f, b, R) => t.PacketCommitment({
          portId: f,
          channelId: b,
          sequence: At.default.fromNumber(R, !0)
        }),
        packetCommitments: async (f, b, R) => t.PacketCommitments({
          channelId: b,
          portId: f,
          pagination: (0, Oe.createPagination)(R)
        }),
        allPacketCommitments: async (f, b) => {
          var R;
          const T = [];
          let V, D;
          do
            V = await t.PacketCommitments({
              channelId: b,
              portId: f,
              pagination: (0, Oe.createPagination)(D)
            }), T.push(...V.commitments), D = (R = V.pagination) == null ? void 0 : R.nextKey;
          while (D && D.length);
          return {
            commitments: T,
            height: V.height
          };
        },
        packetReceipt: async (f, b, R) => t.PacketReceipt({
          portId: f,
          channelId: b,
          sequence: At.default.fromNumber(R, !0)
        }),
        packetAcknowledgement: async (f, b, R) => t.PacketAcknowledgement({
          portId: f,
          channelId: b,
          sequence: At.default.fromNumber(R, !0)
        }),
        packetAcknowledgements: async (f, b, R) => {
          const T = oi.QueryPacketAcknowledgementsRequest.fromPartial({
            portId: f,
            channelId: b,
            pagination: (0, Oe.createPagination)(R)
          });
          return t.PacketAcknowledgements(T);
        },
        allPacketAcknowledgements: async (f, b) => {
          var R;
          const T = [];
          let V, D;
          do {
            const B = oi.QueryPacketAcknowledgementsRequest.fromPartial({
              channelId: b,
              portId: f,
              pagination: (0, Oe.createPagination)(D)
            });
            V = await t.PacketAcknowledgements(B), T.push(...V.acknowledgements), D = (R = V.pagination) == null ? void 0 : R.nextKey;
          } while (D && D.length);
          return {
            acknowledgements: T,
            height: V.height
          };
        },
        unreceivedPackets: async (f, b, R) => t.UnreceivedPackets({
          portId: f,
          channelId: b,
          packetCommitmentSequences: R.map((T) => At.default.fromNumber(T, !0))
        }),
        unreceivedAcks: async (f, b, R) => t.UnreceivedAcks({
          portId: f,
          channelId: b,
          packetAckSequences: R.map((T) => At.default.fromNumber(T, !0))
        }),
        nextSequenceReceive: async (f, b) => t.NextSequenceReceive({
          portId: f,
          channelId: b
        })
      },
      client: {
        state: async (f) => u.ClientState({ clientId: f }),
        states: async (f) => u.ClientStates({
          pagination: (0, Oe.createPagination)(f)
        }),
        allStates: async () => {
          var f;
          const b = [];
          let R, T;
          do
            R = await u.ClientStates({
              pagination: (0, Oe.createPagination)(T)
            }), b.push(...R.clientStates), T = (f = R.pagination) == null ? void 0 : f.nextKey;
          while (T && T.length);
          return {
            clientStates: b
          };
        },
        consensusState: async (f, b) => u.ConsensusState(ri.QueryConsensusStateRequest.fromPartial({
          clientId: f,
          revisionHeight: b !== void 0 ? At.default.fromNumber(b, !0) : void 0,
          latestHeight: b === void 0
        })),
        consensusStates: async (f, b) => u.ConsensusStates({
          clientId: f,
          pagination: (0, Oe.createPagination)(b)
        }),
        allConsensusStates: async (f) => {
          var b;
          const R = [];
          let T, V;
          do
            T = await u.ConsensusStates({
              clientId: f,
              pagination: (0, Oe.createPagination)(V)
            }), R.push(...T.consensusStates), V = (b = T.pagination) == null ? void 0 : b.nextKey;
          while (V && V.length);
          return {
            consensusStates: R
          };
        },
        params: async () => u.ClientParams({}),
        stateTm: async (f) => {
          const b = await u.ClientState({ clientId: f });
          return ii(b.clientState);
        },
        statesTm: async (f) => {
          const { clientStates: b } = await u.ClientStates({
            pagination: (0, Oe.createPagination)(f)
          });
          return b.map(({ clientState: R }) => ii(R));
        },
        allStatesTm: async () => {
          var f;
          const b = [];
          let R, T;
          do
            R = await u.ClientStates({
              pagination: (0, Oe.createPagination)(T)
            }), b.push(...R.clientStates), T = (f = R.pagination) == null ? void 0 : f.nextKey;
          while (T && T.length);
          return b.map(({ clientState: V }) => ii(V));
        },
        consensusStateTm: async (f, b) => {
          const R = await u.ConsensusState(ri.QueryConsensusStateRequest.fromPartial({
            clientId: f,
            revisionHeight: b == null ? void 0 : b.revisionHeight,
            revisionNumber: b == null ? void 0 : b.revisionNumber,
            latestHeight: b === void 0
          }));
          return Gm(R.consensusState);
        }
      },
      connection: {
        connection: async (f) => r.Connection({
          connectionId: f
        }),
        connections: async (f) => r.Connections({
          pagination: (0, Oe.createPagination)(f)
        }),
        allConnections: async () => {
          var f;
          const b = [];
          let R, T;
          do
            R = await r.Connections({
              pagination: (0, Oe.createPagination)(T)
            }), b.push(...R.connections), T = (f = R.pagination) == null ? void 0 : f.nextKey;
          while (T && T.length);
          return {
            connections: b,
            height: R.height
          };
        },
        clientConnections: async (f) => r.ClientConnections({
          clientId: f
        }),
        clientState: async (f) => r.ConnectionClientState({
          connectionId: f
        }),
        consensusState: async (f, b) => r.ConnectionConsensusState(La.QueryConnectionConsensusStateRequest.fromPartial({
          connectionId: f,
          revisionHeight: At.default.fromNumber(b, !0)
        }))
      },
      transfer: {
        denomTrace: async (f) => m.DenomTrace({ hash: f }),
        denomTraces: async (f) => m.DenomTraces({
          pagination: (0, Oe.createPagination)(f)
        }),
        allDenomTraces: async () => {
          var f;
          const b = [];
          let R, T;
          do
            R = await m.DenomTraces({
              pagination: (0, Oe.createPagination)(T)
            }), b.push(...R.denomTraces), T = (f = R.pagination) == null ? void 0 : f.nextKey;
          while (T && T.length);
          return {
            denomTraces: b
          };
        },
        params: async () => m.Params({})
      },
      verified: {
        channel: {
          channel: async (f, b) => {
            const R = (0, So.toAscii)(`channelEnds/ports/${f}/channels/${b}`), { value: T } = await e.queryStoreVerified("ibc", R);
            return T.length ? Fm.Channel.decode(T) : null;
          },
          packetCommitment: async (f, b, R) => {
            const T = (0, So.toAscii)(`commitments/ports/${f}/channels/${b}/packets/${R}`), { value: V } = await e.queryStoreVerified("ibc", T);
            return V;
          },
          packetAcknowledgement: async (f, b, R) => {
            const T = (0, So.toAscii)(`acks/ports/${f}/channels/${b}/acknowledgements/${R}`), { value: V } = await e.queryStoreVerified("ibc", T);
            return V;
          },
          nextSequenceReceive: async (f, b) => {
            const R = (0, So.toAscii)(`seqAcks/ports/${f}/channels/${b}/nextSequenceAck`), { value: T } = await e.queryStoreVerified("ibc", R);
            return T.length ? Zm.Uint64.fromBytes(T).toNumber() : null;
          }
        }
      }
    }
  };
}
pr.setupIbcExtension = Km;
var mr = {}, Jc = {}, Mt = {}, zm = Q && Q.__createBinding || (Object.create ? function(e, o, t, u) {
  u === void 0 && (u = t);
  var r = Object.getOwnPropertyDescriptor(o, t);
  (!r || ("get" in r ? !o.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return o[t];
  } }), Object.defineProperty(e, u, r);
} : function(e, o, t, u) {
  u === void 0 && (u = t), e[u] = o[t];
}), Ym = Q && Q.__setModuleDefault || (Object.create ? function(e, o) {
  Object.defineProperty(e, "default", { enumerable: !0, value: o });
} : function(e, o) {
  e.default = o;
}), $m = Q && Q.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var o = {};
  if (e != null)
    for (var t in e)
      t !== "default" && Object.prototype.hasOwnProperty.call(e, t) && zm(o, e, t);
  return Ym(o, e), o;
};
Object.defineProperty(Mt, "__esModule", { value: !0 });
Mt.Params = Mt.Minter = Mt.protobufPackage = void 0;
const qe = ie, kn = $m(re);
Mt.protobufPackage = "cosmos.mint.v1beta1";
function Ba() {
  return {
    inflation: "",
    annualProvisions: ""
  };
}
Mt.Minter = {
  encode(e, o = kn.Writer.create()) {
    return e.inflation !== "" && o.uint32(10).string(e.inflation), e.annualProvisions !== "" && o.uint32(18).string(e.annualProvisions), o;
  },
  decode(e, o) {
    const t = e instanceof kn.Reader ? e : new kn.Reader(e);
    let u = o === void 0 ? t.len : t.pos + o;
    const r = Ba();
    for (; t.pos < u; ) {
      const m = t.uint32();
      switch (m >>> 3) {
        case 1:
          r.inflation = t.string();
          break;
        case 2:
          r.annualProvisions = t.string();
          break;
        default:
          t.skipType(m & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      inflation: (0, qe.isSet)(e.inflation) ? String(e.inflation) : "",
      annualProvisions: (0, qe.isSet)(e.annualProvisions) ? String(e.annualProvisions) : ""
    };
  },
  toJSON(e) {
    const o = {};
    return e.inflation !== void 0 && (o.inflation = e.inflation), e.annualProvisions !== void 0 && (o.annualProvisions = e.annualProvisions), o;
  },
  fromPartial(e) {
    const o = Ba();
    return o.inflation = e.inflation ?? "", o.annualProvisions = e.annualProvisions ?? "", o;
  }
};
function Va() {
  return {
    mintDenom: "",
    inflationRateChange: "",
    inflationMax: "",
    inflationMin: "",
    goalBonded: "",
    blocksPerYear: qe.Long.UZERO
  };
}
Mt.Params = {
  encode(e, o = kn.Writer.create()) {
    return e.mintDenom !== "" && o.uint32(10).string(e.mintDenom), e.inflationRateChange !== "" && o.uint32(18).string(e.inflationRateChange), e.inflationMax !== "" && o.uint32(26).string(e.inflationMax), e.inflationMin !== "" && o.uint32(34).string(e.inflationMin), e.goalBonded !== "" && o.uint32(42).string(e.goalBonded), e.blocksPerYear.isZero() || o.uint32(48).uint64(e.blocksPerYear), o;
  },
  decode(e, o) {
    const t = e instanceof kn.Reader ? e : new kn.Reader(e);
    let u = o === void 0 ? t.len : t.pos + o;
    const r = Va();
    for (; t.pos < u; ) {
      const m = t.uint32();
      switch (m >>> 3) {
        case 1:
          r.mintDenom = t.string();
          break;
        case 2:
          r.inflationRateChange = t.string();
          break;
        case 3:
          r.inflationMax = t.string();
          break;
        case 4:
          r.inflationMin = t.string();
          break;
        case 5:
          r.goalBonded = t.string();
          break;
        case 6:
          r.blocksPerYear = t.uint64();
          break;
        default:
          t.skipType(m & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      mintDenom: (0, qe.isSet)(e.mintDenom) ? String(e.mintDenom) : "",
      inflationRateChange: (0, qe.isSet)(e.inflationRateChange) ? String(e.inflationRateChange) : "",
      inflationMax: (0, qe.isSet)(e.inflationMax) ? String(e.inflationMax) : "",
      inflationMin: (0, qe.isSet)(e.inflationMin) ? String(e.inflationMin) : "",
      goalBonded: (0, qe.isSet)(e.goalBonded) ? String(e.goalBonded) : "",
      blocksPerYear: (0, qe.isSet)(e.blocksPerYear) ? qe.Long.fromValue(e.blocksPerYear) : qe.Long.UZERO
    };
  },
  toJSON(e) {
    const o = {};
    return e.mintDenom !== void 0 && (o.mintDenom = e.mintDenom), e.inflationRateChange !== void 0 && (o.inflationRateChange = e.inflationRateChange), e.inflationMax !== void 0 && (o.inflationMax = e.inflationMax), e.inflationMin !== void 0 && (o.inflationMin = e.inflationMin), e.goalBonded !== void 0 && (o.goalBonded = e.goalBonded), e.blocksPerYear !== void 0 && (o.blocksPerYear = (e.blocksPerYear || qe.Long.UZERO).toString()), o;
  },
  fromPartial(e) {
    const o = Va();
    return o.mintDenom = e.mintDenom ?? "", o.inflationRateChange = e.inflationRateChange ?? "", o.inflationMax = e.inflationMax ?? "", o.inflationMin = e.inflationMin ?? "", o.goalBonded = e.goalBonded ?? "", o.blocksPerYear = e.blocksPerYear !== void 0 && e.blocksPerYear !== null ? qe.Long.fromValue(e.blocksPerYear) : qe.Long.UZERO, o;
  }
};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(C, l, S, A) {
    A === void 0 && (A = S);
    var d = Object.getOwnPropertyDescriptor(l, S);
    (!d || ("get" in d ? !l.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return l[S];
    } }), Object.defineProperty(C, A, d);
  } : function(C, l, S, A) {
    A === void 0 && (A = S), C[A] = l[S];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(C, l) {
    Object.defineProperty(C, "default", { enumerable: !0, value: l });
  } : function(C, l) {
    C.default = l;
  }), u = Q && Q.__importStar || function(C) {
    if (C && C.__esModule)
      return C;
    var l = {};
    if (C != null)
      for (var S in C)
        S !== "default" && Object.prototype.hasOwnProperty.call(C, S) && o(l, C, S);
    return t(l, C), l;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryAnnualProvisionsResponse = e.QueryAnnualProvisionsRequest = e.QueryInflationResponse = e.QueryInflationRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.protobufPackage = void 0;
  const r = Mt, m = u(re), f = ie;
  e.protobufPackage = "cosmos.mint.v1beta1";
  function b() {
    return {};
  }
  e.QueryParamsRequest = {
    encode(C, l = m.Writer.create()) {
      return l;
    },
    decode(C, l) {
      const S = C instanceof m.Reader ? C : new m.Reader(C);
      let A = l === void 0 ? S.len : S.pos + l;
      const d = b();
      for (; S.pos < A; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(C) {
      return {};
    },
    toJSON(C) {
      return {};
    },
    fromPartial(C) {
      return b();
    }
  };
  function R() {
    return {
      params: void 0
    };
  }
  e.QueryParamsResponse = {
    encode(C, l = m.Writer.create()) {
      return C.params !== void 0 && r.Params.encode(C.params, l.uint32(10).fork()).ldelim(), l;
    },
    decode(C, l) {
      const S = C instanceof m.Reader ? C : new m.Reader(C);
      let A = l === void 0 ? S.len : S.pos + l;
      const d = R();
      for (; S.pos < A; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.params = r.Params.decode(S, S.uint32());
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(C) {
      return {
        params: (0, f.isSet)(C.params) ? r.Params.fromJSON(C.params) : void 0
      };
    },
    toJSON(C) {
      const l = {};
      return C.params !== void 0 && (l.params = C.params ? r.Params.toJSON(C.params) : void 0), l;
    },
    fromPartial(C) {
      const l = R();
      return l.params = C.params !== void 0 && C.params !== null ? r.Params.fromPartial(C.params) : void 0, l;
    }
  };
  function T() {
    return {};
  }
  e.QueryInflationRequest = {
    encode(C, l = m.Writer.create()) {
      return l;
    },
    decode(C, l) {
      const S = C instanceof m.Reader ? C : new m.Reader(C);
      let A = l === void 0 ? S.len : S.pos + l;
      const d = T();
      for (; S.pos < A; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(C) {
      return {};
    },
    toJSON(C) {
      return {};
    },
    fromPartial(C) {
      return T();
    }
  };
  function V() {
    return {
      inflation: new Uint8Array()
    };
  }
  e.QueryInflationResponse = {
    encode(C, l = m.Writer.create()) {
      return C.inflation.length !== 0 && l.uint32(10).bytes(C.inflation), l;
    },
    decode(C, l) {
      const S = C instanceof m.Reader ? C : new m.Reader(C);
      let A = l === void 0 ? S.len : S.pos + l;
      const d = V();
      for (; S.pos < A; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.inflation = S.bytes();
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(C) {
      return {
        inflation: (0, f.isSet)(C.inflation) ? (0, f.bytesFromBase64)(C.inflation) : new Uint8Array()
      };
    },
    toJSON(C) {
      const l = {};
      return C.inflation !== void 0 && (l.inflation = (0, f.base64FromBytes)(C.inflation !== void 0 ? C.inflation : new Uint8Array())), l;
    },
    fromPartial(C) {
      const l = V();
      return l.inflation = C.inflation ?? new Uint8Array(), l;
    }
  };
  function D() {
    return {};
  }
  e.QueryAnnualProvisionsRequest = {
    encode(C, l = m.Writer.create()) {
      return l;
    },
    decode(C, l) {
      const S = C instanceof m.Reader ? C : new m.Reader(C);
      let A = l === void 0 ? S.len : S.pos + l;
      const d = D();
      for (; S.pos < A; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(C) {
      return {};
    },
    toJSON(C) {
      return {};
    },
    fromPartial(C) {
      return D();
    }
  };
  function B() {
    return {
      annualProvisions: new Uint8Array()
    };
  }
  e.QueryAnnualProvisionsResponse = {
    encode(C, l = m.Writer.create()) {
      return C.annualProvisions.length !== 0 && l.uint32(10).bytes(C.annualProvisions), l;
    },
    decode(C, l) {
      const S = C instanceof m.Reader ? C : new m.Reader(C);
      let A = l === void 0 ? S.len : S.pos + l;
      const d = B();
      for (; S.pos < A; ) {
        const p = S.uint32();
        switch (p >>> 3) {
          case 1:
            d.annualProvisions = S.bytes();
            break;
          default:
            S.skipType(p & 7);
            break;
        }
      }
      return d;
    },
    fromJSON(C) {
      return {
        annualProvisions: (0, f.isSet)(C.annualProvisions) ? (0, f.bytesFromBase64)(C.annualProvisions) : new Uint8Array()
      };
    },
    toJSON(C) {
      const l = {};
      return C.annualProvisions !== void 0 && (l.annualProvisions = (0, f.base64FromBytes)(C.annualProvisions !== void 0 ? C.annualProvisions : new Uint8Array())), l;
    },
    fromPartial(C) {
      const l = B();
      return l.annualProvisions = C.annualProvisions ?? new Uint8Array(), l;
    }
  };
  class U {
    constructor(l) {
      this.rpc = l, this.Params = this.Params.bind(this), this.Inflation = this.Inflation.bind(this), this.AnnualProvisions = this.AnnualProvisions.bind(this);
    }
    Params(l = {}) {
      const S = e.QueryParamsRequest.encode(l).finish();
      return this.rpc.request("cosmos.mint.v1beta1.Query", "Params", S).then((A) => e.QueryParamsResponse.decode(new m.Reader(A)));
    }
    Inflation(l = {}) {
      const S = e.QueryInflationRequest.encode(l).finish();
      return this.rpc.request("cosmos.mint.v1beta1.Query", "Inflation", S).then((A) => e.QueryInflationResponse.decode(new m.Reader(A)));
    }
    AnnualProvisions(l = {}) {
      const S = e.QueryAnnualProvisionsRequest.encode(l).finish();
      return this.rpc.request("cosmos.mint.v1beta1.Query", "AnnualProvisions", S).then((A) => e.QueryAnnualProvisionsResponse.decode(new m.Reader(A)));
    }
  }
  e.QueryClientImpl = U;
})(Jc);
Object.defineProperty(mr, "__esModule", { value: !0 });
mr.setupMintExtension = void 0;
const Xm = ht, eg = Jc, Zt = Ve;
function tg(e) {
  const o = (0, Zt.createProtobufRpcClient)(e), t = new eg.QueryClientImpl(o);
  return {
    mint: {
      params: async () => {
        const { params: u } = await t.Params({});
        return (0, Xm.assert)(u), {
          blocksPerYear: u.blocksPerYear,
          goalBonded: (0, Zt.decodeCosmosSdkDecFromProto)(u.goalBonded),
          inflationMin: (0, Zt.decodeCosmosSdkDecFromProto)(u.inflationMin),
          inflationMax: (0, Zt.decodeCosmosSdkDecFromProto)(u.inflationMax),
          inflationRateChange: (0, Zt.decodeCosmosSdkDecFromProto)(u.inflationRateChange),
          mintDenom: u.mintDenom
        };
      },
      inflation: async () => {
        const { inflation: u } = await t.Inflation({});
        return (0, Zt.decodeCosmosSdkDecFromProto)(u);
      },
      annualProvisions: async () => {
        const { annualProvisions: u } = await t.AnnualProvisions({});
        return (0, Zt.decodeCosmosSdkDecFromProto)(u);
      }
    }
  };
}
mr.setupMintExtension = tg;
var xn = {};
Object.defineProperty(xn, "__esModule", { value: !0 });
xn.createSlashingAminoConverters = xn.isAminoMsgUnjail = void 0;
function ng(e) {
  return e.type === "cosmos-sdk/MsgUnjail";
}
xn.isAminoMsgUnjail = ng;
function og() {
  throw new Error("Not implemented");
}
xn.createSlashingAminoConverters = og;
var gr = {}, Uc = {}, Ht = {}, rg = Q && Q.__createBinding || (Object.create ? function(e, o, t, u) {
  u === void 0 && (u = t);
  var r = Object.getOwnPropertyDescriptor(o, t);
  (!r || ("get" in r ? !o.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return o[t];
  } }), Object.defineProperty(e, u, r);
} : function(e, o, t, u) {
  u === void 0 && (u = t), e[u] = o[t];
}), ig = Q && Q.__setModuleDefault || (Object.create ? function(e, o) {
  Object.defineProperty(e, "default", { enumerable: !0, value: o });
} : function(e, o) {
  e.default = o;
}), sg = Q && Q.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var o = {};
  if (e != null)
    for (var t in e)
      t !== "default" && Object.prototype.hasOwnProperty.call(e, t) && rg(o, e, t);
  return ig(o, e), o;
};
Object.defineProperty(Ht, "__esModule", { value: !0 });
Ht.Params = Ht.ValidatorSigningInfo = Ht.protobufPackage = void 0;
const si = Ae, Zn = et, ae = ie, Pn = sg(re);
Ht.protobufPackage = "cosmos.slashing.v1beta1";
function Ma() {
  return {
    address: "",
    startHeight: ae.Long.ZERO,
    indexOffset: ae.Long.ZERO,
    jailedUntil: void 0,
    tombstoned: !1,
    missedBlocksCounter: ae.Long.ZERO
  };
}
Ht.ValidatorSigningInfo = {
  encode(e, o = Pn.Writer.create()) {
    return e.address !== "" && o.uint32(10).string(e.address), e.startHeight.isZero() || o.uint32(16).int64(e.startHeight), e.indexOffset.isZero() || o.uint32(24).int64(e.indexOffset), e.jailedUntil !== void 0 && si.Timestamp.encode(e.jailedUntil, o.uint32(34).fork()).ldelim(), e.tombstoned === !0 && o.uint32(40).bool(e.tombstoned), e.missedBlocksCounter.isZero() || o.uint32(48).int64(e.missedBlocksCounter), o;
  },
  decode(e, o) {
    const t = e instanceof Pn.Reader ? e : new Pn.Reader(e);
    let u = o === void 0 ? t.len : t.pos + o;
    const r = Ma();
    for (; t.pos < u; ) {
      const m = t.uint32();
      switch (m >>> 3) {
        case 1:
          r.address = t.string();
          break;
        case 2:
          r.startHeight = t.int64();
          break;
        case 3:
          r.indexOffset = t.int64();
          break;
        case 4:
          r.jailedUntil = si.Timestamp.decode(t, t.uint32());
          break;
        case 5:
          r.tombstoned = t.bool();
          break;
        case 6:
          r.missedBlocksCounter = t.int64();
          break;
        default:
          t.skipType(m & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      address: (0, ae.isSet)(e.address) ? String(e.address) : "",
      startHeight: (0, ae.isSet)(e.startHeight) ? ae.Long.fromValue(e.startHeight) : ae.Long.ZERO,
      indexOffset: (0, ae.isSet)(e.indexOffset) ? ae.Long.fromValue(e.indexOffset) : ae.Long.ZERO,
      jailedUntil: (0, ae.isSet)(e.jailedUntil) ? (0, ae.fromJsonTimestamp)(e.jailedUntil) : void 0,
      tombstoned: (0, ae.isSet)(e.tombstoned) ? !!e.tombstoned : !1,
      missedBlocksCounter: (0, ae.isSet)(e.missedBlocksCounter) ? ae.Long.fromValue(e.missedBlocksCounter) : ae.Long.ZERO
    };
  },
  toJSON(e) {
    const o = {};
    return e.address !== void 0 && (o.address = e.address), e.startHeight !== void 0 && (o.startHeight = (e.startHeight || ae.Long.ZERO).toString()), e.indexOffset !== void 0 && (o.indexOffset = (e.indexOffset || ae.Long.ZERO).toString()), e.jailedUntil !== void 0 && (o.jailedUntil = (0, ae.fromTimestamp)(e.jailedUntil).toISOString()), e.tombstoned !== void 0 && (o.tombstoned = e.tombstoned), e.missedBlocksCounter !== void 0 && (o.missedBlocksCounter = (e.missedBlocksCounter || ae.Long.ZERO).toString()), o;
  },
  fromPartial(e) {
    const o = Ma();
    return o.address = e.address ?? "", o.startHeight = e.startHeight !== void 0 && e.startHeight !== null ? ae.Long.fromValue(e.startHeight) : ae.Long.ZERO, o.indexOffset = e.indexOffset !== void 0 && e.indexOffset !== null ? ae.Long.fromValue(e.indexOffset) : ae.Long.ZERO, o.jailedUntil = e.jailedUntil !== void 0 && e.jailedUntil !== null ? si.Timestamp.fromPartial(e.jailedUntil) : void 0, o.tombstoned = e.tombstoned ?? !1, o.missedBlocksCounter = e.missedBlocksCounter !== void 0 && e.missedBlocksCounter !== null ? ae.Long.fromValue(e.missedBlocksCounter) : ae.Long.ZERO, o;
  }
};
function Ha() {
  return {
    signedBlocksWindow: ae.Long.ZERO,
    minSignedPerWindow: new Uint8Array(),
    downtimeJailDuration: void 0,
    slashFractionDoubleSign: new Uint8Array(),
    slashFractionDowntime: new Uint8Array()
  };
}
Ht.Params = {
  encode(e, o = Pn.Writer.create()) {
    return e.signedBlocksWindow.isZero() || o.uint32(8).int64(e.signedBlocksWindow), e.minSignedPerWindow.length !== 0 && o.uint32(18).bytes(e.minSignedPerWindow), e.downtimeJailDuration !== void 0 && Zn.Duration.encode(e.downtimeJailDuration, o.uint32(26).fork()).ldelim(), e.slashFractionDoubleSign.length !== 0 && o.uint32(34).bytes(e.slashFractionDoubleSign), e.slashFractionDowntime.length !== 0 && o.uint32(42).bytes(e.slashFractionDowntime), o;
  },
  decode(e, o) {
    const t = e instanceof Pn.Reader ? e : new Pn.Reader(e);
    let u = o === void 0 ? t.len : t.pos + o;
    const r = Ha();
    for (; t.pos < u; ) {
      const m = t.uint32();
      switch (m >>> 3) {
        case 1:
          r.signedBlocksWindow = t.int64();
          break;
        case 2:
          r.minSignedPerWindow = t.bytes();
          break;
        case 3:
          r.downtimeJailDuration = Zn.Duration.decode(t, t.uint32());
          break;
        case 4:
          r.slashFractionDoubleSign = t.bytes();
          break;
        case 5:
          r.slashFractionDowntime = t.bytes();
          break;
        default:
          t.skipType(m & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      signedBlocksWindow: (0, ae.isSet)(e.signedBlocksWindow) ? ae.Long.fromValue(e.signedBlocksWindow) : ae.Long.ZERO,
      minSignedPerWindow: (0, ae.isSet)(e.minSignedPerWindow) ? (0, ae.bytesFromBase64)(e.minSignedPerWindow) : new Uint8Array(),
      downtimeJailDuration: (0, ae.isSet)(e.downtimeJailDuration) ? Zn.Duration.fromJSON(e.downtimeJailDuration) : void 0,
      slashFractionDoubleSign: (0, ae.isSet)(e.slashFractionDoubleSign) ? (0, ae.bytesFromBase64)(e.slashFractionDoubleSign) : new Uint8Array(),
      slashFractionDowntime: (0, ae.isSet)(e.slashFractionDowntime) ? (0, ae.bytesFromBase64)(e.slashFractionDowntime) : new Uint8Array()
    };
  },
  toJSON(e) {
    const o = {};
    return e.signedBlocksWindow !== void 0 && (o.signedBlocksWindow = (e.signedBlocksWindow || ae.Long.ZERO).toString()), e.minSignedPerWindow !== void 0 && (o.minSignedPerWindow = (0, ae.base64FromBytes)(e.minSignedPerWindow !== void 0 ? e.minSignedPerWindow : new Uint8Array())), e.downtimeJailDuration !== void 0 && (o.downtimeJailDuration = e.downtimeJailDuration ? Zn.Duration.toJSON(e.downtimeJailDuration) : void 0), e.slashFractionDoubleSign !== void 0 && (o.slashFractionDoubleSign = (0, ae.base64FromBytes)(e.slashFractionDoubleSign !== void 0 ? e.slashFractionDoubleSign : new Uint8Array())), e.slashFractionDowntime !== void 0 && (o.slashFractionDowntime = (0, ae.base64FromBytes)(e.slashFractionDowntime !== void 0 ? e.slashFractionDowntime : new Uint8Array())), o;
  },
  fromPartial(e) {
    const o = Ha();
    return o.signedBlocksWindow = e.signedBlocksWindow !== void 0 && e.signedBlocksWindow !== null ? ae.Long.fromValue(e.signedBlocksWindow) : ae.Long.ZERO, o.minSignedPerWindow = e.minSignedPerWindow ?? new Uint8Array(), o.downtimeJailDuration = e.downtimeJailDuration !== void 0 && e.downtimeJailDuration !== null ? Zn.Duration.fromPartial(e.downtimeJailDuration) : void 0, o.slashFractionDoubleSign = e.slashFractionDoubleSign ?? new Uint8Array(), o.slashFractionDowntime = e.slashFractionDowntime ?? new Uint8Array(), o;
  }
};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(l, S, A, d) {
    d === void 0 && (d = A);
    var p = Object.getOwnPropertyDescriptor(S, A);
    (!p || ("get" in p ? !S.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return S[A];
    } }), Object.defineProperty(l, d, p);
  } : function(l, S, A, d) {
    d === void 0 && (d = A), l[d] = S[A];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(l, S) {
    Object.defineProperty(l, "default", { enumerable: !0, value: S });
  } : function(l, S) {
    l.default = S;
  }), u = Q && Q.__importStar || function(l) {
    if (l && l.__esModule)
      return l;
    var S = {};
    if (l != null)
      for (var A in l)
        A !== "default" && Object.prototype.hasOwnProperty.call(l, A) && o(S, l, A);
    return t(S, l), S;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QuerySigningInfosResponse = e.QuerySigningInfosRequest = e.QuerySigningInfoResponse = e.QuerySigningInfoRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.protobufPackage = void 0;
  const r = be, m = Ht, f = u(re), b = ie;
  e.protobufPackage = "cosmos.slashing.v1beta1";
  function R() {
    return {};
  }
  e.QueryParamsRequest = {
    encode(l, S = f.Writer.create()) {
      return S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = R();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {};
    },
    toJSON(l) {
      return {};
    },
    fromPartial(l) {
      return R();
    }
  };
  function T() {
    return {
      params: void 0
    };
  }
  e.QueryParamsResponse = {
    encode(l, S = f.Writer.create()) {
      return l.params !== void 0 && m.Params.encode(l.params, S.uint32(10).fork()).ldelim(), S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = T();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.params = m.Params.decode(A, A.uint32());
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        params: (0, b.isSet)(l.params) ? m.Params.fromJSON(l.params) : void 0
      };
    },
    toJSON(l) {
      const S = {};
      return l.params !== void 0 && (S.params = l.params ? m.Params.toJSON(l.params) : void 0), S;
    },
    fromPartial(l) {
      const S = T();
      return S.params = l.params !== void 0 && l.params !== null ? m.Params.fromPartial(l.params) : void 0, S;
    }
  };
  function V() {
    return {
      consAddress: ""
    };
  }
  e.QuerySigningInfoRequest = {
    encode(l, S = f.Writer.create()) {
      return l.consAddress !== "" && S.uint32(10).string(l.consAddress), S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = V();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.consAddress = A.string();
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        consAddress: (0, b.isSet)(l.consAddress) ? String(l.consAddress) : ""
      };
    },
    toJSON(l) {
      const S = {};
      return l.consAddress !== void 0 && (S.consAddress = l.consAddress), S;
    },
    fromPartial(l) {
      const S = V();
      return S.consAddress = l.consAddress ?? "", S;
    }
  };
  function D() {
    return {
      valSigningInfo: void 0
    };
  }
  e.QuerySigningInfoResponse = {
    encode(l, S = f.Writer.create()) {
      return l.valSigningInfo !== void 0 && m.ValidatorSigningInfo.encode(l.valSigningInfo, S.uint32(10).fork()).ldelim(), S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = D();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.valSigningInfo = m.ValidatorSigningInfo.decode(A, A.uint32());
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        valSigningInfo: (0, b.isSet)(l.valSigningInfo) ? m.ValidatorSigningInfo.fromJSON(l.valSigningInfo) : void 0
      };
    },
    toJSON(l) {
      const S = {};
      return l.valSigningInfo !== void 0 && (S.valSigningInfo = l.valSigningInfo ? m.ValidatorSigningInfo.toJSON(l.valSigningInfo) : void 0), S;
    },
    fromPartial(l) {
      const S = D();
      return S.valSigningInfo = l.valSigningInfo !== void 0 && l.valSigningInfo !== null ? m.ValidatorSigningInfo.fromPartial(l.valSigningInfo) : void 0, S;
    }
  };
  function B() {
    return {
      pagination: void 0
    };
  }
  e.QuerySigningInfosRequest = {
    encode(l, S = f.Writer.create()) {
      return l.pagination !== void 0 && r.PageRequest.encode(l.pagination, S.uint32(10).fork()).ldelim(), S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = B();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.pagination = r.PageRequest.decode(A, A.uint32());
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        pagination: (0, b.isSet)(l.pagination) ? r.PageRequest.fromJSON(l.pagination) : void 0
      };
    },
    toJSON(l) {
      const S = {};
      return l.pagination !== void 0 && (S.pagination = l.pagination ? r.PageRequest.toJSON(l.pagination) : void 0), S;
    },
    fromPartial(l) {
      const S = B();
      return S.pagination = l.pagination !== void 0 && l.pagination !== null ? r.PageRequest.fromPartial(l.pagination) : void 0, S;
    }
  };
  function U() {
    return {
      info: [],
      pagination: void 0
    };
  }
  e.QuerySigningInfosResponse = {
    encode(l, S = f.Writer.create()) {
      for (const A of l.info)
        m.ValidatorSigningInfo.encode(A, S.uint32(10).fork()).ldelim();
      return l.pagination !== void 0 && r.PageResponse.encode(l.pagination, S.uint32(18).fork()).ldelim(), S;
    },
    decode(l, S) {
      const A = l instanceof f.Reader ? l : new f.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = U();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.info.push(m.ValidatorSigningInfo.decode(A, A.uint32()));
            break;
          case 2:
            p.pagination = r.PageResponse.decode(A, A.uint32());
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        info: Array.isArray(l == null ? void 0 : l.info) ? l.info.map((S) => m.ValidatorSigningInfo.fromJSON(S)) : [],
        pagination: (0, b.isSet)(l.pagination) ? r.PageResponse.fromJSON(l.pagination) : void 0
      };
    },
    toJSON(l) {
      const S = {};
      return l.info ? S.info = l.info.map((A) => A ? m.ValidatorSigningInfo.toJSON(A) : void 0) : S.info = [], l.pagination !== void 0 && (S.pagination = l.pagination ? r.PageResponse.toJSON(l.pagination) : void 0), S;
    },
    fromPartial(l) {
      var S;
      const A = U();
      return A.info = ((S = l.info) == null ? void 0 : S.map((d) => m.ValidatorSigningInfo.fromPartial(d))) || [], A.pagination = l.pagination !== void 0 && l.pagination !== null ? r.PageResponse.fromPartial(l.pagination) : void 0, A;
    }
  };
  class C {
    constructor(S) {
      this.rpc = S, this.Params = this.Params.bind(this), this.SigningInfo = this.SigningInfo.bind(this), this.SigningInfos = this.SigningInfos.bind(this);
    }
    Params(S = {}) {
      const A = e.QueryParamsRequest.encode(S).finish();
      return this.rpc.request("cosmos.slashing.v1beta1.Query", "Params", A).then((d) => e.QueryParamsResponse.decode(new f.Reader(d)));
    }
    SigningInfo(S) {
      const A = e.QuerySigningInfoRequest.encode(S).finish();
      return this.rpc.request("cosmos.slashing.v1beta1.Query", "SigningInfo", A).then((d) => e.QuerySigningInfoResponse.decode(new f.Reader(d)));
    }
    SigningInfos(S = {
      pagination: void 0
    }) {
      const A = e.QuerySigningInfosRequest.encode(S).finish();
      return this.rpc.request("cosmos.slashing.v1beta1.Query", "SigningInfos", A).then((d) => e.QuerySigningInfosResponse.decode(new f.Reader(d)));
    }
  }
  e.QueryClientImpl = C;
})(Uc);
Object.defineProperty(gr, "__esModule", { value: !0 });
gr.setupSlashingExtension = void 0;
const ag = Uc, ja = Ve;
function dg(e) {
  const o = (0, ja.createProtobufRpcClient)(e), t = new ag.QueryClientImpl(o);
  return {
    slashing: {
      signingInfo: async (u) => await t.SigningInfo({
        consAddress: u
      }),
      signingInfos: async (u) => await t.SigningInfos({
        pagination: (0, ja.createPagination)(u)
      }),
      params: async () => await t.Params({})
    }
  };
}
gr.setupSlashingExtension = dg;
var _e = {};
Object.defineProperty(_e, "__esModule", { value: !0 });
_e.createStakingAminoConverters = _e.isAminoMsgUndelegate = _e.isAminoMsgBeginRedelegate = _e.isAminoMsgDelegate = _e.isAminoMsgEditValidator = _e.isAminoMsgCreateValidator = _e.protoDecimalToJson = void 0;
const Dc = Rt, Wa = tn, Ct = ht;
function Kn(e) {
  const o = Dc.Decimal.fromAtomics(e, 18), [t, u] = o.toString().split(".");
  return `${t}.${(u ?? "").padEnd(18, "0")}`;
}
_e.protoDecimalToJson = Kn;
function bo(e) {
  return Dc.Decimal.fromUserInput(e, 18).atomics;
}
function cg(e) {
  return e.type === "cosmos-sdk/MsgCreateValidator";
}
_e.isAminoMsgCreateValidator = cg;
function ug(e) {
  return e.type === "cosmos-sdk/MsgEditValidator";
}
_e.isAminoMsgEditValidator = ug;
function lg(e) {
  return e.type === "cosmos-sdk/MsgDelegate";
}
_e.isAminoMsgDelegate = lg;
function pg(e) {
  return e.type === "cosmos-sdk/MsgBeginRedelegate";
}
_e.isAminoMsgBeginRedelegate = pg;
function fg(e) {
  return e.type === "cosmos-sdk/MsgUndelegate";
}
_e.isAminoMsgUndelegate = fg;
function mg() {
  return {
    "/cosmos.staking.v1beta1.MsgBeginRedelegate": {
      aminoType: "cosmos-sdk/MsgBeginRedelegate",
      toAmino: ({ delegatorAddress: e, validatorSrcAddress: o, validatorDstAddress: t, amount: u }) => ((0, Ct.assertDefinedAndNotNull)(u, "missing amount"), {
        delegator_address: e,
        validator_src_address: o,
        validator_dst_address: t,
        amount: u
      }),
      fromAmino: ({ delegator_address: e, validator_src_address: o, validator_dst_address: t, amount: u }) => ({
        delegatorAddress: e,
        validatorSrcAddress: o,
        validatorDstAddress: t,
        amount: u
      })
    },
    "/cosmos.staking.v1beta1.MsgCreateValidator": {
      aminoType: "cosmos-sdk/MsgCreateValidator",
      toAmino: ({ description: e, commission: o, minSelfDelegation: t, delegatorAddress: u, validatorAddress: r, pubkey: m, value: f }) => ((0, Ct.assertDefinedAndNotNull)(e, "missing description"), (0, Ct.assertDefinedAndNotNull)(o, "missing commission"), (0, Ct.assertDefinedAndNotNull)(m, "missing pubkey"), (0, Ct.assertDefinedAndNotNull)(f, "missing value"), {
        description: {
          moniker: e.moniker,
          identity: e.identity,
          website: e.website,
          security_contact: e.securityContact,
          details: e.details
        },
        commission: {
          rate: Kn(o.rate),
          max_rate: Kn(o.maxRate),
          max_change_rate: Kn(o.maxChangeRate)
        },
        min_self_delegation: t,
        delegator_address: u,
        validator_address: r,
        pubkey: (0, Wa.decodePubkey)(m),
        value: f
      }),
      fromAmino: ({ description: e, commission: o, min_self_delegation: t, delegator_address: u, validator_address: r, pubkey: m, value: f }) => ({
        description: {
          moniker: e.moniker,
          identity: e.identity,
          website: e.website,
          securityContact: e.security_contact,
          details: e.details
        },
        commission: {
          rate: bo(o.rate),
          maxRate: bo(o.max_rate),
          maxChangeRate: bo(o.max_change_rate)
        },
        minSelfDelegation: t,
        delegatorAddress: u,
        validatorAddress: r,
        pubkey: (0, Wa.encodePubkey)(m),
        value: f
      })
    },
    "/cosmos.staking.v1beta1.MsgDelegate": {
      aminoType: "cosmos-sdk/MsgDelegate",
      toAmino: ({ delegatorAddress: e, validatorAddress: o, amount: t }) => ((0, Ct.assertDefinedAndNotNull)(t, "missing amount"), {
        delegator_address: e,
        validator_address: o,
        amount: t
      }),
      fromAmino: ({ delegator_address: e, validator_address: o, amount: t }) => ({
        delegatorAddress: e,
        validatorAddress: o,
        amount: t
      })
    },
    "/cosmos.staking.v1beta1.MsgEditValidator": {
      aminoType: "cosmos-sdk/MsgEditValidator",
      toAmino: ({ description: e, commissionRate: o, minSelfDelegation: t, validatorAddress: u }) => ((0, Ct.assertDefinedAndNotNull)(e, "missing description"), {
        description: {
          moniker: e.moniker,
          identity: e.identity,
          website: e.website,
          security_contact: e.securityContact,
          details: e.details
        },
        // empty string in the protobuf document means "do not change"
        commission_rate: o ? Kn(o) : void 0,
        // empty string in the protobuf document means "do not change"
        min_self_delegation: t || void 0,
        validator_address: u
      }),
      fromAmino: ({ description: e, commission_rate: o, min_self_delegation: t, validator_address: u }) => ({
        description: {
          moniker: e.moniker,
          identity: e.identity,
          website: e.website,
          securityContact: e.security_contact,
          details: e.details
        },
        // empty string in the protobuf document means "do not change"
        commissionRate: o ? bo(o) : "",
        // empty string in the protobuf document means "do not change"
        minSelfDelegation: t ?? "",
        validatorAddress: u
      })
    },
    "/cosmos.staking.v1beta1.MsgUndelegate": {
      aminoType: "cosmos-sdk/MsgUndelegate",
      toAmino: ({ delegatorAddress: e, validatorAddress: o, amount: t }) => ((0, Ct.assertDefinedAndNotNull)(t, "missing amount"), {
        delegator_address: e,
        validator_address: o,
        amount: t
      }),
      fromAmino: ({ delegator_address: e, validator_address: o, amount: t }) => ({
        delegatorAddress: e,
        validatorAddress: o,
        amount: t
      })
    }
  };
}
_e.createStakingAminoConverters = mg;
var Qe = {}, es = {}, ts = {}, ns = {}, Lc = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(U, C, l, S) {
    S === void 0 && (S = l);
    var A = Object.getOwnPropertyDescriptor(C, l);
    (!A || ("get" in A ? !C.__esModule : A.writable || A.configurable)) && (A = { enumerable: !0, get: function() {
      return C[l];
    } }), Object.defineProperty(U, S, A);
  } : function(U, C, l, S) {
    S === void 0 && (S = l), U[S] = C[l];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(U, C) {
    Object.defineProperty(U, "default", { enumerable: !0, value: C });
  } : function(U, C) {
    U.default = C;
  }), u = Q && Q.__importStar || function(U) {
    if (U && U.__esModule)
      return U;
    var C = {};
    if (U != null)
      for (var l in U)
        l !== "default" && Object.prototype.hasOwnProperty.call(U, l) && o(C, U, l);
    return t(C, U), C;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.HashedParams = e.VersionParams = e.ValidatorParams = e.EvidenceParams = e.BlockParams = e.ConsensusParams = e.protobufPackage = void 0;
  const r = et, m = ie, f = u(re);
  e.protobufPackage = "tendermint.types";
  function b() {
    return {
      block: void 0,
      evidence: void 0,
      validator: void 0,
      version: void 0
    };
  }
  e.ConsensusParams = {
    encode(U, C = f.Writer.create()) {
      return U.block !== void 0 && e.BlockParams.encode(U.block, C.uint32(10).fork()).ldelim(), U.evidence !== void 0 && e.EvidenceParams.encode(U.evidence, C.uint32(18).fork()).ldelim(), U.validator !== void 0 && e.ValidatorParams.encode(U.validator, C.uint32(26).fork()).ldelim(), U.version !== void 0 && e.VersionParams.encode(U.version, C.uint32(34).fork()).ldelim(), C;
    },
    decode(U, C) {
      const l = U instanceof f.Reader ? U : new f.Reader(U);
      let S = C === void 0 ? l.len : l.pos + C;
      const A = b();
      for (; l.pos < S; ) {
        const d = l.uint32();
        switch (d >>> 3) {
          case 1:
            A.block = e.BlockParams.decode(l, l.uint32());
            break;
          case 2:
            A.evidence = e.EvidenceParams.decode(l, l.uint32());
            break;
          case 3:
            A.validator = e.ValidatorParams.decode(l, l.uint32());
            break;
          case 4:
            A.version = e.VersionParams.decode(l, l.uint32());
            break;
          default:
            l.skipType(d & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(U) {
      return {
        block: (0, m.isSet)(U.block) ? e.BlockParams.fromJSON(U.block) : void 0,
        evidence: (0, m.isSet)(U.evidence) ? e.EvidenceParams.fromJSON(U.evidence) : void 0,
        validator: (0, m.isSet)(U.validator) ? e.ValidatorParams.fromJSON(U.validator) : void 0,
        version: (0, m.isSet)(U.version) ? e.VersionParams.fromJSON(U.version) : void 0
      };
    },
    toJSON(U) {
      const C = {};
      return U.block !== void 0 && (C.block = U.block ? e.BlockParams.toJSON(U.block) : void 0), U.evidence !== void 0 && (C.evidence = U.evidence ? e.EvidenceParams.toJSON(U.evidence) : void 0), U.validator !== void 0 && (C.validator = U.validator ? e.ValidatorParams.toJSON(U.validator) : void 0), U.version !== void 0 && (C.version = U.version ? e.VersionParams.toJSON(U.version) : void 0), C;
    },
    fromPartial(U) {
      const C = b();
      return C.block = U.block !== void 0 && U.block !== null ? e.BlockParams.fromPartial(U.block) : void 0, C.evidence = U.evidence !== void 0 && U.evidence !== null ? e.EvidenceParams.fromPartial(U.evidence) : void 0, C.validator = U.validator !== void 0 && U.validator !== null ? e.ValidatorParams.fromPartial(U.validator) : void 0, C.version = U.version !== void 0 && U.version !== null ? e.VersionParams.fromPartial(U.version) : void 0, C;
    }
  };
  function R() {
    return {
      maxBytes: m.Long.ZERO,
      maxGas: m.Long.ZERO
    };
  }
  e.BlockParams = {
    encode(U, C = f.Writer.create()) {
      return U.maxBytes.isZero() || C.uint32(8).int64(U.maxBytes), U.maxGas.isZero() || C.uint32(16).int64(U.maxGas), C;
    },
    decode(U, C) {
      const l = U instanceof f.Reader ? U : new f.Reader(U);
      let S = C === void 0 ? l.len : l.pos + C;
      const A = R();
      for (; l.pos < S; ) {
        const d = l.uint32();
        switch (d >>> 3) {
          case 1:
            A.maxBytes = l.int64();
            break;
          case 2:
            A.maxGas = l.int64();
            break;
          default:
            l.skipType(d & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(U) {
      return {
        maxBytes: (0, m.isSet)(U.maxBytes) ? m.Long.fromValue(U.maxBytes) : m.Long.ZERO,
        maxGas: (0, m.isSet)(U.maxGas) ? m.Long.fromValue(U.maxGas) : m.Long.ZERO
      };
    },
    toJSON(U) {
      const C = {};
      return U.maxBytes !== void 0 && (C.maxBytes = (U.maxBytes || m.Long.ZERO).toString()), U.maxGas !== void 0 && (C.maxGas = (U.maxGas || m.Long.ZERO).toString()), C;
    },
    fromPartial(U) {
      const C = R();
      return C.maxBytes = U.maxBytes !== void 0 && U.maxBytes !== null ? m.Long.fromValue(U.maxBytes) : m.Long.ZERO, C.maxGas = U.maxGas !== void 0 && U.maxGas !== null ? m.Long.fromValue(U.maxGas) : m.Long.ZERO, C;
    }
  };
  function T() {
    return {
      maxAgeNumBlocks: m.Long.ZERO,
      maxAgeDuration: void 0,
      maxBytes: m.Long.ZERO
    };
  }
  e.EvidenceParams = {
    encode(U, C = f.Writer.create()) {
      return U.maxAgeNumBlocks.isZero() || C.uint32(8).int64(U.maxAgeNumBlocks), U.maxAgeDuration !== void 0 && r.Duration.encode(U.maxAgeDuration, C.uint32(18).fork()).ldelim(), U.maxBytes.isZero() || C.uint32(24).int64(U.maxBytes), C;
    },
    decode(U, C) {
      const l = U instanceof f.Reader ? U : new f.Reader(U);
      let S = C === void 0 ? l.len : l.pos + C;
      const A = T();
      for (; l.pos < S; ) {
        const d = l.uint32();
        switch (d >>> 3) {
          case 1:
            A.maxAgeNumBlocks = l.int64();
            break;
          case 2:
            A.maxAgeDuration = r.Duration.decode(l, l.uint32());
            break;
          case 3:
            A.maxBytes = l.int64();
            break;
          default:
            l.skipType(d & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(U) {
      return {
        maxAgeNumBlocks: (0, m.isSet)(U.maxAgeNumBlocks) ? m.Long.fromValue(U.maxAgeNumBlocks) : m.Long.ZERO,
        maxAgeDuration: (0, m.isSet)(U.maxAgeDuration) ? r.Duration.fromJSON(U.maxAgeDuration) : void 0,
        maxBytes: (0, m.isSet)(U.maxBytes) ? m.Long.fromValue(U.maxBytes) : m.Long.ZERO
      };
    },
    toJSON(U) {
      const C = {};
      return U.maxAgeNumBlocks !== void 0 && (C.maxAgeNumBlocks = (U.maxAgeNumBlocks || m.Long.ZERO).toString()), U.maxAgeDuration !== void 0 && (C.maxAgeDuration = U.maxAgeDuration ? r.Duration.toJSON(U.maxAgeDuration) : void 0), U.maxBytes !== void 0 && (C.maxBytes = (U.maxBytes || m.Long.ZERO).toString()), C;
    },
    fromPartial(U) {
      const C = T();
      return C.maxAgeNumBlocks = U.maxAgeNumBlocks !== void 0 && U.maxAgeNumBlocks !== null ? m.Long.fromValue(U.maxAgeNumBlocks) : m.Long.ZERO, C.maxAgeDuration = U.maxAgeDuration !== void 0 && U.maxAgeDuration !== null ? r.Duration.fromPartial(U.maxAgeDuration) : void 0, C.maxBytes = U.maxBytes !== void 0 && U.maxBytes !== null ? m.Long.fromValue(U.maxBytes) : m.Long.ZERO, C;
    }
  };
  function V() {
    return {
      pubKeyTypes: []
    };
  }
  e.ValidatorParams = {
    encode(U, C = f.Writer.create()) {
      for (const l of U.pubKeyTypes)
        C.uint32(10).string(l);
      return C;
    },
    decode(U, C) {
      const l = U instanceof f.Reader ? U : new f.Reader(U);
      let S = C === void 0 ? l.len : l.pos + C;
      const A = V();
      for (; l.pos < S; ) {
        const d = l.uint32();
        switch (d >>> 3) {
          case 1:
            A.pubKeyTypes.push(l.string());
            break;
          default:
            l.skipType(d & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(U) {
      return {
        pubKeyTypes: Array.isArray(U == null ? void 0 : U.pubKeyTypes) ? U.pubKeyTypes.map((C) => String(C)) : []
      };
    },
    toJSON(U) {
      const C = {};
      return U.pubKeyTypes ? C.pubKeyTypes = U.pubKeyTypes.map((l) => l) : C.pubKeyTypes = [], C;
    },
    fromPartial(U) {
      var C;
      const l = V();
      return l.pubKeyTypes = ((C = U.pubKeyTypes) == null ? void 0 : C.map((S) => S)) || [], l;
    }
  };
  function D() {
    return {
      app: m.Long.UZERO
    };
  }
  e.VersionParams = {
    encode(U, C = f.Writer.create()) {
      return U.app.isZero() || C.uint32(8).uint64(U.app), C;
    },
    decode(U, C) {
      const l = U instanceof f.Reader ? U : new f.Reader(U);
      let S = C === void 0 ? l.len : l.pos + C;
      const A = D();
      for (; l.pos < S; ) {
        const d = l.uint32();
        switch (d >>> 3) {
          case 1:
            A.app = l.uint64();
            break;
          default:
            l.skipType(d & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(U) {
      return {
        app: (0, m.isSet)(U.app) ? m.Long.fromValue(U.app) : m.Long.UZERO
      };
    },
    toJSON(U) {
      const C = {};
      return U.app !== void 0 && (C.app = (U.app || m.Long.UZERO).toString()), C;
    },
    fromPartial(U) {
      const C = D();
      return C.app = U.app !== void 0 && U.app !== null ? m.Long.fromValue(U.app) : m.Long.UZERO, C;
    }
  };
  function B() {
    return {
      blockMaxBytes: m.Long.ZERO,
      blockMaxGas: m.Long.ZERO
    };
  }
  e.HashedParams = {
    encode(U, C = f.Writer.create()) {
      return U.blockMaxBytes.isZero() || C.uint32(8).int64(U.blockMaxBytes), U.blockMaxGas.isZero() || C.uint32(16).int64(U.blockMaxGas), C;
    },
    decode(U, C) {
      const l = U instanceof f.Reader ? U : new f.Reader(U);
      let S = C === void 0 ? l.len : l.pos + C;
      const A = B();
      for (; l.pos < S; ) {
        const d = l.uint32();
        switch (d >>> 3) {
          case 1:
            A.blockMaxBytes = l.int64();
            break;
          case 2:
            A.blockMaxGas = l.int64();
            break;
          default:
            l.skipType(d & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(U) {
      return {
        blockMaxBytes: (0, m.isSet)(U.blockMaxBytes) ? m.Long.fromValue(U.blockMaxBytes) : m.Long.ZERO,
        blockMaxGas: (0, m.isSet)(U.blockMaxGas) ? m.Long.fromValue(U.blockMaxGas) : m.Long.ZERO
      };
    },
    toJSON(U) {
      const C = {};
      return U.blockMaxBytes !== void 0 && (C.blockMaxBytes = (U.blockMaxBytes || m.Long.ZERO).toString()), U.blockMaxGas !== void 0 && (C.blockMaxGas = (U.blockMaxGas || m.Long.ZERO).toString()), C;
    },
    fromPartial(U) {
      const C = B();
      return C.blockMaxBytes = U.blockMaxBytes !== void 0 && U.blockMaxBytes !== null ? m.Long.fromValue(U.blockMaxBytes) : m.Long.ZERO, C.blockMaxGas = U.blockMaxGas !== void 0 && U.blockMaxGas !== null ? m.Long.fromValue(U.blockMaxGas) : m.Long.ZERO, C;
    }
  };
})(Lc);
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(a, J, H, z) {
    z === void 0 && (z = H);
    var F = Object.getOwnPropertyDescriptor(J, H);
    (!F || ("get" in F ? !J.__esModule : F.writable || F.configurable)) && (F = { enumerable: !0, get: function() {
      return J[H];
    } }), Object.defineProperty(a, z, F);
  } : function(a, J, H, z) {
    z === void 0 && (z = H), a[z] = J[H];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(a, J) {
    Object.defineProperty(a, "default", { enumerable: !0, value: J });
  } : function(a, J) {
    a.default = J;
  }), u = Q && Q.__importStar || function(a) {
    if (a && a.__esModule)
      return a;
    var J = {};
    if (a != null)
      for (var H in a)
        H !== "default" && Object.prototype.hasOwnProperty.call(a, H) && o(J, a, H);
    return t(J, a), J;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ResponsePrepareProposal = e.ResponseApplySnapshotChunk = e.ResponseLoadSnapshotChunk = e.ResponseOfferSnapshot = e.ResponseListSnapshots = e.ResponseCommit = e.ResponseEndBlock = e.ResponseDeliverTx = e.ResponseCheckTx = e.ResponseBeginBlock = e.ResponseQuery = e.ResponseInitChain = e.ResponseInfo = e.ResponseFlush = e.ResponseEcho = e.ResponseException = e.Response = e.RequestProcessProposal = e.RequestPrepareProposal = e.RequestApplySnapshotChunk = e.RequestLoadSnapshotChunk = e.RequestOfferSnapshot = e.RequestListSnapshots = e.RequestCommit = e.RequestEndBlock = e.RequestDeliverTx = e.RequestCheckTx = e.RequestBeginBlock = e.RequestQuery = e.RequestInitChain = e.RequestInfo = e.RequestFlush = e.RequestEcho = e.Request = e.misbehaviorTypeToJSON = e.misbehaviorTypeFromJSON = e.MisbehaviorType = e.responseProcessProposal_ProposalStatusToJSON = e.responseProcessProposal_ProposalStatusFromJSON = e.ResponseProcessProposal_ProposalStatus = e.responseApplySnapshotChunk_ResultToJSON = e.responseApplySnapshotChunk_ResultFromJSON = e.ResponseApplySnapshotChunk_Result = e.responseOfferSnapshot_ResultToJSON = e.responseOfferSnapshot_ResultFromJSON = e.ResponseOfferSnapshot_Result = e.checkTxTypeToJSON = e.checkTxTypeFromJSON = e.CheckTxType = e.protobufPackage = void 0, e.ABCIApplicationClientImpl = e.Snapshot = e.Misbehavior = e.ExtendedVoteInfo = e.VoteInfo = e.ValidatorUpdate = e.Validator = e.TxResult = e.EventAttribute = e.Event = e.ExtendedCommitInfo = e.CommitInfo = e.ResponseProcessProposal = void 0;
  const r = Ae, m = Lc, f = nn, b = Xi, R = $t, T = ie, V = u(re);
  e.protobufPackage = "tendermint.abci";
  var D;
  (function(a) {
    a[a.NEW = 0] = "NEW", a[a.RECHECK = 1] = "RECHECK", a[a.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(D = e.CheckTxType || (e.CheckTxType = {}));
  function B(a) {
    switch (a) {
      case 0:
      case "NEW":
        return D.NEW;
      case 1:
      case "RECHECK":
        return D.RECHECK;
      case -1:
      case "UNRECOGNIZED":
      default:
        return D.UNRECOGNIZED;
    }
  }
  e.checkTxTypeFromJSON = B;
  function U(a) {
    switch (a) {
      case D.NEW:
        return "NEW";
      case D.RECHECK:
        return "RECHECK";
      case D.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.checkTxTypeToJSON = U;
  var C;
  (function(a) {
    a[a.UNKNOWN = 0] = "UNKNOWN", a[a.ACCEPT = 1] = "ACCEPT", a[a.ABORT = 2] = "ABORT", a[a.REJECT = 3] = "REJECT", a[a.REJECT_FORMAT = 4] = "REJECT_FORMAT", a[a.REJECT_SENDER = 5] = "REJECT_SENDER", a[a.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(C = e.ResponseOfferSnapshot_Result || (e.ResponseOfferSnapshot_Result = {}));
  function l(a) {
    switch (a) {
      case 0:
      case "UNKNOWN":
        return C.UNKNOWN;
      case 1:
      case "ACCEPT":
        return C.ACCEPT;
      case 2:
      case "ABORT":
        return C.ABORT;
      case 3:
      case "REJECT":
        return C.REJECT;
      case 4:
      case "REJECT_FORMAT":
        return C.REJECT_FORMAT;
      case 5:
      case "REJECT_SENDER":
        return C.REJECT_SENDER;
      case -1:
      case "UNRECOGNIZED":
      default:
        return C.UNRECOGNIZED;
    }
  }
  e.responseOfferSnapshot_ResultFromJSON = l;
  function S(a) {
    switch (a) {
      case C.UNKNOWN:
        return "UNKNOWN";
      case C.ACCEPT:
        return "ACCEPT";
      case C.ABORT:
        return "ABORT";
      case C.REJECT:
        return "REJECT";
      case C.REJECT_FORMAT:
        return "REJECT_FORMAT";
      case C.REJECT_SENDER:
        return "REJECT_SENDER";
      case C.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.responseOfferSnapshot_ResultToJSON = S;
  var A;
  (function(a) {
    a[a.UNKNOWN = 0] = "UNKNOWN", a[a.ACCEPT = 1] = "ACCEPT", a[a.ABORT = 2] = "ABORT", a[a.RETRY = 3] = "RETRY", a[a.RETRY_SNAPSHOT = 4] = "RETRY_SNAPSHOT", a[a.REJECT_SNAPSHOT = 5] = "REJECT_SNAPSHOT", a[a.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(A = e.ResponseApplySnapshotChunk_Result || (e.ResponseApplySnapshotChunk_Result = {}));
  function d(a) {
    switch (a) {
      case 0:
      case "UNKNOWN":
        return A.UNKNOWN;
      case 1:
      case "ACCEPT":
        return A.ACCEPT;
      case 2:
      case "ABORT":
        return A.ABORT;
      case 3:
      case "RETRY":
        return A.RETRY;
      case 4:
      case "RETRY_SNAPSHOT":
        return A.RETRY_SNAPSHOT;
      case 5:
      case "REJECT_SNAPSHOT":
        return A.REJECT_SNAPSHOT;
      case -1:
      case "UNRECOGNIZED":
      default:
        return A.UNRECOGNIZED;
    }
  }
  e.responseApplySnapshotChunk_ResultFromJSON = d;
  function p(a) {
    switch (a) {
      case A.UNKNOWN:
        return "UNKNOWN";
      case A.ACCEPT:
        return "ACCEPT";
      case A.ABORT:
        return "ABORT";
      case A.RETRY:
        return "RETRY";
      case A.RETRY_SNAPSHOT:
        return "RETRY_SNAPSHOT";
      case A.REJECT_SNAPSHOT:
        return "REJECT_SNAPSHOT";
      case A.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.responseApplySnapshotChunk_ResultToJSON = p;
  var h;
  (function(a) {
    a[a.UNKNOWN = 0] = "UNKNOWN", a[a.ACCEPT = 1] = "ACCEPT", a[a.REJECT = 2] = "REJECT", a[a.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(h = e.ResponseProcessProposal_ProposalStatus || (e.ResponseProcessProposal_ProposalStatus = {}));
  function x(a) {
    switch (a) {
      case 0:
      case "UNKNOWN":
        return h.UNKNOWN;
      case 1:
      case "ACCEPT":
        return h.ACCEPT;
      case 2:
      case "REJECT":
        return h.REJECT;
      case -1:
      case "UNRECOGNIZED":
      default:
        return h.UNRECOGNIZED;
    }
  }
  e.responseProcessProposal_ProposalStatusFromJSON = x;
  function _(a) {
    switch (a) {
      case h.UNKNOWN:
        return "UNKNOWN";
      case h.ACCEPT:
        return "ACCEPT";
      case h.REJECT:
        return "REJECT";
      case h.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.responseProcessProposal_ProposalStatusToJSON = _;
  var I;
  (function(a) {
    a[a.UNKNOWN = 0] = "UNKNOWN", a[a.DUPLICATE_VOTE = 1] = "DUPLICATE_VOTE", a[a.LIGHT_CLIENT_ATTACK = 2] = "LIGHT_CLIENT_ATTACK", a[a.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(I = e.MisbehaviorType || (e.MisbehaviorType = {}));
  function W(a) {
    switch (a) {
      case 0:
      case "UNKNOWN":
        return I.UNKNOWN;
      case 1:
      case "DUPLICATE_VOTE":
        return I.DUPLICATE_VOTE;
      case 2:
      case "LIGHT_CLIENT_ATTACK":
        return I.LIGHT_CLIENT_ATTACK;
      case -1:
      case "UNRECOGNIZED":
      default:
        return I.UNRECOGNIZED;
    }
  }
  e.misbehaviorTypeFromJSON = W;
  function n(a) {
    switch (a) {
      case I.UNKNOWN:
        return "UNKNOWN";
      case I.DUPLICATE_VOTE:
        return "DUPLICATE_VOTE";
      case I.LIGHT_CLIENT_ATTACK:
        return "LIGHT_CLIENT_ATTACK";
      case I.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.misbehaviorTypeToJSON = n;
  function y() {
    return {
      echo: void 0,
      flush: void 0,
      info: void 0,
      initChain: void 0,
      query: void 0,
      beginBlock: void 0,
      checkTx: void 0,
      deliverTx: void 0,
      endBlock: void 0,
      commit: void 0,
      listSnapshots: void 0,
      offerSnapshot: void 0,
      loadSnapshotChunk: void 0,
      applySnapshotChunk: void 0,
      prepareProposal: void 0,
      processProposal: void 0
    };
  }
  e.Request = {
    encode(a, J = V.Writer.create()) {
      return a.echo !== void 0 && e.RequestEcho.encode(a.echo, J.uint32(10).fork()).ldelim(), a.flush !== void 0 && e.RequestFlush.encode(a.flush, J.uint32(18).fork()).ldelim(), a.info !== void 0 && e.RequestInfo.encode(a.info, J.uint32(26).fork()).ldelim(), a.initChain !== void 0 && e.RequestInitChain.encode(a.initChain, J.uint32(42).fork()).ldelim(), a.query !== void 0 && e.RequestQuery.encode(a.query, J.uint32(50).fork()).ldelim(), a.beginBlock !== void 0 && e.RequestBeginBlock.encode(a.beginBlock, J.uint32(58).fork()).ldelim(), a.checkTx !== void 0 && e.RequestCheckTx.encode(a.checkTx, J.uint32(66).fork()).ldelim(), a.deliverTx !== void 0 && e.RequestDeliverTx.encode(a.deliverTx, J.uint32(74).fork()).ldelim(), a.endBlock !== void 0 && e.RequestEndBlock.encode(a.endBlock, J.uint32(82).fork()).ldelim(), a.commit !== void 0 && e.RequestCommit.encode(a.commit, J.uint32(90).fork()).ldelim(), a.listSnapshots !== void 0 && e.RequestListSnapshots.encode(a.listSnapshots, J.uint32(98).fork()).ldelim(), a.offerSnapshot !== void 0 && e.RequestOfferSnapshot.encode(a.offerSnapshot, J.uint32(106).fork()).ldelim(), a.loadSnapshotChunk !== void 0 && e.RequestLoadSnapshotChunk.encode(a.loadSnapshotChunk, J.uint32(114).fork()).ldelim(), a.applySnapshotChunk !== void 0 && e.RequestApplySnapshotChunk.encode(a.applySnapshotChunk, J.uint32(122).fork()).ldelim(), a.prepareProposal !== void 0 && e.RequestPrepareProposal.encode(a.prepareProposal, J.uint32(130).fork()).ldelim(), a.processProposal !== void 0 && e.RequestProcessProposal.encode(a.processProposal, J.uint32(138).fork()).ldelim(), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = y();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.echo = e.RequestEcho.decode(H, H.uint32());
            break;
          case 2:
            F.flush = e.RequestFlush.decode(H, H.uint32());
            break;
          case 3:
            F.info = e.RequestInfo.decode(H, H.uint32());
            break;
          case 5:
            F.initChain = e.RequestInitChain.decode(H, H.uint32());
            break;
          case 6:
            F.query = e.RequestQuery.decode(H, H.uint32());
            break;
          case 7:
            F.beginBlock = e.RequestBeginBlock.decode(H, H.uint32());
            break;
          case 8:
            F.checkTx = e.RequestCheckTx.decode(H, H.uint32());
            break;
          case 9:
            F.deliverTx = e.RequestDeliverTx.decode(H, H.uint32());
            break;
          case 10:
            F.endBlock = e.RequestEndBlock.decode(H, H.uint32());
            break;
          case 11:
            F.commit = e.RequestCommit.decode(H, H.uint32());
            break;
          case 12:
            F.listSnapshots = e.RequestListSnapshots.decode(H, H.uint32());
            break;
          case 13:
            F.offerSnapshot = e.RequestOfferSnapshot.decode(H, H.uint32());
            break;
          case 14:
            F.loadSnapshotChunk = e.RequestLoadSnapshotChunk.decode(H, H.uint32());
            break;
          case 15:
            F.applySnapshotChunk = e.RequestApplySnapshotChunk.decode(H, H.uint32());
            break;
          case 16:
            F.prepareProposal = e.RequestPrepareProposal.decode(H, H.uint32());
            break;
          case 17:
            F.processProposal = e.RequestProcessProposal.decode(H, H.uint32());
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        echo: (0, T.isSet)(a.echo) ? e.RequestEcho.fromJSON(a.echo) : void 0,
        flush: (0, T.isSet)(a.flush) ? e.RequestFlush.fromJSON(a.flush) : void 0,
        info: (0, T.isSet)(a.info) ? e.RequestInfo.fromJSON(a.info) : void 0,
        initChain: (0, T.isSet)(a.initChain) ? e.RequestInitChain.fromJSON(a.initChain) : void 0,
        query: (0, T.isSet)(a.query) ? e.RequestQuery.fromJSON(a.query) : void 0,
        beginBlock: (0, T.isSet)(a.beginBlock) ? e.RequestBeginBlock.fromJSON(a.beginBlock) : void 0,
        checkTx: (0, T.isSet)(a.checkTx) ? e.RequestCheckTx.fromJSON(a.checkTx) : void 0,
        deliverTx: (0, T.isSet)(a.deliverTx) ? e.RequestDeliverTx.fromJSON(a.deliverTx) : void 0,
        endBlock: (0, T.isSet)(a.endBlock) ? e.RequestEndBlock.fromJSON(a.endBlock) : void 0,
        commit: (0, T.isSet)(a.commit) ? e.RequestCommit.fromJSON(a.commit) : void 0,
        listSnapshots: (0, T.isSet)(a.listSnapshots) ? e.RequestListSnapshots.fromJSON(a.listSnapshots) : void 0,
        offerSnapshot: (0, T.isSet)(a.offerSnapshot) ? e.RequestOfferSnapshot.fromJSON(a.offerSnapshot) : void 0,
        loadSnapshotChunk: (0, T.isSet)(a.loadSnapshotChunk) ? e.RequestLoadSnapshotChunk.fromJSON(a.loadSnapshotChunk) : void 0,
        applySnapshotChunk: (0, T.isSet)(a.applySnapshotChunk) ? e.RequestApplySnapshotChunk.fromJSON(a.applySnapshotChunk) : void 0,
        prepareProposal: (0, T.isSet)(a.prepareProposal) ? e.RequestPrepareProposal.fromJSON(a.prepareProposal) : void 0,
        processProposal: (0, T.isSet)(a.processProposal) ? e.RequestProcessProposal.fromJSON(a.processProposal) : void 0
      };
    },
    toJSON(a) {
      const J = {};
      return a.echo !== void 0 && (J.echo = a.echo ? e.RequestEcho.toJSON(a.echo) : void 0), a.flush !== void 0 && (J.flush = a.flush ? e.RequestFlush.toJSON(a.flush) : void 0), a.info !== void 0 && (J.info = a.info ? e.RequestInfo.toJSON(a.info) : void 0), a.initChain !== void 0 && (J.initChain = a.initChain ? e.RequestInitChain.toJSON(a.initChain) : void 0), a.query !== void 0 && (J.query = a.query ? e.RequestQuery.toJSON(a.query) : void 0), a.beginBlock !== void 0 && (J.beginBlock = a.beginBlock ? e.RequestBeginBlock.toJSON(a.beginBlock) : void 0), a.checkTx !== void 0 && (J.checkTx = a.checkTx ? e.RequestCheckTx.toJSON(a.checkTx) : void 0), a.deliverTx !== void 0 && (J.deliverTx = a.deliverTx ? e.RequestDeliverTx.toJSON(a.deliverTx) : void 0), a.endBlock !== void 0 && (J.endBlock = a.endBlock ? e.RequestEndBlock.toJSON(a.endBlock) : void 0), a.commit !== void 0 && (J.commit = a.commit ? e.RequestCommit.toJSON(a.commit) : void 0), a.listSnapshots !== void 0 && (J.listSnapshots = a.listSnapshots ? e.RequestListSnapshots.toJSON(a.listSnapshots) : void 0), a.offerSnapshot !== void 0 && (J.offerSnapshot = a.offerSnapshot ? e.RequestOfferSnapshot.toJSON(a.offerSnapshot) : void 0), a.loadSnapshotChunk !== void 0 && (J.loadSnapshotChunk = a.loadSnapshotChunk ? e.RequestLoadSnapshotChunk.toJSON(a.loadSnapshotChunk) : void 0), a.applySnapshotChunk !== void 0 && (J.applySnapshotChunk = a.applySnapshotChunk ? e.RequestApplySnapshotChunk.toJSON(a.applySnapshotChunk) : void 0), a.prepareProposal !== void 0 && (J.prepareProposal = a.prepareProposal ? e.RequestPrepareProposal.toJSON(a.prepareProposal) : void 0), a.processProposal !== void 0 && (J.processProposal = a.processProposal ? e.RequestProcessProposal.toJSON(a.processProposal) : void 0), J;
    },
    fromPartial(a) {
      const J = y();
      return J.echo = a.echo !== void 0 && a.echo !== null ? e.RequestEcho.fromPartial(a.echo) : void 0, J.flush = a.flush !== void 0 && a.flush !== null ? e.RequestFlush.fromPartial(a.flush) : void 0, J.info = a.info !== void 0 && a.info !== null ? e.RequestInfo.fromPartial(a.info) : void 0, J.initChain = a.initChain !== void 0 && a.initChain !== null ? e.RequestInitChain.fromPartial(a.initChain) : void 0, J.query = a.query !== void 0 && a.query !== null ? e.RequestQuery.fromPartial(a.query) : void 0, J.beginBlock = a.beginBlock !== void 0 && a.beginBlock !== null ? e.RequestBeginBlock.fromPartial(a.beginBlock) : void 0, J.checkTx = a.checkTx !== void 0 && a.checkTx !== null ? e.RequestCheckTx.fromPartial(a.checkTx) : void 0, J.deliverTx = a.deliverTx !== void 0 && a.deliverTx !== null ? e.RequestDeliverTx.fromPartial(a.deliverTx) : void 0, J.endBlock = a.endBlock !== void 0 && a.endBlock !== null ? e.RequestEndBlock.fromPartial(a.endBlock) : void 0, J.commit = a.commit !== void 0 && a.commit !== null ? e.RequestCommit.fromPartial(a.commit) : void 0, J.listSnapshots = a.listSnapshots !== void 0 && a.listSnapshots !== null ? e.RequestListSnapshots.fromPartial(a.listSnapshots) : void 0, J.offerSnapshot = a.offerSnapshot !== void 0 && a.offerSnapshot !== null ? e.RequestOfferSnapshot.fromPartial(a.offerSnapshot) : void 0, J.loadSnapshotChunk = a.loadSnapshotChunk !== void 0 && a.loadSnapshotChunk !== null ? e.RequestLoadSnapshotChunk.fromPartial(a.loadSnapshotChunk) : void 0, J.applySnapshotChunk = a.applySnapshotChunk !== void 0 && a.applySnapshotChunk !== null ? e.RequestApplySnapshotChunk.fromPartial(a.applySnapshotChunk) : void 0, J.prepareProposal = a.prepareProposal !== void 0 && a.prepareProposal !== null ? e.RequestPrepareProposal.fromPartial(a.prepareProposal) : void 0, J.processProposal = a.processProposal !== void 0 && a.processProposal !== null ? e.RequestProcessProposal.fromPartial(a.processProposal) : void 0, J;
    }
  };
  function w() {
    return {
      message: ""
    };
  }
  e.RequestEcho = {
    encode(a, J = V.Writer.create()) {
      return a.message !== "" && J.uint32(10).string(a.message), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = w();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.message = H.string();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        message: (0, T.isSet)(a.message) ? String(a.message) : ""
      };
    },
    toJSON(a) {
      const J = {};
      return a.message !== void 0 && (J.message = a.message), J;
    },
    fromPartial(a) {
      const J = w();
      return J.message = a.message ?? "", J;
    }
  };
  function M() {
    return {};
  }
  e.RequestFlush = {
    encode(a, J = V.Writer.create()) {
      return J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = M();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {};
    },
    toJSON(a) {
      return {};
    },
    fromPartial(a) {
      return M();
    }
  };
  function s() {
    return {
      version: "",
      blockVersion: T.Long.UZERO,
      p2pVersion: T.Long.UZERO,
      abciVersion: ""
    };
  }
  e.RequestInfo = {
    encode(a, J = V.Writer.create()) {
      return a.version !== "" && J.uint32(10).string(a.version), a.blockVersion.isZero() || J.uint32(16).uint64(a.blockVersion), a.p2pVersion.isZero() || J.uint32(24).uint64(a.p2pVersion), a.abciVersion !== "" && J.uint32(34).string(a.abciVersion), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = s();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.version = H.string();
            break;
          case 2:
            F.blockVersion = H.uint64();
            break;
          case 3:
            F.p2pVersion = H.uint64();
            break;
          case 4:
            F.abciVersion = H.string();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        version: (0, T.isSet)(a.version) ? String(a.version) : "",
        blockVersion: (0, T.isSet)(a.blockVersion) ? T.Long.fromValue(a.blockVersion) : T.Long.UZERO,
        p2pVersion: (0, T.isSet)(a.p2pVersion) ? T.Long.fromValue(a.p2pVersion) : T.Long.UZERO,
        abciVersion: (0, T.isSet)(a.abciVersion) ? String(a.abciVersion) : ""
      };
    },
    toJSON(a) {
      const J = {};
      return a.version !== void 0 && (J.version = a.version), a.blockVersion !== void 0 && (J.blockVersion = (a.blockVersion || T.Long.UZERO).toString()), a.p2pVersion !== void 0 && (J.p2pVersion = (a.p2pVersion || T.Long.UZERO).toString()), a.abciVersion !== void 0 && (J.abciVersion = a.abciVersion), J;
    },
    fromPartial(a) {
      const J = s();
      return J.version = a.version ?? "", J.blockVersion = a.blockVersion !== void 0 && a.blockVersion !== null ? T.Long.fromValue(a.blockVersion) : T.Long.UZERO, J.p2pVersion = a.p2pVersion !== void 0 && a.p2pVersion !== null ? T.Long.fromValue(a.p2pVersion) : T.Long.UZERO, J.abciVersion = a.abciVersion ?? "", J;
    }
  };
  function c() {
    return {
      time: void 0,
      chainId: "",
      consensusParams: void 0,
      validators: [],
      appStateBytes: new Uint8Array(),
      initialHeight: T.Long.ZERO
    };
  }
  e.RequestInitChain = {
    encode(a, J = V.Writer.create()) {
      a.time !== void 0 && r.Timestamp.encode(a.time, J.uint32(10).fork()).ldelim(), a.chainId !== "" && J.uint32(18).string(a.chainId), a.consensusParams !== void 0 && m.ConsensusParams.encode(a.consensusParams, J.uint32(26).fork()).ldelim();
      for (const H of a.validators)
        e.ValidatorUpdate.encode(H, J.uint32(34).fork()).ldelim();
      return a.appStateBytes.length !== 0 && J.uint32(42).bytes(a.appStateBytes), a.initialHeight.isZero() || J.uint32(48).int64(a.initialHeight), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = c();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.time = r.Timestamp.decode(H, H.uint32());
            break;
          case 2:
            F.chainId = H.string();
            break;
          case 3:
            F.consensusParams = m.ConsensusParams.decode(H, H.uint32());
            break;
          case 4:
            F.validators.push(e.ValidatorUpdate.decode(H, H.uint32()));
            break;
          case 5:
            F.appStateBytes = H.bytes();
            break;
          case 6:
            F.initialHeight = H.int64();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        time: (0, T.isSet)(a.time) ? (0, T.fromJsonTimestamp)(a.time) : void 0,
        chainId: (0, T.isSet)(a.chainId) ? String(a.chainId) : "",
        consensusParams: (0, T.isSet)(a.consensusParams) ? m.ConsensusParams.fromJSON(a.consensusParams) : void 0,
        validators: Array.isArray(a == null ? void 0 : a.validators) ? a.validators.map((J) => e.ValidatorUpdate.fromJSON(J)) : [],
        appStateBytes: (0, T.isSet)(a.appStateBytes) ? (0, T.bytesFromBase64)(a.appStateBytes) : new Uint8Array(),
        initialHeight: (0, T.isSet)(a.initialHeight) ? T.Long.fromValue(a.initialHeight) : T.Long.ZERO
      };
    },
    toJSON(a) {
      const J = {};
      return a.time !== void 0 && (J.time = (0, T.fromTimestamp)(a.time).toISOString()), a.chainId !== void 0 && (J.chainId = a.chainId), a.consensusParams !== void 0 && (J.consensusParams = a.consensusParams ? m.ConsensusParams.toJSON(a.consensusParams) : void 0), a.validators ? J.validators = a.validators.map((H) => H ? e.ValidatorUpdate.toJSON(H) : void 0) : J.validators = [], a.appStateBytes !== void 0 && (J.appStateBytes = (0, T.base64FromBytes)(a.appStateBytes !== void 0 ? a.appStateBytes : new Uint8Array())), a.initialHeight !== void 0 && (J.initialHeight = (a.initialHeight || T.Long.ZERO).toString()), J;
    },
    fromPartial(a) {
      var J;
      const H = c();
      return H.time = a.time !== void 0 && a.time !== null ? r.Timestamp.fromPartial(a.time) : void 0, H.chainId = a.chainId ?? "", H.consensusParams = a.consensusParams !== void 0 && a.consensusParams !== null ? m.ConsensusParams.fromPartial(a.consensusParams) : void 0, H.validators = ((J = a.validators) == null ? void 0 : J.map((z) => e.ValidatorUpdate.fromPartial(z))) || [], H.appStateBytes = a.appStateBytes ?? new Uint8Array(), H.initialHeight = a.initialHeight !== void 0 && a.initialHeight !== null ? T.Long.fromValue(a.initialHeight) : T.Long.ZERO, H;
    }
  };
  function E() {
    return {
      data: new Uint8Array(),
      path: "",
      height: T.Long.ZERO,
      prove: !1
    };
  }
  e.RequestQuery = {
    encode(a, J = V.Writer.create()) {
      return a.data.length !== 0 && J.uint32(10).bytes(a.data), a.path !== "" && J.uint32(18).string(a.path), a.height.isZero() || J.uint32(24).int64(a.height), a.prove === !0 && J.uint32(32).bool(a.prove), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = E();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.data = H.bytes();
            break;
          case 2:
            F.path = H.string();
            break;
          case 3:
            F.height = H.int64();
            break;
          case 4:
            F.prove = H.bool();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        data: (0, T.isSet)(a.data) ? (0, T.bytesFromBase64)(a.data) : new Uint8Array(),
        path: (0, T.isSet)(a.path) ? String(a.path) : "",
        height: (0, T.isSet)(a.height) ? T.Long.fromValue(a.height) : T.Long.ZERO,
        prove: (0, T.isSet)(a.prove) ? !!a.prove : !1
      };
    },
    toJSON(a) {
      const J = {};
      return a.data !== void 0 && (J.data = (0, T.base64FromBytes)(a.data !== void 0 ? a.data : new Uint8Array())), a.path !== void 0 && (J.path = a.path), a.height !== void 0 && (J.height = (a.height || T.Long.ZERO).toString()), a.prove !== void 0 && (J.prove = a.prove), J;
    },
    fromPartial(a) {
      const J = E();
      return J.data = a.data ?? new Uint8Array(), J.path = a.path ?? "", J.height = a.height !== void 0 && a.height !== null ? T.Long.fromValue(a.height) : T.Long.ZERO, J.prove = a.prove ?? !1, J;
    }
  };
  function k() {
    return {
      hash: new Uint8Array(),
      header: void 0,
      lastCommitInfo: void 0,
      byzantineValidators: []
    };
  }
  e.RequestBeginBlock = {
    encode(a, J = V.Writer.create()) {
      a.hash.length !== 0 && J.uint32(10).bytes(a.hash), a.header !== void 0 && f.Header.encode(a.header, J.uint32(18).fork()).ldelim(), a.lastCommitInfo !== void 0 && e.CommitInfo.encode(a.lastCommitInfo, J.uint32(26).fork()).ldelim();
      for (const H of a.byzantineValidators)
        e.Misbehavior.encode(H, J.uint32(34).fork()).ldelim();
      return J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = k();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.hash = H.bytes();
            break;
          case 2:
            F.header = f.Header.decode(H, H.uint32());
            break;
          case 3:
            F.lastCommitInfo = e.CommitInfo.decode(H, H.uint32());
            break;
          case 4:
            F.byzantineValidators.push(e.Misbehavior.decode(H, H.uint32()));
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        hash: (0, T.isSet)(a.hash) ? (0, T.bytesFromBase64)(a.hash) : new Uint8Array(),
        header: (0, T.isSet)(a.header) ? f.Header.fromJSON(a.header) : void 0,
        lastCommitInfo: (0, T.isSet)(a.lastCommitInfo) ? e.CommitInfo.fromJSON(a.lastCommitInfo) : void 0,
        byzantineValidators: Array.isArray(a == null ? void 0 : a.byzantineValidators) ? a.byzantineValidators.map((J) => e.Misbehavior.fromJSON(J)) : []
      };
    },
    toJSON(a) {
      const J = {};
      return a.hash !== void 0 && (J.hash = (0, T.base64FromBytes)(a.hash !== void 0 ? a.hash : new Uint8Array())), a.header !== void 0 && (J.header = a.header ? f.Header.toJSON(a.header) : void 0), a.lastCommitInfo !== void 0 && (J.lastCommitInfo = a.lastCommitInfo ? e.CommitInfo.toJSON(a.lastCommitInfo) : void 0), a.byzantineValidators ? J.byzantineValidators = a.byzantineValidators.map((H) => H ? e.Misbehavior.toJSON(H) : void 0) : J.byzantineValidators = [], J;
    },
    fromPartial(a) {
      var J;
      const H = k();
      return H.hash = a.hash ?? new Uint8Array(), H.header = a.header !== void 0 && a.header !== null ? f.Header.fromPartial(a.header) : void 0, H.lastCommitInfo = a.lastCommitInfo !== void 0 && a.lastCommitInfo !== null ? e.CommitInfo.fromPartial(a.lastCommitInfo) : void 0, H.byzantineValidators = ((J = a.byzantineValidators) == null ? void 0 : J.map((z) => e.Misbehavior.fromPartial(z))) || [], H;
    }
  };
  function O() {
    return {
      tx: new Uint8Array(),
      type: 0
    };
  }
  e.RequestCheckTx = {
    encode(a, J = V.Writer.create()) {
      return a.tx.length !== 0 && J.uint32(10).bytes(a.tx), a.type !== 0 && J.uint32(16).int32(a.type), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = O();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.tx = H.bytes();
            break;
          case 2:
            F.type = H.int32();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        tx: (0, T.isSet)(a.tx) ? (0, T.bytesFromBase64)(a.tx) : new Uint8Array(),
        type: (0, T.isSet)(a.type) ? B(a.type) : 0
      };
    },
    toJSON(a) {
      const J = {};
      return a.tx !== void 0 && (J.tx = (0, T.base64FromBytes)(a.tx !== void 0 ? a.tx : new Uint8Array())), a.type !== void 0 && (J.type = U(a.type)), J;
    },
    fromPartial(a) {
      const J = O();
      return J.tx = a.tx ?? new Uint8Array(), J.type = a.type ?? 0, J;
    }
  };
  function L() {
    return {
      tx: new Uint8Array()
    };
  }
  e.RequestDeliverTx = {
    encode(a, J = V.Writer.create()) {
      return a.tx.length !== 0 && J.uint32(10).bytes(a.tx), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = L();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.tx = H.bytes();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        tx: (0, T.isSet)(a.tx) ? (0, T.bytesFromBase64)(a.tx) : new Uint8Array()
      };
    },
    toJSON(a) {
      const J = {};
      return a.tx !== void 0 && (J.tx = (0, T.base64FromBytes)(a.tx !== void 0 ? a.tx : new Uint8Array())), J;
    },
    fromPartial(a) {
      const J = L();
      return J.tx = a.tx ?? new Uint8Array(), J;
    }
  };
  function Z() {
    return {
      height: T.Long.ZERO
    };
  }
  e.RequestEndBlock = {
    encode(a, J = V.Writer.create()) {
      return a.height.isZero() || J.uint32(8).int64(a.height), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = Z();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.height = H.int64();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        height: (0, T.isSet)(a.height) ? T.Long.fromValue(a.height) : T.Long.ZERO
      };
    },
    toJSON(a) {
      const J = {};
      return a.height !== void 0 && (J.height = (a.height || T.Long.ZERO).toString()), J;
    },
    fromPartial(a) {
      const J = Z();
      return J.height = a.height !== void 0 && a.height !== null ? T.Long.fromValue(a.height) : T.Long.ZERO, J;
    }
  };
  function j() {
    return {};
  }
  e.RequestCommit = {
    encode(a, J = V.Writer.create()) {
      return J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = j();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {};
    },
    toJSON(a) {
      return {};
    },
    fromPartial(a) {
      return j();
    }
  };
  function i() {
    return {};
  }
  e.RequestListSnapshots = {
    encode(a, J = V.Writer.create()) {
      return J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = i();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {};
    },
    toJSON(a) {
      return {};
    },
    fromPartial(a) {
      return i();
    }
  };
  function P() {
    return {
      snapshot: void 0,
      appHash: new Uint8Array()
    };
  }
  e.RequestOfferSnapshot = {
    encode(a, J = V.Writer.create()) {
      return a.snapshot !== void 0 && e.Snapshot.encode(a.snapshot, J.uint32(10).fork()).ldelim(), a.appHash.length !== 0 && J.uint32(18).bytes(a.appHash), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = P();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.snapshot = e.Snapshot.decode(H, H.uint32());
            break;
          case 2:
            F.appHash = H.bytes();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        snapshot: (0, T.isSet)(a.snapshot) ? e.Snapshot.fromJSON(a.snapshot) : void 0,
        appHash: (0, T.isSet)(a.appHash) ? (0, T.bytesFromBase64)(a.appHash) : new Uint8Array()
      };
    },
    toJSON(a) {
      const J = {};
      return a.snapshot !== void 0 && (J.snapshot = a.snapshot ? e.Snapshot.toJSON(a.snapshot) : void 0), a.appHash !== void 0 && (J.appHash = (0, T.base64FromBytes)(a.appHash !== void 0 ? a.appHash : new Uint8Array())), J;
    },
    fromPartial(a) {
      const J = P();
      return J.snapshot = a.snapshot !== void 0 && a.snapshot !== null ? e.Snapshot.fromPartial(a.snapshot) : void 0, J.appHash = a.appHash ?? new Uint8Array(), J;
    }
  };
  function g() {
    return {
      height: T.Long.UZERO,
      format: 0,
      chunk: 0
    };
  }
  e.RequestLoadSnapshotChunk = {
    encode(a, J = V.Writer.create()) {
      return a.height.isZero() || J.uint32(8).uint64(a.height), a.format !== 0 && J.uint32(16).uint32(a.format), a.chunk !== 0 && J.uint32(24).uint32(a.chunk), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = g();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.height = H.uint64();
            break;
          case 2:
            F.format = H.uint32();
            break;
          case 3:
            F.chunk = H.uint32();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        height: (0, T.isSet)(a.height) ? T.Long.fromValue(a.height) : T.Long.UZERO,
        format: (0, T.isSet)(a.format) ? Number(a.format) : 0,
        chunk: (0, T.isSet)(a.chunk) ? Number(a.chunk) : 0
      };
    },
    toJSON(a) {
      const J = {};
      return a.height !== void 0 && (J.height = (a.height || T.Long.UZERO).toString()), a.format !== void 0 && (J.format = Math.round(a.format)), a.chunk !== void 0 && (J.chunk = Math.round(a.chunk)), J;
    },
    fromPartial(a) {
      const J = g();
      return J.height = a.height !== void 0 && a.height !== null ? T.Long.fromValue(a.height) : T.Long.UZERO, J.format = a.format ?? 0, J.chunk = a.chunk ?? 0, J;
    }
  };
  function v() {
    return {
      index: 0,
      chunk: new Uint8Array(),
      sender: ""
    };
  }
  e.RequestApplySnapshotChunk = {
    encode(a, J = V.Writer.create()) {
      return a.index !== 0 && J.uint32(8).uint32(a.index), a.chunk.length !== 0 && J.uint32(18).bytes(a.chunk), a.sender !== "" && J.uint32(26).string(a.sender), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = v();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.index = H.uint32();
            break;
          case 2:
            F.chunk = H.bytes();
            break;
          case 3:
            F.sender = H.string();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        index: (0, T.isSet)(a.index) ? Number(a.index) : 0,
        chunk: (0, T.isSet)(a.chunk) ? (0, T.bytesFromBase64)(a.chunk) : new Uint8Array(),
        sender: (0, T.isSet)(a.sender) ? String(a.sender) : ""
      };
    },
    toJSON(a) {
      const J = {};
      return a.index !== void 0 && (J.index = Math.round(a.index)), a.chunk !== void 0 && (J.chunk = (0, T.base64FromBytes)(a.chunk !== void 0 ? a.chunk : new Uint8Array())), a.sender !== void 0 && (J.sender = a.sender), J;
    },
    fromPartial(a) {
      const J = v();
      return J.index = a.index ?? 0, J.chunk = a.chunk ?? new Uint8Array(), J.sender = a.sender ?? "", J;
    }
  };
  function N() {
    return {
      maxTxBytes: T.Long.ZERO,
      txs: [],
      localLastCommit: void 0,
      misbehavior: [],
      height: T.Long.ZERO,
      time: void 0,
      nextValidatorsHash: new Uint8Array(),
      proposerAddress: new Uint8Array()
    };
  }
  e.RequestPrepareProposal = {
    encode(a, J = V.Writer.create()) {
      a.maxTxBytes.isZero() || J.uint32(8).int64(a.maxTxBytes);
      for (const H of a.txs)
        J.uint32(18).bytes(H);
      a.localLastCommit !== void 0 && e.ExtendedCommitInfo.encode(a.localLastCommit, J.uint32(26).fork()).ldelim();
      for (const H of a.misbehavior)
        e.Misbehavior.encode(H, J.uint32(34).fork()).ldelim();
      return a.height.isZero() || J.uint32(40).int64(a.height), a.time !== void 0 && r.Timestamp.encode(a.time, J.uint32(50).fork()).ldelim(), a.nextValidatorsHash.length !== 0 && J.uint32(58).bytes(a.nextValidatorsHash), a.proposerAddress.length !== 0 && J.uint32(66).bytes(a.proposerAddress), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = N();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.maxTxBytes = H.int64();
            break;
          case 2:
            F.txs.push(H.bytes());
            break;
          case 3:
            F.localLastCommit = e.ExtendedCommitInfo.decode(H, H.uint32());
            break;
          case 4:
            F.misbehavior.push(e.Misbehavior.decode(H, H.uint32()));
            break;
          case 5:
            F.height = H.int64();
            break;
          case 6:
            F.time = r.Timestamp.decode(H, H.uint32());
            break;
          case 7:
            F.nextValidatorsHash = H.bytes();
            break;
          case 8:
            F.proposerAddress = H.bytes();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        maxTxBytes: (0, T.isSet)(a.maxTxBytes) ? T.Long.fromValue(a.maxTxBytes) : T.Long.ZERO,
        txs: Array.isArray(a == null ? void 0 : a.txs) ? a.txs.map((J) => (0, T.bytesFromBase64)(J)) : [],
        localLastCommit: (0, T.isSet)(a.localLastCommit) ? e.ExtendedCommitInfo.fromJSON(a.localLastCommit) : void 0,
        misbehavior: Array.isArray(a == null ? void 0 : a.misbehavior) ? a.misbehavior.map((J) => e.Misbehavior.fromJSON(J)) : [],
        height: (0, T.isSet)(a.height) ? T.Long.fromValue(a.height) : T.Long.ZERO,
        time: (0, T.isSet)(a.time) ? (0, T.fromJsonTimestamp)(a.time) : void 0,
        nextValidatorsHash: (0, T.isSet)(a.nextValidatorsHash) ? (0, T.bytesFromBase64)(a.nextValidatorsHash) : new Uint8Array(),
        proposerAddress: (0, T.isSet)(a.proposerAddress) ? (0, T.bytesFromBase64)(a.proposerAddress) : new Uint8Array()
      };
    },
    toJSON(a) {
      const J = {};
      return a.maxTxBytes !== void 0 && (J.maxTxBytes = (a.maxTxBytes || T.Long.ZERO).toString()), a.txs ? J.txs = a.txs.map((H) => (0, T.base64FromBytes)(H !== void 0 ? H : new Uint8Array())) : J.txs = [], a.localLastCommit !== void 0 && (J.localLastCommit = a.localLastCommit ? e.ExtendedCommitInfo.toJSON(a.localLastCommit) : void 0), a.misbehavior ? J.misbehavior = a.misbehavior.map((H) => H ? e.Misbehavior.toJSON(H) : void 0) : J.misbehavior = [], a.height !== void 0 && (J.height = (a.height || T.Long.ZERO).toString()), a.time !== void 0 && (J.time = (0, T.fromTimestamp)(a.time).toISOString()), a.nextValidatorsHash !== void 0 && (J.nextValidatorsHash = (0, T.base64FromBytes)(a.nextValidatorsHash !== void 0 ? a.nextValidatorsHash : new Uint8Array())), a.proposerAddress !== void 0 && (J.proposerAddress = (0, T.base64FromBytes)(a.proposerAddress !== void 0 ? a.proposerAddress : new Uint8Array())), J;
    },
    fromPartial(a) {
      var J, H;
      const z = N();
      return z.maxTxBytes = a.maxTxBytes !== void 0 && a.maxTxBytes !== null ? T.Long.fromValue(a.maxTxBytes) : T.Long.ZERO, z.txs = ((J = a.txs) == null ? void 0 : J.map((F) => F)) || [], z.localLastCommit = a.localLastCommit !== void 0 && a.localLastCommit !== null ? e.ExtendedCommitInfo.fromPartial(a.localLastCommit) : void 0, z.misbehavior = ((H = a.misbehavior) == null ? void 0 : H.map((F) => e.Misbehavior.fromPartial(F))) || [], z.height = a.height !== void 0 && a.height !== null ? T.Long.fromValue(a.height) : T.Long.ZERO, z.time = a.time !== void 0 && a.time !== null ? r.Timestamp.fromPartial(a.time) : void 0, z.nextValidatorsHash = a.nextValidatorsHash ?? new Uint8Array(), z.proposerAddress = a.proposerAddress ?? new Uint8Array(), z;
    }
  };
  function q() {
    return {
      txs: [],
      proposedLastCommit: void 0,
      misbehavior: [],
      hash: new Uint8Array(),
      height: T.Long.ZERO,
      time: void 0,
      nextValidatorsHash: new Uint8Array(),
      proposerAddress: new Uint8Array()
    };
  }
  e.RequestProcessProposal = {
    encode(a, J = V.Writer.create()) {
      for (const H of a.txs)
        J.uint32(10).bytes(H);
      a.proposedLastCommit !== void 0 && e.CommitInfo.encode(a.proposedLastCommit, J.uint32(18).fork()).ldelim();
      for (const H of a.misbehavior)
        e.Misbehavior.encode(H, J.uint32(26).fork()).ldelim();
      return a.hash.length !== 0 && J.uint32(34).bytes(a.hash), a.height.isZero() || J.uint32(40).int64(a.height), a.time !== void 0 && r.Timestamp.encode(a.time, J.uint32(50).fork()).ldelim(), a.nextValidatorsHash.length !== 0 && J.uint32(58).bytes(a.nextValidatorsHash), a.proposerAddress.length !== 0 && J.uint32(66).bytes(a.proposerAddress), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = q();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.txs.push(H.bytes());
            break;
          case 2:
            F.proposedLastCommit = e.CommitInfo.decode(H, H.uint32());
            break;
          case 3:
            F.misbehavior.push(e.Misbehavior.decode(H, H.uint32()));
            break;
          case 4:
            F.hash = H.bytes();
            break;
          case 5:
            F.height = H.int64();
            break;
          case 6:
            F.time = r.Timestamp.decode(H, H.uint32());
            break;
          case 7:
            F.nextValidatorsHash = H.bytes();
            break;
          case 8:
            F.proposerAddress = H.bytes();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        txs: Array.isArray(a == null ? void 0 : a.txs) ? a.txs.map((J) => (0, T.bytesFromBase64)(J)) : [],
        proposedLastCommit: (0, T.isSet)(a.proposedLastCommit) ? e.CommitInfo.fromJSON(a.proposedLastCommit) : void 0,
        misbehavior: Array.isArray(a == null ? void 0 : a.misbehavior) ? a.misbehavior.map((J) => e.Misbehavior.fromJSON(J)) : [],
        hash: (0, T.isSet)(a.hash) ? (0, T.bytesFromBase64)(a.hash) : new Uint8Array(),
        height: (0, T.isSet)(a.height) ? T.Long.fromValue(a.height) : T.Long.ZERO,
        time: (0, T.isSet)(a.time) ? (0, T.fromJsonTimestamp)(a.time) : void 0,
        nextValidatorsHash: (0, T.isSet)(a.nextValidatorsHash) ? (0, T.bytesFromBase64)(a.nextValidatorsHash) : new Uint8Array(),
        proposerAddress: (0, T.isSet)(a.proposerAddress) ? (0, T.bytesFromBase64)(a.proposerAddress) : new Uint8Array()
      };
    },
    toJSON(a) {
      const J = {};
      return a.txs ? J.txs = a.txs.map((H) => (0, T.base64FromBytes)(H !== void 0 ? H : new Uint8Array())) : J.txs = [], a.proposedLastCommit !== void 0 && (J.proposedLastCommit = a.proposedLastCommit ? e.CommitInfo.toJSON(a.proposedLastCommit) : void 0), a.misbehavior ? J.misbehavior = a.misbehavior.map((H) => H ? e.Misbehavior.toJSON(H) : void 0) : J.misbehavior = [], a.hash !== void 0 && (J.hash = (0, T.base64FromBytes)(a.hash !== void 0 ? a.hash : new Uint8Array())), a.height !== void 0 && (J.height = (a.height || T.Long.ZERO).toString()), a.time !== void 0 && (J.time = (0, T.fromTimestamp)(a.time).toISOString()), a.nextValidatorsHash !== void 0 && (J.nextValidatorsHash = (0, T.base64FromBytes)(a.nextValidatorsHash !== void 0 ? a.nextValidatorsHash : new Uint8Array())), a.proposerAddress !== void 0 && (J.proposerAddress = (0, T.base64FromBytes)(a.proposerAddress !== void 0 ? a.proposerAddress : new Uint8Array())), J;
    },
    fromPartial(a) {
      var J, H;
      const z = q();
      return z.txs = ((J = a.txs) == null ? void 0 : J.map((F) => F)) || [], z.proposedLastCommit = a.proposedLastCommit !== void 0 && a.proposedLastCommit !== null ? e.CommitInfo.fromPartial(a.proposedLastCommit) : void 0, z.misbehavior = ((H = a.misbehavior) == null ? void 0 : H.map((F) => e.Misbehavior.fromPartial(F))) || [], z.hash = a.hash ?? new Uint8Array(), z.height = a.height !== void 0 && a.height !== null ? T.Long.fromValue(a.height) : T.Long.ZERO, z.time = a.time !== void 0 && a.time !== null ? r.Timestamp.fromPartial(a.time) : void 0, z.nextValidatorsHash = a.nextValidatorsHash ?? new Uint8Array(), z.proposerAddress = a.proposerAddress ?? new Uint8Array(), z;
    }
  };
  function G() {
    return {
      exception: void 0,
      echo: void 0,
      flush: void 0,
      info: void 0,
      initChain: void 0,
      query: void 0,
      beginBlock: void 0,
      checkTx: void 0,
      deliverTx: void 0,
      endBlock: void 0,
      commit: void 0,
      listSnapshots: void 0,
      offerSnapshot: void 0,
      loadSnapshotChunk: void 0,
      applySnapshotChunk: void 0,
      prepareProposal: void 0,
      processProposal: void 0
    };
  }
  e.Response = {
    encode(a, J = V.Writer.create()) {
      return a.exception !== void 0 && e.ResponseException.encode(a.exception, J.uint32(10).fork()).ldelim(), a.echo !== void 0 && e.ResponseEcho.encode(a.echo, J.uint32(18).fork()).ldelim(), a.flush !== void 0 && e.ResponseFlush.encode(a.flush, J.uint32(26).fork()).ldelim(), a.info !== void 0 && e.ResponseInfo.encode(a.info, J.uint32(34).fork()).ldelim(), a.initChain !== void 0 && e.ResponseInitChain.encode(a.initChain, J.uint32(50).fork()).ldelim(), a.query !== void 0 && e.ResponseQuery.encode(a.query, J.uint32(58).fork()).ldelim(), a.beginBlock !== void 0 && e.ResponseBeginBlock.encode(a.beginBlock, J.uint32(66).fork()).ldelim(), a.checkTx !== void 0 && e.ResponseCheckTx.encode(a.checkTx, J.uint32(74).fork()).ldelim(), a.deliverTx !== void 0 && e.ResponseDeliverTx.encode(a.deliverTx, J.uint32(82).fork()).ldelim(), a.endBlock !== void 0 && e.ResponseEndBlock.encode(a.endBlock, J.uint32(90).fork()).ldelim(), a.commit !== void 0 && e.ResponseCommit.encode(a.commit, J.uint32(98).fork()).ldelim(), a.listSnapshots !== void 0 && e.ResponseListSnapshots.encode(a.listSnapshots, J.uint32(106).fork()).ldelim(), a.offerSnapshot !== void 0 && e.ResponseOfferSnapshot.encode(a.offerSnapshot, J.uint32(114).fork()).ldelim(), a.loadSnapshotChunk !== void 0 && e.ResponseLoadSnapshotChunk.encode(a.loadSnapshotChunk, J.uint32(122).fork()).ldelim(), a.applySnapshotChunk !== void 0 && e.ResponseApplySnapshotChunk.encode(a.applySnapshotChunk, J.uint32(130).fork()).ldelim(), a.prepareProposal !== void 0 && e.ResponsePrepareProposal.encode(a.prepareProposal, J.uint32(138).fork()).ldelim(), a.processProposal !== void 0 && e.ResponseProcessProposal.encode(a.processProposal, J.uint32(146).fork()).ldelim(), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = G();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.exception = e.ResponseException.decode(H, H.uint32());
            break;
          case 2:
            F.echo = e.ResponseEcho.decode(H, H.uint32());
            break;
          case 3:
            F.flush = e.ResponseFlush.decode(H, H.uint32());
            break;
          case 4:
            F.info = e.ResponseInfo.decode(H, H.uint32());
            break;
          case 6:
            F.initChain = e.ResponseInitChain.decode(H, H.uint32());
            break;
          case 7:
            F.query = e.ResponseQuery.decode(H, H.uint32());
            break;
          case 8:
            F.beginBlock = e.ResponseBeginBlock.decode(H, H.uint32());
            break;
          case 9:
            F.checkTx = e.ResponseCheckTx.decode(H, H.uint32());
            break;
          case 10:
            F.deliverTx = e.ResponseDeliverTx.decode(H, H.uint32());
            break;
          case 11:
            F.endBlock = e.ResponseEndBlock.decode(H, H.uint32());
            break;
          case 12:
            F.commit = e.ResponseCommit.decode(H, H.uint32());
            break;
          case 13:
            F.listSnapshots = e.ResponseListSnapshots.decode(H, H.uint32());
            break;
          case 14:
            F.offerSnapshot = e.ResponseOfferSnapshot.decode(H, H.uint32());
            break;
          case 15:
            F.loadSnapshotChunk = e.ResponseLoadSnapshotChunk.decode(H, H.uint32());
            break;
          case 16:
            F.applySnapshotChunk = e.ResponseApplySnapshotChunk.decode(H, H.uint32());
            break;
          case 17:
            F.prepareProposal = e.ResponsePrepareProposal.decode(H, H.uint32());
            break;
          case 18:
            F.processProposal = e.ResponseProcessProposal.decode(H, H.uint32());
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        exception: (0, T.isSet)(a.exception) ? e.ResponseException.fromJSON(a.exception) : void 0,
        echo: (0, T.isSet)(a.echo) ? e.ResponseEcho.fromJSON(a.echo) : void 0,
        flush: (0, T.isSet)(a.flush) ? e.ResponseFlush.fromJSON(a.flush) : void 0,
        info: (0, T.isSet)(a.info) ? e.ResponseInfo.fromJSON(a.info) : void 0,
        initChain: (0, T.isSet)(a.initChain) ? e.ResponseInitChain.fromJSON(a.initChain) : void 0,
        query: (0, T.isSet)(a.query) ? e.ResponseQuery.fromJSON(a.query) : void 0,
        beginBlock: (0, T.isSet)(a.beginBlock) ? e.ResponseBeginBlock.fromJSON(a.beginBlock) : void 0,
        checkTx: (0, T.isSet)(a.checkTx) ? e.ResponseCheckTx.fromJSON(a.checkTx) : void 0,
        deliverTx: (0, T.isSet)(a.deliverTx) ? e.ResponseDeliverTx.fromJSON(a.deliverTx) : void 0,
        endBlock: (0, T.isSet)(a.endBlock) ? e.ResponseEndBlock.fromJSON(a.endBlock) : void 0,
        commit: (0, T.isSet)(a.commit) ? e.ResponseCommit.fromJSON(a.commit) : void 0,
        listSnapshots: (0, T.isSet)(a.listSnapshots) ? e.ResponseListSnapshots.fromJSON(a.listSnapshots) : void 0,
        offerSnapshot: (0, T.isSet)(a.offerSnapshot) ? e.ResponseOfferSnapshot.fromJSON(a.offerSnapshot) : void 0,
        loadSnapshotChunk: (0, T.isSet)(a.loadSnapshotChunk) ? e.ResponseLoadSnapshotChunk.fromJSON(a.loadSnapshotChunk) : void 0,
        applySnapshotChunk: (0, T.isSet)(a.applySnapshotChunk) ? e.ResponseApplySnapshotChunk.fromJSON(a.applySnapshotChunk) : void 0,
        prepareProposal: (0, T.isSet)(a.prepareProposal) ? e.ResponsePrepareProposal.fromJSON(a.prepareProposal) : void 0,
        processProposal: (0, T.isSet)(a.processProposal) ? e.ResponseProcessProposal.fromJSON(a.processProposal) : void 0
      };
    },
    toJSON(a) {
      const J = {};
      return a.exception !== void 0 && (J.exception = a.exception ? e.ResponseException.toJSON(a.exception) : void 0), a.echo !== void 0 && (J.echo = a.echo ? e.ResponseEcho.toJSON(a.echo) : void 0), a.flush !== void 0 && (J.flush = a.flush ? e.ResponseFlush.toJSON(a.flush) : void 0), a.info !== void 0 && (J.info = a.info ? e.ResponseInfo.toJSON(a.info) : void 0), a.initChain !== void 0 && (J.initChain = a.initChain ? e.ResponseInitChain.toJSON(a.initChain) : void 0), a.query !== void 0 && (J.query = a.query ? e.ResponseQuery.toJSON(a.query) : void 0), a.beginBlock !== void 0 && (J.beginBlock = a.beginBlock ? e.ResponseBeginBlock.toJSON(a.beginBlock) : void 0), a.checkTx !== void 0 && (J.checkTx = a.checkTx ? e.ResponseCheckTx.toJSON(a.checkTx) : void 0), a.deliverTx !== void 0 && (J.deliverTx = a.deliverTx ? e.ResponseDeliverTx.toJSON(a.deliverTx) : void 0), a.endBlock !== void 0 && (J.endBlock = a.endBlock ? e.ResponseEndBlock.toJSON(a.endBlock) : void 0), a.commit !== void 0 && (J.commit = a.commit ? e.ResponseCommit.toJSON(a.commit) : void 0), a.listSnapshots !== void 0 && (J.listSnapshots = a.listSnapshots ? e.ResponseListSnapshots.toJSON(a.listSnapshots) : void 0), a.offerSnapshot !== void 0 && (J.offerSnapshot = a.offerSnapshot ? e.ResponseOfferSnapshot.toJSON(a.offerSnapshot) : void 0), a.loadSnapshotChunk !== void 0 && (J.loadSnapshotChunk = a.loadSnapshotChunk ? e.ResponseLoadSnapshotChunk.toJSON(a.loadSnapshotChunk) : void 0), a.applySnapshotChunk !== void 0 && (J.applySnapshotChunk = a.applySnapshotChunk ? e.ResponseApplySnapshotChunk.toJSON(a.applySnapshotChunk) : void 0), a.prepareProposal !== void 0 && (J.prepareProposal = a.prepareProposal ? e.ResponsePrepareProposal.toJSON(a.prepareProposal) : void 0), a.processProposal !== void 0 && (J.processProposal = a.processProposal ? e.ResponseProcessProposal.toJSON(a.processProposal) : void 0), J;
    },
    fromPartial(a) {
      const J = G();
      return J.exception = a.exception !== void 0 && a.exception !== null ? e.ResponseException.fromPartial(a.exception) : void 0, J.echo = a.echo !== void 0 && a.echo !== null ? e.ResponseEcho.fromPartial(a.echo) : void 0, J.flush = a.flush !== void 0 && a.flush !== null ? e.ResponseFlush.fromPartial(a.flush) : void 0, J.info = a.info !== void 0 && a.info !== null ? e.ResponseInfo.fromPartial(a.info) : void 0, J.initChain = a.initChain !== void 0 && a.initChain !== null ? e.ResponseInitChain.fromPartial(a.initChain) : void 0, J.query = a.query !== void 0 && a.query !== null ? e.ResponseQuery.fromPartial(a.query) : void 0, J.beginBlock = a.beginBlock !== void 0 && a.beginBlock !== null ? e.ResponseBeginBlock.fromPartial(a.beginBlock) : void 0, J.checkTx = a.checkTx !== void 0 && a.checkTx !== null ? e.ResponseCheckTx.fromPartial(a.checkTx) : void 0, J.deliverTx = a.deliverTx !== void 0 && a.deliverTx !== null ? e.ResponseDeliverTx.fromPartial(a.deliverTx) : void 0, J.endBlock = a.endBlock !== void 0 && a.endBlock !== null ? e.ResponseEndBlock.fromPartial(a.endBlock) : void 0, J.commit = a.commit !== void 0 && a.commit !== null ? e.ResponseCommit.fromPartial(a.commit) : void 0, J.listSnapshots = a.listSnapshots !== void 0 && a.listSnapshots !== null ? e.ResponseListSnapshots.fromPartial(a.listSnapshots) : void 0, J.offerSnapshot = a.offerSnapshot !== void 0 && a.offerSnapshot !== null ? e.ResponseOfferSnapshot.fromPartial(a.offerSnapshot) : void 0, J.loadSnapshotChunk = a.loadSnapshotChunk !== void 0 && a.loadSnapshotChunk !== null ? e.ResponseLoadSnapshotChunk.fromPartial(a.loadSnapshotChunk) : void 0, J.applySnapshotChunk = a.applySnapshotChunk !== void 0 && a.applySnapshotChunk !== null ? e.ResponseApplySnapshotChunk.fromPartial(a.applySnapshotChunk) : void 0, J.prepareProposal = a.prepareProposal !== void 0 && a.prepareProposal !== null ? e.ResponsePrepareProposal.fromPartial(a.prepareProposal) : void 0, J.processProposal = a.processProposal !== void 0 && a.processProposal !== null ? e.ResponseProcessProposal.fromPartial(a.processProposal) : void 0, J;
    }
  };
  function K() {
    return {
      error: ""
    };
  }
  e.ResponseException = {
    encode(a, J = V.Writer.create()) {
      return a.error !== "" && J.uint32(10).string(a.error), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = K();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.error = H.string();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        error: (0, T.isSet)(a.error) ? String(a.error) : ""
      };
    },
    toJSON(a) {
      const J = {};
      return a.error !== void 0 && (J.error = a.error), J;
    },
    fromPartial(a) {
      const J = K();
      return J.error = a.error ?? "", J;
    }
  };
  function oe() {
    return {
      message: ""
    };
  }
  e.ResponseEcho = {
    encode(a, J = V.Writer.create()) {
      return a.message !== "" && J.uint32(10).string(a.message), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = oe();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.message = H.string();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        message: (0, T.isSet)(a.message) ? String(a.message) : ""
      };
    },
    toJSON(a) {
      const J = {};
      return a.message !== void 0 && (J.message = a.message), J;
    },
    fromPartial(a) {
      const J = oe();
      return J.message = a.message ?? "", J;
    }
  };
  function Ps() {
    return {};
  }
  e.ResponseFlush = {
    encode(a, J = V.Writer.create()) {
      return J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = Ps();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {};
    },
    toJSON(a) {
      return {};
    },
    fromPartial(a) {
      return Ps();
    }
  };
  function Rs() {
    return {
      data: "",
      version: "",
      appVersion: T.Long.UZERO,
      lastBlockHeight: T.Long.ZERO,
      lastBlockAppHash: new Uint8Array()
    };
  }
  e.ResponseInfo = {
    encode(a, J = V.Writer.create()) {
      return a.data !== "" && J.uint32(10).string(a.data), a.version !== "" && J.uint32(18).string(a.version), a.appVersion.isZero() || J.uint32(24).uint64(a.appVersion), a.lastBlockHeight.isZero() || J.uint32(32).int64(a.lastBlockHeight), a.lastBlockAppHash.length !== 0 && J.uint32(42).bytes(a.lastBlockAppHash), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = Rs();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.data = H.string();
            break;
          case 2:
            F.version = H.string();
            break;
          case 3:
            F.appVersion = H.uint64();
            break;
          case 4:
            F.lastBlockHeight = H.int64();
            break;
          case 5:
            F.lastBlockAppHash = H.bytes();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        data: (0, T.isSet)(a.data) ? String(a.data) : "",
        version: (0, T.isSet)(a.version) ? String(a.version) : "",
        appVersion: (0, T.isSet)(a.appVersion) ? T.Long.fromValue(a.appVersion) : T.Long.UZERO,
        lastBlockHeight: (0, T.isSet)(a.lastBlockHeight) ? T.Long.fromValue(a.lastBlockHeight) : T.Long.ZERO,
        lastBlockAppHash: (0, T.isSet)(a.lastBlockAppHash) ? (0, T.bytesFromBase64)(a.lastBlockAppHash) : new Uint8Array()
      };
    },
    toJSON(a) {
      const J = {};
      return a.data !== void 0 && (J.data = a.data), a.version !== void 0 && (J.version = a.version), a.appVersion !== void 0 && (J.appVersion = (a.appVersion || T.Long.UZERO).toString()), a.lastBlockHeight !== void 0 && (J.lastBlockHeight = (a.lastBlockHeight || T.Long.ZERO).toString()), a.lastBlockAppHash !== void 0 && (J.lastBlockAppHash = (0, T.base64FromBytes)(a.lastBlockAppHash !== void 0 ? a.lastBlockAppHash : new Uint8Array())), J;
    },
    fromPartial(a) {
      const J = Rs();
      return J.data = a.data ?? "", J.version = a.version ?? "", J.appVersion = a.appVersion !== void 0 && a.appVersion !== null ? T.Long.fromValue(a.appVersion) : T.Long.UZERO, J.lastBlockHeight = a.lastBlockHeight !== void 0 && a.lastBlockHeight !== null ? T.Long.fromValue(a.lastBlockHeight) : T.Long.ZERO, J.lastBlockAppHash = a.lastBlockAppHash ?? new Uint8Array(), J;
    }
  };
  function As() {
    return {
      consensusParams: void 0,
      validators: [],
      appHash: new Uint8Array()
    };
  }
  e.ResponseInitChain = {
    encode(a, J = V.Writer.create()) {
      a.consensusParams !== void 0 && m.ConsensusParams.encode(a.consensusParams, J.uint32(10).fork()).ldelim();
      for (const H of a.validators)
        e.ValidatorUpdate.encode(H, J.uint32(18).fork()).ldelim();
      return a.appHash.length !== 0 && J.uint32(26).bytes(a.appHash), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = As();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.consensusParams = m.ConsensusParams.decode(H, H.uint32());
            break;
          case 2:
            F.validators.push(e.ValidatorUpdate.decode(H, H.uint32()));
            break;
          case 3:
            F.appHash = H.bytes();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        consensusParams: (0, T.isSet)(a.consensusParams) ? m.ConsensusParams.fromJSON(a.consensusParams) : void 0,
        validators: Array.isArray(a == null ? void 0 : a.validators) ? a.validators.map((J) => e.ValidatorUpdate.fromJSON(J)) : [],
        appHash: (0, T.isSet)(a.appHash) ? (0, T.bytesFromBase64)(a.appHash) : new Uint8Array()
      };
    },
    toJSON(a) {
      const J = {};
      return a.consensusParams !== void 0 && (J.consensusParams = a.consensusParams ? m.ConsensusParams.toJSON(a.consensusParams) : void 0), a.validators ? J.validators = a.validators.map((H) => H ? e.ValidatorUpdate.toJSON(H) : void 0) : J.validators = [], a.appHash !== void 0 && (J.appHash = (0, T.base64FromBytes)(a.appHash !== void 0 ? a.appHash : new Uint8Array())), J;
    },
    fromPartial(a) {
      var J;
      const H = As();
      return H.consensusParams = a.consensusParams !== void 0 && a.consensusParams !== null ? m.ConsensusParams.fromPartial(a.consensusParams) : void 0, H.validators = ((J = a.validators) == null ? void 0 : J.map((z) => e.ValidatorUpdate.fromPartial(z))) || [], H.appHash = a.appHash ?? new Uint8Array(), H;
    }
  };
  function ws() {
    return {
      code: 0,
      log: "",
      info: "",
      index: T.Long.ZERO,
      key: new Uint8Array(),
      value: new Uint8Array(),
      proofOps: void 0,
      height: T.Long.ZERO,
      codespace: ""
    };
  }
  e.ResponseQuery = {
    encode(a, J = V.Writer.create()) {
      return a.code !== 0 && J.uint32(8).uint32(a.code), a.log !== "" && J.uint32(26).string(a.log), a.info !== "" && J.uint32(34).string(a.info), a.index.isZero() || J.uint32(40).int64(a.index), a.key.length !== 0 && J.uint32(50).bytes(a.key), a.value.length !== 0 && J.uint32(58).bytes(a.value), a.proofOps !== void 0 && b.ProofOps.encode(a.proofOps, J.uint32(66).fork()).ldelim(), a.height.isZero() || J.uint32(72).int64(a.height), a.codespace !== "" && J.uint32(82).string(a.codespace), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = ws();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.code = H.uint32();
            break;
          case 3:
            F.log = H.string();
            break;
          case 4:
            F.info = H.string();
            break;
          case 5:
            F.index = H.int64();
            break;
          case 6:
            F.key = H.bytes();
            break;
          case 7:
            F.value = H.bytes();
            break;
          case 8:
            F.proofOps = b.ProofOps.decode(H, H.uint32());
            break;
          case 9:
            F.height = H.int64();
            break;
          case 10:
            F.codespace = H.string();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        code: (0, T.isSet)(a.code) ? Number(a.code) : 0,
        log: (0, T.isSet)(a.log) ? String(a.log) : "",
        info: (0, T.isSet)(a.info) ? String(a.info) : "",
        index: (0, T.isSet)(a.index) ? T.Long.fromValue(a.index) : T.Long.ZERO,
        key: (0, T.isSet)(a.key) ? (0, T.bytesFromBase64)(a.key) : new Uint8Array(),
        value: (0, T.isSet)(a.value) ? (0, T.bytesFromBase64)(a.value) : new Uint8Array(),
        proofOps: (0, T.isSet)(a.proofOps) ? b.ProofOps.fromJSON(a.proofOps) : void 0,
        height: (0, T.isSet)(a.height) ? T.Long.fromValue(a.height) : T.Long.ZERO,
        codespace: (0, T.isSet)(a.codespace) ? String(a.codespace) : ""
      };
    },
    toJSON(a) {
      const J = {};
      return a.code !== void 0 && (J.code = Math.round(a.code)), a.log !== void 0 && (J.log = a.log), a.info !== void 0 && (J.info = a.info), a.index !== void 0 && (J.index = (a.index || T.Long.ZERO).toString()), a.key !== void 0 && (J.key = (0, T.base64FromBytes)(a.key !== void 0 ? a.key : new Uint8Array())), a.value !== void 0 && (J.value = (0, T.base64FromBytes)(a.value !== void 0 ? a.value : new Uint8Array())), a.proofOps !== void 0 && (J.proofOps = a.proofOps ? b.ProofOps.toJSON(a.proofOps) : void 0), a.height !== void 0 && (J.height = (a.height || T.Long.ZERO).toString()), a.codespace !== void 0 && (J.codespace = a.codespace), J;
    },
    fromPartial(a) {
      const J = ws();
      return J.code = a.code ?? 0, J.log = a.log ?? "", J.info = a.info ?? "", J.index = a.index !== void 0 && a.index !== null ? T.Long.fromValue(a.index) : T.Long.ZERO, J.key = a.key ?? new Uint8Array(), J.value = a.value ?? new Uint8Array(), J.proofOps = a.proofOps !== void 0 && a.proofOps !== null ? b.ProofOps.fromPartial(a.proofOps) : void 0, J.height = a.height !== void 0 && a.height !== null ? T.Long.fromValue(a.height) : T.Long.ZERO, J.codespace = a.codespace ?? "", J;
    }
  };
  function Ns() {
    return {
      events: []
    };
  }
  e.ResponseBeginBlock = {
    encode(a, J = V.Writer.create()) {
      for (const H of a.events)
        e.Event.encode(H, J.uint32(10).fork()).ldelim();
      return J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = Ns();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.events.push(e.Event.decode(H, H.uint32()));
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        events: Array.isArray(a == null ? void 0 : a.events) ? a.events.map((J) => e.Event.fromJSON(J)) : []
      };
    },
    toJSON(a) {
      const J = {};
      return a.events ? J.events = a.events.map((H) => H ? e.Event.toJSON(H) : void 0) : J.events = [], J;
    },
    fromPartial(a) {
      var J;
      const H = Ns();
      return H.events = ((J = a.events) == null ? void 0 : J.map((z) => e.Event.fromPartial(z))) || [], H;
    }
  };
  function Es() {
    return {
      code: 0,
      data: new Uint8Array(),
      log: "",
      info: "",
      gasWanted: T.Long.ZERO,
      gasUsed: T.Long.ZERO,
      events: [],
      codespace: "",
      sender: "",
      priority: T.Long.ZERO,
      mempoolError: ""
    };
  }
  e.ResponseCheckTx = {
    encode(a, J = V.Writer.create()) {
      a.code !== 0 && J.uint32(8).uint32(a.code), a.data.length !== 0 && J.uint32(18).bytes(a.data), a.log !== "" && J.uint32(26).string(a.log), a.info !== "" && J.uint32(34).string(a.info), a.gasWanted.isZero() || J.uint32(40).int64(a.gasWanted), a.gasUsed.isZero() || J.uint32(48).int64(a.gasUsed);
      for (const H of a.events)
        e.Event.encode(H, J.uint32(58).fork()).ldelim();
      return a.codespace !== "" && J.uint32(66).string(a.codespace), a.sender !== "" && J.uint32(74).string(a.sender), a.priority.isZero() || J.uint32(80).int64(a.priority), a.mempoolError !== "" && J.uint32(90).string(a.mempoolError), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = Es();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.code = H.uint32();
            break;
          case 2:
            F.data = H.bytes();
            break;
          case 3:
            F.log = H.string();
            break;
          case 4:
            F.info = H.string();
            break;
          case 5:
            F.gasWanted = H.int64();
            break;
          case 6:
            F.gasUsed = H.int64();
            break;
          case 7:
            F.events.push(e.Event.decode(H, H.uint32()));
            break;
          case 8:
            F.codespace = H.string();
            break;
          case 9:
            F.sender = H.string();
            break;
          case 10:
            F.priority = H.int64();
            break;
          case 11:
            F.mempoolError = H.string();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        code: (0, T.isSet)(a.code) ? Number(a.code) : 0,
        data: (0, T.isSet)(a.data) ? (0, T.bytesFromBase64)(a.data) : new Uint8Array(),
        log: (0, T.isSet)(a.log) ? String(a.log) : "",
        info: (0, T.isSet)(a.info) ? String(a.info) : "",
        gasWanted: (0, T.isSet)(a.gas_wanted) ? T.Long.fromValue(a.gas_wanted) : T.Long.ZERO,
        gasUsed: (0, T.isSet)(a.gas_used) ? T.Long.fromValue(a.gas_used) : T.Long.ZERO,
        events: Array.isArray(a == null ? void 0 : a.events) ? a.events.map((J) => e.Event.fromJSON(J)) : [],
        codespace: (0, T.isSet)(a.codespace) ? String(a.codespace) : "",
        sender: (0, T.isSet)(a.sender) ? String(a.sender) : "",
        priority: (0, T.isSet)(a.priority) ? T.Long.fromValue(a.priority) : T.Long.ZERO,
        mempoolError: (0, T.isSet)(a.mempoolError) ? String(a.mempoolError) : ""
      };
    },
    toJSON(a) {
      const J = {};
      return a.code !== void 0 && (J.code = Math.round(a.code)), a.data !== void 0 && (J.data = (0, T.base64FromBytes)(a.data !== void 0 ? a.data : new Uint8Array())), a.log !== void 0 && (J.log = a.log), a.info !== void 0 && (J.info = a.info), a.gasWanted !== void 0 && (J.gas_wanted = (a.gasWanted || T.Long.ZERO).toString()), a.gasUsed !== void 0 && (J.gas_used = (a.gasUsed || T.Long.ZERO).toString()), a.events ? J.events = a.events.map((H) => H ? e.Event.toJSON(H) : void 0) : J.events = [], a.codespace !== void 0 && (J.codespace = a.codespace), a.sender !== void 0 && (J.sender = a.sender), a.priority !== void 0 && (J.priority = (a.priority || T.Long.ZERO).toString()), a.mempoolError !== void 0 && (J.mempoolError = a.mempoolError), J;
    },
    fromPartial(a) {
      var J;
      const H = Es();
      return H.code = a.code ?? 0, H.data = a.data ?? new Uint8Array(), H.log = a.log ?? "", H.info = a.info ?? "", H.gasWanted = a.gasWanted !== void 0 && a.gasWanted !== null ? T.Long.fromValue(a.gasWanted) : T.Long.ZERO, H.gasUsed = a.gasUsed !== void 0 && a.gasUsed !== null ? T.Long.fromValue(a.gasUsed) : T.Long.ZERO, H.events = ((J = a.events) == null ? void 0 : J.map((z) => e.Event.fromPartial(z))) || [], H.codespace = a.codespace ?? "", H.sender = a.sender ?? "", H.priority = a.priority !== void 0 && a.priority !== null ? T.Long.fromValue(a.priority) : T.Long.ZERO, H.mempoolError = a.mempoolError ?? "", H;
    }
  };
  function Ts() {
    return {
      code: 0,
      data: new Uint8Array(),
      log: "",
      info: "",
      gasWanted: T.Long.ZERO,
      gasUsed: T.Long.ZERO,
      events: [],
      codespace: ""
    };
  }
  e.ResponseDeliverTx = {
    encode(a, J = V.Writer.create()) {
      a.code !== 0 && J.uint32(8).uint32(a.code), a.data.length !== 0 && J.uint32(18).bytes(a.data), a.log !== "" && J.uint32(26).string(a.log), a.info !== "" && J.uint32(34).string(a.info), a.gasWanted.isZero() || J.uint32(40).int64(a.gasWanted), a.gasUsed.isZero() || J.uint32(48).int64(a.gasUsed);
      for (const H of a.events)
        e.Event.encode(H, J.uint32(58).fork()).ldelim();
      return a.codespace !== "" && J.uint32(66).string(a.codespace), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = Ts();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.code = H.uint32();
            break;
          case 2:
            F.data = H.bytes();
            break;
          case 3:
            F.log = H.string();
            break;
          case 4:
            F.info = H.string();
            break;
          case 5:
            F.gasWanted = H.int64();
            break;
          case 6:
            F.gasUsed = H.int64();
            break;
          case 7:
            F.events.push(e.Event.decode(H, H.uint32()));
            break;
          case 8:
            F.codespace = H.string();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        code: (0, T.isSet)(a.code) ? Number(a.code) : 0,
        data: (0, T.isSet)(a.data) ? (0, T.bytesFromBase64)(a.data) : new Uint8Array(),
        log: (0, T.isSet)(a.log) ? String(a.log) : "",
        info: (0, T.isSet)(a.info) ? String(a.info) : "",
        gasWanted: (0, T.isSet)(a.gas_wanted) ? T.Long.fromValue(a.gas_wanted) : T.Long.ZERO,
        gasUsed: (0, T.isSet)(a.gas_used) ? T.Long.fromValue(a.gas_used) : T.Long.ZERO,
        events: Array.isArray(a == null ? void 0 : a.events) ? a.events.map((J) => e.Event.fromJSON(J)) : [],
        codespace: (0, T.isSet)(a.codespace) ? String(a.codespace) : ""
      };
    },
    toJSON(a) {
      const J = {};
      return a.code !== void 0 && (J.code = Math.round(a.code)), a.data !== void 0 && (J.data = (0, T.base64FromBytes)(a.data !== void 0 ? a.data : new Uint8Array())), a.log !== void 0 && (J.log = a.log), a.info !== void 0 && (J.info = a.info), a.gasWanted !== void 0 && (J.gas_wanted = (a.gasWanted || T.Long.ZERO).toString()), a.gasUsed !== void 0 && (J.gas_used = (a.gasUsed || T.Long.ZERO).toString()), a.events ? J.events = a.events.map((H) => H ? e.Event.toJSON(H) : void 0) : J.events = [], a.codespace !== void 0 && (J.codespace = a.codespace), J;
    },
    fromPartial(a) {
      var J;
      const H = Ts();
      return H.code = a.code ?? 0, H.data = a.data ?? new Uint8Array(), H.log = a.log ?? "", H.info = a.info ?? "", H.gasWanted = a.gasWanted !== void 0 && a.gasWanted !== null ? T.Long.fromValue(a.gasWanted) : T.Long.ZERO, H.gasUsed = a.gasUsed !== void 0 && a.gasUsed !== null ? T.Long.fromValue(a.gasUsed) : T.Long.ZERO, H.events = ((J = a.events) == null ? void 0 : J.map((z) => e.Event.fromPartial(z))) || [], H.codespace = a.codespace ?? "", H;
    }
  };
  function Cs() {
    return {
      validatorUpdates: [],
      consensusParamUpdates: void 0,
      events: []
    };
  }
  e.ResponseEndBlock = {
    encode(a, J = V.Writer.create()) {
      for (const H of a.validatorUpdates)
        e.ValidatorUpdate.encode(H, J.uint32(10).fork()).ldelim();
      a.consensusParamUpdates !== void 0 && m.ConsensusParams.encode(a.consensusParamUpdates, J.uint32(18).fork()).ldelim();
      for (const H of a.events)
        e.Event.encode(H, J.uint32(26).fork()).ldelim();
      return J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = Cs();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.validatorUpdates.push(e.ValidatorUpdate.decode(H, H.uint32()));
            break;
          case 2:
            F.consensusParamUpdates = m.ConsensusParams.decode(H, H.uint32());
            break;
          case 3:
            F.events.push(e.Event.decode(H, H.uint32()));
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        validatorUpdates: Array.isArray(a == null ? void 0 : a.validatorUpdates) ? a.validatorUpdates.map((J) => e.ValidatorUpdate.fromJSON(J)) : [],
        consensusParamUpdates: (0, T.isSet)(a.consensusParamUpdates) ? m.ConsensusParams.fromJSON(a.consensusParamUpdates) : void 0,
        events: Array.isArray(a == null ? void 0 : a.events) ? a.events.map((J) => e.Event.fromJSON(J)) : []
      };
    },
    toJSON(a) {
      const J = {};
      return a.validatorUpdates ? J.validatorUpdates = a.validatorUpdates.map((H) => H ? e.ValidatorUpdate.toJSON(H) : void 0) : J.validatorUpdates = [], a.consensusParamUpdates !== void 0 && (J.consensusParamUpdates = a.consensusParamUpdates ? m.ConsensusParams.toJSON(a.consensusParamUpdates) : void 0), a.events ? J.events = a.events.map((H) => H ? e.Event.toJSON(H) : void 0) : J.events = [], J;
    },
    fromPartial(a) {
      var J, H;
      const z = Cs();
      return z.validatorUpdates = ((J = a.validatorUpdates) == null ? void 0 : J.map((F) => e.ValidatorUpdate.fromPartial(F))) || [], z.consensusParamUpdates = a.consensusParamUpdates !== void 0 && a.consensusParamUpdates !== null ? m.ConsensusParams.fromPartial(a.consensusParamUpdates) : void 0, z.events = ((H = a.events) == null ? void 0 : H.map((F) => e.Event.fromPartial(F))) || [], z;
    }
  };
  function Is() {
    return {
      data: new Uint8Array(),
      retainHeight: T.Long.ZERO
    };
  }
  e.ResponseCommit = {
    encode(a, J = V.Writer.create()) {
      return a.data.length !== 0 && J.uint32(18).bytes(a.data), a.retainHeight.isZero() || J.uint32(24).int64(a.retainHeight), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = Is();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 2:
            F.data = H.bytes();
            break;
          case 3:
            F.retainHeight = H.int64();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        data: (0, T.isSet)(a.data) ? (0, T.bytesFromBase64)(a.data) : new Uint8Array(),
        retainHeight: (0, T.isSet)(a.retainHeight) ? T.Long.fromValue(a.retainHeight) : T.Long.ZERO
      };
    },
    toJSON(a) {
      const J = {};
      return a.data !== void 0 && (J.data = (0, T.base64FromBytes)(a.data !== void 0 ? a.data : new Uint8Array())), a.retainHeight !== void 0 && (J.retainHeight = (a.retainHeight || T.Long.ZERO).toString()), J;
    },
    fromPartial(a) {
      const J = Is();
      return J.data = a.data ?? new Uint8Array(), J.retainHeight = a.retainHeight !== void 0 && a.retainHeight !== null ? T.Long.fromValue(a.retainHeight) : T.Long.ZERO, J;
    }
  };
  function xs() {
    return {
      snapshots: []
    };
  }
  e.ResponseListSnapshots = {
    encode(a, J = V.Writer.create()) {
      for (const H of a.snapshots)
        e.Snapshot.encode(H, J.uint32(10).fork()).ldelim();
      return J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = xs();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.snapshots.push(e.Snapshot.decode(H, H.uint32()));
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        snapshots: Array.isArray(a == null ? void 0 : a.snapshots) ? a.snapshots.map((J) => e.Snapshot.fromJSON(J)) : []
      };
    },
    toJSON(a) {
      const J = {};
      return a.snapshots ? J.snapshots = a.snapshots.map((H) => H ? e.Snapshot.toJSON(H) : void 0) : J.snapshots = [], J;
    },
    fromPartial(a) {
      var J;
      const H = xs();
      return H.snapshots = ((J = a.snapshots) == null ? void 0 : J.map((z) => e.Snapshot.fromPartial(z))) || [], H;
    }
  };
  function _s() {
    return {
      result: 0
    };
  }
  e.ResponseOfferSnapshot = {
    encode(a, J = V.Writer.create()) {
      return a.result !== 0 && J.uint32(8).int32(a.result), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = _s();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.result = H.int32();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        result: (0, T.isSet)(a.result) ? l(a.result) : 0
      };
    },
    toJSON(a) {
      const J = {};
      return a.result !== void 0 && (J.result = S(a.result)), J;
    },
    fromPartial(a) {
      const J = _s();
      return J.result = a.result ?? 0, J;
    }
  };
  function Js() {
    return {
      chunk: new Uint8Array()
    };
  }
  e.ResponseLoadSnapshotChunk = {
    encode(a, J = V.Writer.create()) {
      return a.chunk.length !== 0 && J.uint32(10).bytes(a.chunk), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = Js();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.chunk = H.bytes();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        chunk: (0, T.isSet)(a.chunk) ? (0, T.bytesFromBase64)(a.chunk) : new Uint8Array()
      };
    },
    toJSON(a) {
      const J = {};
      return a.chunk !== void 0 && (J.chunk = (0, T.base64FromBytes)(a.chunk !== void 0 ? a.chunk : new Uint8Array())), J;
    },
    fromPartial(a) {
      const J = Js();
      return J.chunk = a.chunk ?? new Uint8Array(), J;
    }
  };
  function Us() {
    return {
      result: 0,
      refetchChunks: [],
      rejectSenders: []
    };
  }
  e.ResponseApplySnapshotChunk = {
    encode(a, J = V.Writer.create()) {
      a.result !== 0 && J.uint32(8).int32(a.result), J.uint32(18).fork();
      for (const H of a.refetchChunks)
        J.uint32(H);
      J.ldelim();
      for (const H of a.rejectSenders)
        J.uint32(26).string(H);
      return J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = Us();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.result = H.int32();
            break;
          case 2:
            if (($ & 7) === 2) {
              const qu = H.uint32() + H.pos;
              for (; H.pos < qu; )
                F.refetchChunks.push(H.uint32());
            } else
              F.refetchChunks.push(H.uint32());
            break;
          case 3:
            F.rejectSenders.push(H.string());
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        result: (0, T.isSet)(a.result) ? d(a.result) : 0,
        refetchChunks: Array.isArray(a == null ? void 0 : a.refetchChunks) ? a.refetchChunks.map((J) => Number(J)) : [],
        rejectSenders: Array.isArray(a == null ? void 0 : a.rejectSenders) ? a.rejectSenders.map((J) => String(J)) : []
      };
    },
    toJSON(a) {
      const J = {};
      return a.result !== void 0 && (J.result = p(a.result)), a.refetchChunks ? J.refetchChunks = a.refetchChunks.map((H) => Math.round(H)) : J.refetchChunks = [], a.rejectSenders ? J.rejectSenders = a.rejectSenders.map((H) => H) : J.rejectSenders = [], J;
    },
    fromPartial(a) {
      var J, H;
      const z = Us();
      return z.result = a.result ?? 0, z.refetchChunks = ((J = a.refetchChunks) == null ? void 0 : J.map((F) => F)) || [], z.rejectSenders = ((H = a.rejectSenders) == null ? void 0 : H.map((F) => F)) || [], z;
    }
  };
  function Ds() {
    return {
      txs: []
    };
  }
  e.ResponsePrepareProposal = {
    encode(a, J = V.Writer.create()) {
      for (const H of a.txs)
        J.uint32(10).bytes(H);
      return J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = Ds();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.txs.push(H.bytes());
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        txs: Array.isArray(a == null ? void 0 : a.txs) ? a.txs.map((J) => (0, T.bytesFromBase64)(J)) : []
      };
    },
    toJSON(a) {
      const J = {};
      return a.txs ? J.txs = a.txs.map((H) => (0, T.base64FromBytes)(H !== void 0 ? H : new Uint8Array())) : J.txs = [], J;
    },
    fromPartial(a) {
      var J;
      const H = Ds();
      return H.txs = ((J = a.txs) == null ? void 0 : J.map((z) => z)) || [], H;
    }
  };
  function Ls() {
    return {
      status: 0
    };
  }
  e.ResponseProcessProposal = {
    encode(a, J = V.Writer.create()) {
      return a.status !== 0 && J.uint32(8).int32(a.status), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = Ls();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.status = H.int32();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        status: (0, T.isSet)(a.status) ? x(a.status) : 0
      };
    },
    toJSON(a) {
      const J = {};
      return a.status !== void 0 && (J.status = _(a.status)), J;
    },
    fromPartial(a) {
      const J = Ls();
      return J.status = a.status ?? 0, J;
    }
  };
  function Bs() {
    return {
      round: 0,
      votes: []
    };
  }
  e.CommitInfo = {
    encode(a, J = V.Writer.create()) {
      a.round !== 0 && J.uint32(8).int32(a.round);
      for (const H of a.votes)
        e.VoteInfo.encode(H, J.uint32(18).fork()).ldelim();
      return J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = Bs();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.round = H.int32();
            break;
          case 2:
            F.votes.push(e.VoteInfo.decode(H, H.uint32()));
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        round: (0, T.isSet)(a.round) ? Number(a.round) : 0,
        votes: Array.isArray(a == null ? void 0 : a.votes) ? a.votes.map((J) => e.VoteInfo.fromJSON(J)) : []
      };
    },
    toJSON(a) {
      const J = {};
      return a.round !== void 0 && (J.round = Math.round(a.round)), a.votes ? J.votes = a.votes.map((H) => H ? e.VoteInfo.toJSON(H) : void 0) : J.votes = [], J;
    },
    fromPartial(a) {
      var J;
      const H = Bs();
      return H.round = a.round ?? 0, H.votes = ((J = a.votes) == null ? void 0 : J.map((z) => e.VoteInfo.fromPartial(z))) || [], H;
    }
  };
  function Vs() {
    return {
      round: 0,
      votes: []
    };
  }
  e.ExtendedCommitInfo = {
    encode(a, J = V.Writer.create()) {
      a.round !== 0 && J.uint32(8).int32(a.round);
      for (const H of a.votes)
        e.ExtendedVoteInfo.encode(H, J.uint32(18).fork()).ldelim();
      return J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = Vs();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.round = H.int32();
            break;
          case 2:
            F.votes.push(e.ExtendedVoteInfo.decode(H, H.uint32()));
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        round: (0, T.isSet)(a.round) ? Number(a.round) : 0,
        votes: Array.isArray(a == null ? void 0 : a.votes) ? a.votes.map((J) => e.ExtendedVoteInfo.fromJSON(J)) : []
      };
    },
    toJSON(a) {
      const J = {};
      return a.round !== void 0 && (J.round = Math.round(a.round)), a.votes ? J.votes = a.votes.map((H) => H ? e.ExtendedVoteInfo.toJSON(H) : void 0) : J.votes = [], J;
    },
    fromPartial(a) {
      var J;
      const H = Vs();
      return H.round = a.round ?? 0, H.votes = ((J = a.votes) == null ? void 0 : J.map((z) => e.ExtendedVoteInfo.fromPartial(z))) || [], H;
    }
  };
  function Ms() {
    return {
      type: "",
      attributes: []
    };
  }
  e.Event = {
    encode(a, J = V.Writer.create()) {
      a.type !== "" && J.uint32(10).string(a.type);
      for (const H of a.attributes)
        e.EventAttribute.encode(H, J.uint32(18).fork()).ldelim();
      return J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = Ms();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.type = H.string();
            break;
          case 2:
            F.attributes.push(e.EventAttribute.decode(H, H.uint32()));
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        type: (0, T.isSet)(a.type) ? String(a.type) : "",
        attributes: Array.isArray(a == null ? void 0 : a.attributes) ? a.attributes.map((J) => e.EventAttribute.fromJSON(J)) : []
      };
    },
    toJSON(a) {
      const J = {};
      return a.type !== void 0 && (J.type = a.type), a.attributes ? J.attributes = a.attributes.map((H) => H ? e.EventAttribute.toJSON(H) : void 0) : J.attributes = [], J;
    },
    fromPartial(a) {
      var J;
      const H = Ms();
      return H.type = a.type ?? "", H.attributes = ((J = a.attributes) == null ? void 0 : J.map((z) => e.EventAttribute.fromPartial(z))) || [], H;
    }
  };
  function Hs() {
    return {
      key: "",
      value: "",
      index: !1
    };
  }
  e.EventAttribute = {
    encode(a, J = V.Writer.create()) {
      return a.key !== "" && J.uint32(10).string(a.key), a.value !== "" && J.uint32(18).string(a.value), a.index === !0 && J.uint32(24).bool(a.index), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = Hs();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.key = H.string();
            break;
          case 2:
            F.value = H.string();
            break;
          case 3:
            F.index = H.bool();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        key: (0, T.isSet)(a.key) ? String(a.key) : "",
        value: (0, T.isSet)(a.value) ? String(a.value) : "",
        index: (0, T.isSet)(a.index) ? !!a.index : !1
      };
    },
    toJSON(a) {
      const J = {};
      return a.key !== void 0 && (J.key = a.key), a.value !== void 0 && (J.value = a.value), a.index !== void 0 && (J.index = a.index), J;
    },
    fromPartial(a) {
      const J = Hs();
      return J.key = a.key ?? "", J.value = a.value ?? "", J.index = a.index ?? !1, J;
    }
  };
  function js() {
    return {
      height: T.Long.ZERO,
      index: 0,
      tx: new Uint8Array(),
      result: void 0
    };
  }
  e.TxResult = {
    encode(a, J = V.Writer.create()) {
      return a.height.isZero() || J.uint32(8).int64(a.height), a.index !== 0 && J.uint32(16).uint32(a.index), a.tx.length !== 0 && J.uint32(26).bytes(a.tx), a.result !== void 0 && e.ResponseDeliverTx.encode(a.result, J.uint32(34).fork()).ldelim(), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = js();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.height = H.int64();
            break;
          case 2:
            F.index = H.uint32();
            break;
          case 3:
            F.tx = H.bytes();
            break;
          case 4:
            F.result = e.ResponseDeliverTx.decode(H, H.uint32());
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        height: (0, T.isSet)(a.height) ? T.Long.fromValue(a.height) : T.Long.ZERO,
        index: (0, T.isSet)(a.index) ? Number(a.index) : 0,
        tx: (0, T.isSet)(a.tx) ? (0, T.bytesFromBase64)(a.tx) : new Uint8Array(),
        result: (0, T.isSet)(a.result) ? e.ResponseDeliverTx.fromJSON(a.result) : void 0
      };
    },
    toJSON(a) {
      const J = {};
      return a.height !== void 0 && (J.height = (a.height || T.Long.ZERO).toString()), a.index !== void 0 && (J.index = Math.round(a.index)), a.tx !== void 0 && (J.tx = (0, T.base64FromBytes)(a.tx !== void 0 ? a.tx : new Uint8Array())), a.result !== void 0 && (J.result = a.result ? e.ResponseDeliverTx.toJSON(a.result) : void 0), J;
    },
    fromPartial(a) {
      const J = js();
      return J.height = a.height !== void 0 && a.height !== null ? T.Long.fromValue(a.height) : T.Long.ZERO, J.index = a.index ?? 0, J.tx = a.tx ?? new Uint8Array(), J.result = a.result !== void 0 && a.result !== null ? e.ResponseDeliverTx.fromPartial(a.result) : void 0, J;
    }
  };
  function Ws() {
    return {
      address: new Uint8Array(),
      power: T.Long.ZERO
    };
  }
  e.Validator = {
    encode(a, J = V.Writer.create()) {
      return a.address.length !== 0 && J.uint32(10).bytes(a.address), a.power.isZero() || J.uint32(24).int64(a.power), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = Ws();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.address = H.bytes();
            break;
          case 3:
            F.power = H.int64();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        address: (0, T.isSet)(a.address) ? (0, T.bytesFromBase64)(a.address) : new Uint8Array(),
        power: (0, T.isSet)(a.power) ? T.Long.fromValue(a.power) : T.Long.ZERO
      };
    },
    toJSON(a) {
      const J = {};
      return a.address !== void 0 && (J.address = (0, T.base64FromBytes)(a.address !== void 0 ? a.address : new Uint8Array())), a.power !== void 0 && (J.power = (a.power || T.Long.ZERO).toString()), J;
    },
    fromPartial(a) {
      const J = Ws();
      return J.address = a.address ?? new Uint8Array(), J.power = a.power !== void 0 && a.power !== null ? T.Long.fromValue(a.power) : T.Long.ZERO, J;
    }
  };
  function qs() {
    return {
      pubKey: void 0,
      power: T.Long.ZERO
    };
  }
  e.ValidatorUpdate = {
    encode(a, J = V.Writer.create()) {
      return a.pubKey !== void 0 && R.PublicKey.encode(a.pubKey, J.uint32(10).fork()).ldelim(), a.power.isZero() || J.uint32(16).int64(a.power), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = qs();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.pubKey = R.PublicKey.decode(H, H.uint32());
            break;
          case 2:
            F.power = H.int64();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        pubKey: (0, T.isSet)(a.pubKey) ? R.PublicKey.fromJSON(a.pubKey) : void 0,
        power: (0, T.isSet)(a.power) ? T.Long.fromValue(a.power) : T.Long.ZERO
      };
    },
    toJSON(a) {
      const J = {};
      return a.pubKey !== void 0 && (J.pubKey = a.pubKey ? R.PublicKey.toJSON(a.pubKey) : void 0), a.power !== void 0 && (J.power = (a.power || T.Long.ZERO).toString()), J;
    },
    fromPartial(a) {
      const J = qs();
      return J.pubKey = a.pubKey !== void 0 && a.pubKey !== null ? R.PublicKey.fromPartial(a.pubKey) : void 0, J.power = a.power !== void 0 && a.power !== null ? T.Long.fromValue(a.power) : T.Long.ZERO, J;
    }
  };
  function Zs() {
    return {
      validator: void 0,
      signedLastBlock: !1
    };
  }
  e.VoteInfo = {
    encode(a, J = V.Writer.create()) {
      return a.validator !== void 0 && e.Validator.encode(a.validator, J.uint32(10).fork()).ldelim(), a.signedLastBlock === !0 && J.uint32(16).bool(a.signedLastBlock), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = Zs();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.validator = e.Validator.decode(H, H.uint32());
            break;
          case 2:
            F.signedLastBlock = H.bool();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        validator: (0, T.isSet)(a.validator) ? e.Validator.fromJSON(a.validator) : void 0,
        signedLastBlock: (0, T.isSet)(a.signedLastBlock) ? !!a.signedLastBlock : !1
      };
    },
    toJSON(a) {
      const J = {};
      return a.validator !== void 0 && (J.validator = a.validator ? e.Validator.toJSON(a.validator) : void 0), a.signedLastBlock !== void 0 && (J.signedLastBlock = a.signedLastBlock), J;
    },
    fromPartial(a) {
      const J = Zs();
      return J.validator = a.validator !== void 0 && a.validator !== null ? e.Validator.fromPartial(a.validator) : void 0, J.signedLastBlock = a.signedLastBlock ?? !1, J;
    }
  };
  function Qs() {
    return {
      validator: void 0,
      signedLastBlock: !1,
      voteExtension: new Uint8Array()
    };
  }
  e.ExtendedVoteInfo = {
    encode(a, J = V.Writer.create()) {
      return a.validator !== void 0 && e.Validator.encode(a.validator, J.uint32(10).fork()).ldelim(), a.signedLastBlock === !0 && J.uint32(16).bool(a.signedLastBlock), a.voteExtension.length !== 0 && J.uint32(26).bytes(a.voteExtension), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = Qs();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.validator = e.Validator.decode(H, H.uint32());
            break;
          case 2:
            F.signedLastBlock = H.bool();
            break;
          case 3:
            F.voteExtension = H.bytes();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        validator: (0, T.isSet)(a.validator) ? e.Validator.fromJSON(a.validator) : void 0,
        signedLastBlock: (0, T.isSet)(a.signedLastBlock) ? !!a.signedLastBlock : !1,
        voteExtension: (0, T.isSet)(a.voteExtension) ? (0, T.bytesFromBase64)(a.voteExtension) : new Uint8Array()
      };
    },
    toJSON(a) {
      const J = {};
      return a.validator !== void 0 && (J.validator = a.validator ? e.Validator.toJSON(a.validator) : void 0), a.signedLastBlock !== void 0 && (J.signedLastBlock = a.signedLastBlock), a.voteExtension !== void 0 && (J.voteExtension = (0, T.base64FromBytes)(a.voteExtension !== void 0 ? a.voteExtension : new Uint8Array())), J;
    },
    fromPartial(a) {
      const J = Qs();
      return J.validator = a.validator !== void 0 && a.validator !== null ? e.Validator.fromPartial(a.validator) : void 0, J.signedLastBlock = a.signedLastBlock ?? !1, J.voteExtension = a.voteExtension ?? new Uint8Array(), J;
    }
  };
  function Fs() {
    return {
      type: 0,
      validator: void 0,
      height: T.Long.ZERO,
      time: void 0,
      totalVotingPower: T.Long.ZERO
    };
  }
  e.Misbehavior = {
    encode(a, J = V.Writer.create()) {
      return a.type !== 0 && J.uint32(8).int32(a.type), a.validator !== void 0 && e.Validator.encode(a.validator, J.uint32(18).fork()).ldelim(), a.height.isZero() || J.uint32(24).int64(a.height), a.time !== void 0 && r.Timestamp.encode(a.time, J.uint32(34).fork()).ldelim(), a.totalVotingPower.isZero() || J.uint32(40).int64(a.totalVotingPower), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = Fs();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.type = H.int32();
            break;
          case 2:
            F.validator = e.Validator.decode(H, H.uint32());
            break;
          case 3:
            F.height = H.int64();
            break;
          case 4:
            F.time = r.Timestamp.decode(H, H.uint32());
            break;
          case 5:
            F.totalVotingPower = H.int64();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        type: (0, T.isSet)(a.type) ? W(a.type) : 0,
        validator: (0, T.isSet)(a.validator) ? e.Validator.fromJSON(a.validator) : void 0,
        height: (0, T.isSet)(a.height) ? T.Long.fromValue(a.height) : T.Long.ZERO,
        time: (0, T.isSet)(a.time) ? (0, T.fromJsonTimestamp)(a.time) : void 0,
        totalVotingPower: (0, T.isSet)(a.totalVotingPower) ? T.Long.fromValue(a.totalVotingPower) : T.Long.ZERO
      };
    },
    toJSON(a) {
      const J = {};
      return a.type !== void 0 && (J.type = n(a.type)), a.validator !== void 0 && (J.validator = a.validator ? e.Validator.toJSON(a.validator) : void 0), a.height !== void 0 && (J.height = (a.height || T.Long.ZERO).toString()), a.time !== void 0 && (J.time = (0, T.fromTimestamp)(a.time).toISOString()), a.totalVotingPower !== void 0 && (J.totalVotingPower = (a.totalVotingPower || T.Long.ZERO).toString()), J;
    },
    fromPartial(a) {
      const J = Fs();
      return J.type = a.type ?? 0, J.validator = a.validator !== void 0 && a.validator !== null ? e.Validator.fromPartial(a.validator) : void 0, J.height = a.height !== void 0 && a.height !== null ? T.Long.fromValue(a.height) : T.Long.ZERO, J.time = a.time !== void 0 && a.time !== null ? r.Timestamp.fromPartial(a.time) : void 0, J.totalVotingPower = a.totalVotingPower !== void 0 && a.totalVotingPower !== null ? T.Long.fromValue(a.totalVotingPower) : T.Long.ZERO, J;
    }
  };
  function Gs() {
    return {
      height: T.Long.UZERO,
      format: 0,
      chunks: 0,
      hash: new Uint8Array(),
      metadata: new Uint8Array()
    };
  }
  e.Snapshot = {
    encode(a, J = V.Writer.create()) {
      return a.height.isZero() || J.uint32(8).uint64(a.height), a.format !== 0 && J.uint32(16).uint32(a.format), a.chunks !== 0 && J.uint32(24).uint32(a.chunks), a.hash.length !== 0 && J.uint32(34).bytes(a.hash), a.metadata.length !== 0 && J.uint32(42).bytes(a.metadata), J;
    },
    decode(a, J) {
      const H = a instanceof V.Reader ? a : new V.Reader(a);
      let z = J === void 0 ? H.len : H.pos + J;
      const F = Gs();
      for (; H.pos < z; ) {
        const $ = H.uint32();
        switch ($ >>> 3) {
          case 1:
            F.height = H.uint64();
            break;
          case 2:
            F.format = H.uint32();
            break;
          case 3:
            F.chunks = H.uint32();
            break;
          case 4:
            F.hash = H.bytes();
            break;
          case 5:
            F.metadata = H.bytes();
            break;
          default:
            H.skipType($ & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(a) {
      return {
        height: (0, T.isSet)(a.height) ? T.Long.fromValue(a.height) : T.Long.UZERO,
        format: (0, T.isSet)(a.format) ? Number(a.format) : 0,
        chunks: (0, T.isSet)(a.chunks) ? Number(a.chunks) : 0,
        hash: (0, T.isSet)(a.hash) ? (0, T.bytesFromBase64)(a.hash) : new Uint8Array(),
        metadata: (0, T.isSet)(a.metadata) ? (0, T.bytesFromBase64)(a.metadata) : new Uint8Array()
      };
    },
    toJSON(a) {
      const J = {};
      return a.height !== void 0 && (J.height = (a.height || T.Long.UZERO).toString()), a.format !== void 0 && (J.format = Math.round(a.format)), a.chunks !== void 0 && (J.chunks = Math.round(a.chunks)), a.hash !== void 0 && (J.hash = (0, T.base64FromBytes)(a.hash !== void 0 ? a.hash : new Uint8Array())), a.metadata !== void 0 && (J.metadata = (0, T.base64FromBytes)(a.metadata !== void 0 ? a.metadata : new Uint8Array())), J;
    },
    fromPartial(a) {
      const J = Gs();
      return J.height = a.height !== void 0 && a.height !== null ? T.Long.fromValue(a.height) : T.Long.UZERO, J.format = a.format ?? 0, J.chunks = a.chunks ?? 0, J.hash = a.hash ?? new Uint8Array(), J.metadata = a.metadata ?? new Uint8Array(), J;
    }
  };
  class Wu {
    constructor(J) {
      this.rpc = J, this.Echo = this.Echo.bind(this), this.Flush = this.Flush.bind(this), this.Info = this.Info.bind(this), this.DeliverTx = this.DeliverTx.bind(this), this.CheckTx = this.CheckTx.bind(this), this.Query = this.Query.bind(this), this.Commit = this.Commit.bind(this), this.InitChain = this.InitChain.bind(this), this.BeginBlock = this.BeginBlock.bind(this), this.EndBlock = this.EndBlock.bind(this), this.ListSnapshots = this.ListSnapshots.bind(this), this.OfferSnapshot = this.OfferSnapshot.bind(this), this.LoadSnapshotChunk = this.LoadSnapshotChunk.bind(this), this.ApplySnapshotChunk = this.ApplySnapshotChunk.bind(this), this.PrepareProposal = this.PrepareProposal.bind(this), this.ProcessProposal = this.ProcessProposal.bind(this);
    }
    Echo(J) {
      const H = e.RequestEcho.encode(J).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "Echo", H).then((z) => e.ResponseEcho.decode(new V.Reader(z)));
    }
    Flush(J = {}) {
      const H = e.RequestFlush.encode(J).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "Flush", H).then((z) => e.ResponseFlush.decode(new V.Reader(z)));
    }
    Info(J) {
      const H = e.RequestInfo.encode(J).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "Info", H).then((z) => e.ResponseInfo.decode(new V.Reader(z)));
    }
    DeliverTx(J) {
      const H = e.RequestDeliverTx.encode(J).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "DeliverTx", H).then((z) => e.ResponseDeliverTx.decode(new V.Reader(z)));
    }
    CheckTx(J) {
      const H = e.RequestCheckTx.encode(J).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "CheckTx", H).then((z) => e.ResponseCheckTx.decode(new V.Reader(z)));
    }
    Query(J) {
      const H = e.RequestQuery.encode(J).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "Query", H).then((z) => e.ResponseQuery.decode(new V.Reader(z)));
    }
    Commit(J = {}) {
      const H = e.RequestCommit.encode(J).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "Commit", H).then((z) => e.ResponseCommit.decode(new V.Reader(z)));
    }
    InitChain(J) {
      const H = e.RequestInitChain.encode(J).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "InitChain", H).then((z) => e.ResponseInitChain.decode(new V.Reader(z)));
    }
    BeginBlock(J) {
      const H = e.RequestBeginBlock.encode(J).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "BeginBlock", H).then((z) => e.ResponseBeginBlock.decode(new V.Reader(z)));
    }
    EndBlock(J) {
      const H = e.RequestEndBlock.encode(J).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "EndBlock", H).then((z) => e.ResponseEndBlock.decode(new V.Reader(z)));
    }
    ListSnapshots(J = {}) {
      const H = e.RequestListSnapshots.encode(J).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "ListSnapshots", H).then((z) => e.ResponseListSnapshots.decode(new V.Reader(z)));
    }
    OfferSnapshot(J) {
      const H = e.RequestOfferSnapshot.encode(J).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "OfferSnapshot", H).then((z) => e.ResponseOfferSnapshot.decode(new V.Reader(z)));
    }
    LoadSnapshotChunk(J) {
      const H = e.RequestLoadSnapshotChunk.encode(J).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "LoadSnapshotChunk", H).then((z) => e.ResponseLoadSnapshotChunk.decode(new V.Reader(z)));
    }
    ApplySnapshotChunk(J) {
      const H = e.RequestApplySnapshotChunk.encode(J).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "ApplySnapshotChunk", H).then((z) => e.ResponseApplySnapshotChunk.decode(new V.Reader(z)));
    }
    PrepareProposal(J) {
      const H = e.RequestPrepareProposal.encode(J).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "PrepareProposal", H).then((z) => e.ResponsePrepareProposal.decode(new V.Reader(z)));
    }
    ProcessProposal(J) {
      const H = e.RequestProcessProposal.encode(J).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "ProcessProposal", H).then((z) => e.ResponseProcessProposal.decode(new V.Reader(z)));
    }
  }
  e.ABCIApplicationClientImpl = Wu;
})(ns);
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(g, v, N, q) {
    q === void 0 && (q = N);
    var G = Object.getOwnPropertyDescriptor(v, N);
    (!G || ("get" in G ? !v.__esModule : G.writable || G.configurable)) && (G = { enumerable: !0, get: function() {
      return v[N];
    } }), Object.defineProperty(g, q, G);
  } : function(g, v, N, q) {
    q === void 0 && (q = N), g[q] = v[N];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(g, v) {
    Object.defineProperty(g, "default", { enumerable: !0, value: v });
  } : function(g, v) {
    g.default = v;
  }), u = Q && Q.__importStar || function(g) {
    if (g && g.__esModule)
      return g;
    var v = {};
    if (g != null)
      for (var N in g)
        N !== "default" && Object.prototype.hasOwnProperty.call(g, N) && o(v, g, N);
    return t(v, g), v;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ValidatorUpdates = e.Pool = e.RedelegationResponse = e.RedelegationEntryResponse = e.DelegationResponse = e.Params = e.Redelegation = e.RedelegationEntry = e.UnbondingDelegationEntry = e.UnbondingDelegation = e.Delegation = e.DVVTriplets = e.DVVTriplet = e.DVPairs = e.DVPair = e.ValAddresses = e.Validator = e.Description = e.Commission = e.CommissionRates = e.HistoricalInfo = e.infractionToJSON = e.infractionFromJSON = e.Infraction = e.bondStatusToJSON = e.bondStatusFromJSON = e.BondStatus = e.protobufPackage = void 0;
  const r = nn, m = Ae, f = ye, b = et, R = Le, T = ns, V = ie, D = u(re);
  e.protobufPackage = "cosmos.staking.v1beta1";
  var B;
  (function(g) {
    g[g.BOND_STATUS_UNSPECIFIED = 0] = "BOND_STATUS_UNSPECIFIED", g[g.BOND_STATUS_UNBONDED = 1] = "BOND_STATUS_UNBONDED", g[g.BOND_STATUS_UNBONDING = 2] = "BOND_STATUS_UNBONDING", g[g.BOND_STATUS_BONDED = 3] = "BOND_STATUS_BONDED", g[g.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(B = e.BondStatus || (e.BondStatus = {}));
  function U(g) {
    switch (g) {
      case 0:
      case "BOND_STATUS_UNSPECIFIED":
        return B.BOND_STATUS_UNSPECIFIED;
      case 1:
      case "BOND_STATUS_UNBONDED":
        return B.BOND_STATUS_UNBONDED;
      case 2:
      case "BOND_STATUS_UNBONDING":
        return B.BOND_STATUS_UNBONDING;
      case 3:
      case "BOND_STATUS_BONDED":
        return B.BOND_STATUS_BONDED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return B.UNRECOGNIZED;
    }
  }
  e.bondStatusFromJSON = U;
  function C(g) {
    switch (g) {
      case B.BOND_STATUS_UNSPECIFIED:
        return "BOND_STATUS_UNSPECIFIED";
      case B.BOND_STATUS_UNBONDED:
        return "BOND_STATUS_UNBONDED";
      case B.BOND_STATUS_UNBONDING:
        return "BOND_STATUS_UNBONDING";
      case B.BOND_STATUS_BONDED:
        return "BOND_STATUS_BONDED";
      case B.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.bondStatusToJSON = C;
  var l;
  (function(g) {
    g[g.INFRACTION_UNSPECIFIED = 0] = "INFRACTION_UNSPECIFIED", g[g.INFRACTION_DOUBLE_SIGN = 1] = "INFRACTION_DOUBLE_SIGN", g[g.INFRACTION_DOWNTIME = 2] = "INFRACTION_DOWNTIME", g[g.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(l = e.Infraction || (e.Infraction = {}));
  function S(g) {
    switch (g) {
      case 0:
      case "INFRACTION_UNSPECIFIED":
        return l.INFRACTION_UNSPECIFIED;
      case 1:
      case "INFRACTION_DOUBLE_SIGN":
        return l.INFRACTION_DOUBLE_SIGN;
      case 2:
      case "INFRACTION_DOWNTIME":
        return l.INFRACTION_DOWNTIME;
      case -1:
      case "UNRECOGNIZED":
      default:
        return l.UNRECOGNIZED;
    }
  }
  e.infractionFromJSON = S;
  function A(g) {
    switch (g) {
      case l.INFRACTION_UNSPECIFIED:
        return "INFRACTION_UNSPECIFIED";
      case l.INFRACTION_DOUBLE_SIGN:
        return "INFRACTION_DOUBLE_SIGN";
      case l.INFRACTION_DOWNTIME:
        return "INFRACTION_DOWNTIME";
      case l.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.infractionToJSON = A;
  function d() {
    return {
      header: void 0,
      valset: []
    };
  }
  e.HistoricalInfo = {
    encode(g, v = D.Writer.create()) {
      g.header !== void 0 && r.Header.encode(g.header, v.uint32(10).fork()).ldelim();
      for (const N of g.valset)
        e.Validator.encode(N, v.uint32(18).fork()).ldelim();
      return v;
    },
    decode(g, v) {
      const N = g instanceof D.Reader ? g : new D.Reader(g);
      let q = v === void 0 ? N.len : N.pos + v;
      const G = d();
      for (; N.pos < q; ) {
        const K = N.uint32();
        switch (K >>> 3) {
          case 1:
            G.header = r.Header.decode(N, N.uint32());
            break;
          case 2:
            G.valset.push(e.Validator.decode(N, N.uint32()));
            break;
          default:
            N.skipType(K & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(g) {
      return {
        header: (0, V.isSet)(g.header) ? r.Header.fromJSON(g.header) : void 0,
        valset: Array.isArray(g == null ? void 0 : g.valset) ? g.valset.map((v) => e.Validator.fromJSON(v)) : []
      };
    },
    toJSON(g) {
      const v = {};
      return g.header !== void 0 && (v.header = g.header ? r.Header.toJSON(g.header) : void 0), g.valset ? v.valset = g.valset.map((N) => N ? e.Validator.toJSON(N) : void 0) : v.valset = [], v;
    },
    fromPartial(g) {
      var v;
      const N = d();
      return N.header = g.header !== void 0 && g.header !== null ? r.Header.fromPartial(g.header) : void 0, N.valset = ((v = g.valset) == null ? void 0 : v.map((q) => e.Validator.fromPartial(q))) || [], N;
    }
  };
  function p() {
    return {
      rate: "",
      maxRate: "",
      maxChangeRate: ""
    };
  }
  e.CommissionRates = {
    encode(g, v = D.Writer.create()) {
      return g.rate !== "" && v.uint32(10).string(g.rate), g.maxRate !== "" && v.uint32(18).string(g.maxRate), g.maxChangeRate !== "" && v.uint32(26).string(g.maxChangeRate), v;
    },
    decode(g, v) {
      const N = g instanceof D.Reader ? g : new D.Reader(g);
      let q = v === void 0 ? N.len : N.pos + v;
      const G = p();
      for (; N.pos < q; ) {
        const K = N.uint32();
        switch (K >>> 3) {
          case 1:
            G.rate = N.string();
            break;
          case 2:
            G.maxRate = N.string();
            break;
          case 3:
            G.maxChangeRate = N.string();
            break;
          default:
            N.skipType(K & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(g) {
      return {
        rate: (0, V.isSet)(g.rate) ? String(g.rate) : "",
        maxRate: (0, V.isSet)(g.maxRate) ? String(g.maxRate) : "",
        maxChangeRate: (0, V.isSet)(g.maxChangeRate) ? String(g.maxChangeRate) : ""
      };
    },
    toJSON(g) {
      const v = {};
      return g.rate !== void 0 && (v.rate = g.rate), g.maxRate !== void 0 && (v.maxRate = g.maxRate), g.maxChangeRate !== void 0 && (v.maxChangeRate = g.maxChangeRate), v;
    },
    fromPartial(g) {
      const v = p();
      return v.rate = g.rate ?? "", v.maxRate = g.maxRate ?? "", v.maxChangeRate = g.maxChangeRate ?? "", v;
    }
  };
  function h() {
    return {
      commissionRates: void 0,
      updateTime: void 0
    };
  }
  e.Commission = {
    encode(g, v = D.Writer.create()) {
      return g.commissionRates !== void 0 && e.CommissionRates.encode(g.commissionRates, v.uint32(10).fork()).ldelim(), g.updateTime !== void 0 && m.Timestamp.encode(g.updateTime, v.uint32(18).fork()).ldelim(), v;
    },
    decode(g, v) {
      const N = g instanceof D.Reader ? g : new D.Reader(g);
      let q = v === void 0 ? N.len : N.pos + v;
      const G = h();
      for (; N.pos < q; ) {
        const K = N.uint32();
        switch (K >>> 3) {
          case 1:
            G.commissionRates = e.CommissionRates.decode(N, N.uint32());
            break;
          case 2:
            G.updateTime = m.Timestamp.decode(N, N.uint32());
            break;
          default:
            N.skipType(K & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(g) {
      return {
        commissionRates: (0, V.isSet)(g.commissionRates) ? e.CommissionRates.fromJSON(g.commissionRates) : void 0,
        updateTime: (0, V.isSet)(g.updateTime) ? (0, V.fromJsonTimestamp)(g.updateTime) : void 0
      };
    },
    toJSON(g) {
      const v = {};
      return g.commissionRates !== void 0 && (v.commissionRates = g.commissionRates ? e.CommissionRates.toJSON(g.commissionRates) : void 0), g.updateTime !== void 0 && (v.updateTime = (0, V.fromTimestamp)(g.updateTime).toISOString()), v;
    },
    fromPartial(g) {
      const v = h();
      return v.commissionRates = g.commissionRates !== void 0 && g.commissionRates !== null ? e.CommissionRates.fromPartial(g.commissionRates) : void 0, v.updateTime = g.updateTime !== void 0 && g.updateTime !== null ? m.Timestamp.fromPartial(g.updateTime) : void 0, v;
    }
  };
  function x() {
    return {
      moniker: "",
      identity: "",
      website: "",
      securityContact: "",
      details: ""
    };
  }
  e.Description = {
    encode(g, v = D.Writer.create()) {
      return g.moniker !== "" && v.uint32(10).string(g.moniker), g.identity !== "" && v.uint32(18).string(g.identity), g.website !== "" && v.uint32(26).string(g.website), g.securityContact !== "" && v.uint32(34).string(g.securityContact), g.details !== "" && v.uint32(42).string(g.details), v;
    },
    decode(g, v) {
      const N = g instanceof D.Reader ? g : new D.Reader(g);
      let q = v === void 0 ? N.len : N.pos + v;
      const G = x();
      for (; N.pos < q; ) {
        const K = N.uint32();
        switch (K >>> 3) {
          case 1:
            G.moniker = N.string();
            break;
          case 2:
            G.identity = N.string();
            break;
          case 3:
            G.website = N.string();
            break;
          case 4:
            G.securityContact = N.string();
            break;
          case 5:
            G.details = N.string();
            break;
          default:
            N.skipType(K & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(g) {
      return {
        moniker: (0, V.isSet)(g.moniker) ? String(g.moniker) : "",
        identity: (0, V.isSet)(g.identity) ? String(g.identity) : "",
        website: (0, V.isSet)(g.website) ? String(g.website) : "",
        securityContact: (0, V.isSet)(g.securityContact) ? String(g.securityContact) : "",
        details: (0, V.isSet)(g.details) ? String(g.details) : ""
      };
    },
    toJSON(g) {
      const v = {};
      return g.moniker !== void 0 && (v.moniker = g.moniker), g.identity !== void 0 && (v.identity = g.identity), g.website !== void 0 && (v.website = g.website), g.securityContact !== void 0 && (v.securityContact = g.securityContact), g.details !== void 0 && (v.details = g.details), v;
    },
    fromPartial(g) {
      const v = x();
      return v.moniker = g.moniker ?? "", v.identity = g.identity ?? "", v.website = g.website ?? "", v.securityContact = g.securityContact ?? "", v.details = g.details ?? "", v;
    }
  };
  function _() {
    return {
      operatorAddress: "",
      consensusPubkey: void 0,
      jailed: !1,
      status: 0,
      tokens: "",
      delegatorShares: "",
      description: void 0,
      unbondingHeight: V.Long.ZERO,
      unbondingTime: void 0,
      commission: void 0,
      minSelfDelegation: "",
      unbondingOnHoldRefCount: V.Long.ZERO,
      unbondingIds: []
    };
  }
  e.Validator = {
    encode(g, v = D.Writer.create()) {
      g.operatorAddress !== "" && v.uint32(10).string(g.operatorAddress), g.consensusPubkey !== void 0 && f.Any.encode(g.consensusPubkey, v.uint32(18).fork()).ldelim(), g.jailed === !0 && v.uint32(24).bool(g.jailed), g.status !== 0 && v.uint32(32).int32(g.status), g.tokens !== "" && v.uint32(42).string(g.tokens), g.delegatorShares !== "" && v.uint32(50).string(g.delegatorShares), g.description !== void 0 && e.Description.encode(g.description, v.uint32(58).fork()).ldelim(), g.unbondingHeight.isZero() || v.uint32(64).int64(g.unbondingHeight), g.unbondingTime !== void 0 && m.Timestamp.encode(g.unbondingTime, v.uint32(74).fork()).ldelim(), g.commission !== void 0 && e.Commission.encode(g.commission, v.uint32(82).fork()).ldelim(), g.minSelfDelegation !== "" && v.uint32(90).string(g.minSelfDelegation), g.unbondingOnHoldRefCount.isZero() || v.uint32(96).int64(g.unbondingOnHoldRefCount), v.uint32(106).fork();
      for (const N of g.unbondingIds)
        v.uint64(N);
      return v.ldelim(), v;
    },
    decode(g, v) {
      const N = g instanceof D.Reader ? g : new D.Reader(g);
      let q = v === void 0 ? N.len : N.pos + v;
      const G = _();
      for (; N.pos < q; ) {
        const K = N.uint32();
        switch (K >>> 3) {
          case 1:
            G.operatorAddress = N.string();
            break;
          case 2:
            G.consensusPubkey = f.Any.decode(N, N.uint32());
            break;
          case 3:
            G.jailed = N.bool();
            break;
          case 4:
            G.status = N.int32();
            break;
          case 5:
            G.tokens = N.string();
            break;
          case 6:
            G.delegatorShares = N.string();
            break;
          case 7:
            G.description = e.Description.decode(N, N.uint32());
            break;
          case 8:
            G.unbondingHeight = N.int64();
            break;
          case 9:
            G.unbondingTime = m.Timestamp.decode(N, N.uint32());
            break;
          case 10:
            G.commission = e.Commission.decode(N, N.uint32());
            break;
          case 11:
            G.minSelfDelegation = N.string();
            break;
          case 12:
            G.unbondingOnHoldRefCount = N.int64();
            break;
          case 13:
            if ((K & 7) === 2) {
              const oe = N.uint32() + N.pos;
              for (; N.pos < oe; )
                G.unbondingIds.push(N.uint64());
            } else
              G.unbondingIds.push(N.uint64());
            break;
          default:
            N.skipType(K & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(g) {
      return {
        operatorAddress: (0, V.isSet)(g.operatorAddress) ? String(g.operatorAddress) : "",
        consensusPubkey: (0, V.isSet)(g.consensusPubkey) ? f.Any.fromJSON(g.consensusPubkey) : void 0,
        jailed: (0, V.isSet)(g.jailed) ? !!g.jailed : !1,
        status: (0, V.isSet)(g.status) ? U(g.status) : 0,
        tokens: (0, V.isSet)(g.tokens) ? String(g.tokens) : "",
        delegatorShares: (0, V.isSet)(g.delegatorShares) ? String(g.delegatorShares) : "",
        description: (0, V.isSet)(g.description) ? e.Description.fromJSON(g.description) : void 0,
        unbondingHeight: (0, V.isSet)(g.unbondingHeight) ? V.Long.fromValue(g.unbondingHeight) : V.Long.ZERO,
        unbondingTime: (0, V.isSet)(g.unbondingTime) ? (0, V.fromJsonTimestamp)(g.unbondingTime) : void 0,
        commission: (0, V.isSet)(g.commission) ? e.Commission.fromJSON(g.commission) : void 0,
        minSelfDelegation: (0, V.isSet)(g.minSelfDelegation) ? String(g.minSelfDelegation) : "",
        unbondingOnHoldRefCount: (0, V.isSet)(g.unbondingOnHoldRefCount) ? V.Long.fromValue(g.unbondingOnHoldRefCount) : V.Long.ZERO,
        unbondingIds: Array.isArray(g == null ? void 0 : g.unbondingIds) ? g.unbondingIds.map((v) => V.Long.fromValue(v)) : []
      };
    },
    toJSON(g) {
      const v = {};
      return g.operatorAddress !== void 0 && (v.operatorAddress = g.operatorAddress), g.consensusPubkey !== void 0 && (v.consensusPubkey = g.consensusPubkey ? f.Any.toJSON(g.consensusPubkey) : void 0), g.jailed !== void 0 && (v.jailed = g.jailed), g.status !== void 0 && (v.status = C(g.status)), g.tokens !== void 0 && (v.tokens = g.tokens), g.delegatorShares !== void 0 && (v.delegatorShares = g.delegatorShares), g.description !== void 0 && (v.description = g.description ? e.Description.toJSON(g.description) : void 0), g.unbondingHeight !== void 0 && (v.unbondingHeight = (g.unbondingHeight || V.Long.ZERO).toString()), g.unbondingTime !== void 0 && (v.unbondingTime = (0, V.fromTimestamp)(g.unbondingTime).toISOString()), g.commission !== void 0 && (v.commission = g.commission ? e.Commission.toJSON(g.commission) : void 0), g.minSelfDelegation !== void 0 && (v.minSelfDelegation = g.minSelfDelegation), g.unbondingOnHoldRefCount !== void 0 && (v.unbondingOnHoldRefCount = (g.unbondingOnHoldRefCount || V.Long.ZERO).toString()), g.unbondingIds ? v.unbondingIds = g.unbondingIds.map((N) => (N || V.Long.UZERO).toString()) : v.unbondingIds = [], v;
    },
    fromPartial(g) {
      var v;
      const N = _();
      return N.operatorAddress = g.operatorAddress ?? "", N.consensusPubkey = g.consensusPubkey !== void 0 && g.consensusPubkey !== null ? f.Any.fromPartial(g.consensusPubkey) : void 0, N.jailed = g.jailed ?? !1, N.status = g.status ?? 0, N.tokens = g.tokens ?? "", N.delegatorShares = g.delegatorShares ?? "", N.description = g.description !== void 0 && g.description !== null ? e.Description.fromPartial(g.description) : void 0, N.unbondingHeight = g.unbondingHeight !== void 0 && g.unbondingHeight !== null ? V.Long.fromValue(g.unbondingHeight) : V.Long.ZERO, N.unbondingTime = g.unbondingTime !== void 0 && g.unbondingTime !== null ? m.Timestamp.fromPartial(g.unbondingTime) : void 0, N.commission = g.commission !== void 0 && g.commission !== null ? e.Commission.fromPartial(g.commission) : void 0, N.minSelfDelegation = g.minSelfDelegation ?? "", N.unbondingOnHoldRefCount = g.unbondingOnHoldRefCount !== void 0 && g.unbondingOnHoldRefCount !== null ? V.Long.fromValue(g.unbondingOnHoldRefCount) : V.Long.ZERO, N.unbondingIds = ((v = g.unbondingIds) == null ? void 0 : v.map((q) => V.Long.fromValue(q))) || [], N;
    }
  };
  function I() {
    return {
      addresses: []
    };
  }
  e.ValAddresses = {
    encode(g, v = D.Writer.create()) {
      for (const N of g.addresses)
        v.uint32(10).string(N);
      return v;
    },
    decode(g, v) {
      const N = g instanceof D.Reader ? g : new D.Reader(g);
      let q = v === void 0 ? N.len : N.pos + v;
      const G = I();
      for (; N.pos < q; ) {
        const K = N.uint32();
        switch (K >>> 3) {
          case 1:
            G.addresses.push(N.string());
            break;
          default:
            N.skipType(K & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(g) {
      return {
        addresses: Array.isArray(g == null ? void 0 : g.addresses) ? g.addresses.map((v) => String(v)) : []
      };
    },
    toJSON(g) {
      const v = {};
      return g.addresses ? v.addresses = g.addresses.map((N) => N) : v.addresses = [], v;
    },
    fromPartial(g) {
      var v;
      const N = I();
      return N.addresses = ((v = g.addresses) == null ? void 0 : v.map((q) => q)) || [], N;
    }
  };
  function W() {
    return {
      delegatorAddress: "",
      validatorAddress: ""
    };
  }
  e.DVPair = {
    encode(g, v = D.Writer.create()) {
      return g.delegatorAddress !== "" && v.uint32(10).string(g.delegatorAddress), g.validatorAddress !== "" && v.uint32(18).string(g.validatorAddress), v;
    },
    decode(g, v) {
      const N = g instanceof D.Reader ? g : new D.Reader(g);
      let q = v === void 0 ? N.len : N.pos + v;
      const G = W();
      for (; N.pos < q; ) {
        const K = N.uint32();
        switch (K >>> 3) {
          case 1:
            G.delegatorAddress = N.string();
            break;
          case 2:
            G.validatorAddress = N.string();
            break;
          default:
            N.skipType(K & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(g) {
      return {
        delegatorAddress: (0, V.isSet)(g.delegatorAddress) ? String(g.delegatorAddress) : "",
        validatorAddress: (0, V.isSet)(g.validatorAddress) ? String(g.validatorAddress) : ""
      };
    },
    toJSON(g) {
      const v = {};
      return g.delegatorAddress !== void 0 && (v.delegatorAddress = g.delegatorAddress), g.validatorAddress !== void 0 && (v.validatorAddress = g.validatorAddress), v;
    },
    fromPartial(g) {
      const v = W();
      return v.delegatorAddress = g.delegatorAddress ?? "", v.validatorAddress = g.validatorAddress ?? "", v;
    }
  };
  function n() {
    return {
      pairs: []
    };
  }
  e.DVPairs = {
    encode(g, v = D.Writer.create()) {
      for (const N of g.pairs)
        e.DVPair.encode(N, v.uint32(10).fork()).ldelim();
      return v;
    },
    decode(g, v) {
      const N = g instanceof D.Reader ? g : new D.Reader(g);
      let q = v === void 0 ? N.len : N.pos + v;
      const G = n();
      for (; N.pos < q; ) {
        const K = N.uint32();
        switch (K >>> 3) {
          case 1:
            G.pairs.push(e.DVPair.decode(N, N.uint32()));
            break;
          default:
            N.skipType(K & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(g) {
      return {
        pairs: Array.isArray(g == null ? void 0 : g.pairs) ? g.pairs.map((v) => e.DVPair.fromJSON(v)) : []
      };
    },
    toJSON(g) {
      const v = {};
      return g.pairs ? v.pairs = g.pairs.map((N) => N ? e.DVPair.toJSON(N) : void 0) : v.pairs = [], v;
    },
    fromPartial(g) {
      var v;
      const N = n();
      return N.pairs = ((v = g.pairs) == null ? void 0 : v.map((q) => e.DVPair.fromPartial(q))) || [], N;
    }
  };
  function y() {
    return {
      delegatorAddress: "",
      validatorSrcAddress: "",
      validatorDstAddress: ""
    };
  }
  e.DVVTriplet = {
    encode(g, v = D.Writer.create()) {
      return g.delegatorAddress !== "" && v.uint32(10).string(g.delegatorAddress), g.validatorSrcAddress !== "" && v.uint32(18).string(g.validatorSrcAddress), g.validatorDstAddress !== "" && v.uint32(26).string(g.validatorDstAddress), v;
    },
    decode(g, v) {
      const N = g instanceof D.Reader ? g : new D.Reader(g);
      let q = v === void 0 ? N.len : N.pos + v;
      const G = y();
      for (; N.pos < q; ) {
        const K = N.uint32();
        switch (K >>> 3) {
          case 1:
            G.delegatorAddress = N.string();
            break;
          case 2:
            G.validatorSrcAddress = N.string();
            break;
          case 3:
            G.validatorDstAddress = N.string();
            break;
          default:
            N.skipType(K & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(g) {
      return {
        delegatorAddress: (0, V.isSet)(g.delegatorAddress) ? String(g.delegatorAddress) : "",
        validatorSrcAddress: (0, V.isSet)(g.validatorSrcAddress) ? String(g.validatorSrcAddress) : "",
        validatorDstAddress: (0, V.isSet)(g.validatorDstAddress) ? String(g.validatorDstAddress) : ""
      };
    },
    toJSON(g) {
      const v = {};
      return g.delegatorAddress !== void 0 && (v.delegatorAddress = g.delegatorAddress), g.validatorSrcAddress !== void 0 && (v.validatorSrcAddress = g.validatorSrcAddress), g.validatorDstAddress !== void 0 && (v.validatorDstAddress = g.validatorDstAddress), v;
    },
    fromPartial(g) {
      const v = y();
      return v.delegatorAddress = g.delegatorAddress ?? "", v.validatorSrcAddress = g.validatorSrcAddress ?? "", v.validatorDstAddress = g.validatorDstAddress ?? "", v;
    }
  };
  function w() {
    return {
      triplets: []
    };
  }
  e.DVVTriplets = {
    encode(g, v = D.Writer.create()) {
      for (const N of g.triplets)
        e.DVVTriplet.encode(N, v.uint32(10).fork()).ldelim();
      return v;
    },
    decode(g, v) {
      const N = g instanceof D.Reader ? g : new D.Reader(g);
      let q = v === void 0 ? N.len : N.pos + v;
      const G = w();
      for (; N.pos < q; ) {
        const K = N.uint32();
        switch (K >>> 3) {
          case 1:
            G.triplets.push(e.DVVTriplet.decode(N, N.uint32()));
            break;
          default:
            N.skipType(K & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(g) {
      return {
        triplets: Array.isArray(g == null ? void 0 : g.triplets) ? g.triplets.map((v) => e.DVVTriplet.fromJSON(v)) : []
      };
    },
    toJSON(g) {
      const v = {};
      return g.triplets ? v.triplets = g.triplets.map((N) => N ? e.DVVTriplet.toJSON(N) : void 0) : v.triplets = [], v;
    },
    fromPartial(g) {
      var v;
      const N = w();
      return N.triplets = ((v = g.triplets) == null ? void 0 : v.map((q) => e.DVVTriplet.fromPartial(q))) || [], N;
    }
  };
  function M() {
    return {
      delegatorAddress: "",
      validatorAddress: "",
      shares: ""
    };
  }
  e.Delegation = {
    encode(g, v = D.Writer.create()) {
      return g.delegatorAddress !== "" && v.uint32(10).string(g.delegatorAddress), g.validatorAddress !== "" && v.uint32(18).string(g.validatorAddress), g.shares !== "" && v.uint32(26).string(g.shares), v;
    },
    decode(g, v) {
      const N = g instanceof D.Reader ? g : new D.Reader(g);
      let q = v === void 0 ? N.len : N.pos + v;
      const G = M();
      for (; N.pos < q; ) {
        const K = N.uint32();
        switch (K >>> 3) {
          case 1:
            G.delegatorAddress = N.string();
            break;
          case 2:
            G.validatorAddress = N.string();
            break;
          case 3:
            G.shares = N.string();
            break;
          default:
            N.skipType(K & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(g) {
      return {
        delegatorAddress: (0, V.isSet)(g.delegatorAddress) ? String(g.delegatorAddress) : "",
        validatorAddress: (0, V.isSet)(g.validatorAddress) ? String(g.validatorAddress) : "",
        shares: (0, V.isSet)(g.shares) ? String(g.shares) : ""
      };
    },
    toJSON(g) {
      const v = {};
      return g.delegatorAddress !== void 0 && (v.delegatorAddress = g.delegatorAddress), g.validatorAddress !== void 0 && (v.validatorAddress = g.validatorAddress), g.shares !== void 0 && (v.shares = g.shares), v;
    },
    fromPartial(g) {
      const v = M();
      return v.delegatorAddress = g.delegatorAddress ?? "", v.validatorAddress = g.validatorAddress ?? "", v.shares = g.shares ?? "", v;
    }
  };
  function s() {
    return {
      delegatorAddress: "",
      validatorAddress: "",
      entries: []
    };
  }
  e.UnbondingDelegation = {
    encode(g, v = D.Writer.create()) {
      g.delegatorAddress !== "" && v.uint32(10).string(g.delegatorAddress), g.validatorAddress !== "" && v.uint32(18).string(g.validatorAddress);
      for (const N of g.entries)
        e.UnbondingDelegationEntry.encode(N, v.uint32(26).fork()).ldelim();
      return v;
    },
    decode(g, v) {
      const N = g instanceof D.Reader ? g : new D.Reader(g);
      let q = v === void 0 ? N.len : N.pos + v;
      const G = s();
      for (; N.pos < q; ) {
        const K = N.uint32();
        switch (K >>> 3) {
          case 1:
            G.delegatorAddress = N.string();
            break;
          case 2:
            G.validatorAddress = N.string();
            break;
          case 3:
            G.entries.push(e.UnbondingDelegationEntry.decode(N, N.uint32()));
            break;
          default:
            N.skipType(K & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(g) {
      return {
        delegatorAddress: (0, V.isSet)(g.delegatorAddress) ? String(g.delegatorAddress) : "",
        validatorAddress: (0, V.isSet)(g.validatorAddress) ? String(g.validatorAddress) : "",
        entries: Array.isArray(g == null ? void 0 : g.entries) ? g.entries.map((v) => e.UnbondingDelegationEntry.fromJSON(v)) : []
      };
    },
    toJSON(g) {
      const v = {};
      return g.delegatorAddress !== void 0 && (v.delegatorAddress = g.delegatorAddress), g.validatorAddress !== void 0 && (v.validatorAddress = g.validatorAddress), g.entries ? v.entries = g.entries.map((N) => N ? e.UnbondingDelegationEntry.toJSON(N) : void 0) : v.entries = [], v;
    },
    fromPartial(g) {
      var v;
      const N = s();
      return N.delegatorAddress = g.delegatorAddress ?? "", N.validatorAddress = g.validatorAddress ?? "", N.entries = ((v = g.entries) == null ? void 0 : v.map((q) => e.UnbondingDelegationEntry.fromPartial(q))) || [], N;
    }
  };
  function c() {
    return {
      creationHeight: V.Long.ZERO,
      completionTime: void 0,
      initialBalance: "",
      balance: "",
      unbondingId: V.Long.UZERO,
      unbondingOnHoldRefCount: V.Long.ZERO
    };
  }
  e.UnbondingDelegationEntry = {
    encode(g, v = D.Writer.create()) {
      return g.creationHeight.isZero() || v.uint32(8).int64(g.creationHeight), g.completionTime !== void 0 && m.Timestamp.encode(g.completionTime, v.uint32(18).fork()).ldelim(), g.initialBalance !== "" && v.uint32(26).string(g.initialBalance), g.balance !== "" && v.uint32(34).string(g.balance), g.unbondingId.isZero() || v.uint32(40).uint64(g.unbondingId), g.unbondingOnHoldRefCount.isZero() || v.uint32(48).int64(g.unbondingOnHoldRefCount), v;
    },
    decode(g, v) {
      const N = g instanceof D.Reader ? g : new D.Reader(g);
      let q = v === void 0 ? N.len : N.pos + v;
      const G = c();
      for (; N.pos < q; ) {
        const K = N.uint32();
        switch (K >>> 3) {
          case 1:
            G.creationHeight = N.int64();
            break;
          case 2:
            G.completionTime = m.Timestamp.decode(N, N.uint32());
            break;
          case 3:
            G.initialBalance = N.string();
            break;
          case 4:
            G.balance = N.string();
            break;
          case 5:
            G.unbondingId = N.uint64();
            break;
          case 6:
            G.unbondingOnHoldRefCount = N.int64();
            break;
          default:
            N.skipType(K & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(g) {
      return {
        creationHeight: (0, V.isSet)(g.creationHeight) ? V.Long.fromValue(g.creationHeight) : V.Long.ZERO,
        completionTime: (0, V.isSet)(g.completionTime) ? (0, V.fromJsonTimestamp)(g.completionTime) : void 0,
        initialBalance: (0, V.isSet)(g.initialBalance) ? String(g.initialBalance) : "",
        balance: (0, V.isSet)(g.balance) ? String(g.balance) : "",
        unbondingId: (0, V.isSet)(g.unbondingId) ? V.Long.fromValue(g.unbondingId) : V.Long.UZERO,
        unbondingOnHoldRefCount: (0, V.isSet)(g.unbondingOnHoldRefCount) ? V.Long.fromValue(g.unbondingOnHoldRefCount) : V.Long.ZERO
      };
    },
    toJSON(g) {
      const v = {};
      return g.creationHeight !== void 0 && (v.creationHeight = (g.creationHeight || V.Long.ZERO).toString()), g.completionTime !== void 0 && (v.completionTime = (0, V.fromTimestamp)(g.completionTime).toISOString()), g.initialBalance !== void 0 && (v.initialBalance = g.initialBalance), g.balance !== void 0 && (v.balance = g.balance), g.unbondingId !== void 0 && (v.unbondingId = (g.unbondingId || V.Long.UZERO).toString()), g.unbondingOnHoldRefCount !== void 0 && (v.unbondingOnHoldRefCount = (g.unbondingOnHoldRefCount || V.Long.ZERO).toString()), v;
    },
    fromPartial(g) {
      const v = c();
      return v.creationHeight = g.creationHeight !== void 0 && g.creationHeight !== null ? V.Long.fromValue(g.creationHeight) : V.Long.ZERO, v.completionTime = g.completionTime !== void 0 && g.completionTime !== null ? m.Timestamp.fromPartial(g.completionTime) : void 0, v.initialBalance = g.initialBalance ?? "", v.balance = g.balance ?? "", v.unbondingId = g.unbondingId !== void 0 && g.unbondingId !== null ? V.Long.fromValue(g.unbondingId) : V.Long.UZERO, v.unbondingOnHoldRefCount = g.unbondingOnHoldRefCount !== void 0 && g.unbondingOnHoldRefCount !== null ? V.Long.fromValue(g.unbondingOnHoldRefCount) : V.Long.ZERO, v;
    }
  };
  function E() {
    return {
      creationHeight: V.Long.ZERO,
      completionTime: void 0,
      initialBalance: "",
      sharesDst: "",
      unbondingId: V.Long.UZERO,
      unbondingOnHoldRefCount: V.Long.ZERO
    };
  }
  e.RedelegationEntry = {
    encode(g, v = D.Writer.create()) {
      return g.creationHeight.isZero() || v.uint32(8).int64(g.creationHeight), g.completionTime !== void 0 && m.Timestamp.encode(g.completionTime, v.uint32(18).fork()).ldelim(), g.initialBalance !== "" && v.uint32(26).string(g.initialBalance), g.sharesDst !== "" && v.uint32(34).string(g.sharesDst), g.unbondingId.isZero() || v.uint32(40).uint64(g.unbondingId), g.unbondingOnHoldRefCount.isZero() || v.uint32(48).int64(g.unbondingOnHoldRefCount), v;
    },
    decode(g, v) {
      const N = g instanceof D.Reader ? g : new D.Reader(g);
      let q = v === void 0 ? N.len : N.pos + v;
      const G = E();
      for (; N.pos < q; ) {
        const K = N.uint32();
        switch (K >>> 3) {
          case 1:
            G.creationHeight = N.int64();
            break;
          case 2:
            G.completionTime = m.Timestamp.decode(N, N.uint32());
            break;
          case 3:
            G.initialBalance = N.string();
            break;
          case 4:
            G.sharesDst = N.string();
            break;
          case 5:
            G.unbondingId = N.uint64();
            break;
          case 6:
            G.unbondingOnHoldRefCount = N.int64();
            break;
          default:
            N.skipType(K & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(g) {
      return {
        creationHeight: (0, V.isSet)(g.creationHeight) ? V.Long.fromValue(g.creationHeight) : V.Long.ZERO,
        completionTime: (0, V.isSet)(g.completionTime) ? (0, V.fromJsonTimestamp)(g.completionTime) : void 0,
        initialBalance: (0, V.isSet)(g.initialBalance) ? String(g.initialBalance) : "",
        sharesDst: (0, V.isSet)(g.sharesDst) ? String(g.sharesDst) : "",
        unbondingId: (0, V.isSet)(g.unbondingId) ? V.Long.fromValue(g.unbondingId) : V.Long.UZERO,
        unbondingOnHoldRefCount: (0, V.isSet)(g.unbondingOnHoldRefCount) ? V.Long.fromValue(g.unbondingOnHoldRefCount) : V.Long.ZERO
      };
    },
    toJSON(g) {
      const v = {};
      return g.creationHeight !== void 0 && (v.creationHeight = (g.creationHeight || V.Long.ZERO).toString()), g.completionTime !== void 0 && (v.completionTime = (0, V.fromTimestamp)(g.completionTime).toISOString()), g.initialBalance !== void 0 && (v.initialBalance = g.initialBalance), g.sharesDst !== void 0 && (v.sharesDst = g.sharesDst), g.unbondingId !== void 0 && (v.unbondingId = (g.unbondingId || V.Long.UZERO).toString()), g.unbondingOnHoldRefCount !== void 0 && (v.unbondingOnHoldRefCount = (g.unbondingOnHoldRefCount || V.Long.ZERO).toString()), v;
    },
    fromPartial(g) {
      const v = E();
      return v.creationHeight = g.creationHeight !== void 0 && g.creationHeight !== null ? V.Long.fromValue(g.creationHeight) : V.Long.ZERO, v.completionTime = g.completionTime !== void 0 && g.completionTime !== null ? m.Timestamp.fromPartial(g.completionTime) : void 0, v.initialBalance = g.initialBalance ?? "", v.sharesDst = g.sharesDst ?? "", v.unbondingId = g.unbondingId !== void 0 && g.unbondingId !== null ? V.Long.fromValue(g.unbondingId) : V.Long.UZERO, v.unbondingOnHoldRefCount = g.unbondingOnHoldRefCount !== void 0 && g.unbondingOnHoldRefCount !== null ? V.Long.fromValue(g.unbondingOnHoldRefCount) : V.Long.ZERO, v;
    }
  };
  function k() {
    return {
      delegatorAddress: "",
      validatorSrcAddress: "",
      validatorDstAddress: "",
      entries: []
    };
  }
  e.Redelegation = {
    encode(g, v = D.Writer.create()) {
      g.delegatorAddress !== "" && v.uint32(10).string(g.delegatorAddress), g.validatorSrcAddress !== "" && v.uint32(18).string(g.validatorSrcAddress), g.validatorDstAddress !== "" && v.uint32(26).string(g.validatorDstAddress);
      for (const N of g.entries)
        e.RedelegationEntry.encode(N, v.uint32(34).fork()).ldelim();
      return v;
    },
    decode(g, v) {
      const N = g instanceof D.Reader ? g : new D.Reader(g);
      let q = v === void 0 ? N.len : N.pos + v;
      const G = k();
      for (; N.pos < q; ) {
        const K = N.uint32();
        switch (K >>> 3) {
          case 1:
            G.delegatorAddress = N.string();
            break;
          case 2:
            G.validatorSrcAddress = N.string();
            break;
          case 3:
            G.validatorDstAddress = N.string();
            break;
          case 4:
            G.entries.push(e.RedelegationEntry.decode(N, N.uint32()));
            break;
          default:
            N.skipType(K & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(g) {
      return {
        delegatorAddress: (0, V.isSet)(g.delegatorAddress) ? String(g.delegatorAddress) : "",
        validatorSrcAddress: (0, V.isSet)(g.validatorSrcAddress) ? String(g.validatorSrcAddress) : "",
        validatorDstAddress: (0, V.isSet)(g.validatorDstAddress) ? String(g.validatorDstAddress) : "",
        entries: Array.isArray(g == null ? void 0 : g.entries) ? g.entries.map((v) => e.RedelegationEntry.fromJSON(v)) : []
      };
    },
    toJSON(g) {
      const v = {};
      return g.delegatorAddress !== void 0 && (v.delegatorAddress = g.delegatorAddress), g.validatorSrcAddress !== void 0 && (v.validatorSrcAddress = g.validatorSrcAddress), g.validatorDstAddress !== void 0 && (v.validatorDstAddress = g.validatorDstAddress), g.entries ? v.entries = g.entries.map((N) => N ? e.RedelegationEntry.toJSON(N) : void 0) : v.entries = [], v;
    },
    fromPartial(g) {
      var v;
      const N = k();
      return N.delegatorAddress = g.delegatorAddress ?? "", N.validatorSrcAddress = g.validatorSrcAddress ?? "", N.validatorDstAddress = g.validatorDstAddress ?? "", N.entries = ((v = g.entries) == null ? void 0 : v.map((q) => e.RedelegationEntry.fromPartial(q))) || [], N;
    }
  };
  function O() {
    return {
      unbondingTime: void 0,
      maxValidators: 0,
      maxEntries: 0,
      historicalEntries: 0,
      bondDenom: "",
      minCommissionRate: ""
    };
  }
  e.Params = {
    encode(g, v = D.Writer.create()) {
      return g.unbondingTime !== void 0 && b.Duration.encode(g.unbondingTime, v.uint32(10).fork()).ldelim(), g.maxValidators !== 0 && v.uint32(16).uint32(g.maxValidators), g.maxEntries !== 0 && v.uint32(24).uint32(g.maxEntries), g.historicalEntries !== 0 && v.uint32(32).uint32(g.historicalEntries), g.bondDenom !== "" && v.uint32(42).string(g.bondDenom), g.minCommissionRate !== "" && v.uint32(50).string(g.minCommissionRate), v;
    },
    decode(g, v) {
      const N = g instanceof D.Reader ? g : new D.Reader(g);
      let q = v === void 0 ? N.len : N.pos + v;
      const G = O();
      for (; N.pos < q; ) {
        const K = N.uint32();
        switch (K >>> 3) {
          case 1:
            G.unbondingTime = b.Duration.decode(N, N.uint32());
            break;
          case 2:
            G.maxValidators = N.uint32();
            break;
          case 3:
            G.maxEntries = N.uint32();
            break;
          case 4:
            G.historicalEntries = N.uint32();
            break;
          case 5:
            G.bondDenom = N.string();
            break;
          case 6:
            G.minCommissionRate = N.string();
            break;
          default:
            N.skipType(K & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(g) {
      return {
        unbondingTime: (0, V.isSet)(g.unbondingTime) ? b.Duration.fromJSON(g.unbondingTime) : void 0,
        maxValidators: (0, V.isSet)(g.maxValidators) ? Number(g.maxValidators) : 0,
        maxEntries: (0, V.isSet)(g.maxEntries) ? Number(g.maxEntries) : 0,
        historicalEntries: (0, V.isSet)(g.historicalEntries) ? Number(g.historicalEntries) : 0,
        bondDenom: (0, V.isSet)(g.bondDenom) ? String(g.bondDenom) : "",
        minCommissionRate: (0, V.isSet)(g.minCommissionRate) ? String(g.minCommissionRate) : ""
      };
    },
    toJSON(g) {
      const v = {};
      return g.unbondingTime !== void 0 && (v.unbondingTime = g.unbondingTime ? b.Duration.toJSON(g.unbondingTime) : void 0), g.maxValidators !== void 0 && (v.maxValidators = Math.round(g.maxValidators)), g.maxEntries !== void 0 && (v.maxEntries = Math.round(g.maxEntries)), g.historicalEntries !== void 0 && (v.historicalEntries = Math.round(g.historicalEntries)), g.bondDenom !== void 0 && (v.bondDenom = g.bondDenom), g.minCommissionRate !== void 0 && (v.minCommissionRate = g.minCommissionRate), v;
    },
    fromPartial(g) {
      const v = O();
      return v.unbondingTime = g.unbondingTime !== void 0 && g.unbondingTime !== null ? b.Duration.fromPartial(g.unbondingTime) : void 0, v.maxValidators = g.maxValidators ?? 0, v.maxEntries = g.maxEntries ?? 0, v.historicalEntries = g.historicalEntries ?? 0, v.bondDenom = g.bondDenom ?? "", v.minCommissionRate = g.minCommissionRate ?? "", v;
    }
  };
  function L() {
    return {
      delegation: void 0,
      balance: void 0
    };
  }
  e.DelegationResponse = {
    encode(g, v = D.Writer.create()) {
      return g.delegation !== void 0 && e.Delegation.encode(g.delegation, v.uint32(10).fork()).ldelim(), g.balance !== void 0 && R.Coin.encode(g.balance, v.uint32(18).fork()).ldelim(), v;
    },
    decode(g, v) {
      const N = g instanceof D.Reader ? g : new D.Reader(g);
      let q = v === void 0 ? N.len : N.pos + v;
      const G = L();
      for (; N.pos < q; ) {
        const K = N.uint32();
        switch (K >>> 3) {
          case 1:
            G.delegation = e.Delegation.decode(N, N.uint32());
            break;
          case 2:
            G.balance = R.Coin.decode(N, N.uint32());
            break;
          default:
            N.skipType(K & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(g) {
      return {
        delegation: (0, V.isSet)(g.delegation) ? e.Delegation.fromJSON(g.delegation) : void 0,
        balance: (0, V.isSet)(g.balance) ? R.Coin.fromJSON(g.balance) : void 0
      };
    },
    toJSON(g) {
      const v = {};
      return g.delegation !== void 0 && (v.delegation = g.delegation ? e.Delegation.toJSON(g.delegation) : void 0), g.balance !== void 0 && (v.balance = g.balance ? R.Coin.toJSON(g.balance) : void 0), v;
    },
    fromPartial(g) {
      const v = L();
      return v.delegation = g.delegation !== void 0 && g.delegation !== null ? e.Delegation.fromPartial(g.delegation) : void 0, v.balance = g.balance !== void 0 && g.balance !== null ? R.Coin.fromPartial(g.balance) : void 0, v;
    }
  };
  function Z() {
    return {
      redelegationEntry: void 0,
      balance: ""
    };
  }
  e.RedelegationEntryResponse = {
    encode(g, v = D.Writer.create()) {
      return g.redelegationEntry !== void 0 && e.RedelegationEntry.encode(g.redelegationEntry, v.uint32(10).fork()).ldelim(), g.balance !== "" && v.uint32(34).string(g.balance), v;
    },
    decode(g, v) {
      const N = g instanceof D.Reader ? g : new D.Reader(g);
      let q = v === void 0 ? N.len : N.pos + v;
      const G = Z();
      for (; N.pos < q; ) {
        const K = N.uint32();
        switch (K >>> 3) {
          case 1:
            G.redelegationEntry = e.RedelegationEntry.decode(N, N.uint32());
            break;
          case 4:
            G.balance = N.string();
            break;
          default:
            N.skipType(K & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(g) {
      return {
        redelegationEntry: (0, V.isSet)(g.redelegationEntry) ? e.RedelegationEntry.fromJSON(g.redelegationEntry) : void 0,
        balance: (0, V.isSet)(g.balance) ? String(g.balance) : ""
      };
    },
    toJSON(g) {
      const v = {};
      return g.redelegationEntry !== void 0 && (v.redelegationEntry = g.redelegationEntry ? e.RedelegationEntry.toJSON(g.redelegationEntry) : void 0), g.balance !== void 0 && (v.balance = g.balance), v;
    },
    fromPartial(g) {
      const v = Z();
      return v.redelegationEntry = g.redelegationEntry !== void 0 && g.redelegationEntry !== null ? e.RedelegationEntry.fromPartial(g.redelegationEntry) : void 0, v.balance = g.balance ?? "", v;
    }
  };
  function j() {
    return {
      redelegation: void 0,
      entries: []
    };
  }
  e.RedelegationResponse = {
    encode(g, v = D.Writer.create()) {
      g.redelegation !== void 0 && e.Redelegation.encode(g.redelegation, v.uint32(10).fork()).ldelim();
      for (const N of g.entries)
        e.RedelegationEntryResponse.encode(N, v.uint32(18).fork()).ldelim();
      return v;
    },
    decode(g, v) {
      const N = g instanceof D.Reader ? g : new D.Reader(g);
      let q = v === void 0 ? N.len : N.pos + v;
      const G = j();
      for (; N.pos < q; ) {
        const K = N.uint32();
        switch (K >>> 3) {
          case 1:
            G.redelegation = e.Redelegation.decode(N, N.uint32());
            break;
          case 2:
            G.entries.push(e.RedelegationEntryResponse.decode(N, N.uint32()));
            break;
          default:
            N.skipType(K & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(g) {
      return {
        redelegation: (0, V.isSet)(g.redelegation) ? e.Redelegation.fromJSON(g.redelegation) : void 0,
        entries: Array.isArray(g == null ? void 0 : g.entries) ? g.entries.map((v) => e.RedelegationEntryResponse.fromJSON(v)) : []
      };
    },
    toJSON(g) {
      const v = {};
      return g.redelegation !== void 0 && (v.redelegation = g.redelegation ? e.Redelegation.toJSON(g.redelegation) : void 0), g.entries ? v.entries = g.entries.map((N) => N ? e.RedelegationEntryResponse.toJSON(N) : void 0) : v.entries = [], v;
    },
    fromPartial(g) {
      var v;
      const N = j();
      return N.redelegation = g.redelegation !== void 0 && g.redelegation !== null ? e.Redelegation.fromPartial(g.redelegation) : void 0, N.entries = ((v = g.entries) == null ? void 0 : v.map((q) => e.RedelegationEntryResponse.fromPartial(q))) || [], N;
    }
  };
  function i() {
    return {
      notBondedTokens: "",
      bondedTokens: ""
    };
  }
  e.Pool = {
    encode(g, v = D.Writer.create()) {
      return g.notBondedTokens !== "" && v.uint32(10).string(g.notBondedTokens), g.bondedTokens !== "" && v.uint32(18).string(g.bondedTokens), v;
    },
    decode(g, v) {
      const N = g instanceof D.Reader ? g : new D.Reader(g);
      let q = v === void 0 ? N.len : N.pos + v;
      const G = i();
      for (; N.pos < q; ) {
        const K = N.uint32();
        switch (K >>> 3) {
          case 1:
            G.notBondedTokens = N.string();
            break;
          case 2:
            G.bondedTokens = N.string();
            break;
          default:
            N.skipType(K & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(g) {
      return {
        notBondedTokens: (0, V.isSet)(g.notBondedTokens) ? String(g.notBondedTokens) : "",
        bondedTokens: (0, V.isSet)(g.bondedTokens) ? String(g.bondedTokens) : ""
      };
    },
    toJSON(g) {
      const v = {};
      return g.notBondedTokens !== void 0 && (v.notBondedTokens = g.notBondedTokens), g.bondedTokens !== void 0 && (v.bondedTokens = g.bondedTokens), v;
    },
    fromPartial(g) {
      const v = i();
      return v.notBondedTokens = g.notBondedTokens ?? "", v.bondedTokens = g.bondedTokens ?? "", v;
    }
  };
  function P() {
    return {
      updates: []
    };
  }
  e.ValidatorUpdates = {
    encode(g, v = D.Writer.create()) {
      for (const N of g.updates)
        T.ValidatorUpdate.encode(N, v.uint32(10).fork()).ldelim();
      return v;
    },
    decode(g, v) {
      const N = g instanceof D.Reader ? g : new D.Reader(g);
      let q = v === void 0 ? N.len : N.pos + v;
      const G = P();
      for (; N.pos < q; ) {
        const K = N.uint32();
        switch (K >>> 3) {
          case 1:
            G.updates.push(T.ValidatorUpdate.decode(N, N.uint32()));
            break;
          default:
            N.skipType(K & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(g) {
      return {
        updates: Array.isArray(g == null ? void 0 : g.updates) ? g.updates.map((v) => T.ValidatorUpdate.fromJSON(v)) : []
      };
    },
    toJSON(g) {
      const v = {};
      return g.updates ? v.updates = g.updates.map((N) => N ? T.ValidatorUpdate.toJSON(N) : void 0) : v.updates = [], v;
    },
    fromPartial(g) {
      var v;
      const N = P();
      return N.updates = ((v = g.updates) == null ? void 0 : v.map((q) => T.ValidatorUpdate.fromPartial(q))) || [], N;
    }
  };
})(ts);
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(n, y, w, M) {
    M === void 0 && (M = w);
    var s = Object.getOwnPropertyDescriptor(y, w);
    (!s || ("get" in s ? !y.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: function() {
      return y[w];
    } }), Object.defineProperty(n, M, s);
  } : function(n, y, w, M) {
    M === void 0 && (M = w), n[M] = y[w];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(n, y) {
    Object.defineProperty(n, "default", { enumerable: !0, value: y });
  } : function(n, y) {
    n.default = y;
  }), u = Q && Q.__importStar || function(n) {
    if (n && n.__esModule)
      return n;
    var y = {};
    if (n != null)
      for (var w in n)
        w !== "default" && Object.prototype.hasOwnProperty.call(n, w) && o(y, n, w);
    return t(y, n), y;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgUpdateParamsResponse = e.MsgUpdateParams = e.MsgCancelUnbondingDelegationResponse = e.MsgCancelUnbondingDelegation = e.MsgUndelegateResponse = e.MsgUndelegate = e.MsgBeginRedelegateResponse = e.MsgBeginRedelegate = e.MsgDelegateResponse = e.MsgDelegate = e.MsgEditValidatorResponse = e.MsgEditValidator = e.MsgCreateValidatorResponse = e.MsgCreateValidator = e.protobufPackage = void 0;
  const r = ts, m = ye, f = Le, b = Ae, R = ie, T = u(re);
  e.protobufPackage = "cosmos.staking.v1beta1";
  function V() {
    return {
      description: void 0,
      commission: void 0,
      minSelfDelegation: "",
      delegatorAddress: "",
      validatorAddress: "",
      pubkey: void 0,
      value: void 0
    };
  }
  e.MsgCreateValidator = {
    encode(n, y = T.Writer.create()) {
      return n.description !== void 0 && r.Description.encode(n.description, y.uint32(10).fork()).ldelim(), n.commission !== void 0 && r.CommissionRates.encode(n.commission, y.uint32(18).fork()).ldelim(), n.minSelfDelegation !== "" && y.uint32(26).string(n.minSelfDelegation), n.delegatorAddress !== "" && y.uint32(34).string(n.delegatorAddress), n.validatorAddress !== "" && y.uint32(42).string(n.validatorAddress), n.pubkey !== void 0 && m.Any.encode(n.pubkey, y.uint32(50).fork()).ldelim(), n.value !== void 0 && f.Coin.encode(n.value, y.uint32(58).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = V();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.description = r.Description.decode(w, w.uint32());
            break;
          case 2:
            s.commission = r.CommissionRates.decode(w, w.uint32());
            break;
          case 3:
            s.minSelfDelegation = w.string();
            break;
          case 4:
            s.delegatorAddress = w.string();
            break;
          case 5:
            s.validatorAddress = w.string();
            break;
          case 6:
            s.pubkey = m.Any.decode(w, w.uint32());
            break;
          case 7:
            s.value = f.Coin.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        description: (0, R.isSet)(n.description) ? r.Description.fromJSON(n.description) : void 0,
        commission: (0, R.isSet)(n.commission) ? r.CommissionRates.fromJSON(n.commission) : void 0,
        minSelfDelegation: (0, R.isSet)(n.minSelfDelegation) ? String(n.minSelfDelegation) : "",
        delegatorAddress: (0, R.isSet)(n.delegatorAddress) ? String(n.delegatorAddress) : "",
        validatorAddress: (0, R.isSet)(n.validatorAddress) ? String(n.validatorAddress) : "",
        pubkey: (0, R.isSet)(n.pubkey) ? m.Any.fromJSON(n.pubkey) : void 0,
        value: (0, R.isSet)(n.value) ? f.Coin.fromJSON(n.value) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.description !== void 0 && (y.description = n.description ? r.Description.toJSON(n.description) : void 0), n.commission !== void 0 && (y.commission = n.commission ? r.CommissionRates.toJSON(n.commission) : void 0), n.minSelfDelegation !== void 0 && (y.minSelfDelegation = n.minSelfDelegation), n.delegatorAddress !== void 0 && (y.delegatorAddress = n.delegatorAddress), n.validatorAddress !== void 0 && (y.validatorAddress = n.validatorAddress), n.pubkey !== void 0 && (y.pubkey = n.pubkey ? m.Any.toJSON(n.pubkey) : void 0), n.value !== void 0 && (y.value = n.value ? f.Coin.toJSON(n.value) : void 0), y;
    },
    fromPartial(n) {
      const y = V();
      return y.description = n.description !== void 0 && n.description !== null ? r.Description.fromPartial(n.description) : void 0, y.commission = n.commission !== void 0 && n.commission !== null ? r.CommissionRates.fromPartial(n.commission) : void 0, y.minSelfDelegation = n.minSelfDelegation ?? "", y.delegatorAddress = n.delegatorAddress ?? "", y.validatorAddress = n.validatorAddress ?? "", y.pubkey = n.pubkey !== void 0 && n.pubkey !== null ? m.Any.fromPartial(n.pubkey) : void 0, y.value = n.value !== void 0 && n.value !== null ? f.Coin.fromPartial(n.value) : void 0, y;
    }
  };
  function D() {
    return {};
  }
  e.MsgCreateValidatorResponse = {
    encode(n, y = T.Writer.create()) {
      return y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = D();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {};
    },
    toJSON(n) {
      return {};
    },
    fromPartial(n) {
      return D();
    }
  };
  function B() {
    return {
      description: void 0,
      validatorAddress: "",
      commissionRate: "",
      minSelfDelegation: ""
    };
  }
  e.MsgEditValidator = {
    encode(n, y = T.Writer.create()) {
      return n.description !== void 0 && r.Description.encode(n.description, y.uint32(10).fork()).ldelim(), n.validatorAddress !== "" && y.uint32(18).string(n.validatorAddress), n.commissionRate !== "" && y.uint32(26).string(n.commissionRate), n.minSelfDelegation !== "" && y.uint32(34).string(n.minSelfDelegation), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = B();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.description = r.Description.decode(w, w.uint32());
            break;
          case 2:
            s.validatorAddress = w.string();
            break;
          case 3:
            s.commissionRate = w.string();
            break;
          case 4:
            s.minSelfDelegation = w.string();
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        description: (0, R.isSet)(n.description) ? r.Description.fromJSON(n.description) : void 0,
        validatorAddress: (0, R.isSet)(n.validatorAddress) ? String(n.validatorAddress) : "",
        commissionRate: (0, R.isSet)(n.commissionRate) ? String(n.commissionRate) : "",
        minSelfDelegation: (0, R.isSet)(n.minSelfDelegation) ? String(n.minSelfDelegation) : ""
      };
    },
    toJSON(n) {
      const y = {};
      return n.description !== void 0 && (y.description = n.description ? r.Description.toJSON(n.description) : void 0), n.validatorAddress !== void 0 && (y.validatorAddress = n.validatorAddress), n.commissionRate !== void 0 && (y.commissionRate = n.commissionRate), n.minSelfDelegation !== void 0 && (y.minSelfDelegation = n.minSelfDelegation), y;
    },
    fromPartial(n) {
      const y = B();
      return y.description = n.description !== void 0 && n.description !== null ? r.Description.fromPartial(n.description) : void 0, y.validatorAddress = n.validatorAddress ?? "", y.commissionRate = n.commissionRate ?? "", y.minSelfDelegation = n.minSelfDelegation ?? "", y;
    }
  };
  function U() {
    return {};
  }
  e.MsgEditValidatorResponse = {
    encode(n, y = T.Writer.create()) {
      return y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = U();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {};
    },
    toJSON(n) {
      return {};
    },
    fromPartial(n) {
      return U();
    }
  };
  function C() {
    return {
      delegatorAddress: "",
      validatorAddress: "",
      amount: void 0
    };
  }
  e.MsgDelegate = {
    encode(n, y = T.Writer.create()) {
      return n.delegatorAddress !== "" && y.uint32(10).string(n.delegatorAddress), n.validatorAddress !== "" && y.uint32(18).string(n.validatorAddress), n.amount !== void 0 && f.Coin.encode(n.amount, y.uint32(26).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = C();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.delegatorAddress = w.string();
            break;
          case 2:
            s.validatorAddress = w.string();
            break;
          case 3:
            s.amount = f.Coin.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        delegatorAddress: (0, R.isSet)(n.delegatorAddress) ? String(n.delegatorAddress) : "",
        validatorAddress: (0, R.isSet)(n.validatorAddress) ? String(n.validatorAddress) : "",
        amount: (0, R.isSet)(n.amount) ? f.Coin.fromJSON(n.amount) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.delegatorAddress !== void 0 && (y.delegatorAddress = n.delegatorAddress), n.validatorAddress !== void 0 && (y.validatorAddress = n.validatorAddress), n.amount !== void 0 && (y.amount = n.amount ? f.Coin.toJSON(n.amount) : void 0), y;
    },
    fromPartial(n) {
      const y = C();
      return y.delegatorAddress = n.delegatorAddress ?? "", y.validatorAddress = n.validatorAddress ?? "", y.amount = n.amount !== void 0 && n.amount !== null ? f.Coin.fromPartial(n.amount) : void 0, y;
    }
  };
  function l() {
    return {};
  }
  e.MsgDelegateResponse = {
    encode(n, y = T.Writer.create()) {
      return y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = l();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {};
    },
    toJSON(n) {
      return {};
    },
    fromPartial(n) {
      return l();
    }
  };
  function S() {
    return {
      delegatorAddress: "",
      validatorSrcAddress: "",
      validatorDstAddress: "",
      amount: void 0
    };
  }
  e.MsgBeginRedelegate = {
    encode(n, y = T.Writer.create()) {
      return n.delegatorAddress !== "" && y.uint32(10).string(n.delegatorAddress), n.validatorSrcAddress !== "" && y.uint32(18).string(n.validatorSrcAddress), n.validatorDstAddress !== "" && y.uint32(26).string(n.validatorDstAddress), n.amount !== void 0 && f.Coin.encode(n.amount, y.uint32(34).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = S();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.delegatorAddress = w.string();
            break;
          case 2:
            s.validatorSrcAddress = w.string();
            break;
          case 3:
            s.validatorDstAddress = w.string();
            break;
          case 4:
            s.amount = f.Coin.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        delegatorAddress: (0, R.isSet)(n.delegatorAddress) ? String(n.delegatorAddress) : "",
        validatorSrcAddress: (0, R.isSet)(n.validatorSrcAddress) ? String(n.validatorSrcAddress) : "",
        validatorDstAddress: (0, R.isSet)(n.validatorDstAddress) ? String(n.validatorDstAddress) : "",
        amount: (0, R.isSet)(n.amount) ? f.Coin.fromJSON(n.amount) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.delegatorAddress !== void 0 && (y.delegatorAddress = n.delegatorAddress), n.validatorSrcAddress !== void 0 && (y.validatorSrcAddress = n.validatorSrcAddress), n.validatorDstAddress !== void 0 && (y.validatorDstAddress = n.validatorDstAddress), n.amount !== void 0 && (y.amount = n.amount ? f.Coin.toJSON(n.amount) : void 0), y;
    },
    fromPartial(n) {
      const y = S();
      return y.delegatorAddress = n.delegatorAddress ?? "", y.validatorSrcAddress = n.validatorSrcAddress ?? "", y.validatorDstAddress = n.validatorDstAddress ?? "", y.amount = n.amount !== void 0 && n.amount !== null ? f.Coin.fromPartial(n.amount) : void 0, y;
    }
  };
  function A() {
    return {
      completionTime: void 0
    };
  }
  e.MsgBeginRedelegateResponse = {
    encode(n, y = T.Writer.create()) {
      return n.completionTime !== void 0 && b.Timestamp.encode(n.completionTime, y.uint32(10).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = A();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.completionTime = b.Timestamp.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        completionTime: (0, R.isSet)(n.completionTime) ? (0, R.fromJsonTimestamp)(n.completionTime) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.completionTime !== void 0 && (y.completionTime = (0, R.fromTimestamp)(n.completionTime).toISOString()), y;
    },
    fromPartial(n) {
      const y = A();
      return y.completionTime = n.completionTime !== void 0 && n.completionTime !== null ? b.Timestamp.fromPartial(n.completionTime) : void 0, y;
    }
  };
  function d() {
    return {
      delegatorAddress: "",
      validatorAddress: "",
      amount: void 0
    };
  }
  e.MsgUndelegate = {
    encode(n, y = T.Writer.create()) {
      return n.delegatorAddress !== "" && y.uint32(10).string(n.delegatorAddress), n.validatorAddress !== "" && y.uint32(18).string(n.validatorAddress), n.amount !== void 0 && f.Coin.encode(n.amount, y.uint32(26).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = d();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.delegatorAddress = w.string();
            break;
          case 2:
            s.validatorAddress = w.string();
            break;
          case 3:
            s.amount = f.Coin.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        delegatorAddress: (0, R.isSet)(n.delegatorAddress) ? String(n.delegatorAddress) : "",
        validatorAddress: (0, R.isSet)(n.validatorAddress) ? String(n.validatorAddress) : "",
        amount: (0, R.isSet)(n.amount) ? f.Coin.fromJSON(n.amount) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.delegatorAddress !== void 0 && (y.delegatorAddress = n.delegatorAddress), n.validatorAddress !== void 0 && (y.validatorAddress = n.validatorAddress), n.amount !== void 0 && (y.amount = n.amount ? f.Coin.toJSON(n.amount) : void 0), y;
    },
    fromPartial(n) {
      const y = d();
      return y.delegatorAddress = n.delegatorAddress ?? "", y.validatorAddress = n.validatorAddress ?? "", y.amount = n.amount !== void 0 && n.amount !== null ? f.Coin.fromPartial(n.amount) : void 0, y;
    }
  };
  function p() {
    return {
      completionTime: void 0
    };
  }
  e.MsgUndelegateResponse = {
    encode(n, y = T.Writer.create()) {
      return n.completionTime !== void 0 && b.Timestamp.encode(n.completionTime, y.uint32(10).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = p();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.completionTime = b.Timestamp.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        completionTime: (0, R.isSet)(n.completionTime) ? (0, R.fromJsonTimestamp)(n.completionTime) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.completionTime !== void 0 && (y.completionTime = (0, R.fromTimestamp)(n.completionTime).toISOString()), y;
    },
    fromPartial(n) {
      const y = p();
      return y.completionTime = n.completionTime !== void 0 && n.completionTime !== null ? b.Timestamp.fromPartial(n.completionTime) : void 0, y;
    }
  };
  function h() {
    return {
      delegatorAddress: "",
      validatorAddress: "",
      amount: void 0,
      creationHeight: R.Long.ZERO
    };
  }
  e.MsgCancelUnbondingDelegation = {
    encode(n, y = T.Writer.create()) {
      return n.delegatorAddress !== "" && y.uint32(10).string(n.delegatorAddress), n.validatorAddress !== "" && y.uint32(18).string(n.validatorAddress), n.amount !== void 0 && f.Coin.encode(n.amount, y.uint32(26).fork()).ldelim(), n.creationHeight.isZero() || y.uint32(32).int64(n.creationHeight), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = h();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.delegatorAddress = w.string();
            break;
          case 2:
            s.validatorAddress = w.string();
            break;
          case 3:
            s.amount = f.Coin.decode(w, w.uint32());
            break;
          case 4:
            s.creationHeight = w.int64();
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        delegatorAddress: (0, R.isSet)(n.delegatorAddress) ? String(n.delegatorAddress) : "",
        validatorAddress: (0, R.isSet)(n.validatorAddress) ? String(n.validatorAddress) : "",
        amount: (0, R.isSet)(n.amount) ? f.Coin.fromJSON(n.amount) : void 0,
        creationHeight: (0, R.isSet)(n.creationHeight) ? R.Long.fromValue(n.creationHeight) : R.Long.ZERO
      };
    },
    toJSON(n) {
      const y = {};
      return n.delegatorAddress !== void 0 && (y.delegatorAddress = n.delegatorAddress), n.validatorAddress !== void 0 && (y.validatorAddress = n.validatorAddress), n.amount !== void 0 && (y.amount = n.amount ? f.Coin.toJSON(n.amount) : void 0), n.creationHeight !== void 0 && (y.creationHeight = (n.creationHeight || R.Long.ZERO).toString()), y;
    },
    fromPartial(n) {
      const y = h();
      return y.delegatorAddress = n.delegatorAddress ?? "", y.validatorAddress = n.validatorAddress ?? "", y.amount = n.amount !== void 0 && n.amount !== null ? f.Coin.fromPartial(n.amount) : void 0, y.creationHeight = n.creationHeight !== void 0 && n.creationHeight !== null ? R.Long.fromValue(n.creationHeight) : R.Long.ZERO, y;
    }
  };
  function x() {
    return {};
  }
  e.MsgCancelUnbondingDelegationResponse = {
    encode(n, y = T.Writer.create()) {
      return y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = x();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {};
    },
    toJSON(n) {
      return {};
    },
    fromPartial(n) {
      return x();
    }
  };
  function _() {
    return {
      authority: "",
      params: void 0
    };
  }
  e.MsgUpdateParams = {
    encode(n, y = T.Writer.create()) {
      return n.authority !== "" && y.uint32(10).string(n.authority), n.params !== void 0 && r.Params.encode(n.params, y.uint32(18).fork()).ldelim(), y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = _();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          case 1:
            s.authority = w.string();
            break;
          case 2:
            s.params = r.Params.decode(w, w.uint32());
            break;
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {
        authority: (0, R.isSet)(n.authority) ? String(n.authority) : "",
        params: (0, R.isSet)(n.params) ? r.Params.fromJSON(n.params) : void 0
      };
    },
    toJSON(n) {
      const y = {};
      return n.authority !== void 0 && (y.authority = n.authority), n.params !== void 0 && (y.params = n.params ? r.Params.toJSON(n.params) : void 0), y;
    },
    fromPartial(n) {
      const y = _();
      return y.authority = n.authority ?? "", y.params = n.params !== void 0 && n.params !== null ? r.Params.fromPartial(n.params) : void 0, y;
    }
  };
  function I() {
    return {};
  }
  e.MsgUpdateParamsResponse = {
    encode(n, y = T.Writer.create()) {
      return y;
    },
    decode(n, y) {
      const w = n instanceof T.Reader ? n : new T.Reader(n);
      let M = y === void 0 ? w.len : w.pos + y;
      const s = I();
      for (; w.pos < M; ) {
        const c = w.uint32();
        switch (c >>> 3) {
          default:
            w.skipType(c & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      return {};
    },
    toJSON(n) {
      return {};
    },
    fromPartial(n) {
      return I();
    }
  };
  class W {
    constructor(y) {
      this.rpc = y, this.CreateValidator = this.CreateValidator.bind(this), this.EditValidator = this.EditValidator.bind(this), this.Delegate = this.Delegate.bind(this), this.BeginRedelegate = this.BeginRedelegate.bind(this), this.Undelegate = this.Undelegate.bind(this), this.CancelUnbondingDelegation = this.CancelUnbondingDelegation.bind(this), this.UpdateParams = this.UpdateParams.bind(this);
    }
    CreateValidator(y) {
      const w = e.MsgCreateValidator.encode(y).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "CreateValidator", w).then((M) => e.MsgCreateValidatorResponse.decode(new T.Reader(M)));
    }
    EditValidator(y) {
      const w = e.MsgEditValidator.encode(y).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "EditValidator", w).then((M) => e.MsgEditValidatorResponse.decode(new T.Reader(M)));
    }
    Delegate(y) {
      const w = e.MsgDelegate.encode(y).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "Delegate", w).then((M) => e.MsgDelegateResponse.decode(new T.Reader(M)));
    }
    BeginRedelegate(y) {
      const w = e.MsgBeginRedelegate.encode(y).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "BeginRedelegate", w).then((M) => e.MsgBeginRedelegateResponse.decode(new T.Reader(M)));
    }
    Undelegate(y) {
      const w = e.MsgUndelegate.encode(y).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "Undelegate", w).then((M) => e.MsgUndelegateResponse.decode(new T.Reader(M)));
    }
    CancelUnbondingDelegation(y) {
      const w = e.MsgCancelUnbondingDelegation.encode(y).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "CancelUnbondingDelegation", w).then((M) => e.MsgCancelUnbondingDelegationResponse.decode(new T.Reader(M)));
    }
    UpdateParams(y) {
      const w = e.MsgUpdateParams.encode(y).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "UpdateParams", w).then((M) => e.MsgUpdateParamsResponse.decode(new T.Reader(M)));
    }
  }
  e.MsgClientImpl = W;
})(es);
Object.defineProperty(Qe, "__esModule", { value: !0 });
Qe.isMsgUndelegateEncodeObject = Qe.isMsgEditValidatorEncodeObject = Qe.isMsgDelegateEncodeObject = Qe.isMsgCreateValidatorEncodeObject = Qe.isMsgBeginRedelegateEncodeObject = Qe.stakingTypes = void 0;
const Qn = es;
Qe.stakingTypes = [
  ["/cosmos.staking.v1beta1.MsgBeginRedelegate", Qn.MsgBeginRedelegate],
  ["/cosmos.staking.v1beta1.MsgCreateValidator", Qn.MsgCreateValidator],
  ["/cosmos.staking.v1beta1.MsgDelegate", Qn.MsgDelegate],
  ["/cosmos.staking.v1beta1.MsgEditValidator", Qn.MsgEditValidator],
  ["/cosmos.staking.v1beta1.MsgUndelegate", Qn.MsgUndelegate]
];
function gg(e) {
  return e.typeUrl === "/cosmos.staking.v1beta1.MsgBeginRedelegate";
}
Qe.isMsgBeginRedelegateEncodeObject = gg;
function hg(e) {
  return e.typeUrl === "/cosmos.staking.v1beta1.MsgCreateValidator";
}
Qe.isMsgCreateValidatorEncodeObject = hg;
function vg(e) {
  return e.typeUrl === "/cosmos.staking.v1beta1.MsgDelegate";
}
Qe.isMsgDelegateEncodeObject = vg;
function yg(e) {
  return e.typeUrl === "/cosmos.staking.v1beta1.MsgEditValidator";
}
Qe.isMsgEditValidatorEncodeObject = yg;
function Sg(e) {
  return e.typeUrl === "/cosmos.staking.v1beta1.MsgUndelegate";
}
Qe.isMsgUndelegateEncodeObject = Sg;
var hr = {}, Bc = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(i, P, g, v) {
    v === void 0 && (v = g);
    var N = Object.getOwnPropertyDescriptor(P, g);
    (!N || ("get" in N ? !P.__esModule : N.writable || N.configurable)) && (N = { enumerable: !0, get: function() {
      return P[g];
    } }), Object.defineProperty(i, v, N);
  } : function(i, P, g, v) {
    v === void 0 && (v = g), i[v] = P[g];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(i, P) {
    Object.defineProperty(i, "default", { enumerable: !0, value: P });
  } : function(i, P) {
    i.default = P;
  }), u = Q && Q.__importStar || function(i) {
    if (i && i.__esModule)
      return i;
    var P = {};
    if (i != null)
      for (var g in i)
        g !== "default" && Object.prototype.hasOwnProperty.call(i, g) && o(P, i, g);
    return t(P, i), P;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryParamsResponse = e.QueryParamsRequest = e.QueryPoolResponse = e.QueryPoolRequest = e.QueryHistoricalInfoResponse = e.QueryHistoricalInfoRequest = e.QueryDelegatorValidatorResponse = e.QueryDelegatorValidatorRequest = e.QueryDelegatorValidatorsResponse = e.QueryDelegatorValidatorsRequest = e.QueryRedelegationsResponse = e.QueryRedelegationsRequest = e.QueryDelegatorUnbondingDelegationsResponse = e.QueryDelegatorUnbondingDelegationsRequest = e.QueryDelegatorDelegationsResponse = e.QueryDelegatorDelegationsRequest = e.QueryUnbondingDelegationResponse = e.QueryUnbondingDelegationRequest = e.QueryDelegationResponse = e.QueryDelegationRequest = e.QueryValidatorUnbondingDelegationsResponse = e.QueryValidatorUnbondingDelegationsRequest = e.QueryValidatorDelegationsResponse = e.QueryValidatorDelegationsRequest = e.QueryValidatorResponse = e.QueryValidatorRequest = e.QueryValidatorsResponse = e.QueryValidatorsRequest = e.protobufPackage = void 0;
  const r = be, m = ts, f = ie, b = u(re);
  e.protobufPackage = "cosmos.staking.v1beta1";
  function R() {
    return {
      status: "",
      pagination: void 0
    };
  }
  e.QueryValidatorsRequest = {
    encode(i, P = b.Writer.create()) {
      return i.status !== "" && P.uint32(10).string(i.status), i.pagination !== void 0 && r.PageRequest.encode(i.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = R();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.status = g.string();
            break;
          case 2:
            N.pagination = r.PageRequest.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        status: (0, f.isSet)(i.status) ? String(i.status) : "",
        pagination: (0, f.isSet)(i.pagination) ? r.PageRequest.fromJSON(i.pagination) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.status !== void 0 && (P.status = i.status), i.pagination !== void 0 && (P.pagination = i.pagination ? r.PageRequest.toJSON(i.pagination) : void 0), P;
    },
    fromPartial(i) {
      const P = R();
      return P.status = i.status ?? "", P.pagination = i.pagination !== void 0 && i.pagination !== null ? r.PageRequest.fromPartial(i.pagination) : void 0, P;
    }
  };
  function T() {
    return {
      validators: [],
      pagination: void 0
    };
  }
  e.QueryValidatorsResponse = {
    encode(i, P = b.Writer.create()) {
      for (const g of i.validators)
        m.Validator.encode(g, P.uint32(10).fork()).ldelim();
      return i.pagination !== void 0 && r.PageResponse.encode(i.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = T();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.validators.push(m.Validator.decode(g, g.uint32()));
            break;
          case 2:
            N.pagination = r.PageResponse.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        validators: Array.isArray(i == null ? void 0 : i.validators) ? i.validators.map((P) => m.Validator.fromJSON(P)) : [],
        pagination: (0, f.isSet)(i.pagination) ? r.PageResponse.fromJSON(i.pagination) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.validators ? P.validators = i.validators.map((g) => g ? m.Validator.toJSON(g) : void 0) : P.validators = [], i.pagination !== void 0 && (P.pagination = i.pagination ? r.PageResponse.toJSON(i.pagination) : void 0), P;
    },
    fromPartial(i) {
      var P;
      const g = T();
      return g.validators = ((P = i.validators) == null ? void 0 : P.map((v) => m.Validator.fromPartial(v))) || [], g.pagination = i.pagination !== void 0 && i.pagination !== null ? r.PageResponse.fromPartial(i.pagination) : void 0, g;
    }
  };
  function V() {
    return {
      validatorAddr: ""
    };
  }
  e.QueryValidatorRequest = {
    encode(i, P = b.Writer.create()) {
      return i.validatorAddr !== "" && P.uint32(10).string(i.validatorAddr), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = V();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.validatorAddr = g.string();
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        validatorAddr: (0, f.isSet)(i.validatorAddr) ? String(i.validatorAddr) : ""
      };
    },
    toJSON(i) {
      const P = {};
      return i.validatorAddr !== void 0 && (P.validatorAddr = i.validatorAddr), P;
    },
    fromPartial(i) {
      const P = V();
      return P.validatorAddr = i.validatorAddr ?? "", P;
    }
  };
  function D() {
    return {
      validator: void 0
    };
  }
  e.QueryValidatorResponse = {
    encode(i, P = b.Writer.create()) {
      return i.validator !== void 0 && m.Validator.encode(i.validator, P.uint32(10).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = D();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.validator = m.Validator.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        validator: (0, f.isSet)(i.validator) ? m.Validator.fromJSON(i.validator) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.validator !== void 0 && (P.validator = i.validator ? m.Validator.toJSON(i.validator) : void 0), P;
    },
    fromPartial(i) {
      const P = D();
      return P.validator = i.validator !== void 0 && i.validator !== null ? m.Validator.fromPartial(i.validator) : void 0, P;
    }
  };
  function B() {
    return {
      validatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryValidatorDelegationsRequest = {
    encode(i, P = b.Writer.create()) {
      return i.validatorAddr !== "" && P.uint32(10).string(i.validatorAddr), i.pagination !== void 0 && r.PageRequest.encode(i.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = B();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.validatorAddr = g.string();
            break;
          case 2:
            N.pagination = r.PageRequest.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        validatorAddr: (0, f.isSet)(i.validatorAddr) ? String(i.validatorAddr) : "",
        pagination: (0, f.isSet)(i.pagination) ? r.PageRequest.fromJSON(i.pagination) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.validatorAddr !== void 0 && (P.validatorAddr = i.validatorAddr), i.pagination !== void 0 && (P.pagination = i.pagination ? r.PageRequest.toJSON(i.pagination) : void 0), P;
    },
    fromPartial(i) {
      const P = B();
      return P.validatorAddr = i.validatorAddr ?? "", P.pagination = i.pagination !== void 0 && i.pagination !== null ? r.PageRequest.fromPartial(i.pagination) : void 0, P;
    }
  };
  function U() {
    return {
      delegationResponses: [],
      pagination: void 0
    };
  }
  e.QueryValidatorDelegationsResponse = {
    encode(i, P = b.Writer.create()) {
      for (const g of i.delegationResponses)
        m.DelegationResponse.encode(g, P.uint32(10).fork()).ldelim();
      return i.pagination !== void 0 && r.PageResponse.encode(i.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = U();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.delegationResponses.push(m.DelegationResponse.decode(g, g.uint32()));
            break;
          case 2:
            N.pagination = r.PageResponse.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        delegationResponses: Array.isArray(i == null ? void 0 : i.delegationResponses) ? i.delegationResponses.map((P) => m.DelegationResponse.fromJSON(P)) : [],
        pagination: (0, f.isSet)(i.pagination) ? r.PageResponse.fromJSON(i.pagination) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.delegationResponses ? P.delegationResponses = i.delegationResponses.map((g) => g ? m.DelegationResponse.toJSON(g) : void 0) : P.delegationResponses = [], i.pagination !== void 0 && (P.pagination = i.pagination ? r.PageResponse.toJSON(i.pagination) : void 0), P;
    },
    fromPartial(i) {
      var P;
      const g = U();
      return g.delegationResponses = ((P = i.delegationResponses) == null ? void 0 : P.map((v) => m.DelegationResponse.fromPartial(v))) || [], g.pagination = i.pagination !== void 0 && i.pagination !== null ? r.PageResponse.fromPartial(i.pagination) : void 0, g;
    }
  };
  function C() {
    return {
      validatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryValidatorUnbondingDelegationsRequest = {
    encode(i, P = b.Writer.create()) {
      return i.validatorAddr !== "" && P.uint32(10).string(i.validatorAddr), i.pagination !== void 0 && r.PageRequest.encode(i.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = C();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.validatorAddr = g.string();
            break;
          case 2:
            N.pagination = r.PageRequest.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        validatorAddr: (0, f.isSet)(i.validatorAddr) ? String(i.validatorAddr) : "",
        pagination: (0, f.isSet)(i.pagination) ? r.PageRequest.fromJSON(i.pagination) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.validatorAddr !== void 0 && (P.validatorAddr = i.validatorAddr), i.pagination !== void 0 && (P.pagination = i.pagination ? r.PageRequest.toJSON(i.pagination) : void 0), P;
    },
    fromPartial(i) {
      const P = C();
      return P.validatorAddr = i.validatorAddr ?? "", P.pagination = i.pagination !== void 0 && i.pagination !== null ? r.PageRequest.fromPartial(i.pagination) : void 0, P;
    }
  };
  function l() {
    return {
      unbondingResponses: [],
      pagination: void 0
    };
  }
  e.QueryValidatorUnbondingDelegationsResponse = {
    encode(i, P = b.Writer.create()) {
      for (const g of i.unbondingResponses)
        m.UnbondingDelegation.encode(g, P.uint32(10).fork()).ldelim();
      return i.pagination !== void 0 && r.PageResponse.encode(i.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = l();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.unbondingResponses.push(m.UnbondingDelegation.decode(g, g.uint32()));
            break;
          case 2:
            N.pagination = r.PageResponse.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        unbondingResponses: Array.isArray(i == null ? void 0 : i.unbondingResponses) ? i.unbondingResponses.map((P) => m.UnbondingDelegation.fromJSON(P)) : [],
        pagination: (0, f.isSet)(i.pagination) ? r.PageResponse.fromJSON(i.pagination) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.unbondingResponses ? P.unbondingResponses = i.unbondingResponses.map((g) => g ? m.UnbondingDelegation.toJSON(g) : void 0) : P.unbondingResponses = [], i.pagination !== void 0 && (P.pagination = i.pagination ? r.PageResponse.toJSON(i.pagination) : void 0), P;
    },
    fromPartial(i) {
      var P;
      const g = l();
      return g.unbondingResponses = ((P = i.unbondingResponses) == null ? void 0 : P.map((v) => m.UnbondingDelegation.fromPartial(v))) || [], g.pagination = i.pagination !== void 0 && i.pagination !== null ? r.PageResponse.fromPartial(i.pagination) : void 0, g;
    }
  };
  function S() {
    return {
      delegatorAddr: "",
      validatorAddr: ""
    };
  }
  e.QueryDelegationRequest = {
    encode(i, P = b.Writer.create()) {
      return i.delegatorAddr !== "" && P.uint32(10).string(i.delegatorAddr), i.validatorAddr !== "" && P.uint32(18).string(i.validatorAddr), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = S();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.delegatorAddr = g.string();
            break;
          case 2:
            N.validatorAddr = g.string();
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        delegatorAddr: (0, f.isSet)(i.delegatorAddr) ? String(i.delegatorAddr) : "",
        validatorAddr: (0, f.isSet)(i.validatorAddr) ? String(i.validatorAddr) : ""
      };
    },
    toJSON(i) {
      const P = {};
      return i.delegatorAddr !== void 0 && (P.delegatorAddr = i.delegatorAddr), i.validatorAddr !== void 0 && (P.validatorAddr = i.validatorAddr), P;
    },
    fromPartial(i) {
      const P = S();
      return P.delegatorAddr = i.delegatorAddr ?? "", P.validatorAddr = i.validatorAddr ?? "", P;
    }
  };
  function A() {
    return {
      delegationResponse: void 0
    };
  }
  e.QueryDelegationResponse = {
    encode(i, P = b.Writer.create()) {
      return i.delegationResponse !== void 0 && m.DelegationResponse.encode(i.delegationResponse, P.uint32(10).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = A();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.delegationResponse = m.DelegationResponse.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        delegationResponse: (0, f.isSet)(i.delegationResponse) ? m.DelegationResponse.fromJSON(i.delegationResponse) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.delegationResponse !== void 0 && (P.delegationResponse = i.delegationResponse ? m.DelegationResponse.toJSON(i.delegationResponse) : void 0), P;
    },
    fromPartial(i) {
      const P = A();
      return P.delegationResponse = i.delegationResponse !== void 0 && i.delegationResponse !== null ? m.DelegationResponse.fromPartial(i.delegationResponse) : void 0, P;
    }
  };
  function d() {
    return {
      delegatorAddr: "",
      validatorAddr: ""
    };
  }
  e.QueryUnbondingDelegationRequest = {
    encode(i, P = b.Writer.create()) {
      return i.delegatorAddr !== "" && P.uint32(10).string(i.delegatorAddr), i.validatorAddr !== "" && P.uint32(18).string(i.validatorAddr), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = d();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.delegatorAddr = g.string();
            break;
          case 2:
            N.validatorAddr = g.string();
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        delegatorAddr: (0, f.isSet)(i.delegatorAddr) ? String(i.delegatorAddr) : "",
        validatorAddr: (0, f.isSet)(i.validatorAddr) ? String(i.validatorAddr) : ""
      };
    },
    toJSON(i) {
      const P = {};
      return i.delegatorAddr !== void 0 && (P.delegatorAddr = i.delegatorAddr), i.validatorAddr !== void 0 && (P.validatorAddr = i.validatorAddr), P;
    },
    fromPartial(i) {
      const P = d();
      return P.delegatorAddr = i.delegatorAddr ?? "", P.validatorAddr = i.validatorAddr ?? "", P;
    }
  };
  function p() {
    return {
      unbond: void 0
    };
  }
  e.QueryUnbondingDelegationResponse = {
    encode(i, P = b.Writer.create()) {
      return i.unbond !== void 0 && m.UnbondingDelegation.encode(i.unbond, P.uint32(10).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = p();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.unbond = m.UnbondingDelegation.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        unbond: (0, f.isSet)(i.unbond) ? m.UnbondingDelegation.fromJSON(i.unbond) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.unbond !== void 0 && (P.unbond = i.unbond ? m.UnbondingDelegation.toJSON(i.unbond) : void 0), P;
    },
    fromPartial(i) {
      const P = p();
      return P.unbond = i.unbond !== void 0 && i.unbond !== null ? m.UnbondingDelegation.fromPartial(i.unbond) : void 0, P;
    }
  };
  function h() {
    return {
      delegatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryDelegatorDelegationsRequest = {
    encode(i, P = b.Writer.create()) {
      return i.delegatorAddr !== "" && P.uint32(10).string(i.delegatorAddr), i.pagination !== void 0 && r.PageRequest.encode(i.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = h();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.delegatorAddr = g.string();
            break;
          case 2:
            N.pagination = r.PageRequest.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        delegatorAddr: (0, f.isSet)(i.delegatorAddr) ? String(i.delegatorAddr) : "",
        pagination: (0, f.isSet)(i.pagination) ? r.PageRequest.fromJSON(i.pagination) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.delegatorAddr !== void 0 && (P.delegatorAddr = i.delegatorAddr), i.pagination !== void 0 && (P.pagination = i.pagination ? r.PageRequest.toJSON(i.pagination) : void 0), P;
    },
    fromPartial(i) {
      const P = h();
      return P.delegatorAddr = i.delegatorAddr ?? "", P.pagination = i.pagination !== void 0 && i.pagination !== null ? r.PageRequest.fromPartial(i.pagination) : void 0, P;
    }
  };
  function x() {
    return {
      delegationResponses: [],
      pagination: void 0
    };
  }
  e.QueryDelegatorDelegationsResponse = {
    encode(i, P = b.Writer.create()) {
      for (const g of i.delegationResponses)
        m.DelegationResponse.encode(g, P.uint32(10).fork()).ldelim();
      return i.pagination !== void 0 && r.PageResponse.encode(i.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = x();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.delegationResponses.push(m.DelegationResponse.decode(g, g.uint32()));
            break;
          case 2:
            N.pagination = r.PageResponse.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        delegationResponses: Array.isArray(i == null ? void 0 : i.delegationResponses) ? i.delegationResponses.map((P) => m.DelegationResponse.fromJSON(P)) : [],
        pagination: (0, f.isSet)(i.pagination) ? r.PageResponse.fromJSON(i.pagination) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.delegationResponses ? P.delegationResponses = i.delegationResponses.map((g) => g ? m.DelegationResponse.toJSON(g) : void 0) : P.delegationResponses = [], i.pagination !== void 0 && (P.pagination = i.pagination ? r.PageResponse.toJSON(i.pagination) : void 0), P;
    },
    fromPartial(i) {
      var P;
      const g = x();
      return g.delegationResponses = ((P = i.delegationResponses) == null ? void 0 : P.map((v) => m.DelegationResponse.fromPartial(v))) || [], g.pagination = i.pagination !== void 0 && i.pagination !== null ? r.PageResponse.fromPartial(i.pagination) : void 0, g;
    }
  };
  function _() {
    return {
      delegatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryDelegatorUnbondingDelegationsRequest = {
    encode(i, P = b.Writer.create()) {
      return i.delegatorAddr !== "" && P.uint32(10).string(i.delegatorAddr), i.pagination !== void 0 && r.PageRequest.encode(i.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = _();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.delegatorAddr = g.string();
            break;
          case 2:
            N.pagination = r.PageRequest.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        delegatorAddr: (0, f.isSet)(i.delegatorAddr) ? String(i.delegatorAddr) : "",
        pagination: (0, f.isSet)(i.pagination) ? r.PageRequest.fromJSON(i.pagination) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.delegatorAddr !== void 0 && (P.delegatorAddr = i.delegatorAddr), i.pagination !== void 0 && (P.pagination = i.pagination ? r.PageRequest.toJSON(i.pagination) : void 0), P;
    },
    fromPartial(i) {
      const P = _();
      return P.delegatorAddr = i.delegatorAddr ?? "", P.pagination = i.pagination !== void 0 && i.pagination !== null ? r.PageRequest.fromPartial(i.pagination) : void 0, P;
    }
  };
  function I() {
    return {
      unbondingResponses: [],
      pagination: void 0
    };
  }
  e.QueryDelegatorUnbondingDelegationsResponse = {
    encode(i, P = b.Writer.create()) {
      for (const g of i.unbondingResponses)
        m.UnbondingDelegation.encode(g, P.uint32(10).fork()).ldelim();
      return i.pagination !== void 0 && r.PageResponse.encode(i.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = I();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.unbondingResponses.push(m.UnbondingDelegation.decode(g, g.uint32()));
            break;
          case 2:
            N.pagination = r.PageResponse.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        unbondingResponses: Array.isArray(i == null ? void 0 : i.unbondingResponses) ? i.unbondingResponses.map((P) => m.UnbondingDelegation.fromJSON(P)) : [],
        pagination: (0, f.isSet)(i.pagination) ? r.PageResponse.fromJSON(i.pagination) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.unbondingResponses ? P.unbondingResponses = i.unbondingResponses.map((g) => g ? m.UnbondingDelegation.toJSON(g) : void 0) : P.unbondingResponses = [], i.pagination !== void 0 && (P.pagination = i.pagination ? r.PageResponse.toJSON(i.pagination) : void 0), P;
    },
    fromPartial(i) {
      var P;
      const g = I();
      return g.unbondingResponses = ((P = i.unbondingResponses) == null ? void 0 : P.map((v) => m.UnbondingDelegation.fromPartial(v))) || [], g.pagination = i.pagination !== void 0 && i.pagination !== null ? r.PageResponse.fromPartial(i.pagination) : void 0, g;
    }
  };
  function W() {
    return {
      delegatorAddr: "",
      srcValidatorAddr: "",
      dstValidatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryRedelegationsRequest = {
    encode(i, P = b.Writer.create()) {
      return i.delegatorAddr !== "" && P.uint32(10).string(i.delegatorAddr), i.srcValidatorAddr !== "" && P.uint32(18).string(i.srcValidatorAddr), i.dstValidatorAddr !== "" && P.uint32(26).string(i.dstValidatorAddr), i.pagination !== void 0 && r.PageRequest.encode(i.pagination, P.uint32(34).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = W();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.delegatorAddr = g.string();
            break;
          case 2:
            N.srcValidatorAddr = g.string();
            break;
          case 3:
            N.dstValidatorAddr = g.string();
            break;
          case 4:
            N.pagination = r.PageRequest.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        delegatorAddr: (0, f.isSet)(i.delegatorAddr) ? String(i.delegatorAddr) : "",
        srcValidatorAddr: (0, f.isSet)(i.srcValidatorAddr) ? String(i.srcValidatorAddr) : "",
        dstValidatorAddr: (0, f.isSet)(i.dstValidatorAddr) ? String(i.dstValidatorAddr) : "",
        pagination: (0, f.isSet)(i.pagination) ? r.PageRequest.fromJSON(i.pagination) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.delegatorAddr !== void 0 && (P.delegatorAddr = i.delegatorAddr), i.srcValidatorAddr !== void 0 && (P.srcValidatorAddr = i.srcValidatorAddr), i.dstValidatorAddr !== void 0 && (P.dstValidatorAddr = i.dstValidatorAddr), i.pagination !== void 0 && (P.pagination = i.pagination ? r.PageRequest.toJSON(i.pagination) : void 0), P;
    },
    fromPartial(i) {
      const P = W();
      return P.delegatorAddr = i.delegatorAddr ?? "", P.srcValidatorAddr = i.srcValidatorAddr ?? "", P.dstValidatorAddr = i.dstValidatorAddr ?? "", P.pagination = i.pagination !== void 0 && i.pagination !== null ? r.PageRequest.fromPartial(i.pagination) : void 0, P;
    }
  };
  function n() {
    return {
      redelegationResponses: [],
      pagination: void 0
    };
  }
  e.QueryRedelegationsResponse = {
    encode(i, P = b.Writer.create()) {
      for (const g of i.redelegationResponses)
        m.RedelegationResponse.encode(g, P.uint32(10).fork()).ldelim();
      return i.pagination !== void 0 && r.PageResponse.encode(i.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = n();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.redelegationResponses.push(m.RedelegationResponse.decode(g, g.uint32()));
            break;
          case 2:
            N.pagination = r.PageResponse.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        redelegationResponses: Array.isArray(i == null ? void 0 : i.redelegationResponses) ? i.redelegationResponses.map((P) => m.RedelegationResponse.fromJSON(P)) : [],
        pagination: (0, f.isSet)(i.pagination) ? r.PageResponse.fromJSON(i.pagination) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.redelegationResponses ? P.redelegationResponses = i.redelegationResponses.map((g) => g ? m.RedelegationResponse.toJSON(g) : void 0) : P.redelegationResponses = [], i.pagination !== void 0 && (P.pagination = i.pagination ? r.PageResponse.toJSON(i.pagination) : void 0), P;
    },
    fromPartial(i) {
      var P;
      const g = n();
      return g.redelegationResponses = ((P = i.redelegationResponses) == null ? void 0 : P.map((v) => m.RedelegationResponse.fromPartial(v))) || [], g.pagination = i.pagination !== void 0 && i.pagination !== null ? r.PageResponse.fromPartial(i.pagination) : void 0, g;
    }
  };
  function y() {
    return {
      delegatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryDelegatorValidatorsRequest = {
    encode(i, P = b.Writer.create()) {
      return i.delegatorAddr !== "" && P.uint32(10).string(i.delegatorAddr), i.pagination !== void 0 && r.PageRequest.encode(i.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = y();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.delegatorAddr = g.string();
            break;
          case 2:
            N.pagination = r.PageRequest.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        delegatorAddr: (0, f.isSet)(i.delegatorAddr) ? String(i.delegatorAddr) : "",
        pagination: (0, f.isSet)(i.pagination) ? r.PageRequest.fromJSON(i.pagination) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.delegatorAddr !== void 0 && (P.delegatorAddr = i.delegatorAddr), i.pagination !== void 0 && (P.pagination = i.pagination ? r.PageRequest.toJSON(i.pagination) : void 0), P;
    },
    fromPartial(i) {
      const P = y();
      return P.delegatorAddr = i.delegatorAddr ?? "", P.pagination = i.pagination !== void 0 && i.pagination !== null ? r.PageRequest.fromPartial(i.pagination) : void 0, P;
    }
  };
  function w() {
    return {
      validators: [],
      pagination: void 0
    };
  }
  e.QueryDelegatorValidatorsResponse = {
    encode(i, P = b.Writer.create()) {
      for (const g of i.validators)
        m.Validator.encode(g, P.uint32(10).fork()).ldelim();
      return i.pagination !== void 0 && r.PageResponse.encode(i.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = w();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.validators.push(m.Validator.decode(g, g.uint32()));
            break;
          case 2:
            N.pagination = r.PageResponse.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        validators: Array.isArray(i == null ? void 0 : i.validators) ? i.validators.map((P) => m.Validator.fromJSON(P)) : [],
        pagination: (0, f.isSet)(i.pagination) ? r.PageResponse.fromJSON(i.pagination) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.validators ? P.validators = i.validators.map((g) => g ? m.Validator.toJSON(g) : void 0) : P.validators = [], i.pagination !== void 0 && (P.pagination = i.pagination ? r.PageResponse.toJSON(i.pagination) : void 0), P;
    },
    fromPartial(i) {
      var P;
      const g = w();
      return g.validators = ((P = i.validators) == null ? void 0 : P.map((v) => m.Validator.fromPartial(v))) || [], g.pagination = i.pagination !== void 0 && i.pagination !== null ? r.PageResponse.fromPartial(i.pagination) : void 0, g;
    }
  };
  function M() {
    return {
      delegatorAddr: "",
      validatorAddr: ""
    };
  }
  e.QueryDelegatorValidatorRequest = {
    encode(i, P = b.Writer.create()) {
      return i.delegatorAddr !== "" && P.uint32(10).string(i.delegatorAddr), i.validatorAddr !== "" && P.uint32(18).string(i.validatorAddr), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = M();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.delegatorAddr = g.string();
            break;
          case 2:
            N.validatorAddr = g.string();
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        delegatorAddr: (0, f.isSet)(i.delegatorAddr) ? String(i.delegatorAddr) : "",
        validatorAddr: (0, f.isSet)(i.validatorAddr) ? String(i.validatorAddr) : ""
      };
    },
    toJSON(i) {
      const P = {};
      return i.delegatorAddr !== void 0 && (P.delegatorAddr = i.delegatorAddr), i.validatorAddr !== void 0 && (P.validatorAddr = i.validatorAddr), P;
    },
    fromPartial(i) {
      const P = M();
      return P.delegatorAddr = i.delegatorAddr ?? "", P.validatorAddr = i.validatorAddr ?? "", P;
    }
  };
  function s() {
    return {
      validator: void 0
    };
  }
  e.QueryDelegatorValidatorResponse = {
    encode(i, P = b.Writer.create()) {
      return i.validator !== void 0 && m.Validator.encode(i.validator, P.uint32(10).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = s();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.validator = m.Validator.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        validator: (0, f.isSet)(i.validator) ? m.Validator.fromJSON(i.validator) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.validator !== void 0 && (P.validator = i.validator ? m.Validator.toJSON(i.validator) : void 0), P;
    },
    fromPartial(i) {
      const P = s();
      return P.validator = i.validator !== void 0 && i.validator !== null ? m.Validator.fromPartial(i.validator) : void 0, P;
    }
  };
  function c() {
    return {
      height: f.Long.ZERO
    };
  }
  e.QueryHistoricalInfoRequest = {
    encode(i, P = b.Writer.create()) {
      return i.height.isZero() || P.uint32(8).int64(i.height), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = c();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.height = g.int64();
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        height: (0, f.isSet)(i.height) ? f.Long.fromValue(i.height) : f.Long.ZERO
      };
    },
    toJSON(i) {
      const P = {};
      return i.height !== void 0 && (P.height = (i.height || f.Long.ZERO).toString()), P;
    },
    fromPartial(i) {
      const P = c();
      return P.height = i.height !== void 0 && i.height !== null ? f.Long.fromValue(i.height) : f.Long.ZERO, P;
    }
  };
  function E() {
    return {
      hist: void 0
    };
  }
  e.QueryHistoricalInfoResponse = {
    encode(i, P = b.Writer.create()) {
      return i.hist !== void 0 && m.HistoricalInfo.encode(i.hist, P.uint32(10).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = E();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.hist = m.HistoricalInfo.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        hist: (0, f.isSet)(i.hist) ? m.HistoricalInfo.fromJSON(i.hist) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.hist !== void 0 && (P.hist = i.hist ? m.HistoricalInfo.toJSON(i.hist) : void 0), P;
    },
    fromPartial(i) {
      const P = E();
      return P.hist = i.hist !== void 0 && i.hist !== null ? m.HistoricalInfo.fromPartial(i.hist) : void 0, P;
    }
  };
  function k() {
    return {};
  }
  e.QueryPoolRequest = {
    encode(i, P = b.Writer.create()) {
      return P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = k();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {};
    },
    toJSON(i) {
      return {};
    },
    fromPartial(i) {
      return k();
    }
  };
  function O() {
    return {
      pool: void 0
    };
  }
  e.QueryPoolResponse = {
    encode(i, P = b.Writer.create()) {
      return i.pool !== void 0 && m.Pool.encode(i.pool, P.uint32(10).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = O();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.pool = m.Pool.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        pool: (0, f.isSet)(i.pool) ? m.Pool.fromJSON(i.pool) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.pool !== void 0 && (P.pool = i.pool ? m.Pool.toJSON(i.pool) : void 0), P;
    },
    fromPartial(i) {
      const P = O();
      return P.pool = i.pool !== void 0 && i.pool !== null ? m.Pool.fromPartial(i.pool) : void 0, P;
    }
  };
  function L() {
    return {};
  }
  e.QueryParamsRequest = {
    encode(i, P = b.Writer.create()) {
      return P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = L();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {};
    },
    toJSON(i) {
      return {};
    },
    fromPartial(i) {
      return L();
    }
  };
  function Z() {
    return {
      params: void 0
    };
  }
  e.QueryParamsResponse = {
    encode(i, P = b.Writer.create()) {
      return i.params !== void 0 && m.Params.encode(i.params, P.uint32(10).fork()).ldelim(), P;
    },
    decode(i, P) {
      const g = i instanceof b.Reader ? i : new b.Reader(i);
      let v = P === void 0 ? g.len : g.pos + P;
      const N = Z();
      for (; g.pos < v; ) {
        const q = g.uint32();
        switch (q >>> 3) {
          case 1:
            N.params = m.Params.decode(g, g.uint32());
            break;
          default:
            g.skipType(q & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(i) {
      return {
        params: (0, f.isSet)(i.params) ? m.Params.fromJSON(i.params) : void 0
      };
    },
    toJSON(i) {
      const P = {};
      return i.params !== void 0 && (P.params = i.params ? m.Params.toJSON(i.params) : void 0), P;
    },
    fromPartial(i) {
      const P = Z();
      return P.params = i.params !== void 0 && i.params !== null ? m.Params.fromPartial(i.params) : void 0, P;
    }
  };
  class j {
    constructor(P) {
      this.rpc = P, this.Validators = this.Validators.bind(this), this.Validator = this.Validator.bind(this), this.ValidatorDelegations = this.ValidatorDelegations.bind(this), this.ValidatorUnbondingDelegations = this.ValidatorUnbondingDelegations.bind(this), this.Delegation = this.Delegation.bind(this), this.UnbondingDelegation = this.UnbondingDelegation.bind(this), this.DelegatorDelegations = this.DelegatorDelegations.bind(this), this.DelegatorUnbondingDelegations = this.DelegatorUnbondingDelegations.bind(this), this.Redelegations = this.Redelegations.bind(this), this.DelegatorValidators = this.DelegatorValidators.bind(this), this.DelegatorValidator = this.DelegatorValidator.bind(this), this.HistoricalInfo = this.HistoricalInfo.bind(this), this.Pool = this.Pool.bind(this), this.Params = this.Params.bind(this);
    }
    Validators(P) {
      const g = e.QueryValidatorsRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Validators", g).then((v) => e.QueryValidatorsResponse.decode(new b.Reader(v)));
    }
    Validator(P) {
      const g = e.QueryValidatorRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Validator", g).then((v) => e.QueryValidatorResponse.decode(new b.Reader(v)));
    }
    ValidatorDelegations(P) {
      const g = e.QueryValidatorDelegationsRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorDelegations", g).then((v) => e.QueryValidatorDelegationsResponse.decode(new b.Reader(v)));
    }
    ValidatorUnbondingDelegations(P) {
      const g = e.QueryValidatorUnbondingDelegationsRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorUnbondingDelegations", g).then((v) => e.QueryValidatorUnbondingDelegationsResponse.decode(new b.Reader(v)));
    }
    Delegation(P) {
      const g = e.QueryDelegationRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Delegation", g).then((v) => e.QueryDelegationResponse.decode(new b.Reader(v)));
    }
    UnbondingDelegation(P) {
      const g = e.QueryUnbondingDelegationRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "UnbondingDelegation", g).then((v) => e.QueryUnbondingDelegationResponse.decode(new b.Reader(v)));
    }
    DelegatorDelegations(P) {
      const g = e.QueryDelegatorDelegationsRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorDelegations", g).then((v) => e.QueryDelegatorDelegationsResponse.decode(new b.Reader(v)));
    }
    DelegatorUnbondingDelegations(P) {
      const g = e.QueryDelegatorUnbondingDelegationsRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorUnbondingDelegations", g).then((v) => e.QueryDelegatorUnbondingDelegationsResponse.decode(new b.Reader(v)));
    }
    Redelegations(P) {
      const g = e.QueryRedelegationsRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Redelegations", g).then((v) => e.QueryRedelegationsResponse.decode(new b.Reader(v)));
    }
    DelegatorValidators(P) {
      const g = e.QueryDelegatorValidatorsRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidators", g).then((v) => e.QueryDelegatorValidatorsResponse.decode(new b.Reader(v)));
    }
    DelegatorValidator(P) {
      const g = e.QueryDelegatorValidatorRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidator", g).then((v) => e.QueryDelegatorValidatorResponse.decode(new b.Reader(v)));
    }
    HistoricalInfo(P) {
      const g = e.QueryHistoricalInfoRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "HistoricalInfo", g).then((v) => e.QueryHistoricalInfoResponse.decode(new b.Reader(v)));
    }
    Pool(P = {}) {
      const g = e.QueryPoolRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Pool", g).then((v) => e.QueryPoolResponse.decode(new b.Reader(v)));
    }
    Params(P = {}) {
      const g = e.QueryParamsRequest.encode(P).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Params", g).then((v) => e.QueryParamsResponse.decode(new b.Reader(v)));
    }
  }
  e.QueryClientImpl = j;
})(Bc);
var bg = Q && Q.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(hr, "__esModule", { value: !0 });
hr.setupStakingExtension = void 0;
const Og = Bc, kg = bg(Pt), It = Ve;
function Pg(e) {
  const o = (0, It.createProtobufRpcClient)(e), t = new Og.QueryClientImpl(o);
  return {
    staking: {
      delegation: async (u, r) => await t.Delegation({
        delegatorAddr: u,
        validatorAddr: r
      }),
      delegatorDelegations: async (u, r) => await t.DelegatorDelegations({
        delegatorAddr: u,
        pagination: (0, It.createPagination)(r)
      }),
      delegatorUnbondingDelegations: async (u, r) => await t.DelegatorUnbondingDelegations({
        delegatorAddr: u,
        pagination: (0, It.createPagination)(r)
      }),
      delegatorValidator: async (u, r) => await t.DelegatorValidator({
        delegatorAddr: u,
        validatorAddr: r
      }),
      delegatorValidators: async (u, r) => await t.DelegatorValidators({
        delegatorAddr: u,
        pagination: (0, It.createPagination)(r)
      }),
      historicalInfo: async (u) => await t.HistoricalInfo({
        height: kg.default.fromNumber(u, !0)
      }),
      params: async () => await t.Params({}),
      pool: async () => await t.Pool({}),
      redelegations: async (u, r, m, f) => await t.Redelegations({
        delegatorAddr: u,
        srcValidatorAddr: r,
        dstValidatorAddr: m,
        pagination: (0, It.createPagination)(f)
      }),
      unbondingDelegation: async (u, r) => await t.UnbondingDelegation({
        delegatorAddr: u,
        validatorAddr: r
      }),
      validator: async (u) => await t.Validator({ validatorAddr: u }),
      validatorDelegations: async (u, r) => await t.ValidatorDelegations({
        validatorAddr: u,
        pagination: (0, It.createPagination)(r)
      }),
      validators: async (u, r) => await t.Validators({
        status: u,
        pagination: (0, It.createPagination)(r)
      }),
      validatorUnbondingDelegations: async (u, r) => await t.ValidatorUnbondingDelegations({
        validatorAddr: u,
        pagination: (0, It.createPagination)(r)
      })
    }
  };
}
hr.setupStakingExtension = Pg;
var vr = {}, Vc = {}, os = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(d, p, h, x) {
    x === void 0 && (x = h);
    var _ = Object.getOwnPropertyDescriptor(p, h);
    (!_ || ("get" in _ ? !p.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return p[h];
    } }), Object.defineProperty(d, x, _);
  } : function(d, p, h, x) {
    x === void 0 && (x = h), d[x] = p[h];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(d, p) {
    Object.defineProperty(d, "default", { enumerable: !0, value: p });
  } : function(d, p) {
    d.default = p;
  }), u = Q && Q.__importStar || function(d) {
    if (d && d.__esModule)
      return d;
    var p = {};
    if (d != null)
      for (var h in d)
        h !== "default" && Object.prototype.hasOwnProperty.call(d, h) && o(p, d, h);
    return t(p, d), p;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.SearchTxsResult = e.TxMsgData = e.MsgData = e.SimulationResponse = e.Result = e.GasInfo = e.Attribute = e.StringEvent = e.ABCIMessageLog = e.TxResponse = e.protobufPackage = void 0;
  const r = ye, m = ns, f = ie, b = u(re);
  e.protobufPackage = "cosmos.base.abci.v1beta1";
  function R() {
    return {
      height: f.Long.ZERO,
      txhash: "",
      codespace: "",
      code: 0,
      data: "",
      rawLog: "",
      logs: [],
      info: "",
      gasWanted: f.Long.ZERO,
      gasUsed: f.Long.ZERO,
      tx: void 0,
      timestamp: "",
      events: []
    };
  }
  e.TxResponse = {
    encode(d, p = b.Writer.create()) {
      d.height.isZero() || p.uint32(8).int64(d.height), d.txhash !== "" && p.uint32(18).string(d.txhash), d.codespace !== "" && p.uint32(26).string(d.codespace), d.code !== 0 && p.uint32(32).uint32(d.code), d.data !== "" && p.uint32(42).string(d.data), d.rawLog !== "" && p.uint32(50).string(d.rawLog);
      for (const h of d.logs)
        e.ABCIMessageLog.encode(h, p.uint32(58).fork()).ldelim();
      d.info !== "" && p.uint32(66).string(d.info), d.gasWanted.isZero() || p.uint32(72).int64(d.gasWanted), d.gasUsed.isZero() || p.uint32(80).int64(d.gasUsed), d.tx !== void 0 && r.Any.encode(d.tx, p.uint32(90).fork()).ldelim(), d.timestamp !== "" && p.uint32(98).string(d.timestamp);
      for (const h of d.events)
        m.Event.encode(h, p.uint32(106).fork()).ldelim();
      return p;
    },
    decode(d, p) {
      const h = d instanceof b.Reader ? d : new b.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = R();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.height = h.int64();
            break;
          case 2:
            _.txhash = h.string();
            break;
          case 3:
            _.codespace = h.string();
            break;
          case 4:
            _.code = h.uint32();
            break;
          case 5:
            _.data = h.string();
            break;
          case 6:
            _.rawLog = h.string();
            break;
          case 7:
            _.logs.push(e.ABCIMessageLog.decode(h, h.uint32()));
            break;
          case 8:
            _.info = h.string();
            break;
          case 9:
            _.gasWanted = h.int64();
            break;
          case 10:
            _.gasUsed = h.int64();
            break;
          case 11:
            _.tx = r.Any.decode(h, h.uint32());
            break;
          case 12:
            _.timestamp = h.string();
            break;
          case 13:
            _.events.push(m.Event.decode(h, h.uint32()));
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        height: (0, f.isSet)(d.height) ? f.Long.fromValue(d.height) : f.Long.ZERO,
        txhash: (0, f.isSet)(d.txhash) ? String(d.txhash) : "",
        codespace: (0, f.isSet)(d.codespace) ? String(d.codespace) : "",
        code: (0, f.isSet)(d.code) ? Number(d.code) : 0,
        data: (0, f.isSet)(d.data) ? String(d.data) : "",
        rawLog: (0, f.isSet)(d.rawLog) ? String(d.rawLog) : "",
        logs: Array.isArray(d == null ? void 0 : d.logs) ? d.logs.map((p) => e.ABCIMessageLog.fromJSON(p)) : [],
        info: (0, f.isSet)(d.info) ? String(d.info) : "",
        gasWanted: (0, f.isSet)(d.gasWanted) ? f.Long.fromValue(d.gasWanted) : f.Long.ZERO,
        gasUsed: (0, f.isSet)(d.gasUsed) ? f.Long.fromValue(d.gasUsed) : f.Long.ZERO,
        tx: (0, f.isSet)(d.tx) ? r.Any.fromJSON(d.tx) : void 0,
        timestamp: (0, f.isSet)(d.timestamp) ? String(d.timestamp) : "",
        events: Array.isArray(d == null ? void 0 : d.events) ? d.events.map((p) => m.Event.fromJSON(p)) : []
      };
    },
    toJSON(d) {
      const p = {};
      return d.height !== void 0 && (p.height = (d.height || f.Long.ZERO).toString()), d.txhash !== void 0 && (p.txhash = d.txhash), d.codespace !== void 0 && (p.codespace = d.codespace), d.code !== void 0 && (p.code = Math.round(d.code)), d.data !== void 0 && (p.data = d.data), d.rawLog !== void 0 && (p.rawLog = d.rawLog), d.logs ? p.logs = d.logs.map((h) => h ? e.ABCIMessageLog.toJSON(h) : void 0) : p.logs = [], d.info !== void 0 && (p.info = d.info), d.gasWanted !== void 0 && (p.gasWanted = (d.gasWanted || f.Long.ZERO).toString()), d.gasUsed !== void 0 && (p.gasUsed = (d.gasUsed || f.Long.ZERO).toString()), d.tx !== void 0 && (p.tx = d.tx ? r.Any.toJSON(d.tx) : void 0), d.timestamp !== void 0 && (p.timestamp = d.timestamp), d.events ? p.events = d.events.map((h) => h ? m.Event.toJSON(h) : void 0) : p.events = [], p;
    },
    fromPartial(d) {
      var p, h;
      const x = R();
      return x.height = d.height !== void 0 && d.height !== null ? f.Long.fromValue(d.height) : f.Long.ZERO, x.txhash = d.txhash ?? "", x.codespace = d.codespace ?? "", x.code = d.code ?? 0, x.data = d.data ?? "", x.rawLog = d.rawLog ?? "", x.logs = ((p = d.logs) == null ? void 0 : p.map((_) => e.ABCIMessageLog.fromPartial(_))) || [], x.info = d.info ?? "", x.gasWanted = d.gasWanted !== void 0 && d.gasWanted !== null ? f.Long.fromValue(d.gasWanted) : f.Long.ZERO, x.gasUsed = d.gasUsed !== void 0 && d.gasUsed !== null ? f.Long.fromValue(d.gasUsed) : f.Long.ZERO, x.tx = d.tx !== void 0 && d.tx !== null ? r.Any.fromPartial(d.tx) : void 0, x.timestamp = d.timestamp ?? "", x.events = ((h = d.events) == null ? void 0 : h.map((_) => m.Event.fromPartial(_))) || [], x;
    }
  };
  function T() {
    return {
      msgIndex: 0,
      log: "",
      events: []
    };
  }
  e.ABCIMessageLog = {
    encode(d, p = b.Writer.create()) {
      d.msgIndex !== 0 && p.uint32(8).uint32(d.msgIndex), d.log !== "" && p.uint32(18).string(d.log);
      for (const h of d.events)
        e.StringEvent.encode(h, p.uint32(26).fork()).ldelim();
      return p;
    },
    decode(d, p) {
      const h = d instanceof b.Reader ? d : new b.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = T();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.msgIndex = h.uint32();
            break;
          case 2:
            _.log = h.string();
            break;
          case 3:
            _.events.push(e.StringEvent.decode(h, h.uint32()));
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        msgIndex: (0, f.isSet)(d.msgIndex) ? Number(d.msgIndex) : 0,
        log: (0, f.isSet)(d.log) ? String(d.log) : "",
        events: Array.isArray(d == null ? void 0 : d.events) ? d.events.map((p) => e.StringEvent.fromJSON(p)) : []
      };
    },
    toJSON(d) {
      const p = {};
      return d.msgIndex !== void 0 && (p.msgIndex = Math.round(d.msgIndex)), d.log !== void 0 && (p.log = d.log), d.events ? p.events = d.events.map((h) => h ? e.StringEvent.toJSON(h) : void 0) : p.events = [], p;
    },
    fromPartial(d) {
      var p;
      const h = T();
      return h.msgIndex = d.msgIndex ?? 0, h.log = d.log ?? "", h.events = ((p = d.events) == null ? void 0 : p.map((x) => e.StringEvent.fromPartial(x))) || [], h;
    }
  };
  function V() {
    return {
      type: "",
      attributes: []
    };
  }
  e.StringEvent = {
    encode(d, p = b.Writer.create()) {
      d.type !== "" && p.uint32(10).string(d.type);
      for (const h of d.attributes)
        e.Attribute.encode(h, p.uint32(18).fork()).ldelim();
      return p;
    },
    decode(d, p) {
      const h = d instanceof b.Reader ? d : new b.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = V();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.type = h.string();
            break;
          case 2:
            _.attributes.push(e.Attribute.decode(h, h.uint32()));
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        type: (0, f.isSet)(d.type) ? String(d.type) : "",
        attributes: Array.isArray(d == null ? void 0 : d.attributes) ? d.attributes.map((p) => e.Attribute.fromJSON(p)) : []
      };
    },
    toJSON(d) {
      const p = {};
      return d.type !== void 0 && (p.type = d.type), d.attributes ? p.attributes = d.attributes.map((h) => h ? e.Attribute.toJSON(h) : void 0) : p.attributes = [], p;
    },
    fromPartial(d) {
      var p;
      const h = V();
      return h.type = d.type ?? "", h.attributes = ((p = d.attributes) == null ? void 0 : p.map((x) => e.Attribute.fromPartial(x))) || [], h;
    }
  };
  function D() {
    return {
      key: "",
      value: ""
    };
  }
  e.Attribute = {
    encode(d, p = b.Writer.create()) {
      return d.key !== "" && p.uint32(10).string(d.key), d.value !== "" && p.uint32(18).string(d.value), p;
    },
    decode(d, p) {
      const h = d instanceof b.Reader ? d : new b.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = D();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.key = h.string();
            break;
          case 2:
            _.value = h.string();
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        key: (0, f.isSet)(d.key) ? String(d.key) : "",
        value: (0, f.isSet)(d.value) ? String(d.value) : ""
      };
    },
    toJSON(d) {
      const p = {};
      return d.key !== void 0 && (p.key = d.key), d.value !== void 0 && (p.value = d.value), p;
    },
    fromPartial(d) {
      const p = D();
      return p.key = d.key ?? "", p.value = d.value ?? "", p;
    }
  };
  function B() {
    return {
      gasWanted: f.Long.UZERO,
      gasUsed: f.Long.UZERO
    };
  }
  e.GasInfo = {
    encode(d, p = b.Writer.create()) {
      return d.gasWanted.isZero() || p.uint32(8).uint64(d.gasWanted), d.gasUsed.isZero() || p.uint32(16).uint64(d.gasUsed), p;
    },
    decode(d, p) {
      const h = d instanceof b.Reader ? d : new b.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = B();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.gasWanted = h.uint64();
            break;
          case 2:
            _.gasUsed = h.uint64();
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        gasWanted: (0, f.isSet)(d.gasWanted) ? f.Long.fromValue(d.gasWanted) : f.Long.UZERO,
        gasUsed: (0, f.isSet)(d.gasUsed) ? f.Long.fromValue(d.gasUsed) : f.Long.UZERO
      };
    },
    toJSON(d) {
      const p = {};
      return d.gasWanted !== void 0 && (p.gasWanted = (d.gasWanted || f.Long.UZERO).toString()), d.gasUsed !== void 0 && (p.gasUsed = (d.gasUsed || f.Long.UZERO).toString()), p;
    },
    fromPartial(d) {
      const p = B();
      return p.gasWanted = d.gasWanted !== void 0 && d.gasWanted !== null ? f.Long.fromValue(d.gasWanted) : f.Long.UZERO, p.gasUsed = d.gasUsed !== void 0 && d.gasUsed !== null ? f.Long.fromValue(d.gasUsed) : f.Long.UZERO, p;
    }
  };
  function U() {
    return {
      data: new Uint8Array(),
      log: "",
      events: [],
      msgResponses: []
    };
  }
  e.Result = {
    encode(d, p = b.Writer.create()) {
      d.data.length !== 0 && p.uint32(10).bytes(d.data), d.log !== "" && p.uint32(18).string(d.log);
      for (const h of d.events)
        m.Event.encode(h, p.uint32(26).fork()).ldelim();
      for (const h of d.msgResponses)
        r.Any.encode(h, p.uint32(34).fork()).ldelim();
      return p;
    },
    decode(d, p) {
      const h = d instanceof b.Reader ? d : new b.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = U();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.data = h.bytes();
            break;
          case 2:
            _.log = h.string();
            break;
          case 3:
            _.events.push(m.Event.decode(h, h.uint32()));
            break;
          case 4:
            _.msgResponses.push(r.Any.decode(h, h.uint32()));
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        data: (0, f.isSet)(d.data) ? (0, f.bytesFromBase64)(d.data) : new Uint8Array(),
        log: (0, f.isSet)(d.log) ? String(d.log) : "",
        events: Array.isArray(d == null ? void 0 : d.events) ? d.events.map((p) => m.Event.fromJSON(p)) : [],
        msgResponses: Array.isArray(d == null ? void 0 : d.msgResponses) ? d.msgResponses.map((p) => r.Any.fromJSON(p)) : []
      };
    },
    toJSON(d) {
      const p = {};
      return d.data !== void 0 && (p.data = (0, f.base64FromBytes)(d.data !== void 0 ? d.data : new Uint8Array())), d.log !== void 0 && (p.log = d.log), d.events ? p.events = d.events.map((h) => h ? m.Event.toJSON(h) : void 0) : p.events = [], d.msgResponses ? p.msgResponses = d.msgResponses.map((h) => h ? r.Any.toJSON(h) : void 0) : p.msgResponses = [], p;
    },
    fromPartial(d) {
      var p, h;
      const x = U();
      return x.data = d.data ?? new Uint8Array(), x.log = d.log ?? "", x.events = ((p = d.events) == null ? void 0 : p.map((_) => m.Event.fromPartial(_))) || [], x.msgResponses = ((h = d.msgResponses) == null ? void 0 : h.map((_) => r.Any.fromPartial(_))) || [], x;
    }
  };
  function C() {
    return {
      gasInfo: void 0,
      result: void 0
    };
  }
  e.SimulationResponse = {
    encode(d, p = b.Writer.create()) {
      return d.gasInfo !== void 0 && e.GasInfo.encode(d.gasInfo, p.uint32(10).fork()).ldelim(), d.result !== void 0 && e.Result.encode(d.result, p.uint32(18).fork()).ldelim(), p;
    },
    decode(d, p) {
      const h = d instanceof b.Reader ? d : new b.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = C();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.gasInfo = e.GasInfo.decode(h, h.uint32());
            break;
          case 2:
            _.result = e.Result.decode(h, h.uint32());
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        gasInfo: (0, f.isSet)(d.gasInfo) ? e.GasInfo.fromJSON(d.gasInfo) : void 0,
        result: (0, f.isSet)(d.result) ? e.Result.fromJSON(d.result) : void 0
      };
    },
    toJSON(d) {
      const p = {};
      return d.gasInfo !== void 0 && (p.gasInfo = d.gasInfo ? e.GasInfo.toJSON(d.gasInfo) : void 0), d.result !== void 0 && (p.result = d.result ? e.Result.toJSON(d.result) : void 0), p;
    },
    fromPartial(d) {
      const p = C();
      return p.gasInfo = d.gasInfo !== void 0 && d.gasInfo !== null ? e.GasInfo.fromPartial(d.gasInfo) : void 0, p.result = d.result !== void 0 && d.result !== null ? e.Result.fromPartial(d.result) : void 0, p;
    }
  };
  function l() {
    return {
      msgType: "",
      data: new Uint8Array()
    };
  }
  e.MsgData = {
    encode(d, p = b.Writer.create()) {
      return d.msgType !== "" && p.uint32(10).string(d.msgType), d.data.length !== 0 && p.uint32(18).bytes(d.data), p;
    },
    decode(d, p) {
      const h = d instanceof b.Reader ? d : new b.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = l();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.msgType = h.string();
            break;
          case 2:
            _.data = h.bytes();
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        msgType: (0, f.isSet)(d.msgType) ? String(d.msgType) : "",
        data: (0, f.isSet)(d.data) ? (0, f.bytesFromBase64)(d.data) : new Uint8Array()
      };
    },
    toJSON(d) {
      const p = {};
      return d.msgType !== void 0 && (p.msgType = d.msgType), d.data !== void 0 && (p.data = (0, f.base64FromBytes)(d.data !== void 0 ? d.data : new Uint8Array())), p;
    },
    fromPartial(d) {
      const p = l();
      return p.msgType = d.msgType ?? "", p.data = d.data ?? new Uint8Array(), p;
    }
  };
  function S() {
    return {
      data: [],
      msgResponses: []
    };
  }
  e.TxMsgData = {
    encode(d, p = b.Writer.create()) {
      for (const h of d.data)
        e.MsgData.encode(h, p.uint32(10).fork()).ldelim();
      for (const h of d.msgResponses)
        r.Any.encode(h, p.uint32(18).fork()).ldelim();
      return p;
    },
    decode(d, p) {
      const h = d instanceof b.Reader ? d : new b.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = S();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.data.push(e.MsgData.decode(h, h.uint32()));
            break;
          case 2:
            _.msgResponses.push(r.Any.decode(h, h.uint32()));
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        data: Array.isArray(d == null ? void 0 : d.data) ? d.data.map((p) => e.MsgData.fromJSON(p)) : [],
        msgResponses: Array.isArray(d == null ? void 0 : d.msgResponses) ? d.msgResponses.map((p) => r.Any.fromJSON(p)) : []
      };
    },
    toJSON(d) {
      const p = {};
      return d.data ? p.data = d.data.map((h) => h ? e.MsgData.toJSON(h) : void 0) : p.data = [], d.msgResponses ? p.msgResponses = d.msgResponses.map((h) => h ? r.Any.toJSON(h) : void 0) : p.msgResponses = [], p;
    },
    fromPartial(d) {
      var p, h;
      const x = S();
      return x.data = ((p = d.data) == null ? void 0 : p.map((_) => e.MsgData.fromPartial(_))) || [], x.msgResponses = ((h = d.msgResponses) == null ? void 0 : h.map((_) => r.Any.fromPartial(_))) || [], x;
    }
  };
  function A() {
    return {
      totalCount: f.Long.UZERO,
      count: f.Long.UZERO,
      pageNumber: f.Long.UZERO,
      pageTotal: f.Long.UZERO,
      limit: f.Long.UZERO,
      txs: []
    };
  }
  e.SearchTxsResult = {
    encode(d, p = b.Writer.create()) {
      d.totalCount.isZero() || p.uint32(8).uint64(d.totalCount), d.count.isZero() || p.uint32(16).uint64(d.count), d.pageNumber.isZero() || p.uint32(24).uint64(d.pageNumber), d.pageTotal.isZero() || p.uint32(32).uint64(d.pageTotal), d.limit.isZero() || p.uint32(40).uint64(d.limit);
      for (const h of d.txs)
        e.TxResponse.encode(h, p.uint32(50).fork()).ldelim();
      return p;
    },
    decode(d, p) {
      const h = d instanceof b.Reader ? d : new b.Reader(d);
      let x = p === void 0 ? h.len : h.pos + p;
      const _ = A();
      for (; h.pos < x; ) {
        const I = h.uint32();
        switch (I >>> 3) {
          case 1:
            _.totalCount = h.uint64();
            break;
          case 2:
            _.count = h.uint64();
            break;
          case 3:
            _.pageNumber = h.uint64();
            break;
          case 4:
            _.pageTotal = h.uint64();
            break;
          case 5:
            _.limit = h.uint64();
            break;
          case 6:
            _.txs.push(e.TxResponse.decode(h, h.uint32()));
            break;
          default:
            h.skipType(I & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(d) {
      return {
        totalCount: (0, f.isSet)(d.totalCount) ? f.Long.fromValue(d.totalCount) : f.Long.UZERO,
        count: (0, f.isSet)(d.count) ? f.Long.fromValue(d.count) : f.Long.UZERO,
        pageNumber: (0, f.isSet)(d.pageNumber) ? f.Long.fromValue(d.pageNumber) : f.Long.UZERO,
        pageTotal: (0, f.isSet)(d.pageTotal) ? f.Long.fromValue(d.pageTotal) : f.Long.UZERO,
        limit: (0, f.isSet)(d.limit) ? f.Long.fromValue(d.limit) : f.Long.UZERO,
        txs: Array.isArray(d == null ? void 0 : d.txs) ? d.txs.map((p) => e.TxResponse.fromJSON(p)) : []
      };
    },
    toJSON(d) {
      const p = {};
      return d.totalCount !== void 0 && (p.totalCount = (d.totalCount || f.Long.UZERO).toString()), d.count !== void 0 && (p.count = (d.count || f.Long.UZERO).toString()), d.pageNumber !== void 0 && (p.pageNumber = (d.pageNumber || f.Long.UZERO).toString()), d.pageTotal !== void 0 && (p.pageTotal = (d.pageTotal || f.Long.UZERO).toString()), d.limit !== void 0 && (p.limit = (d.limit || f.Long.UZERO).toString()), d.txs ? p.txs = d.txs.map((h) => h ? e.TxResponse.toJSON(h) : void 0) : p.txs = [], p;
    },
    fromPartial(d) {
      var p;
      const h = A();
      return h.totalCount = d.totalCount !== void 0 && d.totalCount !== null ? f.Long.fromValue(d.totalCount) : f.Long.UZERO, h.count = d.count !== void 0 && d.count !== null ? f.Long.fromValue(d.count) : f.Long.UZERO, h.pageNumber = d.pageNumber !== void 0 && d.pageNumber !== null ? f.Long.fromValue(d.pageNumber) : f.Long.UZERO, h.pageTotal = d.pageTotal !== void 0 && d.pageTotal !== null ? f.Long.fromValue(d.pageTotal) : f.Long.UZERO, h.limit = d.limit !== void 0 && d.limit !== null ? f.Long.fromValue(d.limit) : f.Long.UZERO, h.txs = ((p = d.txs) == null ? void 0 : p.map((x) => e.TxResponse.fromPartial(x))) || [], h;
    }
  };
})(os);
var _n = {}, Mc = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(U, C, l, S) {
    S === void 0 && (S = l);
    var A = Object.getOwnPropertyDescriptor(C, l);
    (!A || ("get" in A ? !C.__esModule : A.writable || A.configurable)) && (A = { enumerable: !0, get: function() {
      return C[l];
    } }), Object.defineProperty(U, S, A);
  } : function(U, C, l, S) {
    S === void 0 && (S = l), U[S] = C[l];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(U, C) {
    Object.defineProperty(U, "default", { enumerable: !0, value: C });
  } : function(U, C) {
    U.default = C;
  }), u = Q && Q.__importStar || function(U) {
    if (U && U.__esModule)
      return U;
    var C = {};
    if (U != null)
      for (var l in U)
        l !== "default" && Object.prototype.hasOwnProperty.call(U, l) && o(C, U, l);
    return t(C, U), C;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.EvidenceList = e.LightClientAttackEvidence = e.DuplicateVoteEvidence = e.Evidence = e.protobufPackage = void 0;
  const r = nn, m = Ae, f = fr, b = ie, R = u(re);
  e.protobufPackage = "tendermint.types";
  function T() {
    return {
      duplicateVoteEvidence: void 0,
      lightClientAttackEvidence: void 0
    };
  }
  e.Evidence = {
    encode(U, C = R.Writer.create()) {
      return U.duplicateVoteEvidence !== void 0 && e.DuplicateVoteEvidence.encode(U.duplicateVoteEvidence, C.uint32(10).fork()).ldelim(), U.lightClientAttackEvidence !== void 0 && e.LightClientAttackEvidence.encode(U.lightClientAttackEvidence, C.uint32(18).fork()).ldelim(), C;
    },
    decode(U, C) {
      const l = U instanceof R.Reader ? U : new R.Reader(U);
      let S = C === void 0 ? l.len : l.pos + C;
      const A = T();
      for (; l.pos < S; ) {
        const d = l.uint32();
        switch (d >>> 3) {
          case 1:
            A.duplicateVoteEvidence = e.DuplicateVoteEvidence.decode(l, l.uint32());
            break;
          case 2:
            A.lightClientAttackEvidence = e.LightClientAttackEvidence.decode(l, l.uint32());
            break;
          default:
            l.skipType(d & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(U) {
      return {
        duplicateVoteEvidence: (0, b.isSet)(U.duplicateVoteEvidence) ? e.DuplicateVoteEvidence.fromJSON(U.duplicateVoteEvidence) : void 0,
        lightClientAttackEvidence: (0, b.isSet)(U.lightClientAttackEvidence) ? e.LightClientAttackEvidence.fromJSON(U.lightClientAttackEvidence) : void 0
      };
    },
    toJSON(U) {
      const C = {};
      return U.duplicateVoteEvidence !== void 0 && (C.duplicateVoteEvidence = U.duplicateVoteEvidence ? e.DuplicateVoteEvidence.toJSON(U.duplicateVoteEvidence) : void 0), U.lightClientAttackEvidence !== void 0 && (C.lightClientAttackEvidence = U.lightClientAttackEvidence ? e.LightClientAttackEvidence.toJSON(U.lightClientAttackEvidence) : void 0), C;
    },
    fromPartial(U) {
      const C = T();
      return C.duplicateVoteEvidence = U.duplicateVoteEvidence !== void 0 && U.duplicateVoteEvidence !== null ? e.DuplicateVoteEvidence.fromPartial(U.duplicateVoteEvidence) : void 0, C.lightClientAttackEvidence = U.lightClientAttackEvidence !== void 0 && U.lightClientAttackEvidence !== null ? e.LightClientAttackEvidence.fromPartial(U.lightClientAttackEvidence) : void 0, C;
    }
  };
  function V() {
    return {
      voteA: void 0,
      voteB: void 0,
      totalVotingPower: b.Long.ZERO,
      validatorPower: b.Long.ZERO,
      timestamp: void 0
    };
  }
  e.DuplicateVoteEvidence = {
    encode(U, C = R.Writer.create()) {
      return U.voteA !== void 0 && r.Vote.encode(U.voteA, C.uint32(10).fork()).ldelim(), U.voteB !== void 0 && r.Vote.encode(U.voteB, C.uint32(18).fork()).ldelim(), U.totalVotingPower.isZero() || C.uint32(24).int64(U.totalVotingPower), U.validatorPower.isZero() || C.uint32(32).int64(U.validatorPower), U.timestamp !== void 0 && m.Timestamp.encode(U.timestamp, C.uint32(42).fork()).ldelim(), C;
    },
    decode(U, C) {
      const l = U instanceof R.Reader ? U : new R.Reader(U);
      let S = C === void 0 ? l.len : l.pos + C;
      const A = V();
      for (; l.pos < S; ) {
        const d = l.uint32();
        switch (d >>> 3) {
          case 1:
            A.voteA = r.Vote.decode(l, l.uint32());
            break;
          case 2:
            A.voteB = r.Vote.decode(l, l.uint32());
            break;
          case 3:
            A.totalVotingPower = l.int64();
            break;
          case 4:
            A.validatorPower = l.int64();
            break;
          case 5:
            A.timestamp = m.Timestamp.decode(l, l.uint32());
            break;
          default:
            l.skipType(d & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(U) {
      return {
        voteA: (0, b.isSet)(U.voteA) ? r.Vote.fromJSON(U.voteA) : void 0,
        voteB: (0, b.isSet)(U.voteB) ? r.Vote.fromJSON(U.voteB) : void 0,
        totalVotingPower: (0, b.isSet)(U.totalVotingPower) ? b.Long.fromValue(U.totalVotingPower) : b.Long.ZERO,
        validatorPower: (0, b.isSet)(U.validatorPower) ? b.Long.fromValue(U.validatorPower) : b.Long.ZERO,
        timestamp: (0, b.isSet)(U.timestamp) ? (0, b.fromJsonTimestamp)(U.timestamp) : void 0
      };
    },
    toJSON(U) {
      const C = {};
      return U.voteA !== void 0 && (C.voteA = U.voteA ? r.Vote.toJSON(U.voteA) : void 0), U.voteB !== void 0 && (C.voteB = U.voteB ? r.Vote.toJSON(U.voteB) : void 0), U.totalVotingPower !== void 0 && (C.totalVotingPower = (U.totalVotingPower || b.Long.ZERO).toString()), U.validatorPower !== void 0 && (C.validatorPower = (U.validatorPower || b.Long.ZERO).toString()), U.timestamp !== void 0 && (C.timestamp = (0, b.fromTimestamp)(U.timestamp).toISOString()), C;
    },
    fromPartial(U) {
      const C = V();
      return C.voteA = U.voteA !== void 0 && U.voteA !== null ? r.Vote.fromPartial(U.voteA) : void 0, C.voteB = U.voteB !== void 0 && U.voteB !== null ? r.Vote.fromPartial(U.voteB) : void 0, C.totalVotingPower = U.totalVotingPower !== void 0 && U.totalVotingPower !== null ? b.Long.fromValue(U.totalVotingPower) : b.Long.ZERO, C.validatorPower = U.validatorPower !== void 0 && U.validatorPower !== null ? b.Long.fromValue(U.validatorPower) : b.Long.ZERO, C.timestamp = U.timestamp !== void 0 && U.timestamp !== null ? m.Timestamp.fromPartial(U.timestamp) : void 0, C;
    }
  };
  function D() {
    return {
      conflictingBlock: void 0,
      commonHeight: b.Long.ZERO,
      byzantineValidators: [],
      totalVotingPower: b.Long.ZERO,
      timestamp: void 0
    };
  }
  e.LightClientAttackEvidence = {
    encode(U, C = R.Writer.create()) {
      U.conflictingBlock !== void 0 && r.LightBlock.encode(U.conflictingBlock, C.uint32(10).fork()).ldelim(), U.commonHeight.isZero() || C.uint32(16).int64(U.commonHeight);
      for (const l of U.byzantineValidators)
        f.Validator.encode(l, C.uint32(26).fork()).ldelim();
      return U.totalVotingPower.isZero() || C.uint32(32).int64(U.totalVotingPower), U.timestamp !== void 0 && m.Timestamp.encode(U.timestamp, C.uint32(42).fork()).ldelim(), C;
    },
    decode(U, C) {
      const l = U instanceof R.Reader ? U : new R.Reader(U);
      let S = C === void 0 ? l.len : l.pos + C;
      const A = D();
      for (; l.pos < S; ) {
        const d = l.uint32();
        switch (d >>> 3) {
          case 1:
            A.conflictingBlock = r.LightBlock.decode(l, l.uint32());
            break;
          case 2:
            A.commonHeight = l.int64();
            break;
          case 3:
            A.byzantineValidators.push(f.Validator.decode(l, l.uint32()));
            break;
          case 4:
            A.totalVotingPower = l.int64();
            break;
          case 5:
            A.timestamp = m.Timestamp.decode(l, l.uint32());
            break;
          default:
            l.skipType(d & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(U) {
      return {
        conflictingBlock: (0, b.isSet)(U.conflictingBlock) ? r.LightBlock.fromJSON(U.conflictingBlock) : void 0,
        commonHeight: (0, b.isSet)(U.commonHeight) ? b.Long.fromValue(U.commonHeight) : b.Long.ZERO,
        byzantineValidators: Array.isArray(U == null ? void 0 : U.byzantineValidators) ? U.byzantineValidators.map((C) => f.Validator.fromJSON(C)) : [],
        totalVotingPower: (0, b.isSet)(U.totalVotingPower) ? b.Long.fromValue(U.totalVotingPower) : b.Long.ZERO,
        timestamp: (0, b.isSet)(U.timestamp) ? (0, b.fromJsonTimestamp)(U.timestamp) : void 0
      };
    },
    toJSON(U) {
      const C = {};
      return U.conflictingBlock !== void 0 && (C.conflictingBlock = U.conflictingBlock ? r.LightBlock.toJSON(U.conflictingBlock) : void 0), U.commonHeight !== void 0 && (C.commonHeight = (U.commonHeight || b.Long.ZERO).toString()), U.byzantineValidators ? C.byzantineValidators = U.byzantineValidators.map((l) => l ? f.Validator.toJSON(l) : void 0) : C.byzantineValidators = [], U.totalVotingPower !== void 0 && (C.totalVotingPower = (U.totalVotingPower || b.Long.ZERO).toString()), U.timestamp !== void 0 && (C.timestamp = (0, b.fromTimestamp)(U.timestamp).toISOString()), C;
    },
    fromPartial(U) {
      var C;
      const l = D();
      return l.conflictingBlock = U.conflictingBlock !== void 0 && U.conflictingBlock !== null ? r.LightBlock.fromPartial(U.conflictingBlock) : void 0, l.commonHeight = U.commonHeight !== void 0 && U.commonHeight !== null ? b.Long.fromValue(U.commonHeight) : b.Long.ZERO, l.byzantineValidators = ((C = U.byzantineValidators) == null ? void 0 : C.map((S) => f.Validator.fromPartial(S))) || [], l.totalVotingPower = U.totalVotingPower !== void 0 && U.totalVotingPower !== null ? b.Long.fromValue(U.totalVotingPower) : b.Long.ZERO, l.timestamp = U.timestamp !== void 0 && U.timestamp !== null ? m.Timestamp.fromPartial(U.timestamp) : void 0, l;
    }
  };
  function B() {
    return {
      evidence: []
    };
  }
  e.EvidenceList = {
    encode(U, C = R.Writer.create()) {
      for (const l of U.evidence)
        e.Evidence.encode(l, C.uint32(10).fork()).ldelim();
      return C;
    },
    decode(U, C) {
      const l = U instanceof R.Reader ? U : new R.Reader(U);
      let S = C === void 0 ? l.len : l.pos + C;
      const A = B();
      for (; l.pos < S; ) {
        const d = l.uint32();
        switch (d >>> 3) {
          case 1:
            A.evidence.push(e.Evidence.decode(l, l.uint32()));
            break;
          default:
            l.skipType(d & 7);
            break;
        }
      }
      return A;
    },
    fromJSON(U) {
      return {
        evidence: Array.isArray(U == null ? void 0 : U.evidence) ? U.evidence.map((C) => e.Evidence.fromJSON(C)) : []
      };
    },
    toJSON(U) {
      const C = {};
      return U.evidence ? C.evidence = U.evidence.map((l) => l ? e.Evidence.toJSON(l) : void 0) : C.evidence = [], C;
    },
    fromPartial(U) {
      var C;
      const l = B();
      return l.evidence = ((C = U.evidence) == null ? void 0 : C.map((S) => e.Evidence.fromPartial(S))) || [], l;
    }
  };
})(Mc);
var Rg = Q && Q.__createBinding || (Object.create ? function(e, o, t, u) {
  u === void 0 && (u = t);
  var r = Object.getOwnPropertyDescriptor(o, t);
  (!r || ("get" in r ? !o.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return o[t];
  } }), Object.defineProperty(e, u, r);
} : function(e, o, t, u) {
  u === void 0 && (u = t), e[u] = o[t];
}), Ag = Q && Q.__setModuleDefault || (Object.create ? function(e, o) {
  Object.defineProperty(e, "default", { enumerable: !0, value: o });
} : function(e, o) {
  e.default = o;
}), wg = Q && Q.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var o = {};
  if (e != null)
    for (var t in e)
      t !== "default" && Object.prototype.hasOwnProperty.call(e, t) && Rg(o, e, t);
  return Ag(o, e), o;
};
Object.defineProperty(_n, "__esModule", { value: !0 });
_n.Block = _n.protobufPackage = void 0;
const Je = nn, Fn = Mc, ai = wg(re), Oo = ie;
_n.protobufPackage = "tendermint.types";
function qa() {
  return {
    header: void 0,
    data: void 0,
    evidence: void 0,
    lastCommit: void 0
  };
}
_n.Block = {
  encode(e, o = ai.Writer.create()) {
    return e.header !== void 0 && Je.Header.encode(e.header, o.uint32(10).fork()).ldelim(), e.data !== void 0 && Je.Data.encode(e.data, o.uint32(18).fork()).ldelim(), e.evidence !== void 0 && Fn.EvidenceList.encode(e.evidence, o.uint32(26).fork()).ldelim(), e.lastCommit !== void 0 && Je.Commit.encode(e.lastCommit, o.uint32(34).fork()).ldelim(), o;
  },
  decode(e, o) {
    const t = e instanceof ai.Reader ? e : new ai.Reader(e);
    let u = o === void 0 ? t.len : t.pos + o;
    const r = qa();
    for (; t.pos < u; ) {
      const m = t.uint32();
      switch (m >>> 3) {
        case 1:
          r.header = Je.Header.decode(t, t.uint32());
          break;
        case 2:
          r.data = Je.Data.decode(t, t.uint32());
          break;
        case 3:
          r.evidence = Fn.EvidenceList.decode(t, t.uint32());
          break;
        case 4:
          r.lastCommit = Je.Commit.decode(t, t.uint32());
          break;
        default:
          t.skipType(m & 7);
          break;
      }
    }
    return r;
  },
  fromJSON(e) {
    return {
      header: (0, Oo.isSet)(e.header) ? Je.Header.fromJSON(e.header) : void 0,
      data: (0, Oo.isSet)(e.data) ? Je.Data.fromJSON(e.data) : void 0,
      evidence: (0, Oo.isSet)(e.evidence) ? Fn.EvidenceList.fromJSON(e.evidence) : void 0,
      lastCommit: (0, Oo.isSet)(e.lastCommit) ? Je.Commit.fromJSON(e.lastCommit) : void 0
    };
  },
  toJSON(e) {
    const o = {};
    return e.header !== void 0 && (o.header = e.header ? Je.Header.toJSON(e.header) : void 0), e.data !== void 0 && (o.data = e.data ? Je.Data.toJSON(e.data) : void 0), e.evidence !== void 0 && (o.evidence = e.evidence ? Fn.EvidenceList.toJSON(e.evidence) : void 0), e.lastCommit !== void 0 && (o.lastCommit = e.lastCommit ? Je.Commit.toJSON(e.lastCommit) : void 0), o;
  },
  fromPartial(e) {
    const o = qa();
    return o.header = e.header !== void 0 && e.header !== null ? Je.Header.fromPartial(e.header) : void 0, o.data = e.data !== void 0 && e.data !== null ? Je.Data.fromPartial(e.data) : void 0, o.evidence = e.evidence !== void 0 && e.evidence !== null ? Fn.EvidenceList.fromPartial(e.evidence) : void 0, o.lastCommit = e.lastCommit !== void 0 && e.lastCommit !== null ? Je.Commit.fromPartial(e.lastCommit) : void 0, o;
  }
};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(j, i, P, g) {
    g === void 0 && (g = P);
    var v = Object.getOwnPropertyDescriptor(i, P);
    (!v || ("get" in v ? !i.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
      return i[P];
    } }), Object.defineProperty(j, g, v);
  } : function(j, i, P, g) {
    g === void 0 && (g = P), j[g] = i[P];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(j, i) {
    Object.defineProperty(j, "default", { enumerable: !0, value: i });
  } : function(j, i) {
    j.default = i;
  }), u = Q && Q.__importStar || function(j) {
    if (j && j.__esModule)
      return j;
    var i = {};
    if (j != null)
      for (var P in j)
        P !== "default" && Object.prototype.hasOwnProperty.call(j, P) && o(i, j, P);
    return t(i, j), i;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ServiceClientImpl = e.TxDecodeAminoResponse = e.TxDecodeAminoRequest = e.TxEncodeAminoResponse = e.TxEncodeAminoRequest = e.TxEncodeResponse = e.TxEncodeRequest = e.TxDecodeResponse = e.TxDecodeRequest = e.GetBlockWithTxsResponse = e.GetBlockWithTxsRequest = e.GetTxResponse = e.GetTxRequest = e.SimulateResponse = e.SimulateRequest = e.BroadcastTxResponse = e.BroadcastTxRequest = e.GetTxsEventResponse = e.GetTxsEventRequest = e.broadcastModeToJSON = e.broadcastModeFromJSON = e.BroadcastMode = e.orderByToJSON = e.orderByFromJSON = e.OrderBy = e.protobufPackage = void 0;
  const r = eo, m = be, f = os, b = nn, R = _n, T = ie, V = u(re);
  e.protobufPackage = "cosmos.tx.v1beta1";
  var D;
  (function(j) {
    j[j.ORDER_BY_UNSPECIFIED = 0] = "ORDER_BY_UNSPECIFIED", j[j.ORDER_BY_ASC = 1] = "ORDER_BY_ASC", j[j.ORDER_BY_DESC = 2] = "ORDER_BY_DESC", j[j.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(D = e.OrderBy || (e.OrderBy = {}));
  function B(j) {
    switch (j) {
      case 0:
      case "ORDER_BY_UNSPECIFIED":
        return D.ORDER_BY_UNSPECIFIED;
      case 1:
      case "ORDER_BY_ASC":
        return D.ORDER_BY_ASC;
      case 2:
      case "ORDER_BY_DESC":
        return D.ORDER_BY_DESC;
      case -1:
      case "UNRECOGNIZED":
      default:
        return D.UNRECOGNIZED;
    }
  }
  e.orderByFromJSON = B;
  function U(j) {
    switch (j) {
      case D.ORDER_BY_UNSPECIFIED:
        return "ORDER_BY_UNSPECIFIED";
      case D.ORDER_BY_ASC:
        return "ORDER_BY_ASC";
      case D.ORDER_BY_DESC:
        return "ORDER_BY_DESC";
      case D.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.orderByToJSON = U;
  var C;
  (function(j) {
    j[j.BROADCAST_MODE_UNSPECIFIED = 0] = "BROADCAST_MODE_UNSPECIFIED", j[j.BROADCAST_MODE_BLOCK = 1] = "BROADCAST_MODE_BLOCK", j[j.BROADCAST_MODE_SYNC = 2] = "BROADCAST_MODE_SYNC", j[j.BROADCAST_MODE_ASYNC = 3] = "BROADCAST_MODE_ASYNC", j[j.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(C = e.BroadcastMode || (e.BroadcastMode = {}));
  function l(j) {
    switch (j) {
      case 0:
      case "BROADCAST_MODE_UNSPECIFIED":
        return C.BROADCAST_MODE_UNSPECIFIED;
      case 1:
      case "BROADCAST_MODE_BLOCK":
        return C.BROADCAST_MODE_BLOCK;
      case 2:
      case "BROADCAST_MODE_SYNC":
        return C.BROADCAST_MODE_SYNC;
      case 3:
      case "BROADCAST_MODE_ASYNC":
        return C.BROADCAST_MODE_ASYNC;
      case -1:
      case "UNRECOGNIZED":
      default:
        return C.UNRECOGNIZED;
    }
  }
  e.broadcastModeFromJSON = l;
  function S(j) {
    switch (j) {
      case C.BROADCAST_MODE_UNSPECIFIED:
        return "BROADCAST_MODE_UNSPECIFIED";
      case C.BROADCAST_MODE_BLOCK:
        return "BROADCAST_MODE_BLOCK";
      case C.BROADCAST_MODE_SYNC:
        return "BROADCAST_MODE_SYNC";
      case C.BROADCAST_MODE_ASYNC:
        return "BROADCAST_MODE_ASYNC";
      case C.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.broadcastModeToJSON = S;
  function A() {
    return {
      events: [],
      pagination: void 0,
      orderBy: 0,
      page: T.Long.UZERO,
      limit: T.Long.UZERO
    };
  }
  e.GetTxsEventRequest = {
    encode(j, i = V.Writer.create()) {
      for (const P of j.events)
        i.uint32(10).string(P);
      return j.pagination !== void 0 && m.PageRequest.encode(j.pagination, i.uint32(18).fork()).ldelim(), j.orderBy !== 0 && i.uint32(24).int32(j.orderBy), j.page.isZero() || i.uint32(32).uint64(j.page), j.limit.isZero() || i.uint32(40).uint64(j.limit), i;
    },
    decode(j, i) {
      const P = j instanceof V.Reader ? j : new V.Reader(j);
      let g = i === void 0 ? P.len : P.pos + i;
      const v = A();
      for (; P.pos < g; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            v.events.push(P.string());
            break;
          case 2:
            v.pagination = m.PageRequest.decode(P, P.uint32());
            break;
          case 3:
            v.orderBy = P.int32();
            break;
          case 4:
            v.page = P.uint64();
            break;
          case 5:
            v.limit = P.uint64();
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(j) {
      return {
        events: Array.isArray(j == null ? void 0 : j.events) ? j.events.map((i) => String(i)) : [],
        pagination: (0, T.isSet)(j.pagination) ? m.PageRequest.fromJSON(j.pagination) : void 0,
        orderBy: (0, T.isSet)(j.orderBy) ? B(j.orderBy) : 0,
        page: (0, T.isSet)(j.page) ? T.Long.fromValue(j.page) : T.Long.UZERO,
        limit: (0, T.isSet)(j.limit) ? T.Long.fromValue(j.limit) : T.Long.UZERO
      };
    },
    toJSON(j) {
      const i = {};
      return j.events ? i.events = j.events.map((P) => P) : i.events = [], j.pagination !== void 0 && (i.pagination = j.pagination ? m.PageRequest.toJSON(j.pagination) : void 0), j.orderBy !== void 0 && (i.orderBy = U(j.orderBy)), j.page !== void 0 && (i.page = (j.page || T.Long.UZERO).toString()), j.limit !== void 0 && (i.limit = (j.limit || T.Long.UZERO).toString()), i;
    },
    fromPartial(j) {
      var i;
      const P = A();
      return P.events = ((i = j.events) == null ? void 0 : i.map((g) => g)) || [], P.pagination = j.pagination !== void 0 && j.pagination !== null ? m.PageRequest.fromPartial(j.pagination) : void 0, P.orderBy = j.orderBy ?? 0, P.page = j.page !== void 0 && j.page !== null ? T.Long.fromValue(j.page) : T.Long.UZERO, P.limit = j.limit !== void 0 && j.limit !== null ? T.Long.fromValue(j.limit) : T.Long.UZERO, P;
    }
  };
  function d() {
    return {
      txs: [],
      txResponses: [],
      pagination: void 0,
      total: T.Long.UZERO
    };
  }
  e.GetTxsEventResponse = {
    encode(j, i = V.Writer.create()) {
      for (const P of j.txs)
        r.Tx.encode(P, i.uint32(10).fork()).ldelim();
      for (const P of j.txResponses)
        f.TxResponse.encode(P, i.uint32(18).fork()).ldelim();
      return j.pagination !== void 0 && m.PageResponse.encode(j.pagination, i.uint32(26).fork()).ldelim(), j.total.isZero() || i.uint32(32).uint64(j.total), i;
    },
    decode(j, i) {
      const P = j instanceof V.Reader ? j : new V.Reader(j);
      let g = i === void 0 ? P.len : P.pos + i;
      const v = d();
      for (; P.pos < g; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            v.txs.push(r.Tx.decode(P, P.uint32()));
            break;
          case 2:
            v.txResponses.push(f.TxResponse.decode(P, P.uint32()));
            break;
          case 3:
            v.pagination = m.PageResponse.decode(P, P.uint32());
            break;
          case 4:
            v.total = P.uint64();
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(j) {
      return {
        txs: Array.isArray(j == null ? void 0 : j.txs) ? j.txs.map((i) => r.Tx.fromJSON(i)) : [],
        txResponses: Array.isArray(j == null ? void 0 : j.txResponses) ? j.txResponses.map((i) => f.TxResponse.fromJSON(i)) : [],
        pagination: (0, T.isSet)(j.pagination) ? m.PageResponse.fromJSON(j.pagination) : void 0,
        total: (0, T.isSet)(j.total) ? T.Long.fromValue(j.total) : T.Long.UZERO
      };
    },
    toJSON(j) {
      const i = {};
      return j.txs ? i.txs = j.txs.map((P) => P ? r.Tx.toJSON(P) : void 0) : i.txs = [], j.txResponses ? i.txResponses = j.txResponses.map((P) => P ? f.TxResponse.toJSON(P) : void 0) : i.txResponses = [], j.pagination !== void 0 && (i.pagination = j.pagination ? m.PageResponse.toJSON(j.pagination) : void 0), j.total !== void 0 && (i.total = (j.total || T.Long.UZERO).toString()), i;
    },
    fromPartial(j) {
      var i, P;
      const g = d();
      return g.txs = ((i = j.txs) == null ? void 0 : i.map((v) => r.Tx.fromPartial(v))) || [], g.txResponses = ((P = j.txResponses) == null ? void 0 : P.map((v) => f.TxResponse.fromPartial(v))) || [], g.pagination = j.pagination !== void 0 && j.pagination !== null ? m.PageResponse.fromPartial(j.pagination) : void 0, g.total = j.total !== void 0 && j.total !== null ? T.Long.fromValue(j.total) : T.Long.UZERO, g;
    }
  };
  function p() {
    return {
      txBytes: new Uint8Array(),
      mode: 0
    };
  }
  e.BroadcastTxRequest = {
    encode(j, i = V.Writer.create()) {
      return j.txBytes.length !== 0 && i.uint32(10).bytes(j.txBytes), j.mode !== 0 && i.uint32(16).int32(j.mode), i;
    },
    decode(j, i) {
      const P = j instanceof V.Reader ? j : new V.Reader(j);
      let g = i === void 0 ? P.len : P.pos + i;
      const v = p();
      for (; P.pos < g; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            v.txBytes = P.bytes();
            break;
          case 2:
            v.mode = P.int32();
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(j) {
      return {
        txBytes: (0, T.isSet)(j.txBytes) ? (0, T.bytesFromBase64)(j.txBytes) : new Uint8Array(),
        mode: (0, T.isSet)(j.mode) ? l(j.mode) : 0
      };
    },
    toJSON(j) {
      const i = {};
      return j.txBytes !== void 0 && (i.txBytes = (0, T.base64FromBytes)(j.txBytes !== void 0 ? j.txBytes : new Uint8Array())), j.mode !== void 0 && (i.mode = S(j.mode)), i;
    },
    fromPartial(j) {
      const i = p();
      return i.txBytes = j.txBytes ?? new Uint8Array(), i.mode = j.mode ?? 0, i;
    }
  };
  function h() {
    return {
      txResponse: void 0
    };
  }
  e.BroadcastTxResponse = {
    encode(j, i = V.Writer.create()) {
      return j.txResponse !== void 0 && f.TxResponse.encode(j.txResponse, i.uint32(10).fork()).ldelim(), i;
    },
    decode(j, i) {
      const P = j instanceof V.Reader ? j : new V.Reader(j);
      let g = i === void 0 ? P.len : P.pos + i;
      const v = h();
      for (; P.pos < g; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            v.txResponse = f.TxResponse.decode(P, P.uint32());
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(j) {
      return {
        txResponse: (0, T.isSet)(j.txResponse) ? f.TxResponse.fromJSON(j.txResponse) : void 0
      };
    },
    toJSON(j) {
      const i = {};
      return j.txResponse !== void 0 && (i.txResponse = j.txResponse ? f.TxResponse.toJSON(j.txResponse) : void 0), i;
    },
    fromPartial(j) {
      const i = h();
      return i.txResponse = j.txResponse !== void 0 && j.txResponse !== null ? f.TxResponse.fromPartial(j.txResponse) : void 0, i;
    }
  };
  function x() {
    return {
      tx: void 0,
      txBytes: new Uint8Array()
    };
  }
  e.SimulateRequest = {
    encode(j, i = V.Writer.create()) {
      return j.tx !== void 0 && r.Tx.encode(j.tx, i.uint32(10).fork()).ldelim(), j.txBytes.length !== 0 && i.uint32(18).bytes(j.txBytes), i;
    },
    decode(j, i) {
      const P = j instanceof V.Reader ? j : new V.Reader(j);
      let g = i === void 0 ? P.len : P.pos + i;
      const v = x();
      for (; P.pos < g; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            v.tx = r.Tx.decode(P, P.uint32());
            break;
          case 2:
            v.txBytes = P.bytes();
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(j) {
      return {
        tx: (0, T.isSet)(j.tx) ? r.Tx.fromJSON(j.tx) : void 0,
        txBytes: (0, T.isSet)(j.txBytes) ? (0, T.bytesFromBase64)(j.txBytes) : new Uint8Array()
      };
    },
    toJSON(j) {
      const i = {};
      return j.tx !== void 0 && (i.tx = j.tx ? r.Tx.toJSON(j.tx) : void 0), j.txBytes !== void 0 && (i.txBytes = (0, T.base64FromBytes)(j.txBytes !== void 0 ? j.txBytes : new Uint8Array())), i;
    },
    fromPartial(j) {
      const i = x();
      return i.tx = j.tx !== void 0 && j.tx !== null ? r.Tx.fromPartial(j.tx) : void 0, i.txBytes = j.txBytes ?? new Uint8Array(), i;
    }
  };
  function _() {
    return {
      gasInfo: void 0,
      result: void 0
    };
  }
  e.SimulateResponse = {
    encode(j, i = V.Writer.create()) {
      return j.gasInfo !== void 0 && f.GasInfo.encode(j.gasInfo, i.uint32(10).fork()).ldelim(), j.result !== void 0 && f.Result.encode(j.result, i.uint32(18).fork()).ldelim(), i;
    },
    decode(j, i) {
      const P = j instanceof V.Reader ? j : new V.Reader(j);
      let g = i === void 0 ? P.len : P.pos + i;
      const v = _();
      for (; P.pos < g; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            v.gasInfo = f.GasInfo.decode(P, P.uint32());
            break;
          case 2:
            v.result = f.Result.decode(P, P.uint32());
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(j) {
      return {
        gasInfo: (0, T.isSet)(j.gasInfo) ? f.GasInfo.fromJSON(j.gasInfo) : void 0,
        result: (0, T.isSet)(j.result) ? f.Result.fromJSON(j.result) : void 0
      };
    },
    toJSON(j) {
      const i = {};
      return j.gasInfo !== void 0 && (i.gasInfo = j.gasInfo ? f.GasInfo.toJSON(j.gasInfo) : void 0), j.result !== void 0 && (i.result = j.result ? f.Result.toJSON(j.result) : void 0), i;
    },
    fromPartial(j) {
      const i = _();
      return i.gasInfo = j.gasInfo !== void 0 && j.gasInfo !== null ? f.GasInfo.fromPartial(j.gasInfo) : void 0, i.result = j.result !== void 0 && j.result !== null ? f.Result.fromPartial(j.result) : void 0, i;
    }
  };
  function I() {
    return {
      hash: ""
    };
  }
  e.GetTxRequest = {
    encode(j, i = V.Writer.create()) {
      return j.hash !== "" && i.uint32(10).string(j.hash), i;
    },
    decode(j, i) {
      const P = j instanceof V.Reader ? j : new V.Reader(j);
      let g = i === void 0 ? P.len : P.pos + i;
      const v = I();
      for (; P.pos < g; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            v.hash = P.string();
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(j) {
      return {
        hash: (0, T.isSet)(j.hash) ? String(j.hash) : ""
      };
    },
    toJSON(j) {
      const i = {};
      return j.hash !== void 0 && (i.hash = j.hash), i;
    },
    fromPartial(j) {
      const i = I();
      return i.hash = j.hash ?? "", i;
    }
  };
  function W() {
    return {
      tx: void 0,
      txResponse: void 0
    };
  }
  e.GetTxResponse = {
    encode(j, i = V.Writer.create()) {
      return j.tx !== void 0 && r.Tx.encode(j.tx, i.uint32(10).fork()).ldelim(), j.txResponse !== void 0 && f.TxResponse.encode(j.txResponse, i.uint32(18).fork()).ldelim(), i;
    },
    decode(j, i) {
      const P = j instanceof V.Reader ? j : new V.Reader(j);
      let g = i === void 0 ? P.len : P.pos + i;
      const v = W();
      for (; P.pos < g; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            v.tx = r.Tx.decode(P, P.uint32());
            break;
          case 2:
            v.txResponse = f.TxResponse.decode(P, P.uint32());
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(j) {
      return {
        tx: (0, T.isSet)(j.tx) ? r.Tx.fromJSON(j.tx) : void 0,
        txResponse: (0, T.isSet)(j.txResponse) ? f.TxResponse.fromJSON(j.txResponse) : void 0
      };
    },
    toJSON(j) {
      const i = {};
      return j.tx !== void 0 && (i.tx = j.tx ? r.Tx.toJSON(j.tx) : void 0), j.txResponse !== void 0 && (i.txResponse = j.txResponse ? f.TxResponse.toJSON(j.txResponse) : void 0), i;
    },
    fromPartial(j) {
      const i = W();
      return i.tx = j.tx !== void 0 && j.tx !== null ? r.Tx.fromPartial(j.tx) : void 0, i.txResponse = j.txResponse !== void 0 && j.txResponse !== null ? f.TxResponse.fromPartial(j.txResponse) : void 0, i;
    }
  };
  function n() {
    return {
      height: T.Long.ZERO,
      pagination: void 0
    };
  }
  e.GetBlockWithTxsRequest = {
    encode(j, i = V.Writer.create()) {
      return j.height.isZero() || i.uint32(8).int64(j.height), j.pagination !== void 0 && m.PageRequest.encode(j.pagination, i.uint32(18).fork()).ldelim(), i;
    },
    decode(j, i) {
      const P = j instanceof V.Reader ? j : new V.Reader(j);
      let g = i === void 0 ? P.len : P.pos + i;
      const v = n();
      for (; P.pos < g; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            v.height = P.int64();
            break;
          case 2:
            v.pagination = m.PageRequest.decode(P, P.uint32());
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(j) {
      return {
        height: (0, T.isSet)(j.height) ? T.Long.fromValue(j.height) : T.Long.ZERO,
        pagination: (0, T.isSet)(j.pagination) ? m.PageRequest.fromJSON(j.pagination) : void 0
      };
    },
    toJSON(j) {
      const i = {};
      return j.height !== void 0 && (i.height = (j.height || T.Long.ZERO).toString()), j.pagination !== void 0 && (i.pagination = j.pagination ? m.PageRequest.toJSON(j.pagination) : void 0), i;
    },
    fromPartial(j) {
      const i = n();
      return i.height = j.height !== void 0 && j.height !== null ? T.Long.fromValue(j.height) : T.Long.ZERO, i.pagination = j.pagination !== void 0 && j.pagination !== null ? m.PageRequest.fromPartial(j.pagination) : void 0, i;
    }
  };
  function y() {
    return {
      txs: [],
      blockId: void 0,
      block: void 0,
      pagination: void 0
    };
  }
  e.GetBlockWithTxsResponse = {
    encode(j, i = V.Writer.create()) {
      for (const P of j.txs)
        r.Tx.encode(P, i.uint32(10).fork()).ldelim();
      return j.blockId !== void 0 && b.BlockID.encode(j.blockId, i.uint32(18).fork()).ldelim(), j.block !== void 0 && R.Block.encode(j.block, i.uint32(26).fork()).ldelim(), j.pagination !== void 0 && m.PageResponse.encode(j.pagination, i.uint32(34).fork()).ldelim(), i;
    },
    decode(j, i) {
      const P = j instanceof V.Reader ? j : new V.Reader(j);
      let g = i === void 0 ? P.len : P.pos + i;
      const v = y();
      for (; P.pos < g; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            v.txs.push(r.Tx.decode(P, P.uint32()));
            break;
          case 2:
            v.blockId = b.BlockID.decode(P, P.uint32());
            break;
          case 3:
            v.block = R.Block.decode(P, P.uint32());
            break;
          case 4:
            v.pagination = m.PageResponse.decode(P, P.uint32());
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(j) {
      return {
        txs: Array.isArray(j == null ? void 0 : j.txs) ? j.txs.map((i) => r.Tx.fromJSON(i)) : [],
        blockId: (0, T.isSet)(j.blockId) ? b.BlockID.fromJSON(j.blockId) : void 0,
        block: (0, T.isSet)(j.block) ? R.Block.fromJSON(j.block) : void 0,
        pagination: (0, T.isSet)(j.pagination) ? m.PageResponse.fromJSON(j.pagination) : void 0
      };
    },
    toJSON(j) {
      const i = {};
      return j.txs ? i.txs = j.txs.map((P) => P ? r.Tx.toJSON(P) : void 0) : i.txs = [], j.blockId !== void 0 && (i.blockId = j.blockId ? b.BlockID.toJSON(j.blockId) : void 0), j.block !== void 0 && (i.block = j.block ? R.Block.toJSON(j.block) : void 0), j.pagination !== void 0 && (i.pagination = j.pagination ? m.PageResponse.toJSON(j.pagination) : void 0), i;
    },
    fromPartial(j) {
      var i;
      const P = y();
      return P.txs = ((i = j.txs) == null ? void 0 : i.map((g) => r.Tx.fromPartial(g))) || [], P.blockId = j.blockId !== void 0 && j.blockId !== null ? b.BlockID.fromPartial(j.blockId) : void 0, P.block = j.block !== void 0 && j.block !== null ? R.Block.fromPartial(j.block) : void 0, P.pagination = j.pagination !== void 0 && j.pagination !== null ? m.PageResponse.fromPartial(j.pagination) : void 0, P;
    }
  };
  function w() {
    return {
      txBytes: new Uint8Array()
    };
  }
  e.TxDecodeRequest = {
    encode(j, i = V.Writer.create()) {
      return j.txBytes.length !== 0 && i.uint32(10).bytes(j.txBytes), i;
    },
    decode(j, i) {
      const P = j instanceof V.Reader ? j : new V.Reader(j);
      let g = i === void 0 ? P.len : P.pos + i;
      const v = w();
      for (; P.pos < g; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            v.txBytes = P.bytes();
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(j) {
      return {
        txBytes: (0, T.isSet)(j.txBytes) ? (0, T.bytesFromBase64)(j.txBytes) : new Uint8Array()
      };
    },
    toJSON(j) {
      const i = {};
      return j.txBytes !== void 0 && (i.txBytes = (0, T.base64FromBytes)(j.txBytes !== void 0 ? j.txBytes : new Uint8Array())), i;
    },
    fromPartial(j) {
      const i = w();
      return i.txBytes = j.txBytes ?? new Uint8Array(), i;
    }
  };
  function M() {
    return {
      tx: void 0
    };
  }
  e.TxDecodeResponse = {
    encode(j, i = V.Writer.create()) {
      return j.tx !== void 0 && r.Tx.encode(j.tx, i.uint32(10).fork()).ldelim(), i;
    },
    decode(j, i) {
      const P = j instanceof V.Reader ? j : new V.Reader(j);
      let g = i === void 0 ? P.len : P.pos + i;
      const v = M();
      for (; P.pos < g; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            v.tx = r.Tx.decode(P, P.uint32());
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(j) {
      return {
        tx: (0, T.isSet)(j.tx) ? r.Tx.fromJSON(j.tx) : void 0
      };
    },
    toJSON(j) {
      const i = {};
      return j.tx !== void 0 && (i.tx = j.tx ? r.Tx.toJSON(j.tx) : void 0), i;
    },
    fromPartial(j) {
      const i = M();
      return i.tx = j.tx !== void 0 && j.tx !== null ? r.Tx.fromPartial(j.tx) : void 0, i;
    }
  };
  function s() {
    return {
      tx: void 0
    };
  }
  e.TxEncodeRequest = {
    encode(j, i = V.Writer.create()) {
      return j.tx !== void 0 && r.Tx.encode(j.tx, i.uint32(10).fork()).ldelim(), i;
    },
    decode(j, i) {
      const P = j instanceof V.Reader ? j : new V.Reader(j);
      let g = i === void 0 ? P.len : P.pos + i;
      const v = s();
      for (; P.pos < g; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            v.tx = r.Tx.decode(P, P.uint32());
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(j) {
      return {
        tx: (0, T.isSet)(j.tx) ? r.Tx.fromJSON(j.tx) : void 0
      };
    },
    toJSON(j) {
      const i = {};
      return j.tx !== void 0 && (i.tx = j.tx ? r.Tx.toJSON(j.tx) : void 0), i;
    },
    fromPartial(j) {
      const i = s();
      return i.tx = j.tx !== void 0 && j.tx !== null ? r.Tx.fromPartial(j.tx) : void 0, i;
    }
  };
  function c() {
    return {
      txBytes: new Uint8Array()
    };
  }
  e.TxEncodeResponse = {
    encode(j, i = V.Writer.create()) {
      return j.txBytes.length !== 0 && i.uint32(10).bytes(j.txBytes), i;
    },
    decode(j, i) {
      const P = j instanceof V.Reader ? j : new V.Reader(j);
      let g = i === void 0 ? P.len : P.pos + i;
      const v = c();
      for (; P.pos < g; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            v.txBytes = P.bytes();
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(j) {
      return {
        txBytes: (0, T.isSet)(j.txBytes) ? (0, T.bytesFromBase64)(j.txBytes) : new Uint8Array()
      };
    },
    toJSON(j) {
      const i = {};
      return j.txBytes !== void 0 && (i.txBytes = (0, T.base64FromBytes)(j.txBytes !== void 0 ? j.txBytes : new Uint8Array())), i;
    },
    fromPartial(j) {
      const i = c();
      return i.txBytes = j.txBytes ?? new Uint8Array(), i;
    }
  };
  function E() {
    return {
      aminoJson: ""
    };
  }
  e.TxEncodeAminoRequest = {
    encode(j, i = V.Writer.create()) {
      return j.aminoJson !== "" && i.uint32(10).string(j.aminoJson), i;
    },
    decode(j, i) {
      const P = j instanceof V.Reader ? j : new V.Reader(j);
      let g = i === void 0 ? P.len : P.pos + i;
      const v = E();
      for (; P.pos < g; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            v.aminoJson = P.string();
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(j) {
      return {
        aminoJson: (0, T.isSet)(j.aminoJson) ? String(j.aminoJson) : ""
      };
    },
    toJSON(j) {
      const i = {};
      return j.aminoJson !== void 0 && (i.aminoJson = j.aminoJson), i;
    },
    fromPartial(j) {
      const i = E();
      return i.aminoJson = j.aminoJson ?? "", i;
    }
  };
  function k() {
    return {
      aminoBinary: new Uint8Array()
    };
  }
  e.TxEncodeAminoResponse = {
    encode(j, i = V.Writer.create()) {
      return j.aminoBinary.length !== 0 && i.uint32(10).bytes(j.aminoBinary), i;
    },
    decode(j, i) {
      const P = j instanceof V.Reader ? j : new V.Reader(j);
      let g = i === void 0 ? P.len : P.pos + i;
      const v = k();
      for (; P.pos < g; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            v.aminoBinary = P.bytes();
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(j) {
      return {
        aminoBinary: (0, T.isSet)(j.aminoBinary) ? (0, T.bytesFromBase64)(j.aminoBinary) : new Uint8Array()
      };
    },
    toJSON(j) {
      const i = {};
      return j.aminoBinary !== void 0 && (i.aminoBinary = (0, T.base64FromBytes)(j.aminoBinary !== void 0 ? j.aminoBinary : new Uint8Array())), i;
    },
    fromPartial(j) {
      const i = k();
      return i.aminoBinary = j.aminoBinary ?? new Uint8Array(), i;
    }
  };
  function O() {
    return {
      aminoBinary: new Uint8Array()
    };
  }
  e.TxDecodeAminoRequest = {
    encode(j, i = V.Writer.create()) {
      return j.aminoBinary.length !== 0 && i.uint32(10).bytes(j.aminoBinary), i;
    },
    decode(j, i) {
      const P = j instanceof V.Reader ? j : new V.Reader(j);
      let g = i === void 0 ? P.len : P.pos + i;
      const v = O();
      for (; P.pos < g; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            v.aminoBinary = P.bytes();
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(j) {
      return {
        aminoBinary: (0, T.isSet)(j.aminoBinary) ? (0, T.bytesFromBase64)(j.aminoBinary) : new Uint8Array()
      };
    },
    toJSON(j) {
      const i = {};
      return j.aminoBinary !== void 0 && (i.aminoBinary = (0, T.base64FromBytes)(j.aminoBinary !== void 0 ? j.aminoBinary : new Uint8Array())), i;
    },
    fromPartial(j) {
      const i = O();
      return i.aminoBinary = j.aminoBinary ?? new Uint8Array(), i;
    }
  };
  function L() {
    return {
      aminoJson: ""
    };
  }
  e.TxDecodeAminoResponse = {
    encode(j, i = V.Writer.create()) {
      return j.aminoJson !== "" && i.uint32(10).string(j.aminoJson), i;
    },
    decode(j, i) {
      const P = j instanceof V.Reader ? j : new V.Reader(j);
      let g = i === void 0 ? P.len : P.pos + i;
      const v = L();
      for (; P.pos < g; ) {
        const N = P.uint32();
        switch (N >>> 3) {
          case 1:
            v.aminoJson = P.string();
            break;
          default:
            P.skipType(N & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(j) {
      return {
        aminoJson: (0, T.isSet)(j.aminoJson) ? String(j.aminoJson) : ""
      };
    },
    toJSON(j) {
      const i = {};
      return j.aminoJson !== void 0 && (i.aminoJson = j.aminoJson), i;
    },
    fromPartial(j) {
      const i = L();
      return i.aminoJson = j.aminoJson ?? "", i;
    }
  };
  class Z {
    constructor(i) {
      this.rpc = i, this.Simulate = this.Simulate.bind(this), this.GetTx = this.GetTx.bind(this), this.BroadcastTx = this.BroadcastTx.bind(this), this.GetTxsEvent = this.GetTxsEvent.bind(this), this.GetBlockWithTxs = this.GetBlockWithTxs.bind(this), this.TxDecode = this.TxDecode.bind(this), this.TxEncode = this.TxEncode.bind(this), this.TxEncodeAmino = this.TxEncodeAmino.bind(this), this.TxDecodeAmino = this.TxDecodeAmino.bind(this);
    }
    Simulate(i) {
      const P = e.SimulateRequest.encode(i).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "Simulate", P).then((g) => e.SimulateResponse.decode(new V.Reader(g)));
    }
    GetTx(i) {
      const P = e.GetTxRequest.encode(i).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "GetTx", P).then((g) => e.GetTxResponse.decode(new V.Reader(g)));
    }
    BroadcastTx(i) {
      const P = e.BroadcastTxRequest.encode(i).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "BroadcastTx", P).then((g) => e.BroadcastTxResponse.decode(new V.Reader(g)));
    }
    GetTxsEvent(i) {
      const P = e.GetTxsEventRequest.encode(i).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "GetTxsEvent", P).then((g) => e.GetTxsEventResponse.decode(new V.Reader(g)));
    }
    GetBlockWithTxs(i) {
      const P = e.GetBlockWithTxsRequest.encode(i).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "GetBlockWithTxs", P).then((g) => e.GetBlockWithTxsResponse.decode(new V.Reader(g)));
    }
    TxDecode(i) {
      const P = e.TxDecodeRequest.encode(i).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "TxDecode", P).then((g) => e.TxDecodeResponse.decode(new V.Reader(g)));
    }
    TxEncode(i) {
      const P = e.TxEncodeRequest.encode(i).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "TxEncode", P).then((g) => e.TxEncodeResponse.decode(new V.Reader(g)));
    }
    TxEncodeAmino(i) {
      const P = e.TxEncodeAminoRequest.encode(i).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "TxEncodeAmino", P).then((g) => e.TxEncodeAminoResponse.decode(new V.Reader(g)));
    }
    TxDecodeAmino(i) {
      const P = e.TxDecodeAminoRequest.encode(i).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "TxDecodeAmino", P).then((g) => e.TxDecodeAminoResponse.decode(new V.Reader(g)));
    }
  }
  e.ServiceClientImpl = Z;
})(Vc);
var Ng = Q && Q.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(vr, "__esModule", { value: !0 });
vr.setupTxExtension = void 0;
const Eg = tn, Tg = Bi, Za = Vc, Gn = eo, Cg = Ng(Pt), Ig = Ve;
function xg(e) {
  const o = (0, Ig.createProtobufRpcClient)(e), t = new Za.ServiceClientImpl(o);
  return {
    tx: {
      getTx: async (u) => {
        const r = {
          hash: u
        };
        return await t.GetTx(r);
      },
      simulate: async (u, r, m, f) => {
        const b = Gn.Tx.fromPartial({
          authInfo: Gn.AuthInfo.fromPartial({
            fee: Gn.Fee.fromPartial({}),
            signerInfos: [
              {
                publicKey: (0, Eg.encodePubkey)(m),
                sequence: Cg.default.fromNumber(f, !0),
                modeInfo: { single: { mode: Tg.SignMode.SIGN_MODE_UNSPECIFIED } }
              }
            ]
          }),
          body: Gn.TxBody.fromPartial({
            messages: Array.from(u),
            memo: r
          }),
          signatures: [new Uint8Array()]
        }), R = Za.SimulateRequest.fromPartial({
          txBytes: Gn.Tx.encode(b).finish()
        });
        return await t.Simulate(R);
      }
    }
  };
}
vr.setupTxExtension = xg;
var Jn = {}, _g = Q && Q.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Jn, "__esModule", { value: !0 });
Jn.createVestingAminoConverters = Jn.isAminoMsgCreateVestingAccount = void 0;
const Jg = _g(Pt);
function Ug(e) {
  return e.type === "cosmos-sdk/MsgCreateVestingAccount";
}
Jn.isAminoMsgCreateVestingAccount = Ug;
function Dg() {
  return {
    "/cosmos.vesting.v1beta1.MsgCreateVestingAccount": {
      aminoType: "cosmos-sdk/MsgCreateVestingAccount",
      toAmino: ({ fromAddress: e, toAddress: o, amount: t, endTime: u, delayed: r }) => ({
        from_address: e,
        to_address: o,
        amount: [...t],
        end_time: u.toString(),
        delayed: r
      }),
      fromAmino: ({ from_address: e, to_address: o, amount: t, end_time: u, delayed: r }) => ({
        fromAddress: e,
        toAddress: o,
        amount: [...t],
        endTime: Jg.default.fromString(u),
        delayed: r
      })
    }
  };
}
Jn.createVestingAminoConverters = Dg;
var yr = {}, Hc = {};
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(l, S, A, d) {
    d === void 0 && (d = A);
    var p = Object.getOwnPropertyDescriptor(S, A);
    (!p || ("get" in p ? !S.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return S[A];
    } }), Object.defineProperty(l, d, p);
  } : function(l, S, A, d) {
    d === void 0 && (d = A), l[d] = S[A];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(l, S) {
    Object.defineProperty(l, "default", { enumerable: !0, value: S });
  } : function(l, S) {
    l.default = S;
  }), u = Q && Q.__importStar || function(l) {
    if (l && l.__esModule)
      return l;
    var S = {};
    if (l != null)
      for (var A in l)
        A !== "default" && Object.prototype.hasOwnProperty.call(l, A) && o(S, l, A);
    return t(S, l), S;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgCreatePeriodicVestingAccountResponse = e.MsgCreatePeriodicVestingAccount = e.MsgCreatePermanentLockedAccountResponse = e.MsgCreatePermanentLockedAccount = e.MsgCreateVestingAccountResponse = e.MsgCreateVestingAccount = e.protobufPackage = void 0;
  const r = Le, m = Hi, f = ie, b = u(re);
  e.protobufPackage = "cosmos.vesting.v1beta1";
  function R() {
    return {
      fromAddress: "",
      toAddress: "",
      amount: [],
      endTime: f.Long.ZERO,
      delayed: !1
    };
  }
  e.MsgCreateVestingAccount = {
    encode(l, S = b.Writer.create()) {
      l.fromAddress !== "" && S.uint32(10).string(l.fromAddress), l.toAddress !== "" && S.uint32(18).string(l.toAddress);
      for (const A of l.amount)
        r.Coin.encode(A, S.uint32(26).fork()).ldelim();
      return l.endTime.isZero() || S.uint32(32).int64(l.endTime), l.delayed === !0 && S.uint32(40).bool(l.delayed), S;
    },
    decode(l, S) {
      const A = l instanceof b.Reader ? l : new b.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = R();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.fromAddress = A.string();
            break;
          case 2:
            p.toAddress = A.string();
            break;
          case 3:
            p.amount.push(r.Coin.decode(A, A.uint32()));
            break;
          case 4:
            p.endTime = A.int64();
            break;
          case 5:
            p.delayed = A.bool();
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        fromAddress: (0, f.isSet)(l.fromAddress) ? String(l.fromAddress) : "",
        toAddress: (0, f.isSet)(l.toAddress) ? String(l.toAddress) : "",
        amount: Array.isArray(l == null ? void 0 : l.amount) ? l.amount.map((S) => r.Coin.fromJSON(S)) : [],
        endTime: (0, f.isSet)(l.endTime) ? f.Long.fromValue(l.endTime) : f.Long.ZERO,
        delayed: (0, f.isSet)(l.delayed) ? !!l.delayed : !1
      };
    },
    toJSON(l) {
      const S = {};
      return l.fromAddress !== void 0 && (S.fromAddress = l.fromAddress), l.toAddress !== void 0 && (S.toAddress = l.toAddress), l.amount ? S.amount = l.amount.map((A) => A ? r.Coin.toJSON(A) : void 0) : S.amount = [], l.endTime !== void 0 && (S.endTime = (l.endTime || f.Long.ZERO).toString()), l.delayed !== void 0 && (S.delayed = l.delayed), S;
    },
    fromPartial(l) {
      var S;
      const A = R();
      return A.fromAddress = l.fromAddress ?? "", A.toAddress = l.toAddress ?? "", A.amount = ((S = l.amount) == null ? void 0 : S.map((d) => r.Coin.fromPartial(d))) || [], A.endTime = l.endTime !== void 0 && l.endTime !== null ? f.Long.fromValue(l.endTime) : f.Long.ZERO, A.delayed = l.delayed ?? !1, A;
    }
  };
  function T() {
    return {};
  }
  e.MsgCreateVestingAccountResponse = {
    encode(l, S = b.Writer.create()) {
      return S;
    },
    decode(l, S) {
      const A = l instanceof b.Reader ? l : new b.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = T();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {};
    },
    toJSON(l) {
      return {};
    },
    fromPartial(l) {
      return T();
    }
  };
  function V() {
    return {
      fromAddress: "",
      toAddress: "",
      amount: []
    };
  }
  e.MsgCreatePermanentLockedAccount = {
    encode(l, S = b.Writer.create()) {
      l.fromAddress !== "" && S.uint32(10).string(l.fromAddress), l.toAddress !== "" && S.uint32(18).string(l.toAddress);
      for (const A of l.amount)
        r.Coin.encode(A, S.uint32(26).fork()).ldelim();
      return S;
    },
    decode(l, S) {
      const A = l instanceof b.Reader ? l : new b.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = V();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.fromAddress = A.string();
            break;
          case 2:
            p.toAddress = A.string();
            break;
          case 3:
            p.amount.push(r.Coin.decode(A, A.uint32()));
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        fromAddress: (0, f.isSet)(l.fromAddress) ? String(l.fromAddress) : "",
        toAddress: (0, f.isSet)(l.toAddress) ? String(l.toAddress) : "",
        amount: Array.isArray(l == null ? void 0 : l.amount) ? l.amount.map((S) => r.Coin.fromJSON(S)) : []
      };
    },
    toJSON(l) {
      const S = {};
      return l.fromAddress !== void 0 && (S.fromAddress = l.fromAddress), l.toAddress !== void 0 && (S.toAddress = l.toAddress), l.amount ? S.amount = l.amount.map((A) => A ? r.Coin.toJSON(A) : void 0) : S.amount = [], S;
    },
    fromPartial(l) {
      var S;
      const A = V();
      return A.fromAddress = l.fromAddress ?? "", A.toAddress = l.toAddress ?? "", A.amount = ((S = l.amount) == null ? void 0 : S.map((d) => r.Coin.fromPartial(d))) || [], A;
    }
  };
  function D() {
    return {};
  }
  e.MsgCreatePermanentLockedAccountResponse = {
    encode(l, S = b.Writer.create()) {
      return S;
    },
    decode(l, S) {
      const A = l instanceof b.Reader ? l : new b.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = D();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {};
    },
    toJSON(l) {
      return {};
    },
    fromPartial(l) {
      return D();
    }
  };
  function B() {
    return {
      fromAddress: "",
      toAddress: "",
      startTime: f.Long.ZERO,
      vestingPeriods: []
    };
  }
  e.MsgCreatePeriodicVestingAccount = {
    encode(l, S = b.Writer.create()) {
      l.fromAddress !== "" && S.uint32(10).string(l.fromAddress), l.toAddress !== "" && S.uint32(18).string(l.toAddress), l.startTime.isZero() || S.uint32(24).int64(l.startTime);
      for (const A of l.vestingPeriods)
        m.Period.encode(A, S.uint32(34).fork()).ldelim();
      return S;
    },
    decode(l, S) {
      const A = l instanceof b.Reader ? l : new b.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = B();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          case 1:
            p.fromAddress = A.string();
            break;
          case 2:
            p.toAddress = A.string();
            break;
          case 3:
            p.startTime = A.int64();
            break;
          case 4:
            p.vestingPeriods.push(m.Period.decode(A, A.uint32()));
            break;
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {
        fromAddress: (0, f.isSet)(l.fromAddress) ? String(l.fromAddress) : "",
        toAddress: (0, f.isSet)(l.toAddress) ? String(l.toAddress) : "",
        startTime: (0, f.isSet)(l.startTime) ? f.Long.fromValue(l.startTime) : f.Long.ZERO,
        vestingPeriods: Array.isArray(l == null ? void 0 : l.vestingPeriods) ? l.vestingPeriods.map((S) => m.Period.fromJSON(S)) : []
      };
    },
    toJSON(l) {
      const S = {};
      return l.fromAddress !== void 0 && (S.fromAddress = l.fromAddress), l.toAddress !== void 0 && (S.toAddress = l.toAddress), l.startTime !== void 0 && (S.startTime = (l.startTime || f.Long.ZERO).toString()), l.vestingPeriods ? S.vestingPeriods = l.vestingPeriods.map((A) => A ? m.Period.toJSON(A) : void 0) : S.vestingPeriods = [], S;
    },
    fromPartial(l) {
      var S;
      const A = B();
      return A.fromAddress = l.fromAddress ?? "", A.toAddress = l.toAddress ?? "", A.startTime = l.startTime !== void 0 && l.startTime !== null ? f.Long.fromValue(l.startTime) : f.Long.ZERO, A.vestingPeriods = ((S = l.vestingPeriods) == null ? void 0 : S.map((d) => m.Period.fromPartial(d))) || [], A;
    }
  };
  function U() {
    return {};
  }
  e.MsgCreatePeriodicVestingAccountResponse = {
    encode(l, S = b.Writer.create()) {
      return S;
    },
    decode(l, S) {
      const A = l instanceof b.Reader ? l : new b.Reader(l);
      let d = S === void 0 ? A.len : A.pos + S;
      const p = U();
      for (; A.pos < d; ) {
        const h = A.uint32();
        switch (h >>> 3) {
          default:
            A.skipType(h & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(l) {
      return {};
    },
    toJSON(l) {
      return {};
    },
    fromPartial(l) {
      return U();
    }
  };
  class C {
    constructor(S) {
      this.rpc = S, this.CreateVestingAccount = this.CreateVestingAccount.bind(this), this.CreatePermanentLockedAccount = this.CreatePermanentLockedAccount.bind(this), this.CreatePeriodicVestingAccount = this.CreatePeriodicVestingAccount.bind(this);
    }
    CreateVestingAccount(S) {
      const A = e.MsgCreateVestingAccount.encode(S).finish();
      return this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreateVestingAccount", A).then((d) => e.MsgCreateVestingAccountResponse.decode(new b.Reader(d)));
    }
    CreatePermanentLockedAccount(S) {
      const A = e.MsgCreatePermanentLockedAccount.encode(S).finish();
      return this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreatePermanentLockedAccount", A).then((d) => e.MsgCreatePermanentLockedAccountResponse.decode(new b.Reader(d)));
    }
    CreatePeriodicVestingAccount(S) {
      const A = e.MsgCreatePeriodicVestingAccount.encode(S).finish();
      return this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreatePeriodicVestingAccount", A).then((d) => e.MsgCreatePeriodicVestingAccountResponse.decode(new b.Reader(d)));
    }
  }
  e.MsgClientImpl = C;
})(Hc);
Object.defineProperty(yr, "__esModule", { value: !0 });
yr.vestingTypes = void 0;
const Lg = Hc;
yr.vestingTypes = [
  ["/cosmos.vesting.v1beta1.MsgCreateVestingAccount", Lg.MsgCreateVestingAccount]
];
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isAminoMsgCreateValidator = e.isAminoMsgBeginRedelegate = e.createStakingAminoConverters = e.setupSlashingExtension = e.isAminoMsgUnjail = e.createSlashingAminoConverters = e.setupMintExtension = e.setupIbcExtension = e.isMsgTransferEncodeObject = e.ibcTypes = e.isAminoMsgTransfer = e.createIbcAminoConverters = e.groupTypes = e.createGroupAminoConverters = e.setupGovExtension = e.isMsgVoteWeightedEncodeObject = e.isMsgVoteEncodeObject = e.isMsgSubmitProposalEncodeObject = e.isMsgDepositEncodeObject = e.govTypes = e.isAminoMsgVoteWeighted = e.isAminoMsgVote = e.isAminoMsgSubmitProposal = e.isAminoMsgDeposit = e.createGovAminoConverters = e.setupFeegrantExtension = e.feegrantTypes = e.createFeegrantAminoConverters = e.isAminoMsgSubmitEvidence = e.createEvidenceAminoConverters = e.setupDistributionExtension = e.isMsgWithdrawDelegatorRewardEncodeObject = e.distributionTypes = e.isAminoMsgWithdrawValidatorCommission = e.isAminoMsgWithdrawDelegatorReward = e.isAminoMsgSetWithdrawAddress = e.isAminoMsgFundCommunityPool = e.createDistributionAminoConverters = e.isAminoMsgVerifyInvariant = e.createCrysisAminoConverters = e.setupBankExtension = e.isMsgSendEncodeObject = e.bankTypes = e.isAminoMsgSend = e.isAminoMsgMultiSend = e.createBankAminoConverters = e.setupAuthzExtension = e.authzTypes = e.createAuthzAminoConverters = e.setupAuthExtension = void 0, e.vestingTypes = e.isAminoMsgCreateVestingAccount = e.createVestingAminoConverters = e.setupTxExtension = e.setupStakingExtension = e.stakingTypes = e.isMsgUndelegateEncodeObject = e.isMsgEditValidatorEncodeObject = e.isMsgDelegateEncodeObject = e.isMsgCreateValidatorEncodeObject = e.isMsgBeginRedelegateEncodeObject = e.isAminoMsgUndelegate = e.isAminoMsgEditValidator = e.isAminoMsgDelegate = void 0;
  var o = jo;
  Object.defineProperty(e, "setupAuthExtension", { enumerable: !0, get: function() {
    return o.setupAuthExtension;
  } });
  var t = $o;
  Object.defineProperty(e, "createAuthzAminoConverters", { enumerable: !0, get: function() {
    return t.createAuthzAminoConverters;
  } });
  var u = Xo;
  Object.defineProperty(e, "authzTypes", { enumerable: !0, get: function() {
    return u.authzTypes;
  } });
  var r = er;
  Object.defineProperty(e, "setupAuthzExtension", { enumerable: !0, get: function() {
    return r.setupAuthzExtension;
  } });
  var m = Lt;
  Object.defineProperty(e, "createBankAminoConverters", { enumerable: !0, get: function() {
    return m.createBankAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgMultiSend", { enumerable: !0, get: function() {
    return m.isAminoMsgMultiSend;
  } }), Object.defineProperty(e, "isAminoMsgSend", { enumerable: !0, get: function() {
    return m.isAminoMsgSend;
  } });
  var f = wn;
  Object.defineProperty(e, "bankTypes", { enumerable: !0, get: function() {
    return f.bankTypes;
  } }), Object.defineProperty(e, "isMsgSendEncodeObject", { enumerable: !0, get: function() {
    return f.isMsgSendEncodeObject;
  } });
  var b = tr;
  Object.defineProperty(e, "setupBankExtension", { enumerable: !0, get: function() {
    return b.setupBankExtension;
  } });
  var R = Nn;
  Object.defineProperty(e, "createCrysisAminoConverters", { enumerable: !0, get: function() {
    return R.createCrysisAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgVerifyInvariant", { enumerable: !0, get: function() {
    return R.isAminoMsgVerifyInvariant;
  } });
  var T = ot;
  Object.defineProperty(e, "createDistributionAminoConverters", { enumerable: !0, get: function() {
    return T.createDistributionAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgFundCommunityPool", { enumerable: !0, get: function() {
    return T.isAminoMsgFundCommunityPool;
  } }), Object.defineProperty(e, "isAminoMsgSetWithdrawAddress", { enumerable: !0, get: function() {
    return T.isAminoMsgSetWithdrawAddress;
  } }), Object.defineProperty(e, "isAminoMsgWithdrawDelegatorReward", { enumerable: !0, get: function() {
    return T.isAminoMsgWithdrawDelegatorReward;
  } }), Object.defineProperty(e, "isAminoMsgWithdrawValidatorCommission", { enumerable: !0, get: function() {
    return T.isAminoMsgWithdrawValidatorCommission;
  } });
  var V = En;
  Object.defineProperty(e, "distributionTypes", { enumerable: !0, get: function() {
    return V.distributionTypes;
  } }), Object.defineProperty(e, "isMsgWithdrawDelegatorRewardEncodeObject", { enumerable: !0, get: function() {
    return V.isMsgWithdrawDelegatorRewardEncodeObject;
  } });
  var D = nr;
  Object.defineProperty(e, "setupDistributionExtension", { enumerable: !0, get: function() {
    return D.setupDistributionExtension;
  } });
  var B = Tn;
  Object.defineProperty(e, "createEvidenceAminoConverters", { enumerable: !0, get: function() {
    return B.createEvidenceAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgSubmitEvidence", { enumerable: !0, get: function() {
    return B.isAminoMsgSubmitEvidence;
  } });
  var U = or;
  Object.defineProperty(e, "createFeegrantAminoConverters", { enumerable: !0, get: function() {
    return U.createFeegrantAminoConverters;
  } });
  var C = rr;
  Object.defineProperty(e, "feegrantTypes", { enumerable: !0, get: function() {
    return C.feegrantTypes;
  } });
  var l = ir;
  Object.defineProperty(e, "setupFeegrantExtension", { enumerable: !0, get: function() {
    return l.setupFeegrantExtension;
  } });
  var S = rt;
  Object.defineProperty(e, "createGovAminoConverters", { enumerable: !0, get: function() {
    return S.createGovAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgDeposit", { enumerable: !0, get: function() {
    return S.isAminoMsgDeposit;
  } }), Object.defineProperty(e, "isAminoMsgSubmitProposal", { enumerable: !0, get: function() {
    return S.isAminoMsgSubmitProposal;
  } }), Object.defineProperty(e, "isAminoMsgVote", { enumerable: !0, get: function() {
    return S.isAminoMsgVote;
  } }), Object.defineProperty(e, "isAminoMsgVoteWeighted", { enumerable: !0, get: function() {
    return S.isAminoMsgVoteWeighted;
  } });
  var A = it;
  Object.defineProperty(e, "govTypes", { enumerable: !0, get: function() {
    return A.govTypes;
  } }), Object.defineProperty(e, "isMsgDepositEncodeObject", { enumerable: !0, get: function() {
    return A.isMsgDepositEncodeObject;
  } }), Object.defineProperty(e, "isMsgSubmitProposalEncodeObject", { enumerable: !0, get: function() {
    return A.isMsgSubmitProposalEncodeObject;
  } }), Object.defineProperty(e, "isMsgVoteEncodeObject", { enumerable: !0, get: function() {
    return A.isMsgVoteEncodeObject;
  } }), Object.defineProperty(e, "isMsgVoteWeightedEncodeObject", { enumerable: !0, get: function() {
    return A.isMsgVoteWeightedEncodeObject;
  } });
  var d = ar;
  Object.defineProperty(e, "setupGovExtension", { enumerable: !0, get: function() {
    return d.setupGovExtension;
  } });
  var p = dr;
  Object.defineProperty(e, "createGroupAminoConverters", { enumerable: !0, get: function() {
    return p.createGroupAminoConverters;
  } });
  var h = cr;
  Object.defineProperty(e, "groupTypes", { enumerable: !0, get: function() {
    return h.groupTypes;
  } });
  var x = Cn;
  Object.defineProperty(e, "createIbcAminoConverters", { enumerable: !0, get: function() {
    return x.createIbcAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgTransfer", { enumerable: !0, get: function() {
    return x.isAminoMsgTransfer;
  } });
  var _ = In;
  Object.defineProperty(e, "ibcTypes", { enumerable: !0, get: function() {
    return _.ibcTypes;
  } }), Object.defineProperty(e, "isMsgTransferEncodeObject", { enumerable: !0, get: function() {
    return _.isMsgTransferEncodeObject;
  } });
  var I = pr;
  Object.defineProperty(e, "setupIbcExtension", { enumerable: !0, get: function() {
    return I.setupIbcExtension;
  } });
  var W = mr;
  Object.defineProperty(e, "setupMintExtension", { enumerable: !0, get: function() {
    return W.setupMintExtension;
  } });
  var n = xn;
  Object.defineProperty(e, "createSlashingAminoConverters", { enumerable: !0, get: function() {
    return n.createSlashingAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgUnjail", { enumerable: !0, get: function() {
    return n.isAminoMsgUnjail;
  } });
  var y = gr;
  Object.defineProperty(e, "setupSlashingExtension", { enumerable: !0, get: function() {
    return y.setupSlashingExtension;
  } });
  var w = _e;
  Object.defineProperty(e, "createStakingAminoConverters", { enumerable: !0, get: function() {
    return w.createStakingAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgBeginRedelegate", { enumerable: !0, get: function() {
    return w.isAminoMsgBeginRedelegate;
  } }), Object.defineProperty(e, "isAminoMsgCreateValidator", { enumerable: !0, get: function() {
    return w.isAminoMsgCreateValidator;
  } }), Object.defineProperty(e, "isAminoMsgDelegate", { enumerable: !0, get: function() {
    return w.isAminoMsgDelegate;
  } }), Object.defineProperty(e, "isAminoMsgEditValidator", { enumerable: !0, get: function() {
    return w.isAminoMsgEditValidator;
  } }), Object.defineProperty(e, "isAminoMsgUndelegate", { enumerable: !0, get: function() {
    return w.isAminoMsgUndelegate;
  } });
  var M = Qe;
  Object.defineProperty(e, "isMsgBeginRedelegateEncodeObject", { enumerable: !0, get: function() {
    return M.isMsgBeginRedelegateEncodeObject;
  } }), Object.defineProperty(e, "isMsgCreateValidatorEncodeObject", { enumerable: !0, get: function() {
    return M.isMsgCreateValidatorEncodeObject;
  } }), Object.defineProperty(e, "isMsgDelegateEncodeObject", { enumerable: !0, get: function() {
    return M.isMsgDelegateEncodeObject;
  } }), Object.defineProperty(e, "isMsgEditValidatorEncodeObject", { enumerable: !0, get: function() {
    return M.isMsgEditValidatorEncodeObject;
  } }), Object.defineProperty(e, "isMsgUndelegateEncodeObject", { enumerable: !0, get: function() {
    return M.isMsgUndelegateEncodeObject;
  } }), Object.defineProperty(e, "stakingTypes", { enumerable: !0, get: function() {
    return M.stakingTypes;
  } });
  var s = hr;
  Object.defineProperty(e, "setupStakingExtension", { enumerable: !0, get: function() {
    return s.setupStakingExtension;
  } });
  var c = vr;
  Object.defineProperty(e, "setupTxExtension", { enumerable: !0, get: function() {
    return c.setupTxExtension;
  } });
  var E = Jn;
  Object.defineProperty(e, "createVestingAminoConverters", { enumerable: !0, get: function() {
    return E.createVestingAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgCreateVestingAccount", { enumerable: !0, get: function() {
    return E.isAminoMsgCreateVestingAccount;
  } });
  var k = yr;
  Object.defineProperty(e, "vestingTypes", { enumerable: !0, get: function() {
    return k.vestingTypes;
  } });
})(Yn);
var jt = {}, Bg = Q && Q.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(jt, "__esModule", { value: !0 });
jt.makeMultisignedTxBytes = jt.makeMultisignedTx = jt.makeCompactBitArray = void 0;
const Vg = Mi, Mg = Be, Hg = tn, Ti = Zu, jg = Bi, Qa = eo, jc = eo, Fa = Bg(Pt);
function Wc(e) {
  const o = Math.ceil(e.length / 8), t = e.length - Math.floor(e.length / 8) * 8, u = new Uint8Array(o);
  return e.forEach((r, m) => {
    const f = Math.floor(m / 8), b = m % 8;
    r && (u[f] |= 1 << 8 - 1 - b);
  }), Ti.CompactBitArray.fromPartial({ elems: u, extraBitsStored: t });
}
jt.makeCompactBitArray = Wc;
function qc(e, o, t, u, r) {
  const m = Array.from(r.keys()), f = (0, Mg.fromBech32)(m[0]).prefix, b = Array(e.value.pubkeys.length).fill(!1), R = new Array();
  for (let B = 0; B < e.value.pubkeys.length; B++) {
    const U = (0, Vg.pubkeyToAddress)(e.value.pubkeys[B], f), C = r.get(U);
    C && (b[B] = !0, R.push(C));
  }
  const T = {
    publicKey: (0, Hg.encodePubkey)(e),
    modeInfo: {
      multi: {
        bitarray: Wc(b),
        modeInfos: R.map((B) => ({ single: { mode: jg.SignMode.SIGN_MODE_LEGACY_AMINO_JSON } }))
      }
    },
    sequence: Fa.default.fromNumber(o)
  }, V = Qa.AuthInfo.fromPartial({
    signerInfos: [T],
    fee: {
      amount: [...t.amount],
      gasLimit: Fa.default.fromString(t.gas)
    }
  }), D = Qa.AuthInfo.encode(V).finish();
  return jc.TxRaw.fromPartial({
    bodyBytes: u,
    authInfoBytes: D,
    signatures: [Ti.MultiSignature.encode(Ti.MultiSignature.fromPartial({ signatures: R })).finish()]
  });
}
jt.makeMultisignedTx = qc;
function Wg(e, o, t, u, r) {
  const m = qc(e, o, t, u, r);
  return Uint8Array.from(jc.TxRaw.encode(m).finish());
}
jt.makeMultisignedTxBytes = Wg;
var Zc = {}, rs = {}, kt = {};
Object.defineProperty(kt, "__esModule", { value: !0 });
kt.pubkeyToAddress = kt.pubkeyToRawAddress = kt.rawSecp256k1PubkeyToRawAddress = kt.rawEd25519PubkeyToRawAddress = void 0;
const Ci = Vi, qg = Be;
function Qc(e) {
  if (e.length !== 32)
    throw new Error(`Invalid Ed25519 pubkey length: ${e.length}`);
  return (0, Ci.sha256)(e).slice(0, 20);
}
kt.rawEd25519PubkeyToRawAddress = Qc;
function Fc(e) {
  if (e.length !== 33)
    throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${e.length}`);
  return (0, Ci.ripemd160)((0, Ci.sha256)(e));
}
kt.rawSecp256k1PubkeyToRawAddress = Fc;
function Gc(e, o) {
  switch (e) {
    case "ed25519":
      return Qc(o);
    case "secp256k1":
      return Fc(o);
    default:
      throw new Error(`Pubkey type ${e} not supported`);
  }
}
kt.pubkeyToRawAddress = Gc;
function Zg(e, o) {
  return (0, qg.toHex)(Gc(e, o)).toUpperCase();
}
kt.pubkeyToAddress = Zg;
var Fe = {};
Object.defineProperty(Fe, "__esModule", { value: !0 });
Fe.DateTime = Fe.toSeconds = Fe.fromSeconds = Fe.toRfc3339WithNanoseconds = Fe.fromRfc3339WithNanoseconds = void 0;
const Qg = Be, Fg = Rt;
function Kc(e) {
  const o = (0, Qg.fromRfc3339)(e), t = e.match(/\.(\d+)Z$/), u = t ? t[1].slice(3) : "";
  return o.nanoseconds = parseInt(u.padEnd(6, "0"), 10), o;
}
Fe.fromRfc3339WithNanoseconds = Kc;
function zc(e) {
  var o;
  const t = e.toISOString(), u = ((o = e.nanoseconds) == null ? void 0 : o.toString()) ?? "";
  return `${t.slice(0, -1)}${u.padStart(6, "0")}Z`;
}
Fe.toRfc3339WithNanoseconds = zc;
function Gg(e, o = 0) {
  const t = new Fg.Uint32(o).toNumber();
  if (t > 999999999)
    throw new Error("Nano seconds must not exceed 999999999");
  const u = new Date(e * 1e3 + Math.floor(t / 1e6));
  return u.nanoseconds = t % 1e6, u;
}
Fe.fromSeconds = Gg;
function Kg(e) {
  return {
    seconds: Math.floor(e.getTime() / 1e3),
    nanos: e.getTime() % 1e3 * 1e6 + (e.nanoseconds ?? 0)
  };
}
Fe.toSeconds = Kg;
class zg {
  /** @deprecated Use fromRfc3339WithNanoseconds instead */
  static decode(o) {
    return Kc(o);
  }
  /** @deprecated Use toRfc3339WithNanoseconds instead */
  static encode(o) {
    return zc(o);
  }
}
Fe.DateTime = zg;
var Sr = {}, br = {}, Or = {}, kr = {};
Object.defineProperty(kr, "__esModule", { value: !0 });
kr.makeJsonRpcId = void 0;
let Yg = 1e4;
function $g() {
  return Yg += 1;
}
kr.makeJsonRpcId = $g;
var Pr = {}, Nt = {};
Object.defineProperty(Nt, "__esModule", { value: !0 });
Nt.jsonRpcCode = Nt.isJsonRpcSuccessResponse = Nt.isJsonRpcErrorResponse = void 0;
function Yc(e) {
  return typeof e.error == "object";
}
Nt.isJsonRpcErrorResponse = Yc;
function Xg(e) {
  return !Yc(e);
}
Nt.isJsonRpcSuccessResponse = Xg;
Nt.jsonRpcCode = {
  parseError: -32700,
  invalidRequest: -32600,
  methodNotFound: -32601,
  invalidParams: -32602,
  internalError: -32603,
  // server error (Reserved for implementation-defined server-errors.):
  // -32000 to -32099
  serverError: {
    default: -32e3
  }
};
Object.defineProperty(Pr, "__esModule", { value: !0 });
Pr.JsonRpcClient = void 0;
const eh = ro, th = Nt;
class nh {
  constructor(o) {
    this.connection = o;
  }
  async run(o) {
    const t = this.connection.responseStream.filter((m) => m.id === o.id), u = (0, eh.firstEvent)(t);
    this.connection.sendRequest(o);
    const r = await u;
    if ((0, th.isJsonRpcErrorResponse)(r)) {
      const m = r.error;
      throw new Error(`JSON RPC error: code=${m.code}; message='${m.message}'`);
    }
    return r;
  }
}
Pr.JsonRpcClient = nh;
var st = {}, Wt = {};
Object.defineProperty(Wt, "__esModule", { value: !0 });
Wt.isJsonCompatibleDictionary = Wt.isJsonCompatibleArray = Wt.isJsonCompatibleValue = void 0;
function is(e) {
  return !!(typeof e == "string" || typeof e == "number" || typeof e == "boolean" || e === null || // eslint-disable-next-line @typescript-eslint/no-use-before-define
  $c(e) || // eslint-disable-next-line @typescript-eslint/no-use-before-define
  Xc(e));
}
Wt.isJsonCompatibleValue = is;
function $c(e) {
  if (!Array.isArray(e))
    return !1;
  for (const o of e)
    if (!is(o))
      return !1;
  return !0;
}
Wt.isJsonCompatibleArray = $c;
function Xc(e) {
  return typeof e != "object" || e === null || Object.prototype.toString.call(e) !== "[object Object]" ? !1 : Object.values(e).every(is);
}
Wt.isJsonCompatibleDictionary = Xc;
Object.defineProperty(st, "__esModule", { value: !0 });
st.parseJsonRpcResponse = st.parseJsonRpcSuccessResponse = st.parseJsonRpcErrorResponse = st.parseJsonRpcRequest = st.parseJsonRpcId = void 0;
const qt = Wt;
function eu(e) {
  if (!(0, qt.isJsonCompatibleDictionary)(e))
    throw new Error("Data must be JSON compatible dictionary");
  const o = e.id;
  return typeof o != "number" && typeof o != "string" ? null : o;
}
st.parseJsonRpcId = eu;
function oh(e) {
  if (!(0, qt.isJsonCompatibleDictionary)(e))
    throw new Error("Data must be JSON compatible dictionary");
  if (e.jsonrpc !== "2.0")
    throw new Error(`Got unexpected jsonrpc version: ${e.jsonrpc}`);
  const o = eu(e);
  if (o === null)
    throw new Error("Invalid id field");
  const t = e.method;
  if (typeof t != "string")
    throw new Error("Invalid method field");
  if (!(0, qt.isJsonCompatibleArray)(e.params) && !(0, qt.isJsonCompatibleDictionary)(e.params))
    throw new Error("Invalid params field");
  return {
    jsonrpc: "2.0",
    id: o,
    method: t,
    params: e.params
  };
}
st.parseJsonRpcRequest = oh;
function rh(e) {
  if (typeof e.code != "number")
    throw new Error("Error property 'code' is not a number");
  if (typeof e.message != "string")
    throw new Error("Error property 'message' is not a string");
  let o;
  if (e.data === void 0)
    o = void 0;
  else if ((0, qt.isJsonCompatibleValue)(e.data))
    o = e.data;
  else
    throw new Error("Error property 'data' is defined but not a JSON compatible value.");
  return {
    code: e.code,
    message: e.message,
    ...o !== void 0 ? { data: o } : {}
  };
}
function tu(e) {
  if (!(0, qt.isJsonCompatibleDictionary)(e))
    throw new Error("Data must be JSON compatible dictionary");
  if (e.jsonrpc !== "2.0")
    throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(e)}`);
  const o = e.id;
  if (typeof o != "number" && typeof o != "string" && o !== null)
    throw new Error("Invalid id field");
  if (typeof e.error > "u" || !(0, qt.isJsonCompatibleDictionary)(e.error))
    throw new Error("Invalid error field");
  return {
    jsonrpc: "2.0",
    id: o,
    error: rh(e.error)
  };
}
st.parseJsonRpcErrorResponse = tu;
function nu(e) {
  if (!(0, qt.isJsonCompatibleDictionary)(e))
    throw new Error("Data must be JSON compatible dictionary");
  if (e.jsonrpc !== "2.0")
    throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(e)}`);
  const o = e.id;
  if (typeof o != "number" && typeof o != "string")
    throw new Error("Invalid id field");
  if (typeof e.result > "u")
    throw new Error("Invalid result field");
  const t = e.result;
  return {
    jsonrpc: "2.0",
    id: o,
    result: t
  };
}
st.parseJsonRpcSuccessResponse = nu;
function ih(e) {
  let o;
  try {
    o = tu(e);
  } catch {
    o = nu(e);
  }
  return o;
}
st.parseJsonRpcResponse = ih;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.jsonRpcCode = e.isJsonRpcSuccessResponse = e.isJsonRpcErrorResponse = e.parseJsonRpcSuccessResponse = e.parseJsonRpcResponse = e.parseJsonRpcRequest = e.parseJsonRpcId = e.parseJsonRpcErrorResponse = e.JsonRpcClient = e.makeJsonRpcId = void 0;
  var o = kr;
  Object.defineProperty(e, "makeJsonRpcId", { enumerable: !0, get: function() {
    return o.makeJsonRpcId;
  } });
  var t = Pr;
  Object.defineProperty(e, "JsonRpcClient", { enumerable: !0, get: function() {
    return t.JsonRpcClient;
  } });
  var u = st;
  Object.defineProperty(e, "parseJsonRpcErrorResponse", { enumerable: !0, get: function() {
    return u.parseJsonRpcErrorResponse;
  } }), Object.defineProperty(e, "parseJsonRpcId", { enumerable: !0, get: function() {
    return u.parseJsonRpcId;
  } }), Object.defineProperty(e, "parseJsonRpcRequest", { enumerable: !0, get: function() {
    return u.parseJsonRpcRequest;
  } }), Object.defineProperty(e, "parseJsonRpcResponse", { enumerable: !0, get: function() {
    return u.parseJsonRpcResponse;
  } }), Object.defineProperty(e, "parseJsonRpcSuccessResponse", { enumerable: !0, get: function() {
    return u.parseJsonRpcSuccessResponse;
  } });
  var r = Nt;
  Object.defineProperty(e, "isJsonRpcErrorResponse", { enumerable: !0, get: function() {
    return r.isJsonRpcErrorResponse;
  } }), Object.defineProperty(e, "isJsonRpcSuccessResponse", { enumerable: !0, get: function() {
    return r.isJsonRpcSuccessResponse;
  } }), Object.defineProperty(e, "jsonRpcCode", { enumerable: !0, get: function() {
    return r.jsonRpcCode;
  } });
})(Or);
var so = {}, ss = { exports: {} }, ou = function(e, o) {
  return function() {
    for (var t = new Array(arguments.length), u = 0; u < t.length; u++)
      t[u] = arguments[u];
    return e.apply(o, t);
  };
}, sh = ou, on = Object.prototype.toString;
function as(e) {
  return on.call(e) === "[object Array]";
}
function Ii(e) {
  return typeof e > "u";
}
function ah(e) {
  return e !== null && !Ii(e) && e.constructor !== null && !Ii(e.constructor) && typeof e.constructor.isBuffer == "function" && e.constructor.isBuffer(e);
}
function dh(e) {
  return on.call(e) === "[object ArrayBuffer]";
}
function ch(e) {
  return typeof FormData < "u" && e instanceof FormData;
}
function uh(e) {
  var o;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? o = ArrayBuffer.isView(e) : o = e && e.buffer && e.buffer instanceof ArrayBuffer, o;
}
function lh(e) {
  return typeof e == "string";
}
function ph(e) {
  return typeof e == "number";
}
function ru(e) {
  return e !== null && typeof e == "object";
}
function Co(e) {
  if (on.call(e) !== "[object Object]")
    return !1;
  var o = Object.getPrototypeOf(e);
  return o === null || o === Object.prototype;
}
function fh(e) {
  return on.call(e) === "[object Date]";
}
function mh(e) {
  return on.call(e) === "[object File]";
}
function gh(e) {
  return on.call(e) === "[object Blob]";
}
function iu(e) {
  return on.call(e) === "[object Function]";
}
function hh(e) {
  return ru(e) && iu(e.pipe);
}
function vh(e) {
  return typeof URLSearchParams < "u" && e instanceof URLSearchParams;
}
function yh(e) {
  return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "");
}
function Sh() {
  return typeof navigator < "u" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS") ? !1 : typeof window < "u" && typeof document < "u";
}
function ds(e, o) {
  if (!(e === null || typeof e > "u"))
    if (typeof e != "object" && (e = [e]), as(e))
      for (var t = 0, u = e.length; t < u; t++)
        o.call(null, e[t], t, e);
    else
      for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && o.call(null, e[r], r, e);
}
function xi() {
  var e = {};
  function o(r, m) {
    Co(e[m]) && Co(r) ? e[m] = xi(e[m], r) : Co(r) ? e[m] = xi({}, r) : as(r) ? e[m] = r.slice() : e[m] = r;
  }
  for (var t = 0, u = arguments.length; t < u; t++)
    ds(arguments[t], o);
  return e;
}
function bh(e, o, t) {
  return ds(o, function(u, r) {
    t && typeof u == "function" ? e[r] = sh(u, t) : e[r] = u;
  }), e;
}
function Oh(e) {
  return e.charCodeAt(0) === 65279 && (e = e.slice(1)), e;
}
var tt = {
  isArray: as,
  isArrayBuffer: dh,
  isBuffer: ah,
  isFormData: ch,
  isArrayBufferView: uh,
  isString: lh,
  isNumber: ph,
  isObject: ru,
  isPlainObject: Co,
  isUndefined: Ii,
  isDate: fh,
  isFile: mh,
  isBlob: gh,
  isFunction: iu,
  isStream: hh,
  isURLSearchParams: vh,
  isStandardBrowserEnv: Sh,
  forEach: ds,
  merge: xi,
  extend: bh,
  trim: yh,
  stripBOM: Oh
}, ln = tt;
function Ga(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var su = function(e, o, t) {
  if (!o)
    return e;
  var u;
  if (t)
    u = t(o);
  else if (ln.isURLSearchParams(o))
    u = o.toString();
  else {
    var r = [];
    ln.forEach(o, function(f, b) {
      f === null || typeof f > "u" || (ln.isArray(f) ? b = b + "[]" : f = [f], ln.forEach(f, function(R) {
        ln.isDate(R) ? R = R.toISOString() : ln.isObject(R) && (R = JSON.stringify(R)), r.push(Ga(b) + "=" + Ga(R));
      }));
    }), u = r.join("&");
  }
  if (u) {
    var m = e.indexOf("#");
    m !== -1 && (e = e.slice(0, m)), e += (e.indexOf("?") === -1 ? "?" : "&") + u;
  }
  return e;
}, kh = tt;
function Rr() {
  this.handlers = [];
}
Rr.prototype.use = function(e, o, t) {
  return this.handlers.push({
    fulfilled: e,
    rejected: o,
    synchronous: t ? t.synchronous : !1,
    runWhen: t ? t.runWhen : null
  }), this.handlers.length - 1;
};
Rr.prototype.eject = function(e) {
  this.handlers[e] && (this.handlers[e] = null);
};
Rr.prototype.forEach = function(e) {
  kh.forEach(this.handlers, function(o) {
    o !== null && e(o);
  });
};
var Ph = Rr, Rh = tt, Ah = function(e, o) {
  Rh.forEach(e, function(t, u) {
    u !== o && u.toUpperCase() === o.toUpperCase() && (e[o] = t, delete e[u]);
  });
}, au = function(e, o, t, u, r) {
  return e.config = o, t && (e.code = t), e.request = u, e.response = r, e.isAxiosError = !0, e.toJSON = function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  }, e;
}, di, Ka;
function du() {
  if (Ka)
    return di;
  Ka = 1;
  var e = au;
  return di = function(o, t, u, r, m) {
    var f = new Error(o);
    return e(f, t, u, r, m);
  }, di;
}
var ci, za;
function wh() {
  if (za)
    return ci;
  za = 1;
  var e = du();
  return ci = function(o, t, u) {
    var r = u.config.validateStatus;
    !u.status || !r || r(u.status) ? o(u) : t(e(
      "Request failed with status code " + u.status,
      u.config,
      null,
      u.request,
      u
    ));
  }, ci;
}
var ui, Ya;
function Nh() {
  if (Ya)
    return ui;
  Ya = 1;
  var e = tt;
  return ui = e.isStandardBrowserEnv() ? (
    // Standard browser envs support document.cookie
    function() {
      return {
        write: function(o, t, u, r, m, f) {
          var b = [];
          b.push(o + "=" + encodeURIComponent(t)), e.isNumber(u) && b.push("expires=" + new Date(u).toGMTString()), e.isString(r) && b.push("path=" + r), e.isString(m) && b.push("domain=" + m), f === !0 && b.push("secure"), document.cookie = b.join("; ");
        },
        read: function(o) {
          var t = document.cookie.match(new RegExp("(^|;\\s*)(" + o + ")=([^;]*)"));
          return t ? decodeURIComponent(t[3]) : null;
        },
        remove: function(o) {
          this.write(o, "", Date.now() - 864e5);
        }
      };
    }()
  ) : (
    // Non standard browser env (web workers, react-native) lack needed support.
    function() {
      return {
        write: function() {
        },
        read: function() {
          return null;
        },
        remove: function() {
        }
      };
    }()
  ), ui;
}
var $a, Xa;
function Eh() {
  return Xa || (Xa = 1, $a = function(e) {
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(e);
  }), $a;
}
var ed, td;
function Th() {
  return td || (td = 1, ed = function(e, o) {
    return o ? e.replace(/\/+$/, "") + "/" + o.replace(/^\/+/, "") : e;
  }), ed;
}
var li, nd;
function Ch() {
  if (nd)
    return li;
  nd = 1;
  var e = Eh(), o = Th();
  return li = function(t, u) {
    return t && !e(u) ? o(t, u) : u;
  }, li;
}
var pi, od;
function Ih() {
  if (od)
    return pi;
  od = 1;
  var e = tt, o = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  return pi = function(t) {
    var u = {}, r, m, f;
    return t && e.forEach(t.split(`
`), function(b) {
      if (f = b.indexOf(":"), r = e.trim(b.substr(0, f)).toLowerCase(), m = e.trim(b.substr(f + 1)), r) {
        if (u[r] && o.indexOf(r) >= 0)
          return;
        r === "set-cookie" ? u[r] = (u[r] ? u[r] : []).concat([m]) : u[r] = u[r] ? u[r] + ", " + m : m;
      }
    }), u;
  }, pi;
}
var fi, rd;
function xh() {
  if (rd)
    return fi;
  rd = 1;
  var e = tt;
  return fi = e.isStandardBrowserEnv() ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function() {
      var o = /(msie|trident)/i.test(navigator.userAgent), t = document.createElement("a"), u;
      function r(m) {
        var f = m;
        return o && (t.setAttribute("href", f), f = t.href), t.setAttribute("href", f), {
          href: t.href,
          protocol: t.protocol ? t.protocol.replace(/:$/, "") : "",
          host: t.host,
          search: t.search ? t.search.replace(/^\?/, "") : "",
          hash: t.hash ? t.hash.replace(/^#/, "") : "",
          hostname: t.hostname,
          port: t.port,
          pathname: t.pathname.charAt(0) === "/" ? t.pathname : "/" + t.pathname
        };
      }
      return u = r(window.location.href), function(m) {
        var f = e.isString(m) ? r(m) : m;
        return f.protocol === u.protocol && f.host === u.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    function() {
      return function() {
        return !0;
      };
    }()
  ), fi;
}
var mi, id;
function _h() {
  if (id)
    return mi;
  id = 1;
  var e = tt, o = wh(), t = Nh(), u = su, r = Ch(), m = Ih(), f = xh(), b = du();
  return mi = function(R) {
    return new Promise(function(T, V) {
      var D = R.data, B = R.headers, U = R.responseType;
      e.isFormData(D) && delete B["Content-Type"];
      var C = new XMLHttpRequest();
      if (R.auth) {
        var l = R.auth.username || "", S = R.auth.password ? unescape(encodeURIComponent(R.auth.password)) : "";
        B.Authorization = "Basic " + btoa(l + ":" + S);
      }
      var A = r(R.baseURL, R.url);
      C.open(R.method.toUpperCase(), u(A, R.params, R.paramsSerializer), !0), C.timeout = R.timeout;
      function d() {
        if (C) {
          var h = "getAllResponseHeaders" in C ? m(C.getAllResponseHeaders()) : null, x = !U || U === "text" || U === "json" ? C.responseText : C.response, _ = {
            data: x,
            status: C.status,
            statusText: C.statusText,
            headers: h,
            config: R,
            request: C
          };
          o(T, V, _), C = null;
        }
      }
      if ("onloadend" in C ? C.onloadend = d : C.onreadystatechange = function() {
        !C || C.readyState !== 4 || C.status === 0 && !(C.responseURL && C.responseURL.indexOf("file:") === 0) || setTimeout(d);
      }, C.onabort = function() {
        C && (V(b("Request aborted", R, "ECONNABORTED", C)), C = null);
      }, C.onerror = function() {
        V(b("Network Error", R, null, C)), C = null;
      }, C.ontimeout = function() {
        var h = "timeout of " + R.timeout + "ms exceeded";
        R.timeoutErrorMessage && (h = R.timeoutErrorMessage), V(b(
          h,
          R,
          R.transitional && R.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
          C
        )), C = null;
      }, e.isStandardBrowserEnv()) {
        var p = (R.withCredentials || f(A)) && R.xsrfCookieName ? t.read(R.xsrfCookieName) : void 0;
        p && (B[R.xsrfHeaderName] = p);
      }
      "setRequestHeader" in C && e.forEach(B, function(h, x) {
        typeof D > "u" && x.toLowerCase() === "content-type" ? delete B[x] : C.setRequestHeader(x, h);
      }), e.isUndefined(R.withCredentials) || (C.withCredentials = !!R.withCredentials), U && U !== "json" && (C.responseType = R.responseType), typeof R.onDownloadProgress == "function" && C.addEventListener("progress", R.onDownloadProgress), typeof R.onUploadProgress == "function" && C.upload && C.upload.addEventListener("progress", R.onUploadProgress), R.cancelToken && R.cancelToken.promise.then(function(h) {
        C && (C.abort(), V(h), C = null);
      }), D || (D = null), C.send(D);
    });
  }, mi;
}
var we = tt, sd = Ah, Jh = au, Uh = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function ad(e, o) {
  !we.isUndefined(e) && we.isUndefined(e["Content-Type"]) && (e["Content-Type"] = o);
}
function Dh() {
  var e;
  return (typeof XMLHttpRequest < "u" || typeof process < "u" && Object.prototype.toString.call(process) === "[object process]") && (e = _h()), e;
}
function Lh(e, o, t) {
  if (we.isString(e))
    try {
      return (o || JSON.parse)(e), we.trim(e);
    } catch (u) {
      if (u.name !== "SyntaxError")
        throw u;
    }
  return (t || JSON.stringify)(e);
}
var Ar = {
  transitional: {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
  },
  adapter: Dh(),
  transformRequest: [function(e, o) {
    return sd(o, "Accept"), sd(o, "Content-Type"), we.isFormData(e) || we.isArrayBuffer(e) || we.isBuffer(e) || we.isStream(e) || we.isFile(e) || we.isBlob(e) ? e : we.isArrayBufferView(e) ? e.buffer : we.isURLSearchParams(e) ? (ad(o, "application/x-www-form-urlencoded;charset=utf-8"), e.toString()) : we.isObject(e) || o && o["Content-Type"] === "application/json" ? (ad(o, "application/json"), Lh(e)) : e;
  }],
  transformResponse: [function(e) {
    var o = this.transitional, t = o && o.silentJSONParsing, u = o && o.forcedJSONParsing, r = !t && this.responseType === "json";
    if (r || u && we.isString(e) && e.length)
      try {
        return JSON.parse(e);
      } catch (m) {
        if (r)
          throw m.name === "SyntaxError" ? Jh(m, this, "E_JSON_PARSE") : m;
      }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  }
};
Ar.headers = {
  common: {
    Accept: "application/json, text/plain, */*"
  }
};
we.forEach(["delete", "get", "head"], function(e) {
  Ar.headers[e] = {};
});
we.forEach(["post", "put", "patch"], function(e) {
  Ar.headers[e] = we.merge(Uh);
});
var cs = Ar, Bh = tt, Vh = cs, Mh = function(e, o, t) {
  var u = this || Vh;
  return Bh.forEach(t, function(r) {
    e = r.call(u, e, o);
  }), e;
}, dd, cd;
function cu() {
  return cd || (cd = 1, dd = function(e) {
    return !!(e && e.__CANCEL__);
  }), dd;
}
var ud = tt, gi = Mh, Hh = cu(), jh = cs;
function hi(e) {
  e.cancelToken && e.cancelToken.throwIfRequested();
}
var Wh = function(e) {
  hi(e), e.headers = e.headers || {}, e.data = gi.call(
    e,
    e.data,
    e.headers,
    e.transformRequest
  ), e.headers = ud.merge(
    e.headers.common || {},
    e.headers[e.method] || {},
    e.headers
  ), ud.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function(t) {
      delete e.headers[t];
    }
  );
  var o = e.adapter || jh.adapter;
  return o(e).then(function(t) {
    return hi(e), t.data = gi.call(
      e,
      t.data,
      t.headers,
      e.transformResponse
    ), t;
  }, function(t) {
    return Hh(t) || (hi(e), t && t.response && (t.response.data = gi.call(
      e,
      t.response.data,
      t.response.headers,
      e.transformResponse
    ))), Promise.reject(t);
  });
}, Te = tt, uu = function(e, o) {
  o = o || {};
  var t = {}, u = ["url", "method", "data"], r = ["headers", "auth", "proxy", "params"], m = [
    "baseURL",
    "transformRequest",
    "transformResponse",
    "paramsSerializer",
    "timeout",
    "timeoutMessage",
    "withCredentials",
    "adapter",
    "responseType",
    "xsrfCookieName",
    "xsrfHeaderName",
    "onUploadProgress",
    "onDownloadProgress",
    "decompress",
    "maxContentLength",
    "maxBodyLength",
    "maxRedirects",
    "transport",
    "httpAgent",
    "httpsAgent",
    "cancelToken",
    "socketPath",
    "responseEncoding"
  ], f = ["validateStatus"];
  function b(D, B) {
    return Te.isPlainObject(D) && Te.isPlainObject(B) ? Te.merge(D, B) : Te.isPlainObject(B) ? Te.merge({}, B) : Te.isArray(B) ? B.slice() : B;
  }
  function R(D) {
    Te.isUndefined(o[D]) ? Te.isUndefined(e[D]) || (t[D] = b(void 0, e[D])) : t[D] = b(e[D], o[D]);
  }
  Te.forEach(u, function(D) {
    Te.isUndefined(o[D]) || (t[D] = b(void 0, o[D]));
  }), Te.forEach(r, R), Te.forEach(m, function(D) {
    Te.isUndefined(o[D]) ? Te.isUndefined(e[D]) || (t[D] = b(void 0, e[D])) : t[D] = b(void 0, o[D]);
  }), Te.forEach(f, function(D) {
    D in o ? t[D] = b(e[D], o[D]) : D in e && (t[D] = b(void 0, e[D]));
  });
  var T = u.concat(r).concat(m).concat(f), V = Object.keys(e).concat(Object.keys(o)).filter(function(D) {
    return T.indexOf(D) === -1;
  });
  return Te.forEach(V, R), t;
};
const qh = "axios", Zh = "0.21.4", Qh = "Promise based HTTP client for the browser and node.js", Fh = "index.js", Gh = {
  test: "grunt test",
  start: "node ./sandbox/server.js",
  build: "NODE_ENV=production grunt build",
  preversion: "npm test",
  version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
  postversion: "git push && git push --tags",
  examples: "node ./examples/server.js",
  coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
  fix: "eslint --fix lib/**/*.js"
}, Kh = {
  type: "git",
  url: "https://github.com/axios/axios.git"
}, zh = [
  "xhr",
  "http",
  "ajax",
  "promise",
  "node"
], Yh = "Matt Zabriskie", $h = "MIT", Xh = {
  url: "https://github.com/axios/axios/issues"
}, ev = "https://axios-http.com", tv = {
  coveralls: "^3.0.0",
  "es6-promise": "^4.2.4",
  grunt: "^1.3.0",
  "grunt-banner": "^0.6.0",
  "grunt-cli": "^1.2.0",
  "grunt-contrib-clean": "^1.1.0",
  "grunt-contrib-watch": "^1.0.0",
  "grunt-eslint": "^23.0.0",
  "grunt-karma": "^4.0.0",
  "grunt-mocha-test": "^0.13.3",
  "grunt-ts": "^6.0.0-beta.19",
  "grunt-webpack": "^4.0.2",
  "istanbul-instrumenter-loader": "^1.0.0",
  "jasmine-core": "^2.4.1",
  karma: "^6.3.2",
  "karma-chrome-launcher": "^3.1.0",
  "karma-firefox-launcher": "^2.1.0",
  "karma-jasmine": "^1.1.1",
  "karma-jasmine-ajax": "^0.1.13",
  "karma-safari-launcher": "^1.0.0",
  "karma-sauce-launcher": "^4.3.6",
  "karma-sinon": "^1.0.5",
  "karma-sourcemap-loader": "^0.3.8",
  "karma-webpack": "^4.0.2",
  "load-grunt-tasks": "^3.5.2",
  minimist: "^1.2.0",
  mocha: "^8.2.1",
  sinon: "^4.5.0",
  "terser-webpack-plugin": "^4.2.3",
  typescript: "^4.0.5",
  "url-search-params": "^0.10.0",
  webpack: "^4.44.2",
  "webpack-dev-server": "^3.11.0"
}, nv = {
  "./lib/adapters/http.js": "./lib/adapters/xhr.js"
}, ov = "dist/axios.min.js", rv = "dist/axios.min.js", iv = "./index.d.ts", sv = {
  "follow-redirects": "^1.14.0"
}, av = [
  {
    path: "./dist/axios.min.js",
    threshold: "5kB"
  }
], dv = {
  name: qh,
  version: Zh,
  description: Qh,
  main: Fh,
  scripts: Gh,
  repository: Kh,
  keywords: zh,
  author: Yh,
  license: $h,
  bugs: Xh,
  homepage: ev,
  devDependencies: tv,
  browser: nv,
  jsdelivr: ov,
  unpkg: rv,
  typings: iv,
  dependencies: sv,
  bundlesize: av
};
var lu = dv, us = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(e, o) {
  us[e] = function(t) {
    return typeof t === e || "a" + (o < 1 ? "n " : " ") + e;
  };
});
var ld = {}, cv = lu.version.split(".");
function pu(e, o) {
  for (var t = o ? o.split(".") : cv, u = e.split("."), r = 0; r < 3; r++) {
    if (t[r] > u[r])
      return !0;
    if (t[r] < u[r])
      return !1;
  }
  return !1;
}
us.transitional = function(e, o, t) {
  var u = o && pu(o);
  function r(m, f) {
    return "[Axios v" + lu.version + "] Transitional option '" + m + "'" + f + (t ? ". " + t : "");
  }
  return function(m, f, b) {
    if (e === !1)
      throw new Error(r(f, " has been removed in " + o));
    return u && !ld[f] && (ld[f] = !0, console.warn(
      r(
        f,
        " has been deprecated since v" + o + " and will be removed in the near future"
      )
    )), e ? e(m, f, b) : !0;
  };
};
function uv(e, o, t) {
  if (typeof e != "object")
    throw new TypeError("options must be an object");
  for (var u = Object.keys(e), r = u.length; r-- > 0; ) {
    var m = u[r], f = o[m];
    if (f) {
      var b = e[m], R = b === void 0 || f(b, m, e);
      if (R !== !0)
        throw new TypeError("option " + m + " must be " + R);
      continue;
    }
    if (t !== !0)
      throw Error("Unknown option " + m);
  }
}
var lv = {
  isOlderVersion: pu,
  assertOptions: uv,
  validators: us
}, fu = tt, pv = su, pd = Ph, fd = Wh, wr = uu, mu = lv, pn = mu.validators;
function ao(e) {
  this.defaults = e, this.interceptors = {
    request: new pd(),
    response: new pd()
  };
}
ao.prototype.request = function(e) {
  typeof e == "string" ? (e = arguments[1] || {}, e.url = arguments[0]) : e = e || {}, e = wr(this.defaults, e), e.method ? e.method = e.method.toLowerCase() : this.defaults.method ? e.method = this.defaults.method.toLowerCase() : e.method = "get";
  var o = e.transitional;
  o !== void 0 && mu.assertOptions(o, {
    silentJSONParsing: pn.transitional(pn.boolean, "1.0.0"),
    forcedJSONParsing: pn.transitional(pn.boolean, "1.0.0"),
    clarifyTimeoutError: pn.transitional(pn.boolean, "1.0.0")
  }, !1);
  var t = [], u = !0;
  this.interceptors.request.forEach(function(V) {
    typeof V.runWhen == "function" && V.runWhen(e) === !1 || (u = u && V.synchronous, t.unshift(V.fulfilled, V.rejected));
  });
  var r = [];
  this.interceptors.response.forEach(function(V) {
    r.push(V.fulfilled, V.rejected);
  });
  var m;
  if (!u) {
    var f = [fd, void 0];
    for (Array.prototype.unshift.apply(f, t), f = f.concat(r), m = Promise.resolve(e); f.length; )
      m = m.then(f.shift(), f.shift());
    return m;
  }
  for (var b = e; t.length; ) {
    var R = t.shift(), T = t.shift();
    try {
      b = R(b);
    } catch (V) {
      T(V);
      break;
    }
  }
  try {
    m = fd(b);
  } catch (V) {
    return Promise.reject(V);
  }
  for (; r.length; )
    m = m.then(r.shift(), r.shift());
  return m;
};
ao.prototype.getUri = function(e) {
  return e = wr(this.defaults, e), pv(e.url, e.params, e.paramsSerializer).replace(/^\?/, "");
};
fu.forEach(["delete", "get", "head", "options"], function(e) {
  ao.prototype[e] = function(o, t) {
    return this.request(wr(t || {}, {
      method: e,
      url: o,
      data: (t || {}).data
    }));
  };
});
fu.forEach(["post", "put", "patch"], function(e) {
  ao.prototype[e] = function(o, t, u) {
    return this.request(wr(u || {}, {
      method: e,
      url: o,
      data: t
    }));
  };
});
var fv = ao, vi, md;
function gu() {
  if (md)
    return vi;
  md = 1;
  function e(o) {
    this.message = o;
  }
  return e.prototype.toString = function() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  }, e.prototype.__CANCEL__ = !0, vi = e, vi;
}
var yi, gd;
function mv() {
  if (gd)
    return yi;
  gd = 1;
  var e = gu();
  function o(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    var u;
    this.promise = new Promise(function(m) {
      u = m;
    });
    var r = this;
    t(function(m) {
      r.reason || (r.reason = new e(m), u(r.reason));
    });
  }
  return o.prototype.throwIfRequested = function() {
    if (this.reason)
      throw this.reason;
  }, o.source = function() {
    var t, u = new o(function(r) {
      t = r;
    });
    return {
      token: u,
      cancel: t
    };
  }, yi = o, yi;
}
var hd, vd;
function gv() {
  return vd || (vd = 1, hd = function(e) {
    return function(o) {
      return e.apply(null, o);
    };
  }), hd;
}
var yd, Sd;
function hv() {
  return Sd || (Sd = 1, yd = function(e) {
    return typeof e == "object" && e.isAxiosError === !0;
  }), yd;
}
var bd = tt, vv = ou, Io = fv, yv = uu, Sv = cs;
function hu(e) {
  var o = new Io(e), t = vv(Io.prototype.request, o);
  return bd.extend(t, Io.prototype, o), bd.extend(t, o), t;
}
var gt = hu(Sv);
gt.Axios = Io;
gt.create = function(e) {
  return hu(yv(gt.defaults, e));
};
gt.Cancel = gu();
gt.CancelToken = mv();
gt.isCancel = cu();
gt.all = function(e) {
  return Promise.all(e);
};
gt.spread = gv();
gt.isAxiosError = hv();
ss.exports = gt;
ss.exports.default = gt;
var bv = ss.exports, Ov = bv, kv = Q && Q.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(so, "__esModule", { value: !0 });
so.http = void 0;
const Pv = kv(Ov);
function Rv(e) {
  if (e.status >= 400)
    throw new Error(`Bad status on response: ${e.status}`);
  return e;
}
function Av(e) {
  return e.toString().includes("emitExperimentalWarning");
}
async function wv(e, o, t, u) {
  if (typeof fetch == "function" && !Av(fetch)) {
    const r = {
      method: e,
      body: u ? JSON.stringify(u) : void 0,
      headers: {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        "Content-Type": "application/json",
        ...t
      }
    };
    return fetch(o, r).then(Rv).then((m) => m.json());
  } else
    return Pv.default.request({ url: o, method: e, data: u, headers: t }).then((r) => r.data);
}
so.http = wv;
var Et = {};
Object.defineProperty(Et, "__esModule", { value: !0 });
Et.hasProtocol = Et.instanceOfRpcStreamingClient = void 0;
function Nv(e) {
  return typeof e.listen == "function";
}
Et.instanceOfRpcStreamingClient = Nv;
function Ev(e) {
  return e.search("://") !== -1;
}
Et.hasProtocol = Ev;
Object.defineProperty(br, "__esModule", { value: !0 });
br.HttpBatchClient = void 0;
const Od = Or, Tv = so, Cv = Et, kd = {
  dispatchInterval: 20,
  batchSizeLimit: 20
};
class Iv {
  constructor(o, t = {}) {
    this.queue = [], this.options = {
      batchSizeLimit: t.batchSizeLimit ?? kd.batchSizeLimit,
      dispatchInterval: t.dispatchInterval ?? kd.dispatchInterval
    }, typeof o == "string" ? this.url = (0, Cv.hasProtocol)(o) ? o : "http://" + o : (this.url = o.url, this.headers = o.headers), this.timer = setInterval(() => this.tick(), t.dispatchInterval), this.validate();
  }
  disconnect() {
    this.timer && clearInterval(this.timer), this.timer = void 0;
  }
  async execute(o) {
    return new Promise((t, u) => {
      this.queue.push({ request: o, resolve: t, reject: u }), this.queue.length >= this.options.batchSizeLimit && this.tick();
    });
  }
  validate() {
    if (!this.options.batchSizeLimit || !Number.isSafeInteger(this.options.batchSizeLimit) || this.options.batchSizeLimit < 1)
      throw new Error("batchSizeLimit must be a safe integer >= 1");
  }
  /**
   * This is called in an interval where promise rejections cannot be handled.
   * So this is not async and HTTP errors need to be handled by the queued promises.
   */
  tick() {
    const o = this.queue.splice(0, this.options.batchSizeLimit);
    if (!o.length)
      return;
    const t = o.map((r) => r.request), u = t.map((r) => r.id);
    (0, Tv.http)("POST", this.url, this.headers, t).then((r) => {
      (Array.isArray(r) ? r : [r]).forEach((m) => {
        const f = o.find((V) => V.request.id === m.id);
        if (!f)
          return;
        const { reject: b, resolve: R } = f, T = (0, Od.parseJsonRpcResponse)(m);
        (0, Od.isJsonRpcErrorResponse)(T) ? b(new Error(JSON.stringify(T.error))) : R(T);
      });
    }, (r) => {
      for (const m of u) {
        const f = o.find((b) => b.request.id === m);
        if (!f)
          return;
        f.reject(r);
      }
    });
  }
}
br.HttpBatchClient = Iv;
var Nr = {};
Object.defineProperty(Nr, "__esModule", { value: !0 });
Nr.HttpClient = void 0;
const Pd = Or, xv = so, _v = Et;
class Jv {
  constructor(o) {
    typeof o == "string" ? this.url = (0, _v.hasProtocol)(o) ? o : "http://" + o : (this.url = o.url, this.headers = o.headers);
  }
  disconnect() {
  }
  async execute(o) {
    const t = (0, Pd.parseJsonRpcResponse)(await (0, xv.http)("POST", this.url, this.headers, o));
    if ((0, Pd.isJsonRpcErrorResponse)(t))
      throw new Error(JSON.stringify(t.error));
    return t;
  }
}
Nr.HttpClient = Jv;
var Er = {}, vu = {}, ls = {}, co = {}, uo = {}, gn = null;
typeof WebSocket < "u" ? gn = WebSocket : typeof MozWebSocket < "u" ? gn = MozWebSocket : typeof Q < "u" ? gn = Q.WebSocket || Q.MozWebSocket : typeof window < "u" ? gn = window.WebSocket || window.MozWebSocket : typeof self < "u" && (gn = self.WebSocket || self.MozWebSocket);
var Uv = gn, Dv = Q && Q.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(uo, "__esModule", { value: !0 });
uo.SocketWrapper = void 0;
const fn = Dv(Uv);
function Lv() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
class Bv {
  constructor(o, t, u, r, m, f = 1e4) {
    this.closed = !1, this.connected = new Promise((b, R) => {
      this.connectedResolver = b, this.connectedRejecter = R;
    }), this.url = o, this.messageHandler = t, this.errorHandler = u, this.openHandler = r, this.closeHandler = m, this.timeout = f;
  }
  /**
   * returns a promise that resolves when connection is open
   */
  connect() {
    const o = new fn.default(this.url);
    o.onerror = (u) => {
      this.clearTimeout(), this.errorHandler && this.errorHandler(u);
    }, o.onmessage = (u) => {
      this.messageHandler({
        type: u.type,
        data: u.data
      });
    }, o.onopen = (u) => {
      this.clearTimeout(), this.connectedResolver(), this.openHandler && this.openHandler();
    }, o.onclose = (u) => {
      this.closed = !0, this.closeHandler && this.closeHandler(u);
    };
    const t = Date.now();
    this.timeoutId = setTimeout(() => {
      o.onmessage = () => 0, o.onerror = () => 0, o.onopen = () => 0, o.onclose = () => 0, o.close(), this.socket = void 0;
      const u = Math.floor(Date.now() - t);
      this.connectedRejecter(`Connection attempt timed out after ${u} ms`);
    }, this.timeout), this.socket = o;
  }
  /**
   * Closes an established connection and aborts other connection states
   */
  disconnect() {
    if (!this.socket)
      throw new Error("Socket undefined. This must be called after connecting.");
    switch (this.clearTimeout(), this.socket.readyState) {
      case fn.default.OPEN:
        this.socket.close(
          1e3
          /* Normal Closure */
        );
        break;
      case fn.default.CLOSED:
        break;
      case fn.default.CONNECTING:
        this.socket.onopen = () => 0, this.socket.onclose = () => 0, this.socket.onerror = () => 0, this.socket.onmessage = () => 0, this.socket = void 0, this.closeHandler && this.closeHandler({ wasClean: !1, code: 4001 });
        break;
      case fn.default.CLOSING:
        break;
      default:
        throw new Error(`Unknown readyState: ${this.socket.readyState}`);
    }
  }
  async send(o) {
    return new Promise((t, u) => {
      if (!this.socket)
        throw new Error("Socket undefined. This must be called after connecting.");
      if (this.closed)
        throw new Error("Socket was closed, so no data can be sent anymore.");
      if (this.socket.readyState !== fn.default.OPEN)
        throw new Error("Websocket is not open");
      Lv() ? this.socket.send(o, (r) => r ? u(r) : t()) : (this.socket.send(o), t());
    });
  }
  /**
   * Clears the timeout function, such that no timeout error will be raised anymore. This should be
   * called when the connection is established, a connection error occurred or the socket is disconnected.
   *
   * This method must not be called before `connect()`.
   * This method is idempotent.
   */
  clearTimeout() {
    if (!this.timeoutId)
      throw new Error("Timeout ID not set. This should not happen and usually means connect() was not called.");
    clearTimeout(this.timeoutId);
  }
}
uo.SocketWrapper = Bv;
Object.defineProperty(co, "__esModule", { value: !0 });
co.StreamingSocket = void 0;
const Vv = Ee, Mv = uo;
class Hv {
  constructor(o, t = 1e4) {
    this.socket = new Mv.SocketWrapper(o, (r) => {
      this.eventProducerListener && this.eventProducerListener.next(r);
    }, (r) => {
      this.eventProducerListener && this.eventProducerListener.error(r);
    }, () => {
    }, (r) => {
      this.eventProducerListener && (r.wasClean ? this.eventProducerListener.complete() : this.eventProducerListener.error("Socket was closed unclean"));
    }, t), this.connected = this.socket.connected;
    const u = {
      start: (r) => this.eventProducerListener = r,
      stop: () => this.eventProducerListener = void 0
    };
    this.events = Vv.Stream.create(u);
  }
  connect() {
    this.socket.connect();
  }
  disconnect() {
    this.socket.disconnect();
  }
  async send(o) {
    return this.socket.send(o);
  }
}
co.StreamingSocket = Hv;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueueingStreamingSocket = e.ConnectionStatus = void 0;
  const o = ro, t = Ee, u = co;
  var r;
  (function(f) {
    f[f.Unconnected = 0] = "Unconnected", f[f.Connecting = 1] = "Connecting", f[f.Connected = 2] = "Connected", f[f.Disconnected = 3] = "Disconnected";
  })(r = e.ConnectionStatus || (e.ConnectionStatus = {}));
  class m {
    constructor(b, R = 1e4, T) {
      this.queue = [], this.isProcessingQueue = !1, this.url = b, this.timeout = R, this.reconnectedHandler = T;
      const V = {
        start: (D) => this.eventProducerListener = D,
        stop: () => this.eventProducerListener = void 0
      };
      this.events = t.Stream.create(V), this.connectionStatusProducer = new o.DefaultValueProducer(r.Unconnected), this.connectionStatus = new o.ValueAndUpdates(this.connectionStatusProducer), this.socket = new u.StreamingSocket(this.url, this.timeout), this.socket.events.subscribe({
        next: (D) => {
          if (!this.eventProducerListener)
            throw new Error("No event producer listener set");
          this.eventProducerListener.next(D);
        },
        error: () => this.connectionStatusProducer.update(r.Disconnected)
      });
    }
    connect() {
      this.connectionStatusProducer.update(r.Connecting), this.socket.connected.then(async () => (this.connectionStatusProducer.update(r.Connected), this.processQueue()), () => this.connectionStatusProducer.update(r.Disconnected)), this.socket.connect();
    }
    disconnect() {
      this.connectionStatusProducer.update(r.Disconnected), this.socket.disconnect();
    }
    reconnect() {
      this.socket = new u.StreamingSocket(this.url, this.timeout), this.socket.events.subscribe({
        next: (b) => {
          if (!this.eventProducerListener)
            throw new Error("No event producer listener set");
          this.eventProducerListener.next(b);
        },
        error: () => this.connectionStatusProducer.update(r.Disconnected)
      }), this.socket.connected.then(() => {
        this.reconnectedHandler && this.reconnectedHandler();
      }), this.connect();
    }
    getQueueLength() {
      return this.queue.length;
    }
    queueRequest(b) {
      this.queue.push(b), this.processQueue();
    }
    async processQueue() {
      if (this.isProcessingQueue || this.connectionStatus.value !== r.Connected)
        return;
      this.isProcessingQueue = !0;
      let b;
      for (; b = this.queue.shift(); )
        try {
          await this.socket.send(b), this.isProcessingQueue = !1;
        } catch {
          this.queue.unshift(b), this.isProcessingQueue = !1;
          return;
        }
    }
  }
  e.QueueingStreamingSocket = m;
})(ls);
var Tr = {};
Object.defineProperty(Tr, "__esModule", { value: !0 });
Tr.ReconnectingSocket = void 0;
const jv = Ee, Si = ls;
class ps {
  /** Starts with a 0.1 second timeout, then doubles every attempt with a maximum timeout of 5 seconds. */
  static calculateTimeout(o) {
    return Math.min(2 ** o * 100, 5e3);
  }
  constructor(o, t = 1e4, u) {
    this.unconnected = !0, this.disconnected = !1, this.timeoutIndex = 0, this.reconnectTimeout = null;
    const r = {
      start: (m) => this.eventProducerListener = m,
      stop: () => this.eventProducerListener = void 0
    };
    this.events = jv.Stream.create(r), this.socket = new Si.QueueingStreamingSocket(o, t, u), this.socket.events.subscribe({
      next: (m) => {
        this.eventProducerListener && this.eventProducerListener.next(m);
      },
      error: (m) => {
        this.eventProducerListener && this.eventProducerListener.error(m);
      }
    }), this.connectionStatus = this.socket.connectionStatus, this.connectionStatus.updates.subscribe({
      next: (m) => {
        m === Si.ConnectionStatus.Connected && (this.timeoutIndex = 0), m === Si.ConnectionStatus.Disconnected && (this.reconnectTimeout && (clearTimeout(this.reconnectTimeout), this.reconnectTimeout = null), this.reconnectTimeout = setTimeout(() => this.socket.reconnect(), ps.calculateTimeout(this.timeoutIndex++)));
      }
    });
  }
  connect() {
    if (!this.unconnected)
      throw new Error("Cannot connect: socket has already connected");
    this.socket.connect(), this.unconnected = !1;
  }
  disconnect() {
    if (this.unconnected)
      throw new Error("Cannot disconnect: socket has not yet connected");
    this.socket.disconnect(), this.eventProducerListener && this.eventProducerListener.complete(), this.disconnected = !0;
  }
  queueRequest(o) {
    if (this.disconnected)
      throw new Error("Cannot queue request: socket has disconnected");
    this.socket.queueRequest(o);
  }
}
Tr.ReconnectingSocket = ps;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.StreamingSocket = e.SocketWrapper = e.ReconnectingSocket = e.QueueingStreamingSocket = e.ConnectionStatus = void 0;
  var o = ls;
  Object.defineProperty(e, "ConnectionStatus", { enumerable: !0, get: function() {
    return o.ConnectionStatus;
  } }), Object.defineProperty(e, "QueueingStreamingSocket", { enumerable: !0, get: function() {
    return o.QueueingStreamingSocket;
  } });
  var t = Tr;
  Object.defineProperty(e, "ReconnectingSocket", { enumerable: !0, get: function() {
    return t.ReconnectingSocket;
  } });
  var u = uo;
  Object.defineProperty(e, "SocketWrapper", { enumerable: !0, get: function() {
    return u.SocketWrapper;
  } });
  var r = co;
  Object.defineProperty(e, "StreamingSocket", { enumerable: !0, get: function() {
    return r.StreamingSocket;
  } });
})(vu);
Object.defineProperty(Er, "__esModule", { value: !0 });
Er.WebsocketClient = void 0;
const Uo = Or, Rd = vu, Wv = ro, qv = Ee, Zv = Et;
function Qv(e) {
  throw e;
}
function yu(e) {
  if (e.type !== "message")
    throw new Error(`Unexcepted message type on websocket: ${e.type}`);
  return (0, Uo.parseJsonRpcResponse)(JSON.parse(e.data));
}
class Fv {
  constructor(o, t) {
    this.running = !1, this.subscriptions = [], this.request = o, this.socket = t;
  }
  /**
   * Implementation of Producer.start
   */
  start(o) {
    if (this.running)
      throw Error("Already started. Please stop first before restarting.");
    this.running = !0, this.connectToClient(o), this.socket.queueRequest(JSON.stringify(this.request));
  }
  /**
   * Implementation of Producer.stop
   *
   * Called by the stream when the stream's last listener stopped listening
   * or when the producer completed.
   */
  stop() {
    this.running = !1;
    const o = { ...this.request, method: "unsubscribe" };
    try {
      this.socket.queueRequest(JSON.stringify(o));
    } catch (t) {
      if (!(t instanceof Error && t.message.match(/socket has disconnected/i)))
        throw t;
    }
  }
  connectToClient(o) {
    const t = this.socket.events.map(yu), u = t.filter((f) => f.id === this.request.id).subscribe({
      next: (f) => {
        (0, Uo.isJsonRpcErrorResponse)(f) && (this.closeSubscriptions(), o.error(JSON.stringify(f.error))), u.unsubscribe();
      }
    }), r = t.filter((f) => f.id === this.request.id).subscribe({
      next: (f) => {
        (0, Uo.isJsonRpcErrorResponse)(f) ? (this.closeSubscriptions(), o.error(JSON.stringify(f.error))) : o.next(f.result);
      }
    }), m = t.subscribe({
      error: (f) => {
        this.closeSubscriptions(), o.error(f);
      },
      complete: () => {
        this.closeSubscriptions(), o.complete();
      }
    });
    this.subscriptions.push(u, r, m);
  }
  closeSubscriptions() {
    for (const o of this.subscriptions)
      o.unsubscribe();
    this.subscriptions = [];
  }
}
class Gv {
  constructor(o, t = Qv) {
    this.subscriptionStreams = /* @__PURE__ */ new Map();
    const u = o.endsWith("/") ? "websocket" : "/websocket", r = (0, Zv.hasProtocol)(o) ? o : "ws://" + o;
    this.url = r + u, this.socket = new Rd.ReconnectingSocket(this.url);
    const m = this.socket.events.subscribe({
      error: (f) => {
        t(f), m.unsubscribe();
      }
    });
    this.jsonRpcResponseStream = this.socket.events.map(yu), this.socket.connect();
  }
  async execute(o) {
    const t = this.responseForRequestId(o.id);
    this.socket.queueRequest(JSON.stringify(o));
    const u = await t;
    if ((0, Uo.isJsonRpcErrorResponse)(u))
      throw new Error(JSON.stringify(u.error));
    return u;
  }
  listen(o) {
    if (o.method !== "subscribe")
      throw new Error('Request method must be "subscribe" to start event listening');
    const t = o.params.query;
    if (typeof t != "string")
      throw new Error("request.params.query must be a string");
    if (!this.subscriptionStreams.has(t)) {
      const u = new Fv(o, this.socket), r = qv.Stream.create(u);
      this.subscriptionStreams.set(t, r);
    }
    return this.subscriptionStreams.get(t).filter((u) => u.query !== void 0);
  }
  /**
   * Resolves as soon as websocket is connected. execute() queues requests automatically,
   * so this should be required for testing purposes only.
   */
  async connected() {
    await this.socket.connectionStatus.waitFor(Rd.ConnectionStatus.Connected);
  }
  disconnect() {
    this.socket.disconnect();
  }
  async responseForRequestId(o) {
    return (0, Wv.firstEvent)(this.jsonRpcResponseStream.filter((t) => t.id === o));
  }
}
Er.WebsocketClient = Gv;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.WebsocketClient = e.instanceOfRpcStreamingClient = e.HttpClient = e.HttpBatchClient = void 0;
  var o = br;
  Object.defineProperty(e, "HttpBatchClient", { enumerable: !0, get: function() {
    return o.HttpBatchClient;
  } });
  var t = Nr;
  Object.defineProperty(e, "HttpClient", { enumerable: !0, get: function() {
    return t.HttpClient;
  } });
  var u = Et;
  Object.defineProperty(e, "instanceOfRpcStreamingClient", { enumerable: !0, get: function() {
    return u.instanceOfRpcStreamingClient;
  } });
  var r = Er;
  Object.defineProperty(e, "WebsocketClient", { enumerable: !0, get: function() {
    return r.WebsocketClient;
  } });
})(Sr);
var zn = {}, Cr = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.buildQuery = e.SubscriptionEventType = e.Method = void 0, function(t) {
    t.AbciInfo = "abci_info", t.AbciQuery = "abci_query", t.Block = "block", t.Blockchain = "blockchain", t.BlockResults = "block_results", t.BlockSearch = "block_search", t.BroadcastTxAsync = "broadcast_tx_async", t.BroadcastTxSync = "broadcast_tx_sync", t.BroadcastTxCommit = "broadcast_tx_commit", t.Commit = "commit", t.Genesis = "genesis", t.Health = "health", t.NumUnconfirmedTxs = "num_unconfirmed_txs", t.Status = "status", t.Subscribe = "subscribe", t.Tx = "tx", t.TxSearch = "tx_search", t.Validators = "validators", t.Unsubscribe = "unsubscribe";
  }(e.Method || (e.Method = {})), function(t) {
    t.NewBlock = "NewBlock", t.NewBlockHeader = "NewBlockHeader", t.Tx = "Tx";
  }(e.SubscriptionEventType || (e.SubscriptionEventType = {}));
  function o(t) {
    const u = (t.tags ? t.tags : []).map((m) => `${m.key}='${m.value}'`), r = t.raw ? [t.raw] : [];
    return [...u, ...r].join(" AND ");
  }
  e.buildQuery = o;
})(Cr);
var Su = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.VoteType = e.broadcastTxCommitSuccess = e.broadcastTxSyncSuccess = void 0;
  function o(u) {
    return u.code === 0;
  }
  e.broadcastTxSyncSuccess = o;
  function t(u) {
    return u.checkTx.code === 0 && !!u.deliverTx && u.deliverTx.code === 0;
  }
  e.broadcastTxCommitSuccess = t, function(u) {
    u[u.PreVote = 1] = "PreVote", u[u.PreCommit = 2] = "PreCommit";
  }(e.VoteType || (e.VoteType = {}));
})(Su);
var Ir = {}, rn = {};
Object.defineProperty(rn, "__esModule", { value: !0 });
rn.createJsonRpcRequest = void 0;
const Ad = "123456789";
function Kv() {
  return Ad[Math.floor(Math.random() * Ad.length)];
}
function zv() {
  return parseInt(Array.from({ length: 12 }).map(() => Kv()).join(""), 10);
}
function Yv(e, o) {
  const t = o ? { ...o } : {};
  return {
    jsonrpc: "2.0",
    id: zv(),
    method: e,
    params: t
  };
}
rn.createJsonRpcRequest = Yv;
var xr = {}, Xt = {}, fe = {};
Object.defineProperty(fe, "__esModule", { value: !0 });
fe.encodeBlockId = fe.encodeVersion = fe.encodeBytes = fe.encodeTime = fe.encodeUvarint = fe.encodeString = fe.dictionaryToStringMap = fe.may = fe.assertNotEmpty = fe.assertObject = fe.assertArray = fe.assertNumber = fe.assertString = fe.assertBoolean = fe.assertSet = void 0;
const $v = Be;
function sn(e) {
  if (e === void 0)
    throw new Error("Value must not be undefined");
  if (e === null)
    throw new Error("Value must not be null");
  return e;
}
fe.assertSet = sn;
function Xv(e) {
  if (sn(e), typeof e != "boolean")
    throw new Error("Value must be a boolean");
  return e;
}
fe.assertBoolean = Xv;
function e0(e) {
  if (sn(e), typeof e != "string")
    throw new Error("Value must be a string");
  return e;
}
fe.assertString = e0;
function t0(e) {
  if (sn(e), typeof e != "number")
    throw new Error("Value must be a number");
  return e;
}
fe.assertNumber = t0;
function n0(e) {
  if (sn(e), !Array.isArray(e))
    throw new Error("Value must be a an array");
  return e;
}
fe.assertArray = n0;
function o0(e) {
  if (sn(e), typeof e != "object")
    throw new Error("Value must be an object");
  if (Object.prototype.toString.call(e) !== "[object Object]")
    throw new Error("Value must be a simple object");
  return e;
}
fe.assertObject = o0;
function r0(e) {
  if (sn(e), typeof e == "number" && e === 0)
    throw new Error("must provide a non-zero value");
  if (e.length === 0)
    throw new Error("must provide a non-empty value");
  return e;
}
fe.assertNotEmpty = r0;
function i0(e, o) {
  return o == null ? void 0 : e(o);
}
fe.may = i0;
function s0(e) {
  const o = /* @__PURE__ */ new Map();
  for (const t of Object.keys(e)) {
    const u = e[t];
    if (typeof u != "string")
      throw new Error("Found dictionary value of type other than string");
    o.set(t, u);
  }
  return o;
}
fe.dictionaryToStringMap = s0;
function a0(e) {
  const o = (0, $v.toUtf8)(e);
  return Uint8Array.from([o.length, ...o]);
}
fe.encodeString = a0;
function Un(e) {
  return e >= 128 ? (
    // eslint-disable-next-line no-bitwise
    Uint8Array.from([e & 255 | 128, ...Un(e >> 7)])
  ) : (
    // eslint-disable-next-line no-bitwise
    Uint8Array.from([e & 255])
  );
}
fe.encodeUvarint = Un;
function d0(e) {
  const o = e.getTime(), t = Math.floor(o / 1e3), u = t ? [8, ...Un(t)] : new Uint8Array(), r = (e.nanoseconds || 0) + o % 1e3 * 1e6, m = r ? [16, ...Un(r)] : new Uint8Array();
  return Uint8Array.from([...u, ...m]);
}
fe.encodeTime = d0;
function c0(e) {
  if (e.length >= 128)
    throw new Error("Not implemented for byte arrays of length 128 or more");
  return e.length ? Uint8Array.from([e.length, ...e]) : new Uint8Array();
}
fe.encodeBytes = c0;
function u0(e) {
  const o = e.block ? Uint8Array.from([8, ...Un(e.block)]) : new Uint8Array(), t = e.app ? Uint8Array.from([16, ...Un(e.app)]) : new Uint8Array();
  return Uint8Array.from([...o, ...t]);
}
fe.encodeVersion = u0;
function l0(e) {
  return Uint8Array.from([
    10,
    e.hash.length,
    ...e.hash,
    18,
    e.parts.hash.length + 4,
    8,
    e.parts.total,
    18,
    e.parts.hash.length,
    ...e.parts.hash
  ]);
}
fe.encodeBlockId = l0;
Object.defineProperty(Xt, "__esModule", { value: !0 });
Xt.hashBlock = Xt.hashTx = void 0;
const fs = Vi, He = fe;
function p0(e) {
  return (0, fs.sha256)(e);
}
Xt.hashTx = p0;
function f0(e) {
  if (e < 1)
    throw new Error("Cannot split an empty tree");
  const o = 2 ** Math.floor(Math.log2(e));
  return o < e ? o : o / 2;
}
function m0(e) {
  const o = new fs.Sha256(Uint8Array.from([0]));
  return o.update(e), o.digest();
}
function g0(e, o) {
  const t = new fs.Sha256(Uint8Array.from([1]));
  return t.update(e), t.update(o), t.digest();
}
function _i(e) {
  switch (e.length) {
    case 0:
      throw new Error("Cannot hash empty tree");
    case 1:
      return m0(e[0]);
    default: {
      const o = f0(e.length), t = _i(e.slice(0, o)), u = _i(e.slice(o));
      return g0(t, u);
    }
  }
}
function h0(e) {
  if (!e.lastBlockId)
    throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
  const o = [
    (0, He.encodeVersion)(e.version),
    (0, He.encodeString)(e.chainId),
    (0, He.encodeUvarint)(e.height),
    (0, He.encodeTime)(e.time),
    (0, He.encodeBlockId)(e.lastBlockId),
    (0, He.encodeBytes)(e.lastCommitHash),
    (0, He.encodeBytes)(e.dataHash),
    (0, He.encodeBytes)(e.validatorsHash),
    (0, He.encodeBytes)(e.nextValidatorsHash),
    (0, He.encodeBytes)(e.consensusHash),
    (0, He.encodeBytes)(e.appHash),
    (0, He.encodeBytes)(e.lastResultsHash),
    (0, He.encodeBytes)(e.evidenceHash),
    (0, He.encodeBytes)(e.proposerAddress)
  ];
  return _i(o);
}
Xt.hashBlock = h0;
var _r = {}, pt = {};
Object.defineProperty(pt, "__esModule", { value: !0 });
pt.smallIntToApi = pt.apiToBigInt = pt.apiToSmallInt = void 0;
const Ji = Rt, v0 = fe;
function y0(e) {
  return (typeof e == "number" ? new Ji.Int53(e) : Ji.Int53.fromString(e)).toNumber();
}
pt.apiToSmallInt = y0;
function S0(e) {
  if ((0, v0.assertString)(e), !e.match(/^-?[0-9]+$/))
    throw new Error("Invalid string format");
  return BigInt(e);
}
pt.apiToBigInt = S0;
function b0(e) {
  return new Ji.Int53(e).toString();
}
pt.smallIntToApi = b0;
var O0 = Q && Q.__createBinding || (Object.create ? function(e, o, t, u) {
  u === void 0 && (u = t);
  var r = Object.getOwnPropertyDescriptor(o, t);
  (!r || ("get" in r ? !o.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return o[t];
  } }), Object.defineProperty(e, u, r);
} : function(e, o, t, u) {
  u === void 0 && (u = t), e[u] = o[t];
}), k0 = Q && Q.__setModuleDefault || (Object.create ? function(e, o) {
  Object.defineProperty(e, "default", { enumerable: !0, value: o });
} : function(e, o) {
  e.default = o;
}), P0 = Q && Q.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var o = {};
  if (e != null)
    for (var t in e)
      t !== "default" && Object.prototype.hasOwnProperty.call(e, t) && O0(o, e, t);
  return k0(o, e), o;
};
Object.defineProperty(_r, "__esModule", { value: !0 });
_r.Params = void 0;
const ms = Be, ft = pt, Ce = rn, Ge = fe, R0 = P0(Cr);
function bi(e) {
  return {
    height: (0, Ge.may)(ft.smallIntToApi, e.height)
  };
}
function A0(e) {
  return {
    minHeight: (0, Ge.may)(ft.smallIntToApi, e.minHeight),
    maxHeight: (0, Ge.may)(ft.smallIntToApi, e.maxHeight)
  };
}
function w0(e) {
  return {
    query: e.query,
    page: (0, Ge.may)(ft.smallIntToApi, e.page),
    per_page: (0, Ge.may)(ft.smallIntToApi, e.per_page),
    order_by: e.order_by
  };
}
function N0(e) {
  return {
    path: (0, Ge.assertNotEmpty)(e.path),
    data: (0, ms.toHex)(e.data),
    height: (0, Ge.may)(ft.smallIntToApi, e.height),
    prove: e.prove
  };
}
function E0(e) {
  return {
    tx: (0, ms.toBase64)((0, Ge.assertNotEmpty)(e.tx))
  };
}
function T0(e) {
  return {
    hash: (0, ms.toBase64)((0, Ge.assertNotEmpty)(e.hash)),
    prove: e.prove
  };
}
function C0(e) {
  return {
    query: e.query,
    prove: e.prove,
    page: (0, Ge.may)(ft.smallIntToApi, e.page),
    per_page: (0, Ge.may)(ft.smallIntToApi, e.per_page),
    order_by: e.order_by
  };
}
function I0(e) {
  return {
    height: (0, Ge.may)(ft.smallIntToApi, e.height),
    page: (0, Ge.may)(ft.smallIntToApi, e.page),
    per_page: (0, Ge.may)(ft.smallIntToApi, e.per_page)
  };
}
let x0 = class {
  static encodeAbciInfo(e) {
    return (0, Ce.createJsonRpcRequest)(e.method);
  }
  static encodeAbciQuery(e) {
    return (0, Ce.createJsonRpcRequest)(e.method, N0(e.params));
  }
  static encodeBlock(e) {
    return (0, Ce.createJsonRpcRequest)(e.method, bi(e.params));
  }
  static encodeBlockchain(e) {
    return (0, Ce.createJsonRpcRequest)(e.method, A0(e.params));
  }
  static encodeBlockResults(e) {
    return (0, Ce.createJsonRpcRequest)(e.method, bi(e.params));
  }
  static encodeBlockSearch(e) {
    return (0, Ce.createJsonRpcRequest)(e.method, w0(e.params));
  }
  static encodeBroadcastTx(e) {
    return (0, Ce.createJsonRpcRequest)(e.method, E0(e.params));
  }
  static encodeCommit(e) {
    return (0, Ce.createJsonRpcRequest)(e.method, bi(e.params));
  }
  static encodeGenesis(e) {
    return (0, Ce.createJsonRpcRequest)(e.method);
  }
  static encodeHealth(e) {
    return (0, Ce.createJsonRpcRequest)(e.method);
  }
  static encodeNumUnconfirmedTxs(e) {
    return (0, Ce.createJsonRpcRequest)(e.method);
  }
  static encodeStatus(e) {
    return (0, Ce.createJsonRpcRequest)(e.method);
  }
  static encodeSubscribe(e) {
    const o = { key: "tm.event", value: e.query.type }, t = R0.buildQuery({ tags: [o], raw: e.query.raw });
    return (0, Ce.createJsonRpcRequest)("subscribe", { query: t });
  }
  static encodeTx(e) {
    return (0, Ce.createJsonRpcRequest)(e.method, T0(e.params));
  }
  // TODO: encode params for query string???
  static encodeTxSearch(e) {
    return (0, Ce.createJsonRpcRequest)(e.method, C0(e.params));
  }
  static encodeValidators(e) {
    return (0, Ce.createJsonRpcRequest)(e.method, I0(e.params));
  }
};
_r.Params = x0;
var at = {}, Jr = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.BlockIdFlag = void 0, function(o) {
    o[o.Unknown = 0] = "Unknown", o[o.Absent = 1] = "Absent", o[o.Commit = 2] = "Commit", o[o.Nil = 3] = "Nil", o[o.Unrecognized = -1] = "Unrecognized";
  }(e.BlockIdFlag || (e.BlockIdFlag = {}));
})(Jr);
Object.defineProperty(at, "__esModule", { value: !0 });
at.Responses = at.decodeValidatorInfo = at.decodeValidatorGenesis = at.decodeValidatorUpdate = at.decodeEvent = void 0;
const de = Be, bu = ht, $n = Fe, ce = pt, _0 = Jr, X = fe, J0 = Xt;
function U0(e) {
  return {
    data: e.data,
    lastBlockHeight: (0, X.may)(ce.apiToSmallInt, e.last_block_height),
    lastBlockAppHash: (0, X.may)(de.fromBase64, e.last_block_app_hash)
  };
}
function D0(e) {
  return {
    ops: e.ops.map((o) => ({
      type: o.type,
      key: (0, de.fromBase64)(o.key),
      data: (0, de.fromBase64)(o.data)
    }))
  };
}
function L0(e) {
  return {
    key: (0, de.fromBase64)((0, X.assertString)(e.key ?? "")),
    value: (0, de.fromBase64)((0, X.assertString)(e.value ?? "")),
    proof: (0, X.may)(D0, e.proofOps),
    height: (0, X.may)(ce.apiToSmallInt, e.height),
    code: (0, X.may)(ce.apiToSmallInt, e.code),
    codespace: (0, X.assertString)(e.codespace ?? ""),
    index: (0, X.may)(ce.apiToSmallInt, e.index),
    log: e.log,
    info: (0, X.assertString)(e.info ?? "")
  };
}
function B0(e) {
  return {
    key: (0, de.fromBase64)((0, X.assertNotEmpty)(e.key)),
    value: (0, de.fromBase64)((0, X.assertString)(e.value ?? ""))
  };
}
function V0(e) {
  return (0, X.assertArray)(e).map(B0);
}
function Ou(e) {
  return {
    type: e.type,
    attributes: e.attributes ? V0(e.attributes) : []
  };
}
at.decodeEvent = Ou;
function Ui(e) {
  return (0, X.assertArray)(e).map(Ou);
}
function Dn(e) {
  return {
    code: (0, ce.apiToSmallInt)((0, X.assertNumber)(e.code ?? 0)),
    codespace: e.codespace,
    log: e.log,
    data: (0, X.may)(de.fromBase64, e.data),
    events: e.events ? Ui(e.events) : [],
    gasWanted: (0, ce.apiToSmallInt)(e.gas_wanted ?? "0"),
    gasUsed: (0, ce.apiToSmallInt)(e.gas_used ?? "0")
  };
}
function gs(e) {
  if ("Sum" in e) {
    const [[o, t]] = Object.entries(e.Sum.value);
    return (0, bu.assert)(o === "ed25519" || o === "secp256k1", `unknown pubkey type: ${o}`), {
      algorithm: o,
      data: (0, de.fromBase64)((0, X.assertNotEmpty)(t))
    };
  } else
    switch (e.type) {
      case "tendermint/PubKeyEd25519":
        return {
          algorithm: "ed25519",
          data: (0, de.fromBase64)((0, X.assertNotEmpty)(e.value))
        };
      case "tendermint/PubKeySecp256k1":
        return {
          algorithm: "secp256k1",
          data: (0, de.fromBase64)((0, X.assertNotEmpty)(e.value))
        };
      default:
        throw new Error(`unknown pubkey type: ${e.type}`);
    }
}
function M0(e) {
  return {
    maxBytes: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.max_bytes)),
    maxGas: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.max_gas))
  };
}
function H0(e) {
  return {
    maxAgeNumBlocks: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.max_age_num_blocks)),
    maxAgeDuration: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.max_age_duration))
  };
}
function ku(e) {
  return {
    block: M0((0, X.assertObject)(e.block)),
    evidence: H0((0, X.assertObject)(e.evidence))
  };
}
function Pu(e) {
  return {
    pubkey: gs((0, X.assertObject)(e.pub_key)),
    votingPower: (0, ce.apiToBigInt)(e.power ?? "0")
  };
}
at.decodeValidatorUpdate = Pu;
function j0(e) {
  return {
    height: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.height)),
    results: (e.txs_results || []).map(Dn),
    validatorUpdates: (e.validator_updates || []).map(Pu),
    consensusUpdates: (0, X.may)(ku, e.consensus_param_updates),
    beginBlockEvents: Ui(e.begin_block_events || []),
    endBlockEvents: Ui(e.end_block_events || [])
  };
}
function Ur(e) {
  return {
    hash: (0, de.fromHex)((0, X.assertNotEmpty)(e.hash)),
    parts: {
      total: (0, X.assertNotEmpty)(e.parts.total),
      hash: (0, de.fromHex)((0, X.assertNotEmpty)(e.parts.hash))
    }
  };
}
function W0(e) {
  return {
    block: (0, ce.apiToSmallInt)(e.block),
    app: (0, ce.apiToSmallInt)(e.app ?? 0)
  };
}
function Dr(e) {
  return {
    version: W0(e.version),
    chainId: (0, X.assertNotEmpty)(e.chain_id),
    height: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.height)),
    time: (0, $n.fromRfc3339WithNanoseconds)((0, X.assertNotEmpty)(e.time)),
    // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
    // { hash: '', parts: { total: 0, hash: '' } }
    lastBlockId: e.last_block_id.hash ? Ur(e.last_block_id) : null,
    lastCommitHash: (0, de.fromHex)((0, X.assertSet)(e.last_commit_hash)),
    dataHash: (0, de.fromHex)((0, X.assertSet)(e.data_hash)),
    validatorsHash: (0, de.fromHex)((0, X.assertSet)(e.validators_hash)),
    nextValidatorsHash: (0, de.fromHex)((0, X.assertSet)(e.next_validators_hash)),
    consensusHash: (0, de.fromHex)((0, X.assertSet)(e.consensus_hash)),
    appHash: (0, de.fromHex)((0, X.assertSet)(e.app_hash)),
    lastResultsHash: (0, de.fromHex)((0, X.assertSet)(e.last_results_hash)),
    evidenceHash: (0, de.fromHex)((0, X.assertSet)(e.evidence_hash)),
    proposerAddress: (0, de.fromHex)((0, X.assertNotEmpty)(e.proposer_address))
  };
}
function q0(e) {
  return {
    blockId: Ur(e.block_id),
    blockSize: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.block_size)),
    header: Dr(e.header),
    numTxs: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.num_txs))
  };
}
function Z0(e) {
  return {
    lastHeight: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.last_height)),
    blockMetas: (0, X.assertArray)(e.block_metas).map(q0)
  };
}
function Q0(e) {
  return {
    ...Dn(e),
    hash: (0, de.fromHex)((0, X.assertNotEmpty)(e.hash))
  };
}
function F0(e) {
  return {
    height: (0, ce.apiToSmallInt)(e.height),
    hash: (0, de.fromHex)((0, X.assertNotEmpty)(e.hash)),
    checkTx: Dn((0, X.assertObject)(e.check_tx)),
    deliverTx: (0, X.may)(Dn, e.deliver_tx)
  };
}
function G0(e) {
  return (0, bu.assert)(e in _0.BlockIdFlag), e;
}
function K0(e) {
  return e && !e.startsWith("0001-01-01") ? (0, $n.fromRfc3339WithNanoseconds)(e) : void 0;
}
function z0(e) {
  return {
    blockIdFlag: G0(e.block_id_flag),
    validatorAddress: e.validator_address ? (0, de.fromHex)(e.validator_address) : void 0,
    timestamp: K0(e.timestamp),
    signature: e.signature ? (0, de.fromBase64)(e.signature) : void 0
  };
}
function Ru(e) {
  return {
    blockId: Ur((0, X.assertObject)(e.block_id)),
    height: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.height)),
    round: (0, ce.apiToSmallInt)(e.round),
    signatures: (0, X.assertArray)(e.signatures).map(z0)
  };
}
function Y0(e) {
  return {
    canonical: (0, X.assertBoolean)(e.canonical),
    header: Dr(e.signed_header.header),
    commit: Ru(e.signed_header.commit)
  };
}
function Au(e) {
  return {
    address: (0, de.fromHex)((0, X.assertNotEmpty)(e.address)),
    pubkey: gs((0, X.assertObject)(e.pub_key)),
    votingPower: (0, ce.apiToBigInt)((0, X.assertNotEmpty)(e.power))
  };
}
at.decodeValidatorGenesis = Au;
function $0(e) {
  return {
    genesisTime: (0, $n.fromRfc3339WithNanoseconds)((0, X.assertNotEmpty)(e.genesis_time)),
    chainId: (0, X.assertNotEmpty)(e.chain_id),
    consensusParams: ku(e.consensus_params),
    validators: e.validators ? (0, X.assertArray)(e.validators).map(Au) : [],
    appHash: (0, de.fromHex)((0, X.assertSet)(e.app_hash)),
    appState: e.app_state
  };
}
function hs(e) {
  return {
    pubkey: gs((0, X.assertObject)(e.pub_key)),
    votingPower: (0, ce.apiToBigInt)((0, X.assertNotEmpty)(e.voting_power)),
    address: (0, de.fromHex)((0, X.assertNotEmpty)(e.address)),
    proposerPriority: e.proposer_priority ? (0, ce.apiToSmallInt)(e.proposer_priority) : void 0
  };
}
at.decodeValidatorInfo = hs;
function X0(e) {
  return {
    id: (0, de.fromHex)((0, X.assertNotEmpty)(e.id)),
    listenAddr: (0, X.assertNotEmpty)(e.listen_addr),
    network: (0, X.assertNotEmpty)(e.network),
    version: (0, X.assertString)(e.version),
    channels: (0, X.assertNotEmpty)(e.channels),
    moniker: (0, X.assertNotEmpty)(e.moniker),
    other: (0, X.dictionaryToStringMap)(e.other),
    protocolVersion: {
      app: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.protocol_version.app)),
      block: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.protocol_version.block)),
      p2p: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.protocol_version.p2p))
    }
  };
}
function ey(e) {
  const o = e.earliest_block_height ? (0, ce.apiToSmallInt)(e.earliest_block_height) : void 0, t = e.earliest_block_time ? (0, $n.fromRfc3339WithNanoseconds)(e.earliest_block_time) : void 0;
  return {
    earliestAppHash: e.earliest_app_hash ? (0, de.fromHex)(e.earliest_app_hash) : void 0,
    earliestBlockHash: e.earliest_block_hash ? (0, de.fromHex)(e.earliest_block_hash) : void 0,
    earliestBlockHeight: o || void 0,
    earliestBlockTime: t != null && t.getTime() ? t : void 0,
    latestBlockHash: (0, de.fromHex)((0, X.assertNotEmpty)(e.latest_block_hash)),
    latestAppHash: (0, de.fromHex)((0, X.assertNotEmpty)(e.latest_app_hash)),
    latestBlockTime: (0, $n.fromRfc3339WithNanoseconds)((0, X.assertNotEmpty)(e.latest_block_time)),
    latestBlockHeight: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.latest_block_height)),
    catchingUp: (0, X.assertBoolean)(e.catching_up)
  };
}
function ty(e) {
  return {
    nodeInfo: X0(e.node_info),
    syncInfo: ey(e.sync_info),
    validatorInfo: hs(e.validator_info)
  };
}
function ny(e) {
  return {
    data: (0, de.fromBase64)((0, X.assertNotEmpty)(e.data)),
    rootHash: (0, de.fromHex)((0, X.assertNotEmpty)(e.root_hash)),
    proof: {
      total: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.proof.total)),
      index: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.proof.index)),
      leafHash: (0, de.fromBase64)((0, X.assertNotEmpty)(e.proof.leaf_hash)),
      aunts: (0, X.assertArray)(e.proof.aunts).map(de.fromBase64)
    }
  };
}
function wu(e) {
  return {
    tx: (0, de.fromBase64)((0, X.assertNotEmpty)(e.tx)),
    result: Dn((0, X.assertObject)(e.tx_result)),
    height: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.height)),
    index: (0, ce.apiToSmallInt)((0, X.assertNumber)(e.index)),
    hash: (0, de.fromHex)((0, X.assertNotEmpty)(e.hash)),
    proof: (0, X.may)(ny, e.proof)
  };
}
function oy(e) {
  return {
    totalCount: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.total_count)),
    txs: (0, X.assertArray)(e.txs).map(wu)
  };
}
function ry(e) {
  const o = (0, de.fromBase64)((0, X.assertNotEmpty)(e.tx));
  return {
    tx: o,
    hash: (0, J0.hashTx)(o),
    result: Dn(e.result),
    height: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.height))
  };
}
function iy(e) {
  return {
    blockHeight: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.block_height)),
    validators: (0, X.assertArray)(e.validators).map(hs),
    count: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.count)),
    total: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.total))
  };
}
function Nu(e) {
  var o;
  return {
    header: Dr((0, X.assertObject)(e.header)),
    // For the block at height 1, last commit is not set. This is represented in an empty object like this:
    // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
    lastCommit: e.last_commit.block_id.hash ? Ru((0, X.assertObject)(e.last_commit)) : null,
    txs: e.data.txs ? (0, X.assertArray)(e.data.txs).map(de.fromBase64) : [],
    // Lift up .evidence.evidence to just .evidence
    // See https://github.com/tendermint/tendermint/issues/7697
    evidence: ((o = e.evidence) == null ? void 0 : o.evidence) ?? []
  };
}
function Eu(e) {
  return {
    blockId: Ur(e.block_id),
    block: Nu(e.block)
  };
}
function sy(e) {
  return {
    totalCount: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.total_count)),
    blocks: (0, X.assertArray)(e.blocks).map(Eu)
  };
}
function ay(e) {
  return {
    total: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.total)),
    totalBytes: (0, ce.apiToSmallInt)((0, X.assertNotEmpty)(e.total_bytes))
  };
}
let dy = class Tu {
  static decodeAbciInfo(o) {
    return U0((0, X.assertObject)(o.result.response));
  }
  static decodeAbciQuery(o) {
    return L0((0, X.assertObject)(o.result.response));
  }
  static decodeBlock(o) {
    return Eu(o.result);
  }
  static decodeBlockResults(o) {
    return j0(o.result);
  }
  static decodeBlockSearch(o) {
    return sy(o.result);
  }
  static decodeBlockchain(o) {
    return Z0(o.result);
  }
  static decodeBroadcastTxSync(o) {
    return Q0(o.result);
  }
  static decodeBroadcastTxAsync(o) {
    return Tu.decodeBroadcastTxSync(o);
  }
  static decodeBroadcastTxCommit(o) {
    return F0(o.result);
  }
  static decodeCommit(o) {
    return Y0(o.result);
  }
  static decodeGenesis(o) {
    return $0((0, X.assertObject)(o.result.genesis));
  }
  static decodeHealth() {
    return null;
  }
  static decodeNumUnconfirmedTxs(o) {
    return ay(o.result);
  }
  static decodeStatus(o) {
    return ty(o.result);
  }
  static decodeNewBlockEvent(o) {
    return Nu(o.data.value.block);
  }
  static decodeNewBlockHeaderEvent(o) {
    return Dr(o.data.value.header);
  }
  static decodeTxEvent(o) {
    return ry(o.data.value.TxResult);
  }
  static decodeTx(o) {
    return wu(o.result);
  }
  static decodeTxSearch(o) {
    return oy(o.result);
  }
  static decodeValidators(o) {
    return iy(o.result);
  }
};
at.Responses = dy;
Object.defineProperty(xr, "__esModule", { value: !0 });
xr.adaptor34 = void 0;
const wd = Xt, cy = _r, uy = at;
xr.adaptor34 = {
  params: cy.Params,
  responses: uy.Responses,
  hashTx: wd.hashTx,
  hashBlock: wd.hashBlock
};
var ly = Q && Q.__createBinding || (Object.create ? function(e, o, t, u) {
  u === void 0 && (u = t);
  var r = Object.getOwnPropertyDescriptor(o, t);
  (!r || ("get" in r ? !o.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return o[t];
  } }), Object.defineProperty(e, u, r);
} : function(e, o, t, u) {
  u === void 0 && (u = t), e[u] = o[t];
}), py = Q && Q.__setModuleDefault || (Object.create ? function(e, o) {
  Object.defineProperty(e, "default", { enumerable: !0, value: o });
} : function(e, o) {
  e.default = o;
}), fy = Q && Q.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var o = {};
  if (e != null)
    for (var t in e)
      t !== "default" && Object.prototype.hasOwnProperty.call(e, t) && ly(o, e, t);
  return py(o, e), o;
};
Object.defineProperty(Ir, "__esModule", { value: !0 });
Ir.Tendermint34Client = void 0;
const my = rn, ko = Sr, Nd = xr, he = fy(Cr);
class Do {
  /**
   * Creates a new Tendermint client for the given endpoint.
   *
   * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
   */
  static async connect(o) {
    let t;
    return typeof o == "object" ? t = new ko.HttpClient(o) : t = o.startsWith("http://") || o.startsWith("https://") ? new ko.HttpClient(o) : new ko.WebsocketClient(o), await this.detectVersion(t), Do.create(t);
  }
  /**
   * Creates a new Tendermint client given an RPC client.
   */
  static async create(o) {
    return new Do(o);
  }
  static async detectVersion(o) {
    const t = (0, my.createJsonRpcRequest)(he.Method.Status), u = (await o.execute(t)).result;
    if (!u || !u.node_info)
      throw new Error("Unrecognized format for status response");
    const r = u.node_info.version;
    if (typeof r != "string")
      throw new Error("Unrecognized version format: must be string");
    return r;
  }
  /**
   * Use `Tendermint34Client.connect` or `Tendermint34Client.create` to create an instance.
   */
  constructor(o) {
    this.client = o, this.p = Nd.adaptor34.params, this.r = Nd.adaptor34.responses;
  }
  disconnect() {
    this.client.disconnect();
  }
  async abciInfo() {
    const o = { method: he.Method.AbciInfo };
    return this.doCall(o, this.p.encodeAbciInfo, this.r.decodeAbciInfo);
  }
  async abciQuery(o) {
    const t = { params: o, method: he.Method.AbciQuery };
    return this.doCall(t, this.p.encodeAbciQuery, this.r.decodeAbciQuery);
  }
  async block(o) {
    const t = { method: he.Method.Block, params: { height: o } };
    return this.doCall(t, this.p.encodeBlock, this.r.decodeBlock);
  }
  async blockResults(o) {
    const t = {
      method: he.Method.BlockResults,
      params: { height: o }
    };
    return this.doCall(t, this.p.encodeBlockResults, this.r.decodeBlockResults);
  }
  /**
   * Search for events that are in a block.
   *
   * NOTE
   * This method will error on any node that is running a Tendermint version lower than 0.34.9.
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
   */
  async blockSearch(o) {
    const t = { params: o, method: he.Method.BlockSearch }, u = await this.doCall(t, this.p.encodeBlockSearch, this.r.decodeBlockSearch);
    return {
      ...u,
      // make sure we sort by height, as tendermint may be sorting by string value of the height
      blocks: [...u.blocks].sort((r, m) => r.block.header.height - m.block.header.height)
    };
  }
  // this should paginate through all blockSearch options to ensure it returns all results.
  // starts with page 1 or whatever was provided (eg. to start on page 7)
  //
  // NOTE
  // This method will error on any node that is running a Tendermint version lower than 0.34.9.
  async blockSearchAll(o) {
    let t = o.page || 1;
    const u = [];
    let r = !1;
    for (; !r; ) {
      const m = await this.blockSearch({ ...o, page: t });
      u.push(...m.blocks), u.length < m.totalCount ? t++ : r = !0;
    }
    return u.sort((m, f) => m.block.header.height - f.block.header.height), {
      totalCount: u.length,
      blocks: u
    };
  }
  /**
   * Queries block headers filtered by minHeight <= height <= maxHeight.
   *
   * @param minHeight The minimum height to be included in the result. Defaults to 0.
   * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
   */
  async blockchain(o, t) {
    const u = {
      method: he.Method.Blockchain,
      params: {
        minHeight: o,
        maxHeight: t
      }
    };
    return this.doCall(u, this.p.encodeBlockchain, this.r.decodeBlockchain);
  }
  /**
   * Broadcast transaction to mempool and wait for response
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
   */
  async broadcastTxSync(o) {
    const t = { params: o, method: he.Method.BroadcastTxSync };
    return this.doCall(t, this.p.encodeBroadcastTx, this.r.decodeBroadcastTxSync);
  }
  /**
   * Broadcast transaction to mempool and do not wait for result
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
   */
  async broadcastTxAsync(o) {
    const t = { params: o, method: he.Method.BroadcastTxAsync };
    return this.doCall(t, this.p.encodeBroadcastTx, this.r.decodeBroadcastTxAsync);
  }
  /**
   * Broadcast transaction to mempool and wait for block
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
   */
  async broadcastTxCommit(o) {
    const t = { params: o, method: he.Method.BroadcastTxCommit };
    return this.doCall(t, this.p.encodeBroadcastTx, this.r.decodeBroadcastTxCommit);
  }
  async commit(o) {
    const t = { method: he.Method.Commit, params: { height: o } };
    return this.doCall(t, this.p.encodeCommit, this.r.decodeCommit);
  }
  async genesis() {
    const o = { method: he.Method.Genesis };
    return this.doCall(o, this.p.encodeGenesis, this.r.decodeGenesis);
  }
  async health() {
    const o = { method: he.Method.Health };
    return this.doCall(o, this.p.encodeHealth, this.r.decodeHealth);
  }
  async numUnconfirmedTxs() {
    const o = { method: he.Method.NumUnconfirmedTxs };
    return this.doCall(o, this.p.encodeNumUnconfirmedTxs, this.r.decodeNumUnconfirmedTxs);
  }
  async status() {
    const o = { method: he.Method.Status };
    return this.doCall(o, this.p.encodeStatus, this.r.decodeStatus);
  }
  subscribeNewBlock() {
    const o = {
      method: he.Method.Subscribe,
      query: { type: he.SubscriptionEventType.NewBlock }
    };
    return this.subscribe(o, this.r.decodeNewBlockEvent);
  }
  subscribeNewBlockHeader() {
    const o = {
      method: he.Method.Subscribe,
      query: { type: he.SubscriptionEventType.NewBlockHeader }
    };
    return this.subscribe(o, this.r.decodeNewBlockHeaderEvent);
  }
  subscribeTx(o) {
    const t = {
      method: he.Method.Subscribe,
      query: {
        type: he.SubscriptionEventType.Tx,
        raw: o
      }
    };
    return this.subscribe(t, this.r.decodeTxEvent);
  }
  /**
   * Get a single transaction by hash
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/tx
   */
  async tx(o) {
    const t = { params: o, method: he.Method.Tx };
    return this.doCall(t, this.p.encodeTx, this.r.decodeTx);
  }
  /**
   * Search for transactions that are in a block
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
   */
  async txSearch(o) {
    const t = { params: o, method: he.Method.TxSearch };
    return this.doCall(t, this.p.encodeTxSearch, this.r.decodeTxSearch);
  }
  // this should paginate through all txSearch options to ensure it returns all results.
  // starts with page 1 or whatever was provided (eg. to start on page 7)
  async txSearchAll(o) {
    let t = o.page || 1;
    const u = [];
    let r = !1;
    for (; !r; ) {
      const m = await this.txSearch({ ...o, page: t });
      u.push(...m.txs), u.length < m.totalCount ? t++ : r = !0;
    }
    return {
      totalCount: u.length,
      txs: u
    };
  }
  async validators(o) {
    const t = {
      method: he.Method.Validators,
      params: o
    };
    return this.doCall(t, this.p.encodeValidators, this.r.decodeValidators);
  }
  async validatorsAll(o) {
    const t = [];
    let u = 1, r = !1, m = o;
    for (; !r; ) {
      const f = await this.validators({
        per_page: 50,
        height: m,
        page: u
      });
      t.push(...f.validators), m = m || f.blockHeight, t.length < f.total ? u++ : r = !0;
    }
    return {
      // NOTE: Default value is for type safety but this should always be set
      blockHeight: m ?? 0,
      count: t.length,
      total: t.length,
      validators: t
    };
  }
  // doCall is a helper to handle the encode/call/decode logic
  async doCall(o, t, u) {
    const r = t(o), m = await this.client.execute(r);
    return u(m);
  }
  subscribe(o, t) {
    if (!(0, ko.instanceOfRpcStreamingClient)(this.client))
      throw new Error("This RPC client type cannot subscribe to events");
    const u = this.p.encodeSubscribe(o);
    return this.client.listen(u).map((r) => t(r));
  }
}
Ir.Tendermint34Client = Do;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Tendermint34Client = e.VoteType = e.broadcastTxSyncSuccess = e.broadcastTxCommitSuccess = e.SubscriptionEventType = e.Method = void 0;
  var o = Cr;
  Object.defineProperty(e, "Method", { enumerable: !0, get: function() {
    return o.Method;
  } }), Object.defineProperty(e, "SubscriptionEventType", { enumerable: !0, get: function() {
    return o.SubscriptionEventType;
  } });
  var t = Su;
  Object.defineProperty(e, "broadcastTxCommitSuccess", { enumerable: !0, get: function() {
    return t.broadcastTxCommitSuccess;
  } }), Object.defineProperty(e, "broadcastTxSyncSuccess", { enumerable: !0, get: function() {
    return t.broadcastTxSyncSuccess;
  } }), Object.defineProperty(e, "VoteType", { enumerable: !0, get: function() {
    return t.VoteType;
  } });
  var u = Ir;
  Object.defineProperty(e, "Tendermint34Client", { enumerable: !0, get: function() {
    return u.Tendermint34Client;
  } });
})(zn);
var Lo = {}, Lr = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.buildQuery = e.SubscriptionEventType = e.Method = void 0, function(t) {
    t.AbciInfo = "abci_info", t.AbciQuery = "abci_query", t.Block = "block", t.Blockchain = "blockchain", t.BlockResults = "block_results", t.BlockSearch = "block_search", t.BroadcastTxAsync = "broadcast_tx_async", t.BroadcastTxSync = "broadcast_tx_sync", t.BroadcastTxCommit = "broadcast_tx_commit", t.Commit = "commit", t.Genesis = "genesis", t.Health = "health", t.NumUnconfirmedTxs = "num_unconfirmed_txs", t.Status = "status", t.Subscribe = "subscribe", t.Tx = "tx", t.TxSearch = "tx_search", t.Validators = "validators", t.Unsubscribe = "unsubscribe";
  }(e.Method || (e.Method = {})), function(t) {
    t.NewBlock = "NewBlock", t.NewBlockHeader = "NewBlockHeader", t.Tx = "Tx";
  }(e.SubscriptionEventType || (e.SubscriptionEventType = {}));
  function o(t) {
    const u = (t.tags ? t.tags : []).map((m) => `${m.key}='${m.value}'`), r = t.raw ? [t.raw] : [];
    return [...u, ...r].join(" AND ");
  }
  e.buildQuery = o;
})(Lr);
var Cu = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.VoteType = e.broadcastTxCommitSuccess = e.broadcastTxSyncSuccess = void 0;
  function o(u) {
    return u.code === 0;
  }
  e.broadcastTxSyncSuccess = o;
  function t(u) {
    return u.checkTx.code === 0 && !!u.deliverTx && u.deliverTx.code === 0;
  }
  e.broadcastTxCommitSuccess = t, function(u) {
    u[u.PreVote = 1] = "PreVote", u[u.PreCommit = 2] = "PreCommit";
  }(e.VoteType || (e.VoteType = {}));
})(Cu);
var Br = {}, Vr = {}, en = {}, me = {};
Object.defineProperty(me, "__esModule", { value: !0 });
me.encodeBlockId = me.encodeVersion = me.encodeBytes = me.encodeTime = me.encodeUvarint = me.encodeString = me.dictionaryToStringMap = me.may = me.assertNotEmpty = me.assertObject = me.assertArray = me.assertNumber = me.assertString = me.assertBoolean = me.assertSet = void 0;
const gy = Be;
function an(e) {
  if (e === void 0)
    throw new Error("Value must not be undefined");
  if (e === null)
    throw new Error("Value must not be null");
  return e;
}
me.assertSet = an;
function hy(e) {
  if (an(e), typeof e != "boolean")
    throw new Error("Value must be a boolean");
  return e;
}
me.assertBoolean = hy;
function vy(e) {
  if (an(e), typeof e != "string")
    throw new Error("Value must be a string");
  return e;
}
me.assertString = vy;
function yy(e) {
  if (an(e), typeof e != "number")
    throw new Error("Value must be a number");
  return e;
}
me.assertNumber = yy;
function Sy(e) {
  if (an(e), !Array.isArray(e))
    throw new Error("Value must be a an array");
  return e;
}
me.assertArray = Sy;
function by(e) {
  if (an(e), typeof e != "object")
    throw new Error("Value must be an object");
  if (Object.prototype.toString.call(e) !== "[object Object]")
    throw new Error("Value must be a simple object");
  return e;
}
me.assertObject = by;
function Oy(e) {
  if (an(e), typeof e == "number" && e === 0)
    throw new Error("must provide a non-zero value");
  if (e.length === 0)
    throw new Error("must provide a non-empty value");
  return e;
}
me.assertNotEmpty = Oy;
function ky(e, o) {
  return o == null ? void 0 : e(o);
}
me.may = ky;
function Py(e) {
  const o = /* @__PURE__ */ new Map();
  for (const t of Object.keys(e)) {
    const u = e[t];
    if (typeof u != "string")
      throw new Error("Found dictionary value of type other than string");
    o.set(t, u);
  }
  return o;
}
me.dictionaryToStringMap = Py;
function Ry(e) {
  const o = (0, gy.toUtf8)(e);
  return Uint8Array.from([o.length, ...o]);
}
me.encodeString = Ry;
function Ln(e) {
  return e >= 128 ? (
    // eslint-disable-next-line no-bitwise
    Uint8Array.from([e & 255 | 128, ...Ln(e >> 7)])
  ) : (
    // eslint-disable-next-line no-bitwise
    Uint8Array.from([e & 255])
  );
}
me.encodeUvarint = Ln;
function Ay(e) {
  const o = e.getTime(), t = Math.floor(o / 1e3), u = t ? [8, ...Ln(t)] : new Uint8Array(), r = (e.nanoseconds || 0) + o % 1e3 * 1e6, m = r ? [16, ...Ln(r)] : new Uint8Array();
  return Uint8Array.from([...u, ...m]);
}
me.encodeTime = Ay;
function wy(e) {
  if (e.length >= 128)
    throw new Error("Not implemented for byte arrays of length 128 or more");
  return e.length ? Uint8Array.from([e.length, ...e]) : new Uint8Array();
}
me.encodeBytes = wy;
function Ny(e) {
  const o = e.block ? Uint8Array.from([8, ...Ln(e.block)]) : new Uint8Array(), t = e.app ? Uint8Array.from([16, ...Ln(e.app)]) : new Uint8Array();
  return Uint8Array.from([...o, ...t]);
}
me.encodeVersion = Ny;
function Ey(e) {
  return Uint8Array.from([
    10,
    e.hash.length,
    ...e.hash,
    18,
    e.parts.hash.length + 4,
    8,
    e.parts.total,
    18,
    e.parts.hash.length,
    ...e.parts.hash
  ]);
}
me.encodeBlockId = Ey;
Object.defineProperty(en, "__esModule", { value: !0 });
en.hashBlock = en.hashTx = void 0;
const vs = Vi, je = me;
function Ty(e) {
  return (0, vs.sha256)(e);
}
en.hashTx = Ty;
function Cy(e) {
  if (e < 1)
    throw new Error("Cannot split an empty tree");
  const o = 2 ** Math.floor(Math.log2(e));
  return o < e ? o : o / 2;
}
function Iy(e) {
  const o = new vs.Sha256(Uint8Array.from([0]));
  return o.update(e), o.digest();
}
function xy(e, o) {
  const t = new vs.Sha256(Uint8Array.from([1]));
  return t.update(e), t.update(o), t.digest();
}
function Di(e) {
  switch (e.length) {
    case 0:
      throw new Error("Cannot hash empty tree");
    case 1:
      return Iy(e[0]);
    default: {
      const o = Cy(e.length), t = Di(e.slice(0, o)), u = Di(e.slice(o));
      return xy(t, u);
    }
  }
}
function _y(e) {
  if (!e.lastBlockId)
    throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
  const o = [
    (0, je.encodeVersion)(e.version),
    (0, je.encodeString)(e.chainId),
    (0, je.encodeUvarint)(e.height),
    (0, je.encodeTime)(e.time),
    (0, je.encodeBlockId)(e.lastBlockId),
    (0, je.encodeBytes)(e.lastCommitHash),
    (0, je.encodeBytes)(e.dataHash),
    (0, je.encodeBytes)(e.validatorsHash),
    (0, je.encodeBytes)(e.nextValidatorsHash),
    (0, je.encodeBytes)(e.consensusHash),
    (0, je.encodeBytes)(e.appHash),
    (0, je.encodeBytes)(e.lastResultsHash),
    (0, je.encodeBytes)(e.evidenceHash),
    (0, je.encodeBytes)(e.proposerAddress)
  ];
  return Di(o);
}
en.hashBlock = _y;
var Mr = {}, Jy = Q && Q.__createBinding || (Object.create ? function(e, o, t, u) {
  u === void 0 && (u = t);
  var r = Object.getOwnPropertyDescriptor(o, t);
  (!r || ("get" in r ? !o.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return o[t];
  } }), Object.defineProperty(e, u, r);
} : function(e, o, t, u) {
  u === void 0 && (u = t), e[u] = o[t];
}), Uy = Q && Q.__setModuleDefault || (Object.create ? function(e, o) {
  Object.defineProperty(e, "default", { enumerable: !0, value: o });
} : function(e, o) {
  e.default = o;
}), Dy = Q && Q.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var o = {};
  if (e != null)
    for (var t in e)
      t !== "default" && Object.prototype.hasOwnProperty.call(e, t) && Jy(o, e, t);
  return Uy(o, e), o;
};
Object.defineProperty(Mr, "__esModule", { value: !0 });
Mr.Params = void 0;
const ys = Be, mt = pt, Ie = rn, Ke = me, Ly = Dy(Lr);
function Oi(e) {
  return {
    height: (0, Ke.may)(mt.smallIntToApi, e.height)
  };
}
function By(e) {
  return {
    minHeight: (0, Ke.may)(mt.smallIntToApi, e.minHeight),
    maxHeight: (0, Ke.may)(mt.smallIntToApi, e.maxHeight)
  };
}
function Vy(e) {
  return {
    query: e.query,
    page: (0, Ke.may)(mt.smallIntToApi, e.page),
    per_page: (0, Ke.may)(mt.smallIntToApi, e.per_page),
    order_by: e.order_by
  };
}
function My(e) {
  return {
    path: (0, Ke.assertNotEmpty)(e.path),
    data: (0, ys.toHex)(e.data),
    height: (0, Ke.may)(mt.smallIntToApi, e.height),
    prove: e.prove
  };
}
function Hy(e) {
  return {
    tx: (0, ys.toBase64)((0, Ke.assertNotEmpty)(e.tx))
  };
}
function jy(e) {
  return {
    hash: (0, ys.toBase64)((0, Ke.assertNotEmpty)(e.hash)),
    prove: e.prove
  };
}
function Wy(e) {
  return {
    query: e.query,
    prove: e.prove,
    page: (0, Ke.may)(mt.smallIntToApi, e.page),
    per_page: (0, Ke.may)(mt.smallIntToApi, e.per_page),
    order_by: e.order_by
  };
}
function qy(e) {
  return {
    height: (0, Ke.may)(mt.smallIntToApi, e.height),
    page: (0, Ke.may)(mt.smallIntToApi, e.page),
    per_page: (0, Ke.may)(mt.smallIntToApi, e.per_page)
  };
}
class Zy {
  static encodeAbciInfo(o) {
    return (0, Ie.createJsonRpcRequest)(o.method);
  }
  static encodeAbciQuery(o) {
    return (0, Ie.createJsonRpcRequest)(o.method, My(o.params));
  }
  static encodeBlock(o) {
    return (0, Ie.createJsonRpcRequest)(o.method, Oi(o.params));
  }
  static encodeBlockchain(o) {
    return (0, Ie.createJsonRpcRequest)(o.method, By(o.params));
  }
  static encodeBlockResults(o) {
    return (0, Ie.createJsonRpcRequest)(o.method, Oi(o.params));
  }
  static encodeBlockSearch(o) {
    return (0, Ie.createJsonRpcRequest)(o.method, Vy(o.params));
  }
  static encodeBroadcastTx(o) {
    return (0, Ie.createJsonRpcRequest)(o.method, Hy(o.params));
  }
  static encodeCommit(o) {
    return (0, Ie.createJsonRpcRequest)(o.method, Oi(o.params));
  }
  static encodeGenesis(o) {
    return (0, Ie.createJsonRpcRequest)(o.method);
  }
  static encodeHealth(o) {
    return (0, Ie.createJsonRpcRequest)(o.method);
  }
  static encodeNumUnconfirmedTxs(o) {
    return (0, Ie.createJsonRpcRequest)(o.method);
  }
  static encodeStatus(o) {
    return (0, Ie.createJsonRpcRequest)(o.method);
  }
  static encodeSubscribe(o) {
    const t = { key: "tm.event", value: o.query.type }, u = Ly.buildQuery({ tags: [t], raw: o.query.raw });
    return (0, Ie.createJsonRpcRequest)("subscribe", { query: u });
  }
  static encodeTx(o) {
    return (0, Ie.createJsonRpcRequest)(o.method, jy(o.params));
  }
  // TODO: encode params for query string???
  static encodeTxSearch(o) {
    return (0, Ie.createJsonRpcRequest)(o.method, Wy(o.params));
  }
  static encodeValidators(o) {
    return (0, Ie.createJsonRpcRequest)(o.method, qy(o.params));
  }
}
Mr.Params = Zy;
var dt = {};
Object.defineProperty(dt, "__esModule", { value: !0 });
dt.Responses = dt.decodeValidatorInfo = dt.decodeValidatorGenesis = dt.decodeValidatorUpdate = dt.decodeEvent = void 0;
const le = Be, Iu = ht, Xn = Fe, ue = pt, Qy = Jr, ee = me, Fy = en;
function Gy(e) {
  return {
    data: e.data,
    lastBlockHeight: (0, ee.may)(ue.apiToSmallInt, e.last_block_height),
    lastBlockAppHash: (0, ee.may)(le.fromBase64, e.last_block_app_hash)
  };
}
function Ky(e) {
  return {
    ops: e.ops.map((o) => ({
      type: o.type,
      key: (0, le.fromBase64)(o.key),
      data: (0, le.fromBase64)(o.data)
    }))
  };
}
function zy(e) {
  return {
    key: (0, le.fromBase64)((0, ee.assertString)(e.key ?? "")),
    value: (0, le.fromBase64)((0, ee.assertString)(e.value ?? "")),
    proof: (0, ee.may)(Ky, e.proofOps),
    height: (0, ee.may)(ue.apiToSmallInt, e.height),
    code: (0, ee.may)(ue.apiToSmallInt, e.code),
    codespace: (0, ee.assertString)(e.codespace ?? ""),
    index: (0, ee.may)(ue.apiToSmallInt, e.index),
    log: e.log,
    info: (0, ee.assertString)(e.info ?? "")
  };
}
function Yy(e) {
  return {
    key: (0, ee.assertNotEmpty)(e.key),
    value: e.value ?? ""
  };
}
function $y(e) {
  return (0, ee.assertArray)(e).map(Yy);
}
function xu(e) {
  return {
    type: e.type,
    attributes: e.attributes ? $y(e.attributes) : []
  };
}
dt.decodeEvent = xu;
function Li(e) {
  return (0, ee.assertArray)(e).map(xu);
}
function Bn(e) {
  return {
    code: (0, ue.apiToSmallInt)((0, ee.assertNumber)(e.code ?? 0)),
    codespace: e.codespace,
    log: e.log,
    data: (0, ee.may)(le.fromBase64, e.data),
    events: e.events ? Li(e.events) : [],
    gasWanted: (0, ue.apiToSmallInt)(e.gas_wanted ?? "0"),
    gasUsed: (0, ue.apiToSmallInt)(e.gas_used ?? "0")
  };
}
function Ss(e) {
  if ("Sum" in e) {
    const [[o, t]] = Object.entries(e.Sum.value);
    return (0, Iu.assert)(o === "ed25519" || o === "secp256k1", `unknown pubkey type: ${o}`), {
      algorithm: o,
      data: (0, le.fromBase64)((0, ee.assertNotEmpty)(t))
    };
  } else
    switch (e.type) {
      case "tendermint/PubKeyEd25519":
        return {
          algorithm: "ed25519",
          data: (0, le.fromBase64)((0, ee.assertNotEmpty)(e.value))
        };
      case "tendermint/PubKeySecp256k1":
        return {
          algorithm: "secp256k1",
          data: (0, le.fromBase64)((0, ee.assertNotEmpty)(e.value))
        };
      default:
        throw new Error(`unknown pubkey type: ${e.type}`);
    }
}
function Xy(e) {
  return {
    maxBytes: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.max_bytes)),
    maxGas: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.max_gas))
  };
}
function eS(e) {
  return {
    maxAgeNumBlocks: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.max_age_num_blocks)),
    maxAgeDuration: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.max_age_duration))
  };
}
function _u(e) {
  return {
    block: Xy((0, ee.assertObject)(e.block)),
    evidence: eS((0, ee.assertObject)(e.evidence))
  };
}
function Ju(e) {
  return {
    pubkey: Ss((0, ee.assertObject)(e.pub_key)),
    votingPower: (0, ue.apiToBigInt)(e.power ?? "0")
  };
}
dt.decodeValidatorUpdate = Ju;
function tS(e) {
  return {
    height: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.height)),
    results: (e.txs_results || []).map(Bn),
    validatorUpdates: (e.validator_updates || []).map(Ju),
    consensusUpdates: (0, ee.may)(_u, e.consensus_param_updates),
    beginBlockEvents: Li(e.begin_block_events || []),
    endBlockEvents: Li(e.end_block_events || [])
  };
}
function Hr(e) {
  return {
    hash: (0, le.fromHex)((0, ee.assertNotEmpty)(e.hash)),
    parts: {
      total: (0, ee.assertNotEmpty)(e.parts.total),
      hash: (0, le.fromHex)((0, ee.assertNotEmpty)(e.parts.hash))
    }
  };
}
function nS(e) {
  return {
    block: (0, ue.apiToSmallInt)(e.block),
    app: (0, ue.apiToSmallInt)(e.app ?? 0)
  };
}
function jr(e) {
  return {
    version: nS(e.version),
    chainId: (0, ee.assertNotEmpty)(e.chain_id),
    height: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.height)),
    time: (0, Xn.fromRfc3339WithNanoseconds)((0, ee.assertNotEmpty)(e.time)),
    // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
    // { hash: '', parts: { total: 0, hash: '' } }
    lastBlockId: e.last_block_id.hash ? Hr(e.last_block_id) : null,
    lastCommitHash: (0, le.fromHex)((0, ee.assertSet)(e.last_commit_hash)),
    dataHash: (0, le.fromHex)((0, ee.assertSet)(e.data_hash)),
    validatorsHash: (0, le.fromHex)((0, ee.assertSet)(e.validators_hash)),
    nextValidatorsHash: (0, le.fromHex)((0, ee.assertSet)(e.next_validators_hash)),
    consensusHash: (0, le.fromHex)((0, ee.assertSet)(e.consensus_hash)),
    appHash: (0, le.fromHex)((0, ee.assertSet)(e.app_hash)),
    lastResultsHash: (0, le.fromHex)((0, ee.assertSet)(e.last_results_hash)),
    evidenceHash: (0, le.fromHex)((0, ee.assertSet)(e.evidence_hash)),
    proposerAddress: (0, le.fromHex)((0, ee.assertNotEmpty)(e.proposer_address))
  };
}
function oS(e) {
  return {
    blockId: Hr(e.block_id),
    blockSize: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.block_size)),
    header: jr(e.header),
    numTxs: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.num_txs))
  };
}
function rS(e) {
  return {
    lastHeight: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.last_height)),
    blockMetas: (0, ee.assertArray)(e.block_metas).map(oS)
  };
}
function iS(e) {
  return {
    ...Bn(e),
    hash: (0, le.fromHex)((0, ee.assertNotEmpty)(e.hash))
  };
}
function sS(e) {
  return {
    height: (0, ue.apiToSmallInt)(e.height),
    hash: (0, le.fromHex)((0, ee.assertNotEmpty)(e.hash)),
    checkTx: Bn((0, ee.assertObject)(e.check_tx)),
    deliverTx: (0, ee.may)(Bn, e.deliver_tx)
  };
}
function aS(e) {
  return (0, Iu.assert)(e in Qy.BlockIdFlag), e;
}
function dS(e) {
  return e && !e.startsWith("0001-01-01") ? (0, Xn.fromRfc3339WithNanoseconds)(e) : void 0;
}
function cS(e) {
  return {
    blockIdFlag: aS(e.block_id_flag),
    validatorAddress: e.validator_address ? (0, le.fromHex)(e.validator_address) : void 0,
    timestamp: dS(e.timestamp),
    signature: e.signature ? (0, le.fromBase64)(e.signature) : void 0
  };
}
function Uu(e) {
  return {
    blockId: Hr((0, ee.assertObject)(e.block_id)),
    height: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.height)),
    round: (0, ue.apiToSmallInt)(e.round),
    signatures: (0, ee.assertArray)(e.signatures).map(cS)
  };
}
function uS(e) {
  return {
    canonical: (0, ee.assertBoolean)(e.canonical),
    header: jr(e.signed_header.header),
    commit: Uu(e.signed_header.commit)
  };
}
function Du(e) {
  return {
    address: (0, le.fromHex)((0, ee.assertNotEmpty)(e.address)),
    pubkey: Ss((0, ee.assertObject)(e.pub_key)),
    votingPower: (0, ue.apiToBigInt)((0, ee.assertNotEmpty)(e.power))
  };
}
dt.decodeValidatorGenesis = Du;
function lS(e) {
  return {
    genesisTime: (0, Xn.fromRfc3339WithNanoseconds)((0, ee.assertNotEmpty)(e.genesis_time)),
    chainId: (0, ee.assertNotEmpty)(e.chain_id),
    consensusParams: _u(e.consensus_params),
    validators: e.validators ? (0, ee.assertArray)(e.validators).map(Du) : [],
    appHash: (0, le.fromHex)((0, ee.assertSet)(e.app_hash)),
    appState: e.app_state
  };
}
function bs(e) {
  return {
    pubkey: Ss((0, ee.assertObject)(e.pub_key)),
    votingPower: (0, ue.apiToBigInt)((0, ee.assertNotEmpty)(e.voting_power)),
    address: (0, le.fromHex)((0, ee.assertNotEmpty)(e.address)),
    proposerPriority: e.proposer_priority ? (0, ue.apiToSmallInt)(e.proposer_priority) : void 0
  };
}
dt.decodeValidatorInfo = bs;
function pS(e) {
  return {
    id: (0, le.fromHex)((0, ee.assertNotEmpty)(e.id)),
    listenAddr: (0, ee.assertNotEmpty)(e.listen_addr),
    network: (0, ee.assertNotEmpty)(e.network),
    version: (0, ee.assertString)(e.version),
    channels: (0, ee.assertNotEmpty)(e.channels),
    moniker: (0, ee.assertNotEmpty)(e.moniker),
    other: (0, ee.dictionaryToStringMap)(e.other),
    protocolVersion: {
      app: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.protocol_version.app)),
      block: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.protocol_version.block)),
      p2p: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.protocol_version.p2p))
    }
  };
}
function fS(e) {
  const o = e.earliest_block_height ? (0, ue.apiToSmallInt)(e.earliest_block_height) : void 0, t = e.earliest_block_time ? (0, Xn.fromRfc3339WithNanoseconds)(e.earliest_block_time) : void 0;
  return {
    earliestAppHash: e.earliest_app_hash ? (0, le.fromHex)(e.earliest_app_hash) : void 0,
    earliestBlockHash: e.earliest_block_hash ? (0, le.fromHex)(e.earliest_block_hash) : void 0,
    earliestBlockHeight: o || void 0,
    earliestBlockTime: t != null && t.getTime() ? t : void 0,
    latestBlockHash: (0, le.fromHex)((0, ee.assertNotEmpty)(e.latest_block_hash)),
    latestAppHash: (0, le.fromHex)((0, ee.assertNotEmpty)(e.latest_app_hash)),
    latestBlockTime: (0, Xn.fromRfc3339WithNanoseconds)((0, ee.assertNotEmpty)(e.latest_block_time)),
    latestBlockHeight: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.latest_block_height)),
    catchingUp: (0, ee.assertBoolean)(e.catching_up)
  };
}
function mS(e) {
  return {
    nodeInfo: pS(e.node_info),
    syncInfo: fS(e.sync_info),
    validatorInfo: bs(e.validator_info)
  };
}
function gS(e) {
  return {
    data: (0, le.fromBase64)((0, ee.assertNotEmpty)(e.data)),
    rootHash: (0, le.fromHex)((0, ee.assertNotEmpty)(e.root_hash)),
    proof: {
      total: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.proof.total)),
      index: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.proof.index)),
      leafHash: (0, le.fromBase64)((0, ee.assertNotEmpty)(e.proof.leaf_hash)),
      aunts: (0, ee.assertArray)(e.proof.aunts).map(le.fromBase64)
    }
  };
}
function Lu(e) {
  return {
    tx: (0, le.fromBase64)((0, ee.assertNotEmpty)(e.tx)),
    result: Bn((0, ee.assertObject)(e.tx_result)),
    height: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.height)),
    index: (0, ue.apiToSmallInt)((0, ee.assertNumber)(e.index)),
    hash: (0, le.fromHex)((0, ee.assertNotEmpty)(e.hash)),
    proof: (0, ee.may)(gS, e.proof)
  };
}
function hS(e) {
  return {
    totalCount: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.total_count)),
    txs: (0, ee.assertArray)(e.txs).map(Lu)
  };
}
function vS(e) {
  const o = (0, le.fromBase64)((0, ee.assertNotEmpty)(e.tx));
  return {
    tx: o,
    hash: (0, Fy.hashTx)(o),
    result: Bn(e.result),
    height: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.height))
  };
}
function yS(e) {
  return {
    blockHeight: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.block_height)),
    validators: (0, ee.assertArray)(e.validators).map(bs),
    count: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.count)),
    total: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.total))
  };
}
function Bu(e) {
  var o;
  return {
    header: jr((0, ee.assertObject)(e.header)),
    // For the block at height 1, last commit is not set. This is represented in an empty object like this:
    // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
    lastCommit: e.last_commit.block_id.hash ? Uu((0, ee.assertObject)(e.last_commit)) : null,
    txs: e.data.txs ? (0, ee.assertArray)(e.data.txs).map(le.fromBase64) : [],
    // Lift up .evidence.evidence to just .evidence
    // See https://github.com/tendermint/tendermint/issues/7697
    evidence: ((o = e.evidence) == null ? void 0 : o.evidence) ?? []
  };
}
function Vu(e) {
  return {
    blockId: Hr(e.block_id),
    block: Bu(e.block)
  };
}
function SS(e) {
  return {
    totalCount: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.total_count)),
    blocks: (0, ee.assertArray)(e.blocks).map(Vu)
  };
}
function bS(e) {
  return {
    total: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.total)),
    totalBytes: (0, ue.apiToSmallInt)((0, ee.assertNotEmpty)(e.total_bytes))
  };
}
class Os {
  static decodeAbciInfo(o) {
    return Gy((0, ee.assertObject)(o.result.response));
  }
  static decodeAbciQuery(o) {
    return zy((0, ee.assertObject)(o.result.response));
  }
  static decodeBlock(o) {
    return Vu(o.result);
  }
  static decodeBlockResults(o) {
    return tS(o.result);
  }
  static decodeBlockSearch(o) {
    return SS(o.result);
  }
  static decodeBlockchain(o) {
    return rS(o.result);
  }
  static decodeBroadcastTxSync(o) {
    return iS(o.result);
  }
  static decodeBroadcastTxAsync(o) {
    return Os.decodeBroadcastTxSync(o);
  }
  static decodeBroadcastTxCommit(o) {
    return sS(o.result);
  }
  static decodeCommit(o) {
    return uS(o.result);
  }
  static decodeGenesis(o) {
    return lS((0, ee.assertObject)(o.result.genesis));
  }
  static decodeHealth() {
    return null;
  }
  static decodeNumUnconfirmedTxs(o) {
    return bS(o.result);
  }
  static decodeStatus(o) {
    return mS(o.result);
  }
  static decodeNewBlockEvent(o) {
    return Bu(o.data.value.block);
  }
  static decodeNewBlockHeaderEvent(o) {
    return jr(o.data.value.header);
  }
  static decodeTxEvent(o) {
    return vS(o.data.value.TxResult);
  }
  static decodeTx(o) {
    return Lu(o.result);
  }
  static decodeTxSearch(o) {
    return hS(o.result);
  }
  static decodeValidators(o) {
    return yS(o.result);
  }
}
dt.Responses = Os;
Object.defineProperty(Vr, "__esModule", { value: !0 });
Vr.adaptor37 = void 0;
const Ed = en, OS = Mr, kS = dt;
Vr.adaptor37 = {
  params: OS.Params,
  responses: kS.Responses,
  hashTx: Ed.hashTx,
  hashBlock: Ed.hashBlock
};
var PS = Q && Q.__createBinding || (Object.create ? function(e, o, t, u) {
  u === void 0 && (u = t);
  var r = Object.getOwnPropertyDescriptor(o, t);
  (!r || ("get" in r ? !o.__esModule : r.writable || r.configurable)) && (r = { enumerable: !0, get: function() {
    return o[t];
  } }), Object.defineProperty(e, u, r);
} : function(e, o, t, u) {
  u === void 0 && (u = t), e[u] = o[t];
}), RS = Q && Q.__setModuleDefault || (Object.create ? function(e, o) {
  Object.defineProperty(e, "default", { enumerable: !0, value: o });
} : function(e, o) {
  e.default = o;
}), AS = Q && Q.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var o = {};
  if (e != null)
    for (var t in e)
      t !== "default" && Object.prototype.hasOwnProperty.call(e, t) && PS(o, e, t);
  return RS(o, e), o;
};
Object.defineProperty(Br, "__esModule", { value: !0 });
Br.Tendermint37Client = void 0;
const wS = rn, Po = Sr, Td = Vr, ve = AS(Lr);
class Bo {
  /**
   * Creates a new Tendermint client for the given endpoint.
   *
   * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
   */
  static async connect(o) {
    let t;
    return typeof o == "object" ? t = new Po.HttpClient(o) : t = o.startsWith("http://") || o.startsWith("https://") ? new Po.HttpClient(o) : new Po.WebsocketClient(o), await this.detectVersion(t), Bo.create(t);
  }
  /**
   * Creates a new Tendermint client given an RPC client.
   */
  static async create(o) {
    return new Bo(o);
  }
  static async detectVersion(o) {
    const t = (0, wS.createJsonRpcRequest)(ve.Method.Status), u = (await o.execute(t)).result;
    if (!u || !u.node_info)
      throw new Error("Unrecognized format for status response");
    const r = u.node_info.version;
    if (typeof r != "string")
      throw new Error("Unrecognized version format: must be string");
    return r;
  }
  /**
   * Use `Tendermint37Client.connect` or `Tendermint37Client.create` to create an instance.
   */
  constructor(o) {
    this.client = o, this.p = Td.adaptor37.params, this.r = Td.adaptor37.responses;
  }
  disconnect() {
    this.client.disconnect();
  }
  async abciInfo() {
    const o = { method: ve.Method.AbciInfo };
    return this.doCall(o, this.p.encodeAbciInfo, this.r.decodeAbciInfo);
  }
  async abciQuery(o) {
    const t = { params: o, method: ve.Method.AbciQuery };
    return this.doCall(t, this.p.encodeAbciQuery, this.r.decodeAbciQuery);
  }
  async block(o) {
    const t = { method: ve.Method.Block, params: { height: o } };
    return this.doCall(t, this.p.encodeBlock, this.r.decodeBlock);
  }
  async blockResults(o) {
    const t = {
      method: ve.Method.BlockResults,
      params: { height: o }
    };
    return this.doCall(t, this.p.encodeBlockResults, this.r.decodeBlockResults);
  }
  /**
   * Search for events that are in a block.
   *
   * NOTE
   * This method will error on any node that is running a Tendermint version lower than 0.34.9.
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
   */
  async blockSearch(o) {
    const t = { params: o, method: ve.Method.BlockSearch }, u = await this.doCall(t, this.p.encodeBlockSearch, this.r.decodeBlockSearch);
    return {
      ...u,
      // make sure we sort by height, as tendermint may be sorting by string value of the height
      blocks: [...u.blocks].sort((r, m) => r.block.header.height - m.block.header.height)
    };
  }
  // this should paginate through all blockSearch options to ensure it returns all results.
  // starts with page 1 or whatever was provided (eg. to start on page 7)
  //
  // NOTE
  // This method will error on any node that is running a Tendermint version lower than 0.34.9.
  async blockSearchAll(o) {
    let t = o.page || 1;
    const u = [];
    let r = !1;
    for (; !r; ) {
      const m = await this.blockSearch({ ...o, page: t });
      u.push(...m.blocks), u.length < m.totalCount ? t++ : r = !0;
    }
    return u.sort((m, f) => m.block.header.height - f.block.header.height), {
      totalCount: u.length,
      blocks: u
    };
  }
  /**
   * Queries block headers filtered by minHeight <= height <= maxHeight.
   *
   * @param minHeight The minimum height to be included in the result. Defaults to 0.
   * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
   */
  async blockchain(o, t) {
    const u = {
      method: ve.Method.Blockchain,
      params: {
        minHeight: o,
        maxHeight: t
      }
    };
    return this.doCall(u, this.p.encodeBlockchain, this.r.decodeBlockchain);
  }
  /**
   * Broadcast transaction to mempool and wait for response
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
   */
  async broadcastTxSync(o) {
    const t = { params: o, method: ve.Method.BroadcastTxSync };
    return this.doCall(t, this.p.encodeBroadcastTx, this.r.decodeBroadcastTxSync);
  }
  /**
   * Broadcast transaction to mempool and do not wait for result
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
   */
  async broadcastTxAsync(o) {
    const t = { params: o, method: ve.Method.BroadcastTxAsync };
    return this.doCall(t, this.p.encodeBroadcastTx, this.r.decodeBroadcastTxAsync);
  }
  /**
   * Broadcast transaction to mempool and wait for block
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
   */
  async broadcastTxCommit(o) {
    const t = { params: o, method: ve.Method.BroadcastTxCommit };
    return this.doCall(t, this.p.encodeBroadcastTx, this.r.decodeBroadcastTxCommit);
  }
  async commit(o) {
    const t = { method: ve.Method.Commit, params: { height: o } };
    return this.doCall(t, this.p.encodeCommit, this.r.decodeCommit);
  }
  async genesis() {
    const o = { method: ve.Method.Genesis };
    return this.doCall(o, this.p.encodeGenesis, this.r.decodeGenesis);
  }
  async health() {
    const o = { method: ve.Method.Health };
    return this.doCall(o, this.p.encodeHealth, this.r.decodeHealth);
  }
  async numUnconfirmedTxs() {
    const o = { method: ve.Method.NumUnconfirmedTxs };
    return this.doCall(o, this.p.encodeNumUnconfirmedTxs, this.r.decodeNumUnconfirmedTxs);
  }
  async status() {
    const o = { method: ve.Method.Status };
    return this.doCall(o, this.p.encodeStatus, this.r.decodeStatus);
  }
  subscribeNewBlock() {
    const o = {
      method: ve.Method.Subscribe,
      query: { type: ve.SubscriptionEventType.NewBlock }
    };
    return this.subscribe(o, this.r.decodeNewBlockEvent);
  }
  subscribeNewBlockHeader() {
    const o = {
      method: ve.Method.Subscribe,
      query: { type: ve.SubscriptionEventType.NewBlockHeader }
    };
    return this.subscribe(o, this.r.decodeNewBlockHeaderEvent);
  }
  subscribeTx(o) {
    const t = {
      method: ve.Method.Subscribe,
      query: {
        type: ve.SubscriptionEventType.Tx,
        raw: o
      }
    };
    return this.subscribe(t, this.r.decodeTxEvent);
  }
  /**
   * Get a single transaction by hash
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/tx
   */
  async tx(o) {
    const t = { params: o, method: ve.Method.Tx };
    return this.doCall(t, this.p.encodeTx, this.r.decodeTx);
  }
  /**
   * Search for transactions that are in a block
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
   */
  async txSearch(o) {
    const t = { params: o, method: ve.Method.TxSearch };
    return this.doCall(t, this.p.encodeTxSearch, this.r.decodeTxSearch);
  }
  // this should paginate through all txSearch options to ensure it returns all results.
  // starts with page 1 or whatever was provided (eg. to start on page 7)
  async txSearchAll(o) {
    let t = o.page || 1;
    const u = [];
    let r = !1;
    for (; !r; ) {
      const m = await this.txSearch({ ...o, page: t });
      u.push(...m.txs), u.length < m.totalCount ? t++ : r = !0;
    }
    return {
      totalCount: u.length,
      txs: u
    };
  }
  async validators(o) {
    const t = {
      method: ve.Method.Validators,
      params: o
    };
    return this.doCall(t, this.p.encodeValidators, this.r.decodeValidators);
  }
  async validatorsAll(o) {
    const t = [];
    let u = 1, r = !1, m = o;
    for (; !r; ) {
      const f = await this.validators({
        per_page: 50,
        height: m,
        page: u
      });
      t.push(...f.validators), m = m || f.blockHeight, t.length < f.total ? u++ : r = !0;
    }
    return {
      // NOTE: Default value is for type safety but this should always be set
      blockHeight: m ?? 0,
      count: t.length,
      total: t.length,
      validators: t
    };
  }
  // doCall is a helper to handle the encode/call/decode logic
  async doCall(o, t, u) {
    const r = t(o), m = await this.client.execute(r);
    return u(m);
  }
  subscribe(o, t) {
    if (!(0, Po.instanceOfRpcStreamingClient)(this.client))
      throw new Error("This RPC client type cannot subscribe to events");
    const u = this.p.encodeSubscribe(o);
    return this.client.listen(u).map((r) => t(r));
  }
}
Br.Tendermint37Client = Bo;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Tendermint37Client = e.VoteType = e.broadcastTxSyncSuccess = e.broadcastTxCommitSuccess = e.SubscriptionEventType = e.Method = void 0;
  var o = Lr;
  Object.defineProperty(e, "Method", { enumerable: !0, get: function() {
    return o.Method;
  } }), Object.defineProperty(e, "SubscriptionEventType", { enumerable: !0, get: function() {
    return o.SubscriptionEventType;
  } });
  var t = Cu;
  Object.defineProperty(e, "broadcastTxCommitSuccess", { enumerable: !0, get: function() {
    return t.broadcastTxCommitSuccess;
  } }), Object.defineProperty(e, "broadcastTxSyncSuccess", { enumerable: !0, get: function() {
    return t.broadcastTxSyncSuccess;
  } }), Object.defineProperty(e, "VoteType", { enumerable: !0, get: function() {
    return t.VoteType;
  } });
  var u = Br;
  Object.defineProperty(e, "Tendermint37Client", { enumerable: !0, get: function() {
    return u.Tendermint37Client;
  } });
})(Lo);
var Vn = {};
Object.defineProperty(Vn, "__esModule", { value: !0 });
Vn.isTendermint37Client = Vn.isTendermint34Client = void 0;
const NS = zn, ES = Lo;
function TS(e) {
  return e instanceof NS.Tendermint34Client;
}
Vn.isTendermint34Client = TS;
function CS(e) {
  return e instanceof ES.Tendermint37Client;
}
Vn.isTendermint37Client = CS;
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(B, U, C, l) {
    l === void 0 && (l = C);
    var S = Object.getOwnPropertyDescriptor(U, C);
    (!S || ("get" in S ? !U.__esModule : S.writable || S.configurable)) && (S = { enumerable: !0, get: function() {
      return U[C];
    } }), Object.defineProperty(B, l, S);
  } : function(B, U, C, l) {
    l === void 0 && (l = C), B[l] = U[C];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(B, U) {
    Object.defineProperty(B, "default", { enumerable: !0, value: U });
  } : function(B, U) {
    B.default = U;
  }), u = Q && Q.__importStar || function(B) {
    if (B && B.__esModule)
      return B;
    var U = {};
    if (B != null)
      for (var C in B)
        C !== "default" && Object.prototype.hasOwnProperty.call(B, C) && o(U, B, C);
    return t(U, B), U;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.BlockIdFlag = e.isTendermint37Client = e.isTendermint34Client = e.Tendermint37Client = e.tendermint37 = e.Tendermint34Client = e.tendermint34 = e.VoteType = e.SubscriptionEventType = e.Method = e.broadcastTxSyncSuccess = e.broadcastTxCommitSuccess = e.WebsocketClient = e.HttpClient = e.HttpBatchClient = e.toSeconds = e.toRfc3339WithNanoseconds = e.fromSeconds = e.fromRfc3339WithNanoseconds = e.DateTime = e.rawSecp256k1PubkeyToRawAddress = e.rawEd25519PubkeyToRawAddress = e.pubkeyToRawAddress = e.pubkeyToAddress = void 0;
  var r = kt;
  Object.defineProperty(e, "pubkeyToAddress", { enumerable: !0, get: function() {
    return r.pubkeyToAddress;
  } }), Object.defineProperty(e, "pubkeyToRawAddress", { enumerable: !0, get: function() {
    return r.pubkeyToRawAddress;
  } }), Object.defineProperty(e, "rawEd25519PubkeyToRawAddress", { enumerable: !0, get: function() {
    return r.rawEd25519PubkeyToRawAddress;
  } }), Object.defineProperty(e, "rawSecp256k1PubkeyToRawAddress", { enumerable: !0, get: function() {
    return r.rawSecp256k1PubkeyToRawAddress;
  } });
  var m = Fe;
  Object.defineProperty(e, "DateTime", { enumerable: !0, get: function() {
    return m.DateTime;
  } }), Object.defineProperty(e, "fromRfc3339WithNanoseconds", { enumerable: !0, get: function() {
    return m.fromRfc3339WithNanoseconds;
  } }), Object.defineProperty(e, "fromSeconds", { enumerable: !0, get: function() {
    return m.fromSeconds;
  } }), Object.defineProperty(e, "toRfc3339WithNanoseconds", { enumerable: !0, get: function() {
    return m.toRfc3339WithNanoseconds;
  } }), Object.defineProperty(e, "toSeconds", { enumerable: !0, get: function() {
    return m.toSeconds;
  } });
  var f = Sr;
  Object.defineProperty(e, "HttpBatchClient", { enumerable: !0, get: function() {
    return f.HttpBatchClient;
  } }), Object.defineProperty(e, "HttpClient", { enumerable: !0, get: function() {
    return f.HttpClient;
  } }), Object.defineProperty(e, "WebsocketClient", { enumerable: !0, get: function() {
    return f.WebsocketClient;
  } });
  var b = zn;
  Object.defineProperty(e, "broadcastTxCommitSuccess", { enumerable: !0, get: function() {
    return b.broadcastTxCommitSuccess;
  } }), Object.defineProperty(e, "broadcastTxSyncSuccess", { enumerable: !0, get: function() {
    return b.broadcastTxSyncSuccess;
  } }), Object.defineProperty(e, "Method", { enumerable: !0, get: function() {
    return b.Method;
  } }), Object.defineProperty(e, "SubscriptionEventType", { enumerable: !0, get: function() {
    return b.SubscriptionEventType;
  } }), Object.defineProperty(e, "VoteType", { enumerable: !0, get: function() {
    return b.VoteType;
  } }), e.tendermint34 = u(zn);
  var R = zn;
  Object.defineProperty(e, "Tendermint34Client", { enumerable: !0, get: function() {
    return R.Tendermint34Client;
  } }), e.tendermint37 = u(Lo);
  var T = Lo;
  Object.defineProperty(e, "Tendermint37Client", { enumerable: !0, get: function() {
    return T.Tendermint37Client;
  } });
  var V = Vn;
  Object.defineProperty(e, "isTendermint34Client", { enumerable: !0, get: function() {
    return V.isTendermint34Client;
  } }), Object.defineProperty(e, "isTendermint37Client", { enumerable: !0, get: function() {
    return V.isTendermint37Client;
  } });
  var D = Jr;
  Object.defineProperty(e, "BlockIdFlag", { enumerable: !0, get: function() {
    return D.BlockIdFlag;
  } });
})(rs);
var Ne = {};
Object.defineProperty(Ne, "__esModule", { value: !0 });
Ne.StargateClient = Ne.BroadcastTxError = Ne.assertIsDeliverTxFailure = Ne.assertIsDeliverTxSuccess = Ne.isDeliverTxSuccess = Ne.isDeliverTxFailure = Ne.TimeoutError = void 0;
const IS = Mi, ki = Be, Cd = Rt, Pi = rs, Id = ht, xS = os, _S = to, JS = oo, Ro = Yn, US = Ve;
class Mu extends Error {
  constructor(o, t) {
    super(o), this.txId = t;
  }
}
Ne.TimeoutError = Mu;
function ks(e) {
  return !!e.code;
}
Ne.isDeliverTxFailure = ks;
function Hu(e) {
  return !ks(e);
}
Ne.isDeliverTxSuccess = Hu;
function DS(e) {
  if (ks(e))
    throw new Error(`Error when broadcasting tx ${e.transactionHash} at height ${e.height}. Code: ${e.code}; Raw log: ${e.rawLog}`);
}
Ne.assertIsDeliverTxSuccess = DS;
function LS(e) {
  if (Hu(e))
    throw new Error(`Transaction ${e.transactionHash} did not fail at height ${e.height}. Code: ${e.code}; Raw log: ${e.rawLog}`);
}
Ne.assertIsDeliverTxFailure = LS;
class ju extends Error {
  constructor(o, t, u) {
    super(`Broadcasting transaction failed with code ${o} (codespace: ${t}). Log: ${u}`), this.code = o, this.codespace = t, this.log = u;
  }
}
Ne.BroadcastTxError = ju;
class Vo {
  /**
   * Creates an instance by connecting to the given Tendermint RPC endpoint.
   *
   * This uses auto-detection to decide between a Tendermint 0.37 and 0.34 client.
   * To set the Tendermint client explicitly, use `create`.
   */
  static async connect(o, t = {}) {
    let u;
    const r = await Pi.Tendermint37Client.connect(o);
    return (await r.status()).nodeInfo.version.startsWith("0.37.") ? u = r : (r.disconnect(), u = await Pi.Tendermint34Client.connect(o)), Vo.create(u, t);
  }
  /**
   * Creates an instance from a manually created Tendermint client.
   * Use this to use `Tendermint37Client` instead of `Tendermint34Client`.
   */
  static async create(o, t = {}) {
    return new Vo(o, t);
  }
  constructor(o, t) {
    o && (this.tmClient = o, this.queryClient = US.QueryClient.withExtensions(o, Ro.setupAuthExtension, Ro.setupBankExtension, Ro.setupStakingExtension, Ro.setupTxExtension));
    const { accountParser: u = _S.accountFromAny } = t;
    this.accountParser = u;
  }
  getTmClient() {
    return this.tmClient;
  }
  forceGetTmClient() {
    if (!this.tmClient)
      throw new Error("Tendermint client not available. You cannot use online functionality in offline mode.");
    return this.tmClient;
  }
  getQueryClient() {
    return this.queryClient;
  }
  forceGetQueryClient() {
    if (!this.queryClient)
      throw new Error("Query client not available. You cannot use online functionality in offline mode.");
    return this.queryClient;
  }
  async getChainId() {
    if (!this.chainId) {
      const o = (await this.forceGetTmClient().status()).nodeInfo.network;
      if (!o)
        throw new Error("Chain ID must not be empty");
      this.chainId = o;
    }
    return this.chainId;
  }
  async getHeight() {
    return (await this.forceGetTmClient().status()).syncInfo.latestBlockHeight;
  }
  async getAccount(o) {
    try {
      const t = await this.forceGetQueryClient().auth.account(o);
      return t ? this.accountParser(t) : null;
    } catch (t) {
      if (/rpc error: code = NotFound/i.test(t.toString()))
        return null;
      throw t;
    }
  }
  async getSequence(o) {
    const t = await this.getAccount(o);
    if (!t)
      throw new Error(`Account '${o}' does not exist on chain. Send some tokens there before trying to query sequence.`);
    return {
      accountNumber: t.accountNumber,
      sequence: t.sequence
    };
  }
  async getBlock(o) {
    const t = await this.forceGetTmClient().block(o);
    return {
      id: (0, ki.toHex)(t.blockId.hash).toUpperCase(),
      header: {
        version: {
          block: new Cd.Uint53(t.block.header.version.block).toString(),
          app: new Cd.Uint53(t.block.header.version.app).toString()
        },
        height: t.block.header.height,
        chainId: t.block.header.chainId,
        time: (0, Pi.toRfc3339WithNanoseconds)(t.block.header.time)
      },
      txs: t.block.txs
    };
  }
  async getBalance(o, t) {
    return this.forceGetQueryClient().bank.balance(o, t);
  }
  /**
   * Queries all balances for all denoms that belong to this address.
   *
   * Uses the grpc queries (which iterates over the store internally), and we cannot get
   * proofs from such a method.
   */
  async getAllBalances(o) {
    return this.forceGetQueryClient().bank.allBalances(o);
  }
  async getBalanceStaked(o) {
    const t = [];
    let u;
    do {
      const { delegationResponses: r, pagination: m } = await this.forceGetQueryClient().staking.delegatorDelegations(o, u), f = r || [];
      t.push(...f), u = m == null ? void 0 : m.nextKey;
    } while (u !== void 0 && u.length !== 0);
    return t.reduce((r, m) => ((0, Id.assert)(m.balance), r !== null ? (0, IS.addCoins)(r, m.balance) : m.balance), null);
  }
  async getDelegation(o, t) {
    var u;
    let r;
    try {
      r = (u = (await this.forceGetQueryClient().staking.delegation(o, t)).delegationResponse) == null ? void 0 : u.balance;
    } catch (m) {
      if (!m.toString().includes("key not found"))
        throw m;
    }
    return r || null;
  }
  async getTx(o) {
    return (await this.txsQuery(`tx.hash='${o}'`))[0] ?? null;
  }
  async searchTx(o) {
    let t;
    if (typeof o == "string")
      t = o;
    else if (Array.isArray(o))
      t = o.map((u) => `${u.key}='${u.value}'`).join(" AND ");
    else
      throw new Error("Got unsupported query type. See CosmJS 0.31 CHANGELOG for API breaking changes here.");
    return this.txsQuery(t);
  }
  disconnect() {
    this.tmClient && this.tmClient.disconnect();
  }
  /**
   * Broadcasts a signed transaction to the network and monitors its inclusion in a block.
   *
   * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
   * an error is thrown.
   *
   * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.
   *
   * If the transaction is included in a block, a `DeliverTxResponse` is returned. The caller then
   * usually needs to check for execution success or failure.
   */
  async broadcastTx(o, t = 6e4, u = 3e3) {
    let r = !1;
    const m = setTimeout(() => {
      r = !0;
    }, t), f = async (R) => {
      if (r)
        throw new Mu(`Transaction with ID ${R} was submitted but was not yet found on the chain. You might want to check later. There was a wait of ${t / 1e3} seconds.`, R);
      await (0, Id.sleep)(u);
      const T = await this.getTx(R);
      return T ? {
        code: T.code,
        height: T.height,
        txIndex: T.txIndex,
        events: T.events,
        rawLog: T.rawLog,
        transactionHash: R,
        msgResponses: T.msgResponses,
        gasUsed: T.gasUsed,
        gasWanted: T.gasWanted
      } : f(R);
    }, b = await this.broadcastTxSync(o);
    return new Promise((R, T) => f(b).then((V) => {
      clearTimeout(m), R(V);
    }, (V) => {
      clearTimeout(m), T(V);
    }));
  }
  /**
   * Broadcasts a signed transaction to the network without monitoring it.
   *
   * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
   * an error is thrown.
   *
   * If the transaction is broadcasted, a `string` containing the hash of the transaction is returned. The caller then
   * usually needs to check if the transaction was included in a block and was successful.
   *
   * @returns Returns the hash of the transaction
   */
  async broadcastTxSync(o) {
    const t = await this.forceGetTmClient().broadcastTxSync({ tx: o });
    return t.code ? Promise.reject(new ju(t.code, t.codespace ?? "", t.log)) : (0, ki.toHex)(t.hash).toUpperCase();
  }
  async txsQuery(o) {
    return (await this.forceGetTmClient().txSearchAll({ query: o })).txs.map((t) => {
      const u = xS.TxMsgData.decode(t.result.data ?? new Uint8Array());
      return {
        height: t.height,
        txIndex: t.index,
        hash: (0, ki.toHex)(t.hash).toUpperCase(),
        code: t.result.code,
        events: t.result.events.map(JS.fromTendermintEvent),
        rawLog: t.result.log || "",
        tx: t.tx,
        msgResponses: u.msgResponses,
        gasUsed: t.result.gasUsed,
        gasWanted: t.result.gasWanted
      };
    });
  }
}
Ne.StargateClient = Vo;
(function(e) {
  var o = Q && Q.__importDefault || function(_) {
    return _ && _.__esModule ? _ : { default: _ };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.SigningStargateClient = e.createDefaultAminoConverters = e.defaultRegistryTypes = void 0;
  const t = Mi, u = Be, r = Rt, m = tn, f = rs, b = ht, R = Le, T = Ki, V = es, D = Bi, B = eo, U = ur, C = o(Pt), l = no, S = Yt, A = Yn, d = Yn, p = Ne;
  e.defaultRegistryTypes = [
    ["/cosmos.base.v1beta1.Coin", R.Coin],
    ...A.authzTypes,
    ...A.bankTypes,
    ...A.distributionTypes,
    ...A.feegrantTypes,
    ...A.govTypes,
    ...A.groupTypes,
    ...A.stakingTypes,
    ...A.ibcTypes,
    ...A.vestingTypes
  ];
  function h() {
    return {
      ...(0, d.createAuthzAminoConverters)(),
      ...(0, d.createBankAminoConverters)(),
      ...(0, d.createDistributionAminoConverters)(),
      ...(0, d.createGovAminoConverters)(),
      ...(0, d.createStakingAminoConverters)(),
      ...(0, d.createIbcAminoConverters)(),
      ...(0, d.createFeegrantAminoConverters)(),
      ...(0, d.createVestingAminoConverters)()
    };
  }
  e.createDefaultAminoConverters = h;
  class x extends p.StargateClient {
    /**
     * Creates an instance by connecting to the given Tendermint RPC endpoint.
     *
     * This uses auto-detection to decide between a Tendermint 0.37 and 0.34 client.
     * To set the Tendermint client explicitly, use `createWithSigner`.
     */
    static async connectWithSigner(I, W, n = {}) {
      let y;
      const w = await f.Tendermint37Client.connect(I);
      return (await w.status()).nodeInfo.version.startsWith("0.37.") ? y = w : (w.disconnect(), y = await f.Tendermint34Client.connect(I)), x.createWithSigner(y, W, n);
    }
    /**
     * Creates an instance from a manually created Tendermint client.
     * Use this to use `Tendermint37Client` instead of `Tendermint34Client`.
     */
    static async createWithSigner(I, W, n = {}) {
      return new x(I, W, n);
    }
    /**
     * Creates a client in offline mode.
     *
     * This should only be used in niche cases where you know exactly what you're doing,
     * e.g. when building an offline signing application.
     *
     * When you try to use online functionality with such a signer, an
     * exception will be raised.
     */
    static async offline(I, W = {}) {
      return new x(void 0, I, W);
    }
    constructor(I, W, n) {
      super(I, n);
      const { registry: y = new m.Registry(e.defaultRegistryTypes), aminoTypes: w = new l.AminoTypes(h()) } = n;
      this.registry = y, this.aminoTypes = w, this.signer = W, this.broadcastTimeoutMs = n.broadcastTimeoutMs, this.broadcastPollIntervalMs = n.broadcastPollIntervalMs, this.gasPrice = n.gasPrice;
    }
    async simulate(I, W, n) {
      const y = W.map((E) => this.registry.encodeAsAny(E)), w = (await this.signer.getAccounts()).find((E) => E.address === I);
      if (!w)
        throw new Error("Failed to retrieve account from signer");
      const M = (0, t.encodeSecp256k1Pubkey)(w.pubkey), { sequence: s } = await this.getSequence(I), { gasInfo: c } = await this.forceGetQueryClient().tx.simulate(y, n, M, s);
      return (0, b.assertDefined)(c), r.Uint53.fromString(c.gasUsed.toString()).toNumber();
    }
    async sendTokens(I, W, n, y, w = "") {
      const M = {
        typeUrl: "/cosmos.bank.v1beta1.MsgSend",
        value: {
          fromAddress: I,
          toAddress: W,
          amount: [...n]
        }
      };
      return this.signAndBroadcast(I, [M], y, w);
    }
    async delegateTokens(I, W, n, y, w = "") {
      const M = {
        typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
        value: V.MsgDelegate.fromPartial({
          delegatorAddress: I,
          validatorAddress: W,
          amount: n
        })
      };
      return this.signAndBroadcast(I, [M], y, w);
    }
    async undelegateTokens(I, W, n, y, w = "") {
      const M = {
        typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
        value: V.MsgUndelegate.fromPartial({
          delegatorAddress: I,
          validatorAddress: W,
          amount: n
        })
      };
      return this.signAndBroadcast(I, [M], y, w);
    }
    async withdrawRewards(I, W, n, y = "") {
      const w = {
        typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
        value: T.MsgWithdrawDelegatorReward.fromPartial({
          delegatorAddress: I,
          validatorAddress: W
        })
      };
      return this.signAndBroadcast(I, [w], n, y);
    }
    async sendIbcTokens(I, W, n, y, w, M, s, c, E = "") {
      const k = s ? C.default.fromNumber(s).multiply(1e9) : void 0, O = {
        typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
        value: U.MsgTransfer.fromPartial({
          sourcePort: y,
          sourceChannel: w,
          sender: I,
          receiver: W,
          token: n,
          timeoutHeight: M,
          timeoutTimestamp: k
        })
      };
      return this.signAndBroadcast(I, [O], c, E);
    }
    async signAndBroadcast(I, W, n, y = "") {
      let w;
      if (n == "auto" || typeof n == "number") {
        (0, b.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
        const c = await this.simulate(I, W, y), E = typeof n == "number" ? n : 1.4;
        w = (0, S.calculateFee)(Math.round(c * E), this.gasPrice);
      } else
        w = n;
      const M = await this.sign(I, W, w, y), s = B.TxRaw.encode(M).finish();
      return this.broadcastTx(s, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);
    }
    /**
     * This method is useful if you want to send a transaction in broadcast,
     * without waiting for it to be placed inside a block, because for example
     * I would like to receive the hash to later track the transaction with another tool.
     * @returns Returns the hash of the transaction
     */
    async signAndBroadcastSync(I, W, n, y = "") {
      let w;
      if (n == "auto" || typeof n == "number") {
        (0, b.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
        const c = await this.simulate(I, W, y), E = typeof n == "number" ? n : 1.3;
        w = (0, S.calculateFee)(Math.round(c * E), this.gasPrice);
      } else
        w = n;
      const M = await this.sign(I, W, w, y), s = B.TxRaw.encode(M).finish();
      return this.broadcastTxSync(s);
    }
    /**
     * Gets account number and sequence from the API, creates a sign doc,
     * creates a single signature and assembles the signed transaction.
     *
     * The sign mode (SIGN_MODE_DIRECT or SIGN_MODE_LEGACY_AMINO_JSON) is determined by this client's signer.
     *
     * You can pass signer data (account number, sequence and chain ID) explicitly instead of querying them
     * from the chain. This is needed when signing for a multisig account, but it also allows for offline signing
     * (See the SigningStargateClient.offline constructor).
     */
    async sign(I, W, n, y, w) {
      let M;
      if (w)
        M = w;
      else {
        const { accountNumber: s, sequence: c } = await this.getSequence(I), E = await this.getChainId();
        M = {
          accountNumber: s,
          sequence: c,
          chainId: E
        };
      }
      return (0, m.isOfflineDirectSigner)(this.signer) ? this.signDirect(I, W, n, y, M) : this.signAmino(I, W, n, y, M);
    }
    async signAmino(I, W, n, y, { accountNumber: w, sequence: M, chainId: s }) {
      (0, b.assert)(!(0, m.isOfflineDirectSigner)(this.signer));
      const c = (await this.signer.getAccounts()).find((q) => q.address === I);
      if (!c)
        throw new Error("Failed to retrieve account from signer");
      const E = (0, m.encodePubkey)((0, t.encodeSecp256k1Pubkey)(c.pubkey)), k = D.SignMode.SIGN_MODE_LEGACY_AMINO_JSON, O = W.map((q) => this.aminoTypes.toAmino(q)), L = (0, t.makeSignDoc)(O, n, s, y, w, M), { signature: Z, signed: j } = await this.signer.signAmino(I, L), i = {
        typeUrl: "/cosmos.tx.v1beta1.TxBody",
        value: {
          messages: j.msgs.map((q) => this.aminoTypes.fromAmino(q)),
          memo: j.memo
        }
      }, P = this.registry.encode(i), g = r.Int53.fromString(j.fee.gas).toNumber(), v = r.Int53.fromString(j.sequence).toNumber(), N = (0, m.makeAuthInfoBytes)([{ pubkey: E, sequence: v }], j.fee.amount, g, j.fee.granter, j.fee.payer, k);
      return B.TxRaw.fromPartial({
        bodyBytes: P,
        authInfoBytes: N,
        signatures: [(0, u.fromBase64)(Z.signature)]
      });
    }
    async signDirect(I, W, n, y, { accountNumber: w, sequence: M, chainId: s }) {
      (0, b.assert)((0, m.isOfflineDirectSigner)(this.signer));
      const c = (await this.signer.getAccounts()).find((g) => g.address === I);
      if (!c)
        throw new Error("Failed to retrieve account from signer");
      const E = (0, m.encodePubkey)((0, t.encodeSecp256k1Pubkey)(c.pubkey)), k = {
        typeUrl: "/cosmos.tx.v1beta1.TxBody",
        value: {
          messages: W,
          memo: y
        }
      }, O = this.registry.encode(k), L = r.Int53.fromString(n.gas).toNumber(), Z = (0, m.makeAuthInfoBytes)([{ pubkey: E, sequence: M }], n.amount, L, n.granter, n.payer), j = (0, m.makeSignDoc)(O, Z, s, w), { signature: i, signed: P } = await this.signer.signDirect(I, j);
      return B.TxRaw.fromPartial({
        bodyBytes: P.bodyBytes,
        authInfoBytes: P.authInfoBytes,
        signatures: [(0, u.fromBase64)(i.signature)]
      });
    }
  }
  e.SigningStargateClient = x;
})(Zc);
(function(e) {
  var o = Q && Q.__createBinding || (Object.create ? function(C, l, S, A) {
    A === void 0 && (A = S);
    var d = Object.getOwnPropertyDescriptor(l, S);
    (!d || ("get" in d ? !l.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return l[S];
    } }), Object.defineProperty(C, A, d);
  } : function(C, l, S, A) {
    A === void 0 && (A = S), C[A] = l[S];
  }), t = Q && Q.__setModuleDefault || (Object.create ? function(C, l) {
    Object.defineProperty(C, "default", { enumerable: !0, value: l });
  } : function(C, l) {
    C.default = l;
  }), u = Q && Q.__importStar || function(C) {
    if (C && C.__esModule)
      return C;
    var l = {};
    if (C != null)
      for (var S in C)
        S !== "default" && Object.prototype.hasOwnProperty.call(C, S) && o(l, C, S);
    return t(l, C), l;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isMsgWithdrawDelegatorRewardEncodeObject = e.isMsgVoteWeightedEncodeObject = e.isMsgVoteEncodeObject = e.isMsgUndelegateEncodeObject = e.isMsgTransferEncodeObject = e.isMsgSubmitProposalEncodeObject = e.isMsgSendEncodeObject = e.isMsgEditValidatorEncodeObject = e.isMsgDepositEncodeObject = e.isMsgDelegateEncodeObject = e.isMsgCreateValidatorEncodeObject = e.isMsgBeginRedelegateEncodeObject = e.isAminoMsgWithdrawValidatorCommission = e.isAminoMsgWithdrawDelegatorReward = e.isAminoMsgVoteWeighted = e.isAminoMsgVote = e.isAminoMsgVerifyInvariant = e.isAminoMsgUnjail = e.isAminoMsgUndelegate = e.isAminoMsgTransfer = e.isAminoMsgSubmitProposal = e.isAminoMsgSubmitEvidence = e.isAminoMsgSetWithdrawAddress = e.isAminoMsgSend = e.isAminoMsgMultiSend = e.isAminoMsgFundCommunityPool = e.isAminoMsgEditValidator = e.isAminoMsgDeposit = e.isAminoMsgDelegate = e.isAminoMsgCreateVestingAccount = e.isAminoMsgCreateValidator = e.isAminoMsgBeginRedelegate = e.createVestingAminoConverters = e.createStakingAminoConverters = e.createSlashingAminoConverters = e.createIbcAminoConverters = e.createGroupAminoConverters = e.createGovAminoConverters = e.createFeegrantAminoConverters = e.createEvidenceAminoConverters = e.createDistributionAminoConverters = e.createCrysisAminoConverters = e.createBankAminoConverters = e.createAuthzAminoConverters = e.logs = e.GasPrice = e.calculateFee = e.fromTendermintEvent = e.AminoTypes = e.accountFromAny = void 0, e.parseCoins = e.makeCosmoshubPath = e.coins = e.coin = e.TimeoutError = e.StargateClient = e.isDeliverTxSuccess = e.isDeliverTxFailure = e.BroadcastTxError = e.assertIsDeliverTxSuccess = e.assertIsDeliverTxFailure = e.SigningStargateClient = e.defaultRegistryTypes = e.createDefaultAminoConverters = e.QueryClient = e.decodeCosmosSdkDecFromProto = e.createProtobufRpcClient = e.createPagination = e.makeMultisignedTxBytes = e.makeMultisignedTx = e.setupTxExtension = e.setupStakingExtension = e.setupSlashingExtension = e.setupMintExtension = e.setupIbcExtension = e.setupGovExtension = e.setupFeegrantExtension = e.setupDistributionExtension = e.setupBankExtension = e.setupAuthzExtension = e.setupAuthExtension = void 0;
  var r = to;
  Object.defineProperty(e, "accountFromAny", { enumerable: !0, get: function() {
    return r.accountFromAny;
  } });
  var m = no;
  Object.defineProperty(e, "AminoTypes", { enumerable: !0, get: function() {
    return m.AminoTypes;
  } });
  var f = oo;
  Object.defineProperty(e, "fromTendermintEvent", { enumerable: !0, get: function() {
    return f.fromTendermintEvent;
  } });
  var b = Yt;
  Object.defineProperty(e, "calculateFee", { enumerable: !0, get: function() {
    return b.calculateFee;
  } }), Object.defineProperty(e, "GasPrice", { enumerable: !0, get: function() {
    return b.GasPrice;
  } }), e.logs = u(Ze);
  var R = Yn;
  Object.defineProperty(e, "createAuthzAminoConverters", { enumerable: !0, get: function() {
    return R.createAuthzAminoConverters;
  } }), Object.defineProperty(e, "createBankAminoConverters", { enumerable: !0, get: function() {
    return R.createBankAminoConverters;
  } }), Object.defineProperty(e, "createCrysisAminoConverters", { enumerable: !0, get: function() {
    return R.createCrysisAminoConverters;
  } }), Object.defineProperty(e, "createDistributionAminoConverters", { enumerable: !0, get: function() {
    return R.createDistributionAminoConverters;
  } }), Object.defineProperty(e, "createEvidenceAminoConverters", { enumerable: !0, get: function() {
    return R.createEvidenceAminoConverters;
  } }), Object.defineProperty(e, "createFeegrantAminoConverters", { enumerable: !0, get: function() {
    return R.createFeegrantAminoConverters;
  } }), Object.defineProperty(e, "createGovAminoConverters", { enumerable: !0, get: function() {
    return R.createGovAminoConverters;
  } }), Object.defineProperty(e, "createGroupAminoConverters", { enumerable: !0, get: function() {
    return R.createGroupAminoConverters;
  } }), Object.defineProperty(e, "createIbcAminoConverters", { enumerable: !0, get: function() {
    return R.createIbcAminoConverters;
  } }), Object.defineProperty(e, "createSlashingAminoConverters", { enumerable: !0, get: function() {
    return R.createSlashingAminoConverters;
  } }), Object.defineProperty(e, "createStakingAminoConverters", { enumerable: !0, get: function() {
    return R.createStakingAminoConverters;
  } }), Object.defineProperty(e, "createVestingAminoConverters", { enumerable: !0, get: function() {
    return R.createVestingAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgBeginRedelegate", { enumerable: !0, get: function() {
    return R.isAminoMsgBeginRedelegate;
  } }), Object.defineProperty(e, "isAminoMsgCreateValidator", { enumerable: !0, get: function() {
    return R.isAminoMsgCreateValidator;
  } }), Object.defineProperty(e, "isAminoMsgCreateVestingAccount", { enumerable: !0, get: function() {
    return R.isAminoMsgCreateVestingAccount;
  } }), Object.defineProperty(e, "isAminoMsgDelegate", { enumerable: !0, get: function() {
    return R.isAminoMsgDelegate;
  } }), Object.defineProperty(e, "isAminoMsgDeposit", { enumerable: !0, get: function() {
    return R.isAminoMsgDeposit;
  } }), Object.defineProperty(e, "isAminoMsgEditValidator", { enumerable: !0, get: function() {
    return R.isAminoMsgEditValidator;
  } }), Object.defineProperty(e, "isAminoMsgFundCommunityPool", { enumerable: !0, get: function() {
    return R.isAminoMsgFundCommunityPool;
  } }), Object.defineProperty(e, "isAminoMsgMultiSend", { enumerable: !0, get: function() {
    return R.isAminoMsgMultiSend;
  } }), Object.defineProperty(e, "isAminoMsgSend", { enumerable: !0, get: function() {
    return R.isAminoMsgSend;
  } }), Object.defineProperty(e, "isAminoMsgSetWithdrawAddress", { enumerable: !0, get: function() {
    return R.isAminoMsgSetWithdrawAddress;
  } }), Object.defineProperty(e, "isAminoMsgSubmitEvidence", { enumerable: !0, get: function() {
    return R.isAminoMsgSubmitEvidence;
  } }), Object.defineProperty(e, "isAminoMsgSubmitProposal", { enumerable: !0, get: function() {
    return R.isAminoMsgSubmitProposal;
  } }), Object.defineProperty(e, "isAminoMsgTransfer", { enumerable: !0, get: function() {
    return R.isAminoMsgTransfer;
  } }), Object.defineProperty(e, "isAminoMsgUndelegate", { enumerable: !0, get: function() {
    return R.isAminoMsgUndelegate;
  } }), Object.defineProperty(e, "isAminoMsgUnjail", { enumerable: !0, get: function() {
    return R.isAminoMsgUnjail;
  } }), Object.defineProperty(e, "isAminoMsgVerifyInvariant", { enumerable: !0, get: function() {
    return R.isAminoMsgVerifyInvariant;
  } }), Object.defineProperty(e, "isAminoMsgVote", { enumerable: !0, get: function() {
    return R.isAminoMsgVote;
  } }), Object.defineProperty(e, "isAminoMsgVoteWeighted", { enumerable: !0, get: function() {
    return R.isAminoMsgVoteWeighted;
  } }), Object.defineProperty(e, "isAminoMsgWithdrawDelegatorReward", { enumerable: !0, get: function() {
    return R.isAminoMsgWithdrawDelegatorReward;
  } }), Object.defineProperty(e, "isAminoMsgWithdrawValidatorCommission", { enumerable: !0, get: function() {
    return R.isAminoMsgWithdrawValidatorCommission;
  } }), Object.defineProperty(e, "isMsgBeginRedelegateEncodeObject", { enumerable: !0, get: function() {
    return R.isMsgBeginRedelegateEncodeObject;
  } }), Object.defineProperty(e, "isMsgCreateValidatorEncodeObject", { enumerable: !0, get: function() {
    return R.isMsgCreateValidatorEncodeObject;
  } }), Object.defineProperty(e, "isMsgDelegateEncodeObject", { enumerable: !0, get: function() {
    return R.isMsgDelegateEncodeObject;
  } }), Object.defineProperty(e, "isMsgDepositEncodeObject", { enumerable: !0, get: function() {
    return R.isMsgDepositEncodeObject;
  } }), Object.defineProperty(e, "isMsgEditValidatorEncodeObject", { enumerable: !0, get: function() {
    return R.isMsgEditValidatorEncodeObject;
  } }), Object.defineProperty(e, "isMsgSendEncodeObject", { enumerable: !0, get: function() {
    return R.isMsgSendEncodeObject;
  } }), Object.defineProperty(e, "isMsgSubmitProposalEncodeObject", { enumerable: !0, get: function() {
    return R.isMsgSubmitProposalEncodeObject;
  } }), Object.defineProperty(e, "isMsgTransferEncodeObject", { enumerable: !0, get: function() {
    return R.isMsgTransferEncodeObject;
  } }), Object.defineProperty(e, "isMsgUndelegateEncodeObject", { enumerable: !0, get: function() {
    return R.isMsgUndelegateEncodeObject;
  } }), Object.defineProperty(e, "isMsgVoteEncodeObject", { enumerable: !0, get: function() {
    return R.isMsgVoteEncodeObject;
  } }), Object.defineProperty(e, "isMsgVoteWeightedEncodeObject", { enumerable: !0, get: function() {
    return R.isMsgVoteWeightedEncodeObject;
  } }), Object.defineProperty(e, "isMsgWithdrawDelegatorRewardEncodeObject", { enumerable: !0, get: function() {
    return R.isMsgWithdrawDelegatorRewardEncodeObject;
  } }), Object.defineProperty(e, "setupAuthExtension", { enumerable: !0, get: function() {
    return R.setupAuthExtension;
  } }), Object.defineProperty(e, "setupAuthzExtension", { enumerable: !0, get: function() {
    return R.setupAuthzExtension;
  } }), Object.defineProperty(e, "setupBankExtension", { enumerable: !0, get: function() {
    return R.setupBankExtension;
  } }), Object.defineProperty(e, "setupDistributionExtension", { enumerable: !0, get: function() {
    return R.setupDistributionExtension;
  } }), Object.defineProperty(e, "setupFeegrantExtension", { enumerable: !0, get: function() {
    return R.setupFeegrantExtension;
  } }), Object.defineProperty(e, "setupGovExtension", { enumerable: !0, get: function() {
    return R.setupGovExtension;
  } }), Object.defineProperty(e, "setupIbcExtension", { enumerable: !0, get: function() {
    return R.setupIbcExtension;
  } }), Object.defineProperty(e, "setupMintExtension", { enumerable: !0, get: function() {
    return R.setupMintExtension;
  } }), Object.defineProperty(e, "setupSlashingExtension", { enumerable: !0, get: function() {
    return R.setupSlashingExtension;
  } }), Object.defineProperty(e, "setupStakingExtension", { enumerable: !0, get: function() {
    return R.setupStakingExtension;
  } }), Object.defineProperty(e, "setupTxExtension", { enumerable: !0, get: function() {
    return R.setupTxExtension;
  } });
  var T = jt;
  Object.defineProperty(e, "makeMultisignedTx", { enumerable: !0, get: function() {
    return T.makeMultisignedTx;
  } }), Object.defineProperty(e, "makeMultisignedTxBytes", { enumerable: !0, get: function() {
    return T.makeMultisignedTxBytes;
  } });
  var V = Ve;
  Object.defineProperty(e, "createPagination", { enumerable: !0, get: function() {
    return V.createPagination;
  } }), Object.defineProperty(e, "createProtobufRpcClient", { enumerable: !0, get: function() {
    return V.createProtobufRpcClient;
  } }), Object.defineProperty(e, "decodeCosmosSdkDecFromProto", { enumerable: !0, get: function() {
    return V.decodeCosmosSdkDecFromProto;
  } }), Object.defineProperty(e, "QueryClient", { enumerable: !0, get: function() {
    return V.QueryClient;
  } });
  var D = Zc;
  Object.defineProperty(e, "createDefaultAminoConverters", { enumerable: !0, get: function() {
    return D.createDefaultAminoConverters;
  } }), Object.defineProperty(e, "defaultRegistryTypes", { enumerable: !0, get: function() {
    return D.defaultRegistryTypes;
  } }), Object.defineProperty(e, "SigningStargateClient", { enumerable: !0, get: function() {
    return D.SigningStargateClient;
  } });
  var B = Ne;
  Object.defineProperty(e, "assertIsDeliverTxFailure", { enumerable: !0, get: function() {
    return B.assertIsDeliverTxFailure;
  } }), Object.defineProperty(e, "assertIsDeliverTxSuccess", { enumerable: !0, get: function() {
    return B.assertIsDeliverTxSuccess;
  } }), Object.defineProperty(e, "BroadcastTxError", { enumerable: !0, get: function() {
    return B.BroadcastTxError;
  } }), Object.defineProperty(e, "isDeliverTxFailure", { enumerable: !0, get: function() {
    return B.isDeliverTxFailure;
  } }), Object.defineProperty(e, "isDeliverTxSuccess", { enumerable: !0, get: function() {
    return B.isDeliverTxSuccess;
  } }), Object.defineProperty(e, "StargateClient", { enumerable: !0, get: function() {
    return B.StargateClient;
  } }), Object.defineProperty(e, "TimeoutError", { enumerable: !0, get: function() {
    return B.TimeoutError;
  } });
  var U = tn;
  Object.defineProperty(e, "coin", { enumerable: !0, get: function() {
    return U.coin;
  } }), Object.defineProperty(e, "coins", { enumerable: !0, get: function() {
    return U.coins;
  } }), Object.defineProperty(e, "makeCosmoshubPath", { enumerable: !0, get: function() {
    return U.makeCosmoshubPath;
  } }), Object.defineProperty(e, "parseCoins", { enumerable: !0, get: function() {
    return U.parseCoins;
  } });
})(xd);
const KS = /* @__PURE__ */ Yu({
  __proto__: null
}, [xd]);
export {
  KS as i
};
