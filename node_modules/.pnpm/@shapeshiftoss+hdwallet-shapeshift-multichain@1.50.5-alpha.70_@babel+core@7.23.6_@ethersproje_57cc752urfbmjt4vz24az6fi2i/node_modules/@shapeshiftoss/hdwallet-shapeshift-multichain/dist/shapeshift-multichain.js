"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetaMaskShapeShiftMultiChainHDWallet = exports.MetaMaskShapeShiftMultiChainHDWalletInfo = exports.isMetaMask = void 0;
const core = __importStar(require("@shapeshiftoss/hdwallet-core"));
const eth_rpc_errors_1 = require("eth-rpc-errors");
const lodash_1 = __importDefault(require("lodash"));
const Btc = __importStar(require("./bitcoin"));
const BtcCash = __importStar(require("./bitcoincash"));
const Cosmos = __importStar(require("./cosmos"));
const Doge = __importStar(require("./dogecoin"));
const Eth = __importStar(require("./ethereum"));
const Litecoin = __importStar(require("./litecoin"));
const Thorchain = __importStar(require("./thorchain"));
const utxo = __importStar(require("./utxo"));
function isMetaMask(wallet) {
    return lodash_1.default.isObject(wallet) && wallet._isMetaMask;
}
exports.isMetaMask = isMetaMask;
class MetaMaskShapeShiftMultiChainHDWalletInfo {
    constructor() {
        this._supportsBTCInfo = true;
        this._supportsETHInfo = true;
        this._supportsCosmosInfo = true;
        this._supportsBinanceInfo = false;
        this._supportsRippleInfo = false;
        this._supportsEosInfo = false;
        this._supportsFioInfo = false;
        this._supportsThorchainInfo = true;
    }
    ethGetChainId() {
        throw new Error("Method not implemented.");
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ethSwitchChain(params) {
        throw new Error("Method not implemented.");
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ethAddChain(params) {
        throw new Error("Method not implemented.");
    }
    getVendor() {
        return "MetaMask";
    }
    hasOnDevicePinEntry() {
        return false;
    }
    hasOnDevicePassphrase() {
        return true;
    }
    hasOnDeviceDisplay() {
        return true;
    }
    hasOnDeviceRecovery() {
        return true;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    hasNativeShapeShift(srcCoin, dstCoin) {
        return false;
    }
    supportsBip44Accounts() {
        return false;
    }
    supportsOfflineSigning() {
        return false;
    }
    supportsBroadcast() {
        return true;
    }
    describePath(msg) {
        switch (msg.coin) {
            case "bitcoin":
            case "bitcoincash":
            case "dogecoin":
            case "litecoin": {
                const unknown = core.unknownUTXOPath(msg.path, msg.coin, msg.scriptType);
                if (!msg.scriptType)
                    return unknown;
                if (!utxo.utxoSupportsCoin(msg.coin))
                    return unknown;
                if (!utxo.utxoSupportsScriptType(msg.coin, msg.scriptType))
                    return unknown;
                return core.describeUTXOPath(msg.path, msg.coin, msg.scriptType);
            }
            case "atom":
                return core.cosmosDescribePath(msg.path);
            case "ethereum":
                return core.describeETHPath(msg.path);
            case "rune":
            case "trune":
            case "thorchain":
                return core.thorchainDescribePath(msg.path);
            default:
                throw new Error("Unsupported path");
        }
    }
    bitcoinSupportsNetwork(chainId = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            return chainId === 0;
        });
    }
    bitcoinSupportsSecureTransfer() {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    bitcoinSupportsNativeShapeShift() {
        return false;
    }
    bitcoinGetAccountPaths(msg) {
        return Btc.bitcoinGetAccountPaths(msg);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    bitcoinNextAccountPath(msg) {
        // TODO: What do we do here?
        return undefined;
    }
    bitcoinCashSupportsNetwork(chainId = 145) {
        return __awaiter(this, void 0, void 0, function* () {
            return chainId === 145;
        });
    }
    bitcoinCashSupportsSecureTransfer() {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    bitcoinCashSupportsNativeShapeShift() {
        return false;
    }
    bitcoinCashGetAccountPaths(msg) {
        return Btc.bitcoinGetAccountPaths(msg);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    bitcoinCashNextAccountPath(msg) {
        // TODO: What do we do here?
        return undefined;
    }
    cosmosSupportsNetwork(chainId = 118) {
        return __awaiter(this, void 0, void 0, function* () {
            return chainId === 118;
        });
    }
    cosmosSupportsSecureTransfer() {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    cosmosSupportsNativeShapeShift() {
        return false;
    }
    cosmosGetAccountPaths(msg) {
        return Cosmos.cosmosGetAccountPaths(msg);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    cosmosNextAccountPath(msg) {
        // TODO: What do we do here?
        return undefined;
    }
    dogecoinSupportsNetwork(chainId = 3) {
        return __awaiter(this, void 0, void 0, function* () {
            return chainId === 3;
        });
    }
    dogecoinSupportsSecureTransfer() {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    dogecoinSupportsNativeShapeShift() {
        return false;
    }
    dogecoinGetAccountPaths(msg) {
        return Doge.dogecoinGetAccountPaths(msg);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    dogecoinNextAccountPath(msg) {
        // TODO: What do we do here?
        return undefined;
    }
    ethSupportsNetwork(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            return chainId === 1;
        });
    }
    ethSupportsSecureTransfer() {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    ethSupportsNativeShapeShift() {
        return false;
    }
    ethGetAccountPaths(msg) {
        return Eth.ethGetAccountPaths(msg);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ethNextAccountPath(msg) {
        // TODO: What do we do here?
        return undefined;
    }
    ethSupportsEIP1559() {
        return __awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    litecoinSupportsNetwork(chainId = 2) {
        return __awaiter(this, void 0, void 0, function* () {
            return chainId === 2;
        });
    }
    litecoinSupportsSecureTransfer() {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    litecoinSupportsNativeShapeShift() {
        return false;
    }
    litecoinGetAccountPaths(msg) {
        return Litecoin.litecoinGetAccountPaths(msg);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    litecoinNextAccountPath(msg) {
        // TODO: What do we do here?
        return undefined;
    }
    thorchainSupportsNetwork(chainId = 931) {
        return __awaiter(this, void 0, void 0, function* () {
            return chainId === 931;
        });
    }
    thorchainSupportsSecureTransfer() {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    thorchainSupportsNativeShapeShift() {
        return false;
    }
    thorchainGetAccountPaths(msg) {
        return Thorchain.thorchainGetAccountPaths(msg);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    thorchainNextAccountPath(msg) {
        // TODO: What do we do here?
        return undefined;
    }
}
exports.MetaMaskShapeShiftMultiChainHDWalletInfo = MetaMaskShapeShiftMultiChainHDWalletInfo;
class MetaMaskShapeShiftMultiChainHDWallet {
    constructor(provider) {
        this._supportsETH = true;
        this._supportsETHInfo = true;
        this._supportsBTCInfo = true;
        this._supportsBTC = true;
        this._supportsCosmosInfo = true;
        this._supportsCosmos = true;
        this._supportsEthSwitchChain = true;
        this._supportsAvalanche = true;
        this._supportsOptimism = true;
        this._supportsBSC = true;
        this._supportsPolygon = true;
        this._supportsGnosis = true;
        this._supportsOsmosisInfo = true;
        this._supportsOsmosis = true;
        this._supportsBinanceInfo = false;
        this._supportsBinance = false;
        this._supportsDebugLink = false;
        this._isPortis = false;
        this._isMetaMask = true;
        this._supportsRippleInfo = false;
        this._supportsRipple = false;
        this._supportsEosInfo = false;
        this._supportsEos = false;
        this._supportsFioInfo = false;
        this._supportsFio = false;
        this._supportsThorchainInfo = true;
        this._supportsThorchain = true;
        this.publicKeysCache = new Map();
        this.addressCache = new Map();
        this.info = new MetaMaskShapeShiftMultiChainHDWalletInfo();
        this.provider = provider;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ethSignTypedData(msg) {
        throw new Error("Method not implemented.");
    }
    getFeatures() {
        return __awaiter(this, void 0, void 0, function* () {
            return {};
        });
    }
    isLocked() {
        return __awaiter(this, void 0, void 0, function* () {
            return !this.provider._metamask.isUnlocked();
        });
    }
    getVendor() {
        return "MetaMask";
    }
    getModel() {
        return __awaiter(this, void 0, void 0, function* () {
            return "MetaMask";
        });
    }
    getLabel() {
        return __awaiter(this, void 0, void 0, function* () {
            return "MetaMask";
        });
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            // nothing to initialize
        });
    }
    hasOnDevicePinEntry() {
        return this.info.hasOnDevicePinEntry();
    }
    hasOnDevicePassphrase() {
        return this.info.hasOnDevicePassphrase();
    }
    hasOnDeviceDisplay() {
        return this.info.hasOnDeviceDisplay();
    }
    hasOnDeviceRecovery() {
        return this.info.hasOnDeviceRecovery();
    }
    hasNativeShapeShift(srcCoin, dstCoin) {
        return this.info.hasNativeShapeShift(srcCoin, dstCoin);
    }
    supportsBip44Accounts() {
        return this.info.supportsBip44Accounts();
    }
    supportsOfflineSigning() {
        return false;
    }
    supportsBroadcast() {
        return true;
    }
    clearSession() {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Can we lock MetaMask from here?
        });
    }
    ping(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            // no ping function for MetaMask, so just returning Core.Pong
            return { msg: msg.msg };
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sendPin(pin) {
        return __awaiter(this, void 0, void 0, function* () {
            // no concept of pin in MetaMask
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sendPassphrase(passphrase) {
        return __awaiter(this, void 0, void 0, function* () {
            // cannot send passphrase to MetaMask. Could show the widget?
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sendCharacter(charater) {
        return __awaiter(this, void 0, void 0, function* () {
            // no concept of sendCharacter in MetaMask
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sendWord(word) {
        return __awaiter(this, void 0, void 0, function* () {
            // no concept of sendWord in MetaMask
        });
    }
    cancel() {
        return __awaiter(this, void 0, void 0, function* () {
            // no concept of cancel in MetaMask
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    wipe() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
    reset(msg) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    recover(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            // no concept of recover in MetaMask
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    loadDevice(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Does MetaMask allow this to be done programatically?
        });
    }
    describePath(msg) {
        return this.info.describePath(msg);
    }
    getPublicKeys(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = JSON.stringify(msg);
            const maybeCachedPublicKeys = this.publicKeysCache.get(key);
            if (maybeCachedPublicKeys) {
                return maybeCachedPublicKeys;
            }
            const pubKeys = yield Promise.all(msg.map((getPublicKey) => __awaiter(this, void 0, void 0, function* () {
                switch (getPublicKey.coin) {
                    case "Bitcoin":
                        return Btc.bitcoinGetPublicKeys(getPublicKey);
                    case "Litecoin":
                        return Litecoin.litecoinGetPublicKeys(getPublicKey);
                    case "Dogecoin":
                        return Doge.dogecoinGetPublicKeys(getPublicKey);
                    case "BitcoinCash":
                        return BtcCash.bitcoinCashGetPublicKeys(getPublicKey);
                    default:
                        return null;
                }
            })));
            const flattened = pubKeys.flat();
            const filtered = flattened.filter((x) => x !== null);
            // Cache the result
            this.publicKeysCache.set(key, filtered);
            return filtered;
        });
    }
    isInitialized() {
        return __awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    /** INSERT NEW CODE HERE */
    /** BITCOIN */
    btcSupportsSecureTransfer() {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    btcSupportsNativeShapeShift() {
        return false;
    }
    btcGetAccountPaths(msg) {
        return Btc.bitcoinGetAccountPaths(msg);
    }
    btcNextAccountPath(msg) {
        return this.info.bitcoinNextAccountPath(msg);
    }
    btcGetAddress(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = JSON.stringify(msg);
            const maybeCachedAddress = this.addressCache.get(key);
            if (maybeCachedAddress)
                return maybeCachedAddress;
            const value = yield (() => __awaiter(this, void 0, void 0, function* () {
                switch (msg.coin) {
                    case "Bitcoin":
                        return Btc.bitcoinGetAddress(msg);
                    case "Litecoin":
                        return Litecoin.litecoinGetAddress(msg);
                    case "Dogecoin":
                        return Doge.dogecoinGetAddress(msg);
                    case "BitcoinCash":
                        return BtcCash.bitcoinCashGetAddress(msg);
                    default:
                        return null;
                }
            }))();
            if (!value || typeof value !== "string")
                return null;
            this.addressCache.set(key, value);
            return value;
        });
    }
    btcSignTx(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const { coin } = msg;
            switch (coin) {
                case "Bitcoin":
                    return Btc.bitcoinSignTx(msg);
                case "Litecoin":
                    return Litecoin.litecoinSignTx(msg);
                case "Dogecoin":
                    return Doge.dogecoinSignTx(msg);
                case "BitcoinCash":
                    return BtcCash.bitcoinCashSignTx(msg);
                default:
                    return null;
            }
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    btcSignMessage(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("Method not implemented.");
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    btcVerifyMessage(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("Method not implemented.");
        });
    }
    btcSupportsScriptType(coin, scriptType) {
        return __awaiter(this, void 0, void 0, function* () {
            return utxo.utxoSupportsScriptType(coin, scriptType);
        });
    }
    btcSupportsCoin(coin) {
        return __awaiter(this, void 0, void 0, function* () {
            return utxo.utxoSupportsCoin(coin);
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    btcIsSameAccount(msg) {
        throw new Error("Method not implemented.");
    }
    /** BITCOIN CASH */
    bitcoinCashSupportsSecureTransfer() {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    bitcoinCashSupportsNativeShapeShift() {
        return false;
    }
    bitcoinCashGetAccountPaths(msg) {
        return BtcCash.bitcoinCashGetAccountPaths(msg);
    }
    bitcoinCashNextAccountPath(msg) {
        return this.info.bitcoinCashNextAccountPath(msg);
    }
    bitcoinCashGetAddress(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.bitcoinCashAddress) {
                return this.bitcoinCashAddress;
            }
            const address = yield BtcCash.bitcoinCashGetAddress(msg);
            if (address && typeof address === "string") {
                this.bitcoinCashAddress = address;
                return address;
            }
            else {
                this.bitcoinCashAddress = null;
                return null;
            }
        });
    }
    bitcoinCashSignTx(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.bitcoinCashGetAddress(this.provider);
            return address ? Btc.bitcoinSignTx(msg) : null;
        });
    }
    /** COSMOS */
    cosmosSupportsSecureTransfer() {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    cosmosSupportsNativeShapeShift() {
        return false;
    }
    cosmosGetAccountPaths(msg) {
        return Cosmos.cosmosGetAccountPaths(msg);
    }
    cosmosNextAccountPath(msg) {
        return this.info.cosmosNextAccountPath(msg);
    }
    cosmosGetAddress(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.cosmosAddress) {
                return this.cosmosAddress;
            }
            const address = yield Cosmos.cosmosGetAddress(msg);
            if (address && typeof address === "string") {
                this.cosmosAddress = address;
                return address;
            }
            else {
                this.cosmosAddress = null;
                return null;
            }
        });
    }
    cosmosSignTx(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.cosmosGetAddress(this.provider);
            return address ? Cosmos.cosmosSignTx(msg) : null;
        });
    }
    /** DOGECOIN */
    dogecoinSupportsSecureTransfer() {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    dogecoinSupportsNativeShapeShift() {
        return false;
    }
    dogecoinGetAccountPaths(msg) {
        return Doge.dogecoinGetAccountPaths(msg);
    }
    dogecoinNextAccountPath(msg) {
        return this.info.dogecoinNextAccountPath(msg);
    }
    dogecoinGetAddress(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.dogecoinAddress) {
                return this.dogecoinAddress;
            }
            const address = yield Doge.dogecoinGetAddress(msg);
            if (address && typeof address === "string") {
                this.dogecoinAddress = address;
                return address;
            }
            else {
                this.dogecoinAddress = null;
                return null;
            }
        });
    }
    dogecoinSignTx(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.dogecoinGetAddress(this.provider);
            return address ? Doge.dogecoinSignTx(msg) : null;
        });
    }
    /** ETHEREUM */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    ethSupportsNetwork(chainId = 1) {
        return __awaiter(this, void 0, void 0, function* () {
            return chainId === 1;
        });
    }
    ethGetChainId() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // chainId as hex string
                const chainId = yield this.provider.request({ method: "eth_chainId" });
                return parseInt(chainId, 16);
            }
            catch (e) {
                console.error(e);
                return null;
            }
        });
    }
    ethAddChain(params) {
        return __awaiter(this, void 0, void 0, function* () {
            // at this point, we know that we're in the context of a valid MetaMask provider
            yield this.provider.request({ method: "wallet_addEthereumChain", params: [params] });
        });
    }
    ethSwitchChain(params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // at this point, we know that we're in the context of a valid MetaMask provider
                yield this.provider.request({ method: "wallet_switchEthereumChain", params: [{ chainId: params.chainId }] });
            }
            catch (e) {
                const error = (0, eth_rpc_errors_1.serializeError)(e);
                // https://docs.metamask.io/guide/ethereum-provider.html#errors
                // Internal error, which in the case of wallet_switchEthereumChain call means the chain isn't currently added to the wallet
                if (error.code === -32603) {
                    // We only support Avalanche C-Chain currently. It is supported natively in XDEFI, and unsupported in Tally, both with no capabilities to add a new chain
                    // TODO(gomes): Find a better home for these. When that's done, we'll want to call ethSwitchChain with (params: AddEthereumChainParameter) instead
                    try {
                        yield this.ethAddChain(params);
                        return;
                    }
                    catch (addChainE) {
                        const addChainError = (0, eth_rpc_errors_1.serializeError)(addChainE);
                        if (addChainError.code === 4001) {
                            throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest();
                        }
                        throw addChainError.data.originalError;
                    }
                }
                if (error.code === 4001) {
                    throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest();
                }
                throw error.data.originalError;
            }
        });
    }
    ethSupportsSecureTransfer() {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    ethSupportsNativeShapeShift() {
        return false;
    }
    ethSupportsEIP1559() {
        return __awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    ethGetAccountPaths(msg) {
        return Eth.ethGetAccountPaths(msg);
    }
    ethNextAccountPath(msg) {
        return this.info.ethNextAccountPath(msg);
    }
    // TODO: Respect msg.addressNList!
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ethGetAddress(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.ethAddress) {
                return this.ethAddress;
            }
            const address = yield Eth.ethGetAddress(this.provider);
            if (address) {
                this.ethAddress = address;
                return address;
            }
            else {
                this.ethAddress = null;
                return null;
            }
        });
    }
    ethSignTx(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.ethGetAddress(this.provider);
            return address ? Eth.ethSignTx(msg, this.provider, address) : null;
        });
    }
    ethSendTx(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const txid = yield this.ethGetAddress(this.provider);
            return txid ? Eth.ethSendTx(msg, this.provider, txid) : null;
        });
    }
    ethSignMessage(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const signedMessage = yield this.ethGetAddress(this.provider);
            return signedMessage ? Eth.ethSignMessage(msg, this.provider, signedMessage) : null;
        });
    }
    ethVerifyMessage(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return Eth.ethVerifyMessage(msg, this.provider);
        });
    }
    /** LITECOIN */
    litecoinSupportsSecureTransfer() {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    litecoinSupportsNativeShapeShift() {
        return false;
    }
    litecoinGetAccountPaths(msg) {
        return Litecoin.litecoinGetAccountPaths(msg);
    }
    litecoinNextAccountPath(msg) {
        return this.info.litecoinNextAccountPath(msg);
    }
    litecoinGetAddress(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.litecoinAddress) {
                return this.litecoinAddress;
            }
            const address = yield Litecoin.litecoinGetAddress(msg);
            if (address && typeof address === "string") {
                this.litecoinAddress = address;
                return address;
            }
            else {
                this.litecoinAddress = null;
                return null;
            }
        });
    }
    litecoinSignTx(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.litecoinGetAddress(this.provider);
            return address ? Litecoin.litecoinSignTx(msg) : null;
        });
    }
    /** THORCHAIN */
    thorchainSupportsSecureTransfer() {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    thorchainSupportsNativeShapeShift() {
        return false;
    }
    thorchainGetAccountPaths(msg) {
        return Thorchain.thorchainGetAccountPaths(msg);
    }
    thorchainNextAccountPath(msg) {
        return this.info.thorchainNextAccountPath(msg);
    }
    thorchainGetAddress(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.thorchainAddress) {
                return this.thorchainAddress;
            }
            const address = yield Thorchain.thorchainGetAddress(msg);
            if (address && typeof address === "string") {
                this.thorchainAddress = address;
                return address;
            }
            else {
                this.thorchainAddress = null;
                return null;
            }
        });
    }
    thorchainSignTx(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = yield this.thorchainGetAddress(this.provider);
            return address ? Thorchain.thorchainSignTx(msg) : null;
        });
    }
    getDeviceID() {
        return __awaiter(this, void 0, void 0, function* () {
            return "metaMask:" + (yield this.ethGetAddress(this.provider));
        });
    }
    getFirmwareVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            return "metaMask";
        });
    }
}
exports.MetaMaskShapeShiftMultiChainHDWallet = MetaMaskShapeShiftMultiChainHDWallet;
//# sourceMappingURL=shapeshift-multichain.js.map