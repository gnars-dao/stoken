"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.utxoGetAccountPaths = exports.describeUTXOPath = exports.utxoSupportsScriptType = exports.utxoSupportsCoin = void 0;
const core = __importStar(require("@shapeshiftoss/hdwallet-core"));
const supportedCoins = ["Bitcoin", "BitcoinCash", "Litecoin", "Dogecoin"];
function legacyAccount(coin, slip44, accountIdx) {
    return {
        coin,
        scriptType: core.BTCInputScriptType.SpendAddress,
        addressNList: [0x80000000 + 44, 0x80000000 + slip44, 0x80000000 + accountIdx],
    };
}
function segwitAccount(coin, slip44, accountIdx) {
    return {
        coin,
        scriptType: core.BTCInputScriptType.SpendP2SHWitness,
        addressNList: [0x80000000 + 49, 0x80000000 + slip44, 0x80000000 + accountIdx],
    };
}
function segwitNativeAccount(coin, slip44, accountIdx) {
    return {
        coin,
        scriptType: core.BTCInputScriptType.SpendWitness,
        addressNList: [0x80000000 + 84, 0x80000000 + slip44, 0x80000000 + accountIdx],
    };
}
function utxoSupportsCoin(coin) {
    // FIXME: inspect the CoinTable to determine which coins are actually supported by the device.
    return supportedCoins.includes(coin);
}
exports.utxoSupportsCoin = utxoSupportsCoin;
function utxoSupportsScriptType(coin, scriptType) {
    if (!utxoSupportsCoin(coin))
        return false;
    switch (scriptType) {
        case core.BTCInputScriptType.SpendMultisig:
        case core.BTCInputScriptType.SpendAddress:
        case core.BTCInputScriptType.SpendWitness:
        case core.BTCInputScriptType.Bech32:
        case core.BTCInputScriptType.SpendP2SHWitness:
            return true;
        default:
            return false;
    }
}
exports.utxoSupportsScriptType = utxoSupportsScriptType;
function describeUTXOPath(path, coin, scriptType) {
    var _a;
    const pathStr = core.addressNListToBIP32(path);
    const unknown = {
        verbose: pathStr,
        coin,
        scriptType,
        isKnown: false,
    };
    if (!scriptType)
        return unknown;
    if (!utxoSupportsCoin(coin))
        return unknown;
    if (!utxoSupportsScriptType(coin, scriptType))
        return unknown;
    if (path.length !== 3 && path.length !== 5)
        return unknown;
    if ((path[0] & 0x80000000) >>> 0 !== 0x80000000)
        return unknown;
    const purpose = path[0] & 0x7fffffff;
    if (![44, 49, 84].includes(purpose))
        return unknown;
    if (purpose === 44 && scriptType !== core.BTCInputScriptType.SpendAddress)
        return unknown;
    if (purpose === 49 && scriptType !== core.BTCInputScriptType.SpendP2SHWitness)
        return unknown;
    if (purpose === 84 && scriptType !== core.BTCInputScriptType.SpendWitness)
        return unknown;
    const wholeAccount = path.length === 3;
    const script = scriptType
        ? (_a = {
            [core.BTCInputScriptType.SpendAddress]: ["Legacy"],
            [core.BTCInputScriptType.SpendP2SHWitness]: [],
            [core.BTCInputScriptType.SpendWitness]: ["Segwit Native"],
        }[scriptType]) !== null && _a !== void 0 ? _a : []
        : [];
    let isPrefork = false;
    const slip44 = core.slip44ByCoin(coin);
    if (slip44 === undefined)
        return unknown;
    if (path[1] !== 0x80000000 + slip44) {
        switch (coin) {
            case "BitcoinCash":
            case "BitcoinGold": {
                if (path[1] === 0x80000000 + core.slip44ByCoin("Bitcoin")) {
                    isPrefork = true;
                    break;
                }
                return unknown;
            }
            case "BitcoinSV": {
                if (path[1] === 0x80000000 + core.slip44ByCoin("Bitcoin") ||
                    path[1] === 0x80000000 + core.slip44ByCoin("BitcoinCash")) {
                    isPrefork = true;
                    break;
                }
                return unknown;
            }
            default:
                return unknown;
        }
    }
    let attributes = isPrefork ? ["Prefork"] : [];
    switch (coin) {
        case "Bitcoin":
        case "Litecoin":
        case "BitcoinGold":
        case "Testnet": {
            attributes = attributes.concat(script);
            break;
        }
        default:
            break;
    }
    const attr = attributes.length ? ` (${attributes.join(", ")})` : "";
    const accountIdx = path[2] & 0x7fffffff;
    if (wholeAccount) {
        return {
            coin,
            verbose: `${coin} Account #${accountIdx}${attr}`,
            accountIdx,
            wholeAccount: true,
            isKnown: true,
            scriptType,
            isPrefork,
        };
    }
    else {
        const change = path[3] === 1 ? "Change " : "";
        const addressIdx = path[4];
        return {
            coin,
            verbose: `${coin} Account #${accountIdx}, ${change}Address #${addressIdx}${attr}`,
            accountIdx,
            addressIdx,
            wholeAccount: false,
            isKnown: true,
            isChange: path[3] === 1,
            scriptType,
            isPrefork,
        };
    }
}
exports.describeUTXOPath = describeUTXOPath;
function utxoGetAccountPaths(msg) {
    var _a;
    const slip44 = core.slip44ByCoin(msg.coin);
    if (slip44 === undefined)
        return [];
    const bip44 = legacyAccount(msg.coin, slip44, msg.accountIdx);
    const bip49 = segwitAccount(msg.coin, slip44, msg.accountIdx);
    const bip84 = segwitNativeAccount(msg.coin, slip44, msg.accountIdx);
    // For BTC Forks
    const btcLegacy = legacyAccount(msg.coin, core.slip44ByCoin("Bitcoin"), msg.accountIdx);
    const btcSegwit = segwitAccount(msg.coin, core.slip44ByCoin("Bitcoin"), msg.accountIdx);
    const btcSegwitNative = segwitNativeAccount(msg.coin, core.slip44ByCoin("Bitcoin"), msg.accountIdx);
    // For BCH Forks
    const bchLegacy = legacyAccount(msg.coin, core.slip44ByCoin("BitcoinCash"), msg.accountIdx);
    let paths = (_a = {
        Bitcoin: [bip44, bip49, bip84],
        Litecoin: [bip44, bip49, bip84],
        Dash: [bip44],
        DigiByte: [bip44, bip49, bip84],
        Dogecoin: [bip44],
        Testnet: [bip44, bip49, bip84],
        BitcoinCash: [bip44, btcLegacy],
        BitcoinSV: [bip44, bchLegacy, btcLegacy],
        BitcoinGold: [bip44, bip49, bip84, btcLegacy, btcSegwit, btcSegwitNative],
    }[msg.coin]) !== null && _a !== void 0 ? _a : [];
    if (msg.scriptType !== undefined)
        paths = paths.filter((path) => {
            return path.scriptType === msg.scriptType;
        });
    return paths;
}
exports.utxoGetAccountPaths = utxoGetAccountPaths;
//# sourceMappingURL=utxo.js.map