"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ApprovalController_instances, _ApprovalController_approvals, _ApprovalController_origins, _ApprovalController_showApprovalRequest, _ApprovalController_typesExcludedFromRateLimiting, _ApprovalController_add, _ApprovalController_validateAddParams, _ApprovalController_addPendingApprovalOrigin, _ApprovalController_addToStore, _ApprovalController_delete, _ApprovalController_deleteApprovalAndGetCallbacks, _ApprovalController_result;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApprovalController = exports.APPROVAL_TYPE_RESULT_SUCCESS = exports.APPROVAL_TYPE_RESULT_ERROR = exports.ORIGIN_METAMASK = void 0;
const base_controller_1 = require("@metamask/base-controller");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const nanoid_1 = require("nanoid");
const errors_1 = require("./errors");
// Constants
// Avoiding dependency on controller-utils
exports.ORIGIN_METAMASK = 'metamask';
exports.APPROVAL_TYPE_RESULT_ERROR = 'result_error';
exports.APPROVAL_TYPE_RESULT_SUCCESS = 'result_success';
const controllerName = 'ApprovalController';
const stateMetadata = {
    pendingApprovals: { persist: false, anonymous: true },
    pendingApprovalCount: { persist: false, anonymous: false },
    approvalFlows: { persist: false, anonymous: false },
};
const getAlreadyPendingMessage = (origin, type) => `Request of type '${type}' already pending for origin ${origin}. Please wait.`;
const getDefaultState = () => {
    return {
        pendingApprovals: {},
        pendingApprovalCount: 0,
        approvalFlows: [],
    };
};
/**
 * Controller for managing requests that require user approval.
 *
 * Enables limiting the number of pending requests by origin and type, counting
 * pending requests, and more.
 *
 * Adding a request returns a promise that resolves or rejects when the request
 * is approved or denied, respectively.
 */
class ApprovalController extends base_controller_1.BaseControllerV2 {
    /**
     * Construct an Approval controller.
     *
     * @param options - The controller options.
     * @param options.showApprovalRequest - Function for opening the UI such that
     * the request can be displayed to the user.
     * @param options.messenger - The restricted controller messenger for the Approval controller.
     * @param options.state - The initial controller state.
     * @param options.typesExcludedFromRateLimiting - Array of aproval types which allow multiple pending approval requests from the same origin.
     */
    constructor({ messenger, showApprovalRequest, state = {}, typesExcludedFromRateLimiting = [], }) {
        super({
            name: controllerName,
            metadata: stateMetadata,
            messenger,
            state: Object.assign(Object.assign({}, getDefaultState()), state),
        });
        _ApprovalController_instances.add(this);
        _ApprovalController_approvals.set(this, void 0);
        _ApprovalController_origins.set(this, void 0);
        _ApprovalController_showApprovalRequest.set(this, void 0);
        _ApprovalController_typesExcludedFromRateLimiting.set(this, void 0);
        __classPrivateFieldSet(this, _ApprovalController_approvals, new Map(), "f");
        __classPrivateFieldSet(this, _ApprovalController_origins, new Map(), "f");
        __classPrivateFieldSet(this, _ApprovalController_showApprovalRequest, showApprovalRequest, "f");
        __classPrivateFieldSet(this, _ApprovalController_typesExcludedFromRateLimiting, typesExcludedFromRateLimiting, "f");
        this.registerMessageHandlers();
    }
    /**
     * Constructor helper for registering this controller's messaging system
     * actions.
     */
    registerMessageHandlers() {
        this.messagingSystem.registerActionHandler(`${controllerName}:clearRequests`, this.clear.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:addRequest`, (opts, shouldShowRequest) => {
            if (shouldShowRequest) {
                return this.addAndShowApprovalRequest(opts);
            }
            return this.add(opts);
        });
        this.messagingSystem.registerActionHandler(`${controllerName}:hasRequest`, this.has.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:acceptRequest`, this.accept.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:rejectRequest`, this.reject.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:updateRequestState`, this.updateRequestState.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:startFlow`, this.startFlow.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:endFlow`, this.endFlow.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:setFlowLoadingText`, this.setFlowLoadingText.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:showSuccess`, this.success.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:showError`, this.error.bind(this));
    }
    addAndShowApprovalRequest(opts) {
        const promise = __classPrivateFieldGet(this, _ApprovalController_instances, "m", _ApprovalController_add).call(this, opts.origin, opts.type, opts.id, opts.requestData, opts.requestState, opts.expectsResult);
        __classPrivateFieldGet(this, _ApprovalController_showApprovalRequest, "f").call(this);
        return promise;
    }
    add(opts) {
        return __classPrivateFieldGet(this, _ApprovalController_instances, "m", _ApprovalController_add).call(this, opts.origin, opts.type, opts.id, opts.requestData, opts.requestState, opts.expectsResult);
    }
    /**
     * Gets the info for the approval request with the given id.
     *
     * @param id - The id of the approval request.
     * @returns The approval request data associated with the id.
     */
    get(id) {
        return this.state.pendingApprovals[id];
    }
    /**
     * Gets the number of pending approvals, by origin and/or type.
     *
     * If only `origin` is specified, all approvals for that origin will be
     * counted, regardless of type.
     * If only `type` is specified, all approvals for that type will be counted,
     * regardless of origin.
     * If both `origin` and `type` are specified, 0 or 1 will be returned.
     *
     * @param opts - The approval count options.
     * @param opts.origin - An approval origin.
     * @param opts.type - The type of the approval request.
     * @returns The current approval request count for the given origin and/or
     * type.
     */
    getApprovalCount(opts = {}) {
        var _a;
        if (!opts.origin && !opts.type) {
            throw new Error('Must specify origin, type, or both.');
        }
        const { origin, type: _type } = opts;
        if (origin && _type) {
            return ((_a = __classPrivateFieldGet(this, _ApprovalController_origins, "f").get(origin)) === null || _a === void 0 ? void 0 : _a.get(_type)) || 0;
        }
        if (origin) {
            return Array.from((__classPrivateFieldGet(this, _ApprovalController_origins, "f").get(origin) || new Map()).values()).reduce((total, value) => total + value, 0);
        }
        // Only "type" was specified
        let count = 0;
        for (const approval of Object.values(this.state.pendingApprovals)) {
            if (approval.type === _type) {
                count += 1;
            }
        }
        return count;
    }
    /**
     * Get the total count of all pending approval requests for all origins.
     *
     * @returns The total pending approval request count.
     */
    getTotalApprovalCount() {
        return this.state.pendingApprovalCount;
    }
    /**
     * Checks if there's a pending approval request per the given parameters.
     * At least one parameter must be specified. An error will be thrown if the
     * parameters are invalid.
     *
     * If `id` is specified, all other parameters will be ignored.
     * If `id` is not specified, the method will check for requests that match
     * all of the specified parameters.
     *
     * @param opts - Options bag.
     * @param opts.id - The ID to check for.
     * @param opts.origin - The origin to check for.
     * @param opts.type - The type to check for.
     * @returns `true` if a matching approval is found, and `false` otherwise.
     */
    has(opts = {}) {
        var _a;
        const { id, origin, type: _type } = opts;
        if (id) {
            if (typeof id !== 'string') {
                throw new Error('May not specify non-string id.');
            }
            return __classPrivateFieldGet(this, _ApprovalController_approvals, "f").has(id);
        }
        if (_type && typeof _type !== 'string') {
            throw new Error('May not specify non-string type.');
        }
        if (origin) {
            if (typeof origin !== 'string') {
                throw new Error('May not specify non-string origin.');
            }
            // Check origin and type pair if type also specified
            if (_type) {
                return Boolean((_a = __classPrivateFieldGet(this, _ApprovalController_origins, "f").get(origin)) === null || _a === void 0 ? void 0 : _a.get(_type));
            }
            return __classPrivateFieldGet(this, _ApprovalController_origins, "f").has(origin);
        }
        if (_type) {
            for (const approval of Object.values(this.state.pendingApprovals)) {
                if (approval.type === _type) {
                    return true;
                }
            }
            return false;
        }
        throw new Error('Must specify a valid combination of id, origin, and type.');
    }
    /**
     * Resolves the promise of the approval with the given id, and deletes the
     * approval. Throws an error if no such approval exists.
     *
     * @param id - The id of the approval request.
     * @param value - The value to resolve the approval promise with.
     * @param options - Options bag.
     * @returns A promise that either resolves once a result is provided by
     * the creator of the approval request, or immediately if `options.waitForResult`
     * is `false` or `undefined`.
     */
    accept(id, value, options) {
        // Safe to cast as the delete method below will throw if the ID is not found
        const approval = this.get(id);
        const requestPromise = __classPrivateFieldGet(this, _ApprovalController_instances, "m", _ApprovalController_deleteApprovalAndGetCallbacks).call(this, id);
        return new Promise((resolve, reject) => {
            const resultCallbacks = {
                success: (acceptValue) => resolve({ value: acceptValue }),
                error: reject,
            };
            if ((options === null || options === void 0 ? void 0 : options.waitForResult) && !approval.expectsResult) {
                reject(new errors_1.ApprovalRequestNoResultSupportError(id));
                return;
            }
            const resultValue = (options === null || options === void 0 ? void 0 : options.waitForResult) ? resultCallbacks : undefined;
            const resolveValue = approval.expectsResult
                ? { value, resultCallbacks: resultValue }
                : value;
            requestPromise.resolve(resolveValue);
            if (!(options === null || options === void 0 ? void 0 : options.waitForResult)) {
                resolve({ value: undefined });
            }
        });
    }
    /**
     * Rejects the promise of the approval with the given id, and deletes the
     * approval. Throws an error if no such approval exists.
     *
     * @param id - The id of the approval request.
     * @param error - The error to reject the approval promise with.
     */
    reject(id, error) {
        __classPrivateFieldGet(this, _ApprovalController_instances, "m", _ApprovalController_deleteApprovalAndGetCallbacks).call(this, id).reject(error);
    }
    /**
     * Rejects and deletes all approval requests.
     *
     * @param rejectionError - The EthereumRpcError to reject the approval
     * requests with.
     */
    clear(rejectionError) {
        for (const id of __classPrivateFieldGet(this, _ApprovalController_approvals, "f").keys()) {
            this.reject(id, rejectionError);
        }
        __classPrivateFieldGet(this, _ApprovalController_origins, "f").clear();
        this.update((draftState) => {
            draftState.pendingApprovals = {};
            draftState.pendingApprovalCount = 0;
        });
    }
    /**
     * Updates the request state of the approval with the given id.
     *
     * @param opts - Options bag.
     * @param opts.id - The id of the approval request.
     * @param opts.requestState - Additional data associated with the request
     */
    updateRequestState(opts) {
        if (!this.state.pendingApprovals[opts.id]) {
            throw new errors_1.ApprovalRequestNotFoundError(opts.id);
        }
        this.update((draftState) => {
            // Typecast: ts(2589)
            draftState.pendingApprovals[opts.id].requestState =
                opts.requestState;
        });
    }
    /**
     * Starts a new approval flow.
     *
     * @param opts - Options bag.
     * @param opts.id - The id of the approval flow.
     * @param opts.loadingText - The loading text that will be associated to the approval flow.
     * @returns The object containing the approval flow id.
     */
    startFlow(opts = {}) {
        var _a, _b;
        const id = (_a = opts.id) !== null && _a !== void 0 ? _a : (0, nanoid_1.nanoid)();
        const loadingText = (_b = opts.loadingText) !== null && _b !== void 0 ? _b : null;
        this.update((draftState) => {
            draftState.approvalFlows.push({ id, loadingText });
        });
        __classPrivateFieldGet(this, _ApprovalController_showApprovalRequest, "f").call(this);
        return { id, loadingText };
    }
    /**
     * Ends the current approval flow.
     *
     * @param opts - Options bag.
     * @param opts.id - The id of the approval flow that will be finished.
     */
    endFlow({ id }) {
        if (!this.state.approvalFlows.length) {
            throw new errors_1.NoApprovalFlowsError();
        }
        const currentFlow = this.state.approvalFlows.slice(-1)[0];
        if (id !== currentFlow.id) {
            throw new errors_1.EndInvalidFlowError(id, this.state.approvalFlows.map((flow) => flow.id));
        }
        this.update((draftState) => {
            draftState.approvalFlows.pop();
        });
    }
    /**
     * Sets the loading text for the approval flow.
     *
     * @param opts - Options bag.
     * @param opts.id - The approval flow loading text that will be displayed.
     * @param opts.loadingText - The loading text that will be associated to the approval flow.
     */
    setFlowLoadingText({ id, loadingText }) {
        const flowIndex = this.state.approvalFlows.findIndex((flow) => flow.id === id);
        if (flowIndex === -1) {
            throw new errors_1.MissingApprovalFlowError(id);
        }
        this.update((draftState) => {
            draftState.approvalFlows[flowIndex].loadingText = loadingText;
        });
    }
    /**
     * Show a success page.
     *
     * @param opts - Options bag.
     * @param opts.message - The message text or components to display in the page.
     * @param opts.header - The text or components to display in the header of the page.
     * @param opts.flowToEnd - The ID of the approval flow to end once the success page is approved.
     * @returns Empty object to support future additions.
     */
    success(opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            yield __classPrivateFieldGet(this, _ApprovalController_instances, "m", _ApprovalController_result).call(this, exports.APPROVAL_TYPE_RESULT_SUCCESS, opts, {
                message: opts.message,
                header: opts.header,
            });
            return {};
        });
    }
    /**
     * Show an error page.
     *
     * @param opts - Options bag.
     * @param opts.message - The message text or components to display in the page.
     * @param opts.header - The text or components to display in the header of the page.
     * @param opts.flowToEnd - The ID of the approval flow to end once the error page is approved.
     * @returns Empty object to support future additions.
     */
    error(opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            yield __classPrivateFieldGet(this, _ApprovalController_instances, "m", _ApprovalController_result).call(this, exports.APPROVAL_TYPE_RESULT_ERROR, opts, {
                error: opts.error,
                header: opts.header,
            });
            return {};
        });
    }
}
exports.ApprovalController = ApprovalController;
_ApprovalController_approvals = new WeakMap(), _ApprovalController_origins = new WeakMap(), _ApprovalController_showApprovalRequest = new WeakMap(), _ApprovalController_typesExcludedFromRateLimiting = new WeakMap(), _ApprovalController_instances = new WeakSet(), _ApprovalController_add = function _ApprovalController_add(origin, type, id = (0, nanoid_1.nanoid)(), requestData, requestState, expectsResult) {
    __classPrivateFieldGet(this, _ApprovalController_instances, "m", _ApprovalController_validateAddParams).call(this, id, origin, type, requestData, requestState);
    if (!__classPrivateFieldGet(this, _ApprovalController_typesExcludedFromRateLimiting, "f").includes(type) &&
        this.has({ origin, type })) {
        throw eth_rpc_errors_1.ethErrors.rpc.resourceUnavailable(getAlreadyPendingMessage(origin, type));
    }
    // add pending approval
    return new Promise((resolve, reject) => {
        __classPrivateFieldGet(this, _ApprovalController_approvals, "f").set(id, { resolve, reject });
        __classPrivateFieldGet(this, _ApprovalController_instances, "m", _ApprovalController_addPendingApprovalOrigin).call(this, origin, type);
        __classPrivateFieldGet(this, _ApprovalController_instances, "m", _ApprovalController_addToStore).call(this, id, origin, type, requestData, requestState, expectsResult);
    });
}, _ApprovalController_validateAddParams = function _ApprovalController_validateAddParams(id, origin, type, requestData, requestState) {
    let errorMessage = null;
    if (!id || typeof id !== 'string') {
        errorMessage = 'Must specify non-empty string id.';
    }
    else if (__classPrivateFieldGet(this, _ApprovalController_approvals, "f").has(id)) {
        errorMessage = `Approval request with id '${id}' already exists.`;
    }
    else if (!origin || typeof origin !== 'string') {
        errorMessage = 'Must specify non-empty string origin.';
    }
    else if (!type || typeof type !== 'string') {
        errorMessage = 'Must specify non-empty string type.';
    }
    else if (requestData &&
        (typeof requestData !== 'object' || Array.isArray(requestData))) {
        errorMessage = 'Request data must be a plain object if specified.';
    }
    else if (requestState &&
        (typeof requestState !== 'object' || Array.isArray(requestState))) {
        errorMessage = 'Request state must be a plain object if specified.';
    }
    if (errorMessage) {
        throw eth_rpc_errors_1.ethErrors.rpc.internal(errorMessage);
    }
}, _ApprovalController_addPendingApprovalOrigin = function _ApprovalController_addPendingApprovalOrigin(origin, type) {
    let originMap = __classPrivateFieldGet(this, _ApprovalController_origins, "f").get(origin);
    if (!originMap) {
        originMap = new Map();
        __classPrivateFieldGet(this, _ApprovalController_origins, "f").set(origin, originMap);
    }
    const currentValue = originMap.get(type) || 0;
    originMap.set(type, currentValue + 1);
}, _ApprovalController_addToStore = function _ApprovalController_addToStore(id, origin, type, requestData, requestState, expectsResult) {
    const approval = {
        id,
        origin,
        type,
        time: Date.now(),
        requestData: requestData || null,
        requestState: requestState || null,
        expectsResult: expectsResult || false,
    };
    this.update((draftState) => {
        // Typecast: ts(2589)
        draftState.pendingApprovals[id] = approval;
        draftState.pendingApprovalCount = Object.keys(draftState.pendingApprovals).length;
    });
}, _ApprovalController_delete = function _ApprovalController_delete(id) {
    __classPrivateFieldGet(this, _ApprovalController_approvals, "f").delete(id);
    // This method is only called after verifying that the approval with the
    // specified id exists.
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const { origin, type } = this.state.pendingApprovals[id];
    const originMap = __classPrivateFieldGet(this, _ApprovalController_origins, "f").get(origin);
    const originTotalCount = this.getApprovalCount({ origin });
    const originTypeCount = originMap.get(type);
    if (originTotalCount === 1) {
        __classPrivateFieldGet(this, _ApprovalController_origins, "f").delete(origin);
    }
    else {
        originMap.set(type, originTypeCount - 1);
    }
    this.update((draftState) => {
        delete draftState.pendingApprovals[id];
        draftState.pendingApprovalCount = Object.keys(draftState.pendingApprovals).length;
    });
}, _ApprovalController_deleteApprovalAndGetCallbacks = function _ApprovalController_deleteApprovalAndGetCallbacks(id) {
    const callbacks = __classPrivateFieldGet(this, _ApprovalController_approvals, "f").get(id);
    if (!callbacks) {
        throw new errors_1.ApprovalRequestNotFoundError(id);
    }
    __classPrivateFieldGet(this, _ApprovalController_instances, "m", _ApprovalController_delete).call(this, id);
    return callbacks;
}, _ApprovalController_result = function _ApprovalController_result(type, opts, requestData) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield this.addAndShowApprovalRequest({
                origin: exports.ORIGIN_METAMASK,
                type,
                requestData,
            });
        }
        catch (error) {
            console.info('Failed to display result page', error);
        }
        finally {
            if (opts.flowToEnd) {
                try {
                    this.endFlow({ id: opts.flowToEnd });
                }
                catch (error) {
                    console.info('Failed to end flow', { id: opts.flowToEnd, error });
                }
            }
        }
    });
};
exports.default = ApprovalController;
//# sourceMappingURL=ApprovalController.js.map