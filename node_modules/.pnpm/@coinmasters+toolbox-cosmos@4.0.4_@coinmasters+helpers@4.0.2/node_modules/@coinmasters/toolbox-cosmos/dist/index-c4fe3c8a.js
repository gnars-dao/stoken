import { b as ie, a as D, e as C } from "./index-376c10b7.js";
import { e as k } from "./index-dd5ccbe6.js";
function pe(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const o in r)
        if (o !== "default" && !(o in e)) {
          const i = Object.getOwnPropertyDescriptor(r, o);
          i && Object.defineProperty(e, o, i.get ? i : {
            enumerable: !0,
            get: () => r[o]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var se = {}, l = {}, a = {}, B = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isMultisigThresholdPubkey = e.isSinglePubkey = e.pubkeyType = e.isSecp256k1Pubkey = e.isEd25519Pubkey = void 0;
  function t(i) {
    return i.type === "tendermint/PubKeyEd25519";
  }
  e.isEd25519Pubkey = t;
  function n(i) {
    return i.type === "tendermint/PubKeySecp256k1";
  }
  e.isSecp256k1Pubkey = n, e.pubkeyType = {
    /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/ed25519/ed25519.go#L22 */
    secp256k1: "tendermint/PubKeySecp256k1",
    /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/secp256k1/secp256k1.go#L23 */
    ed25519: "tendermint/PubKeyEd25519",
    /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/sr25519/codec.go#L12 */
    sr25519: "tendermint/PubKeySr25519",
    multisigThreshold: "tendermint/PubKeyMultisigThreshold"
  };
  function r(i) {
    return [e.pubkeyType.ed25519, e.pubkeyType.secp256k1, e.pubkeyType.sr25519].includes(i.type);
  }
  e.isSinglePubkey = r;
  function o(i) {
    return i.type === "tendermint/PubKeyMultisigThreshold";
  }
  e.isMultisigThresholdPubkey = o;
})(B);
Object.defineProperty(a, "__esModule", { value: !0 });
a.encodeBech32Pubkey = a.encodeAminoPubkey = a.decodeBech32Pubkey = a.decodeAminoPubkey = a.encodeEd25519Pubkey = a.encodeSecp256k1Pubkey = void 0;
const y = k, be = D, j = ie, b = B;
function me(e) {
  if (e.length !== 33 || e[0] !== 2 && e[0] !== 3)
    throw new Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");
  return {
    type: b.pubkeyType.secp256k1,
    value: (0, y.toBase64)(e)
  };
}
a.encodeSecp256k1Pubkey = me;
function ge(e) {
  if (e.length !== 32)
    throw new Error("Ed25519 public key must be 32 bytes long");
  return {
    type: b.pubkeyType.ed25519,
    value: (0, y.toBase64)(e)
  };
}
a.encodeEd25519Pubkey = ge;
const W = (0, y.fromHex)(
  "eb5ae98721"
  /* fixed length */
), J = (0, y.fromHex)(
  "1624de6420"
  /* fixed length */
), Q = (0, y.fromHex)(
  "0dfb100520"
  /* fixed length */
), $ = (0, y.fromHex)(
  "22c1f7e2"
  /* variable length not included */
);
function F(e) {
  if ((0, j.arrayContentStartsWith)(e, W)) {
    const t = e.slice(W.length);
    if (t.length !== 33)
      throw new Error("Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).");
    return {
      type: b.pubkeyType.secp256k1,
      value: (0, y.toBase64)(t)
    };
  } else if ((0, j.arrayContentStartsWith)(e, J)) {
    const t = e.slice(J.length);
    if (t.length !== 32)
      throw new Error("Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).");
    return {
      type: b.pubkeyType.ed25519,
      value: (0, y.toBase64)(t)
    };
  } else if ((0, j.arrayContentStartsWith)(e, Q)) {
    const t = e.slice(Q.length);
    if (t.length !== 32)
      throw new Error("Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).");
    return {
      type: b.pubkeyType.sr25519,
      value: (0, y.toBase64)(t)
    };
  } else {
    if ((0, j.arrayContentStartsWith)(e, $))
      return Pe(e);
    throw new Error("Unsupported public key type. Amino data starts with: " + (0, y.toHex)(e.slice(0, 5)));
  }
}
a.decodeAminoPubkey = F;
function ke(e) {
  const { data: t } = (0, y.fromBech32)(e);
  return F(t);
}
a.decodeBech32Pubkey = ke;
function Y(e) {
  if (e.length < 1)
    throw new Error("Can't decode varint. EOF");
  if (e[0] > 127)
    throw new Error("Decoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.Varint implementation from the Go standard library and write some tests.");
  return [e[0], 1];
}
function Pe(e) {
  const t = Array.from(e), n = t.splice(0, $.length);
  if (!(0, j.arrayContentStartsWith)(n, $))
    throw new Error("Invalid multisig prefix.");
  if (t.shift() != 8)
    throw new Error("Invalid multisig data. Expecting 0x08 prefix before threshold.");
  const [r, o] = Y(t);
  t.splice(0, o);
  const i = [];
  for (; t.length > 0; ) {
    if (t.shift() != 18)
      throw new Error("Invalid multisig data. Expecting 0x12 prefix before participant pubkey length.");
    const [c, u] = Y(t);
    if (t.splice(0, u), t.length < c)
      throw new Error("Invalid multisig data length.");
    const s = t.splice(0, c), d = F(Uint8Array.from(s));
    i.push(d);
  }
  return {
    type: b.pubkeyType.multisigThreshold,
    value: {
      threshold: r.toString(),
      pubkeys: i
    }
  };
}
function ee(e) {
  const t = be.Uint53.fromString(e.toString()).toNumber();
  if (t > 127)
    throw new Error("Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.");
  return [t];
}
function X(e) {
  if ((0, b.isMultisigThresholdPubkey)(e)) {
    const t = Array.from($);
    t.push(8), t.push(...ee(e.value.threshold));
    for (const n of e.value.pubkeys.map((r) => X(r)))
      t.push(18), t.push(...ee(n.length)), t.push(...n);
    return new Uint8Array(t);
  } else {
    if ((0, b.isEd25519Pubkey)(e))
      return new Uint8Array([...J, ...(0, y.fromBase64)(e.value)]);
    if ((0, b.isSecp256k1Pubkey)(e))
      return new Uint8Array([...W, ...(0, y.fromBase64)(e.value)]);
    throw new Error("Unsupported pubkey type");
  }
}
a.encodeAminoPubkey = X;
function we(e, t) {
  return (0, y.toBech32)(t, X(e));
}
a.encodeBech32Pubkey = we;
Object.defineProperty(l, "__esModule", { value: !0 });
l.pubkeyToAddress = l.pubkeyToRawAddress = l.rawSecp256k1PubkeyToRawAddress = l.rawEd25519PubkeyToRawAddress = void 0;
const U = C, H = k, Se = a, I = B;
function ce(e) {
  if (e.length !== 32)
    throw new Error(`Invalid Ed25519 pubkey length: ${e.length}`);
  return (0, U.sha256)(e).slice(0, 20);
}
l.rawEd25519PubkeyToRawAddress = ce;
function ue(e) {
  if (e.length !== 33)
    throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${e.length}`);
  return (0, U.ripemd160)((0, U.sha256)(e));
}
l.rawSecp256k1PubkeyToRawAddress = ue;
function ae(e) {
  if ((0, I.isSecp256k1Pubkey)(e)) {
    const t = (0, H.fromBase64)(e.value);
    return ue(t);
  } else if ((0, I.isEd25519Pubkey)(e)) {
    const t = (0, H.fromBase64)(e.value);
    return ce(t);
  } else if ((0, I.isMultisigThresholdPubkey)(e)) {
    const t = (0, Se.encodeAminoPubkey)(e);
    return (0, U.sha256)(t).slice(0, 20);
  } else
    throw new Error("Unsupported public key type");
}
l.pubkeyToRawAddress = ae;
function ve(e, t) {
  return (0, H.toBech32)(t, ae(e));
}
l.pubkeyToAddress = ve;
var p = {};
Object.defineProperty(p, "__esModule", { value: !0 });
p.addCoins = p.parseCoins = p.coins = p.coin = void 0;
const L = D;
function de(e, t) {
  let n;
  if (typeof e == "number")
    try {
      n = new L.Uint53(e).toString();
    } catch {
      throw new Error("Given amount is not a safe integer. Consider using a string instead to overcome the limitations of JS numbers.");
    }
  else {
    if (!e.match(/^[0-9]+$/))
      throw new Error("Invalid unsigned integer string format");
    n = e.replace(/^0*/, "") || "0";
  }
  return {
    amount: n,
    denom: t
  };
}
p.coin = de;
function Ae(e, t) {
  return [de(e, t)];
}
p.coins = Ae;
function Te(e) {
  return e.replace(/\s/g, "").split(",").filter(Boolean).map((t) => {
    const n = t.match(/^([0-9]+)([a-zA-Z]+)/);
    if (!n)
      throw new Error("Got an invalid coin string");
    return {
      amount: n[1].replace(/^0+/, "") || "0",
      denom: n[2]
    };
  });
}
p.parseCoins = Te;
function Ee(e, t) {
  if (e.denom !== t.denom)
    throw new Error("Trying to add two coins with different denoms");
  return {
    amount: L.Decimal.fromAtomics(e.amount, 0).plus(L.Decimal.fromAtomics(t.amount, 0)).atomics,
    denom: e.denom
  };
}
p.addCoins = Ee;
var v = {};
Object.defineProperty(v, "__esModule", { value: !0 });
v.createMultisigThresholdPubkey = v.compareArrays = void 0;
const te = k, _e = D, ne = l;
function ye(e, t) {
  const n = (0, te.toHex)(e), r = (0, te.toHex)(t);
  return n === r ? 0 : n < r ? -1 : 1;
}
v.compareArrays = ye;
function Oe(e, t, n = !1) {
  const r = new _e.Uint53(t);
  if (r.toNumber() > e.length)
    throw new Error(`Threshold k = ${r.toNumber()} exceeds number of keys n = ${e.length}`);
  const o = n ? e : Array.from(e).sort((i, c) => {
    const u = (0, ne.pubkeyToRawAddress)(i), s = (0, ne.pubkeyToRawAddress)(c);
    return ye(u, s);
  });
  return {
    type: "tendermint/PubKeyMultisigThreshold",
    value: {
      threshold: r.toString(),
      pubkeys: o
    }
  };
}
v.createMultisigThresholdPubkey = Oe;
var N = {};
Object.defineProperty(N, "__esModule", { value: !0 });
N.omitDefault = void 0;
function je(e) {
  switch (typeof e) {
    case "string":
      return e === "" ? void 0 : e;
    case "number":
      return e === 0 ? void 0 : e;
    case "bigint":
      return e === BigInt(0) ? void 0 : e;
    case "boolean":
      return e || void 0;
    default:
      throw new Error(`Got unsupported type '${typeof e}'`);
  }
}
N.omitDefault = je;
var M = {};
Object.defineProperty(M, "__esModule", { value: !0 });
M.makeCosmoshubPath = void 0;
const E = C;
function Ce(e) {
  return [
    E.Slip10RawIndex.hardened(44),
    E.Slip10RawIndex.hardened(118),
    E.Slip10RawIndex.hardened(0),
    E.Slip10RawIndex.normal(0),
    E.Slip10RawIndex.normal(e)
  ];
}
M.makeCosmoshubPath = Ce;
var A = {}, g = {};
Object.defineProperty(g, "__esModule", { value: !0 });
g.decodeSignature = g.encodeSecp256k1Signature = void 0;
const G = k, Be = a, Me = B;
function Ke(e, t) {
  if (t.length !== 64)
    throw new Error("Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.");
  return {
    pub_key: (0, Be.encodeSecp256k1Pubkey)(e),
    signature: (0, G.toBase64)(t)
  };
}
g.encodeSecp256k1Signature = Ke;
function Re(e) {
  switch (e.pub_key.type) {
    case Me.pubkeyType.secp256k1:
      return {
        pubkey: (0, G.fromBase64)(e.pub_key.value),
        signature: (0, G.fromBase64)(e.signature)
      };
    default:
      throw new Error("Unsupported pubkey type");
  }
}
g.decodeSignature = Re;
var h = {};
Object.defineProperty(h, "__esModule", { value: !0 });
h.serializeSignDoc = h.escapeCharacters = h.makeSignDoc = h.sortedJsonStringify = void 0;
const $e = k, re = D;
function V(e) {
  if (typeof e != "object" || e === null)
    return e;
  if (Array.isArray(e))
    return e.map(V);
  const t = Object.keys(e).sort(), n = {};
  return t.forEach((r) => {
    n[r] = V(e[r]);
  }), n;
}
function le(e) {
  return JSON.stringify(V(e));
}
h.sortedJsonStringify = le;
function Ue(e, t, n, r, o, i, c) {
  return {
    chain_id: n,
    account_number: re.Uint53.fromString(o.toString()).toString(),
    sequence: re.Uint53.fromString(i.toString()).toString(),
    fee: t,
    msgs: e,
    memo: r || "",
    ...c && { timeout_height: c.toString() }
  };
}
h.makeSignDoc = Ue;
function fe(e) {
  const t = /&/g, n = /</g, r = />/g;
  return e.replace(t, "\\u0026").replace(n, "\\u003c").replace(r, "\\u003e");
}
h.escapeCharacters = fe;
function De(e) {
  const t = fe(le(e));
  return (0, $e.toUtf8)(t);
}
h.serializeSignDoc = De;
var q = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.decrypt = e.encrypt = e.supportedAlgorithms = e.executeKdf = e.cosmjsSalt = void 0;
  const t = C, n = k;
  e.cosmjsSalt = (0, n.toAscii)("The CosmJS salt.");
  async function r(c, u) {
    switch (u.algorithm) {
      case "argon2id": {
        const s = u.params;
        if (!(0, t.isArgon2idOptions)(s))
          throw new Error("Invalid format of argon2id params");
        return t.Argon2id.execute(c, e.cosmjsSalt, s);
      }
      default:
        throw new Error("Unsupported KDF algorithm");
    }
  }
  e.executeKdf = r, e.supportedAlgorithms = {
    xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
  };
  async function o(c, u, s) {
    switch (s.algorithm) {
      case e.supportedAlgorithms.xchacha20poly1305Ietf: {
        const d = t.Random.getBytes(t.xchacha20NonceLength);
        return new Uint8Array([
          ...d,
          ...await t.Xchacha20poly1305Ietf.encrypt(c, u, d)
        ]);
      }
      default:
        throw new Error(`Unsupported encryption algorithm: '${s.algorithm}'`);
    }
  }
  e.encrypt = o;
  async function i(c, u, s) {
    switch (s.algorithm) {
      case e.supportedAlgorithms.xchacha20poly1305Ietf: {
        const d = c.slice(0, t.xchacha20NonceLength);
        return t.Xchacha20poly1305Ietf.decrypt(c.slice(t.xchacha20NonceLength), u, d);
      }
      default:
        throw new Error(`Unsupported encryption algorithm: '${s.algorithm}'`);
    }
  }
  e.decrypt = i;
})(q);
Object.defineProperty(A, "__esModule", { value: !0 });
A.Secp256k1HdWallet = A.extractKdfConfiguration = void 0;
const f = C, _ = k, S = ie, Ne = l, ze = M, Ie = g, We = h, O = q, R = "secp256k1wallet-v1", Je = {
  algorithm: "argon2id",
  params: {
    outputLength: 32,
    opsLimit: 24,
    memLimitKib: 12 * 1024
  }
};
function He(e) {
  return !(!(0, S.isNonNullObject)(e) || typeof e.hdPath != "string" || typeof e.prefix != "string");
}
function Le(e) {
  return e.kdf;
}
function Ge(e) {
  const t = JSON.parse(e);
  if (!(0, S.isNonNullObject)(t))
    throw new Error("Root document is not an object.");
  switch (t.type) {
    case R:
      return Le(t);
    default:
      throw new Error("Unsupported serialization type");
  }
}
A.extractKdfConfiguration = Ge;
const oe = {
  bip39Password: "",
  hdPaths: [(0, ze.makeCosmoshubPath)(0)],
  prefix: "cosmos"
};
class P {
  /**
   * Restores a wallet from the given BIP39 mnemonic.
   *
   * @param mnemonic Any valid English mnemonic.
   * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
   */
  static async fromMnemonic(t, n = {}) {
    const r = new f.EnglishMnemonic(t), o = await f.Bip39.mnemonicToSeed(r, n.bip39Password);
    return new P(r, {
      ...n,
      seed: o
    });
  }
  /**
   * Generates a new wallet with a BIP39 mnemonic of the given length.
   *
   * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
   * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
   */
  static async generate(t = 12, n = {}) {
    const r = 4 * Math.floor(11 * t / 33), o = f.Random.getBytes(r), i = f.Bip39.encode(o);
    return P.fromMnemonic(i.toString(), n);
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * @param password The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  static async deserialize(t, n) {
    const r = JSON.parse(t);
    if (!(0, S.isNonNullObject)(r))
      throw new Error("Root document is not an object.");
    switch (r.type) {
      case R:
        return P.deserializeTypeV1(t, n);
      default:
        throw new Error("Unsupported serialization type");
    }
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
   * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
   * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
   */
  static async deserializeWithEncryptionKey(t, n) {
    const r = JSON.parse(t);
    if (!(0, S.isNonNullObject)(r))
      throw new Error("Root document is not an object.");
    const o = r;
    switch (o.type) {
      case R: {
        const i = await (0, O.decrypt)((0, _.fromBase64)(o.data), n, o.encryption), c = JSON.parse((0, _.fromUtf8)(i)), { mnemonic: u, accounts: s } = c;
        if ((0, S.assert)(typeof u == "string"), !Array.isArray(s))
          throw new Error("Property 'accounts' is not an array");
        if (!s.every((m) => He(m)))
          throw new Error("Account is not in the correct format.");
        const d = s[0].prefix;
        if (!s.every(({ prefix: m }) => m === d))
          throw new Error("Accounts do not all have the same prefix");
        const w = s.map(({ hdPath: m }) => (0, f.stringToPath)(m));
        return P.fromMnemonic(u, {
          hdPaths: w,
          prefix: d
        });
      }
      default:
        throw new Error("Unsupported serialization type");
    }
  }
  static async deserializeTypeV1(t, n) {
    const r = JSON.parse(t);
    if (!(0, S.isNonNullObject)(r))
      throw new Error("Root document is not an object.");
    const o = await (0, O.executeKdf)(n, r.kdf);
    return P.deserializeWithEncryptionKey(t, o);
  }
  constructor(t, n) {
    const r = n.hdPaths ?? oe.hdPaths, o = n.prefix ?? oe.prefix;
    this.secret = t, this.seed = n.seed, this.accounts = r.map((i) => ({
      hdPath: i,
      prefix: o
    }));
  }
  get mnemonic() {
    return this.secret.toString();
  }
  async getAccounts() {
    return (await this.getAccountsWithPrivkeys()).map(({ algo: n, pubkey: r, address: o }) => ({
      algo: n,
      pubkey: r,
      address: o
    }));
  }
  async signAmino(t, n) {
    const o = (await this.getAccountsWithPrivkeys()).find(({ address: w }) => w === t);
    if (o === void 0)
      throw new Error(`Address ${t} not found in wallet`);
    const { privkey: i, pubkey: c } = o, u = (0, f.sha256)((0, We.serializeSignDoc)(n)), s = await f.Secp256k1.createSignature(u, i), d = new Uint8Array([...s.r(32), ...s.s(32)]);
    return {
      signed: n,
      signature: (0, Ie.encodeSecp256k1Signature)(c, d)
    };
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * @param password The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  async serialize(t) {
    const n = Je, r = await (0, O.executeKdf)(t, n);
    return this.serializeWithEncryptionKey(r, n);
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
   * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF options. If this
   * is not the case, the wallet cannot be restored with the original password.
   */
  async serializeWithEncryptionKey(t, n) {
    const r = {
      mnemonic: this.mnemonic,
      accounts: this.accounts.map(({ hdPath: s, prefix: d }) => ({
        hdPath: (0, f.pathToString)(s),
        prefix: d
      }))
    }, o = (0, _.toUtf8)(JSON.stringify(r)), i = {
      algorithm: O.supportedAlgorithms.xchacha20poly1305Ietf
    }, c = await (0, O.encrypt)(o, t, i), u = {
      type: R,
      kdf: n,
      encryption: i,
      data: (0, _.toBase64)(c)
    };
    return JSON.stringify(u);
  }
  async getKeyPair(t) {
    const { privkey: n } = f.Slip10.derivePath(f.Slip10Curve.Secp256k1, this.seed, t), { pubkey: r } = await f.Secp256k1.makeKeypair(n);
    return {
      privkey: n,
      pubkey: f.Secp256k1.compressPubkey(r)
    };
  }
  async getAccountsWithPrivkeys() {
    return Promise.all(this.accounts.map(async ({ hdPath: t, prefix: n }) => {
      const { privkey: r, pubkey: o } = await this.getKeyPair(t), i = (0, _.toBech32)(n, (0, Ne.rawSecp256k1PubkeyToRawAddress)(o));
      return {
        algo: "secp256k1",
        privkey: r,
        pubkey: o,
        address: i
      };
    }));
  }
}
A.Secp256k1HdWallet = P;
var z = {};
Object.defineProperty(z, "__esModule", { value: !0 });
z.Secp256k1Wallet = void 0;
const K = C, Ve = k, Fe = l, Xe = g, qe = h;
class x {
  /**
   * Creates a Secp256k1Wallet from the given private key
   *
   * @param privkey The private key.
   * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
   */
  static async fromKey(t, n = "cosmos") {
    const r = (await K.Secp256k1.makeKeypair(t)).pubkey;
    return new x(t, K.Secp256k1.compressPubkey(r), n);
  }
  constructor(t, n, r) {
    this.privkey = t, this.pubkey = n, this.prefix = r;
  }
  get address() {
    return (0, Ve.toBech32)(this.prefix, (0, Fe.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
  }
  async getAccounts() {
    return [
      {
        algo: "secp256k1",
        address: this.address,
        pubkey: this.pubkey
      }
    ];
  }
  async signAmino(t, n) {
    if (t !== this.address)
      throw new Error(`Address ${t} not found in wallet`);
    const r = new K.Sha256((0, qe.serializeSignDoc)(n)).digest(), o = await K.Secp256k1.createSignature(r, this.privkey), i = new Uint8Array([...o.r(32), ...o.s(32)]);
    return {
      signed: n,
      signature: (0, Xe.encodeSecp256k1Signature)(this.pubkey, i)
    };
  }
}
z.Secp256k1Wallet = x;
var T = {};
Object.defineProperty(T, "__esModule", { value: !0 });
T.makeStdTx = T.isStdTx = void 0;
function xe(e) {
  const { memo: t, msg: n, fee: r, signatures: o } = e;
  return typeof t == "string" && Array.isArray(n) && typeof r == "object" && Array.isArray(o);
}
T.isStdTx = xe;
function Ze(e, t) {
  return {
    msg: e.msgs,
    fee: e.fee,
    memo: e.memo,
    signatures: Array.isArray(t) ? t : [t]
  };
}
T.makeStdTx = Ze;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.executeKdf = e.makeStdTx = e.isStdTx = e.serializeSignDoc = e.makeSignDoc = e.encodeSecp256k1Signature = e.decodeSignature = e.Secp256k1Wallet = e.Secp256k1HdWallet = e.extractKdfConfiguration = e.pubkeyType = e.isSinglePubkey = e.isSecp256k1Pubkey = e.isMultisigThresholdPubkey = e.isEd25519Pubkey = e.makeCosmoshubPath = e.omitDefault = e.createMultisigThresholdPubkey = e.encodeSecp256k1Pubkey = e.encodeEd25519Pubkey = e.encodeBech32Pubkey = e.encodeAminoPubkey = e.decodeBech32Pubkey = e.decodeAminoPubkey = e.parseCoins = e.coins = e.coin = e.addCoins = e.rawSecp256k1PubkeyToRawAddress = e.rawEd25519PubkeyToRawAddress = e.pubkeyToRawAddress = e.pubkeyToAddress = void 0;
  var t = l;
  Object.defineProperty(e, "pubkeyToAddress", { enumerable: !0, get: function() {
    return t.pubkeyToAddress;
  } }), Object.defineProperty(e, "pubkeyToRawAddress", { enumerable: !0, get: function() {
    return t.pubkeyToRawAddress;
  } }), Object.defineProperty(e, "rawEd25519PubkeyToRawAddress", { enumerable: !0, get: function() {
    return t.rawEd25519PubkeyToRawAddress;
  } }), Object.defineProperty(e, "rawSecp256k1PubkeyToRawAddress", { enumerable: !0, get: function() {
    return t.rawSecp256k1PubkeyToRawAddress;
  } });
  var n = p;
  Object.defineProperty(e, "addCoins", { enumerable: !0, get: function() {
    return n.addCoins;
  } }), Object.defineProperty(e, "coin", { enumerable: !0, get: function() {
    return n.coin;
  } }), Object.defineProperty(e, "coins", { enumerable: !0, get: function() {
    return n.coins;
  } }), Object.defineProperty(e, "parseCoins", { enumerable: !0, get: function() {
    return n.parseCoins;
  } });
  var r = a;
  Object.defineProperty(e, "decodeAminoPubkey", { enumerable: !0, get: function() {
    return r.decodeAminoPubkey;
  } }), Object.defineProperty(e, "decodeBech32Pubkey", { enumerable: !0, get: function() {
    return r.decodeBech32Pubkey;
  } }), Object.defineProperty(e, "encodeAminoPubkey", { enumerable: !0, get: function() {
    return r.encodeAminoPubkey;
  } }), Object.defineProperty(e, "encodeBech32Pubkey", { enumerable: !0, get: function() {
    return r.encodeBech32Pubkey;
  } }), Object.defineProperty(e, "encodeEd25519Pubkey", { enumerable: !0, get: function() {
    return r.encodeEd25519Pubkey;
  } }), Object.defineProperty(e, "encodeSecp256k1Pubkey", { enumerable: !0, get: function() {
    return r.encodeSecp256k1Pubkey;
  } });
  var o = v;
  Object.defineProperty(e, "createMultisigThresholdPubkey", { enumerable: !0, get: function() {
    return o.createMultisigThresholdPubkey;
  } });
  var i = N;
  Object.defineProperty(e, "omitDefault", { enumerable: !0, get: function() {
    return i.omitDefault;
  } });
  var c = M;
  Object.defineProperty(e, "makeCosmoshubPath", { enumerable: !0, get: function() {
    return c.makeCosmoshubPath;
  } });
  var u = B;
  Object.defineProperty(e, "isEd25519Pubkey", { enumerable: !0, get: function() {
    return u.isEd25519Pubkey;
  } }), Object.defineProperty(e, "isMultisigThresholdPubkey", { enumerable: !0, get: function() {
    return u.isMultisigThresholdPubkey;
  } }), Object.defineProperty(e, "isSecp256k1Pubkey", { enumerable: !0, get: function() {
    return u.isSecp256k1Pubkey;
  } }), Object.defineProperty(e, "isSinglePubkey", { enumerable: !0, get: function() {
    return u.isSinglePubkey;
  } }), Object.defineProperty(e, "pubkeyType", { enumerable: !0, get: function() {
    return u.pubkeyType;
  } });
  var s = A;
  Object.defineProperty(e, "extractKdfConfiguration", { enumerable: !0, get: function() {
    return s.extractKdfConfiguration;
  } }), Object.defineProperty(e, "Secp256k1HdWallet", { enumerable: !0, get: function() {
    return s.Secp256k1HdWallet;
  } });
  var d = z;
  Object.defineProperty(e, "Secp256k1Wallet", { enumerable: !0, get: function() {
    return d.Secp256k1Wallet;
  } });
  var w = g;
  Object.defineProperty(e, "decodeSignature", { enumerable: !0, get: function() {
    return w.decodeSignature;
  } }), Object.defineProperty(e, "encodeSecp256k1Signature", { enumerable: !0, get: function() {
    return w.encodeSecp256k1Signature;
  } });
  var m = h;
  Object.defineProperty(e, "makeSignDoc", { enumerable: !0, get: function() {
    return m.makeSignDoc;
  } }), Object.defineProperty(e, "serializeSignDoc", { enumerable: !0, get: function() {
    return m.serializeSignDoc;
  } });
  var Z = T;
  Object.defineProperty(e, "isStdTx", { enumerable: !0, get: function() {
    return Z.isStdTx;
  } }), Object.defineProperty(e, "makeStdTx", { enumerable: !0, get: function() {
    return Z.makeStdTx;
  } });
  var he = q;
  Object.defineProperty(e, "executeKdf", { enumerable: !0, get: function() {
    return he.executeKdf;
  } });
})(se);
const et = /* @__PURE__ */ pe({
  __proto__: null
}, [se]);
export {
  se as b,
  et as i
};
