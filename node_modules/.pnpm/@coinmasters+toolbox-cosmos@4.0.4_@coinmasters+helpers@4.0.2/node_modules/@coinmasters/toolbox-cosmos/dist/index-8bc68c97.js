import { a as Be, b as re, h as ie, d as Le, e as Ct, c as j, f as rc, r as kp, t as xr, s as ed, m as Pp, i as vp, j as Rp, k as ic, l as Yi, n as oc, o as Ci } from "./index-dd5ccbe6.js";
import { b as an, a as mt, r as ac, s as sc, c as nd, p as Bp, d as Op, l as bp } from "./index-376c10b7.js";
import { b as Nt, t as Ap, a as Ip } from "./index-d10572c9.js";
import { a as Tp, b as Cp, e as Np, f as wp, i as _p, u as Ep, p as Jp } from "./index-7bcca4ca.js";
import { b as Xi } from "./index-c4fe3c8a.js";
function Up(e, n) {
  for (var r = 0; r < n.length; r++) {
    const t = n[r];
    if (typeof t != "string" && !Array.isArray(t)) {
      for (const i in t)
        if (i !== "default" && !(i in e)) {
          const f = Object.getOwnPropertyDescriptor(t, i);
          f && Object.defineProperty(e, i, f.get ? f : {
            enumerable: !0,
            get: () => t[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var dc = {}, Zr = {}, ji = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Params = e.ModuleCredential = e.ModuleAccount = e.BaseAccount = e.protobufPackage = void 0;
  const n = Be, r = re, t = ie;
  e.protobufPackage = "cosmos.auth.v1beta1";
  function i() {
    return {
      address: "",
      pubKey: void 0,
      accountNumber: BigInt(0),
      sequence: BigInt(0)
    };
  }
  e.BaseAccount = {
    typeUrl: "/cosmos.auth.v1beta1.BaseAccount",
    encode(T, U = r.BinaryWriter.create()) {
      return T.address !== "" && U.uint32(10).string(T.address), T.pubKey !== void 0 && n.Any.encode(T.pubKey, U.uint32(18).fork()).ldelim(), T.accountNumber !== BigInt(0) && U.uint32(24).uint64(T.accountNumber), T.sequence !== BigInt(0) && U.uint32(32).uint64(T.sequence), U;
    },
    decode(T, U) {
      const w = T instanceof r.BinaryReader ? T : new r.BinaryReader(T);
      let N = U === void 0 ? w.len : w.pos + U;
      const h = i();
      for (; w.pos < N; ) {
        const P = w.uint32();
        switch (P >>> 3) {
          case 1:
            h.address = w.string();
            break;
          case 2:
            h.pubKey = n.Any.decode(w, w.uint32());
            break;
          case 3:
            h.accountNumber = w.uint64();
            break;
          case 4:
            h.sequence = w.uint64();
            break;
          default:
            w.skipType(P & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(T) {
      const U = i();
      return (0, t.isSet)(T.address) && (U.address = String(T.address)), (0, t.isSet)(T.pubKey) && (U.pubKey = n.Any.fromJSON(T.pubKey)), (0, t.isSet)(T.accountNumber) && (U.accountNumber = BigInt(T.accountNumber.toString())), (0, t.isSet)(T.sequence) && (U.sequence = BigInt(T.sequence.toString())), U;
    },
    toJSON(T) {
      const U = {};
      return T.address !== void 0 && (U.address = T.address), T.pubKey !== void 0 && (U.pubKey = T.pubKey ? n.Any.toJSON(T.pubKey) : void 0), T.accountNumber !== void 0 && (U.accountNumber = (T.accountNumber || BigInt(0)).toString()), T.sequence !== void 0 && (U.sequence = (T.sequence || BigInt(0)).toString()), U;
    },
    fromPartial(T) {
      const U = i();
      return U.address = T.address ?? "", T.pubKey !== void 0 && T.pubKey !== null && (U.pubKey = n.Any.fromPartial(T.pubKey)), T.accountNumber !== void 0 && T.accountNumber !== null && (U.accountNumber = BigInt(T.accountNumber.toString())), T.sequence !== void 0 && T.sequence !== null && (U.sequence = BigInt(T.sequence.toString())), U;
    }
  };
  function f() {
    return {
      baseAccount: void 0,
      name: "",
      permissions: []
    };
  }
  e.ModuleAccount = {
    typeUrl: "/cosmos.auth.v1beta1.ModuleAccount",
    encode(T, U = r.BinaryWriter.create()) {
      T.baseAccount !== void 0 && e.BaseAccount.encode(T.baseAccount, U.uint32(10).fork()).ldelim(), T.name !== "" && U.uint32(18).string(T.name);
      for (const w of T.permissions)
        U.uint32(26).string(w);
      return U;
    },
    decode(T, U) {
      const w = T instanceof r.BinaryReader ? T : new r.BinaryReader(T);
      let N = U === void 0 ? w.len : w.pos + U;
      const h = f();
      for (; w.pos < N; ) {
        const P = w.uint32();
        switch (P >>> 3) {
          case 1:
            h.baseAccount = e.BaseAccount.decode(w, w.uint32());
            break;
          case 2:
            h.name = w.string();
            break;
          case 3:
            h.permissions.push(w.string());
            break;
          default:
            w.skipType(P & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(T) {
      const U = f();
      return (0, t.isSet)(T.baseAccount) && (U.baseAccount = e.BaseAccount.fromJSON(T.baseAccount)), (0, t.isSet)(T.name) && (U.name = String(T.name)), Array.isArray(T == null ? void 0 : T.permissions) && (U.permissions = T.permissions.map((w) => String(w))), U;
    },
    toJSON(T) {
      const U = {};
      return T.baseAccount !== void 0 && (U.baseAccount = T.baseAccount ? e.BaseAccount.toJSON(T.baseAccount) : void 0), T.name !== void 0 && (U.name = T.name), T.permissions ? U.permissions = T.permissions.map((w) => w) : U.permissions = [], U;
    },
    fromPartial(T) {
      var w;
      const U = f();
      return T.baseAccount !== void 0 && T.baseAccount !== null && (U.baseAccount = e.BaseAccount.fromPartial(T.baseAccount)), U.name = T.name ?? "", U.permissions = ((w = T.permissions) == null ? void 0 : w.map((N) => N)) || [], U;
    }
  };
  function k() {
    return {
      moduleName: "",
      derivationKeys: []
    };
  }
  e.ModuleCredential = {
    typeUrl: "/cosmos.auth.v1beta1.ModuleCredential",
    encode(T, U = r.BinaryWriter.create()) {
      T.moduleName !== "" && U.uint32(10).string(T.moduleName);
      for (const w of T.derivationKeys)
        U.uint32(18).bytes(w);
      return U;
    },
    decode(T, U) {
      const w = T instanceof r.BinaryReader ? T : new r.BinaryReader(T);
      let N = U === void 0 ? w.len : w.pos + U;
      const h = k();
      for (; w.pos < N; ) {
        const P = w.uint32();
        switch (P >>> 3) {
          case 1:
            h.moduleName = w.string();
            break;
          case 2:
            h.derivationKeys.push(w.bytes());
            break;
          default:
            w.skipType(P & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(T) {
      const U = k();
      return (0, t.isSet)(T.moduleName) && (U.moduleName = String(T.moduleName)), Array.isArray(T == null ? void 0 : T.derivationKeys) && (U.derivationKeys = T.derivationKeys.map((w) => (0, t.bytesFromBase64)(w))), U;
    },
    toJSON(T) {
      const U = {};
      return T.moduleName !== void 0 && (U.moduleName = T.moduleName), T.derivationKeys ? U.derivationKeys = T.derivationKeys.map((w) => (0, t.base64FromBytes)(w !== void 0 ? w : new Uint8Array())) : U.derivationKeys = [], U;
    },
    fromPartial(T) {
      var w;
      const U = k();
      return U.moduleName = T.moduleName ?? "", U.derivationKeys = ((w = T.derivationKeys) == null ? void 0 : w.map((N) => N)) || [], U;
    }
  };
  function C() {
    return {
      maxMemoCharacters: BigInt(0),
      txSigLimit: BigInt(0),
      txSizeCostPerByte: BigInt(0),
      sigVerifyCostEd25519: BigInt(0),
      sigVerifyCostSecp256k1: BigInt(0)
    };
  }
  e.Params = {
    typeUrl: "/cosmos.auth.v1beta1.Params",
    encode(T, U = r.BinaryWriter.create()) {
      return T.maxMemoCharacters !== BigInt(0) && U.uint32(8).uint64(T.maxMemoCharacters), T.txSigLimit !== BigInt(0) && U.uint32(16).uint64(T.txSigLimit), T.txSizeCostPerByte !== BigInt(0) && U.uint32(24).uint64(T.txSizeCostPerByte), T.sigVerifyCostEd25519 !== BigInt(0) && U.uint32(32).uint64(T.sigVerifyCostEd25519), T.sigVerifyCostSecp256k1 !== BigInt(0) && U.uint32(40).uint64(T.sigVerifyCostSecp256k1), U;
    },
    decode(T, U) {
      const w = T instanceof r.BinaryReader ? T : new r.BinaryReader(T);
      let N = U === void 0 ? w.len : w.pos + U;
      const h = C();
      for (; w.pos < N; ) {
        const P = w.uint32();
        switch (P >>> 3) {
          case 1:
            h.maxMemoCharacters = w.uint64();
            break;
          case 2:
            h.txSigLimit = w.uint64();
            break;
          case 3:
            h.txSizeCostPerByte = w.uint64();
            break;
          case 4:
            h.sigVerifyCostEd25519 = w.uint64();
            break;
          case 5:
            h.sigVerifyCostSecp256k1 = w.uint64();
            break;
          default:
            w.skipType(P & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(T) {
      const U = C();
      return (0, t.isSet)(T.maxMemoCharacters) && (U.maxMemoCharacters = BigInt(T.maxMemoCharacters.toString())), (0, t.isSet)(T.txSigLimit) && (U.txSigLimit = BigInt(T.txSigLimit.toString())), (0, t.isSet)(T.txSizeCostPerByte) && (U.txSizeCostPerByte = BigInt(T.txSizeCostPerByte.toString())), (0, t.isSet)(T.sigVerifyCostEd25519) && (U.sigVerifyCostEd25519 = BigInt(T.sigVerifyCostEd25519.toString())), (0, t.isSet)(T.sigVerifyCostSecp256k1) && (U.sigVerifyCostSecp256k1 = BigInt(T.sigVerifyCostSecp256k1.toString())), U;
    },
    toJSON(T) {
      const U = {};
      return T.maxMemoCharacters !== void 0 && (U.maxMemoCharacters = (T.maxMemoCharacters || BigInt(0)).toString()), T.txSigLimit !== void 0 && (U.txSigLimit = (T.txSigLimit || BigInt(0)).toString()), T.txSizeCostPerByte !== void 0 && (U.txSizeCostPerByte = (T.txSizeCostPerByte || BigInt(0)).toString()), T.sigVerifyCostEd25519 !== void 0 && (U.sigVerifyCostEd25519 = (T.sigVerifyCostEd25519 || BigInt(0)).toString()), T.sigVerifyCostSecp256k1 !== void 0 && (U.sigVerifyCostSecp256k1 = (T.sigVerifyCostSecp256k1 || BigInt(0)).toString()), U;
    },
    fromPartial(T) {
      const U = C();
      return T.maxMemoCharacters !== void 0 && T.maxMemoCharacters !== null && (U.maxMemoCharacters = BigInt(T.maxMemoCharacters.toString())), T.txSigLimit !== void 0 && T.txSigLimit !== null && (U.txSigLimit = BigInt(T.txSigLimit.toString())), T.txSizeCostPerByte !== void 0 && T.txSizeCostPerByte !== null && (U.txSizeCostPerByte = BigInt(T.txSizeCostPerByte.toString())), T.sigVerifyCostEd25519 !== void 0 && T.sigVerifyCostEd25519 !== null && (U.sigVerifyCostEd25519 = BigInt(T.sigVerifyCostEd25519.toString())), T.sigVerifyCostSecp256k1 !== void 0 && T.sigVerifyCostSecp256k1 !== null && (U.sigVerifyCostSecp256k1 = BigInt(T.sigVerifyCostSecp256k1.toString())), U;
    }
  };
})(ji);
var td = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.PermanentLockedAccount = e.PeriodicVestingAccount = e.Period = e.DelayedVestingAccount = e.ContinuousVestingAccount = e.BaseVestingAccount = e.protobufPackage = void 0;
  const n = ji, r = Le, t = re, i = ie;
  e.protobufPackage = "cosmos.vesting.v1beta1";
  function f() {
    return {
      baseAccount: void 0,
      originalVesting: [],
      delegatedFree: [],
      delegatedVesting: [],
      endTime: BigInt(0)
    };
  }
  e.BaseVestingAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.BaseVestingAccount",
    encode(N, h = t.BinaryWriter.create()) {
      N.baseAccount !== void 0 && n.BaseAccount.encode(N.baseAccount, h.uint32(10).fork()).ldelim();
      for (const P of N.originalVesting)
        r.Coin.encode(P, h.uint32(18).fork()).ldelim();
      for (const P of N.delegatedFree)
        r.Coin.encode(P, h.uint32(26).fork()).ldelim();
      for (const P of N.delegatedVesting)
        r.Coin.encode(P, h.uint32(34).fork()).ldelim();
      return N.endTime !== BigInt(0) && h.uint32(40).int64(N.endTime), h;
    },
    decode(N, h) {
      const P = N instanceof t.BinaryReader ? N : new t.BinaryReader(N);
      let b = h === void 0 ? P.len : P.pos + h;
      const c = f();
      for (; P.pos < b; ) {
        const l = P.uint32();
        switch (l >>> 3) {
          case 1:
            c.baseAccount = n.BaseAccount.decode(P, P.uint32());
            break;
          case 2:
            c.originalVesting.push(r.Coin.decode(P, P.uint32()));
            break;
          case 3:
            c.delegatedFree.push(r.Coin.decode(P, P.uint32()));
            break;
          case 4:
            c.delegatedVesting.push(r.Coin.decode(P, P.uint32()));
            break;
          case 5:
            c.endTime = P.int64();
            break;
          default:
            P.skipType(l & 7);
            break;
        }
      }
      return c;
    },
    fromJSON(N) {
      const h = f();
      return (0, i.isSet)(N.baseAccount) && (h.baseAccount = n.BaseAccount.fromJSON(N.baseAccount)), Array.isArray(N == null ? void 0 : N.originalVesting) && (h.originalVesting = N.originalVesting.map((P) => r.Coin.fromJSON(P))), Array.isArray(N == null ? void 0 : N.delegatedFree) && (h.delegatedFree = N.delegatedFree.map((P) => r.Coin.fromJSON(P))), Array.isArray(N == null ? void 0 : N.delegatedVesting) && (h.delegatedVesting = N.delegatedVesting.map((P) => r.Coin.fromJSON(P))), (0, i.isSet)(N.endTime) && (h.endTime = BigInt(N.endTime.toString())), h;
    },
    toJSON(N) {
      const h = {};
      return N.baseAccount !== void 0 && (h.baseAccount = N.baseAccount ? n.BaseAccount.toJSON(N.baseAccount) : void 0), N.originalVesting ? h.originalVesting = N.originalVesting.map((P) => P ? r.Coin.toJSON(P) : void 0) : h.originalVesting = [], N.delegatedFree ? h.delegatedFree = N.delegatedFree.map((P) => P ? r.Coin.toJSON(P) : void 0) : h.delegatedFree = [], N.delegatedVesting ? h.delegatedVesting = N.delegatedVesting.map((P) => P ? r.Coin.toJSON(P) : void 0) : h.delegatedVesting = [], N.endTime !== void 0 && (h.endTime = (N.endTime || BigInt(0)).toString()), h;
    },
    fromPartial(N) {
      var P, b, c;
      const h = f();
      return N.baseAccount !== void 0 && N.baseAccount !== null && (h.baseAccount = n.BaseAccount.fromPartial(N.baseAccount)), h.originalVesting = ((P = N.originalVesting) == null ? void 0 : P.map((l) => r.Coin.fromPartial(l))) || [], h.delegatedFree = ((b = N.delegatedFree) == null ? void 0 : b.map((l) => r.Coin.fromPartial(l))) || [], h.delegatedVesting = ((c = N.delegatedVesting) == null ? void 0 : c.map((l) => r.Coin.fromPartial(l))) || [], N.endTime !== void 0 && N.endTime !== null && (h.endTime = BigInt(N.endTime.toString())), h;
    }
  };
  function k() {
    return {
      baseVestingAccount: void 0,
      startTime: BigInt(0)
    };
  }
  e.ContinuousVestingAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.ContinuousVestingAccount",
    encode(N, h = t.BinaryWriter.create()) {
      return N.baseVestingAccount !== void 0 && e.BaseVestingAccount.encode(N.baseVestingAccount, h.uint32(10).fork()).ldelim(), N.startTime !== BigInt(0) && h.uint32(16).int64(N.startTime), h;
    },
    decode(N, h) {
      const P = N instanceof t.BinaryReader ? N : new t.BinaryReader(N);
      let b = h === void 0 ? P.len : P.pos + h;
      const c = k();
      for (; P.pos < b; ) {
        const l = P.uint32();
        switch (l >>> 3) {
          case 1:
            c.baseVestingAccount = e.BaseVestingAccount.decode(P, P.uint32());
            break;
          case 2:
            c.startTime = P.int64();
            break;
          default:
            P.skipType(l & 7);
            break;
        }
      }
      return c;
    },
    fromJSON(N) {
      const h = k();
      return (0, i.isSet)(N.baseVestingAccount) && (h.baseVestingAccount = e.BaseVestingAccount.fromJSON(N.baseVestingAccount)), (0, i.isSet)(N.startTime) && (h.startTime = BigInt(N.startTime.toString())), h;
    },
    toJSON(N) {
      const h = {};
      return N.baseVestingAccount !== void 0 && (h.baseVestingAccount = N.baseVestingAccount ? e.BaseVestingAccount.toJSON(N.baseVestingAccount) : void 0), N.startTime !== void 0 && (h.startTime = (N.startTime || BigInt(0)).toString()), h;
    },
    fromPartial(N) {
      const h = k();
      return N.baseVestingAccount !== void 0 && N.baseVestingAccount !== null && (h.baseVestingAccount = e.BaseVestingAccount.fromPartial(N.baseVestingAccount)), N.startTime !== void 0 && N.startTime !== null && (h.startTime = BigInt(N.startTime.toString())), h;
    }
  };
  function C() {
    return {
      baseVestingAccount: void 0
    };
  }
  e.DelayedVestingAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.DelayedVestingAccount",
    encode(N, h = t.BinaryWriter.create()) {
      return N.baseVestingAccount !== void 0 && e.BaseVestingAccount.encode(N.baseVestingAccount, h.uint32(10).fork()).ldelim(), h;
    },
    decode(N, h) {
      const P = N instanceof t.BinaryReader ? N : new t.BinaryReader(N);
      let b = h === void 0 ? P.len : P.pos + h;
      const c = C();
      for (; P.pos < b; ) {
        const l = P.uint32();
        switch (l >>> 3) {
          case 1:
            c.baseVestingAccount = e.BaseVestingAccount.decode(P, P.uint32());
            break;
          default:
            P.skipType(l & 7);
            break;
        }
      }
      return c;
    },
    fromJSON(N) {
      const h = C();
      return (0, i.isSet)(N.baseVestingAccount) && (h.baseVestingAccount = e.BaseVestingAccount.fromJSON(N.baseVestingAccount)), h;
    },
    toJSON(N) {
      const h = {};
      return N.baseVestingAccount !== void 0 && (h.baseVestingAccount = N.baseVestingAccount ? e.BaseVestingAccount.toJSON(N.baseVestingAccount) : void 0), h;
    },
    fromPartial(N) {
      const h = C();
      return N.baseVestingAccount !== void 0 && N.baseVestingAccount !== null && (h.baseVestingAccount = e.BaseVestingAccount.fromPartial(N.baseVestingAccount)), h;
    }
  };
  function T() {
    return {
      length: BigInt(0),
      amount: []
    };
  }
  e.Period = {
    typeUrl: "/cosmos.vesting.v1beta1.Period",
    encode(N, h = t.BinaryWriter.create()) {
      N.length !== BigInt(0) && h.uint32(8).int64(N.length);
      for (const P of N.amount)
        r.Coin.encode(P, h.uint32(18).fork()).ldelim();
      return h;
    },
    decode(N, h) {
      const P = N instanceof t.BinaryReader ? N : new t.BinaryReader(N);
      let b = h === void 0 ? P.len : P.pos + h;
      const c = T();
      for (; P.pos < b; ) {
        const l = P.uint32();
        switch (l >>> 3) {
          case 1:
            c.length = P.int64();
            break;
          case 2:
            c.amount.push(r.Coin.decode(P, P.uint32()));
            break;
          default:
            P.skipType(l & 7);
            break;
        }
      }
      return c;
    },
    fromJSON(N) {
      const h = T();
      return (0, i.isSet)(N.length) && (h.length = BigInt(N.length.toString())), Array.isArray(N == null ? void 0 : N.amount) && (h.amount = N.amount.map((P) => r.Coin.fromJSON(P))), h;
    },
    toJSON(N) {
      const h = {};
      return N.length !== void 0 && (h.length = (N.length || BigInt(0)).toString()), N.amount ? h.amount = N.amount.map((P) => P ? r.Coin.toJSON(P) : void 0) : h.amount = [], h;
    },
    fromPartial(N) {
      var P;
      const h = T();
      return N.length !== void 0 && N.length !== null && (h.length = BigInt(N.length.toString())), h.amount = ((P = N.amount) == null ? void 0 : P.map((b) => r.Coin.fromPartial(b))) || [], h;
    }
  };
  function U() {
    return {
      baseVestingAccount: void 0,
      startTime: BigInt(0),
      vestingPeriods: []
    };
  }
  e.PeriodicVestingAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.PeriodicVestingAccount",
    encode(N, h = t.BinaryWriter.create()) {
      N.baseVestingAccount !== void 0 && e.BaseVestingAccount.encode(N.baseVestingAccount, h.uint32(10).fork()).ldelim(), N.startTime !== BigInt(0) && h.uint32(16).int64(N.startTime);
      for (const P of N.vestingPeriods)
        e.Period.encode(P, h.uint32(26).fork()).ldelim();
      return h;
    },
    decode(N, h) {
      const P = N instanceof t.BinaryReader ? N : new t.BinaryReader(N);
      let b = h === void 0 ? P.len : P.pos + h;
      const c = U();
      for (; P.pos < b; ) {
        const l = P.uint32();
        switch (l >>> 3) {
          case 1:
            c.baseVestingAccount = e.BaseVestingAccount.decode(P, P.uint32());
            break;
          case 2:
            c.startTime = P.int64();
            break;
          case 3:
            c.vestingPeriods.push(e.Period.decode(P, P.uint32()));
            break;
          default:
            P.skipType(l & 7);
            break;
        }
      }
      return c;
    },
    fromJSON(N) {
      const h = U();
      return (0, i.isSet)(N.baseVestingAccount) && (h.baseVestingAccount = e.BaseVestingAccount.fromJSON(N.baseVestingAccount)), (0, i.isSet)(N.startTime) && (h.startTime = BigInt(N.startTime.toString())), Array.isArray(N == null ? void 0 : N.vestingPeriods) && (h.vestingPeriods = N.vestingPeriods.map((P) => e.Period.fromJSON(P))), h;
    },
    toJSON(N) {
      const h = {};
      return N.baseVestingAccount !== void 0 && (h.baseVestingAccount = N.baseVestingAccount ? e.BaseVestingAccount.toJSON(N.baseVestingAccount) : void 0), N.startTime !== void 0 && (h.startTime = (N.startTime || BigInt(0)).toString()), N.vestingPeriods ? h.vestingPeriods = N.vestingPeriods.map((P) => P ? e.Period.toJSON(P) : void 0) : h.vestingPeriods = [], h;
    },
    fromPartial(N) {
      var P;
      const h = U();
      return N.baseVestingAccount !== void 0 && N.baseVestingAccount !== null && (h.baseVestingAccount = e.BaseVestingAccount.fromPartial(N.baseVestingAccount)), N.startTime !== void 0 && N.startTime !== null && (h.startTime = BigInt(N.startTime.toString())), h.vestingPeriods = ((P = N.vestingPeriods) == null ? void 0 : P.map((b) => e.Period.fromPartial(b))) || [], h;
    }
  };
  function w() {
    return {
      baseVestingAccount: void 0
    };
  }
  e.PermanentLockedAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.PermanentLockedAccount",
    encode(N, h = t.BinaryWriter.create()) {
      return N.baseVestingAccount !== void 0 && e.BaseVestingAccount.encode(N.baseVestingAccount, h.uint32(10).fork()).ldelim(), h;
    },
    decode(N, h) {
      const P = N instanceof t.BinaryReader ? N : new t.BinaryReader(N);
      let b = h === void 0 ? P.len : P.pos + h;
      const c = w();
      for (; P.pos < b; ) {
        const l = P.uint32();
        switch (l >>> 3) {
          case 1:
            c.baseVestingAccount = e.BaseVestingAccount.decode(P, P.uint32());
            break;
          default:
            P.skipType(l & 7);
            break;
        }
      }
      return c;
    },
    fromJSON(N) {
      const h = w();
      return (0, i.isSet)(N.baseVestingAccount) && (h.baseVestingAccount = e.BaseVestingAccount.fromJSON(N.baseVestingAccount)), h;
    },
    toJSON(N) {
      const h = {};
      return N.baseVestingAccount !== void 0 && (h.baseVestingAccount = N.baseVestingAccount ? e.BaseVestingAccount.toJSON(N.baseVestingAccount) : void 0), h;
    },
    fromPartial(N) {
      const h = w();
      return N.baseVestingAccount !== void 0 && N.baseVestingAccount !== null && (h.baseVestingAccount = e.BaseVestingAccount.fromPartial(N.baseVestingAccount)), h;
    }
  };
})(td);
Object.defineProperty(Zr, "__esModule", { value: !0 });
Zr.accountFromAny = void 0;
const Dp = mt, Mp = Nt, Tr = an, jd = ji, li = td;
function eu(e) {
  return Dp.Uint64.fromString(e.toString());
}
function Dt(e) {
  const { address: n, pubKey: r, accountNumber: t, sequence: i } = e, f = (0, Mp.decodeOptionalPubkey)(r);
  return {
    address: n,
    pubkey: f,
    accountNumber: eu(t).toNumber(),
    sequence: eu(i).toNumber()
  };
}
function Hp(e) {
  var t, i, f, k, C, T, U;
  const { typeUrl: n, value: r } = e;
  switch (n) {
    case "/cosmos.auth.v1beta1.BaseAccount":
      return Dt(jd.BaseAccount.decode(r));
    case "/cosmos.auth.v1beta1.ModuleAccount": {
      const w = jd.ModuleAccount.decode(r).baseAccount;
      return (0, Tr.assert)(w), Dt(w);
    }
    case "/cosmos.vesting.v1beta1.BaseVestingAccount": {
      const w = (t = li.BaseVestingAccount.decode(r)) == null ? void 0 : t.baseAccount;
      return (0, Tr.assert)(w), Dt(w);
    }
    case "/cosmos.vesting.v1beta1.ContinuousVestingAccount": {
      const w = (f = (i = li.ContinuousVestingAccount.decode(r)) == null ? void 0 : i.baseVestingAccount) == null ? void 0 : f.baseAccount;
      return (0, Tr.assert)(w), Dt(w);
    }
    case "/cosmos.vesting.v1beta1.DelayedVestingAccount": {
      const w = (C = (k = li.DelayedVestingAccount.decode(r)) == null ? void 0 : k.baseVestingAccount) == null ? void 0 : C.baseAccount;
      return (0, Tr.assert)(w), Dt(w);
    }
    case "/cosmos.vesting.v1beta1.PeriodicVestingAccount": {
      const w = (U = (T = li.PeriodicVestingAccount.decode(r)) == null ? void 0 : T.baseVestingAccount) == null ? void 0 : U.baseAccount;
      return (0, Tr.assert)(w), Dt(w);
    }
    default:
      throw new Error(`Unsupported type: '${n}'`);
  }
}
Zr.accountFromAny = Hp;
var Yr = {};
Object.defineProperty(Yr, "__esModule", { value: !0 });
Yr.AminoTypes = void 0;
class qp {
  constructor(n) {
    this.register = n;
  }
  toAmino({ typeUrl: n, value: r }) {
    const t = this.register[n];
    if (!t)
      throw new Error(`Type URL '${n}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
    return {
      type: t.aminoType,
      value: t.toAmino(r)
    };
  }
  fromAmino({ type: n, value: r }) {
    const t = Object.entries(this.register).filter(([i, { aminoType: f }]) => f === n);
    switch (t.length) {
      case 0:
        throw new Error(`Amino type identifier '${n}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
      case 1: {
        const [i, f] = t[0];
        return {
          typeUrl: i,
          value: f.fromAmino(r)
        };
      }
      default:
        throw new Error(`Multiple types are registered with Amino type identifier '${n}': '` + t.map(([i, f]) => i).sort().join("', '") + "'. Thus fromAmino cannot be performed.");
    }
  }
}
Yr.AminoTypes = qp;
var Xr = {};
Object.defineProperty(Xr, "__esModule", { value: !0 });
Xr.fromTendermintEvent = void 0;
const nu = Ct;
function Vp(e) {
  return {
    type: e.type,
    attributes: e.attributes.map((n) => ({
      key: typeof n.key == "string" ? n.key : (0, nu.fromUtf8)(n.key, !0),
      value: typeof n.value == "string" ? n.value : (0, nu.fromUtf8)(n.value, !0)
    }))
  };
}
Xr.fromTendermintEvent = Vp;
var Ot = {};
Object.defineProperty(Ot, "__esModule", { value: !0 });
Ot.calculateFee = Ot.GasPrice = void 0;
const uc = mt, Qp = Nt;
function Wp(e) {
  if (e.length < 3 || e.length > 128)
    throw new Error("Denom must be between 3 and 128 characters");
}
class eo {
  constructor(n, r) {
    this.amount = n, this.denom = r;
  }
  /**
   * Parses a gas price formatted as `<amount><denom>`, e.g. `GasPrice.fromString("0.012utoken")`.
   *
   * The denom must match the Cosmos SDK 0.42 pattern (https://github.com/cosmos/cosmos-sdk/blob/v0.42.4/types/coin.go#L599-L601).
   * See `GasPrice` in @cosmjs/stargate for a more generic matcher.
   *
   * Separators are not yet supported.
   */
  static fromString(n) {
    const r = n.match(/^([0-9.]+)([a-z][a-z0-9]*)$/i);
    if (!r)
      throw new Error("Invalid gas price string");
    const [t, i, f] = r;
    Wp(f);
    const k = 18, C = uc.Decimal.fromUserInput(i, k);
    return new eo(C, f);
  }
  /**
   * Returns a string representation of this gas price, e.g. "0.025uatom".
   * This can be used as an input to `GasPrice.fromString`.
   */
  toString() {
    return this.amount.toString() + this.denom;
  }
}
Ot.GasPrice = eo;
function Fp(e, n) {
  const r = typeof n == "string" ? eo.fromString(n) : n, { denom: t, amount: i } = r, f = i.multiply(new uc.Uint53(e)).ceil().toString();
  return {
    amount: (0, Qp.coins)(f, t),
    gas: e.toString()
  };
}
Ot.calculateFee = Fp;
var Xe = {};
Object.defineProperty(Xe, "__esModule", { value: !0 });
Xe.findAttribute = Xe.parseRawLog = Xe.parseLogs = Xe.parseLog = Xe.parseEvent = Xe.parseAttribute = void 0;
const rd = an;
function cc(e) {
  if (!(0, rd.isNonNullObject)(e))
    throw new Error("Attribute must be a non-null object");
  const { key: n, value: r } = e;
  if (typeof n != "string" || !n)
    throw new Error("Attribute's key must be a non-empty string");
  if (typeof r != "string" && typeof r < "u")
    throw new Error("Attribute's value must be a string or unset");
  return {
    key: n,
    value: r || ""
  };
}
Xe.parseAttribute = cc;
function lc(e) {
  if (!(0, rd.isNonNullObject)(e))
    throw new Error("Event must be a non-null object");
  const { type: n, attributes: r } = e;
  if (typeof n != "string" || n === "")
    throw new Error("Event type must be a non-empty string");
  if (!Array.isArray(r))
    throw new Error("Event's attributes must be an array");
  return {
    type: n,
    attributes: r.map(cc)
  };
}
Xe.parseEvent = lc;
function fc(e) {
  if (!(0, rd.isNonNullObject)(e))
    throw new Error("Log must be a non-null object");
  const { msg_index: n, log: r, events: t } = e;
  if (typeof n != "number")
    throw new Error("Log's msg_index must be a number");
  if (typeof r != "string")
    throw new Error("Log's log must be a string");
  if (!Array.isArray(t))
    throw new Error("Log's events must be an array");
  return {
    msg_index: n,
    log: r,
    events: t.map(lc)
  };
}
Xe.parseLog = fc;
function pc(e) {
  if (!Array.isArray(e))
    throw new Error("Logs must be an array");
  return e.map(fc);
}
Xe.parseLogs = pc;
function Lp(e = "[]") {
  const n = JSON.parse(e).map(({ events: r }, t) => ({
    msg_index: t,
    events: r,
    log: ""
  }));
  return pc(n);
}
Xe.parseRawLog = Lp;
function Gp(e, n, r) {
  var f;
  const t = e.find(() => !0), i = (f = t == null ? void 0 : t.events.find((k) => k.type === n)) == null ? void 0 : f.attributes.find((k) => k.key === r);
  if (!i)
    throw new Error(`Could not find attribute '${r}' in first event of type '${n}' in first log.`);
  return i;
}
Xe.findAttribute = Gp;
var Qr = {}, no = {}, hc = {}, Ae = {};
Object.defineProperty(Ae, "__esModule", { value: !0 });
Ae.PageResponse = Ae.PageRequest = Ae.protobufPackage = void 0;
const $t = re, Tn = ie;
Ae.protobufPackage = "cosmos.base.query.v1beta1";
function Ha() {
  return {
    key: new Uint8Array(),
    offset: BigInt(0),
    limit: BigInt(0),
    countTotal: !1,
    reverse: !1
  };
}
Ae.PageRequest = {
  typeUrl: "/cosmos.base.query.v1beta1.PageRequest",
  encode(e, n = $t.BinaryWriter.create()) {
    return e.key.length !== 0 && n.uint32(10).bytes(e.key), e.offset !== BigInt(0) && n.uint32(16).uint64(e.offset), e.limit !== BigInt(0) && n.uint32(24).uint64(e.limit), e.countTotal === !0 && n.uint32(32).bool(e.countTotal), e.reverse === !0 && n.uint32(40).bool(e.reverse), n;
  },
  decode(e, n) {
    const r = e instanceof $t.BinaryReader ? e : new $t.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = Ha();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.key = r.bytes();
          break;
        case 2:
          i.offset = r.uint64();
          break;
        case 3:
          i.limit = r.uint64();
          break;
        case 4:
          i.countTotal = r.bool();
          break;
        case 5:
          i.reverse = r.bool();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = Ha();
    return (0, Tn.isSet)(e.key) && (n.key = (0, Tn.bytesFromBase64)(e.key)), (0, Tn.isSet)(e.offset) && (n.offset = BigInt(e.offset.toString())), (0, Tn.isSet)(e.limit) && (n.limit = BigInt(e.limit.toString())), (0, Tn.isSet)(e.countTotal) && (n.countTotal = !!e.countTotal), (0, Tn.isSet)(e.reverse) && (n.reverse = !!e.reverse), n;
  },
  toJSON(e) {
    const n = {};
    return e.key !== void 0 && (n.key = (0, Tn.base64FromBytes)(e.key !== void 0 ? e.key : new Uint8Array())), e.offset !== void 0 && (n.offset = (e.offset || BigInt(0)).toString()), e.limit !== void 0 && (n.limit = (e.limit || BigInt(0)).toString()), e.countTotal !== void 0 && (n.countTotal = e.countTotal), e.reverse !== void 0 && (n.reverse = e.reverse), n;
  },
  fromPartial(e) {
    const n = Ha();
    return n.key = e.key ?? new Uint8Array(), e.offset !== void 0 && e.offset !== null && (n.offset = BigInt(e.offset.toString())), e.limit !== void 0 && e.limit !== null && (n.limit = BigInt(e.limit.toString())), n.countTotal = e.countTotal ?? !1, n.reverse = e.reverse ?? !1, n;
  }
};
function qa() {
  return {
    nextKey: new Uint8Array(),
    total: BigInt(0)
  };
}
Ae.PageResponse = {
  typeUrl: "/cosmos.base.query.v1beta1.PageResponse",
  encode(e, n = $t.BinaryWriter.create()) {
    return e.nextKey.length !== 0 && n.uint32(10).bytes(e.nextKey), e.total !== BigInt(0) && n.uint32(16).uint64(e.total), n;
  },
  decode(e, n) {
    const r = e instanceof $t.BinaryReader ? e : new $t.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = qa();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.nextKey = r.bytes();
          break;
        case 2:
          i.total = r.uint64();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = qa();
    return (0, Tn.isSet)(e.nextKey) && (n.nextKey = (0, Tn.bytesFromBase64)(e.nextKey)), (0, Tn.isSet)(e.total) && (n.total = BigInt(e.total.toString())), n;
  },
  toJSON(e) {
    const n = {};
    return e.nextKey !== void 0 && (n.nextKey = (0, Tn.base64FromBytes)(e.nextKey !== void 0 ? e.nextKey : new Uint8Array())), e.total !== void 0 && (n.total = (e.total || BigInt(0)).toString()), n;
  },
  fromPartial(e) {
    const n = qa();
    return n.nextKey = e.nextKey ?? new Uint8Array(), e.total !== void 0 && e.total !== null && (n.total = BigInt(e.total.toString())), n;
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryAccountInfoResponse = e.QueryAccountInfoRequest = e.QueryAccountAddressByIDResponse = e.QueryAccountAddressByIDRequest = e.AddressStringToBytesResponse = e.AddressStringToBytesRequest = e.AddressBytesToStringResponse = e.AddressBytesToStringRequest = e.Bech32PrefixResponse = e.Bech32PrefixRequest = e.QueryModuleAccountByNameResponse = e.QueryModuleAccountByNameRequest = e.QueryModuleAccountsResponse = e.QueryModuleAccountsRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.QueryAccountResponse = e.QueryAccountRequest = e.QueryAccountsResponse = e.QueryAccountsRequest = e.protobufPackage = void 0;
  const n = Ae, r = Be, t = ji, i = re, f = ie;
  e.protobufPackage = "cosmos.auth.v1beta1";
  function k() {
    return {
      pagination: void 0
    };
  }
  e.QueryAccountsRequest = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountsRequest",
    encode(u, A = i.BinaryWriter.create()) {
      return u.pagination !== void 0 && n.PageRequest.encode(u.pagination, A.uint32(10).fork()).ldelim(), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = k();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.pagination = n.PageRequest.decode(R, R.uint32());
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = k();
      return (0, f.isSet)(u.pagination) && (A.pagination = n.PageRequest.fromJSON(u.pagination)), A;
    },
    toJSON(u) {
      const A = {};
      return u.pagination !== void 0 && (A.pagination = u.pagination ? n.PageRequest.toJSON(u.pagination) : void 0), A;
    },
    fromPartial(u) {
      const A = k();
      return u.pagination !== void 0 && u.pagination !== null && (A.pagination = n.PageRequest.fromPartial(u.pagination)), A;
    }
  };
  function C() {
    return {
      accounts: [],
      pagination: void 0
    };
  }
  e.QueryAccountsResponse = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountsResponse",
    encode(u, A = i.BinaryWriter.create()) {
      for (const R of u.accounts)
        r.Any.encode(R, A.uint32(10).fork()).ldelim();
      return u.pagination !== void 0 && n.PageResponse.encode(u.pagination, A.uint32(18).fork()).ldelim(), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = C();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.accounts.push(r.Any.decode(R, R.uint32()));
            break;
          case 2:
            D.pagination = n.PageResponse.decode(R, R.uint32());
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = C();
      return Array.isArray(u == null ? void 0 : u.accounts) && (A.accounts = u.accounts.map((R) => r.Any.fromJSON(R))), (0, f.isSet)(u.pagination) && (A.pagination = n.PageResponse.fromJSON(u.pagination)), A;
    },
    toJSON(u) {
      const A = {};
      return u.accounts ? A.accounts = u.accounts.map((R) => R ? r.Any.toJSON(R) : void 0) : A.accounts = [], u.pagination !== void 0 && (A.pagination = u.pagination ? n.PageResponse.toJSON(u.pagination) : void 0), A;
    },
    fromPartial(u) {
      var R;
      const A = C();
      return A.accounts = ((R = u.accounts) == null ? void 0 : R.map((v) => r.Any.fromPartial(v))) || [], u.pagination !== void 0 && u.pagination !== null && (A.pagination = n.PageResponse.fromPartial(u.pagination)), A;
    }
  };
  function T() {
    return {
      address: ""
    };
  }
  e.QueryAccountRequest = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountRequest",
    encode(u, A = i.BinaryWriter.create()) {
      return u.address !== "" && A.uint32(10).string(u.address), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = T();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.address = R.string();
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = T();
      return (0, f.isSet)(u.address) && (A.address = String(u.address)), A;
    },
    toJSON(u) {
      const A = {};
      return u.address !== void 0 && (A.address = u.address), A;
    },
    fromPartial(u) {
      const A = T();
      return A.address = u.address ?? "", A;
    }
  };
  function U() {
    return {
      account: void 0
    };
  }
  e.QueryAccountResponse = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountResponse",
    encode(u, A = i.BinaryWriter.create()) {
      return u.account !== void 0 && r.Any.encode(u.account, A.uint32(10).fork()).ldelim(), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = U();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.account = r.Any.decode(R, R.uint32());
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = U();
      return (0, f.isSet)(u.account) && (A.account = r.Any.fromJSON(u.account)), A;
    },
    toJSON(u) {
      const A = {};
      return u.account !== void 0 && (A.account = u.account ? r.Any.toJSON(u.account) : void 0), A;
    },
    fromPartial(u) {
      const A = U();
      return u.account !== void 0 && u.account !== null && (A.account = r.Any.fromPartial(u.account)), A;
    }
  };
  function w() {
    return {};
  }
  e.QueryParamsRequest = {
    typeUrl: "/cosmos.auth.v1beta1.QueryParamsRequest",
    encode(u, A = i.BinaryWriter.create()) {
      return A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = w();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      return w();
    },
    toJSON(u) {
      return {};
    },
    fromPartial(u) {
      return w();
    }
  };
  function N() {
    return {
      params: t.Params.fromPartial({})
    };
  }
  e.QueryParamsResponse = {
    typeUrl: "/cosmos.auth.v1beta1.QueryParamsResponse",
    encode(u, A = i.BinaryWriter.create()) {
      return u.params !== void 0 && t.Params.encode(u.params, A.uint32(10).fork()).ldelim(), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = N();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.params = t.Params.decode(R, R.uint32());
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = N();
      return (0, f.isSet)(u.params) && (A.params = t.Params.fromJSON(u.params)), A;
    },
    toJSON(u) {
      const A = {};
      return u.params !== void 0 && (A.params = u.params ? t.Params.toJSON(u.params) : void 0), A;
    },
    fromPartial(u) {
      const A = N();
      return u.params !== void 0 && u.params !== null && (A.params = t.Params.fromPartial(u.params)), A;
    }
  };
  function h() {
    return {};
  }
  e.QueryModuleAccountsRequest = {
    typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountsRequest",
    encode(u, A = i.BinaryWriter.create()) {
      return A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = h();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      return h();
    },
    toJSON(u) {
      return {};
    },
    fromPartial(u) {
      return h();
    }
  };
  function P() {
    return {
      accounts: []
    };
  }
  e.QueryModuleAccountsResponse = {
    typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountsResponse",
    encode(u, A = i.BinaryWriter.create()) {
      for (const R of u.accounts)
        r.Any.encode(R, A.uint32(10).fork()).ldelim();
      return A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = P();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.accounts.push(r.Any.decode(R, R.uint32()));
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = P();
      return Array.isArray(u == null ? void 0 : u.accounts) && (A.accounts = u.accounts.map((R) => r.Any.fromJSON(R))), A;
    },
    toJSON(u) {
      const A = {};
      return u.accounts ? A.accounts = u.accounts.map((R) => R ? r.Any.toJSON(R) : void 0) : A.accounts = [], A;
    },
    fromPartial(u) {
      var R;
      const A = P();
      return A.accounts = ((R = u.accounts) == null ? void 0 : R.map((v) => r.Any.fromPartial(v))) || [], A;
    }
  };
  function b() {
    return {
      name: ""
    };
  }
  e.QueryModuleAccountByNameRequest = {
    typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountByNameRequest",
    encode(u, A = i.BinaryWriter.create()) {
      return u.name !== "" && A.uint32(10).string(u.name), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = b();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.name = R.string();
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = b();
      return (0, f.isSet)(u.name) && (A.name = String(u.name)), A;
    },
    toJSON(u) {
      const A = {};
      return u.name !== void 0 && (A.name = u.name), A;
    },
    fromPartial(u) {
      const A = b();
      return A.name = u.name ?? "", A;
    }
  };
  function c() {
    return {
      account: void 0
    };
  }
  e.QueryModuleAccountByNameResponse = {
    typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountByNameResponse",
    encode(u, A = i.BinaryWriter.create()) {
      return u.account !== void 0 && r.Any.encode(u.account, A.uint32(10).fork()).ldelim(), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = c();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.account = r.Any.decode(R, R.uint32());
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = c();
      return (0, f.isSet)(u.account) && (A.account = r.Any.fromJSON(u.account)), A;
    },
    toJSON(u) {
      const A = {};
      return u.account !== void 0 && (A.account = u.account ? r.Any.toJSON(u.account) : void 0), A;
    },
    fromPartial(u) {
      const A = c();
      return u.account !== void 0 && u.account !== null && (A.account = r.Any.fromPartial(u.account)), A;
    }
  };
  function l() {
    return {};
  }
  e.Bech32PrefixRequest = {
    typeUrl: "/cosmos.auth.v1beta1.Bech32PrefixRequest",
    encode(u, A = i.BinaryWriter.create()) {
      return A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = l();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      return l();
    },
    toJSON(u) {
      return {};
    },
    fromPartial(u) {
      return l();
    }
  };
  function y() {
    return {
      bech32Prefix: ""
    };
  }
  e.Bech32PrefixResponse = {
    typeUrl: "/cosmos.auth.v1beta1.Bech32PrefixResponse",
    encode(u, A = i.BinaryWriter.create()) {
      return u.bech32Prefix !== "" && A.uint32(10).string(u.bech32Prefix), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = y();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.bech32Prefix = R.string();
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = y();
      return (0, f.isSet)(u.bech32Prefix) && (A.bech32Prefix = String(u.bech32Prefix)), A;
    },
    toJSON(u) {
      const A = {};
      return u.bech32Prefix !== void 0 && (A.bech32Prefix = u.bech32Prefix), A;
    },
    fromPartial(u) {
      const A = y();
      return A.bech32Prefix = u.bech32Prefix ?? "", A;
    }
  };
  function E() {
    return {
      addressBytes: new Uint8Array()
    };
  }
  e.AddressBytesToStringRequest = {
    typeUrl: "/cosmos.auth.v1beta1.AddressBytesToStringRequest",
    encode(u, A = i.BinaryWriter.create()) {
      return u.addressBytes.length !== 0 && A.uint32(10).bytes(u.addressBytes), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = E();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.addressBytes = R.bytes();
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = E();
      return (0, f.isSet)(u.addressBytes) && (A.addressBytes = (0, f.bytesFromBase64)(u.addressBytes)), A;
    },
    toJSON(u) {
      const A = {};
      return u.addressBytes !== void 0 && (A.addressBytes = (0, f.base64FromBytes)(u.addressBytes !== void 0 ? u.addressBytes : new Uint8Array())), A;
    },
    fromPartial(u) {
      const A = E();
      return A.addressBytes = u.addressBytes ?? new Uint8Array(), A;
    }
  };
  function J() {
    return {
      addressString: ""
    };
  }
  e.AddressBytesToStringResponse = {
    typeUrl: "/cosmos.auth.v1beta1.AddressBytesToStringResponse",
    encode(u, A = i.BinaryWriter.create()) {
      return u.addressString !== "" && A.uint32(10).string(u.addressString), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = J();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.addressString = R.string();
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = J();
      return (0, f.isSet)(u.addressString) && (A.addressString = String(u.addressString)), A;
    },
    toJSON(u) {
      const A = {};
      return u.addressString !== void 0 && (A.addressString = u.addressString), A;
    },
    fromPartial(u) {
      const A = J();
      return A.addressString = u.addressString ?? "", A;
    }
  };
  function _() {
    return {
      addressString: ""
    };
  }
  e.AddressStringToBytesRequest = {
    typeUrl: "/cosmos.auth.v1beta1.AddressStringToBytesRequest",
    encode(u, A = i.BinaryWriter.create()) {
      return u.addressString !== "" && A.uint32(10).string(u.addressString), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = _();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.addressString = R.string();
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = _();
      return (0, f.isSet)(u.addressString) && (A.addressString = String(u.addressString)), A;
    },
    toJSON(u) {
      const A = {};
      return u.addressString !== void 0 && (A.addressString = u.addressString), A;
    },
    fromPartial(u) {
      const A = _();
      return A.addressString = u.addressString ?? "", A;
    }
  };
  function V() {
    return {
      addressBytes: new Uint8Array()
    };
  }
  e.AddressStringToBytesResponse = {
    typeUrl: "/cosmos.auth.v1beta1.AddressStringToBytesResponse",
    encode(u, A = i.BinaryWriter.create()) {
      return u.addressBytes.length !== 0 && A.uint32(10).bytes(u.addressBytes), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = V();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.addressBytes = R.bytes();
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = V();
      return (0, f.isSet)(u.addressBytes) && (A.addressBytes = (0, f.bytesFromBase64)(u.addressBytes)), A;
    },
    toJSON(u) {
      const A = {};
      return u.addressBytes !== void 0 && (A.addressBytes = (0, f.base64FromBytes)(u.addressBytes !== void 0 ? u.addressBytes : new Uint8Array())), A;
    },
    fromPartial(u) {
      const A = V();
      return A.addressBytes = u.addressBytes ?? new Uint8Array(), A;
    }
  };
  function o() {
    return {
      id: BigInt(0),
      accountId: BigInt(0)
    };
  }
  e.QueryAccountAddressByIDRequest = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountAddressByIDRequest",
    encode(u, A = i.BinaryWriter.create()) {
      return u.id !== BigInt(0) && A.uint32(8).int64(u.id), u.accountId !== BigInt(0) && A.uint32(16).uint64(u.accountId), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = o();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.id = R.int64();
            break;
          case 2:
            D.accountId = R.uint64();
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = o();
      return (0, f.isSet)(u.id) && (A.id = BigInt(u.id.toString())), (0, f.isSet)(u.accountId) && (A.accountId = BigInt(u.accountId.toString())), A;
    },
    toJSON(u) {
      const A = {};
      return u.id !== void 0 && (A.id = (u.id || BigInt(0)).toString()), u.accountId !== void 0 && (A.accountId = (u.accountId || BigInt(0)).toString()), A;
    },
    fromPartial(u) {
      const A = o();
      return u.id !== void 0 && u.id !== null && (A.id = BigInt(u.id.toString())), u.accountId !== void 0 && u.accountId !== null && (A.accountId = BigInt(u.accountId.toString())), A;
    }
  };
  function p() {
    return {
      accountAddress: ""
    };
  }
  e.QueryAccountAddressByIDResponse = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountAddressByIDResponse",
    encode(u, A = i.BinaryWriter.create()) {
      return u.accountAddress !== "" && A.uint32(10).string(u.accountAddress), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = p();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.accountAddress = R.string();
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = p();
      return (0, f.isSet)(u.accountAddress) && (A.accountAddress = String(u.accountAddress)), A;
    },
    toJSON(u) {
      const A = {};
      return u.accountAddress !== void 0 && (A.accountAddress = u.accountAddress), A;
    },
    fromPartial(u) {
      const A = p();
      return A.accountAddress = u.accountAddress ?? "", A;
    }
  };
  function I() {
    return {
      address: ""
    };
  }
  e.QueryAccountInfoRequest = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountInfoRequest",
    encode(u, A = i.BinaryWriter.create()) {
      return u.address !== "" && A.uint32(10).string(u.address), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = I();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.address = R.string();
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = I();
      return (0, f.isSet)(u.address) && (A.address = String(u.address)), A;
    },
    toJSON(u) {
      const A = {};
      return u.address !== void 0 && (A.address = u.address), A;
    },
    fromPartial(u) {
      const A = I();
      return A.address = u.address ?? "", A;
    }
  };
  function q() {
    return {
      info: void 0
    };
  }
  e.QueryAccountInfoResponse = {
    typeUrl: "/cosmos.auth.v1beta1.QueryAccountInfoResponse",
    encode(u, A = i.BinaryWriter.create()) {
      return u.info !== void 0 && t.BaseAccount.encode(u.info, A.uint32(10).fork()).ldelim(), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = q();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.info = t.BaseAccount.decode(R, R.uint32());
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = q();
      return (0, f.isSet)(u.info) && (A.info = t.BaseAccount.fromJSON(u.info)), A;
    },
    toJSON(u) {
      const A = {};
      return u.info !== void 0 && (A.info = u.info ? t.BaseAccount.toJSON(u.info) : void 0), A;
    },
    fromPartial(u) {
      const A = q();
      return u.info !== void 0 && u.info !== null && (A.info = t.BaseAccount.fromPartial(u.info)), A;
    }
  };
  class s {
    constructor(A) {
      this.rpc = A, this.Accounts = this.Accounts.bind(this), this.Account = this.Account.bind(this), this.AccountAddressByID = this.AccountAddressByID.bind(this), this.Params = this.Params.bind(this), this.ModuleAccounts = this.ModuleAccounts.bind(this), this.ModuleAccountByName = this.ModuleAccountByName.bind(this), this.Bech32Prefix = this.Bech32Prefix.bind(this), this.AddressBytesToString = this.AddressBytesToString.bind(this), this.AddressStringToBytes = this.AddressStringToBytes.bind(this), this.AccountInfo = this.AccountInfo.bind(this);
    }
    Accounts(A = {
      pagination: n.PageRequest.fromPartial({})
    }) {
      const R = e.QueryAccountsRequest.encode(A).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "Accounts", R).then((D) => e.QueryAccountsResponse.decode(new i.BinaryReader(D)));
    }
    Account(A) {
      const R = e.QueryAccountRequest.encode(A).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "Account", R).then((D) => e.QueryAccountResponse.decode(new i.BinaryReader(D)));
    }
    AccountAddressByID(A) {
      const R = e.QueryAccountAddressByIDRequest.encode(A).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "AccountAddressByID", R).then((D) => e.QueryAccountAddressByIDResponse.decode(new i.BinaryReader(D)));
    }
    Params(A = {}) {
      const R = e.QueryParamsRequest.encode(A).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "Params", R).then((D) => e.QueryParamsResponse.decode(new i.BinaryReader(D)));
    }
    ModuleAccounts(A = {}) {
      const R = e.QueryModuleAccountsRequest.encode(A).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "ModuleAccounts", R).then((D) => e.QueryModuleAccountsResponse.decode(new i.BinaryReader(D)));
    }
    ModuleAccountByName(A) {
      const R = e.QueryModuleAccountByNameRequest.encode(A).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "ModuleAccountByName", R).then((D) => e.QueryModuleAccountByNameResponse.decode(new i.BinaryReader(D)));
    }
    Bech32Prefix(A = {}) {
      const R = e.Bech32PrefixRequest.encode(A).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "Bech32Prefix", R).then((D) => e.Bech32PrefixResponse.decode(new i.BinaryReader(D)));
    }
    AddressBytesToString(A) {
      const R = e.AddressBytesToStringRequest.encode(A).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "AddressBytesToString", R).then((D) => e.AddressBytesToStringResponse.decode(new i.BinaryReader(D)));
    }
    AddressStringToBytes(A) {
      const R = e.AddressStringToBytesRequest.encode(A).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "AddressStringToBytes", R).then((D) => e.AddressStringToBytesResponse.decode(new i.BinaryReader(D)));
    }
    AccountInfo(A) {
      const R = e.QueryAccountInfoRequest.encode(A).finish();
      return this.rpc.request("cosmos.auth.v1beta1.Query", "AccountInfo", R).then((D) => e.QueryAccountInfoResponse.decode(new i.BinaryReader(D)));
    }
  }
  e.QueryClientImpl = s;
})(hc);
var Ge = {}, to = {}, yc = {}, mc = {}, Va = {}, Qa, tu;
function $p() {
  if (tu)
    return Qa;
  tu = 1, Qa = n;
  var e = wt();
  function n(f, k) {
    this.lo = f >>> 0, this.hi = k >>> 0;
  }
  var r = n.zero = new n(0, 0);
  r.toNumber = function() {
    return 0;
  }, r.zzEncode = r.zzDecode = function() {
    return this;
  }, r.length = function() {
    return 1;
  };
  var t = n.zeroHash = "\0\0\0\0\0\0\0\0";
  n.fromNumber = function(k) {
    if (k === 0)
      return r;
    var C = k < 0;
    C && (k = -k);
    var T = k >>> 0, U = (k - T) / 4294967296 >>> 0;
    return C && (U = ~U >>> 0, T = ~T >>> 0, ++T > 4294967295 && (T = 0, ++U > 4294967295 && (U = 0))), new n(T, U);
  }, n.from = function(k) {
    if (typeof k == "number")
      return n.fromNumber(k);
    if (e.isString(k))
      if (e.Long)
        k = e.Long.fromString(k);
      else
        return n.fromNumber(parseInt(k, 10));
    return k.low || k.high ? new n(k.low >>> 0, k.high >>> 0) : r;
  }, n.prototype.toNumber = function(k) {
    if (!k && this.hi >>> 31) {
      var C = ~this.lo + 1 >>> 0, T = ~this.hi >>> 0;
      return C || (T = T + 1 >>> 0), -(C + T * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  }, n.prototype.toLong = function(k) {
    return e.Long ? new e.Long(this.lo | 0, this.hi | 0, !!k) : { low: this.lo | 0, high: this.hi | 0, unsigned: !!k };
  };
  var i = String.prototype.charCodeAt;
  return n.fromHash = function(k) {
    return k === t ? r : new n(
      (i.call(k, 0) | i.call(k, 1) << 8 | i.call(k, 2) << 16 | i.call(k, 3) << 24) >>> 0,
      (i.call(k, 4) | i.call(k, 5) << 8 | i.call(k, 6) << 16 | i.call(k, 7) << 24) >>> 0
    );
  }, n.prototype.toHash = function() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  }, n.prototype.zzEncode = function() {
    var k = this.hi >> 31;
    return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ k) >>> 0, this.lo = (this.lo << 1 ^ k) >>> 0, this;
  }, n.prototype.zzDecode = function() {
    var k = -(this.lo & 1);
    return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ k) >>> 0, this.hi = (this.hi >>> 1 ^ k) >>> 0, this;
  }, n.prototype.length = function() {
    var k = this.lo, C = (this.lo >>> 28 | this.hi << 4) >>> 0, T = this.hi >>> 24;
    return T === 0 ? C === 0 ? k < 16384 ? k < 128 ? 1 : 2 : k < 2097152 ? 3 : 4 : C < 16384 ? C < 128 ? 5 : 6 : C < 2097152 ? 7 : 8 : T < 128 ? 9 : 10;
  }, Qa;
}
var ru;
function wt() {
  return ru || (ru = 1, function(e) {
    var n = e;
    n.asPromise = Tp, n.base64 = Cp, n.EventEmitter = Np, n.float = wp, n.inquire = _p, n.utf8 = Ep, n.pool = Jp, n.LongBits = $p(), n.isNode = !!(typeof j < "u" && j && j.process && j.process.versions && j.process.versions.node), n.global = n.isNode && j || typeof window < "u" && window || typeof self < "u" && self || j, n.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    ), n.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    ), n.isInteger = Number.isInteger || /* istanbul ignore next */
    function(f) {
      return typeof f == "number" && isFinite(f) && Math.floor(f) === f;
    }, n.isString = function(f) {
      return typeof f == "string" || f instanceof String;
    }, n.isObject = function(f) {
      return f && typeof f == "object";
    }, n.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    n.isSet = function(f, k) {
      var C = f[k];
      return C != null && f.hasOwnProperty(k) ? typeof C != "object" || (Array.isArray(C) ? C.length : Object.keys(C).length) > 0 : !1;
    }, n.Buffer = function() {
      try {
        var i = n.inquire("buffer").Buffer;
        return i.prototype.utf8Write ? i : (
          /* istanbul ignore next */
          null
        );
      } catch {
        return null;
      }
    }(), n._Buffer_from = null, n._Buffer_allocUnsafe = null, n.newBuffer = function(f) {
      return typeof f == "number" ? n.Buffer ? n._Buffer_allocUnsafe(f) : new n.Array(f) : n.Buffer ? n._Buffer_from(f) : typeof Uint8Array > "u" ? f : new Uint8Array(f);
    }, n.Array = typeof Uint8Array < "u" ? Uint8Array : Array, n.Long = /* istanbul ignore next */
    n.global.dcodeIO && /* istanbul ignore next */
    n.global.dcodeIO.Long || /* istanbul ignore next */
    n.global.Long || n.inquire("long"), n.key2Re = /^true|false|0|1$/, n.key32Re = /^-?(?:0|[1-9][0-9]*)$/, n.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, n.longToHash = function(f) {
      return f ? n.LongBits.from(f).toHash() : n.LongBits.zeroHash;
    }, n.longFromHash = function(f, k) {
      var C = n.LongBits.fromHash(f);
      return n.Long ? n.Long.fromBits(C.lo, C.hi, k) : C.toNumber(!!k);
    };
    function r(i, f, k) {
      for (var C = Object.keys(f), T = 0; T < C.length; ++T)
        (i[C[T]] === void 0 || !k) && (i[C[T]] = f[C[T]]);
      return i;
    }
    n.merge = r, n.lcFirst = function(f) {
      return f.charAt(0).toLowerCase() + f.substring(1);
    };
    function t(i) {
      function f(k, C) {
        if (!(this instanceof f))
          return new f(k, C);
        Object.defineProperty(this, "message", { get: function() {
          return k;
        } }), Error.captureStackTrace ? Error.captureStackTrace(this, f) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), C && r(this, C);
      }
      return (f.prototype = Object.create(Error.prototype)).constructor = f, Object.defineProperty(f.prototype, "name", { get: function() {
        return i;
      } }), f.prototype.toString = function() {
        return this.name + ": " + this.message;
      }, f;
    }
    n.newError = t, n.ProtocolError = t("ProtocolError"), n.oneOfGetter = function(f) {
      for (var k = {}, C = 0; C < f.length; ++C)
        k[f[C]] = 1;
      return function() {
        for (var T = Object.keys(this), U = T.length - 1; U > -1; --U)
          if (k[T[U]] === 1 && this[T[U]] !== void 0 && this[T[U]] !== null)
            return T[U];
      };
    }, n.oneOfSetter = function(f) {
      return function(k) {
        for (var C = 0; C < f.length; ++C)
          f[C] !== k && delete this[f[C]];
      };
    }, n.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: !0
    }, n._configure = function() {
      var i = n.Buffer;
      if (!i) {
        n._Buffer_from = n._Buffer_allocUnsafe = null;
        return;
      }
      n._Buffer_from = i.from !== Uint8Array.from && i.from || /* istanbul ignore next */
      function(k, C) {
        return new i(k, C);
      }, n._Buffer_allocUnsafe = i.allocUnsafe || /* istanbul ignore next */
      function(k) {
        return new i(k);
      };
    };
  }(Va)), Va;
}
var gc = ke, Bn = wt(), ws, ro = Bn.LongBits, iu = Bn.base64, ou = Bn.utf8;
function jr(e, n, r) {
  this.fn = e, this.len = n, this.next = void 0, this.val = r;
}
function id() {
}
function zp(e) {
  this.head = e.head, this.tail = e.tail, this.len = e.len, this.next = e.states;
}
function ke() {
  this.len = 0, this.head = new jr(id, 0, 0), this.tail = this.head, this.states = null;
}
var Sc = function() {
  return Bn.Buffer ? function() {
    return (ke.create = function() {
      return new ws();
    })();
  } : function() {
    return new ke();
  };
};
ke.create = Sc();
ke.alloc = function(n) {
  return new Bn.Array(n);
};
Bn.Array !== Array && (ke.alloc = Bn.pool(ke.alloc, Bn.Array.prototype.subarray));
ke.prototype._push = function(n, r, t) {
  return this.tail = this.tail.next = new jr(n, r, t), this.len += r, this;
};
function od(e, n, r) {
  n[r] = e & 255;
}
function Kp(e, n, r) {
  for (; e > 127; )
    n[r++] = e & 127 | 128, e >>>= 7;
  n[r] = e;
}
function ad(e, n) {
  this.len = e, this.next = void 0, this.val = n;
}
ad.prototype = Object.create(jr.prototype);
ad.prototype.fn = Kp;
ke.prototype.uint32 = function(n) {
  return this.len += (this.tail = this.tail.next = new ad(
    (n = n >>> 0) < 128 ? 1 : n < 16384 ? 2 : n < 2097152 ? 3 : n < 268435456 ? 4 : 5,
    n
  )).len, this;
};
ke.prototype.int32 = function(n) {
  return n < 0 ? this._push(sd, 10, ro.fromNumber(n)) : this.uint32(n);
};
ke.prototype.sint32 = function(n) {
  return this.uint32((n << 1 ^ n >> 31) >>> 0);
};
function sd(e, n, r) {
  for (; e.hi; )
    n[r++] = e.lo & 127 | 128, e.lo = (e.lo >>> 7 | e.hi << 25) >>> 0, e.hi >>>= 7;
  for (; e.lo > 127; )
    n[r++] = e.lo & 127 | 128, e.lo = e.lo >>> 7;
  n[r++] = e.lo;
}
ke.prototype.uint64 = function(n) {
  var r = ro.from(n);
  return this._push(sd, r.length(), r);
};
ke.prototype.int64 = ke.prototype.uint64;
ke.prototype.sint64 = function(n) {
  var r = ro.from(n).zzEncode();
  return this._push(sd, r.length(), r);
};
ke.prototype.bool = function(n) {
  return this._push(od, 1, n ? 1 : 0);
};
function _s(e, n, r) {
  n[r] = e & 255, n[r + 1] = e >>> 8 & 255, n[r + 2] = e >>> 16 & 255, n[r + 3] = e >>> 24;
}
ke.prototype.fixed32 = function(n) {
  return this._push(_s, 4, n >>> 0);
};
ke.prototype.sfixed32 = ke.prototype.fixed32;
ke.prototype.fixed64 = function(n) {
  var r = ro.from(n);
  return this._push(_s, 4, r.lo)._push(_s, 4, r.hi);
};
ke.prototype.sfixed64 = ke.prototype.fixed64;
ke.prototype.float = function(n) {
  return this._push(Bn.float.writeFloatLE, 4, n);
};
ke.prototype.double = function(n) {
  return this._push(Bn.float.writeDoubleLE, 8, n);
};
var xp = Bn.Array.prototype.set ? function(n, r, t) {
  r.set(n, t);
} : function(n, r, t) {
  for (var i = 0; i < n.length; ++i)
    r[t + i] = n[i];
};
ke.prototype.bytes = function(n) {
  var r = n.length >>> 0;
  if (!r)
    return this._push(od, 1, 0);
  if (Bn.isString(n)) {
    var t = ke.alloc(r = iu.length(n));
    iu.decode(n, t, 0), n = t;
  }
  return this.uint32(r)._push(xp, r, n);
};
ke.prototype.string = function(n) {
  var r = ou.length(n);
  return r ? this.uint32(r)._push(ou.write, r, n) : this._push(od, 1, 0);
};
ke.prototype.fork = function() {
  return this.states = new zp(this), this.head = this.tail = new jr(id, 0, 0), this.len = 0, this;
};
ke.prototype.reset = function() {
  return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new jr(id, 0, 0), this.len = 0), this;
};
ke.prototype.ldelim = function() {
  var n = this.head, r = this.tail, t = this.len;
  return this.reset().uint32(t), t && (this.tail.next = n.next, this.tail = r, this.len += t), this;
};
ke.prototype.finish = function() {
  for (var n = this.head.next, r = this.constructor.alloc(this.len), t = 0; n; )
    n.fn(n.val, r, t), t += n.len, n = n.next;
  return r;
};
ke._configure = function(e) {
  ws = e, ke.create = Sc(), ws._configure();
};
var Zp = Ln, kc = gc;
(Ln.prototype = Object.create(kc.prototype)).constructor = Ln;
var it = wt();
function Ln() {
  kc.call(this);
}
Ln._configure = function() {
  Ln.alloc = it._Buffer_allocUnsafe, Ln.writeBytesBuffer = it.Buffer && it.Buffer.prototype instanceof Uint8Array && it.Buffer.prototype.set.name === "set" ? function(n, r, t) {
    r.set(n, t);
  } : function(n, r, t) {
    if (n.copy)
      n.copy(r, t, 0, n.length);
    else
      for (var i = 0; i < n.length; )
        r[t++] = n[i++];
  };
};
Ln.prototype.bytes = function(n) {
  it.isString(n) && (n = it._Buffer_from(n, "base64"));
  var r = n.length >>> 0;
  return this.uint32(r), r && this._push(Ln.writeBytesBuffer, r, n), this;
};
function Yp(e, n, r) {
  e.length < 40 ? it.utf8.write(e, n, r) : n.utf8Write ? n.utf8Write(e, r) : n.write(e, r);
}
Ln.prototype.string = function(n) {
  var r = it.Buffer.byteLength(n);
  return this.uint32(r), r && this._push(Yp, r, n), this;
};
Ln._configure();
var Pc = Ie, Gn = wt(), Es, vc = Gn.LongBits, Xp = Gn.utf8;
function En(e, n) {
  return RangeError("index out of range: " + e.pos + " + " + (n || 1) + " > " + e.len);
}
function Ie(e) {
  this.buf = e, this.pos = 0, this.len = e.length;
}
var au = typeof Uint8Array < "u" ? function(n) {
  if (n instanceof Uint8Array || Array.isArray(n))
    return new Ie(n);
  throw Error("illegal buffer");
} : function(n) {
  if (Array.isArray(n))
    return new Ie(n);
  throw Error("illegal buffer");
}, Rc = function() {
  return Gn.Buffer ? function(r) {
    return (Ie.create = function(i) {
      return Gn.Buffer.isBuffer(i) ? new Es(i) : au(i);
    })(r);
  } : au;
};
Ie.create = Rc();
Ie.prototype._slice = Gn.Array.prototype.subarray || /* istanbul ignore next */
Gn.Array.prototype.slice;
Ie.prototype.uint32 = function() {
  var n = 4294967295;
  return function() {
    if (n = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (n = (n | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (n = (n | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (n = (n | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (n = (n | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128))
      return n;
    if ((this.pos += 5) > this.len)
      throw this.pos = this.len, En(this, 10);
    return n;
  };
}();
Ie.prototype.int32 = function() {
  return this.uint32() | 0;
};
Ie.prototype.sint32 = function() {
  var n = this.uint32();
  return n >>> 1 ^ -(n & 1) | 0;
};
function Wa() {
  var e = new vc(0, 0), n = 0;
  if (this.len - this.pos > 4) {
    for (; n < 4; ++n)
      if (e.lo = (e.lo | (this.buf[this.pos] & 127) << n * 7) >>> 0, this.buf[this.pos++] < 128)
        return e;
    if (e.lo = (e.lo | (this.buf[this.pos] & 127) << 28) >>> 0, e.hi = (e.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128)
      return e;
    n = 0;
  } else {
    for (; n < 3; ++n) {
      if (this.pos >= this.len)
        throw En(this);
      if (e.lo = (e.lo | (this.buf[this.pos] & 127) << n * 7) >>> 0, this.buf[this.pos++] < 128)
        return e;
    }
    return e.lo = (e.lo | (this.buf[this.pos++] & 127) << n * 7) >>> 0, e;
  }
  if (this.len - this.pos > 4) {
    for (; n < 5; ++n)
      if (e.hi = (e.hi | (this.buf[this.pos] & 127) << n * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return e;
  } else
    for (; n < 5; ++n) {
      if (this.pos >= this.len)
        throw En(this);
      if (e.hi = (e.hi | (this.buf[this.pos] & 127) << n * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return e;
    }
  throw Error("invalid varint encoding");
}
Ie.prototype.bool = function() {
  return this.uint32() !== 0;
};
function qi(e, n) {
  return (e[n - 4] | e[n - 3] << 8 | e[n - 2] << 16 | e[n - 1] << 24) >>> 0;
}
Ie.prototype.fixed32 = function() {
  if (this.pos + 4 > this.len)
    throw En(this, 4);
  return qi(this.buf, this.pos += 4);
};
Ie.prototype.sfixed32 = function() {
  if (this.pos + 4 > this.len)
    throw En(this, 4);
  return qi(this.buf, this.pos += 4) | 0;
};
function su() {
  if (this.pos + 8 > this.len)
    throw En(this, 8);
  return new vc(qi(this.buf, this.pos += 4), qi(this.buf, this.pos += 4));
}
Ie.prototype.float = function() {
  if (this.pos + 4 > this.len)
    throw En(this, 4);
  var n = Gn.float.readFloatLE(this.buf, this.pos);
  return this.pos += 4, n;
};
Ie.prototype.double = function() {
  if (this.pos + 8 > this.len)
    throw En(this, 4);
  var n = Gn.float.readDoubleLE(this.buf, this.pos);
  return this.pos += 8, n;
};
Ie.prototype.bytes = function() {
  var n = this.uint32(), r = this.pos, t = this.pos + n;
  if (t > this.len)
    throw En(this, n);
  return this.pos += n, Array.isArray(this.buf) ? this.buf.slice(r, t) : r === t ? new this.buf.constructor(0) : this._slice.call(this.buf, r, t);
};
Ie.prototype.string = function() {
  var n = this.bytes();
  return Xp.read(n, 0, n.length);
};
Ie.prototype.skip = function(n) {
  if (typeof n == "number") {
    if (this.pos + n > this.len)
      throw En(this, n);
    this.pos += n;
  } else
    do
      if (this.pos >= this.len)
        throw En(this);
    while (this.buf[this.pos++] & 128);
  return this;
};
Ie.prototype.skipType = function(e) {
  switch (e) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      for (; (e = this.uint32() & 7) !== 4; )
        this.skipType(e);
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + e + " at offset " + this.pos);
  }
  return this;
};
Ie._configure = function(e) {
  Es = e, Ie.create = Rc(), Es._configure();
  var n = Gn.Long ? "toLong" : (
    /* istanbul ignore next */
    "toNumber"
  );
  Gn.merge(Ie.prototype, {
    int64: function() {
      return Wa.call(this)[n](!1);
    },
    uint64: function() {
      return Wa.call(this)[n](!0);
    },
    sint64: function() {
      return Wa.call(this).zzDecode()[n](!1);
    },
    fixed64: function() {
      return su.call(this)[n](!0);
    },
    sfixed64: function() {
      return su.call(this)[n](!1);
    }
  });
};
var jp = bt, Bc = Pc;
(bt.prototype = Object.create(Bc.prototype)).constructor = bt;
var du = wt();
function bt(e) {
  Bc.call(this, e);
}
bt._configure = function() {
  du.Buffer && (bt.prototype._slice = du.Buffer.prototype.slice);
};
bt.prototype.string = function() {
  var n = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + n, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + n, this.len));
};
bt._configure();
var Oc = {}, eh = Wr, dd = wt();
(Wr.prototype = Object.create(dd.EventEmitter.prototype)).constructor = Wr;
function Wr(e, n, r) {
  if (typeof e != "function")
    throw TypeError("rpcImpl must be a function");
  dd.EventEmitter.call(this), this.rpcImpl = e, this.requestDelimited = !!n, this.responseDelimited = !!r;
}
Wr.prototype.rpcCall = function e(n, r, t, i, f) {
  if (!i)
    throw TypeError("request must be specified");
  var k = this;
  if (!f)
    return dd.asPromise(e, k, n, r, t, i);
  if (!k.rpcImpl) {
    setTimeout(function() {
      f(Error("already ended"));
    }, 0);
    return;
  }
  try {
    return k.rpcImpl(
      n,
      r[k.requestDelimited ? "encodeDelimited" : "encode"](i).finish(),
      function(T, U) {
        if (T)
          return k.emit("error", T, n), f(T);
        if (U === null) {
          k.end(
            /* endedByRPC */
            !0
          );
          return;
        }
        if (!(U instanceof t))
          try {
            U = t[k.responseDelimited ? "decodeDelimited" : "decode"](U);
          } catch (w) {
            return k.emit("error", w, n), f(w);
          }
        return k.emit("data", U, n), f(null, U);
      }
    );
  } catch (C) {
    k.emit("error", C, n), setTimeout(function() {
      f(C);
    }, 0);
    return;
  }
};
Wr.prototype.end = function(n) {
  return this.rpcImpl && (n || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
};
(function(e) {
  var n = e;
  n.Service = eh;
})(Oc);
var nh = {};
(function(e) {
  var n = e;
  n.build = "minimal", n.Writer = gc, n.BufferWriter = Zp, n.Reader = Pc, n.BufferReader = jp, n.util = wt(), n.rpc = Oc, n.roots = nh, n.configure = r;
  function r() {
    n.util._configure(), n.Writer._configure(n.BufferWriter), n.Reader._configure(n.BufferReader);
  }
  r();
})(mc);
var th = mc, we = th, oe = we.Reader, sn = we.Writer, te = we.util, $ = we.roots.default || (we.roots.default = {});
$.ics23 = function() {
  var e = {};
  return e.HashOp = function() {
    var n = {}, r = Object.create(n);
    return r[n[0] = "NO_HASH"] = 0, r[n[1] = "SHA256"] = 1, r[n[2] = "SHA512"] = 2, r[n[3] = "KECCAK"] = 3, r[n[4] = "RIPEMD160"] = 4, r[n[5] = "BITCOIN"] = 5, r[n[6] = "SHA512_256"] = 6, r;
  }(), e.LengthOp = function() {
    var n = {}, r = Object.create(n);
    return r[n[0] = "NO_PREFIX"] = 0, r[n[1] = "VAR_PROTO"] = 1, r[n[2] = "VAR_RLP"] = 2, r[n[3] = "FIXED32_BIG"] = 3, r[n[4] = "FIXED32_LITTLE"] = 4, r[n[5] = "FIXED64_BIG"] = 5, r[n[6] = "FIXED64_LITTLE"] = 6, r[n[7] = "REQUIRE_32_BYTES"] = 7, r[n[8] = "REQUIRE_64_BYTES"] = 8, r;
  }(), e.ExistenceProof = function() {
    function n(r) {
      if (this.path = [], r)
        for (var t = Object.keys(r), i = 0; i < t.length; ++i)
          r[t[i]] != null && (this[t[i]] = r[t[i]]);
    }
    return n.prototype.key = te.newBuffer([]), n.prototype.value = te.newBuffer([]), n.prototype.leaf = null, n.prototype.path = te.emptyArray, n.create = function(t) {
      return new n(t);
    }, n.encode = function(t, i) {
      if (i || (i = sn.create()), t.key != null && t.hasOwnProperty("key") && i.uint32(
        /* id 1, wireType 2 =*/
        10
      ).bytes(t.key), t.value != null && t.hasOwnProperty("value") && i.uint32(
        /* id 2, wireType 2 =*/
        18
      ).bytes(t.value), t.leaf != null && t.hasOwnProperty("leaf") && $.ics23.LeafOp.encode(t.leaf, i.uint32(
        /* id 3, wireType 2 =*/
        26
      ).fork()).ldelim(), t.path != null && t.path.length)
        for (var f = 0; f < t.path.length; ++f)
          $.ics23.InnerOp.encode(t.path[f], i.uint32(
            /* id 4, wireType 2 =*/
            34
          ).fork()).ldelim();
      return i;
    }, n.encodeDelimited = function(t, i) {
      return this.encode(t, i).ldelim();
    }, n.decode = function(t, i) {
      t instanceof oe || (t = oe.create(t));
      for (var f = i === void 0 ? t.len : t.pos + i, k = new $.ics23.ExistenceProof(); t.pos < f; ) {
        var C = t.uint32();
        switch (C >>> 3) {
          case 1:
            k.key = t.bytes();
            break;
          case 2:
            k.value = t.bytes();
            break;
          case 3:
            k.leaf = $.ics23.LeafOp.decode(t, t.uint32());
            break;
          case 4:
            k.path && k.path.length || (k.path = []), k.path.push($.ics23.InnerOp.decode(t, t.uint32()));
            break;
          default:
            t.skipType(C & 7);
            break;
        }
      }
      return k;
    }, n.decodeDelimited = function(t) {
      return t instanceof oe || (t = new oe(t)), this.decode(t, t.uint32());
    }, n.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.key != null && t.hasOwnProperty("key") && !(t.key && typeof t.key.length == "number" || te.isString(t.key)))
        return "key: buffer expected";
      if (t.value != null && t.hasOwnProperty("value") && !(t.value && typeof t.value.length == "number" || te.isString(t.value)))
        return "value: buffer expected";
      if (t.leaf != null && t.hasOwnProperty("leaf")) {
        var i = $.ics23.LeafOp.verify(t.leaf);
        if (i)
          return "leaf." + i;
      }
      if (t.path != null && t.hasOwnProperty("path")) {
        if (!Array.isArray(t.path))
          return "path: array expected";
        for (var f = 0; f < t.path.length; ++f) {
          var i = $.ics23.InnerOp.verify(t.path[f]);
          if (i)
            return "path." + i;
        }
      }
      return null;
    }, n.fromObject = function(t) {
      if (t instanceof $.ics23.ExistenceProof)
        return t;
      var i = new $.ics23.ExistenceProof();
      if (t.key != null && (typeof t.key == "string" ? te.base64.decode(t.key, i.key = te.newBuffer(te.base64.length(t.key)), 0) : t.key.length && (i.key = t.key)), t.value != null && (typeof t.value == "string" ? te.base64.decode(t.value, i.value = te.newBuffer(te.base64.length(t.value)), 0) : t.value.length && (i.value = t.value)), t.leaf != null) {
        if (typeof t.leaf != "object")
          throw TypeError(".ics23.ExistenceProof.leaf: object expected");
        i.leaf = $.ics23.LeafOp.fromObject(t.leaf);
      }
      if (t.path) {
        if (!Array.isArray(t.path))
          throw TypeError(".ics23.ExistenceProof.path: array expected");
        i.path = [];
        for (var f = 0; f < t.path.length; ++f) {
          if (typeof t.path[f] != "object")
            throw TypeError(".ics23.ExistenceProof.path: object expected");
          i.path[f] = $.ics23.InnerOp.fromObject(t.path[f]);
        }
      }
      return i;
    }, n.toObject = function(t, i) {
      i || (i = {});
      var f = {};
      if ((i.arrays || i.defaults) && (f.path = []), i.defaults && (i.bytes === String ? f.key = "" : (f.key = [], i.bytes !== Array && (f.key = te.newBuffer(f.key))), i.bytes === String ? f.value = "" : (f.value = [], i.bytes !== Array && (f.value = te.newBuffer(f.value))), f.leaf = null), t.key != null && t.hasOwnProperty("key") && (f.key = i.bytes === String ? te.base64.encode(t.key, 0, t.key.length) : i.bytes === Array ? Array.prototype.slice.call(t.key) : t.key), t.value != null && t.hasOwnProperty("value") && (f.value = i.bytes === String ? te.base64.encode(t.value, 0, t.value.length) : i.bytes === Array ? Array.prototype.slice.call(t.value) : t.value), t.leaf != null && t.hasOwnProperty("leaf") && (f.leaf = $.ics23.LeafOp.toObject(t.leaf, i)), t.path && t.path.length) {
        f.path = [];
        for (var k = 0; k < t.path.length; ++k)
          f.path[k] = $.ics23.InnerOp.toObject(t.path[k], i);
      }
      return f;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, we.util.toJSONOptions);
    }, n;
  }(), e.NonExistenceProof = function() {
    function n(r) {
      if (r)
        for (var t = Object.keys(r), i = 0; i < t.length; ++i)
          r[t[i]] != null && (this[t[i]] = r[t[i]]);
    }
    return n.prototype.key = te.newBuffer([]), n.prototype.left = null, n.prototype.right = null, n.create = function(t) {
      return new n(t);
    }, n.encode = function(t, i) {
      return i || (i = sn.create()), t.key != null && t.hasOwnProperty("key") && i.uint32(
        /* id 1, wireType 2 =*/
        10
      ).bytes(t.key), t.left != null && t.hasOwnProperty("left") && $.ics23.ExistenceProof.encode(t.left, i.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), t.right != null && t.hasOwnProperty("right") && $.ics23.ExistenceProof.encode(t.right, i.uint32(
        /* id 3, wireType 2 =*/
        26
      ).fork()).ldelim(), i;
    }, n.encodeDelimited = function(t, i) {
      return this.encode(t, i).ldelim();
    }, n.decode = function(t, i) {
      t instanceof oe || (t = oe.create(t));
      for (var f = i === void 0 ? t.len : t.pos + i, k = new $.ics23.NonExistenceProof(); t.pos < f; ) {
        var C = t.uint32();
        switch (C >>> 3) {
          case 1:
            k.key = t.bytes();
            break;
          case 2:
            k.left = $.ics23.ExistenceProof.decode(t, t.uint32());
            break;
          case 3:
            k.right = $.ics23.ExistenceProof.decode(t, t.uint32());
            break;
          default:
            t.skipType(C & 7);
            break;
        }
      }
      return k;
    }, n.decodeDelimited = function(t) {
      return t instanceof oe || (t = new oe(t)), this.decode(t, t.uint32());
    }, n.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.key != null && t.hasOwnProperty("key") && !(t.key && typeof t.key.length == "number" || te.isString(t.key)))
        return "key: buffer expected";
      if (t.left != null && t.hasOwnProperty("left")) {
        var i = $.ics23.ExistenceProof.verify(t.left);
        if (i)
          return "left." + i;
      }
      if (t.right != null && t.hasOwnProperty("right")) {
        var i = $.ics23.ExistenceProof.verify(t.right);
        if (i)
          return "right." + i;
      }
      return null;
    }, n.fromObject = function(t) {
      if (t instanceof $.ics23.NonExistenceProof)
        return t;
      var i = new $.ics23.NonExistenceProof();
      if (t.key != null && (typeof t.key == "string" ? te.base64.decode(t.key, i.key = te.newBuffer(te.base64.length(t.key)), 0) : t.key.length && (i.key = t.key)), t.left != null) {
        if (typeof t.left != "object")
          throw TypeError(".ics23.NonExistenceProof.left: object expected");
        i.left = $.ics23.ExistenceProof.fromObject(t.left);
      }
      if (t.right != null) {
        if (typeof t.right != "object")
          throw TypeError(".ics23.NonExistenceProof.right: object expected");
        i.right = $.ics23.ExistenceProof.fromObject(t.right);
      }
      return i;
    }, n.toObject = function(t, i) {
      i || (i = {});
      var f = {};
      return i.defaults && (i.bytes === String ? f.key = "" : (f.key = [], i.bytes !== Array && (f.key = te.newBuffer(f.key))), f.left = null, f.right = null), t.key != null && t.hasOwnProperty("key") && (f.key = i.bytes === String ? te.base64.encode(t.key, 0, t.key.length) : i.bytes === Array ? Array.prototype.slice.call(t.key) : t.key), t.left != null && t.hasOwnProperty("left") && (f.left = $.ics23.ExistenceProof.toObject(t.left, i)), t.right != null && t.hasOwnProperty("right") && (f.right = $.ics23.ExistenceProof.toObject(t.right, i)), f;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, we.util.toJSONOptions);
    }, n;
  }(), e.CommitmentProof = function() {
    function n(t) {
      if (t)
        for (var i = Object.keys(t), f = 0; f < i.length; ++f)
          t[i[f]] != null && (this[i[f]] = t[i[f]]);
    }
    n.prototype.exist = null, n.prototype.nonexist = null, n.prototype.batch = null, n.prototype.compressed = null;
    var r;
    return Object.defineProperty(n.prototype, "proof", {
      get: te.oneOfGetter(r = ["exist", "nonexist", "batch", "compressed"]),
      set: te.oneOfSetter(r)
    }), n.create = function(i) {
      return new n(i);
    }, n.encode = function(i, f) {
      return f || (f = sn.create()), i.exist != null && i.hasOwnProperty("exist") && $.ics23.ExistenceProof.encode(i.exist, f.uint32(
        /* id 1, wireType 2 =*/
        10
      ).fork()).ldelim(), i.nonexist != null && i.hasOwnProperty("nonexist") && $.ics23.NonExistenceProof.encode(i.nonexist, f.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), i.batch != null && i.hasOwnProperty("batch") && $.ics23.BatchProof.encode(i.batch, f.uint32(
        /* id 3, wireType 2 =*/
        26
      ).fork()).ldelim(), i.compressed != null && i.hasOwnProperty("compressed") && $.ics23.CompressedBatchProof.encode(i.compressed, f.uint32(
        /* id 4, wireType 2 =*/
        34
      ).fork()).ldelim(), f;
    }, n.encodeDelimited = function(i, f) {
      return this.encode(i, f).ldelim();
    }, n.decode = function(i, f) {
      i instanceof oe || (i = oe.create(i));
      for (var k = f === void 0 ? i.len : i.pos + f, C = new $.ics23.CommitmentProof(); i.pos < k; ) {
        var T = i.uint32();
        switch (T >>> 3) {
          case 1:
            C.exist = $.ics23.ExistenceProof.decode(i, i.uint32());
            break;
          case 2:
            C.nonexist = $.ics23.NonExistenceProof.decode(i, i.uint32());
            break;
          case 3:
            C.batch = $.ics23.BatchProof.decode(i, i.uint32());
            break;
          case 4:
            C.compressed = $.ics23.CompressedBatchProof.decode(i, i.uint32());
            break;
          default:
            i.skipType(T & 7);
            break;
        }
      }
      return C;
    }, n.decodeDelimited = function(i) {
      return i instanceof oe || (i = new oe(i)), this.decode(i, i.uint32());
    }, n.verify = function(i) {
      if (typeof i != "object" || i === null)
        return "object expected";
      var f = {};
      if (i.exist != null && i.hasOwnProperty("exist")) {
        f.proof = 1;
        {
          var k = $.ics23.ExistenceProof.verify(i.exist);
          if (k)
            return "exist." + k;
        }
      }
      if (i.nonexist != null && i.hasOwnProperty("nonexist")) {
        if (f.proof === 1)
          return "proof: multiple values";
        f.proof = 1;
        {
          var k = $.ics23.NonExistenceProof.verify(i.nonexist);
          if (k)
            return "nonexist." + k;
        }
      }
      if (i.batch != null && i.hasOwnProperty("batch")) {
        if (f.proof === 1)
          return "proof: multiple values";
        f.proof = 1;
        {
          var k = $.ics23.BatchProof.verify(i.batch);
          if (k)
            return "batch." + k;
        }
      }
      if (i.compressed != null && i.hasOwnProperty("compressed")) {
        if (f.proof === 1)
          return "proof: multiple values";
        f.proof = 1;
        {
          var k = $.ics23.CompressedBatchProof.verify(i.compressed);
          if (k)
            return "compressed." + k;
        }
      }
      return null;
    }, n.fromObject = function(i) {
      if (i instanceof $.ics23.CommitmentProof)
        return i;
      var f = new $.ics23.CommitmentProof();
      if (i.exist != null) {
        if (typeof i.exist != "object")
          throw TypeError(".ics23.CommitmentProof.exist: object expected");
        f.exist = $.ics23.ExistenceProof.fromObject(i.exist);
      }
      if (i.nonexist != null) {
        if (typeof i.nonexist != "object")
          throw TypeError(".ics23.CommitmentProof.nonexist: object expected");
        f.nonexist = $.ics23.NonExistenceProof.fromObject(i.nonexist);
      }
      if (i.batch != null) {
        if (typeof i.batch != "object")
          throw TypeError(".ics23.CommitmentProof.batch: object expected");
        f.batch = $.ics23.BatchProof.fromObject(i.batch);
      }
      if (i.compressed != null) {
        if (typeof i.compressed != "object")
          throw TypeError(".ics23.CommitmentProof.compressed: object expected");
        f.compressed = $.ics23.CompressedBatchProof.fromObject(i.compressed);
      }
      return f;
    }, n.toObject = function(i, f) {
      f || (f = {});
      var k = {};
      return i.exist != null && i.hasOwnProperty("exist") && (k.exist = $.ics23.ExistenceProof.toObject(i.exist, f), f.oneofs && (k.proof = "exist")), i.nonexist != null && i.hasOwnProperty("nonexist") && (k.nonexist = $.ics23.NonExistenceProof.toObject(i.nonexist, f), f.oneofs && (k.proof = "nonexist")), i.batch != null && i.hasOwnProperty("batch") && (k.batch = $.ics23.BatchProof.toObject(i.batch, f), f.oneofs && (k.proof = "batch")), i.compressed != null && i.hasOwnProperty("compressed") && (k.compressed = $.ics23.CompressedBatchProof.toObject(i.compressed, f), f.oneofs && (k.proof = "compressed")), k;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, we.util.toJSONOptions);
    }, n;
  }(), e.LeafOp = function() {
    function n(r) {
      if (r)
        for (var t = Object.keys(r), i = 0; i < t.length; ++i)
          r[t[i]] != null && (this[t[i]] = r[t[i]]);
    }
    return n.prototype.hash = 0, n.prototype.prehashKey = 0, n.prototype.prehashValue = 0, n.prototype.length = 0, n.prototype.prefix = te.newBuffer([]), n.create = function(t) {
      return new n(t);
    }, n.encode = function(t, i) {
      return i || (i = sn.create()), t.hash != null && t.hasOwnProperty("hash") && i.uint32(
        /* id 1, wireType 0 =*/
        8
      ).int32(t.hash), t.prehashKey != null && t.hasOwnProperty("prehashKey") && i.uint32(
        /* id 2, wireType 0 =*/
        16
      ).int32(t.prehashKey), t.prehashValue != null && t.hasOwnProperty("prehashValue") && i.uint32(
        /* id 3, wireType 0 =*/
        24
      ).int32(t.prehashValue), t.length != null && t.hasOwnProperty("length") && i.uint32(
        /* id 4, wireType 0 =*/
        32
      ).int32(t.length), t.prefix != null && t.hasOwnProperty("prefix") && i.uint32(
        /* id 5, wireType 2 =*/
        42
      ).bytes(t.prefix), i;
    }, n.encodeDelimited = function(t, i) {
      return this.encode(t, i).ldelim();
    }, n.decode = function(t, i) {
      t instanceof oe || (t = oe.create(t));
      for (var f = i === void 0 ? t.len : t.pos + i, k = new $.ics23.LeafOp(); t.pos < f; ) {
        var C = t.uint32();
        switch (C >>> 3) {
          case 1:
            k.hash = t.int32();
            break;
          case 2:
            k.prehashKey = t.int32();
            break;
          case 3:
            k.prehashValue = t.int32();
            break;
          case 4:
            k.length = t.int32();
            break;
          case 5:
            k.prefix = t.bytes();
            break;
          default:
            t.skipType(C & 7);
            break;
        }
      }
      return k;
    }, n.decodeDelimited = function(t) {
      return t instanceof oe || (t = new oe(t)), this.decode(t, t.uint32());
    }, n.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.hash != null && t.hasOwnProperty("hash"))
        switch (t.hash) {
          default:
            return "hash: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      if (t.prehashKey != null && t.hasOwnProperty("prehashKey"))
        switch (t.prehashKey) {
          default:
            return "prehashKey: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      if (t.prehashValue != null && t.hasOwnProperty("prehashValue"))
        switch (t.prehashValue) {
          default:
            return "prehashValue: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      if (t.length != null && t.hasOwnProperty("length"))
        switch (t.length) {
          default:
            return "length: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
            break;
        }
      return t.prefix != null && t.hasOwnProperty("prefix") && !(t.prefix && typeof t.prefix.length == "number" || te.isString(t.prefix)) ? "prefix: buffer expected" : null;
    }, n.fromObject = function(t) {
      if (t instanceof $.ics23.LeafOp)
        return t;
      var i = new $.ics23.LeafOp();
      switch (t.hash) {
        case "NO_HASH":
        case 0:
          i.hash = 0;
          break;
        case "SHA256":
        case 1:
          i.hash = 1;
          break;
        case "SHA512":
        case 2:
          i.hash = 2;
          break;
        case "KECCAK":
        case 3:
          i.hash = 3;
          break;
        case "RIPEMD160":
        case 4:
          i.hash = 4;
          break;
        case "BITCOIN":
        case 5:
          i.hash = 5;
          break;
        case "SHA512_256":
        case 6:
          i.hash = 6;
          break;
      }
      switch (t.prehashKey) {
        case "NO_HASH":
        case 0:
          i.prehashKey = 0;
          break;
        case "SHA256":
        case 1:
          i.prehashKey = 1;
          break;
        case "SHA512":
        case 2:
          i.prehashKey = 2;
          break;
        case "KECCAK":
        case 3:
          i.prehashKey = 3;
          break;
        case "RIPEMD160":
        case 4:
          i.prehashKey = 4;
          break;
        case "BITCOIN":
        case 5:
          i.prehashKey = 5;
          break;
        case "SHA512_256":
        case 6:
          i.prehashKey = 6;
          break;
      }
      switch (t.prehashValue) {
        case "NO_HASH":
        case 0:
          i.prehashValue = 0;
          break;
        case "SHA256":
        case 1:
          i.prehashValue = 1;
          break;
        case "SHA512":
        case 2:
          i.prehashValue = 2;
          break;
        case "KECCAK":
        case 3:
          i.prehashValue = 3;
          break;
        case "RIPEMD160":
        case 4:
          i.prehashValue = 4;
          break;
        case "BITCOIN":
        case 5:
          i.prehashValue = 5;
          break;
        case "SHA512_256":
        case 6:
          i.prehashValue = 6;
          break;
      }
      switch (t.length) {
        case "NO_PREFIX":
        case 0:
          i.length = 0;
          break;
        case "VAR_PROTO":
        case 1:
          i.length = 1;
          break;
        case "VAR_RLP":
        case 2:
          i.length = 2;
          break;
        case "FIXED32_BIG":
        case 3:
          i.length = 3;
          break;
        case "FIXED32_LITTLE":
        case 4:
          i.length = 4;
          break;
        case "FIXED64_BIG":
        case 5:
          i.length = 5;
          break;
        case "FIXED64_LITTLE":
        case 6:
          i.length = 6;
          break;
        case "REQUIRE_32_BYTES":
        case 7:
          i.length = 7;
          break;
        case "REQUIRE_64_BYTES":
        case 8:
          i.length = 8;
          break;
      }
      return t.prefix != null && (typeof t.prefix == "string" ? te.base64.decode(t.prefix, i.prefix = te.newBuffer(te.base64.length(t.prefix)), 0) : t.prefix.length && (i.prefix = t.prefix)), i;
    }, n.toObject = function(t, i) {
      i || (i = {});
      var f = {};
      return i.defaults && (f.hash = i.enums === String ? "NO_HASH" : 0, f.prehashKey = i.enums === String ? "NO_HASH" : 0, f.prehashValue = i.enums === String ? "NO_HASH" : 0, f.length = i.enums === String ? "NO_PREFIX" : 0, i.bytes === String ? f.prefix = "" : (f.prefix = [], i.bytes !== Array && (f.prefix = te.newBuffer(f.prefix)))), t.hash != null && t.hasOwnProperty("hash") && (f.hash = i.enums === String ? $.ics23.HashOp[t.hash] : t.hash), t.prehashKey != null && t.hasOwnProperty("prehashKey") && (f.prehashKey = i.enums === String ? $.ics23.HashOp[t.prehashKey] : t.prehashKey), t.prehashValue != null && t.hasOwnProperty("prehashValue") && (f.prehashValue = i.enums === String ? $.ics23.HashOp[t.prehashValue] : t.prehashValue), t.length != null && t.hasOwnProperty("length") && (f.length = i.enums === String ? $.ics23.LengthOp[t.length] : t.length), t.prefix != null && t.hasOwnProperty("prefix") && (f.prefix = i.bytes === String ? te.base64.encode(t.prefix, 0, t.prefix.length) : i.bytes === Array ? Array.prototype.slice.call(t.prefix) : t.prefix), f;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, we.util.toJSONOptions);
    }, n;
  }(), e.InnerOp = function() {
    function n(r) {
      if (r)
        for (var t = Object.keys(r), i = 0; i < t.length; ++i)
          r[t[i]] != null && (this[t[i]] = r[t[i]]);
    }
    return n.prototype.hash = 0, n.prototype.prefix = te.newBuffer([]), n.prototype.suffix = te.newBuffer([]), n.create = function(t) {
      return new n(t);
    }, n.encode = function(t, i) {
      return i || (i = sn.create()), t.hash != null && t.hasOwnProperty("hash") && i.uint32(
        /* id 1, wireType 0 =*/
        8
      ).int32(t.hash), t.prefix != null && t.hasOwnProperty("prefix") && i.uint32(
        /* id 2, wireType 2 =*/
        18
      ).bytes(t.prefix), t.suffix != null && t.hasOwnProperty("suffix") && i.uint32(
        /* id 3, wireType 2 =*/
        26
      ).bytes(t.suffix), i;
    }, n.encodeDelimited = function(t, i) {
      return this.encode(t, i).ldelim();
    }, n.decode = function(t, i) {
      t instanceof oe || (t = oe.create(t));
      for (var f = i === void 0 ? t.len : t.pos + i, k = new $.ics23.InnerOp(); t.pos < f; ) {
        var C = t.uint32();
        switch (C >>> 3) {
          case 1:
            k.hash = t.int32();
            break;
          case 2:
            k.prefix = t.bytes();
            break;
          case 3:
            k.suffix = t.bytes();
            break;
          default:
            t.skipType(C & 7);
            break;
        }
      }
      return k;
    }, n.decodeDelimited = function(t) {
      return t instanceof oe || (t = new oe(t)), this.decode(t, t.uint32());
    }, n.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.hash != null && t.hasOwnProperty("hash"))
        switch (t.hash) {
          default:
            return "hash: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      return t.prefix != null && t.hasOwnProperty("prefix") && !(t.prefix && typeof t.prefix.length == "number" || te.isString(t.prefix)) ? "prefix: buffer expected" : t.suffix != null && t.hasOwnProperty("suffix") && !(t.suffix && typeof t.suffix.length == "number" || te.isString(t.suffix)) ? "suffix: buffer expected" : null;
    }, n.fromObject = function(t) {
      if (t instanceof $.ics23.InnerOp)
        return t;
      var i = new $.ics23.InnerOp();
      switch (t.hash) {
        case "NO_HASH":
        case 0:
          i.hash = 0;
          break;
        case "SHA256":
        case 1:
          i.hash = 1;
          break;
        case "SHA512":
        case 2:
          i.hash = 2;
          break;
        case "KECCAK":
        case 3:
          i.hash = 3;
          break;
        case "RIPEMD160":
        case 4:
          i.hash = 4;
          break;
        case "BITCOIN":
        case 5:
          i.hash = 5;
          break;
        case "SHA512_256":
        case 6:
          i.hash = 6;
          break;
      }
      return t.prefix != null && (typeof t.prefix == "string" ? te.base64.decode(t.prefix, i.prefix = te.newBuffer(te.base64.length(t.prefix)), 0) : t.prefix.length && (i.prefix = t.prefix)), t.suffix != null && (typeof t.suffix == "string" ? te.base64.decode(t.suffix, i.suffix = te.newBuffer(te.base64.length(t.suffix)), 0) : t.suffix.length && (i.suffix = t.suffix)), i;
    }, n.toObject = function(t, i) {
      i || (i = {});
      var f = {};
      return i.defaults && (f.hash = i.enums === String ? "NO_HASH" : 0, i.bytes === String ? f.prefix = "" : (f.prefix = [], i.bytes !== Array && (f.prefix = te.newBuffer(f.prefix))), i.bytes === String ? f.suffix = "" : (f.suffix = [], i.bytes !== Array && (f.suffix = te.newBuffer(f.suffix)))), t.hash != null && t.hasOwnProperty("hash") && (f.hash = i.enums === String ? $.ics23.HashOp[t.hash] : t.hash), t.prefix != null && t.hasOwnProperty("prefix") && (f.prefix = i.bytes === String ? te.base64.encode(t.prefix, 0, t.prefix.length) : i.bytes === Array ? Array.prototype.slice.call(t.prefix) : t.prefix), t.suffix != null && t.hasOwnProperty("suffix") && (f.suffix = i.bytes === String ? te.base64.encode(t.suffix, 0, t.suffix.length) : i.bytes === Array ? Array.prototype.slice.call(t.suffix) : t.suffix), f;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, we.util.toJSONOptions);
    }, n;
  }(), e.ProofSpec = function() {
    function n(r) {
      if (r)
        for (var t = Object.keys(r), i = 0; i < t.length; ++i)
          r[t[i]] != null && (this[t[i]] = r[t[i]]);
    }
    return n.prototype.leafSpec = null, n.prototype.innerSpec = null, n.prototype.maxDepth = 0, n.prototype.minDepth = 0, n.create = function(t) {
      return new n(t);
    }, n.encode = function(t, i) {
      return i || (i = sn.create()), t.leafSpec != null && t.hasOwnProperty("leafSpec") && $.ics23.LeafOp.encode(t.leafSpec, i.uint32(
        /* id 1, wireType 2 =*/
        10
      ).fork()).ldelim(), t.innerSpec != null && t.hasOwnProperty("innerSpec") && $.ics23.InnerSpec.encode(t.innerSpec, i.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), t.maxDepth != null && t.hasOwnProperty("maxDepth") && i.uint32(
        /* id 3, wireType 0 =*/
        24
      ).int32(t.maxDepth), t.minDepth != null && t.hasOwnProperty("minDepth") && i.uint32(
        /* id 4, wireType 0 =*/
        32
      ).int32(t.minDepth), i;
    }, n.encodeDelimited = function(t, i) {
      return this.encode(t, i).ldelim();
    }, n.decode = function(t, i) {
      t instanceof oe || (t = oe.create(t));
      for (var f = i === void 0 ? t.len : t.pos + i, k = new $.ics23.ProofSpec(); t.pos < f; ) {
        var C = t.uint32();
        switch (C >>> 3) {
          case 1:
            k.leafSpec = $.ics23.LeafOp.decode(t, t.uint32());
            break;
          case 2:
            k.innerSpec = $.ics23.InnerSpec.decode(t, t.uint32());
            break;
          case 3:
            k.maxDepth = t.int32();
            break;
          case 4:
            k.minDepth = t.int32();
            break;
          default:
            t.skipType(C & 7);
            break;
        }
      }
      return k;
    }, n.decodeDelimited = function(t) {
      return t instanceof oe || (t = new oe(t)), this.decode(t, t.uint32());
    }, n.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.leafSpec != null && t.hasOwnProperty("leafSpec")) {
        var i = $.ics23.LeafOp.verify(t.leafSpec);
        if (i)
          return "leafSpec." + i;
      }
      if (t.innerSpec != null && t.hasOwnProperty("innerSpec")) {
        var i = $.ics23.InnerSpec.verify(t.innerSpec);
        if (i)
          return "innerSpec." + i;
      }
      return t.maxDepth != null && t.hasOwnProperty("maxDepth") && !te.isInteger(t.maxDepth) ? "maxDepth: integer expected" : t.minDepth != null && t.hasOwnProperty("minDepth") && !te.isInteger(t.minDepth) ? "minDepth: integer expected" : null;
    }, n.fromObject = function(t) {
      if (t instanceof $.ics23.ProofSpec)
        return t;
      var i = new $.ics23.ProofSpec();
      if (t.leafSpec != null) {
        if (typeof t.leafSpec != "object")
          throw TypeError(".ics23.ProofSpec.leafSpec: object expected");
        i.leafSpec = $.ics23.LeafOp.fromObject(t.leafSpec);
      }
      if (t.innerSpec != null) {
        if (typeof t.innerSpec != "object")
          throw TypeError(".ics23.ProofSpec.innerSpec: object expected");
        i.innerSpec = $.ics23.InnerSpec.fromObject(t.innerSpec);
      }
      return t.maxDepth != null && (i.maxDepth = t.maxDepth | 0), t.minDepth != null && (i.minDepth = t.minDepth | 0), i;
    }, n.toObject = function(t, i) {
      i || (i = {});
      var f = {};
      return i.defaults && (f.leafSpec = null, f.innerSpec = null, f.maxDepth = 0, f.minDepth = 0), t.leafSpec != null && t.hasOwnProperty("leafSpec") && (f.leafSpec = $.ics23.LeafOp.toObject(t.leafSpec, i)), t.innerSpec != null && t.hasOwnProperty("innerSpec") && (f.innerSpec = $.ics23.InnerSpec.toObject(t.innerSpec, i)), t.maxDepth != null && t.hasOwnProperty("maxDepth") && (f.maxDepth = t.maxDepth), t.minDepth != null && t.hasOwnProperty("minDepth") && (f.minDepth = t.minDepth), f;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, we.util.toJSONOptions);
    }, n;
  }(), e.InnerSpec = function() {
    function n(r) {
      if (this.childOrder = [], r)
        for (var t = Object.keys(r), i = 0; i < t.length; ++i)
          r[t[i]] != null && (this[t[i]] = r[t[i]]);
    }
    return n.prototype.childOrder = te.emptyArray, n.prototype.childSize = 0, n.prototype.minPrefixLength = 0, n.prototype.maxPrefixLength = 0, n.prototype.emptyChild = te.newBuffer([]), n.prototype.hash = 0, n.create = function(t) {
      return new n(t);
    }, n.encode = function(t, i) {
      if (i || (i = sn.create()), t.childOrder != null && t.childOrder.length) {
        i.uint32(
          /* id 1, wireType 2 =*/
          10
        ).fork();
        for (var f = 0; f < t.childOrder.length; ++f)
          i.int32(t.childOrder[f]);
        i.ldelim();
      }
      return t.childSize != null && t.hasOwnProperty("childSize") && i.uint32(
        /* id 2, wireType 0 =*/
        16
      ).int32(t.childSize), t.minPrefixLength != null && t.hasOwnProperty("minPrefixLength") && i.uint32(
        /* id 3, wireType 0 =*/
        24
      ).int32(t.minPrefixLength), t.maxPrefixLength != null && t.hasOwnProperty("maxPrefixLength") && i.uint32(
        /* id 4, wireType 0 =*/
        32
      ).int32(t.maxPrefixLength), t.emptyChild != null && t.hasOwnProperty("emptyChild") && i.uint32(
        /* id 5, wireType 2 =*/
        42
      ).bytes(t.emptyChild), t.hash != null && t.hasOwnProperty("hash") && i.uint32(
        /* id 6, wireType 0 =*/
        48
      ).int32(t.hash), i;
    }, n.encodeDelimited = function(t, i) {
      return this.encode(t, i).ldelim();
    }, n.decode = function(t, i) {
      t instanceof oe || (t = oe.create(t));
      for (var f = i === void 0 ? t.len : t.pos + i, k = new $.ics23.InnerSpec(); t.pos < f; ) {
        var C = t.uint32();
        switch (C >>> 3) {
          case 1:
            if (k.childOrder && k.childOrder.length || (k.childOrder = []), (C & 7) === 2)
              for (var T = t.uint32() + t.pos; t.pos < T; )
                k.childOrder.push(t.int32());
            else
              k.childOrder.push(t.int32());
            break;
          case 2:
            k.childSize = t.int32();
            break;
          case 3:
            k.minPrefixLength = t.int32();
            break;
          case 4:
            k.maxPrefixLength = t.int32();
            break;
          case 5:
            k.emptyChild = t.bytes();
            break;
          case 6:
            k.hash = t.int32();
            break;
          default:
            t.skipType(C & 7);
            break;
        }
      }
      return k;
    }, n.decodeDelimited = function(t) {
      return t instanceof oe || (t = new oe(t)), this.decode(t, t.uint32());
    }, n.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.childOrder != null && t.hasOwnProperty("childOrder")) {
        if (!Array.isArray(t.childOrder))
          return "childOrder: array expected";
        for (var i = 0; i < t.childOrder.length; ++i)
          if (!te.isInteger(t.childOrder[i]))
            return "childOrder: integer[] expected";
      }
      if (t.childSize != null && t.hasOwnProperty("childSize") && !te.isInteger(t.childSize))
        return "childSize: integer expected";
      if (t.minPrefixLength != null && t.hasOwnProperty("minPrefixLength") && !te.isInteger(t.minPrefixLength))
        return "minPrefixLength: integer expected";
      if (t.maxPrefixLength != null && t.hasOwnProperty("maxPrefixLength") && !te.isInteger(t.maxPrefixLength))
        return "maxPrefixLength: integer expected";
      if (t.emptyChild != null && t.hasOwnProperty("emptyChild") && !(t.emptyChild && typeof t.emptyChild.length == "number" || te.isString(t.emptyChild)))
        return "emptyChild: buffer expected";
      if (t.hash != null && t.hasOwnProperty("hash"))
        switch (t.hash) {
          default:
            return "hash: enum value expected";
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
            break;
        }
      return null;
    }, n.fromObject = function(t) {
      if (t instanceof $.ics23.InnerSpec)
        return t;
      var i = new $.ics23.InnerSpec();
      if (t.childOrder) {
        if (!Array.isArray(t.childOrder))
          throw TypeError(".ics23.InnerSpec.childOrder: array expected");
        i.childOrder = [];
        for (var f = 0; f < t.childOrder.length; ++f)
          i.childOrder[f] = t.childOrder[f] | 0;
      }
      switch (t.childSize != null && (i.childSize = t.childSize | 0), t.minPrefixLength != null && (i.minPrefixLength = t.minPrefixLength | 0), t.maxPrefixLength != null && (i.maxPrefixLength = t.maxPrefixLength | 0), t.emptyChild != null && (typeof t.emptyChild == "string" ? te.base64.decode(t.emptyChild, i.emptyChild = te.newBuffer(te.base64.length(t.emptyChild)), 0) : t.emptyChild.length && (i.emptyChild = t.emptyChild)), t.hash) {
        case "NO_HASH":
        case 0:
          i.hash = 0;
          break;
        case "SHA256":
        case 1:
          i.hash = 1;
          break;
        case "SHA512":
        case 2:
          i.hash = 2;
          break;
        case "KECCAK":
        case 3:
          i.hash = 3;
          break;
        case "RIPEMD160":
        case 4:
          i.hash = 4;
          break;
        case "BITCOIN":
        case 5:
          i.hash = 5;
          break;
        case "SHA512_256":
        case 6:
          i.hash = 6;
          break;
      }
      return i;
    }, n.toObject = function(t, i) {
      i || (i = {});
      var f = {};
      if ((i.arrays || i.defaults) && (f.childOrder = []), i.defaults && (f.childSize = 0, f.minPrefixLength = 0, f.maxPrefixLength = 0, i.bytes === String ? f.emptyChild = "" : (f.emptyChild = [], i.bytes !== Array && (f.emptyChild = te.newBuffer(f.emptyChild))), f.hash = i.enums === String ? "NO_HASH" : 0), t.childOrder && t.childOrder.length) {
        f.childOrder = [];
        for (var k = 0; k < t.childOrder.length; ++k)
          f.childOrder[k] = t.childOrder[k];
      }
      return t.childSize != null && t.hasOwnProperty("childSize") && (f.childSize = t.childSize), t.minPrefixLength != null && t.hasOwnProperty("minPrefixLength") && (f.minPrefixLength = t.minPrefixLength), t.maxPrefixLength != null && t.hasOwnProperty("maxPrefixLength") && (f.maxPrefixLength = t.maxPrefixLength), t.emptyChild != null && t.hasOwnProperty("emptyChild") && (f.emptyChild = i.bytes === String ? te.base64.encode(t.emptyChild, 0, t.emptyChild.length) : i.bytes === Array ? Array.prototype.slice.call(t.emptyChild) : t.emptyChild), t.hash != null && t.hasOwnProperty("hash") && (f.hash = i.enums === String ? $.ics23.HashOp[t.hash] : t.hash), f;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, we.util.toJSONOptions);
    }, n;
  }(), e.BatchProof = function() {
    function n(r) {
      if (this.entries = [], r)
        for (var t = Object.keys(r), i = 0; i < t.length; ++i)
          r[t[i]] != null && (this[t[i]] = r[t[i]]);
    }
    return n.prototype.entries = te.emptyArray, n.create = function(t) {
      return new n(t);
    }, n.encode = function(t, i) {
      if (i || (i = sn.create()), t.entries != null && t.entries.length)
        for (var f = 0; f < t.entries.length; ++f)
          $.ics23.BatchEntry.encode(t.entries[f], i.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
      return i;
    }, n.encodeDelimited = function(t, i) {
      return this.encode(t, i).ldelim();
    }, n.decode = function(t, i) {
      t instanceof oe || (t = oe.create(t));
      for (var f = i === void 0 ? t.len : t.pos + i, k = new $.ics23.BatchProof(); t.pos < f; ) {
        var C = t.uint32();
        switch (C >>> 3) {
          case 1:
            k.entries && k.entries.length || (k.entries = []), k.entries.push($.ics23.BatchEntry.decode(t, t.uint32()));
            break;
          default:
            t.skipType(C & 7);
            break;
        }
      }
      return k;
    }, n.decodeDelimited = function(t) {
      return t instanceof oe || (t = new oe(t)), this.decode(t, t.uint32());
    }, n.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.entries != null && t.hasOwnProperty("entries")) {
        if (!Array.isArray(t.entries))
          return "entries: array expected";
        for (var i = 0; i < t.entries.length; ++i) {
          var f = $.ics23.BatchEntry.verify(t.entries[i]);
          if (f)
            return "entries." + f;
        }
      }
      return null;
    }, n.fromObject = function(t) {
      if (t instanceof $.ics23.BatchProof)
        return t;
      var i = new $.ics23.BatchProof();
      if (t.entries) {
        if (!Array.isArray(t.entries))
          throw TypeError(".ics23.BatchProof.entries: array expected");
        i.entries = [];
        for (var f = 0; f < t.entries.length; ++f) {
          if (typeof t.entries[f] != "object")
            throw TypeError(".ics23.BatchProof.entries: object expected");
          i.entries[f] = $.ics23.BatchEntry.fromObject(t.entries[f]);
        }
      }
      return i;
    }, n.toObject = function(t, i) {
      i || (i = {});
      var f = {};
      if ((i.arrays || i.defaults) && (f.entries = []), t.entries && t.entries.length) {
        f.entries = [];
        for (var k = 0; k < t.entries.length; ++k)
          f.entries[k] = $.ics23.BatchEntry.toObject(t.entries[k], i);
      }
      return f;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, we.util.toJSONOptions);
    }, n;
  }(), e.BatchEntry = function() {
    function n(t) {
      if (t)
        for (var i = Object.keys(t), f = 0; f < i.length; ++f)
          t[i[f]] != null && (this[i[f]] = t[i[f]]);
    }
    n.prototype.exist = null, n.prototype.nonexist = null;
    var r;
    return Object.defineProperty(n.prototype, "proof", {
      get: te.oneOfGetter(r = ["exist", "nonexist"]),
      set: te.oneOfSetter(r)
    }), n.create = function(i) {
      return new n(i);
    }, n.encode = function(i, f) {
      return f || (f = sn.create()), i.exist != null && i.hasOwnProperty("exist") && $.ics23.ExistenceProof.encode(i.exist, f.uint32(
        /* id 1, wireType 2 =*/
        10
      ).fork()).ldelim(), i.nonexist != null && i.hasOwnProperty("nonexist") && $.ics23.NonExistenceProof.encode(i.nonexist, f.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), f;
    }, n.encodeDelimited = function(i, f) {
      return this.encode(i, f).ldelim();
    }, n.decode = function(i, f) {
      i instanceof oe || (i = oe.create(i));
      for (var k = f === void 0 ? i.len : i.pos + f, C = new $.ics23.BatchEntry(); i.pos < k; ) {
        var T = i.uint32();
        switch (T >>> 3) {
          case 1:
            C.exist = $.ics23.ExistenceProof.decode(i, i.uint32());
            break;
          case 2:
            C.nonexist = $.ics23.NonExistenceProof.decode(i, i.uint32());
            break;
          default:
            i.skipType(T & 7);
            break;
        }
      }
      return C;
    }, n.decodeDelimited = function(i) {
      return i instanceof oe || (i = new oe(i)), this.decode(i, i.uint32());
    }, n.verify = function(i) {
      if (typeof i != "object" || i === null)
        return "object expected";
      var f = {};
      if (i.exist != null && i.hasOwnProperty("exist")) {
        f.proof = 1;
        {
          var k = $.ics23.ExistenceProof.verify(i.exist);
          if (k)
            return "exist." + k;
        }
      }
      if (i.nonexist != null && i.hasOwnProperty("nonexist")) {
        if (f.proof === 1)
          return "proof: multiple values";
        f.proof = 1;
        {
          var k = $.ics23.NonExistenceProof.verify(i.nonexist);
          if (k)
            return "nonexist." + k;
        }
      }
      return null;
    }, n.fromObject = function(i) {
      if (i instanceof $.ics23.BatchEntry)
        return i;
      var f = new $.ics23.BatchEntry();
      if (i.exist != null) {
        if (typeof i.exist != "object")
          throw TypeError(".ics23.BatchEntry.exist: object expected");
        f.exist = $.ics23.ExistenceProof.fromObject(i.exist);
      }
      if (i.nonexist != null) {
        if (typeof i.nonexist != "object")
          throw TypeError(".ics23.BatchEntry.nonexist: object expected");
        f.nonexist = $.ics23.NonExistenceProof.fromObject(i.nonexist);
      }
      return f;
    }, n.toObject = function(i, f) {
      f || (f = {});
      var k = {};
      return i.exist != null && i.hasOwnProperty("exist") && (k.exist = $.ics23.ExistenceProof.toObject(i.exist, f), f.oneofs && (k.proof = "exist")), i.nonexist != null && i.hasOwnProperty("nonexist") && (k.nonexist = $.ics23.NonExistenceProof.toObject(i.nonexist, f), f.oneofs && (k.proof = "nonexist")), k;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, we.util.toJSONOptions);
    }, n;
  }(), e.CompressedBatchProof = function() {
    function n(r) {
      if (this.entries = [], this.lookupInners = [], r)
        for (var t = Object.keys(r), i = 0; i < t.length; ++i)
          r[t[i]] != null && (this[t[i]] = r[t[i]]);
    }
    return n.prototype.entries = te.emptyArray, n.prototype.lookupInners = te.emptyArray, n.create = function(t) {
      return new n(t);
    }, n.encode = function(t, i) {
      if (i || (i = sn.create()), t.entries != null && t.entries.length)
        for (var f = 0; f < t.entries.length; ++f)
          $.ics23.CompressedBatchEntry.encode(t.entries[f], i.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
      if (t.lookupInners != null && t.lookupInners.length)
        for (var f = 0; f < t.lookupInners.length; ++f)
          $.ics23.InnerOp.encode(t.lookupInners[f], i.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
      return i;
    }, n.encodeDelimited = function(t, i) {
      return this.encode(t, i).ldelim();
    }, n.decode = function(t, i) {
      t instanceof oe || (t = oe.create(t));
      for (var f = i === void 0 ? t.len : t.pos + i, k = new $.ics23.CompressedBatchProof(); t.pos < f; ) {
        var C = t.uint32();
        switch (C >>> 3) {
          case 1:
            k.entries && k.entries.length || (k.entries = []), k.entries.push($.ics23.CompressedBatchEntry.decode(t, t.uint32()));
            break;
          case 2:
            k.lookupInners && k.lookupInners.length || (k.lookupInners = []), k.lookupInners.push($.ics23.InnerOp.decode(t, t.uint32()));
            break;
          default:
            t.skipType(C & 7);
            break;
        }
      }
      return k;
    }, n.decodeDelimited = function(t) {
      return t instanceof oe || (t = new oe(t)), this.decode(t, t.uint32());
    }, n.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.entries != null && t.hasOwnProperty("entries")) {
        if (!Array.isArray(t.entries))
          return "entries: array expected";
        for (var i = 0; i < t.entries.length; ++i) {
          var f = $.ics23.CompressedBatchEntry.verify(t.entries[i]);
          if (f)
            return "entries." + f;
        }
      }
      if (t.lookupInners != null && t.hasOwnProperty("lookupInners")) {
        if (!Array.isArray(t.lookupInners))
          return "lookupInners: array expected";
        for (var i = 0; i < t.lookupInners.length; ++i) {
          var f = $.ics23.InnerOp.verify(t.lookupInners[i]);
          if (f)
            return "lookupInners." + f;
        }
      }
      return null;
    }, n.fromObject = function(t) {
      if (t instanceof $.ics23.CompressedBatchProof)
        return t;
      var i = new $.ics23.CompressedBatchProof();
      if (t.entries) {
        if (!Array.isArray(t.entries))
          throw TypeError(".ics23.CompressedBatchProof.entries: array expected");
        i.entries = [];
        for (var f = 0; f < t.entries.length; ++f) {
          if (typeof t.entries[f] != "object")
            throw TypeError(".ics23.CompressedBatchProof.entries: object expected");
          i.entries[f] = $.ics23.CompressedBatchEntry.fromObject(t.entries[f]);
        }
      }
      if (t.lookupInners) {
        if (!Array.isArray(t.lookupInners))
          throw TypeError(".ics23.CompressedBatchProof.lookupInners: array expected");
        i.lookupInners = [];
        for (var f = 0; f < t.lookupInners.length; ++f) {
          if (typeof t.lookupInners[f] != "object")
            throw TypeError(".ics23.CompressedBatchProof.lookupInners: object expected");
          i.lookupInners[f] = $.ics23.InnerOp.fromObject(t.lookupInners[f]);
        }
      }
      return i;
    }, n.toObject = function(t, i) {
      i || (i = {});
      var f = {};
      if ((i.arrays || i.defaults) && (f.entries = [], f.lookupInners = []), t.entries && t.entries.length) {
        f.entries = [];
        for (var k = 0; k < t.entries.length; ++k)
          f.entries[k] = $.ics23.CompressedBatchEntry.toObject(t.entries[k], i);
      }
      if (t.lookupInners && t.lookupInners.length) {
        f.lookupInners = [];
        for (var k = 0; k < t.lookupInners.length; ++k)
          f.lookupInners[k] = $.ics23.InnerOp.toObject(t.lookupInners[k], i);
      }
      return f;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, we.util.toJSONOptions);
    }, n;
  }(), e.CompressedBatchEntry = function() {
    function n(t) {
      if (t)
        for (var i = Object.keys(t), f = 0; f < i.length; ++f)
          t[i[f]] != null && (this[i[f]] = t[i[f]]);
    }
    n.prototype.exist = null, n.prototype.nonexist = null;
    var r;
    return Object.defineProperty(n.prototype, "proof", {
      get: te.oneOfGetter(r = ["exist", "nonexist"]),
      set: te.oneOfSetter(r)
    }), n.create = function(i) {
      return new n(i);
    }, n.encode = function(i, f) {
      return f || (f = sn.create()), i.exist != null && i.hasOwnProperty("exist") && $.ics23.CompressedExistenceProof.encode(i.exist, f.uint32(
        /* id 1, wireType 2 =*/
        10
      ).fork()).ldelim(), i.nonexist != null && i.hasOwnProperty("nonexist") && $.ics23.CompressedNonExistenceProof.encode(i.nonexist, f.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), f;
    }, n.encodeDelimited = function(i, f) {
      return this.encode(i, f).ldelim();
    }, n.decode = function(i, f) {
      i instanceof oe || (i = oe.create(i));
      for (var k = f === void 0 ? i.len : i.pos + f, C = new $.ics23.CompressedBatchEntry(); i.pos < k; ) {
        var T = i.uint32();
        switch (T >>> 3) {
          case 1:
            C.exist = $.ics23.CompressedExistenceProof.decode(i, i.uint32());
            break;
          case 2:
            C.nonexist = $.ics23.CompressedNonExistenceProof.decode(i, i.uint32());
            break;
          default:
            i.skipType(T & 7);
            break;
        }
      }
      return C;
    }, n.decodeDelimited = function(i) {
      return i instanceof oe || (i = new oe(i)), this.decode(i, i.uint32());
    }, n.verify = function(i) {
      if (typeof i != "object" || i === null)
        return "object expected";
      var f = {};
      if (i.exist != null && i.hasOwnProperty("exist")) {
        f.proof = 1;
        {
          var k = $.ics23.CompressedExistenceProof.verify(i.exist);
          if (k)
            return "exist." + k;
        }
      }
      if (i.nonexist != null && i.hasOwnProperty("nonexist")) {
        if (f.proof === 1)
          return "proof: multiple values";
        f.proof = 1;
        {
          var k = $.ics23.CompressedNonExistenceProof.verify(i.nonexist);
          if (k)
            return "nonexist." + k;
        }
      }
      return null;
    }, n.fromObject = function(i) {
      if (i instanceof $.ics23.CompressedBatchEntry)
        return i;
      var f = new $.ics23.CompressedBatchEntry();
      if (i.exist != null) {
        if (typeof i.exist != "object")
          throw TypeError(".ics23.CompressedBatchEntry.exist: object expected");
        f.exist = $.ics23.CompressedExistenceProof.fromObject(i.exist);
      }
      if (i.nonexist != null) {
        if (typeof i.nonexist != "object")
          throw TypeError(".ics23.CompressedBatchEntry.nonexist: object expected");
        f.nonexist = $.ics23.CompressedNonExistenceProof.fromObject(i.nonexist);
      }
      return f;
    }, n.toObject = function(i, f) {
      f || (f = {});
      var k = {};
      return i.exist != null && i.hasOwnProperty("exist") && (k.exist = $.ics23.CompressedExistenceProof.toObject(i.exist, f), f.oneofs && (k.proof = "exist")), i.nonexist != null && i.hasOwnProperty("nonexist") && (k.nonexist = $.ics23.CompressedNonExistenceProof.toObject(i.nonexist, f), f.oneofs && (k.proof = "nonexist")), k;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, we.util.toJSONOptions);
    }, n;
  }(), e.CompressedExistenceProof = function() {
    function n(r) {
      if (this.path = [], r)
        for (var t = Object.keys(r), i = 0; i < t.length; ++i)
          r[t[i]] != null && (this[t[i]] = r[t[i]]);
    }
    return n.prototype.key = te.newBuffer([]), n.prototype.value = te.newBuffer([]), n.prototype.leaf = null, n.prototype.path = te.emptyArray, n.create = function(t) {
      return new n(t);
    }, n.encode = function(t, i) {
      if (i || (i = sn.create()), t.key != null && t.hasOwnProperty("key") && i.uint32(
        /* id 1, wireType 2 =*/
        10
      ).bytes(t.key), t.value != null && t.hasOwnProperty("value") && i.uint32(
        /* id 2, wireType 2 =*/
        18
      ).bytes(t.value), t.leaf != null && t.hasOwnProperty("leaf") && $.ics23.LeafOp.encode(t.leaf, i.uint32(
        /* id 3, wireType 2 =*/
        26
      ).fork()).ldelim(), t.path != null && t.path.length) {
        i.uint32(
          /* id 4, wireType 2 =*/
          34
        ).fork();
        for (var f = 0; f < t.path.length; ++f)
          i.int32(t.path[f]);
        i.ldelim();
      }
      return i;
    }, n.encodeDelimited = function(t, i) {
      return this.encode(t, i).ldelim();
    }, n.decode = function(t, i) {
      t instanceof oe || (t = oe.create(t));
      for (var f = i === void 0 ? t.len : t.pos + i, k = new $.ics23.CompressedExistenceProof(); t.pos < f; ) {
        var C = t.uint32();
        switch (C >>> 3) {
          case 1:
            k.key = t.bytes();
            break;
          case 2:
            k.value = t.bytes();
            break;
          case 3:
            k.leaf = $.ics23.LeafOp.decode(t, t.uint32());
            break;
          case 4:
            if (k.path && k.path.length || (k.path = []), (C & 7) === 2)
              for (var T = t.uint32() + t.pos; t.pos < T; )
                k.path.push(t.int32());
            else
              k.path.push(t.int32());
            break;
          default:
            t.skipType(C & 7);
            break;
        }
      }
      return k;
    }, n.decodeDelimited = function(t) {
      return t instanceof oe || (t = new oe(t)), this.decode(t, t.uint32());
    }, n.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.key != null && t.hasOwnProperty("key") && !(t.key && typeof t.key.length == "number" || te.isString(t.key)))
        return "key: buffer expected";
      if (t.value != null && t.hasOwnProperty("value") && !(t.value && typeof t.value.length == "number" || te.isString(t.value)))
        return "value: buffer expected";
      if (t.leaf != null && t.hasOwnProperty("leaf")) {
        var i = $.ics23.LeafOp.verify(t.leaf);
        if (i)
          return "leaf." + i;
      }
      if (t.path != null && t.hasOwnProperty("path")) {
        if (!Array.isArray(t.path))
          return "path: array expected";
        for (var f = 0; f < t.path.length; ++f)
          if (!te.isInteger(t.path[f]))
            return "path: integer[] expected";
      }
      return null;
    }, n.fromObject = function(t) {
      if (t instanceof $.ics23.CompressedExistenceProof)
        return t;
      var i = new $.ics23.CompressedExistenceProof();
      if (t.key != null && (typeof t.key == "string" ? te.base64.decode(t.key, i.key = te.newBuffer(te.base64.length(t.key)), 0) : t.key.length && (i.key = t.key)), t.value != null && (typeof t.value == "string" ? te.base64.decode(t.value, i.value = te.newBuffer(te.base64.length(t.value)), 0) : t.value.length && (i.value = t.value)), t.leaf != null) {
        if (typeof t.leaf != "object")
          throw TypeError(".ics23.CompressedExistenceProof.leaf: object expected");
        i.leaf = $.ics23.LeafOp.fromObject(t.leaf);
      }
      if (t.path) {
        if (!Array.isArray(t.path))
          throw TypeError(".ics23.CompressedExistenceProof.path: array expected");
        i.path = [];
        for (var f = 0; f < t.path.length; ++f)
          i.path[f] = t.path[f] | 0;
      }
      return i;
    }, n.toObject = function(t, i) {
      i || (i = {});
      var f = {};
      if ((i.arrays || i.defaults) && (f.path = []), i.defaults && (i.bytes === String ? f.key = "" : (f.key = [], i.bytes !== Array && (f.key = te.newBuffer(f.key))), i.bytes === String ? f.value = "" : (f.value = [], i.bytes !== Array && (f.value = te.newBuffer(f.value))), f.leaf = null), t.key != null && t.hasOwnProperty("key") && (f.key = i.bytes === String ? te.base64.encode(t.key, 0, t.key.length) : i.bytes === Array ? Array.prototype.slice.call(t.key) : t.key), t.value != null && t.hasOwnProperty("value") && (f.value = i.bytes === String ? te.base64.encode(t.value, 0, t.value.length) : i.bytes === Array ? Array.prototype.slice.call(t.value) : t.value), t.leaf != null && t.hasOwnProperty("leaf") && (f.leaf = $.ics23.LeafOp.toObject(t.leaf, i)), t.path && t.path.length) {
        f.path = [];
        for (var k = 0; k < t.path.length; ++k)
          f.path[k] = t.path[k];
      }
      return f;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, we.util.toJSONOptions);
    }, n;
  }(), e.CompressedNonExistenceProof = function() {
    function n(r) {
      if (r)
        for (var t = Object.keys(r), i = 0; i < t.length; ++i)
          r[t[i]] != null && (this[t[i]] = r[t[i]]);
    }
    return n.prototype.key = te.newBuffer([]), n.prototype.left = null, n.prototype.right = null, n.create = function(t) {
      return new n(t);
    }, n.encode = function(t, i) {
      return i || (i = sn.create()), t.key != null && t.hasOwnProperty("key") && i.uint32(
        /* id 1, wireType 2 =*/
        10
      ).bytes(t.key), t.left != null && t.hasOwnProperty("left") && $.ics23.CompressedExistenceProof.encode(t.left, i.uint32(
        /* id 2, wireType 2 =*/
        18
      ).fork()).ldelim(), t.right != null && t.hasOwnProperty("right") && $.ics23.CompressedExistenceProof.encode(t.right, i.uint32(
        /* id 3, wireType 2 =*/
        26
      ).fork()).ldelim(), i;
    }, n.encodeDelimited = function(t, i) {
      return this.encode(t, i).ldelim();
    }, n.decode = function(t, i) {
      t instanceof oe || (t = oe.create(t));
      for (var f = i === void 0 ? t.len : t.pos + i, k = new $.ics23.CompressedNonExistenceProof(); t.pos < f; ) {
        var C = t.uint32();
        switch (C >>> 3) {
          case 1:
            k.key = t.bytes();
            break;
          case 2:
            k.left = $.ics23.CompressedExistenceProof.decode(t, t.uint32());
            break;
          case 3:
            k.right = $.ics23.CompressedExistenceProof.decode(t, t.uint32());
            break;
          default:
            t.skipType(C & 7);
            break;
        }
      }
      return k;
    }, n.decodeDelimited = function(t) {
      return t instanceof oe || (t = new oe(t)), this.decode(t, t.uint32());
    }, n.verify = function(t) {
      if (typeof t != "object" || t === null)
        return "object expected";
      if (t.key != null && t.hasOwnProperty("key") && !(t.key && typeof t.key.length == "number" || te.isString(t.key)))
        return "key: buffer expected";
      if (t.left != null && t.hasOwnProperty("left")) {
        var i = $.ics23.CompressedExistenceProof.verify(t.left);
        if (i)
          return "left." + i;
      }
      if (t.right != null && t.hasOwnProperty("right")) {
        var i = $.ics23.CompressedExistenceProof.verify(t.right);
        if (i)
          return "right." + i;
      }
      return null;
    }, n.fromObject = function(t) {
      if (t instanceof $.ics23.CompressedNonExistenceProof)
        return t;
      var i = new $.ics23.CompressedNonExistenceProof();
      if (t.key != null && (typeof t.key == "string" ? te.base64.decode(t.key, i.key = te.newBuffer(te.base64.length(t.key)), 0) : t.key.length && (i.key = t.key)), t.left != null) {
        if (typeof t.left != "object")
          throw TypeError(".ics23.CompressedNonExistenceProof.left: object expected");
        i.left = $.ics23.CompressedExistenceProof.fromObject(t.left);
      }
      if (t.right != null) {
        if (typeof t.right != "object")
          throw TypeError(".ics23.CompressedNonExistenceProof.right: object expected");
        i.right = $.ics23.CompressedExistenceProof.fromObject(t.right);
      }
      return i;
    }, n.toObject = function(t, i) {
      i || (i = {});
      var f = {};
      return i.defaults && (i.bytes === String ? f.key = "" : (f.key = [], i.bytes !== Array && (f.key = te.newBuffer(f.key))), f.left = null, f.right = null), t.key != null && t.hasOwnProperty("key") && (f.key = i.bytes === String ? te.base64.encode(t.key, 0, t.key.length) : i.bytes === Array ? Array.prototype.slice.call(t.key) : t.key), t.left != null && t.hasOwnProperty("left") && (f.left = $.ics23.CompressedExistenceProof.toObject(t.left, i)), t.right != null && t.hasOwnProperty("right") && (f.right = $.ics23.CompressedExistenceProof.toObject(t.right, i)), f;
    }, n.prototype.toJSON = function() {
      return this.constructor.toObject(this, we.util.toJSONOptions);
    }, n;
  }(), e;
}();
var io = $, Mn = {}, jt = {};
Object.defineProperty(jt, "__esModule", { value: !0 });
jt.decompress = jt.compress = void 0;
const rh = io;
function ih(e) {
  return e.batch ? { compressed: ah(e.batch) } : e;
}
jt.compress = ih;
function oh(e) {
  return e.compressed ? { batch: sh(e.compressed) } : e;
}
jt.decompress = oh;
function ah(e) {
  const n = [], r = [], t = /* @__PURE__ */ new Map();
  for (const i of e.entries)
    if (i.exist) {
      const f = { exist: Fa(i.exist, r, t) };
      n.push(f);
    } else if (i.nonexist) {
      const f = i.nonexist, k = {
        nonexist: {
          key: f.key,
          left: Fa(f.left, r, t),
          right: Fa(f.right, r, t)
        }
      };
      n.push(k);
    } else
      throw new Error("Unexpected batch entry during compress");
  return {
    entries: n,
    lookupInners: r
  };
}
function Fa(e, n, r) {
  if (!e)
    return;
  const t = e.path.map((i) => {
    const f = rh.ics23.InnerOp.encode(i).finish();
    let k = r.get(f);
    return k === void 0 && (k = n.length, n.push(i), r.set(f, k)), k;
  });
  return {
    key: e.key,
    value: e.value,
    leaf: e.leaf,
    path: t
  };
}
function sh(e) {
  const n = e.lookupInners;
  return {
    entries: e.entries.map((t) => {
      if (t.exist)
        return { exist: La(t.exist, n) };
      if (t.nonexist) {
        const i = t.nonexist;
        return {
          nonexist: {
            key: i.key,
            left: La(i.left, n),
            right: La(i.right, n)
          }
        };
      } else
        throw new Error("Unexpected batch entry during compress");
    })
  };
}
function La(e, n) {
  if (!e)
    return;
  const { key: r, value: t, leaf: i, path: f } = e, k = (f || []).map((C) => n[C]);
  return { key: r, value: t, leaf: i, path: k };
}
var Ne = {}, ot = {};
Object.defineProperty(ot, "__esModule", { value: !0 });
ot.doHash = ot.applyInner = ot.applyLeaf = void 0;
const uu = ac, cu = sc, lu = nd, un = io;
function dh(e, n, r) {
  if (n.length === 0)
    throw new Error("Missing key");
  if (r.length === 0)
    throw new Error("Missing value");
  const t = pu(Ni(e.prehashKey), fu(e.length), n), i = pu(Ni(e.prehashValue), fu(e.length), r), f = new Uint8Array([
    ...Js(e.prefix),
    ...t,
    ...i
  ]);
  return oo(Ni(e.hash), f);
}
ot.applyLeaf = dh;
function uh(e, n) {
  if (n.length === 0)
    throw new Error("Inner op needs child value");
  const r = new Uint8Array([
    ...Js(e.prefix),
    ...n,
    ...Js(e.suffix)
  ]);
  return oo(Ni(e.hash), r);
}
ot.applyInner = uh;
function ud(e, n) {
  return e ?? n;
}
const Ni = (e) => ud(e, un.ics23.HashOp.NO_HASH), fu = (e) => ud(e, un.ics23.LengthOp.NO_PREFIX), Js = (e) => ud(e, new Uint8Array([]));
function pu(e, n, r) {
  const t = ch(e, r);
  return lh(n, t);
}
function ch(e, n) {
  return e === un.ics23.HashOp.NO_HASH ? n : oo(e, n);
}
function oo(e, n) {
  switch (e) {
    case un.ics23.HashOp.SHA256:
      return (0, cu.sha256)(n);
    case un.ics23.HashOp.SHA512:
      return (0, lu.sha512)(n);
    case un.ics23.HashOp.RIPEMD160:
      return (0, uu.ripemd160)(n);
    case un.ics23.HashOp.BITCOIN:
      return (0, uu.ripemd160)((0, cu.sha256)(n));
    case un.ics23.HashOp.SHA512_256:
      return (0, lu.sha512_256)(n);
  }
  throw new Error(`Unsupported hashop: ${e}`);
}
ot.doHash = oo;
function lh(e, n) {
  switch (e) {
    case un.ics23.LengthOp.NO_PREFIX:
      return n;
    case un.ics23.LengthOp.VAR_PROTO:
      return new Uint8Array([...fh(n.length), ...n]);
    case un.ics23.LengthOp.REQUIRE_32_BYTES:
      if (n.length !== 32)
        throw new Error(`Length is ${n.length}, not 32 bytes`);
      return n;
    case un.ics23.LengthOp.REQUIRE_64_BYTES:
      if (n.length !== 64)
        throw new Error(`Length is ${n.length}, not 64 bytes`);
      return n;
    case un.ics23.LengthOp.FIXED32_LITTLE:
      return new Uint8Array([...ph(n.length), ...n]);
  }
  throw new Error(`Unsupported lengthop: ${e}`);
}
function fh(e) {
  let n = [], r = e;
  for (; r >= 128; ) {
    const t = r % 128 + 128;
    n = [...n, t], r = r / 128;
  }
  return n = [...n, r], new Uint8Array(n);
}
function ph(e) {
  const n = new Uint8Array(4);
  let r = e;
  for (let t = n.length; t > 0; t--)
    n[Math.abs(t - n.length)] = r % 256, r = Math.floor(r / 256);
  return n;
}
var Qe = {};
Object.defineProperty(Qe, "__esModule", { value: !0 });
Qe.bytesBefore = Qe.ensureBytesBefore = Qe.bytesEqual = Qe.ensureBytesEqual = Qe.ensureInner = Qe.ensureLeaf = void 0;
function hh(e, n) {
  if (e.hash !== n.hash)
    throw new Error(`Unexpected hashOp: ${e.hash}`);
  if (e.prehashKey !== n.prehashKey)
    throw new Error(`Unexpected prehashKey: ${e.prehashKey}`);
  if (e.prehashValue !== n.prehashValue)
    throw new Error(`Unexpected prehashValue: ${e.prehashValue}`);
  if (e.length !== n.length)
    throw new Error(`Unexpected length op: ${e.length}`);
  mh(e.prefix, n.prefix);
}
Qe.ensureLeaf = hh;
function yh(e, n, r) {
  if (e.hash !== r.hash)
    throw new Error(`Unexpected hashOp: ${e.hash}`);
  if (!e.prefix)
    throw new Error("No prefix set for inner node");
  if (Sh(e.prefix, n))
    throw new Error("Inner node has leaf prefix");
  if (e.prefix.length < (r.minPrefixLength || 0))
    throw new Error(`Prefix too short: ${e.prefix.length} bytes`);
  const t = (r.childOrder.length - 1) * r.childSize;
  if (e.prefix.length > (r.maxPrefixLength || 0) + t)
    throw new Error(`Prefix too long: ${e.prefix.length} bytes`);
}
Qe.ensureInner = yh;
function mh(e, n) {
  if (!(!n || n.length === 0)) {
    if (!e)
      throw new Error("Target bytes missing");
    bc(n, e.slice(0, n.length));
  }
}
function bc(e, n) {
  if (e.length !== n.length)
    throw new Error(`Different lengths ${e.length} vs ${n.length}`);
  for (let r = 0; r < e.length; r++)
    if (e[r] !== n[r])
      throw new Error(`Arrays differ at index ${r}: ${e[r]} vs ${n[r]}`);
}
Qe.ensureBytesEqual = bc;
function gh(e, n) {
  if (e.length !== n.length)
    return !1;
  for (let r = 0; r < e.length; r++)
    if (e[r] !== n[r])
      return !1;
  return !0;
}
Qe.bytesEqual = gh;
function Sh(e, n) {
  if (!n || n.length === 0 || !e || e.length <= n.length)
    return !1;
  for (let r = 0; r < n.length; r++)
    if (e[r] !== n[r])
      return !1;
  throw !0;
}
function kh(e, n) {
  if (!Ac(e, n))
    throw new Error("first is after last");
}
Qe.ensureBytesBefore = kh;
function Ac(e, n) {
  const r = e.length < n.length ? e.length : n.length;
  for (let t = 0; t < r; t++) {
    if (e[t] < n[t])
      return !0;
    if (e[t] > n[t])
      return !1;
  }
  return e.length < n.length;
}
Qe.bytesBefore = Ac;
Object.defineProperty(Ne, "__esModule", { value: !0 });
Ne.ensureLeftNeighbor = Ne.ensureSpec = Ne.calculateExistenceRoot = Ne.verifyNonExistence = Ne.verifyExistence = Ne.smtSpec = Ne.tendermintSpec = Ne.iavlSpec = void 0;
const We = io, hu = ot, zn = Qe;
Ne.iavlSpec = {
  leafSpec: {
    prefix: Uint8Array.from([0]),
    hash: We.ics23.HashOp.SHA256,
    prehashValue: We.ics23.HashOp.SHA256,
    prehashKey: We.ics23.HashOp.NO_HASH,
    length: We.ics23.LengthOp.VAR_PROTO
  },
  innerSpec: {
    childOrder: [0, 1],
    minPrefixLength: 4,
    maxPrefixLength: 12,
    childSize: 33,
    hash: We.ics23.HashOp.SHA256
  }
};
Ne.tendermintSpec = {
  leafSpec: {
    prefix: Uint8Array.from([0]),
    hash: We.ics23.HashOp.SHA256,
    prehashValue: We.ics23.HashOp.SHA256,
    prehashKey: We.ics23.HashOp.NO_HASH,
    length: We.ics23.LengthOp.VAR_PROTO
  },
  innerSpec: {
    childOrder: [0, 1],
    minPrefixLength: 1,
    maxPrefixLength: 1,
    childSize: 32,
    hash: We.ics23.HashOp.SHA256
  }
};
Ne.smtSpec = {
  leafSpec: {
    hash: We.ics23.HashOp.SHA256,
    prehashKey: We.ics23.HashOp.NO_HASH,
    prehashValue: We.ics23.HashOp.SHA256,
    length: We.ics23.LengthOp.NO_PREFIX,
    prefix: Uint8Array.from([0])
  },
  innerSpec: {
    childOrder: [0, 1],
    childSize: 32,
    minPrefixLength: 1,
    maxPrefixLength: 1,
    emptyChild: new Uint8Array(32),
    hash: We.ics23.HashOp.SHA256
  },
  maxDepth: 256
};
function Us(e, n, r, t, i) {
  Tc(e, n);
  const f = Ic(e);
  (0, zn.ensureBytesEqual)(f, r), (0, zn.ensureBytesEqual)(t, e.key), (0, zn.ensureBytesEqual)(i, e.value);
}
Ne.verifyExistence = Us;
function Ph(e, n, r, t) {
  let i, f;
  if (e.left && (Us(e.left, n, r, e.left.key, e.left.value), i = e.left.key), e.right && (Us(e.right, n, r, e.right.key, e.right.value), f = e.right.key), !i && !f)
    throw new Error("neither left nor right proof defined");
  if (i && (0, zn.ensureBytesBefore)(i, t), f && (0, zn.ensureBytesBefore)(t, f), !n.innerSpec)
    throw new Error("no inner spec");
  i ? f ? wc(n.innerSpec, e.left.path, e.right.path) : Nc(n.innerSpec, e.left.path) : Cc(n.innerSpec, e.right.path);
}
Ne.verifyNonExistence = Ph;
function Ic(e) {
  if (!e.key || !e.value)
    throw new Error("Existence proof needs key and value set");
  if (!e.leaf)
    throw new Error("Existence proof must start with a leaf operation");
  const n = e.path || [];
  let r = (0, hu.applyLeaf)(e.leaf, e.key, e.value);
  for (const t of n)
    r = (0, hu.applyInner)(t, r);
  return r;
}
Ne.calculateExistenceRoot = Ic;
function Tc(e, n) {
  if (!e.leaf)
    throw new Error("Existence proof must start with a leaf operation");
  if (!n.leafSpec)
    throw new Error("Spec must include leafSpec");
  if (!n.innerSpec)
    throw new Error("Spec must include innerSpec");
  (0, zn.ensureLeaf)(e.leaf, n.leafSpec);
  const r = e.path || [];
  if (n.minDepth && r.length < n.minDepth)
    throw new Error(`Too few inner nodes ${r.length}`);
  if (n.maxDepth && r.length > n.maxDepth)
    throw new Error(`Too many inner nodes ${r.length}`);
  for (const t of r)
    (0, zn.ensureInner)(t, n.leafSpec.prefix, n.innerSpec);
}
Ne.ensureSpec = Tc;
function Cc(e, n) {
  const { minPrefix: r, maxPrefix: t, suffix: i } = ld(e, 0);
  for (const f of n)
    if (!cd(f, r, t, i))
      throw new Error("Step not leftmost");
}
function Nc(e, n) {
  const r = e.childOrder.length - 1, { minPrefix: t, maxPrefix: i, suffix: f } = ld(e, r);
  for (const k of n)
    if (!cd(k, t, i, f))
      throw new Error("Step not leftmost");
}
function wc(e, n, r) {
  const t = [...n], i = [...r];
  let f = t.pop(), k = i.pop();
  for (; (0, zn.bytesEqual)(f.prefix, k.prefix) && (0, zn.bytesEqual)(f.suffix, k.suffix); )
    f = t.pop(), k = i.pop();
  if (!vh(e, f, k))
    throw new Error("Not left neightbor at first divergent step");
  Nc(e, t), Cc(e, i);
}
Ne.ensureLeftNeighbor = wc;
function vh(e, n, r) {
  const t = yu(e, n);
  return yu(e, r) === t + 1;
}
function yu(e, n) {
  for (let r = 0; r < e.childOrder.length; r++) {
    const { minPrefix: t, maxPrefix: i, suffix: f } = ld(e, r);
    if (cd(n, t, i, f))
      return r;
  }
  throw new Error("Cannot find any valid spacing for this node");
}
function cd(e, n, r, t) {
  return (e.prefix || []).length < n || (e.prefix || []).length > r ? !1 : (e.suffix || []).length === t;
}
function ld(e, n) {
  const r = Rh(e.childOrder, n), t = r * e.childSize, i = t + e.minPrefixLength, f = t + e.maxPrefixLength, k = (e.childOrder.length - 1 - r) * e.childSize;
  return { minPrefix: i, maxPrefix: f, suffix: k };
}
function Rh(e, n) {
  if (n < 0 || n >= e.length)
    throw new Error(`Invalid branch: ${n}`);
  return e.findIndex((r) => r === n);
}
Object.defineProperty(Mn, "__esModule", { value: !0 });
Mn.batchVerifyNonMembership = Mn.batchVerifyMembership = Mn.verifyNonMembership = Mn.verifyMembership = void 0;
const ao = jt, _c = Ne, Ds = Qe;
function Ec(e, n, r, t, i) {
  const f = (0, ao.decompress)(e), k = bh(f, t);
  if (!k)
    return !1;
  try {
    return (0, _c.verifyExistence)(k, n, r, t, i), !0;
  } catch {
    return !1;
  }
}
Mn.verifyMembership = Ec;
function Jc(e, n, r, t) {
  const i = (0, ao.decompress)(e), f = Ah(i, t);
  if (!f)
    return !1;
  try {
    return (0, _c.verifyNonExistence)(f, n, r, t), !0;
  } catch {
    return !1;
  }
}
Mn.verifyNonMembership = Jc;
function Bh(e, n, r, t) {
  const i = (0, ao.decompress)(e);
  for (const [f, k] of t.entries())
    if (!Ec(i, n, r, f, k))
      return !1;
  return !0;
}
Mn.batchVerifyMembership = Bh;
function Oh(e, n, r, t) {
  const i = (0, ao.decompress)(e);
  for (const f of t)
    if (!Jc(i, n, r, f))
      return !1;
  return !0;
}
Mn.batchVerifyNonMembership = Oh;
function bh(e, n) {
  const r = (t) => !!t && (0, Ds.bytesEqual)(n, t.key);
  if (r(e.exist))
    return e.exist;
  if (e.batch)
    return e.batch.entries.map((t) => t.exist || null).find(r);
}
function Ah(e, n) {
  const r = (t) => !!t && (!t.left || (0, Ds.bytesBefore)(t.left.key, n)) && (!t.right || (0, Ds.bytesBefore)(n, t.right.key));
  if (r(e.nonexist))
    return e.nonexist;
  if (e.batch)
    return e.batch.entries.map((t) => t.nonexist || null).find(r);
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.verifyNonExistence = e.verifyExistence = e.tendermintSpec = e.iavlSpec = e.calculateExistenceRoot = e.verifyNonMembership = e.verifyMembership = e.ics23 = void 0;
  var n = io;
  Object.defineProperty(e, "ics23", { enumerable: !0, get: function() {
    return n.ics23;
  } });
  var r = Mn;
  Object.defineProperty(e, "verifyMembership", { enumerable: !0, get: function() {
    return r.verifyMembership;
  } }), Object.defineProperty(e, "verifyNonMembership", { enumerable: !0, get: function() {
    return r.verifyNonMembership;
  } });
  var t = Ne;
  Object.defineProperty(e, "calculateExistenceRoot", { enumerable: !0, get: function() {
    return t.calculateExistenceRoot;
  } }), Object.defineProperty(e, "iavlSpec", { enumerable: !0, get: function() {
    return t.iavlSpec;
  } }), Object.defineProperty(e, "tendermintSpec", { enumerable: !0, get: function() {
    return t.tendermintSpec;
  } }), Object.defineProperty(e, "verifyExistence", { enumerable: !0, get: function() {
    return t.verifyExistence;
  } }), Object.defineProperty(e, "verifyNonExistence", { enumerable: !0, get: function() {
    return t.verifyNonExistence;
  } });
})(yc);
var ei = {}, so = {}, Ue = {}, Uc = {};
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.default = n;
  function n(r) {
    var t, i = r.Symbol;
    if (typeof i == "function")
      if (i.observable)
        t = i.observable;
      else {
        t = i.for("https://github.com/benlesh/symbol-observable");
        try {
          i.observable = t;
        } catch {
        }
      }
    else
      t = "@@observable";
    return t;
  }
})(Uc);
var Ih = Uc, mu = Object.prototype.toString, Dc = function(n) {
  var r = mu.call(n), t = r === "[object Arguments]";
  return t || (t = r !== "[object Array]" && n !== null && typeof n == "object" && typeof n.length == "number" && n.length >= 0 && mu.call(n.callee) === "[object Function]"), t;
}, Ga, gu;
function Th() {
  if (gu)
    return Ga;
  gu = 1;
  var e;
  if (!Object.keys) {
    var n = Object.prototype.hasOwnProperty, r = Object.prototype.toString, t = Dc, i = Object.prototype.propertyIsEnumerable, f = !i.call({ toString: null }, "toString"), k = i.call(function() {
    }, "prototype"), C = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], T = function(h) {
      var P = h.constructor;
      return P && P.prototype === h;
    }, U = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, w = function() {
      if (typeof window > "u")
        return !1;
      for (var h in window)
        try {
          if (!U["$" + h] && n.call(window, h) && window[h] !== null && typeof window[h] == "object")
            try {
              T(window[h]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    }(), N = function(h) {
      if (typeof window > "u" || !w)
        return T(h);
      try {
        return T(h);
      } catch {
        return !1;
      }
    };
    e = function(P) {
      var b = P !== null && typeof P == "object", c = r.call(P) === "[object Function]", l = t(P), y = b && r.call(P) === "[object String]", E = [];
      if (!b && !c && !l)
        throw new TypeError("Object.keys called on a non-object");
      var J = k && c;
      if (y && P.length > 0 && !n.call(P, 0))
        for (var _ = 0; _ < P.length; ++_)
          E.push(String(_));
      if (l && P.length > 0)
        for (var V = 0; V < P.length; ++V)
          E.push(String(V));
      else
        for (var o in P)
          !(J && o === "prototype") && n.call(P, o) && E.push(String(o));
      if (f)
        for (var p = N(P), I = 0; I < C.length; ++I)
          !(p && C[I] === "constructor") && n.call(P, C[I]) && E.push(C[I]);
      return E;
    };
  }
  return Ga = e, Ga;
}
var Ch = Array.prototype.slice, Nh = Dc, Su = Object.keys, wi = Su ? function(n) {
  return Su(n);
} : Th(), ku = Object.keys;
wi.shim = function() {
  if (Object.keys) {
    var n = function() {
      var r = Object.keys(arguments);
      return r && r.length === arguments.length;
    }(1, 2);
    n || (Object.keys = function(t) {
      return Nh(t) ? ku(Ch.call(t)) : ku(t);
    });
  } else
    Object.keys = wi;
  return Object.keys || wi;
};
var wh = wi, _h = rc, Ms = _h("%Object.defineProperty%", !0), Hs = function() {
  if (Ms)
    try {
      return Ms({}, "a", { value: 1 }), !0;
    } catch {
      return !1;
    }
  return !1;
};
Hs.hasArrayLengthDefineBug = function() {
  if (!Hs())
    return null;
  try {
    return Ms([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var Mc = Hs, Eh = Mc(), fd = rc, Hr = Eh && fd("%Object.defineProperty%", !0);
if (Hr)
  try {
    Hr({}, "a", { value: 1 });
  } catch {
    Hr = !1;
  }
var Jh = fd("%SyntaxError%"), Mt = fd("%TypeError%"), Pu = kp(), Uh = function(n, r, t) {
  if (!n || typeof n != "object" && typeof n != "function")
    throw new Mt("`obj` must be an object or a function`");
  if (typeof r != "string" && typeof r != "symbol")
    throw new Mt("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new Mt("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new Mt("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new Mt("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new Mt("`loose`, if provided, must be a boolean");
  var i = arguments.length > 3 ? arguments[3] : null, f = arguments.length > 4 ? arguments[4] : null, k = arguments.length > 5 ? arguments[5] : null, C = arguments.length > 6 ? arguments[6] : !1, T = !!Pu && Pu(n, r);
  if (Hr)
    Hr(n, r, {
      configurable: k === null && T ? T.configurable : !k,
      enumerable: i === null && T ? T.enumerable : !i,
      value: t,
      writable: f === null && T ? T.writable : !f
    });
  else if (C || !i && !f && !k)
    n[r] = t;
  else
    throw new Jh("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, Dh = wh, Mh = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", Hh = Object.prototype.toString, qh = Array.prototype.concat, vu = Uh, Vh = function(e) {
  return typeof e == "function" && Hh.call(e) === "[object Function]";
}, Hc = Mc(), Qh = function(e, n, r, t) {
  if (n in e) {
    if (t === !0) {
      if (e[n] === r)
        return;
    } else if (!Vh(t) || !t())
      return;
  }
  Hc ? vu(e, n, r, !0) : vu(e, n, r);
}, qc = function(e, n) {
  var r = arguments.length > 2 ? arguments[2] : {}, t = Dh(n);
  Mh && (t = qh.call(t, Object.getOwnPropertySymbols(n)));
  for (var i = 0; i < t.length; i += 1)
    Qh(e, t[i], n[t[i]], r[t[i]]);
};
qc.supportsDescriptors = !!Hc;
var Vc = qc, _i = { exports: {} };
typeof self < "u" ? _i.exports = self : typeof window < "u" ? _i.exports = window : _i.exports = Function("return this")();
var Qc = _i.exports, Wh = Qc, Wc = function() {
  return typeof j != "object" || !j || j.Math !== Math || j.Array !== Array ? Wh : j;
}, Fh = Vc, Lh = Wc, Gh = function() {
  var n = Lh();
  if (Fh.supportsDescriptors) {
    var r = Object.getOwnPropertyDescriptor(n, "globalThis");
    (!r || r.configurable && (r.enumerable || !r.writable || globalThis !== n)) && Object.defineProperty(n, "globalThis", {
      configurable: !0,
      enumerable: !1,
      value: n,
      writable: !0
    });
  } else
    (typeof globalThis != "object" || globalThis !== n) && (n.globalThis = n);
  return n;
}, $h = Vc, zh = Qc, Fc = Wc, Kh = Gh, xh = Fc(), Lc = function() {
  return xh;
};
$h(Lc, {
  getPolyfill: Fc,
  implementation: zh,
  shim: Kh
});
var Zh = Lc, Yh = j && j.__extends || function() {
  var e = function(n, r) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
      t.__proto__ = i;
    } || function(t, i) {
      for (var f in i)
        i.hasOwnProperty(f) && (t[f] = i[f]);
    }, e(n, r);
  };
  return function(n, r) {
    e(n, r);
    function t() {
      this.constructor = n;
    }
    n.prototype = r === null ? Object.create(r) : (t.prototype = r.prototype, new t());
  };
}();
Object.defineProperty(Ue, "__esModule", { value: !0 });
Ue.NO_IL = Ue.NO = Ue.MemoryStream = Ue.Stream = void 0;
var Xh = Ih, jh = Zh, fi = Xh.default(jh.getPolyfill()), ee = {};
Ue.NO = ee;
function qe() {
}
function Ei(e) {
  for (var n = e.length, r = Array(n), t = 0; t < n; ++t)
    r[t] = e[t];
  return r;
}
function ey(e, n) {
  return function(t) {
    return e(t) && n(t);
  };
}
function pd(e, n, r) {
  try {
    return e.f(n);
  } catch (t) {
    return r._e(t), ee;
  }
}
var Rt = {
  _n: qe,
  _e: qe,
  _c: qe
};
Ue.NO_IL = Rt;
function Ru(e) {
  e._start = function(r) {
    r.next = r._n, r.error = r._e, r.complete = r._c, this.start(r);
  }, e._stop = e.stop;
}
var ny = (
  /** @class */
  function() {
    function e(n, r) {
      this._stream = n, this._listener = r;
    }
    return e.prototype.unsubscribe = function() {
      this._stream._remove(this._listener);
    }, e;
  }()
), ty = (
  /** @class */
  function() {
    function e(n) {
      this._listener = n;
    }
    return e.prototype.next = function(n) {
      this._listener._n(n);
    }, e.prototype.error = function(n) {
      this._listener._e(n);
    }, e.prototype.complete = function() {
      this._listener._c();
    }, e;
  }()
), ry = (
  /** @class */
  function() {
    function e(n) {
      this.type = "fromObservable", this.ins = n, this.active = !1;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.active = !0, this._sub = this.ins.subscribe(new ty(n)), this.active || this._sub.unsubscribe();
    }, e.prototype._stop = function() {
      this._sub && this._sub.unsubscribe(), this.active = !1;
    }, e;
  }()
), iy = (
  /** @class */
  function() {
    function e(n) {
      this.type = "merge", this.insArr = n, this.out = ee, this.ac = 0;
    }
    return e.prototype._start = function(n) {
      this.out = n;
      var r = this.insArr, t = r.length;
      this.ac = t;
      for (var i = 0; i < t; i++)
        r[i]._add(this);
    }, e.prototype._stop = function() {
      for (var n = this.insArr, r = n.length, t = 0; t < r; t++)
        n[t]._remove(this);
      this.out = ee;
    }, e.prototype._n = function(n) {
      var r = this.out;
      r !== ee && r._n(n);
    }, e.prototype._e = function(n) {
      var r = this.out;
      r !== ee && r._e(n);
    }, e.prototype._c = function() {
      if (--this.ac <= 0) {
        var n = this.out;
        if (n === ee)
          return;
        n._c();
      }
    }, e;
  }()
), oy = (
  /** @class */
  function() {
    function e(n, r, t) {
      this.i = n, this.out = r, this.p = t, t.ils.push(this);
    }
    return e.prototype._n = function(n) {
      var r = this.p, t = this.out;
      if (t !== ee && r.up(n, this.i)) {
        var i = Ei(r.vals);
        t._n(i);
      }
    }, e.prototype._e = function(n) {
      var r = this.out;
      r !== ee && r._e(n);
    }, e.prototype._c = function() {
      var n = this.p;
      n.out !== ee && --n.Nc === 0 && n.out._c();
    }, e;
  }()
), ay = (
  /** @class */
  function() {
    function e(n) {
      this.type = "combine", this.insArr = n, this.out = ee, this.ils = [], this.Nc = this.Nn = 0, this.vals = [];
    }
    return e.prototype.up = function(n, r) {
      var t = this.vals[r], i = this.Nn ? t === ee ? --this.Nn : this.Nn : 0;
      return this.vals[r] = n, i === 0;
    }, e.prototype._start = function(n) {
      this.out = n;
      var r = this.insArr, t = this.Nc = this.Nn = r.length, i = this.vals = new Array(t);
      if (t === 0)
        n._n([]), n._c();
      else
        for (var f = 0; f < t; f++)
          i[f] = ee, r[f]._add(new oy(f, n, this));
    }, e.prototype._stop = function() {
      for (var n = this.insArr, r = n.length, t = this.ils, i = 0; i < r; i++)
        n[i]._remove(t[i]);
      this.out = ee, this.ils = [], this.vals = [];
    }, e;
  }()
), sy = (
  /** @class */
  function() {
    function e(n) {
      this.type = "fromArray", this.a = n;
    }
    return e.prototype._start = function(n) {
      for (var r = this.a, t = 0, i = r.length; t < i; t++)
        n._n(r[t]);
      n._c();
    }, e.prototype._stop = function() {
    }, e;
  }()
), dy = (
  /** @class */
  function() {
    function e(n) {
      this.type = "fromPromise", this.on = !1, this.p = n;
    }
    return e.prototype._start = function(n) {
      var r = this;
      this.on = !0, this.p.then(function(t) {
        r.on && (n._n(t), n._c());
      }, function(t) {
        n._e(t);
      }).then(qe, function(t) {
        setTimeout(function() {
          throw t;
        });
      });
    }, e.prototype._stop = function() {
      this.on = !1;
    }, e;
  }()
), uy = (
  /** @class */
  function() {
    function e(n) {
      this.type = "periodic", this.period = n, this.intervalID = -1, this.i = 0;
    }
    return e.prototype._start = function(n) {
      var r = this;
      function t() {
        n._n(r.i++);
      }
      this.intervalID = setInterval(t, this.period);
    }, e.prototype._stop = function() {
      this.intervalID !== -1 && clearInterval(this.intervalID), this.intervalID = -1, this.i = 0;
    }, e;
  }()
), cy = (
  /** @class */
  function() {
    function e(n, r) {
      this.type = "debug", this.ins = n, this.out = ee, this.s = qe, this.l = "", typeof r == "string" ? this.l = r : typeof r == "function" && (this.s = r);
    }
    return e.prototype._start = function(n) {
      this.out = n, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ee;
    }, e.prototype._n = function(n) {
      var r = this.out;
      if (r !== ee) {
        var t = this.s, i = this.l;
        if (t !== qe)
          try {
            t(n);
          } catch (f) {
            r._e(f);
          }
        else
          i ? console.log(i + ":", n) : console.log(n);
        r._n(n);
      }
    }, e.prototype._e = function(n) {
      var r = this.out;
      r !== ee && r._e(n);
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ee && n._c();
    }, e;
  }()
), ly = (
  /** @class */
  function() {
    function e(n, r) {
      this.type = "drop", this.ins = r, this.out = ee, this.max = n, this.dropped = 0;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.dropped = 0, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ee;
    }, e.prototype._n = function(n) {
      var r = this.out;
      r !== ee && this.dropped++ >= this.max && r._n(n);
    }, e.prototype._e = function(n) {
      var r = this.out;
      r !== ee && r._e(n);
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ee && n._c();
    }, e;
  }()
), fy = (
  /** @class */
  function() {
    function e(n, r) {
      this.out = n, this.op = r;
    }
    return e.prototype._n = function() {
      this.op.end();
    }, e.prototype._e = function(n) {
      this.out._e(n);
    }, e.prototype._c = function() {
      this.op.end();
    }, e;
  }()
), py = (
  /** @class */
  function() {
    function e(n, r) {
      this.type = "endWhen", this.ins = r, this.out = ee, this.o = n, this.oil = Rt;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.o._add(this.oil = new fy(n, this)), this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.o._remove(this.oil), this.out = ee, this.oil = Rt;
    }, e.prototype.end = function() {
      var n = this.out;
      n !== ee && n._c();
    }, e.prototype._n = function(n) {
      var r = this.out;
      r !== ee && r._n(n);
    }, e.prototype._e = function(n) {
      var r = this.out;
      r !== ee && r._e(n);
    }, e.prototype._c = function() {
      this.end();
    }, e;
  }()
), $a = (
  /** @class */
  function() {
    function e(n, r) {
      this.type = "filter", this.ins = r, this.out = ee, this.f = n;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ee;
    }, e.prototype._n = function(n) {
      var r = this.out;
      if (r !== ee) {
        var t = pd(this, n, r);
        t === ee || !t || r._n(n);
      }
    }, e.prototype._e = function(n) {
      var r = this.out;
      r !== ee && r._e(n);
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ee && n._c();
    }, e;
  }()
), hy = (
  /** @class */
  function() {
    function e(n, r) {
      this.out = n, this.op = r;
    }
    return e.prototype._n = function(n) {
      this.out._n(n);
    }, e.prototype._e = function(n) {
      this.out._e(n);
    }, e.prototype._c = function() {
      this.op.inner = ee, this.op.less();
    }, e;
  }()
), yy = (
  /** @class */
  function() {
    function e(n) {
      this.type = "flatten", this.ins = n, this.out = ee, this.open = !0, this.inner = ee, this.il = Rt;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.open = !0, this.inner = ee, this.il = Rt, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.inner !== ee && this.inner._remove(this.il), this.out = ee, this.open = !0, this.inner = ee, this.il = Rt;
    }, e.prototype.less = function() {
      var n = this.out;
      n !== ee && !this.open && this.inner === ee && n._c();
    }, e.prototype._n = function(n) {
      var r = this.out;
      if (r !== ee) {
        var t = this, i = t.inner, f = t.il;
        i !== ee && f !== Rt && i._remove(f), (this.inner = n)._add(this.il = new hy(r, this));
      }
    }, e.prototype._e = function(n) {
      var r = this.out;
      r !== ee && r._e(n);
    }, e.prototype._c = function() {
      this.open = !1, this.less();
    }, e;
  }()
), my = (
  /** @class */
  function() {
    function e(n, r, t) {
      var i = this;
      this.type = "fold", this.ins = t, this.out = ee, this.f = function(f) {
        return n(i.acc, f);
      }, this.acc = this.seed = r;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.acc = this.seed, n._n(this.acc), this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ee, this.acc = this.seed;
    }, e.prototype._n = function(n) {
      var r = this.out;
      if (r !== ee) {
        var t = pd(this, n, r);
        t !== ee && r._n(this.acc = t);
      }
    }, e.prototype._e = function(n) {
      var r = this.out;
      r !== ee && r._e(n);
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ee && n._c();
    }, e;
  }()
), gy = (
  /** @class */
  function() {
    function e(n) {
      this.type = "last", this.ins = n, this.out = ee, this.has = !1, this.val = ee;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.has = !1, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ee, this.val = ee;
    }, e.prototype._n = function(n) {
      this.has = !0, this.val = n;
    }, e.prototype._e = function(n) {
      var r = this.out;
      r !== ee && r._e(n);
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ee && (this.has ? (n._n(this.val), n._c()) : n._e(new Error("last() failed because input stream completed")));
    }, e;
  }()
), Sy = (
  /** @class */
  function() {
    function e(n, r) {
      this.type = "map", this.ins = r, this.out = ee, this.f = n;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ee;
    }, e.prototype._n = function(n) {
      var r = this.out;
      if (r !== ee) {
        var t = pd(this, n, r);
        t !== ee && r._n(t);
      }
    }, e.prototype._e = function(n) {
      var r = this.out;
      r !== ee && r._e(n);
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ee && n._c();
    }, e;
  }()
), ky = (
  /** @class */
  function() {
    function e(n) {
      this.type = "remember", this.ins = n, this.out = ee;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.ins._add(n);
    }, e.prototype._stop = function() {
      this.ins._remove(this.out), this.out = ee;
    }, e;
  }()
), Py = (
  /** @class */
  function() {
    function e(n, r) {
      this.type = "replaceError", this.ins = r, this.out = ee, this.f = n;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ee;
    }, e.prototype._n = function(n) {
      var r = this.out;
      r !== ee && r._n(n);
    }, e.prototype._e = function(n) {
      var r = this.out;
      if (r !== ee)
        try {
          this.ins._remove(this), (this.ins = this.f(n))._add(this);
        } catch (t) {
          r._e(t);
        }
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ee && n._c();
    }, e;
  }()
), vy = (
  /** @class */
  function() {
    function e(n, r) {
      this.type = "startWith", this.ins = n, this.out = ee, this.val = r;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.out._n(this.val), this.ins._add(n);
    }, e.prototype._stop = function() {
      this.ins._remove(this.out), this.out = ee;
    }, e;
  }()
), Ry = (
  /** @class */
  function() {
    function e(n, r) {
      this.type = "take", this.ins = r, this.out = ee, this.max = n, this.taken = 0;
    }
    return e.prototype._start = function(n) {
      this.out = n, this.taken = 0, this.max <= 0 ? n._c() : this.ins._add(this);
    }, e.prototype._stop = function() {
      this.ins._remove(this), this.out = ee;
    }, e.prototype._n = function(n) {
      var r = this.out;
      if (r !== ee) {
        var t = ++this.taken;
        t < this.max ? r._n(n) : t === this.max && (r._n(n), r._c());
      }
    }, e.prototype._e = function(n) {
      var r = this.out;
      r !== ee && r._e(n);
    }, e.prototype._c = function() {
      var n = this.out;
      n !== ee && n._c();
    }, e;
  }()
), hd = (
  /** @class */
  function() {
    function e(n) {
      this._prod = n || ee, this._ils = [], this._stopID = ee, this._dl = ee, this._d = !1, this._target = null, this._err = ee;
    }
    return e.prototype._n = function(n) {
      var r = this._ils, t = r.length;
      if (this._d && this._dl._n(n), t == 1)
        r[0]._n(n);
      else {
        if (t == 0)
          return;
        for (var i = Ei(r), f = 0; f < t; f++)
          i[f]._n(n);
      }
    }, e.prototype._e = function(n) {
      if (this._err === ee) {
        this._err = n;
        var r = this._ils, t = r.length;
        if (this._x(), this._d && this._dl._e(n), t == 1)
          r[0]._e(n);
        else {
          if (t == 0)
            return;
          for (var i = Ei(r), f = 0; f < t; f++)
            i[f]._e(n);
        }
        if (!this._d && t == 0)
          throw this._err;
      }
    }, e.prototype._c = function() {
      var n = this._ils, r = n.length;
      if (this._x(), this._d && this._dl._c(), r == 1)
        n[0]._c();
      else {
        if (r == 0)
          return;
        for (var t = Ei(n), i = 0; i < r; i++)
          t[i]._c();
      }
    }, e.prototype._x = function() {
      this._ils.length !== 0 && (this._prod !== ee && this._prod._stop(), this._err = ee, this._ils = []);
    }, e.prototype._stopNow = function() {
      this._prod._stop(), this._err = ee, this._stopID = ee;
    }, e.prototype._add = function(n) {
      var r = this._target;
      if (r)
        return r._add(n);
      var t = this._ils;
      if (t.push(n), !(t.length > 1))
        if (this._stopID !== ee)
          clearTimeout(this._stopID), this._stopID = ee;
        else {
          var i = this._prod;
          i !== ee && i._start(this);
        }
    }, e.prototype._remove = function(n) {
      var r = this, t = this._target;
      if (t)
        return t._remove(n);
      var i = this._ils, f = i.indexOf(n);
      f > -1 && (i.splice(f, 1), this._prod !== ee && i.length <= 0 ? (this._err = ee, this._stopID = setTimeout(function() {
        return r._stopNow();
      })) : i.length === 1 && this._pruneCycles());
    }, e.prototype._pruneCycles = function() {
      this._hasNoSinks(this, []) && this._remove(this._ils[0]);
    }, e.prototype._hasNoSinks = function(n, r) {
      if (r.indexOf(n) !== -1)
        return !0;
      if (n.out === this)
        return !0;
      if (n.out && n.out !== ee)
        return this._hasNoSinks(n.out, r.concat(n));
      if (n._ils) {
        for (var t = 0, i = n._ils.length; t < i; t++)
          if (!this._hasNoSinks(n._ils[t], r.concat(n)))
            return !1;
        return !0;
      } else
        return !1;
    }, e.prototype.ctor = function() {
      return this instanceof tt ? tt : e;
    }, e.prototype.addListener = function(n) {
      n._n = n.next || qe, n._e = n.error || qe, n._c = n.complete || qe, this._add(n);
    }, e.prototype.removeListener = function(n) {
      this._remove(n);
    }, e.prototype.subscribe = function(n) {
      return this.addListener(n), new ny(this, n);
    }, e.prototype[fi] = function() {
      return this;
    }, e.create = function(n) {
      if (n) {
        if (typeof n.start != "function" || typeof n.stop != "function")
          throw new Error("producer requires both start and stop functions");
        Ru(n);
      }
      return new e(n);
    }, e.createWithMemory = function(n) {
      return n && Ru(n), new tt(n);
    }, e.never = function() {
      return new e({ _start: qe, _stop: qe });
    }, e.empty = function() {
      return new e({
        _start: function(n) {
          n._c();
        },
        _stop: qe
      });
    }, e.throw = function(n) {
      return new e({
        _start: function(r) {
          r._e(n);
        },
        _stop: qe
      });
    }, e.from = function(n) {
      if (typeof n[fi] == "function")
        return e.fromObservable(n);
      if (typeof n.then == "function")
        return e.fromPromise(n);
      if (Array.isArray(n))
        return e.fromArray(n);
      throw new TypeError("Type of input to from() must be an Array, Promise, or Observable");
    }, e.of = function() {
      for (var n = [], r = 0; r < arguments.length; r++)
        n[r] = arguments[r];
      return e.fromArray(n);
    }, e.fromArray = function(n) {
      return new e(new sy(n));
    }, e.fromPromise = function(n) {
      return new e(new dy(n));
    }, e.fromObservable = function(n) {
      if (n.endWhen !== void 0)
        return n;
      var r = typeof n[fi] == "function" ? n[fi]() : n;
      return new e(new ry(r));
    }, e.periodic = function(n) {
      return new e(new uy(n));
    }, e.prototype._map = function(n) {
      return new (this.ctor())(new Sy(n, this));
    }, e.prototype.map = function(n) {
      return this._map(n);
    }, e.prototype.mapTo = function(n) {
      var r = this.map(function() {
        return n;
      }), t = r._prod;
      return t.type = "mapTo", r;
    }, e.prototype.filter = function(n) {
      var r = this._prod;
      return r instanceof $a ? new e(new $a(ey(r.f, n), r.ins)) : new e(new $a(n, this));
    }, e.prototype.take = function(n) {
      return new (this.ctor())(new Ry(n, this));
    }, e.prototype.drop = function(n) {
      return new e(new ly(n, this));
    }, e.prototype.last = function() {
      return new e(new gy(this));
    }, e.prototype.startWith = function(n) {
      return new tt(new vy(this, n));
    }, e.prototype.endWhen = function(n) {
      return new (this.ctor())(new py(n, this));
    }, e.prototype.fold = function(n, r) {
      return new tt(new my(n, r, this));
    }, e.prototype.replaceError = function(n) {
      return new (this.ctor())(new Py(n, this));
    }, e.prototype.flatten = function() {
      return new e(new yy(this));
    }, e.prototype.compose = function(n) {
      return n(this);
    }, e.prototype.remember = function() {
      return new tt(new ky(this));
    }, e.prototype.debug = function(n) {
      return new (this.ctor())(new cy(this, n));
    }, e.prototype.imitate = function(n) {
      if (n instanceof tt)
        throw new Error("A MemoryStream was given to imitate(), but it only supports a Stream. Read more about this restriction here: https://github.com/staltz/xstream#faq");
      this._target = n;
      for (var r = this._ils, t = r.length, i = 0; i < t; i++)
        n._add(r[i]);
      this._ils = [];
    }, e.prototype.shamefullySendNext = function(n) {
      this._n(n);
    }, e.prototype.shamefullySendError = function(n) {
      this._e(n);
    }, e.prototype.shamefullySendComplete = function() {
      this._c();
    }, e.prototype.setDebugListener = function(n) {
      n ? (this._d = !0, n._n = n.next || qe, n._e = n.error || qe, n._c = n.complete || qe, this._dl = n) : (this._d = !1, this._dl = ee);
    }, e.merge = function() {
      for (var r = [], t = 0; t < arguments.length; t++)
        r[t] = arguments[t];
      return new e(new iy(r));
    }, e.combine = function() {
      for (var r = [], t = 0; t < arguments.length; t++)
        r[t] = arguments[t];
      return new e(new ay(r));
    }, e;
  }()
);
Ue.Stream = hd;
var tt = (
  /** @class */
  function(e) {
    Yh(n, e);
    function n(r) {
      var t = e.call(this, r) || this;
      return t._has = !1, t;
    }
    return n.prototype._n = function(r) {
      this._v = r, this._has = !0, e.prototype._n.call(this, r);
    }, n.prototype._add = function(r) {
      var t = this._target;
      if (t)
        return t._add(r);
      var i = this._ils;
      if (i.push(r), i.length > 1) {
        this._has && r._n(this._v);
        return;
      }
      if (this._stopID !== ee)
        this._has && r._n(this._v), clearTimeout(this._stopID), this._stopID = ee;
      else if (this._has)
        r._n(this._v);
      else {
        var f = this._prod;
        f !== ee && f._start(this);
      }
    }, n.prototype._stopNow = function() {
      this._has = !1, e.prototype._stopNow.call(this);
    }, n.prototype._x = function() {
      this._has = !1, e.prototype._x.call(this);
    }, n.prototype.map = function(r) {
      return this._map(r);
    }, n.prototype.mapTo = function(r) {
      return e.prototype.mapTo.call(this, r);
    }, n.prototype.take = function(r) {
      return e.prototype.take.call(this, r);
    }, n.prototype.endWhen = function(r) {
      return e.prototype.endWhen.call(this, r);
    }, n.prototype.replaceError = function(r) {
      return e.prototype.replaceError.call(this, r);
    }, n.prototype.remember = function() {
      return this;
    }, n.prototype.debug = function(r) {
      return e.prototype.debug.call(this, r);
    }, n;
  }(hd)
);
Ue.MemoryStream = tt;
var By = hd;
Ue.default = By;
Object.defineProperty(so, "__esModule", { value: !0 });
so.concat = void 0;
const Oy = Ue;
function by(...e) {
  const n = new Array(), r = new Array(), t = /* @__PURE__ */ new Set();
  let i = 0;
  function f() {
    for (; n.length > 0; )
      n.shift().unsubscribe();
    r.length = 0, t.clear(), i = 0;
  }
  const k = {
    start: (C) => {
      e.forEach((w) => r.push([]));
      function T(w) {
        for (; ; ) {
          const N = r[w].shift();
          if (N === void 0)
            return;
          C.next(N);
        }
      }
      function U() {
        return i >= e.length;
      }
      if (U()) {
        C.complete();
        return;
      }
      e.forEach((w, N) => {
        n.push(w.subscribe({
          next: (h) => {
            N === i ? C.next(h) : r[N].push(h);
          },
          complete: () => {
            for (t.add(N); t.has(i); )
              T(i), i++;
            U() ? C.complete() : T(i);
          },
          error: (h) => {
            C.error(h), f();
          }
        }));
      });
    },
    stop: () => {
      f();
    }
  };
  return Oy.Stream.create(k);
}
so.concat = by;
var uo = {};
Object.defineProperty(uo, "__esModule", { value: !0 });
uo.DefaultValueProducer = void 0;
class Ay {
  get value() {
    return this.internalValue;
  }
  constructor(n, r) {
    this.callbacks = r, this.internalValue = n;
  }
  /**
   * Update the current value.
   *
   * If producer is active (i.e. someone is listening), this emits an event.
   * If not, just the current value is updated.
   */
  update(n) {
    this.internalValue = n, this.listener && this.listener.next(n);
  }
  /**
   * Produce an error
   */
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  error(n) {
    this.listener && this.listener.error(n);
  }
  /**
   * Called by the stream. Do not call this directly.
   */
  start(n) {
    this.listener = n, n.next(this.internalValue), this.callbacks && this.callbacks.onStarted();
  }
  /**
   * Called by the stream. Do not call this directly.
   */
  stop() {
    this.callbacks && this.callbacks.onStop(), this.listener = void 0;
  }
}
uo.DefaultValueProducer = Ay;
var co = {};
Object.defineProperty(co, "__esModule", { value: !0 });
co.dropDuplicates = void 0;
function Iy(e) {
  return (r) => {
    const t = /* @__PURE__ */ new Set();
    return r.filter((f) => !t.has(e(f))).debug((f) => t.add(e(f)));
  };
}
co.dropDuplicates = Iy;
var at = {};
Object.defineProperty(at, "__esModule", { value: !0 });
at.firstEvent = at.toListPromise = at.fromListPromise = void 0;
const Ty = Ue;
function Cy(e) {
  const n = {
    start: (r) => {
      e.then((t) => {
        for (const i of t)
          r.next(i);
        r.complete();
      }).catch((t) => r.error(t));
    },
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    stop: () => {
    }
  };
  return Ty.Stream.create(n);
}
at.fromListPromise = Cy;
async function Gc(e, n) {
  return new Promise((r, t) => {
    if (n === 0) {
      r([]);
      return;
    }
    const i = new Array();
    e.take(n).subscribe({
      next: (f) => {
        i.push(f), i.length === n && r(i);
      },
      complete: () => {
        t(`Stream completed before all events could be collected. Collected ${i.length}, expected ${n}`);
      },
      error: (f) => t(f)
    });
  });
}
at.toListPromise = Gc;
async function Ny(e) {
  return (await Gc(e, 1))[0];
}
at.firstEvent = Ny;
var Hn = {};
Object.defineProperty(Hn, "__esModule", { value: !0 });
Hn.lastValue = Hn.asArray = Hn.countStream = Hn.Reducer = void 0;
class lo {
  constructor(n, r, t) {
    this.stream = n, this.reducer = r, this.state = t, this.completed = new Promise((i, f) => {
      const k = this.stream.subscribe({
        next: (C) => {
          this.state = this.reducer(this.state, C);
        },
        complete: () => {
          i(), k.unsubscribe();
        },
        error: (C) => {
          f(C), k.unsubscribe();
        }
      });
    });
  }
  // value returns current materialized state
  value() {
    return this.state;
  }
  // finished resolves on completed stream, rejects on stream error
  async finished() {
    return this.completed;
  }
}
Hn.Reducer = lo;
function wy(e, n) {
  return e + 1;
}
function _y(e) {
  return new lo(e, wy, 0);
}
Hn.countStream = _y;
function Ey(e, n) {
  return [...e, n];
}
function Jy(e) {
  return new lo(e, Ey, []);
}
Hn.asArray = Jy;
function Uy(e, n) {
  return n;
}
function Dy(e) {
  return new lo(e, Uy, void 0);
}
Hn.lastValue = Dy;
var fo = {};
Object.defineProperty(fo, "__esModule", { value: !0 });
fo.ValueAndUpdates = void 0;
const My = Ue;
class Hy {
  get value() {
    return this.producer.value;
  }
  constructor(n) {
    this.producer = n, this.updates = My.MemoryStream.createWithMemory(this.producer);
  }
  /**
   * Resolves as soon as search value is found.
   *
   * @param search either a value or a function that must return true when found
   * @returns the value of the update that caused the search match
   */
  async waitFor(n) {
    const r = typeof n == "function" ? n : (t) => t === n;
    return new Promise((t, i) => {
      const f = this.updates.subscribe({
        next: (k) => {
          r(k) && (t(k), setTimeout(() => f.unsubscribe(), 0));
        },
        complete: () => {
          f.unsubscribe(), i("Update stream completed without expected value");
        },
        error: (k) => {
          i(k);
        }
      });
    });
  }
}
fo.ValueAndUpdates = Hy;
(function(e) {
  var n = j && j.__createBinding || (Object.create ? function(T, U, w, N) {
    N === void 0 && (N = w);
    var h = Object.getOwnPropertyDescriptor(U, w);
    (!h || ("get" in h ? !U.__esModule : h.writable || h.configurable)) && (h = { enumerable: !0, get: function() {
      return U[w];
    } }), Object.defineProperty(T, N, h);
  } : function(T, U, w, N) {
    N === void 0 && (N = w), T[N] = U[w];
  }), r = j && j.__exportStar || function(T, U) {
    for (var w in T)
      w !== "default" && !Object.prototype.hasOwnProperty.call(U, w) && n(U, T, w);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueAndUpdates = e.toListPromise = e.fromListPromise = e.firstEvent = e.dropDuplicates = e.DefaultValueProducer = e.concat = void 0;
  var t = so;
  Object.defineProperty(e, "concat", { enumerable: !0, get: function() {
    return t.concat;
  } });
  var i = uo;
  Object.defineProperty(e, "DefaultValueProducer", { enumerable: !0, get: function() {
    return i.DefaultValueProducer;
  } });
  var f = co;
  Object.defineProperty(e, "dropDuplicates", { enumerable: !0, get: function() {
    return f.dropDuplicates;
  } });
  var k = at;
  Object.defineProperty(e, "firstEvent", { enumerable: !0, get: function() {
    return k.firstEvent;
  } }), Object.defineProperty(e, "fromListPromise", { enumerable: !0, get: function() {
    return k.fromListPromise;
  } }), Object.defineProperty(e, "toListPromise", { enumerable: !0, get: function() {
    return k.toListPromise;
  } }), r(Hn, e);
  var C = fo;
  Object.defineProperty(e, "ValueAndUpdates", { enumerable: !0, get: function() {
    return C.ValueAndUpdates;
  } });
})(ei);
Object.defineProperty(to, "__esModule", { value: !0 });
to.QueryClient = void 0;
const Pt = yc, vt = Ct, qy = ei, Ye = an;
function pi(e, n, r) {
  if (e.type !== n)
    throw new Error(`Op expected to be ${n}, got "${e.type}`);
  if (!(0, Ye.arrayContentEquals)(r, e.key))
    throw new Error(`Proven key different than queried key.
Query: ${(0, vt.toHex)(r)}
Proven: ${(0, vt.toHex)(e.key)}`);
  return Pt.ics23.CommitmentProof.decode(e.data);
}
class yd {
  static withExtensions(n, ...r) {
    const t = new yd(n), i = r.map((f) => f(t));
    for (const f of i) {
      (0, Ye.assert)((0, Ye.isNonNullObject)(f), "Extension must be a non-null object");
      for (const [k, C] of Object.entries(f)) {
        (0, Ye.assert)((0, Ye.isNonNullObject)(C), `Module must be a non-null object. Found type ${typeof C} for module "${k}".`);
        const T = t[k] || {};
        t[k] = {
          ...T,
          ...C
        };
      }
    }
    return t;
  }
  constructor(n) {
    this.cometClient = n;
  }
  /**
   * Queries the database store with a proof, which is then verified.
   *
   * Please note: the current implementation trusts block headers it gets from the PRC endpoint.
   */
  async queryStoreVerified(n, r, t) {
    const { height: i, proof: f, key: k, value: C } = await this.queryRawProof(n, r, t), T = pi(f.ops[0], "ics23:iavl", r), U = pi(f.ops[1], "ics23:simple", (0, vt.toAscii)(n));
    (0, Ye.assert)(U.exist), (0, Ye.assert)(U.exist.value), !C || C.length === 0 ? ((0, Ye.assert)(T.nonexist), (0, Pt.verifyNonExistence)(T.nonexist, Pt.iavlSpec, U.exist.value, r)) : ((0, Ye.assert)(T.exist), (0, Ye.assert)(T.exist.value), (0, Pt.verifyExistence)(T.exist, Pt.iavlSpec, U.exist.value, r, C));
    const w = await this.getNextHeader(i);
    return (0, Pt.verifyExistence)(U.exist, Pt.tendermintSpec, w.appHash, (0, vt.toAscii)(n), U.exist.value), { key: k, value: C, height: i };
  }
  async queryRawProof(n, r, t) {
    const { key: i, value: f, height: k, proof: C, code: T, log: U } = await this.cometClient.abciQuery({
      // we need the StoreKey for the module, not the module name
      // https://github.com/cosmos/cosmos-sdk/blob/8cab43c8120fec5200c3459cbf4a92017bb6f287/x/auth/types/keys.go#L12
      path: `/store/${n}/key`,
      data: r,
      prove: !0,
      height: t
    });
    if (T)
      throw new Error(`Query failed with (${T}): ${U}`);
    if (!(0, Ye.arrayContentEquals)(r, i))
      throw new Error(`Response key ${(0, vt.toHex)(i)} doesn't match query key ${(0, vt.toHex)(r)}`);
    if (!k)
      throw new Error("No query height returned");
    if (!C || C.ops.length !== 2)
      throw new Error(`Expected 2 proof ops, got ${(C == null ? void 0 : C.ops.length) ?? 0}. Are you using stargate?`);
    return pi(C.ops[0], "ics23:iavl", i), pi(C.ops[1], "ics23:simple", (0, vt.toAscii)(n)), {
      key: i,
      value: f,
      height: k,
      // need to clone this: readonly input / writeable output
      proof: {
        ops: [...C.ops]
      }
    };
  }
  /**
   * Performs an ABCI query to Tendermint without requesting a proof.
   *
   * If the `desiredHeight` is set, a particular height is requested. Otherwise
   * the latest height is requested. The response contains the actual height of
   * the query.
   */
  async queryAbci(n, r, t) {
    const i = await this.cometClient.abciQuery({
      path: n,
      data: r,
      prove: !1,
      height: t
    });
    if (i.code)
      throw new Error(`Query failed with (${i.code}): ${i.log}`);
    if (!i.height)
      throw new Error("No query height returned");
    return {
      value: i.value,
      height: i.height
    };
  }
  // this must return the header for height+1
  // throws an error if height is 0 or undefined
  async getNextHeader(n) {
    if ((0, Ye.assertDefined)(n), n === 0)
      throw new Error("Query returned height 0, cannot prove it");
    const r = n + 1;
    let t, i;
    try {
      i = this.cometClient.subscribeNewBlockHeader();
    } catch {
    }
    if (i) {
      const f = await (0, qy.firstEvent)(i);
      f.height === r && (t = f);
    }
    for (; !t; ) {
      const f = (await this.cometClient.blockchain(n, r)).blockMetas.map((k) => k.header).find((k) => k.height === r);
      f ? t = f : await (0, Ye.sleep)(1e3);
    }
    return (0, Ye.assert)(t.height === r, "Got wrong header. This is a bug in the logic above."), t;
  }
}
to.QueryClient = yd;
var hn = {};
Object.defineProperty(hn, "__esModule", { value: !0 });
hn.decodeCosmosSdkDecFromProto = hn.longify = hn.createProtobufRpcClient = hn.createPagination = hn.toAccAddress = void 0;
const $c = Ct, zc = mt, Bu = Ae;
function Vy(e) {
  return (0, $c.fromBech32)(e).data;
}
hn.toAccAddress = Vy;
function Qy(e) {
  return e ? Bu.PageRequest.fromPartial({ key: e }) : Bu.PageRequest.fromPartial({});
}
hn.createPagination = Qy;
function Wy(e) {
  return {
    request: async (n, r, t) => {
      const i = `/${n}/${r}`;
      return (await e.queryAbci(i, t, void 0)).value;
    }
  };
}
hn.createProtobufRpcClient = Wy;
function Fy(e) {
  const n = zc.Uint64.fromString(e.toString());
  return BigInt(n.toString());
}
hn.longify = Fy;
function Ly(e) {
  const n = typeof e == "string" ? e : (0, $c.fromAscii)(e);
  return zc.Decimal.fromAtomics(n, 18);
}
hn.decodeCosmosSdkDecFromProto = Ly;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.longify = e.decodeCosmosSdkDecFromProto = e.createProtobufRpcClient = e.createPagination = e.QueryClient = void 0;
  var n = to;
  Object.defineProperty(e, "QueryClient", { enumerable: !0, get: function() {
    return n.QueryClient;
  } });
  var r = hn;
  Object.defineProperty(e, "createPagination", { enumerable: !0, get: function() {
    return r.createPagination;
  } }), Object.defineProperty(e, "createProtobufRpcClient", { enumerable: !0, get: function() {
    return r.createProtobufRpcClient;
  } }), Object.defineProperty(e, "decodeCosmosSdkDecFromProto", { enumerable: !0, get: function() {
    return r.decodeCosmosSdkDecFromProto;
  } }), Object.defineProperty(e, "longify", { enumerable: !0, get: function() {
    return r.longify;
  } });
})(Ge);
Object.defineProperty(no, "__esModule", { value: !0 });
no.setupAuthExtension = void 0;
const Gy = hc, $y = Ge;
function zy(e) {
  const n = (0, $y.createProtobufRpcClient)(e), r = new Gy.QueryClientImpl(n);
  return {
    auth: {
      account: async (t) => {
        const { account: i } = await r.Account({ address: t });
        return i ?? null;
      }
    }
  };
}
no.setupAuthExtension = zy;
var po = {};
Object.defineProperty(po, "__esModule", { value: !0 });
po.createAuthzAminoConverters = void 0;
function Ky() {
  return {
    // For Cosmos SDK < 0.46 the Amino JSON codec was broken on chain and thus inaccessible.
    // Now this can be implemented for 0.46+ chains, see
    // https://github.com/cosmos/cosmjs/issues/1092
    //
    // "/cosmos.authz.v1beta1.MsgGrant": IMPLEMENT ME,
    // "/cosmos.authz.v1beta1.MsgExec": IMPLEMENT ME,
    // "/cosmos.authz.v1beta1.MsgRevoke": IMPLEMENT ME,
  };
}
po.createAuthzAminoConverters = Ky;
var ho = {}, Kc = {}, cn = {}, _e = {};
Object.defineProperty(_e, "__esModule", { value: !0 });
_e.Timestamp = _e.protobufPackage = void 0;
const za = re, Ou = ie;
_e.protobufPackage = "google.protobuf";
function Ka() {
  return {
    seconds: BigInt(0),
    nanos: 0
  };
}
_e.Timestamp = {
  typeUrl: "/google.protobuf.Timestamp",
  encode(e, n = za.BinaryWriter.create()) {
    return e.seconds !== BigInt(0) && n.uint32(8).int64(e.seconds), e.nanos !== 0 && n.uint32(16).int32(e.nanos), n;
  },
  decode(e, n) {
    const r = e instanceof za.BinaryReader ? e : new za.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = Ka();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.seconds = r.int64();
          break;
        case 2:
          i.nanos = r.int32();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = Ka();
    return (0, Ou.isSet)(e.seconds) && (n.seconds = BigInt(e.seconds.toString())), (0, Ou.isSet)(e.nanos) && (n.nanos = Number(e.nanos)), n;
  },
  toJSON(e) {
    const n = {};
    return e.seconds !== void 0 && (n.seconds = (e.seconds || BigInt(0)).toString()), e.nanos !== void 0 && (n.nanos = Math.round(e.nanos)), n;
  },
  fromPartial(e) {
    const n = Ka();
    return e.seconds !== void 0 && e.seconds !== null && (n.seconds = BigInt(e.seconds.toString())), n.nanos = e.nanos ?? 0, n;
  }
};
Object.defineProperty(cn, "__esModule", { value: !0 });
cn.GrantQueueItem = cn.GrantAuthorization = cn.Grant = cn.GenericAuthorization = cn.protobufPackage = void 0;
const Dn = Be, zt = _e, On = re, Cn = ie;
cn.protobufPackage = "cosmos.authz.v1beta1";
function xa() {
  return {
    msg: ""
  };
}
cn.GenericAuthorization = {
  typeUrl: "/cosmos.authz.v1beta1.GenericAuthorization",
  encode(e, n = On.BinaryWriter.create()) {
    return e.msg !== "" && n.uint32(10).string(e.msg), n;
  },
  decode(e, n) {
    const r = e instanceof On.BinaryReader ? e : new On.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = xa();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.msg = r.string();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = xa();
    return (0, Cn.isSet)(e.msg) && (n.msg = String(e.msg)), n;
  },
  toJSON(e) {
    const n = {};
    return e.msg !== void 0 && (n.msg = e.msg), n;
  },
  fromPartial(e) {
    const n = xa();
    return n.msg = e.msg ?? "", n;
  }
};
function Za() {
  return {
    authorization: void 0,
    expiration: void 0
  };
}
cn.Grant = {
  typeUrl: "/cosmos.authz.v1beta1.Grant",
  encode(e, n = On.BinaryWriter.create()) {
    return e.authorization !== void 0 && Dn.Any.encode(e.authorization, n.uint32(10).fork()).ldelim(), e.expiration !== void 0 && zt.Timestamp.encode(e.expiration, n.uint32(18).fork()).ldelim(), n;
  },
  decode(e, n) {
    const r = e instanceof On.BinaryReader ? e : new On.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = Za();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.authorization = Dn.Any.decode(r, r.uint32());
          break;
        case 2:
          i.expiration = zt.Timestamp.decode(r, r.uint32());
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = Za();
    return (0, Cn.isSet)(e.authorization) && (n.authorization = Dn.Any.fromJSON(e.authorization)), (0, Cn.isSet)(e.expiration) && (n.expiration = (0, Cn.fromJsonTimestamp)(e.expiration)), n;
  },
  toJSON(e) {
    const n = {};
    return e.authorization !== void 0 && (n.authorization = e.authorization ? Dn.Any.toJSON(e.authorization) : void 0), e.expiration !== void 0 && (n.expiration = (0, Cn.fromTimestamp)(e.expiration).toISOString()), n;
  },
  fromPartial(e) {
    const n = Za();
    return e.authorization !== void 0 && e.authorization !== null && (n.authorization = Dn.Any.fromPartial(e.authorization)), e.expiration !== void 0 && e.expiration !== null && (n.expiration = zt.Timestamp.fromPartial(e.expiration)), n;
  }
};
function Ya() {
  return {
    granter: "",
    grantee: "",
    authorization: void 0,
    expiration: void 0
  };
}
cn.GrantAuthorization = {
  typeUrl: "/cosmos.authz.v1beta1.GrantAuthorization",
  encode(e, n = On.BinaryWriter.create()) {
    return e.granter !== "" && n.uint32(10).string(e.granter), e.grantee !== "" && n.uint32(18).string(e.grantee), e.authorization !== void 0 && Dn.Any.encode(e.authorization, n.uint32(26).fork()).ldelim(), e.expiration !== void 0 && zt.Timestamp.encode(e.expiration, n.uint32(34).fork()).ldelim(), n;
  },
  decode(e, n) {
    const r = e instanceof On.BinaryReader ? e : new On.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = Ya();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.granter = r.string();
          break;
        case 2:
          i.grantee = r.string();
          break;
        case 3:
          i.authorization = Dn.Any.decode(r, r.uint32());
          break;
        case 4:
          i.expiration = zt.Timestamp.decode(r, r.uint32());
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = Ya();
    return (0, Cn.isSet)(e.granter) && (n.granter = String(e.granter)), (0, Cn.isSet)(e.grantee) && (n.grantee = String(e.grantee)), (0, Cn.isSet)(e.authorization) && (n.authorization = Dn.Any.fromJSON(e.authorization)), (0, Cn.isSet)(e.expiration) && (n.expiration = (0, Cn.fromJsonTimestamp)(e.expiration)), n;
  },
  toJSON(e) {
    const n = {};
    return e.granter !== void 0 && (n.granter = e.granter), e.grantee !== void 0 && (n.grantee = e.grantee), e.authorization !== void 0 && (n.authorization = e.authorization ? Dn.Any.toJSON(e.authorization) : void 0), e.expiration !== void 0 && (n.expiration = (0, Cn.fromTimestamp)(e.expiration).toISOString()), n;
  },
  fromPartial(e) {
    const n = Ya();
    return n.granter = e.granter ?? "", n.grantee = e.grantee ?? "", e.authorization !== void 0 && e.authorization !== null && (n.authorization = Dn.Any.fromPartial(e.authorization)), e.expiration !== void 0 && e.expiration !== null && (n.expiration = zt.Timestamp.fromPartial(e.expiration)), n;
  }
};
function Xa() {
  return {
    msgTypeUrls: []
  };
}
cn.GrantQueueItem = {
  typeUrl: "/cosmos.authz.v1beta1.GrantQueueItem",
  encode(e, n = On.BinaryWriter.create()) {
    for (const r of e.msgTypeUrls)
      n.uint32(10).string(r);
    return n;
  },
  decode(e, n) {
    const r = e instanceof On.BinaryReader ? e : new On.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = Xa();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.msgTypeUrls.push(r.string());
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = Xa();
    return Array.isArray(e == null ? void 0 : e.msgTypeUrls) && (n.msgTypeUrls = e.msgTypeUrls.map((r) => String(r))), n;
  },
  toJSON(e) {
    const n = {};
    return e.msgTypeUrls ? n.msgTypeUrls = e.msgTypeUrls.map((r) => r) : n.msgTypeUrls = [], n;
  },
  fromPartial(e) {
    var r;
    const n = Xa();
    return n.msgTypeUrls = ((r = e.msgTypeUrls) == null ? void 0 : r.map((t) => t)) || [], n;
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgRevokeResponse = e.MsgRevoke = e.MsgGrantResponse = e.MsgExec = e.MsgExecResponse = e.MsgGrant = e.protobufPackage = void 0;
  const n = cn, r = Be, t = re, i = ie;
  e.protobufPackage = "cosmos.authz.v1beta1";
  function f() {
    return {
      granter: "",
      grantee: "",
      grant: n.Grant.fromPartial({})
    };
  }
  e.MsgGrant = {
    typeUrl: "/cosmos.authz.v1beta1.MsgGrant",
    encode(h, P = t.BinaryWriter.create()) {
      return h.granter !== "" && P.uint32(10).string(h.granter), h.grantee !== "" && P.uint32(18).string(h.grantee), h.grant !== void 0 && n.Grant.encode(h.grant, P.uint32(26).fork()).ldelim(), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = f();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.granter = b.string();
            break;
          case 2:
            l.grantee = b.string();
            break;
          case 3:
            l.grant = n.Grant.decode(b, b.uint32());
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = f();
      return (0, i.isSet)(h.granter) && (P.granter = String(h.granter)), (0, i.isSet)(h.grantee) && (P.grantee = String(h.grantee)), (0, i.isSet)(h.grant) && (P.grant = n.Grant.fromJSON(h.grant)), P;
    },
    toJSON(h) {
      const P = {};
      return h.granter !== void 0 && (P.granter = h.granter), h.grantee !== void 0 && (P.grantee = h.grantee), h.grant !== void 0 && (P.grant = h.grant ? n.Grant.toJSON(h.grant) : void 0), P;
    },
    fromPartial(h) {
      const P = f();
      return P.granter = h.granter ?? "", P.grantee = h.grantee ?? "", h.grant !== void 0 && h.grant !== null && (P.grant = n.Grant.fromPartial(h.grant)), P;
    }
  };
  function k() {
    return {
      results: []
    };
  }
  e.MsgExecResponse = {
    typeUrl: "/cosmos.authz.v1beta1.MsgExecResponse",
    encode(h, P = t.BinaryWriter.create()) {
      for (const b of h.results)
        P.uint32(10).bytes(b);
      return P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = k();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.results.push(b.bytes());
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = k();
      return Array.isArray(h == null ? void 0 : h.results) && (P.results = h.results.map((b) => (0, i.bytesFromBase64)(b))), P;
    },
    toJSON(h) {
      const P = {};
      return h.results ? P.results = h.results.map((b) => (0, i.base64FromBytes)(b !== void 0 ? b : new Uint8Array())) : P.results = [], P;
    },
    fromPartial(h) {
      var b;
      const P = k();
      return P.results = ((b = h.results) == null ? void 0 : b.map((c) => c)) || [], P;
    }
  };
  function C() {
    return {
      grantee: "",
      msgs: []
    };
  }
  e.MsgExec = {
    typeUrl: "/cosmos.authz.v1beta1.MsgExec",
    encode(h, P = t.BinaryWriter.create()) {
      h.grantee !== "" && P.uint32(10).string(h.grantee);
      for (const b of h.msgs)
        r.Any.encode(b, P.uint32(18).fork()).ldelim();
      return P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = C();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.grantee = b.string();
            break;
          case 2:
            l.msgs.push(r.Any.decode(b, b.uint32()));
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = C();
      return (0, i.isSet)(h.grantee) && (P.grantee = String(h.grantee)), Array.isArray(h == null ? void 0 : h.msgs) && (P.msgs = h.msgs.map((b) => r.Any.fromJSON(b))), P;
    },
    toJSON(h) {
      const P = {};
      return h.grantee !== void 0 && (P.grantee = h.grantee), h.msgs ? P.msgs = h.msgs.map((b) => b ? r.Any.toJSON(b) : void 0) : P.msgs = [], P;
    },
    fromPartial(h) {
      var b;
      const P = C();
      return P.grantee = h.grantee ?? "", P.msgs = ((b = h.msgs) == null ? void 0 : b.map((c) => r.Any.fromPartial(c))) || [], P;
    }
  };
  function T() {
    return {};
  }
  e.MsgGrantResponse = {
    typeUrl: "/cosmos.authz.v1beta1.MsgGrantResponse",
    encode(h, P = t.BinaryWriter.create()) {
      return P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = T();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      return T();
    },
    toJSON(h) {
      return {};
    },
    fromPartial(h) {
      return T();
    }
  };
  function U() {
    return {
      granter: "",
      grantee: "",
      msgTypeUrl: ""
    };
  }
  e.MsgRevoke = {
    typeUrl: "/cosmos.authz.v1beta1.MsgRevoke",
    encode(h, P = t.BinaryWriter.create()) {
      return h.granter !== "" && P.uint32(10).string(h.granter), h.grantee !== "" && P.uint32(18).string(h.grantee), h.msgTypeUrl !== "" && P.uint32(26).string(h.msgTypeUrl), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = U();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.granter = b.string();
            break;
          case 2:
            l.grantee = b.string();
            break;
          case 3:
            l.msgTypeUrl = b.string();
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = U();
      return (0, i.isSet)(h.granter) && (P.granter = String(h.granter)), (0, i.isSet)(h.grantee) && (P.grantee = String(h.grantee)), (0, i.isSet)(h.msgTypeUrl) && (P.msgTypeUrl = String(h.msgTypeUrl)), P;
    },
    toJSON(h) {
      const P = {};
      return h.granter !== void 0 && (P.granter = h.granter), h.grantee !== void 0 && (P.grantee = h.grantee), h.msgTypeUrl !== void 0 && (P.msgTypeUrl = h.msgTypeUrl), P;
    },
    fromPartial(h) {
      const P = U();
      return P.granter = h.granter ?? "", P.grantee = h.grantee ?? "", P.msgTypeUrl = h.msgTypeUrl ?? "", P;
    }
  };
  function w() {
    return {};
  }
  e.MsgRevokeResponse = {
    typeUrl: "/cosmos.authz.v1beta1.MsgRevokeResponse",
    encode(h, P = t.BinaryWriter.create()) {
      return P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = w();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      return w();
    },
    toJSON(h) {
      return {};
    },
    fromPartial(h) {
      return w();
    }
  };
  class N {
    constructor(P) {
      this.rpc = P, this.Grant = this.Grant.bind(this), this.Exec = this.Exec.bind(this), this.Revoke = this.Revoke.bind(this);
    }
    Grant(P) {
      const b = e.MsgGrant.encode(P).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Msg", "Grant", b).then((l) => e.MsgGrantResponse.decode(new t.BinaryReader(l)));
    }
    Exec(P) {
      const b = e.MsgExec.encode(P).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Msg", "Exec", b).then((l) => e.MsgExecResponse.decode(new t.BinaryReader(l)));
    }
    Revoke(P) {
      const b = e.MsgRevoke.encode(P).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Msg", "Revoke", b).then((l) => e.MsgRevokeResponse.decode(new t.BinaryReader(l)));
    }
  }
  e.MsgClientImpl = N;
})(Kc);
Object.defineProperty(ho, "__esModule", { value: !0 });
ho.authzTypes = void 0;
const ja = Kc;
ho.authzTypes = [
  ["/cosmos.authz.v1beta1.MsgExec", ja.MsgExec],
  ["/cosmos.authz.v1beta1.MsgGrant", ja.MsgGrant],
  ["/cosmos.authz.v1beta1.MsgRevoke", ja.MsgRevoke]
];
var yo = {}, xc = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryGranteeGrantsResponse = e.QueryGranteeGrantsRequest = e.QueryGranterGrantsResponse = e.QueryGranterGrantsRequest = e.QueryGrantsResponse = e.QueryGrantsRequest = e.protobufPackage = void 0;
  const n = Ae, r = cn, t = re, i = ie;
  e.protobufPackage = "cosmos.authz.v1beta1";
  function f() {
    return {
      granter: "",
      grantee: "",
      msgTypeUrl: "",
      pagination: void 0
    };
  }
  e.QueryGrantsRequest = {
    typeUrl: "/cosmos.authz.v1beta1.QueryGrantsRequest",
    encode(h, P = t.BinaryWriter.create()) {
      return h.granter !== "" && P.uint32(10).string(h.granter), h.grantee !== "" && P.uint32(18).string(h.grantee), h.msgTypeUrl !== "" && P.uint32(26).string(h.msgTypeUrl), h.pagination !== void 0 && n.PageRequest.encode(h.pagination, P.uint32(34).fork()).ldelim(), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = f();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.granter = b.string();
            break;
          case 2:
            l.grantee = b.string();
            break;
          case 3:
            l.msgTypeUrl = b.string();
            break;
          case 4:
            l.pagination = n.PageRequest.decode(b, b.uint32());
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = f();
      return (0, i.isSet)(h.granter) && (P.granter = String(h.granter)), (0, i.isSet)(h.grantee) && (P.grantee = String(h.grantee)), (0, i.isSet)(h.msgTypeUrl) && (P.msgTypeUrl = String(h.msgTypeUrl)), (0, i.isSet)(h.pagination) && (P.pagination = n.PageRequest.fromJSON(h.pagination)), P;
    },
    toJSON(h) {
      const P = {};
      return h.granter !== void 0 && (P.granter = h.granter), h.grantee !== void 0 && (P.grantee = h.grantee), h.msgTypeUrl !== void 0 && (P.msgTypeUrl = h.msgTypeUrl), h.pagination !== void 0 && (P.pagination = h.pagination ? n.PageRequest.toJSON(h.pagination) : void 0), P;
    },
    fromPartial(h) {
      const P = f();
      return P.granter = h.granter ?? "", P.grantee = h.grantee ?? "", P.msgTypeUrl = h.msgTypeUrl ?? "", h.pagination !== void 0 && h.pagination !== null && (P.pagination = n.PageRequest.fromPartial(h.pagination)), P;
    }
  };
  function k() {
    return {
      grants: [],
      pagination: void 0
    };
  }
  e.QueryGrantsResponse = {
    typeUrl: "/cosmos.authz.v1beta1.QueryGrantsResponse",
    encode(h, P = t.BinaryWriter.create()) {
      for (const b of h.grants)
        r.Grant.encode(b, P.uint32(10).fork()).ldelim();
      return h.pagination !== void 0 && n.PageResponse.encode(h.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = k();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.grants.push(r.Grant.decode(b, b.uint32()));
            break;
          case 2:
            l.pagination = n.PageResponse.decode(b, b.uint32());
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = k();
      return Array.isArray(h == null ? void 0 : h.grants) && (P.grants = h.grants.map((b) => r.Grant.fromJSON(b))), (0, i.isSet)(h.pagination) && (P.pagination = n.PageResponse.fromJSON(h.pagination)), P;
    },
    toJSON(h) {
      const P = {};
      return h.grants ? P.grants = h.grants.map((b) => b ? r.Grant.toJSON(b) : void 0) : P.grants = [], h.pagination !== void 0 && (P.pagination = h.pagination ? n.PageResponse.toJSON(h.pagination) : void 0), P;
    },
    fromPartial(h) {
      var b;
      const P = k();
      return P.grants = ((b = h.grants) == null ? void 0 : b.map((c) => r.Grant.fromPartial(c))) || [], h.pagination !== void 0 && h.pagination !== null && (P.pagination = n.PageResponse.fromPartial(h.pagination)), P;
    }
  };
  function C() {
    return {
      granter: "",
      pagination: void 0
    };
  }
  e.QueryGranterGrantsRequest = {
    typeUrl: "/cosmos.authz.v1beta1.QueryGranterGrantsRequest",
    encode(h, P = t.BinaryWriter.create()) {
      return h.granter !== "" && P.uint32(10).string(h.granter), h.pagination !== void 0 && n.PageRequest.encode(h.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = C();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.granter = b.string();
            break;
          case 2:
            l.pagination = n.PageRequest.decode(b, b.uint32());
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = C();
      return (0, i.isSet)(h.granter) && (P.granter = String(h.granter)), (0, i.isSet)(h.pagination) && (P.pagination = n.PageRequest.fromJSON(h.pagination)), P;
    },
    toJSON(h) {
      const P = {};
      return h.granter !== void 0 && (P.granter = h.granter), h.pagination !== void 0 && (P.pagination = h.pagination ? n.PageRequest.toJSON(h.pagination) : void 0), P;
    },
    fromPartial(h) {
      const P = C();
      return P.granter = h.granter ?? "", h.pagination !== void 0 && h.pagination !== null && (P.pagination = n.PageRequest.fromPartial(h.pagination)), P;
    }
  };
  function T() {
    return {
      grants: [],
      pagination: void 0
    };
  }
  e.QueryGranterGrantsResponse = {
    typeUrl: "/cosmos.authz.v1beta1.QueryGranterGrantsResponse",
    encode(h, P = t.BinaryWriter.create()) {
      for (const b of h.grants)
        r.GrantAuthorization.encode(b, P.uint32(10).fork()).ldelim();
      return h.pagination !== void 0 && n.PageResponse.encode(h.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = T();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.grants.push(r.GrantAuthorization.decode(b, b.uint32()));
            break;
          case 2:
            l.pagination = n.PageResponse.decode(b, b.uint32());
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = T();
      return Array.isArray(h == null ? void 0 : h.grants) && (P.grants = h.grants.map((b) => r.GrantAuthorization.fromJSON(b))), (0, i.isSet)(h.pagination) && (P.pagination = n.PageResponse.fromJSON(h.pagination)), P;
    },
    toJSON(h) {
      const P = {};
      return h.grants ? P.grants = h.grants.map((b) => b ? r.GrantAuthorization.toJSON(b) : void 0) : P.grants = [], h.pagination !== void 0 && (P.pagination = h.pagination ? n.PageResponse.toJSON(h.pagination) : void 0), P;
    },
    fromPartial(h) {
      var b;
      const P = T();
      return P.grants = ((b = h.grants) == null ? void 0 : b.map((c) => r.GrantAuthorization.fromPartial(c))) || [], h.pagination !== void 0 && h.pagination !== null && (P.pagination = n.PageResponse.fromPartial(h.pagination)), P;
    }
  };
  function U() {
    return {
      grantee: "",
      pagination: void 0
    };
  }
  e.QueryGranteeGrantsRequest = {
    typeUrl: "/cosmos.authz.v1beta1.QueryGranteeGrantsRequest",
    encode(h, P = t.BinaryWriter.create()) {
      return h.grantee !== "" && P.uint32(10).string(h.grantee), h.pagination !== void 0 && n.PageRequest.encode(h.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = U();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.grantee = b.string();
            break;
          case 2:
            l.pagination = n.PageRequest.decode(b, b.uint32());
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = U();
      return (0, i.isSet)(h.grantee) && (P.grantee = String(h.grantee)), (0, i.isSet)(h.pagination) && (P.pagination = n.PageRequest.fromJSON(h.pagination)), P;
    },
    toJSON(h) {
      const P = {};
      return h.grantee !== void 0 && (P.grantee = h.grantee), h.pagination !== void 0 && (P.pagination = h.pagination ? n.PageRequest.toJSON(h.pagination) : void 0), P;
    },
    fromPartial(h) {
      const P = U();
      return P.grantee = h.grantee ?? "", h.pagination !== void 0 && h.pagination !== null && (P.pagination = n.PageRequest.fromPartial(h.pagination)), P;
    }
  };
  function w() {
    return {
      grants: [],
      pagination: void 0
    };
  }
  e.QueryGranteeGrantsResponse = {
    typeUrl: "/cosmos.authz.v1beta1.QueryGranteeGrantsResponse",
    encode(h, P = t.BinaryWriter.create()) {
      for (const b of h.grants)
        r.GrantAuthorization.encode(b, P.uint32(10).fork()).ldelim();
      return h.pagination !== void 0 && n.PageResponse.encode(h.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = w();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.grants.push(r.GrantAuthorization.decode(b, b.uint32()));
            break;
          case 2:
            l.pagination = n.PageResponse.decode(b, b.uint32());
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = w();
      return Array.isArray(h == null ? void 0 : h.grants) && (P.grants = h.grants.map((b) => r.GrantAuthorization.fromJSON(b))), (0, i.isSet)(h.pagination) && (P.pagination = n.PageResponse.fromJSON(h.pagination)), P;
    },
    toJSON(h) {
      const P = {};
      return h.grants ? P.grants = h.grants.map((b) => b ? r.GrantAuthorization.toJSON(b) : void 0) : P.grants = [], h.pagination !== void 0 && (P.pagination = h.pagination ? n.PageResponse.toJSON(h.pagination) : void 0), P;
    },
    fromPartial(h) {
      var b;
      const P = w();
      return P.grants = ((b = h.grants) == null ? void 0 : b.map((c) => r.GrantAuthorization.fromPartial(c))) || [], h.pagination !== void 0 && h.pagination !== null && (P.pagination = n.PageResponse.fromPartial(h.pagination)), P;
    }
  };
  class N {
    constructor(P) {
      this.rpc = P, this.Grants = this.Grants.bind(this), this.GranterGrants = this.GranterGrants.bind(this), this.GranteeGrants = this.GranteeGrants.bind(this);
    }
    Grants(P) {
      const b = e.QueryGrantsRequest.encode(P).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Query", "Grants", b).then((l) => e.QueryGrantsResponse.decode(new t.BinaryReader(l)));
    }
    GranterGrants(P) {
      const b = e.QueryGranterGrantsRequest.encode(P).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Query", "GranterGrants", b).then((l) => e.QueryGranterGrantsResponse.decode(new t.BinaryReader(l)));
    }
    GranteeGrants(P) {
      const b = e.QueryGranteeGrantsRequest.encode(P).finish();
      return this.rpc.request("cosmos.authz.v1beta1.Query", "GranteeGrants", b).then((l) => e.QueryGranteeGrantsResponse.decode(new t.BinaryReader(l)));
    }
  }
  e.QueryClientImpl = N;
})(xc);
Object.defineProperty(yo, "__esModule", { value: !0 });
yo.setupAuthzExtension = void 0;
const xy = xc, hi = Ge;
function Zy(e) {
  const n = (0, hi.createProtobufRpcClient)(e), r = new xy.QueryClientImpl(n);
  return {
    authz: {
      grants: async (t, i, f, k) => await r.Grants({
        granter: t,
        grantee: i,
        msgTypeUrl: f,
        pagination: (0, hi.createPagination)(k)
      }),
      granteeGrants: async (t, i) => await r.GranteeGrants({
        grantee: t,
        pagination: (0, hi.createPagination)(i)
      }),
      granterGrants: async (t, i) => await r.GranterGrants({
        granter: t,
        pagination: (0, hi.createPagination)(i)
      })
    }
  };
}
yo.setupAuthzExtension = Zy;
var st = {};
Object.defineProperty(st, "__esModule", { value: !0 });
st.createBankAminoConverters = st.isAminoMsgMultiSend = st.isAminoMsgSend = void 0;
function Yy(e) {
  return e.type === "cosmos-sdk/MsgSend";
}
st.isAminoMsgSend = Yy;
function Xy(e) {
  return e.type === "cosmos-sdk/MsgMultiSend";
}
st.isAminoMsgMultiSend = Xy;
function jy() {
  return {
    "/cosmos.bank.v1beta1.MsgSend": {
      aminoType: "cosmos-sdk/MsgSend",
      toAmino: ({ fromAddress: e, toAddress: n, amount: r }) => ({
        from_address: e,
        to_address: n,
        amount: [...r]
      }),
      fromAmino: ({ from_address: e, to_address: n, amount: r }) => ({
        fromAddress: e,
        toAddress: n,
        amount: [...r]
      })
    },
    "/cosmos.bank.v1beta1.MsgMultiSend": {
      aminoType: "cosmos-sdk/MsgMultiSend",
      toAmino: ({ inputs: e, outputs: n }) => ({
        inputs: e.map((r) => ({
          address: r.address,
          coins: [...r.coins]
        })),
        outputs: n.map((r) => ({
          address: r.address,
          coins: [...r.coins]
        }))
      }),
      fromAmino: ({ inputs: e, outputs: n }) => ({
        inputs: e.map((r) => ({
          address: r.address,
          coins: [...r.coins]
        })),
        outputs: n.map((r) => ({
          address: r.address,
          coins: [...r.coins]
        }))
      })
    }
  };
}
st.createBankAminoConverters = jy;
var er = {};
Object.defineProperty(er, "__esModule", { value: !0 });
er.isMsgSendEncodeObject = er.bankTypes = void 0;
const bu = Ap;
er.bankTypes = [
  ["/cosmos.bank.v1beta1.MsgMultiSend", bu.MsgMultiSend],
  ["/cosmos.bank.v1beta1.MsgSend", bu.MsgSend]
];
function em(e) {
  return e.typeUrl === "/cosmos.bank.v1beta1.MsgSend";
}
er.isMsgSendEncodeObject = em;
var mo = {}, Zc = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QuerySendEnabledResponse = e.QuerySendEnabledRequest = e.QueryDenomOwnersResponse = e.DenomOwner = e.QueryDenomOwnersRequest = e.QueryDenomMetadataResponse = e.QueryDenomMetadataRequest = e.QueryDenomsMetadataResponse = e.QueryDenomsMetadataRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.QuerySupplyOfResponse = e.QuerySupplyOfRequest = e.QueryTotalSupplyResponse = e.QueryTotalSupplyRequest = e.QuerySpendableBalanceByDenomResponse = e.QuerySpendableBalanceByDenomRequest = e.QuerySpendableBalancesResponse = e.QuerySpendableBalancesRequest = e.QueryAllBalancesResponse = e.QueryAllBalancesRequest = e.QueryBalanceResponse = e.QueryBalanceRequest = e.protobufPackage = void 0;
  const n = Ae, r = Le, t = Ip, i = re, f = ie;
  e.protobufPackage = "cosmos.bank.v1beta1";
  function k() {
    return {
      address: "",
      denom: ""
    };
  }
  e.QueryBalanceRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QueryBalanceRequest",
    encode(v, D = i.BinaryWriter.create()) {
      return v.address !== "" && D.uint32(10).string(v.address), v.denom !== "" && D.uint32(18).string(v.denom), D;
    },
    decode(v, D) {
      const W = v instanceof i.BinaryReader ? v : new i.BinaryReader(v);
      let H = D === void 0 ? W.len : W.pos + D;
      const a = k();
      for (; W.pos < H; ) {
        const g = W.uint32();
        switch (g >>> 3) {
          case 1:
            a.address = W.string();
            break;
          case 2:
            a.denom = W.string();
            break;
          default:
            W.skipType(g & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(v) {
      const D = k();
      return (0, f.isSet)(v.address) && (D.address = String(v.address)), (0, f.isSet)(v.denom) && (D.denom = String(v.denom)), D;
    },
    toJSON(v) {
      const D = {};
      return v.address !== void 0 && (D.address = v.address), v.denom !== void 0 && (D.denom = v.denom), D;
    },
    fromPartial(v) {
      const D = k();
      return D.address = v.address ?? "", D.denom = v.denom ?? "", D;
    }
  };
  function C() {
    return {
      balance: void 0
    };
  }
  e.QueryBalanceResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QueryBalanceResponse",
    encode(v, D = i.BinaryWriter.create()) {
      return v.balance !== void 0 && r.Coin.encode(v.balance, D.uint32(10).fork()).ldelim(), D;
    },
    decode(v, D) {
      const W = v instanceof i.BinaryReader ? v : new i.BinaryReader(v);
      let H = D === void 0 ? W.len : W.pos + D;
      const a = C();
      for (; W.pos < H; ) {
        const g = W.uint32();
        switch (g >>> 3) {
          case 1:
            a.balance = r.Coin.decode(W, W.uint32());
            break;
          default:
            W.skipType(g & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(v) {
      const D = C();
      return (0, f.isSet)(v.balance) && (D.balance = r.Coin.fromJSON(v.balance)), D;
    },
    toJSON(v) {
      const D = {};
      return v.balance !== void 0 && (D.balance = v.balance ? r.Coin.toJSON(v.balance) : void 0), D;
    },
    fromPartial(v) {
      const D = C();
      return v.balance !== void 0 && v.balance !== null && (D.balance = r.Coin.fromPartial(v.balance)), D;
    }
  };
  function T() {
    return {
      address: "",
      pagination: void 0
    };
  }
  e.QueryAllBalancesRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QueryAllBalancesRequest",
    encode(v, D = i.BinaryWriter.create()) {
      return v.address !== "" && D.uint32(10).string(v.address), v.pagination !== void 0 && n.PageRequest.encode(v.pagination, D.uint32(18).fork()).ldelim(), D;
    },
    decode(v, D) {
      const W = v instanceof i.BinaryReader ? v : new i.BinaryReader(v);
      let H = D === void 0 ? W.len : W.pos + D;
      const a = T();
      for (; W.pos < H; ) {
        const g = W.uint32();
        switch (g >>> 3) {
          case 1:
            a.address = W.string();
            break;
          case 2:
            a.pagination = n.PageRequest.decode(W, W.uint32());
            break;
          default:
            W.skipType(g & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(v) {
      const D = T();
      return (0, f.isSet)(v.address) && (D.address = String(v.address)), (0, f.isSet)(v.pagination) && (D.pagination = n.PageRequest.fromJSON(v.pagination)), D;
    },
    toJSON(v) {
      const D = {};
      return v.address !== void 0 && (D.address = v.address), v.pagination !== void 0 && (D.pagination = v.pagination ? n.PageRequest.toJSON(v.pagination) : void 0), D;
    },
    fromPartial(v) {
      const D = T();
      return D.address = v.address ?? "", v.pagination !== void 0 && v.pagination !== null && (D.pagination = n.PageRequest.fromPartial(v.pagination)), D;
    }
  };
  function U() {
    return {
      balances: [],
      pagination: void 0
    };
  }
  e.QueryAllBalancesResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QueryAllBalancesResponse",
    encode(v, D = i.BinaryWriter.create()) {
      for (const W of v.balances)
        r.Coin.encode(W, D.uint32(10).fork()).ldelim();
      return v.pagination !== void 0 && n.PageResponse.encode(v.pagination, D.uint32(18).fork()).ldelim(), D;
    },
    decode(v, D) {
      const W = v instanceof i.BinaryReader ? v : new i.BinaryReader(v);
      let H = D === void 0 ? W.len : W.pos + D;
      const a = U();
      for (; W.pos < H; ) {
        const g = W.uint32();
        switch (g >>> 3) {
          case 1:
            a.balances.push(r.Coin.decode(W, W.uint32()));
            break;
          case 2:
            a.pagination = n.PageResponse.decode(W, W.uint32());
            break;
          default:
            W.skipType(g & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(v) {
      const D = U();
      return Array.isArray(v == null ? void 0 : v.balances) && (D.balances = v.balances.map((W) => r.Coin.fromJSON(W))), (0, f.isSet)(v.pagination) && (D.pagination = n.PageResponse.fromJSON(v.pagination)), D;
    },
    toJSON(v) {
      const D = {};
      return v.balances ? D.balances = v.balances.map((W) => W ? r.Coin.toJSON(W) : void 0) : D.balances = [], v.pagination !== void 0 && (D.pagination = v.pagination ? n.PageResponse.toJSON(v.pagination) : void 0), D;
    },
    fromPartial(v) {
      var W;
      const D = U();
      return D.balances = ((W = v.balances) == null ? void 0 : W.map((H) => r.Coin.fromPartial(H))) || [], v.pagination !== void 0 && v.pagination !== null && (D.pagination = n.PageResponse.fromPartial(v.pagination)), D;
    }
  };
  function w() {
    return {
      address: "",
      pagination: void 0
    };
  }
  e.QuerySpendableBalancesRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalancesRequest",
    encode(v, D = i.BinaryWriter.create()) {
      return v.address !== "" && D.uint32(10).string(v.address), v.pagination !== void 0 && n.PageRequest.encode(v.pagination, D.uint32(18).fork()).ldelim(), D;
    },
    decode(v, D) {
      const W = v instanceof i.BinaryReader ? v : new i.BinaryReader(v);
      let H = D === void 0 ? W.len : W.pos + D;
      const a = w();
      for (; W.pos < H; ) {
        const g = W.uint32();
        switch (g >>> 3) {
          case 1:
            a.address = W.string();
            break;
          case 2:
            a.pagination = n.PageRequest.decode(W, W.uint32());
            break;
          default:
            W.skipType(g & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(v) {
      const D = w();
      return (0, f.isSet)(v.address) && (D.address = String(v.address)), (0, f.isSet)(v.pagination) && (D.pagination = n.PageRequest.fromJSON(v.pagination)), D;
    },
    toJSON(v) {
      const D = {};
      return v.address !== void 0 && (D.address = v.address), v.pagination !== void 0 && (D.pagination = v.pagination ? n.PageRequest.toJSON(v.pagination) : void 0), D;
    },
    fromPartial(v) {
      const D = w();
      return D.address = v.address ?? "", v.pagination !== void 0 && v.pagination !== null && (D.pagination = n.PageRequest.fromPartial(v.pagination)), D;
    }
  };
  function N() {
    return {
      balances: [],
      pagination: void 0
    };
  }
  e.QuerySpendableBalancesResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalancesResponse",
    encode(v, D = i.BinaryWriter.create()) {
      for (const W of v.balances)
        r.Coin.encode(W, D.uint32(10).fork()).ldelim();
      return v.pagination !== void 0 && n.PageResponse.encode(v.pagination, D.uint32(18).fork()).ldelim(), D;
    },
    decode(v, D) {
      const W = v instanceof i.BinaryReader ? v : new i.BinaryReader(v);
      let H = D === void 0 ? W.len : W.pos + D;
      const a = N();
      for (; W.pos < H; ) {
        const g = W.uint32();
        switch (g >>> 3) {
          case 1:
            a.balances.push(r.Coin.decode(W, W.uint32()));
            break;
          case 2:
            a.pagination = n.PageResponse.decode(W, W.uint32());
            break;
          default:
            W.skipType(g & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(v) {
      const D = N();
      return Array.isArray(v == null ? void 0 : v.balances) && (D.balances = v.balances.map((W) => r.Coin.fromJSON(W))), (0, f.isSet)(v.pagination) && (D.pagination = n.PageResponse.fromJSON(v.pagination)), D;
    },
    toJSON(v) {
      const D = {};
      return v.balances ? D.balances = v.balances.map((W) => W ? r.Coin.toJSON(W) : void 0) : D.balances = [], v.pagination !== void 0 && (D.pagination = v.pagination ? n.PageResponse.toJSON(v.pagination) : void 0), D;
    },
    fromPartial(v) {
      var W;
      const D = N();
      return D.balances = ((W = v.balances) == null ? void 0 : W.map((H) => r.Coin.fromPartial(H))) || [], v.pagination !== void 0 && v.pagination !== null && (D.pagination = n.PageResponse.fromPartial(v.pagination)), D;
    }
  };
  function h() {
    return {
      address: "",
      denom: ""
    };
  }
  e.QuerySpendableBalanceByDenomRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalanceByDenomRequest",
    encode(v, D = i.BinaryWriter.create()) {
      return v.address !== "" && D.uint32(10).string(v.address), v.denom !== "" && D.uint32(18).string(v.denom), D;
    },
    decode(v, D) {
      const W = v instanceof i.BinaryReader ? v : new i.BinaryReader(v);
      let H = D === void 0 ? W.len : W.pos + D;
      const a = h();
      for (; W.pos < H; ) {
        const g = W.uint32();
        switch (g >>> 3) {
          case 1:
            a.address = W.string();
            break;
          case 2:
            a.denom = W.string();
            break;
          default:
            W.skipType(g & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(v) {
      const D = h();
      return (0, f.isSet)(v.address) && (D.address = String(v.address)), (0, f.isSet)(v.denom) && (D.denom = String(v.denom)), D;
    },
    toJSON(v) {
      const D = {};
      return v.address !== void 0 && (D.address = v.address), v.denom !== void 0 && (D.denom = v.denom), D;
    },
    fromPartial(v) {
      const D = h();
      return D.address = v.address ?? "", D.denom = v.denom ?? "", D;
    }
  };
  function P() {
    return {
      balance: void 0
    };
  }
  e.QuerySpendableBalanceByDenomResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalanceByDenomResponse",
    encode(v, D = i.BinaryWriter.create()) {
      return v.balance !== void 0 && r.Coin.encode(v.balance, D.uint32(10).fork()).ldelim(), D;
    },
    decode(v, D) {
      const W = v instanceof i.BinaryReader ? v : new i.BinaryReader(v);
      let H = D === void 0 ? W.len : W.pos + D;
      const a = P();
      for (; W.pos < H; ) {
        const g = W.uint32();
        switch (g >>> 3) {
          case 1:
            a.balance = r.Coin.decode(W, W.uint32());
            break;
          default:
            W.skipType(g & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(v) {
      const D = P();
      return (0, f.isSet)(v.balance) && (D.balance = r.Coin.fromJSON(v.balance)), D;
    },
    toJSON(v) {
      const D = {};
      return v.balance !== void 0 && (D.balance = v.balance ? r.Coin.toJSON(v.balance) : void 0), D;
    },
    fromPartial(v) {
      const D = P();
      return v.balance !== void 0 && v.balance !== null && (D.balance = r.Coin.fromPartial(v.balance)), D;
    }
  };
  function b() {
    return {
      pagination: void 0
    };
  }
  e.QueryTotalSupplyRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QueryTotalSupplyRequest",
    encode(v, D = i.BinaryWriter.create()) {
      return v.pagination !== void 0 && n.PageRequest.encode(v.pagination, D.uint32(10).fork()).ldelim(), D;
    },
    decode(v, D) {
      const W = v instanceof i.BinaryReader ? v : new i.BinaryReader(v);
      let H = D === void 0 ? W.len : W.pos + D;
      const a = b();
      for (; W.pos < H; ) {
        const g = W.uint32();
        switch (g >>> 3) {
          case 1:
            a.pagination = n.PageRequest.decode(W, W.uint32());
            break;
          default:
            W.skipType(g & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(v) {
      const D = b();
      return (0, f.isSet)(v.pagination) && (D.pagination = n.PageRequest.fromJSON(v.pagination)), D;
    },
    toJSON(v) {
      const D = {};
      return v.pagination !== void 0 && (D.pagination = v.pagination ? n.PageRequest.toJSON(v.pagination) : void 0), D;
    },
    fromPartial(v) {
      const D = b();
      return v.pagination !== void 0 && v.pagination !== null && (D.pagination = n.PageRequest.fromPartial(v.pagination)), D;
    }
  };
  function c() {
    return {
      supply: [],
      pagination: void 0
    };
  }
  e.QueryTotalSupplyResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QueryTotalSupplyResponse",
    encode(v, D = i.BinaryWriter.create()) {
      for (const W of v.supply)
        r.Coin.encode(W, D.uint32(10).fork()).ldelim();
      return v.pagination !== void 0 && n.PageResponse.encode(v.pagination, D.uint32(18).fork()).ldelim(), D;
    },
    decode(v, D) {
      const W = v instanceof i.BinaryReader ? v : new i.BinaryReader(v);
      let H = D === void 0 ? W.len : W.pos + D;
      const a = c();
      for (; W.pos < H; ) {
        const g = W.uint32();
        switch (g >>> 3) {
          case 1:
            a.supply.push(r.Coin.decode(W, W.uint32()));
            break;
          case 2:
            a.pagination = n.PageResponse.decode(W, W.uint32());
            break;
          default:
            W.skipType(g & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(v) {
      const D = c();
      return Array.isArray(v == null ? void 0 : v.supply) && (D.supply = v.supply.map((W) => r.Coin.fromJSON(W))), (0, f.isSet)(v.pagination) && (D.pagination = n.PageResponse.fromJSON(v.pagination)), D;
    },
    toJSON(v) {
      const D = {};
      return v.supply ? D.supply = v.supply.map((W) => W ? r.Coin.toJSON(W) : void 0) : D.supply = [], v.pagination !== void 0 && (D.pagination = v.pagination ? n.PageResponse.toJSON(v.pagination) : void 0), D;
    },
    fromPartial(v) {
      var W;
      const D = c();
      return D.supply = ((W = v.supply) == null ? void 0 : W.map((H) => r.Coin.fromPartial(H))) || [], v.pagination !== void 0 && v.pagination !== null && (D.pagination = n.PageResponse.fromPartial(v.pagination)), D;
    }
  };
  function l() {
    return {
      denom: ""
    };
  }
  e.QuerySupplyOfRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySupplyOfRequest",
    encode(v, D = i.BinaryWriter.create()) {
      return v.denom !== "" && D.uint32(10).string(v.denom), D;
    },
    decode(v, D) {
      const W = v instanceof i.BinaryReader ? v : new i.BinaryReader(v);
      let H = D === void 0 ? W.len : W.pos + D;
      const a = l();
      for (; W.pos < H; ) {
        const g = W.uint32();
        switch (g >>> 3) {
          case 1:
            a.denom = W.string();
            break;
          default:
            W.skipType(g & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(v) {
      const D = l();
      return (0, f.isSet)(v.denom) && (D.denom = String(v.denom)), D;
    },
    toJSON(v) {
      const D = {};
      return v.denom !== void 0 && (D.denom = v.denom), D;
    },
    fromPartial(v) {
      const D = l();
      return D.denom = v.denom ?? "", D;
    }
  };
  function y() {
    return {
      amount: r.Coin.fromPartial({})
    };
  }
  e.QuerySupplyOfResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySupplyOfResponse",
    encode(v, D = i.BinaryWriter.create()) {
      return v.amount !== void 0 && r.Coin.encode(v.amount, D.uint32(10).fork()).ldelim(), D;
    },
    decode(v, D) {
      const W = v instanceof i.BinaryReader ? v : new i.BinaryReader(v);
      let H = D === void 0 ? W.len : W.pos + D;
      const a = y();
      for (; W.pos < H; ) {
        const g = W.uint32();
        switch (g >>> 3) {
          case 1:
            a.amount = r.Coin.decode(W, W.uint32());
            break;
          default:
            W.skipType(g & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(v) {
      const D = y();
      return (0, f.isSet)(v.amount) && (D.amount = r.Coin.fromJSON(v.amount)), D;
    },
    toJSON(v) {
      const D = {};
      return v.amount !== void 0 && (D.amount = v.amount ? r.Coin.toJSON(v.amount) : void 0), D;
    },
    fromPartial(v) {
      const D = y();
      return v.amount !== void 0 && v.amount !== null && (D.amount = r.Coin.fromPartial(v.amount)), D;
    }
  };
  function E() {
    return {};
  }
  e.QueryParamsRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QueryParamsRequest",
    encode(v, D = i.BinaryWriter.create()) {
      return D;
    },
    decode(v, D) {
      const W = v instanceof i.BinaryReader ? v : new i.BinaryReader(v);
      let H = D === void 0 ? W.len : W.pos + D;
      const a = E();
      for (; W.pos < H; ) {
        const g = W.uint32();
        switch (g >>> 3) {
          default:
            W.skipType(g & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(v) {
      return E();
    },
    toJSON(v) {
      return {};
    },
    fromPartial(v) {
      return E();
    }
  };
  function J() {
    return {
      params: t.Params.fromPartial({})
    };
  }
  e.QueryParamsResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QueryParamsResponse",
    encode(v, D = i.BinaryWriter.create()) {
      return v.params !== void 0 && t.Params.encode(v.params, D.uint32(10).fork()).ldelim(), D;
    },
    decode(v, D) {
      const W = v instanceof i.BinaryReader ? v : new i.BinaryReader(v);
      let H = D === void 0 ? W.len : W.pos + D;
      const a = J();
      for (; W.pos < H; ) {
        const g = W.uint32();
        switch (g >>> 3) {
          case 1:
            a.params = t.Params.decode(W, W.uint32());
            break;
          default:
            W.skipType(g & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(v) {
      const D = J();
      return (0, f.isSet)(v.params) && (D.params = t.Params.fromJSON(v.params)), D;
    },
    toJSON(v) {
      const D = {};
      return v.params !== void 0 && (D.params = v.params ? t.Params.toJSON(v.params) : void 0), D;
    },
    fromPartial(v) {
      const D = J();
      return v.params !== void 0 && v.params !== null && (D.params = t.Params.fromPartial(v.params)), D;
    }
  };
  function _() {
    return {
      pagination: void 0
    };
  }
  e.QueryDenomsMetadataRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QueryDenomsMetadataRequest",
    encode(v, D = i.BinaryWriter.create()) {
      return v.pagination !== void 0 && n.PageRequest.encode(v.pagination, D.uint32(10).fork()).ldelim(), D;
    },
    decode(v, D) {
      const W = v instanceof i.BinaryReader ? v : new i.BinaryReader(v);
      let H = D === void 0 ? W.len : W.pos + D;
      const a = _();
      for (; W.pos < H; ) {
        const g = W.uint32();
        switch (g >>> 3) {
          case 1:
            a.pagination = n.PageRequest.decode(W, W.uint32());
            break;
          default:
            W.skipType(g & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(v) {
      const D = _();
      return (0, f.isSet)(v.pagination) && (D.pagination = n.PageRequest.fromJSON(v.pagination)), D;
    },
    toJSON(v) {
      const D = {};
      return v.pagination !== void 0 && (D.pagination = v.pagination ? n.PageRequest.toJSON(v.pagination) : void 0), D;
    },
    fromPartial(v) {
      const D = _();
      return v.pagination !== void 0 && v.pagination !== null && (D.pagination = n.PageRequest.fromPartial(v.pagination)), D;
    }
  };
  function V() {
    return {
      metadatas: [],
      pagination: void 0
    };
  }
  e.QueryDenomsMetadataResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QueryDenomsMetadataResponse",
    encode(v, D = i.BinaryWriter.create()) {
      for (const W of v.metadatas)
        t.Metadata.encode(W, D.uint32(10).fork()).ldelim();
      return v.pagination !== void 0 && n.PageResponse.encode(v.pagination, D.uint32(18).fork()).ldelim(), D;
    },
    decode(v, D) {
      const W = v instanceof i.BinaryReader ? v : new i.BinaryReader(v);
      let H = D === void 0 ? W.len : W.pos + D;
      const a = V();
      for (; W.pos < H; ) {
        const g = W.uint32();
        switch (g >>> 3) {
          case 1:
            a.metadatas.push(t.Metadata.decode(W, W.uint32()));
            break;
          case 2:
            a.pagination = n.PageResponse.decode(W, W.uint32());
            break;
          default:
            W.skipType(g & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(v) {
      const D = V();
      return Array.isArray(v == null ? void 0 : v.metadatas) && (D.metadatas = v.metadatas.map((W) => t.Metadata.fromJSON(W))), (0, f.isSet)(v.pagination) && (D.pagination = n.PageResponse.fromJSON(v.pagination)), D;
    },
    toJSON(v) {
      const D = {};
      return v.metadatas ? D.metadatas = v.metadatas.map((W) => W ? t.Metadata.toJSON(W) : void 0) : D.metadatas = [], v.pagination !== void 0 && (D.pagination = v.pagination ? n.PageResponse.toJSON(v.pagination) : void 0), D;
    },
    fromPartial(v) {
      var W;
      const D = V();
      return D.metadatas = ((W = v.metadatas) == null ? void 0 : W.map((H) => t.Metadata.fromPartial(H))) || [], v.pagination !== void 0 && v.pagination !== null && (D.pagination = n.PageResponse.fromPartial(v.pagination)), D;
    }
  };
  function o() {
    return {
      denom: ""
    };
  }
  e.QueryDenomMetadataRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataRequest",
    encode(v, D = i.BinaryWriter.create()) {
      return v.denom !== "" && D.uint32(10).string(v.denom), D;
    },
    decode(v, D) {
      const W = v instanceof i.BinaryReader ? v : new i.BinaryReader(v);
      let H = D === void 0 ? W.len : W.pos + D;
      const a = o();
      for (; W.pos < H; ) {
        const g = W.uint32();
        switch (g >>> 3) {
          case 1:
            a.denom = W.string();
            break;
          default:
            W.skipType(g & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(v) {
      const D = o();
      return (0, f.isSet)(v.denom) && (D.denom = String(v.denom)), D;
    },
    toJSON(v) {
      const D = {};
      return v.denom !== void 0 && (D.denom = v.denom), D;
    },
    fromPartial(v) {
      const D = o();
      return D.denom = v.denom ?? "", D;
    }
  };
  function p() {
    return {
      metadata: t.Metadata.fromPartial({})
    };
  }
  e.QueryDenomMetadataResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataResponse",
    encode(v, D = i.BinaryWriter.create()) {
      return v.metadata !== void 0 && t.Metadata.encode(v.metadata, D.uint32(10).fork()).ldelim(), D;
    },
    decode(v, D) {
      const W = v instanceof i.BinaryReader ? v : new i.BinaryReader(v);
      let H = D === void 0 ? W.len : W.pos + D;
      const a = p();
      for (; W.pos < H; ) {
        const g = W.uint32();
        switch (g >>> 3) {
          case 1:
            a.metadata = t.Metadata.decode(W, W.uint32());
            break;
          default:
            W.skipType(g & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(v) {
      const D = p();
      return (0, f.isSet)(v.metadata) && (D.metadata = t.Metadata.fromJSON(v.metadata)), D;
    },
    toJSON(v) {
      const D = {};
      return v.metadata !== void 0 && (D.metadata = v.metadata ? t.Metadata.toJSON(v.metadata) : void 0), D;
    },
    fromPartial(v) {
      const D = p();
      return v.metadata !== void 0 && v.metadata !== null && (D.metadata = t.Metadata.fromPartial(v.metadata)), D;
    }
  };
  function I() {
    return {
      denom: "",
      pagination: void 0
    };
  }
  e.QueryDenomOwnersRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersRequest",
    encode(v, D = i.BinaryWriter.create()) {
      return v.denom !== "" && D.uint32(10).string(v.denom), v.pagination !== void 0 && n.PageRequest.encode(v.pagination, D.uint32(18).fork()).ldelim(), D;
    },
    decode(v, D) {
      const W = v instanceof i.BinaryReader ? v : new i.BinaryReader(v);
      let H = D === void 0 ? W.len : W.pos + D;
      const a = I();
      for (; W.pos < H; ) {
        const g = W.uint32();
        switch (g >>> 3) {
          case 1:
            a.denom = W.string();
            break;
          case 2:
            a.pagination = n.PageRequest.decode(W, W.uint32());
            break;
          default:
            W.skipType(g & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(v) {
      const D = I();
      return (0, f.isSet)(v.denom) && (D.denom = String(v.denom)), (0, f.isSet)(v.pagination) && (D.pagination = n.PageRequest.fromJSON(v.pagination)), D;
    },
    toJSON(v) {
      const D = {};
      return v.denom !== void 0 && (D.denom = v.denom), v.pagination !== void 0 && (D.pagination = v.pagination ? n.PageRequest.toJSON(v.pagination) : void 0), D;
    },
    fromPartial(v) {
      const D = I();
      return D.denom = v.denom ?? "", v.pagination !== void 0 && v.pagination !== null && (D.pagination = n.PageRequest.fromPartial(v.pagination)), D;
    }
  };
  function q() {
    return {
      address: "",
      balance: r.Coin.fromPartial({})
    };
  }
  e.DenomOwner = {
    typeUrl: "/cosmos.bank.v1beta1.DenomOwner",
    encode(v, D = i.BinaryWriter.create()) {
      return v.address !== "" && D.uint32(10).string(v.address), v.balance !== void 0 && r.Coin.encode(v.balance, D.uint32(18).fork()).ldelim(), D;
    },
    decode(v, D) {
      const W = v instanceof i.BinaryReader ? v : new i.BinaryReader(v);
      let H = D === void 0 ? W.len : W.pos + D;
      const a = q();
      for (; W.pos < H; ) {
        const g = W.uint32();
        switch (g >>> 3) {
          case 1:
            a.address = W.string();
            break;
          case 2:
            a.balance = r.Coin.decode(W, W.uint32());
            break;
          default:
            W.skipType(g & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(v) {
      const D = q();
      return (0, f.isSet)(v.address) && (D.address = String(v.address)), (0, f.isSet)(v.balance) && (D.balance = r.Coin.fromJSON(v.balance)), D;
    },
    toJSON(v) {
      const D = {};
      return v.address !== void 0 && (D.address = v.address), v.balance !== void 0 && (D.balance = v.balance ? r.Coin.toJSON(v.balance) : void 0), D;
    },
    fromPartial(v) {
      const D = q();
      return D.address = v.address ?? "", v.balance !== void 0 && v.balance !== null && (D.balance = r.Coin.fromPartial(v.balance)), D;
    }
  };
  function s() {
    return {
      denomOwners: [],
      pagination: void 0
    };
  }
  e.QueryDenomOwnersResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersResponse",
    encode(v, D = i.BinaryWriter.create()) {
      for (const W of v.denomOwners)
        e.DenomOwner.encode(W, D.uint32(10).fork()).ldelim();
      return v.pagination !== void 0 && n.PageResponse.encode(v.pagination, D.uint32(18).fork()).ldelim(), D;
    },
    decode(v, D) {
      const W = v instanceof i.BinaryReader ? v : new i.BinaryReader(v);
      let H = D === void 0 ? W.len : W.pos + D;
      const a = s();
      for (; W.pos < H; ) {
        const g = W.uint32();
        switch (g >>> 3) {
          case 1:
            a.denomOwners.push(e.DenomOwner.decode(W, W.uint32()));
            break;
          case 2:
            a.pagination = n.PageResponse.decode(W, W.uint32());
            break;
          default:
            W.skipType(g & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(v) {
      const D = s();
      return Array.isArray(v == null ? void 0 : v.denomOwners) && (D.denomOwners = v.denomOwners.map((W) => e.DenomOwner.fromJSON(W))), (0, f.isSet)(v.pagination) && (D.pagination = n.PageResponse.fromJSON(v.pagination)), D;
    },
    toJSON(v) {
      const D = {};
      return v.denomOwners ? D.denomOwners = v.denomOwners.map((W) => W ? e.DenomOwner.toJSON(W) : void 0) : D.denomOwners = [], v.pagination !== void 0 && (D.pagination = v.pagination ? n.PageResponse.toJSON(v.pagination) : void 0), D;
    },
    fromPartial(v) {
      var W;
      const D = s();
      return D.denomOwners = ((W = v.denomOwners) == null ? void 0 : W.map((H) => e.DenomOwner.fromPartial(H))) || [], v.pagination !== void 0 && v.pagination !== null && (D.pagination = n.PageResponse.fromPartial(v.pagination)), D;
    }
  };
  function u() {
    return {
      denoms: [],
      pagination: void 0
    };
  }
  e.QuerySendEnabledRequest = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySendEnabledRequest",
    encode(v, D = i.BinaryWriter.create()) {
      for (const W of v.denoms)
        D.uint32(10).string(W);
      return v.pagination !== void 0 && n.PageRequest.encode(v.pagination, D.uint32(794).fork()).ldelim(), D;
    },
    decode(v, D) {
      const W = v instanceof i.BinaryReader ? v : new i.BinaryReader(v);
      let H = D === void 0 ? W.len : W.pos + D;
      const a = u();
      for (; W.pos < H; ) {
        const g = W.uint32();
        switch (g >>> 3) {
          case 1:
            a.denoms.push(W.string());
            break;
          case 99:
            a.pagination = n.PageRequest.decode(W, W.uint32());
            break;
          default:
            W.skipType(g & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(v) {
      const D = u();
      return Array.isArray(v == null ? void 0 : v.denoms) && (D.denoms = v.denoms.map((W) => String(W))), (0, f.isSet)(v.pagination) && (D.pagination = n.PageRequest.fromJSON(v.pagination)), D;
    },
    toJSON(v) {
      const D = {};
      return v.denoms ? D.denoms = v.denoms.map((W) => W) : D.denoms = [], v.pagination !== void 0 && (D.pagination = v.pagination ? n.PageRequest.toJSON(v.pagination) : void 0), D;
    },
    fromPartial(v) {
      var W;
      const D = u();
      return D.denoms = ((W = v.denoms) == null ? void 0 : W.map((H) => H)) || [], v.pagination !== void 0 && v.pagination !== null && (D.pagination = n.PageRequest.fromPartial(v.pagination)), D;
    }
  };
  function A() {
    return {
      sendEnabled: [],
      pagination: void 0
    };
  }
  e.QuerySendEnabledResponse = {
    typeUrl: "/cosmos.bank.v1beta1.QuerySendEnabledResponse",
    encode(v, D = i.BinaryWriter.create()) {
      for (const W of v.sendEnabled)
        t.SendEnabled.encode(W, D.uint32(10).fork()).ldelim();
      return v.pagination !== void 0 && n.PageResponse.encode(v.pagination, D.uint32(794).fork()).ldelim(), D;
    },
    decode(v, D) {
      const W = v instanceof i.BinaryReader ? v : new i.BinaryReader(v);
      let H = D === void 0 ? W.len : W.pos + D;
      const a = A();
      for (; W.pos < H; ) {
        const g = W.uint32();
        switch (g >>> 3) {
          case 1:
            a.sendEnabled.push(t.SendEnabled.decode(W, W.uint32()));
            break;
          case 99:
            a.pagination = n.PageResponse.decode(W, W.uint32());
            break;
          default:
            W.skipType(g & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(v) {
      const D = A();
      return Array.isArray(v == null ? void 0 : v.sendEnabled) && (D.sendEnabled = v.sendEnabled.map((W) => t.SendEnabled.fromJSON(W))), (0, f.isSet)(v.pagination) && (D.pagination = n.PageResponse.fromJSON(v.pagination)), D;
    },
    toJSON(v) {
      const D = {};
      return v.sendEnabled ? D.sendEnabled = v.sendEnabled.map((W) => W ? t.SendEnabled.toJSON(W) : void 0) : D.sendEnabled = [], v.pagination !== void 0 && (D.pagination = v.pagination ? n.PageResponse.toJSON(v.pagination) : void 0), D;
    },
    fromPartial(v) {
      var W;
      const D = A();
      return D.sendEnabled = ((W = v.sendEnabled) == null ? void 0 : W.map((H) => t.SendEnabled.fromPartial(H))) || [], v.pagination !== void 0 && v.pagination !== null && (D.pagination = n.PageResponse.fromPartial(v.pagination)), D;
    }
  };
  class R {
    constructor(D) {
      this.rpc = D, this.Balance = this.Balance.bind(this), this.AllBalances = this.AllBalances.bind(this), this.SpendableBalances = this.SpendableBalances.bind(this), this.SpendableBalanceByDenom = this.SpendableBalanceByDenom.bind(this), this.TotalSupply = this.TotalSupply.bind(this), this.SupplyOf = this.SupplyOf.bind(this), this.Params = this.Params.bind(this), this.DenomMetadata = this.DenomMetadata.bind(this), this.DenomsMetadata = this.DenomsMetadata.bind(this), this.DenomOwners = this.DenomOwners.bind(this), this.SendEnabled = this.SendEnabled.bind(this);
    }
    Balance(D) {
      const W = e.QueryBalanceRequest.encode(D).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "Balance", W).then((a) => e.QueryBalanceResponse.decode(new i.BinaryReader(a)));
    }
    AllBalances(D) {
      const W = e.QueryAllBalancesRequest.encode(D).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "AllBalances", W).then((a) => e.QueryAllBalancesResponse.decode(new i.BinaryReader(a)));
    }
    SpendableBalances(D) {
      const W = e.QuerySpendableBalancesRequest.encode(D).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "SpendableBalances", W).then((a) => e.QuerySpendableBalancesResponse.decode(new i.BinaryReader(a)));
    }
    SpendableBalanceByDenom(D) {
      const W = e.QuerySpendableBalanceByDenomRequest.encode(D).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "SpendableBalanceByDenom", W).then((a) => e.QuerySpendableBalanceByDenomResponse.decode(new i.BinaryReader(a)));
    }
    TotalSupply(D = {
      pagination: n.PageRequest.fromPartial({})
    }) {
      const W = e.QueryTotalSupplyRequest.encode(D).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "TotalSupply", W).then((a) => e.QueryTotalSupplyResponse.decode(new i.BinaryReader(a)));
    }
    SupplyOf(D) {
      const W = e.QuerySupplyOfRequest.encode(D).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "SupplyOf", W).then((a) => e.QuerySupplyOfResponse.decode(new i.BinaryReader(a)));
    }
    Params(D = {}) {
      const W = e.QueryParamsRequest.encode(D).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "Params", W).then((a) => e.QueryParamsResponse.decode(new i.BinaryReader(a)));
    }
    DenomMetadata(D) {
      const W = e.QueryDenomMetadataRequest.encode(D).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "DenomMetadata", W).then((a) => e.QueryDenomMetadataResponse.decode(new i.BinaryReader(a)));
    }
    DenomsMetadata(D = {
      pagination: n.PageRequest.fromPartial({})
    }) {
      const W = e.QueryDenomsMetadataRequest.encode(D).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "DenomsMetadata", W).then((a) => e.QueryDenomsMetadataResponse.decode(new i.BinaryReader(a)));
    }
    DenomOwners(D) {
      const W = e.QueryDenomOwnersRequest.encode(D).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "DenomOwners", W).then((a) => e.QueryDenomOwnersResponse.decode(new i.BinaryReader(a)));
    }
    SendEnabled(D) {
      const W = e.QuerySendEnabledRequest.encode(D).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Query", "SendEnabled", W).then((a) => e.QuerySendEnabledResponse.decode(new i.BinaryReader(a)));
    }
  }
  e.QueryClientImpl = R;
})(Zc);
Object.defineProperty(mo, "__esModule", { value: !0 });
mo.setupBankExtension = void 0;
const es = an, ns = Zc, Au = Ge;
function nm(e) {
  const n = (0, Au.createProtobufRpcClient)(e), r = new ns.QueryClientImpl(n);
  return {
    bank: {
      balance: async (t, i) => {
        const { balance: f } = await r.Balance({ address: t, denom: i });
        return (0, es.assert)(f), f;
      },
      allBalances: async (t) => {
        const { balances: i } = await r.AllBalances(ns.QueryAllBalancesRequest.fromPartial({ address: t }));
        return i;
      },
      totalSupply: async (t) => await r.TotalSupply({
        pagination: (0, Au.createPagination)(t)
      }),
      supplyOf: async (t) => {
        const { amount: i } = await r.SupplyOf({ denom: t });
        return (0, es.assert)(i), i;
      },
      denomMetadata: async (t) => {
        const { metadata: i } = await r.DenomMetadata({ denom: t });
        return (0, es.assert)(i), i;
      },
      denomsMetadata: async () => {
        const { metadatas: t } = await r.DenomsMetadata(ns.QueryDenomsMetadataRequest.fromPartial({
          pagination: void 0
          // Not implemented
        }));
        return t;
      }
    }
  };
}
mo.setupBankExtension = nm;
var nr = {};
Object.defineProperty(nr, "__esModule", { value: !0 });
nr.createCrysisAminoConverters = nr.isAminoMsgVerifyInvariant = void 0;
function tm(e) {
  return e.type === "cosmos-sdk/MsgVerifyInvariant";
}
nr.isAminoMsgVerifyInvariant = tm;
function rm() {
  throw new Error("Not implemented");
}
nr.createCrysisAminoConverters = rm;
var yn = {};
Object.defineProperty(yn, "__esModule", { value: !0 });
yn.createDistributionAminoConverters = yn.isAminoMsgFundCommunityPool = yn.isAminoMsgWithdrawValidatorCommission = yn.isAminoMsgWithdrawDelegatorReward = yn.isAminoMsgSetWithdrawAddress = void 0;
function im(e) {
  return e.type === "cosmos-sdk/MsgModifyWithdrawAddress";
}
yn.isAminoMsgSetWithdrawAddress = im;
function om(e) {
  return e.type === "cosmos-sdk/MsgWithdrawDelegationReward";
}
yn.isAminoMsgWithdrawDelegatorReward = om;
function am(e) {
  return e.type === "cosmos-sdk/MsgWithdrawValidatorCommission";
}
yn.isAminoMsgWithdrawValidatorCommission = am;
function sm(e) {
  return e.type === "cosmos-sdk/MsgFundCommunityPool";
}
yn.isAminoMsgFundCommunityPool = sm;
function dm() {
  return {
    "/cosmos.distribution.v1beta1.MsgFundCommunityPool": {
      aminoType: "cosmos-sdk/MsgFundCommunityPool",
      toAmino: ({ amount: e, depositor: n }) => ({
        amount: [...e],
        depositor: n
      }),
      fromAmino: ({ amount: e, depositor: n }) => ({
        amount: [...e],
        depositor: n
      })
    },
    "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress": {
      aminoType: "cosmos-sdk/MsgModifyWithdrawAddress",
      toAmino: ({ delegatorAddress: e, withdrawAddress: n }) => ({
        delegator_address: e,
        withdraw_address: n
      }),
      fromAmino: ({ delegator_address: e, withdraw_address: n }) => ({
        delegatorAddress: e,
        withdrawAddress: n
      })
    },
    "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward": {
      aminoType: "cosmos-sdk/MsgWithdrawDelegationReward",
      toAmino: ({ delegatorAddress: e, validatorAddress: n }) => ({
        delegator_address: e,
        validator_address: n
      }),
      fromAmino: ({ delegator_address: e, validator_address: n }) => ({
        delegatorAddress: e,
        validatorAddress: n
      })
    },
    "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission": {
      aminoType: "cosmos-sdk/MsgWithdrawValidatorCommission",
      toAmino: ({ validatorAddress: e }) => ({
        validator_address: e
      }),
      fromAmino: ({ validator_address: e }) => ({
        validatorAddress: e
      })
    }
  };
}
yn.createDistributionAminoConverters = dm;
var tr = {}, md = {}, gd = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CommunityPoolSpendProposalWithDeposit = e.DelegationDelegatorReward = e.DelegatorStartingInfo = e.CommunityPoolSpendProposal = e.FeePool = e.ValidatorSlashEvents = e.ValidatorSlashEvent = e.ValidatorOutstandingRewards = e.ValidatorAccumulatedCommission = e.ValidatorCurrentRewards = e.ValidatorHistoricalRewards = e.Params = e.protobufPackage = void 0;
  const n = Le, r = re, t = ie;
  e.protobufPackage = "cosmos.distribution.v1beta1";
  function i() {
    return {
      communityTax: "",
      baseProposerReward: "",
      bonusProposerReward: "",
      withdrawAddrEnabled: !1
    };
  }
  e.Params = {
    typeUrl: "/cosmos.distribution.v1beta1.Params",
    encode(l, y = r.BinaryWriter.create()) {
      return l.communityTax !== "" && y.uint32(10).string(l.communityTax), l.baseProposerReward !== "" && y.uint32(18).string(l.baseProposerReward), l.bonusProposerReward !== "" && y.uint32(26).string(l.bonusProposerReward), l.withdrawAddrEnabled === !0 && y.uint32(32).bool(l.withdrawAddrEnabled), y;
    },
    decode(l, y) {
      const E = l instanceof r.BinaryReader ? l : new r.BinaryReader(l);
      let J = y === void 0 ? E.len : E.pos + y;
      const _ = i();
      for (; E.pos < J; ) {
        const V = E.uint32();
        switch (V >>> 3) {
          case 1:
            _.communityTax = E.string();
            break;
          case 2:
            _.baseProposerReward = E.string();
            break;
          case 3:
            _.bonusProposerReward = E.string();
            break;
          case 4:
            _.withdrawAddrEnabled = E.bool();
            break;
          default:
            E.skipType(V & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(l) {
      const y = i();
      return (0, t.isSet)(l.communityTax) && (y.communityTax = String(l.communityTax)), (0, t.isSet)(l.baseProposerReward) && (y.baseProposerReward = String(l.baseProposerReward)), (0, t.isSet)(l.bonusProposerReward) && (y.bonusProposerReward = String(l.bonusProposerReward)), (0, t.isSet)(l.withdrawAddrEnabled) && (y.withdrawAddrEnabled = !!l.withdrawAddrEnabled), y;
    },
    toJSON(l) {
      const y = {};
      return l.communityTax !== void 0 && (y.communityTax = l.communityTax), l.baseProposerReward !== void 0 && (y.baseProposerReward = l.baseProposerReward), l.bonusProposerReward !== void 0 && (y.bonusProposerReward = l.bonusProposerReward), l.withdrawAddrEnabled !== void 0 && (y.withdrawAddrEnabled = l.withdrawAddrEnabled), y;
    },
    fromPartial(l) {
      const y = i();
      return y.communityTax = l.communityTax ?? "", y.baseProposerReward = l.baseProposerReward ?? "", y.bonusProposerReward = l.bonusProposerReward ?? "", y.withdrawAddrEnabled = l.withdrawAddrEnabled ?? !1, y;
    }
  };
  function f() {
    return {
      cumulativeRewardRatio: [],
      referenceCount: 0
    };
  }
  e.ValidatorHistoricalRewards = {
    typeUrl: "/cosmos.distribution.v1beta1.ValidatorHistoricalRewards",
    encode(l, y = r.BinaryWriter.create()) {
      for (const E of l.cumulativeRewardRatio)
        n.DecCoin.encode(E, y.uint32(10).fork()).ldelim();
      return l.referenceCount !== 0 && y.uint32(16).uint32(l.referenceCount), y;
    },
    decode(l, y) {
      const E = l instanceof r.BinaryReader ? l : new r.BinaryReader(l);
      let J = y === void 0 ? E.len : E.pos + y;
      const _ = f();
      for (; E.pos < J; ) {
        const V = E.uint32();
        switch (V >>> 3) {
          case 1:
            _.cumulativeRewardRatio.push(n.DecCoin.decode(E, E.uint32()));
            break;
          case 2:
            _.referenceCount = E.uint32();
            break;
          default:
            E.skipType(V & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(l) {
      const y = f();
      return Array.isArray(l == null ? void 0 : l.cumulativeRewardRatio) && (y.cumulativeRewardRatio = l.cumulativeRewardRatio.map((E) => n.DecCoin.fromJSON(E))), (0, t.isSet)(l.referenceCount) && (y.referenceCount = Number(l.referenceCount)), y;
    },
    toJSON(l) {
      const y = {};
      return l.cumulativeRewardRatio ? y.cumulativeRewardRatio = l.cumulativeRewardRatio.map((E) => E ? n.DecCoin.toJSON(E) : void 0) : y.cumulativeRewardRatio = [], l.referenceCount !== void 0 && (y.referenceCount = Math.round(l.referenceCount)), y;
    },
    fromPartial(l) {
      var E;
      const y = f();
      return y.cumulativeRewardRatio = ((E = l.cumulativeRewardRatio) == null ? void 0 : E.map((J) => n.DecCoin.fromPartial(J))) || [], y.referenceCount = l.referenceCount ?? 0, y;
    }
  };
  function k() {
    return {
      rewards: [],
      period: BigInt(0)
    };
  }
  e.ValidatorCurrentRewards = {
    typeUrl: "/cosmos.distribution.v1beta1.ValidatorCurrentRewards",
    encode(l, y = r.BinaryWriter.create()) {
      for (const E of l.rewards)
        n.DecCoin.encode(E, y.uint32(10).fork()).ldelim();
      return l.period !== BigInt(0) && y.uint32(16).uint64(l.period), y;
    },
    decode(l, y) {
      const E = l instanceof r.BinaryReader ? l : new r.BinaryReader(l);
      let J = y === void 0 ? E.len : E.pos + y;
      const _ = k();
      for (; E.pos < J; ) {
        const V = E.uint32();
        switch (V >>> 3) {
          case 1:
            _.rewards.push(n.DecCoin.decode(E, E.uint32()));
            break;
          case 2:
            _.period = E.uint64();
            break;
          default:
            E.skipType(V & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(l) {
      const y = k();
      return Array.isArray(l == null ? void 0 : l.rewards) && (y.rewards = l.rewards.map((E) => n.DecCoin.fromJSON(E))), (0, t.isSet)(l.period) && (y.period = BigInt(l.period.toString())), y;
    },
    toJSON(l) {
      const y = {};
      return l.rewards ? y.rewards = l.rewards.map((E) => E ? n.DecCoin.toJSON(E) : void 0) : y.rewards = [], l.period !== void 0 && (y.period = (l.period || BigInt(0)).toString()), y;
    },
    fromPartial(l) {
      var E;
      const y = k();
      return y.rewards = ((E = l.rewards) == null ? void 0 : E.map((J) => n.DecCoin.fromPartial(J))) || [], l.period !== void 0 && l.period !== null && (y.period = BigInt(l.period.toString())), y;
    }
  };
  function C() {
    return {
      commission: []
    };
  }
  e.ValidatorAccumulatedCommission = {
    typeUrl: "/cosmos.distribution.v1beta1.ValidatorAccumulatedCommission",
    encode(l, y = r.BinaryWriter.create()) {
      for (const E of l.commission)
        n.DecCoin.encode(E, y.uint32(10).fork()).ldelim();
      return y;
    },
    decode(l, y) {
      const E = l instanceof r.BinaryReader ? l : new r.BinaryReader(l);
      let J = y === void 0 ? E.len : E.pos + y;
      const _ = C();
      for (; E.pos < J; ) {
        const V = E.uint32();
        switch (V >>> 3) {
          case 1:
            _.commission.push(n.DecCoin.decode(E, E.uint32()));
            break;
          default:
            E.skipType(V & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(l) {
      const y = C();
      return Array.isArray(l == null ? void 0 : l.commission) && (y.commission = l.commission.map((E) => n.DecCoin.fromJSON(E))), y;
    },
    toJSON(l) {
      const y = {};
      return l.commission ? y.commission = l.commission.map((E) => E ? n.DecCoin.toJSON(E) : void 0) : y.commission = [], y;
    },
    fromPartial(l) {
      var E;
      const y = C();
      return y.commission = ((E = l.commission) == null ? void 0 : E.map((J) => n.DecCoin.fromPartial(J))) || [], y;
    }
  };
  function T() {
    return {
      rewards: []
    };
  }
  e.ValidatorOutstandingRewards = {
    typeUrl: "/cosmos.distribution.v1beta1.ValidatorOutstandingRewards",
    encode(l, y = r.BinaryWriter.create()) {
      for (const E of l.rewards)
        n.DecCoin.encode(E, y.uint32(10).fork()).ldelim();
      return y;
    },
    decode(l, y) {
      const E = l instanceof r.BinaryReader ? l : new r.BinaryReader(l);
      let J = y === void 0 ? E.len : E.pos + y;
      const _ = T();
      for (; E.pos < J; ) {
        const V = E.uint32();
        switch (V >>> 3) {
          case 1:
            _.rewards.push(n.DecCoin.decode(E, E.uint32()));
            break;
          default:
            E.skipType(V & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(l) {
      const y = T();
      return Array.isArray(l == null ? void 0 : l.rewards) && (y.rewards = l.rewards.map((E) => n.DecCoin.fromJSON(E))), y;
    },
    toJSON(l) {
      const y = {};
      return l.rewards ? y.rewards = l.rewards.map((E) => E ? n.DecCoin.toJSON(E) : void 0) : y.rewards = [], y;
    },
    fromPartial(l) {
      var E;
      const y = T();
      return y.rewards = ((E = l.rewards) == null ? void 0 : E.map((J) => n.DecCoin.fromPartial(J))) || [], y;
    }
  };
  function U() {
    return {
      validatorPeriod: BigInt(0),
      fraction: ""
    };
  }
  e.ValidatorSlashEvent = {
    typeUrl: "/cosmos.distribution.v1beta1.ValidatorSlashEvent",
    encode(l, y = r.BinaryWriter.create()) {
      return l.validatorPeriod !== BigInt(0) && y.uint32(8).uint64(l.validatorPeriod), l.fraction !== "" && y.uint32(18).string(l.fraction), y;
    },
    decode(l, y) {
      const E = l instanceof r.BinaryReader ? l : new r.BinaryReader(l);
      let J = y === void 0 ? E.len : E.pos + y;
      const _ = U();
      for (; E.pos < J; ) {
        const V = E.uint32();
        switch (V >>> 3) {
          case 1:
            _.validatorPeriod = E.uint64();
            break;
          case 2:
            _.fraction = E.string();
            break;
          default:
            E.skipType(V & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(l) {
      const y = U();
      return (0, t.isSet)(l.validatorPeriod) && (y.validatorPeriod = BigInt(l.validatorPeriod.toString())), (0, t.isSet)(l.fraction) && (y.fraction = String(l.fraction)), y;
    },
    toJSON(l) {
      const y = {};
      return l.validatorPeriod !== void 0 && (y.validatorPeriod = (l.validatorPeriod || BigInt(0)).toString()), l.fraction !== void 0 && (y.fraction = l.fraction), y;
    },
    fromPartial(l) {
      const y = U();
      return l.validatorPeriod !== void 0 && l.validatorPeriod !== null && (y.validatorPeriod = BigInt(l.validatorPeriod.toString())), y.fraction = l.fraction ?? "", y;
    }
  };
  function w() {
    return {
      validatorSlashEvents: []
    };
  }
  e.ValidatorSlashEvents = {
    typeUrl: "/cosmos.distribution.v1beta1.ValidatorSlashEvents",
    encode(l, y = r.BinaryWriter.create()) {
      for (const E of l.validatorSlashEvents)
        e.ValidatorSlashEvent.encode(E, y.uint32(10).fork()).ldelim();
      return y;
    },
    decode(l, y) {
      const E = l instanceof r.BinaryReader ? l : new r.BinaryReader(l);
      let J = y === void 0 ? E.len : E.pos + y;
      const _ = w();
      for (; E.pos < J; ) {
        const V = E.uint32();
        switch (V >>> 3) {
          case 1:
            _.validatorSlashEvents.push(e.ValidatorSlashEvent.decode(E, E.uint32()));
            break;
          default:
            E.skipType(V & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(l) {
      const y = w();
      return Array.isArray(l == null ? void 0 : l.validatorSlashEvents) && (y.validatorSlashEvents = l.validatorSlashEvents.map((E) => e.ValidatorSlashEvent.fromJSON(E))), y;
    },
    toJSON(l) {
      const y = {};
      return l.validatorSlashEvents ? y.validatorSlashEvents = l.validatorSlashEvents.map((E) => E ? e.ValidatorSlashEvent.toJSON(E) : void 0) : y.validatorSlashEvents = [], y;
    },
    fromPartial(l) {
      var E;
      const y = w();
      return y.validatorSlashEvents = ((E = l.validatorSlashEvents) == null ? void 0 : E.map((J) => e.ValidatorSlashEvent.fromPartial(J))) || [], y;
    }
  };
  function N() {
    return {
      communityPool: []
    };
  }
  e.FeePool = {
    typeUrl: "/cosmos.distribution.v1beta1.FeePool",
    encode(l, y = r.BinaryWriter.create()) {
      for (const E of l.communityPool)
        n.DecCoin.encode(E, y.uint32(10).fork()).ldelim();
      return y;
    },
    decode(l, y) {
      const E = l instanceof r.BinaryReader ? l : new r.BinaryReader(l);
      let J = y === void 0 ? E.len : E.pos + y;
      const _ = N();
      for (; E.pos < J; ) {
        const V = E.uint32();
        switch (V >>> 3) {
          case 1:
            _.communityPool.push(n.DecCoin.decode(E, E.uint32()));
            break;
          default:
            E.skipType(V & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(l) {
      const y = N();
      return Array.isArray(l == null ? void 0 : l.communityPool) && (y.communityPool = l.communityPool.map((E) => n.DecCoin.fromJSON(E))), y;
    },
    toJSON(l) {
      const y = {};
      return l.communityPool ? y.communityPool = l.communityPool.map((E) => E ? n.DecCoin.toJSON(E) : void 0) : y.communityPool = [], y;
    },
    fromPartial(l) {
      var E;
      const y = N();
      return y.communityPool = ((E = l.communityPool) == null ? void 0 : E.map((J) => n.DecCoin.fromPartial(J))) || [], y;
    }
  };
  function h() {
    return {
      title: "",
      description: "",
      recipient: "",
      amount: []
    };
  }
  e.CommunityPoolSpendProposal = {
    typeUrl: "/cosmos.distribution.v1beta1.CommunityPoolSpendProposal",
    encode(l, y = r.BinaryWriter.create()) {
      l.title !== "" && y.uint32(10).string(l.title), l.description !== "" && y.uint32(18).string(l.description), l.recipient !== "" && y.uint32(26).string(l.recipient);
      for (const E of l.amount)
        n.Coin.encode(E, y.uint32(34).fork()).ldelim();
      return y;
    },
    decode(l, y) {
      const E = l instanceof r.BinaryReader ? l : new r.BinaryReader(l);
      let J = y === void 0 ? E.len : E.pos + y;
      const _ = h();
      for (; E.pos < J; ) {
        const V = E.uint32();
        switch (V >>> 3) {
          case 1:
            _.title = E.string();
            break;
          case 2:
            _.description = E.string();
            break;
          case 3:
            _.recipient = E.string();
            break;
          case 4:
            _.amount.push(n.Coin.decode(E, E.uint32()));
            break;
          default:
            E.skipType(V & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(l) {
      const y = h();
      return (0, t.isSet)(l.title) && (y.title = String(l.title)), (0, t.isSet)(l.description) && (y.description = String(l.description)), (0, t.isSet)(l.recipient) && (y.recipient = String(l.recipient)), Array.isArray(l == null ? void 0 : l.amount) && (y.amount = l.amount.map((E) => n.Coin.fromJSON(E))), y;
    },
    toJSON(l) {
      const y = {};
      return l.title !== void 0 && (y.title = l.title), l.description !== void 0 && (y.description = l.description), l.recipient !== void 0 && (y.recipient = l.recipient), l.amount ? y.amount = l.amount.map((E) => E ? n.Coin.toJSON(E) : void 0) : y.amount = [], y;
    },
    fromPartial(l) {
      var E;
      const y = h();
      return y.title = l.title ?? "", y.description = l.description ?? "", y.recipient = l.recipient ?? "", y.amount = ((E = l.amount) == null ? void 0 : E.map((J) => n.Coin.fromPartial(J))) || [], y;
    }
  };
  function P() {
    return {
      previousPeriod: BigInt(0),
      stake: "",
      height: BigInt(0)
    };
  }
  e.DelegatorStartingInfo = {
    typeUrl: "/cosmos.distribution.v1beta1.DelegatorStartingInfo",
    encode(l, y = r.BinaryWriter.create()) {
      return l.previousPeriod !== BigInt(0) && y.uint32(8).uint64(l.previousPeriod), l.stake !== "" && y.uint32(18).string(l.stake), l.height !== BigInt(0) && y.uint32(24).uint64(l.height), y;
    },
    decode(l, y) {
      const E = l instanceof r.BinaryReader ? l : new r.BinaryReader(l);
      let J = y === void 0 ? E.len : E.pos + y;
      const _ = P();
      for (; E.pos < J; ) {
        const V = E.uint32();
        switch (V >>> 3) {
          case 1:
            _.previousPeriod = E.uint64();
            break;
          case 2:
            _.stake = E.string();
            break;
          case 3:
            _.height = E.uint64();
            break;
          default:
            E.skipType(V & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(l) {
      const y = P();
      return (0, t.isSet)(l.previousPeriod) && (y.previousPeriod = BigInt(l.previousPeriod.toString())), (0, t.isSet)(l.stake) && (y.stake = String(l.stake)), (0, t.isSet)(l.height) && (y.height = BigInt(l.height.toString())), y;
    },
    toJSON(l) {
      const y = {};
      return l.previousPeriod !== void 0 && (y.previousPeriod = (l.previousPeriod || BigInt(0)).toString()), l.stake !== void 0 && (y.stake = l.stake), l.height !== void 0 && (y.height = (l.height || BigInt(0)).toString()), y;
    },
    fromPartial(l) {
      const y = P();
      return l.previousPeriod !== void 0 && l.previousPeriod !== null && (y.previousPeriod = BigInt(l.previousPeriod.toString())), y.stake = l.stake ?? "", l.height !== void 0 && l.height !== null && (y.height = BigInt(l.height.toString())), y;
    }
  };
  function b() {
    return {
      validatorAddress: "",
      reward: []
    };
  }
  e.DelegationDelegatorReward = {
    typeUrl: "/cosmos.distribution.v1beta1.DelegationDelegatorReward",
    encode(l, y = r.BinaryWriter.create()) {
      l.validatorAddress !== "" && y.uint32(10).string(l.validatorAddress);
      for (const E of l.reward)
        n.DecCoin.encode(E, y.uint32(18).fork()).ldelim();
      return y;
    },
    decode(l, y) {
      const E = l instanceof r.BinaryReader ? l : new r.BinaryReader(l);
      let J = y === void 0 ? E.len : E.pos + y;
      const _ = b();
      for (; E.pos < J; ) {
        const V = E.uint32();
        switch (V >>> 3) {
          case 1:
            _.validatorAddress = E.string();
            break;
          case 2:
            _.reward.push(n.DecCoin.decode(E, E.uint32()));
            break;
          default:
            E.skipType(V & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(l) {
      const y = b();
      return (0, t.isSet)(l.validatorAddress) && (y.validatorAddress = String(l.validatorAddress)), Array.isArray(l == null ? void 0 : l.reward) && (y.reward = l.reward.map((E) => n.DecCoin.fromJSON(E))), y;
    },
    toJSON(l) {
      const y = {};
      return l.validatorAddress !== void 0 && (y.validatorAddress = l.validatorAddress), l.reward ? y.reward = l.reward.map((E) => E ? n.DecCoin.toJSON(E) : void 0) : y.reward = [], y;
    },
    fromPartial(l) {
      var E;
      const y = b();
      return y.validatorAddress = l.validatorAddress ?? "", y.reward = ((E = l.reward) == null ? void 0 : E.map((J) => n.DecCoin.fromPartial(J))) || [], y;
    }
  };
  function c() {
    return {
      title: "",
      description: "",
      recipient: "",
      amount: "",
      deposit: ""
    };
  }
  e.CommunityPoolSpendProposalWithDeposit = {
    typeUrl: "/cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit",
    encode(l, y = r.BinaryWriter.create()) {
      return l.title !== "" && y.uint32(10).string(l.title), l.description !== "" && y.uint32(18).string(l.description), l.recipient !== "" && y.uint32(26).string(l.recipient), l.amount !== "" && y.uint32(34).string(l.amount), l.deposit !== "" && y.uint32(42).string(l.deposit), y;
    },
    decode(l, y) {
      const E = l instanceof r.BinaryReader ? l : new r.BinaryReader(l);
      let J = y === void 0 ? E.len : E.pos + y;
      const _ = c();
      for (; E.pos < J; ) {
        const V = E.uint32();
        switch (V >>> 3) {
          case 1:
            _.title = E.string();
            break;
          case 2:
            _.description = E.string();
            break;
          case 3:
            _.recipient = E.string();
            break;
          case 4:
            _.amount = E.string();
            break;
          case 5:
            _.deposit = E.string();
            break;
          default:
            E.skipType(V & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(l) {
      const y = c();
      return (0, t.isSet)(l.title) && (y.title = String(l.title)), (0, t.isSet)(l.description) && (y.description = String(l.description)), (0, t.isSet)(l.recipient) && (y.recipient = String(l.recipient)), (0, t.isSet)(l.amount) && (y.amount = String(l.amount)), (0, t.isSet)(l.deposit) && (y.deposit = String(l.deposit)), y;
    },
    toJSON(l) {
      const y = {};
      return l.title !== void 0 && (y.title = l.title), l.description !== void 0 && (y.description = l.description), l.recipient !== void 0 && (y.recipient = l.recipient), l.amount !== void 0 && (y.amount = l.amount), l.deposit !== void 0 && (y.deposit = l.deposit), y;
    },
    fromPartial(l) {
      const y = c();
      return y.title = l.title ?? "", y.description = l.description ?? "", y.recipient = l.recipient ?? "", y.amount = l.amount ?? "", y.deposit = l.deposit ?? "", y;
    }
  };
})(gd);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgCommunityPoolSpendResponse = e.MsgCommunityPoolSpend = e.MsgUpdateParamsResponse = e.MsgUpdateParams = e.MsgFundCommunityPoolResponse = e.MsgFundCommunityPool = e.MsgWithdrawValidatorCommissionResponse = e.MsgWithdrawValidatorCommission = e.MsgWithdrawDelegatorRewardResponse = e.MsgWithdrawDelegatorReward = e.MsgSetWithdrawAddressResponse = e.MsgSetWithdrawAddress = e.protobufPackage = void 0;
  const n = Le, r = gd, t = re, i = ie;
  e.protobufPackage = "cosmos.distribution.v1beta1";
  function f() {
    return {
      delegatorAddress: "",
      withdrawAddress: ""
    };
  }
  e.MsgSetWithdrawAddress = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
    encode(E, J = t.BinaryWriter.create()) {
      return E.delegatorAddress !== "" && J.uint32(10).string(E.delegatorAddress), E.withdrawAddress !== "" && J.uint32(18).string(E.withdrawAddress), J;
    },
    decode(E, J) {
      const _ = E instanceof t.BinaryReader ? E : new t.BinaryReader(E);
      let V = J === void 0 ? _.len : _.pos + J;
      const o = f();
      for (; _.pos < V; ) {
        const p = _.uint32();
        switch (p >>> 3) {
          case 1:
            o.delegatorAddress = _.string();
            break;
          case 2:
            o.withdrawAddress = _.string();
            break;
          default:
            _.skipType(p & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(E) {
      const J = f();
      return (0, i.isSet)(E.delegatorAddress) && (J.delegatorAddress = String(E.delegatorAddress)), (0, i.isSet)(E.withdrawAddress) && (J.withdrawAddress = String(E.withdrawAddress)), J;
    },
    toJSON(E) {
      const J = {};
      return E.delegatorAddress !== void 0 && (J.delegatorAddress = E.delegatorAddress), E.withdrawAddress !== void 0 && (J.withdrawAddress = E.withdrawAddress), J;
    },
    fromPartial(E) {
      const J = f();
      return J.delegatorAddress = E.delegatorAddress ?? "", J.withdrawAddress = E.withdrawAddress ?? "", J;
    }
  };
  function k() {
    return {};
  }
  e.MsgSetWithdrawAddressResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddressResponse",
    encode(E, J = t.BinaryWriter.create()) {
      return J;
    },
    decode(E, J) {
      const _ = E instanceof t.BinaryReader ? E : new t.BinaryReader(E);
      let V = J === void 0 ? _.len : _.pos + J;
      const o = k();
      for (; _.pos < V; ) {
        const p = _.uint32();
        switch (p >>> 3) {
          default:
            _.skipType(p & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(E) {
      return k();
    },
    toJSON(E) {
      return {};
    },
    fromPartial(E) {
      return k();
    }
  };
  function C() {
    return {
      delegatorAddress: "",
      validatorAddress: ""
    };
  }
  e.MsgWithdrawDelegatorReward = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
    encode(E, J = t.BinaryWriter.create()) {
      return E.delegatorAddress !== "" && J.uint32(10).string(E.delegatorAddress), E.validatorAddress !== "" && J.uint32(18).string(E.validatorAddress), J;
    },
    decode(E, J) {
      const _ = E instanceof t.BinaryReader ? E : new t.BinaryReader(E);
      let V = J === void 0 ? _.len : _.pos + J;
      const o = C();
      for (; _.pos < V; ) {
        const p = _.uint32();
        switch (p >>> 3) {
          case 1:
            o.delegatorAddress = _.string();
            break;
          case 2:
            o.validatorAddress = _.string();
            break;
          default:
            _.skipType(p & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(E) {
      const J = C();
      return (0, i.isSet)(E.delegatorAddress) && (J.delegatorAddress = String(E.delegatorAddress)), (0, i.isSet)(E.validatorAddress) && (J.validatorAddress = String(E.validatorAddress)), J;
    },
    toJSON(E) {
      const J = {};
      return E.delegatorAddress !== void 0 && (J.delegatorAddress = E.delegatorAddress), E.validatorAddress !== void 0 && (J.validatorAddress = E.validatorAddress), J;
    },
    fromPartial(E) {
      const J = C();
      return J.delegatorAddress = E.delegatorAddress ?? "", J.validatorAddress = E.validatorAddress ?? "", J;
    }
  };
  function T() {
    return {
      amount: []
    };
  }
  e.MsgWithdrawDelegatorRewardResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorRewardResponse",
    encode(E, J = t.BinaryWriter.create()) {
      for (const _ of E.amount)
        n.Coin.encode(_, J.uint32(10).fork()).ldelim();
      return J;
    },
    decode(E, J) {
      const _ = E instanceof t.BinaryReader ? E : new t.BinaryReader(E);
      let V = J === void 0 ? _.len : _.pos + J;
      const o = T();
      for (; _.pos < V; ) {
        const p = _.uint32();
        switch (p >>> 3) {
          case 1:
            o.amount.push(n.Coin.decode(_, _.uint32()));
            break;
          default:
            _.skipType(p & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(E) {
      const J = T();
      return Array.isArray(E == null ? void 0 : E.amount) && (J.amount = E.amount.map((_) => n.Coin.fromJSON(_))), J;
    },
    toJSON(E) {
      const J = {};
      return E.amount ? J.amount = E.amount.map((_) => _ ? n.Coin.toJSON(_) : void 0) : J.amount = [], J;
    },
    fromPartial(E) {
      var _;
      const J = T();
      return J.amount = ((_ = E.amount) == null ? void 0 : _.map((V) => n.Coin.fromPartial(V))) || [], J;
    }
  };
  function U() {
    return {
      validatorAddress: ""
    };
  }
  e.MsgWithdrawValidatorCommission = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
    encode(E, J = t.BinaryWriter.create()) {
      return E.validatorAddress !== "" && J.uint32(10).string(E.validatorAddress), J;
    },
    decode(E, J) {
      const _ = E instanceof t.BinaryReader ? E : new t.BinaryReader(E);
      let V = J === void 0 ? _.len : _.pos + J;
      const o = U();
      for (; _.pos < V; ) {
        const p = _.uint32();
        switch (p >>> 3) {
          case 1:
            o.validatorAddress = _.string();
            break;
          default:
            _.skipType(p & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(E) {
      const J = U();
      return (0, i.isSet)(E.validatorAddress) && (J.validatorAddress = String(E.validatorAddress)), J;
    },
    toJSON(E) {
      const J = {};
      return E.validatorAddress !== void 0 && (J.validatorAddress = E.validatorAddress), J;
    },
    fromPartial(E) {
      const J = U();
      return J.validatorAddress = E.validatorAddress ?? "", J;
    }
  };
  function w() {
    return {
      amount: []
    };
  }
  e.MsgWithdrawValidatorCommissionResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommissionResponse",
    encode(E, J = t.BinaryWriter.create()) {
      for (const _ of E.amount)
        n.Coin.encode(_, J.uint32(10).fork()).ldelim();
      return J;
    },
    decode(E, J) {
      const _ = E instanceof t.BinaryReader ? E : new t.BinaryReader(E);
      let V = J === void 0 ? _.len : _.pos + J;
      const o = w();
      for (; _.pos < V; ) {
        const p = _.uint32();
        switch (p >>> 3) {
          case 1:
            o.amount.push(n.Coin.decode(_, _.uint32()));
            break;
          default:
            _.skipType(p & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(E) {
      const J = w();
      return Array.isArray(E == null ? void 0 : E.amount) && (J.amount = E.amount.map((_) => n.Coin.fromJSON(_))), J;
    },
    toJSON(E) {
      const J = {};
      return E.amount ? J.amount = E.amount.map((_) => _ ? n.Coin.toJSON(_) : void 0) : J.amount = [], J;
    },
    fromPartial(E) {
      var _;
      const J = w();
      return J.amount = ((_ = E.amount) == null ? void 0 : _.map((V) => n.Coin.fromPartial(V))) || [], J;
    }
  };
  function N() {
    return {
      amount: [],
      depositor: ""
    };
  }
  e.MsgFundCommunityPool = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPool",
    encode(E, J = t.BinaryWriter.create()) {
      for (const _ of E.amount)
        n.Coin.encode(_, J.uint32(10).fork()).ldelim();
      return E.depositor !== "" && J.uint32(18).string(E.depositor), J;
    },
    decode(E, J) {
      const _ = E instanceof t.BinaryReader ? E : new t.BinaryReader(E);
      let V = J === void 0 ? _.len : _.pos + J;
      const o = N();
      for (; _.pos < V; ) {
        const p = _.uint32();
        switch (p >>> 3) {
          case 1:
            o.amount.push(n.Coin.decode(_, _.uint32()));
            break;
          case 2:
            o.depositor = _.string();
            break;
          default:
            _.skipType(p & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(E) {
      const J = N();
      return Array.isArray(E == null ? void 0 : E.amount) && (J.amount = E.amount.map((_) => n.Coin.fromJSON(_))), (0, i.isSet)(E.depositor) && (J.depositor = String(E.depositor)), J;
    },
    toJSON(E) {
      const J = {};
      return E.amount ? J.amount = E.amount.map((_) => _ ? n.Coin.toJSON(_) : void 0) : J.amount = [], E.depositor !== void 0 && (J.depositor = E.depositor), J;
    },
    fromPartial(E) {
      var _;
      const J = N();
      return J.amount = ((_ = E.amount) == null ? void 0 : _.map((V) => n.Coin.fromPartial(V))) || [], J.depositor = E.depositor ?? "", J;
    }
  };
  function h() {
    return {};
  }
  e.MsgFundCommunityPoolResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPoolResponse",
    encode(E, J = t.BinaryWriter.create()) {
      return J;
    },
    decode(E, J) {
      const _ = E instanceof t.BinaryReader ? E : new t.BinaryReader(E);
      let V = J === void 0 ? _.len : _.pos + J;
      const o = h();
      for (; _.pos < V; ) {
        const p = _.uint32();
        switch (p >>> 3) {
          default:
            _.skipType(p & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(E) {
      return h();
    },
    toJSON(E) {
      return {};
    },
    fromPartial(E) {
      return h();
    }
  };
  function P() {
    return {
      authority: "",
      params: r.Params.fromPartial({})
    };
  }
  e.MsgUpdateParams = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParams",
    encode(E, J = t.BinaryWriter.create()) {
      return E.authority !== "" && J.uint32(10).string(E.authority), E.params !== void 0 && r.Params.encode(E.params, J.uint32(18).fork()).ldelim(), J;
    },
    decode(E, J) {
      const _ = E instanceof t.BinaryReader ? E : new t.BinaryReader(E);
      let V = J === void 0 ? _.len : _.pos + J;
      const o = P();
      for (; _.pos < V; ) {
        const p = _.uint32();
        switch (p >>> 3) {
          case 1:
            o.authority = _.string();
            break;
          case 2:
            o.params = r.Params.decode(_, _.uint32());
            break;
          default:
            _.skipType(p & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(E) {
      const J = P();
      return (0, i.isSet)(E.authority) && (J.authority = String(E.authority)), (0, i.isSet)(E.params) && (J.params = r.Params.fromJSON(E.params)), J;
    },
    toJSON(E) {
      const J = {};
      return E.authority !== void 0 && (J.authority = E.authority), E.params !== void 0 && (J.params = E.params ? r.Params.toJSON(E.params) : void 0), J;
    },
    fromPartial(E) {
      const J = P();
      return J.authority = E.authority ?? "", E.params !== void 0 && E.params !== null && (J.params = r.Params.fromPartial(E.params)), J;
    }
  };
  function b() {
    return {};
  }
  e.MsgUpdateParamsResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParamsResponse",
    encode(E, J = t.BinaryWriter.create()) {
      return J;
    },
    decode(E, J) {
      const _ = E instanceof t.BinaryReader ? E : new t.BinaryReader(E);
      let V = J === void 0 ? _.len : _.pos + J;
      const o = b();
      for (; _.pos < V; ) {
        const p = _.uint32();
        switch (p >>> 3) {
          default:
            _.skipType(p & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(E) {
      return b();
    },
    toJSON(E) {
      return {};
    },
    fromPartial(E) {
      return b();
    }
  };
  function c() {
    return {
      authority: "",
      recipient: "",
      amount: []
    };
  }
  e.MsgCommunityPoolSpend = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpend",
    encode(E, J = t.BinaryWriter.create()) {
      E.authority !== "" && J.uint32(10).string(E.authority), E.recipient !== "" && J.uint32(18).string(E.recipient);
      for (const _ of E.amount)
        n.Coin.encode(_, J.uint32(26).fork()).ldelim();
      return J;
    },
    decode(E, J) {
      const _ = E instanceof t.BinaryReader ? E : new t.BinaryReader(E);
      let V = J === void 0 ? _.len : _.pos + J;
      const o = c();
      for (; _.pos < V; ) {
        const p = _.uint32();
        switch (p >>> 3) {
          case 1:
            o.authority = _.string();
            break;
          case 2:
            o.recipient = _.string();
            break;
          case 3:
            o.amount.push(n.Coin.decode(_, _.uint32()));
            break;
          default:
            _.skipType(p & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(E) {
      const J = c();
      return (0, i.isSet)(E.authority) && (J.authority = String(E.authority)), (0, i.isSet)(E.recipient) && (J.recipient = String(E.recipient)), Array.isArray(E == null ? void 0 : E.amount) && (J.amount = E.amount.map((_) => n.Coin.fromJSON(_))), J;
    },
    toJSON(E) {
      const J = {};
      return E.authority !== void 0 && (J.authority = E.authority), E.recipient !== void 0 && (J.recipient = E.recipient), E.amount ? J.amount = E.amount.map((_) => _ ? n.Coin.toJSON(_) : void 0) : J.amount = [], J;
    },
    fromPartial(E) {
      var _;
      const J = c();
      return J.authority = E.authority ?? "", J.recipient = E.recipient ?? "", J.amount = ((_ = E.amount) == null ? void 0 : _.map((V) => n.Coin.fromPartial(V))) || [], J;
    }
  };
  function l() {
    return {};
  }
  e.MsgCommunityPoolSpendResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpendResponse",
    encode(E, J = t.BinaryWriter.create()) {
      return J;
    },
    decode(E, J) {
      const _ = E instanceof t.BinaryReader ? E : new t.BinaryReader(E);
      let V = J === void 0 ? _.len : _.pos + J;
      const o = l();
      for (; _.pos < V; ) {
        const p = _.uint32();
        switch (p >>> 3) {
          default:
            _.skipType(p & 7);
            break;
        }
      }
      return o;
    },
    fromJSON(E) {
      return l();
    },
    toJSON(E) {
      return {};
    },
    fromPartial(E) {
      return l();
    }
  };
  class y {
    constructor(J) {
      this.rpc = J, this.SetWithdrawAddress = this.SetWithdrawAddress.bind(this), this.WithdrawDelegatorReward = this.WithdrawDelegatorReward.bind(this), this.WithdrawValidatorCommission = this.WithdrawValidatorCommission.bind(this), this.FundCommunityPool = this.FundCommunityPool.bind(this), this.UpdateParams = this.UpdateParams.bind(this), this.CommunityPoolSpend = this.CommunityPoolSpend.bind(this);
    }
    SetWithdrawAddress(J) {
      const _ = e.MsgSetWithdrawAddress.encode(J).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "SetWithdrawAddress", _).then((o) => e.MsgSetWithdrawAddressResponse.decode(new t.BinaryReader(o)));
    }
    WithdrawDelegatorReward(J) {
      const _ = e.MsgWithdrawDelegatorReward.encode(J).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawDelegatorReward", _).then((o) => e.MsgWithdrawDelegatorRewardResponse.decode(new t.BinaryReader(o)));
    }
    WithdrawValidatorCommission(J) {
      const _ = e.MsgWithdrawValidatorCommission.encode(J).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawValidatorCommission", _).then((o) => e.MsgWithdrawValidatorCommissionResponse.decode(new t.BinaryReader(o)));
    }
    FundCommunityPool(J) {
      const _ = e.MsgFundCommunityPool.encode(J).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "FundCommunityPool", _).then((o) => e.MsgFundCommunityPoolResponse.decode(new t.BinaryReader(o)));
    }
    UpdateParams(J) {
      const _ = e.MsgUpdateParams.encode(J).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "UpdateParams", _).then((o) => e.MsgUpdateParamsResponse.decode(new t.BinaryReader(o)));
    }
    CommunityPoolSpend(J) {
      const _ = e.MsgCommunityPoolSpend.encode(J).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Msg", "CommunityPoolSpend", _).then((o) => e.MsgCommunityPoolSpendResponse.decode(new t.BinaryReader(o)));
    }
  }
  e.MsgClientImpl = y;
})(md);
Object.defineProperty(tr, "__esModule", { value: !0 });
tr.isMsgWithdrawDelegatorRewardEncodeObject = tr.distributionTypes = void 0;
const yi = md;
tr.distributionTypes = [
  ["/cosmos.distribution.v1beta1.MsgFundCommunityPool", yi.MsgFundCommunityPool],
  ["/cosmos.distribution.v1beta1.MsgSetWithdrawAddress", yi.MsgSetWithdrawAddress],
  ["/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward", yi.MsgWithdrawDelegatorReward],
  ["/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission", yi.MsgWithdrawValidatorCommission]
];
function um(e) {
  return e.typeUrl === "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward";
}
tr.isMsgWithdrawDelegatorRewardEncodeObject = um;
var go = {}, Yc = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryCommunityPoolResponse = e.QueryCommunityPoolRequest = e.QueryDelegatorWithdrawAddressResponse = e.QueryDelegatorWithdrawAddressRequest = e.QueryDelegatorValidatorsResponse = e.QueryDelegatorValidatorsRequest = e.QueryDelegationTotalRewardsResponse = e.QueryDelegationTotalRewardsRequest = e.QueryDelegationRewardsResponse = e.QueryDelegationRewardsRequest = e.QueryValidatorSlashesResponse = e.QueryValidatorSlashesRequest = e.QueryValidatorCommissionResponse = e.QueryValidatorCommissionRequest = e.QueryValidatorOutstandingRewardsResponse = e.QueryValidatorOutstandingRewardsRequest = e.QueryValidatorDistributionInfoResponse = e.QueryValidatorDistributionInfoRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.protobufPackage = void 0;
  const n = Ae, r = gd, t = Le, i = re, f = ie;
  e.protobufPackage = "cosmos.distribution.v1beta1";
  function k() {
    return {};
  }
  e.QueryParamsRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryParamsRequest",
    encode(u, A = i.BinaryWriter.create()) {
      return A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = k();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      return k();
    },
    toJSON(u) {
      return {};
    },
    fromPartial(u) {
      return k();
    }
  };
  function C() {
    return {
      params: r.Params.fromPartial({})
    };
  }
  e.QueryParamsResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryParamsResponse",
    encode(u, A = i.BinaryWriter.create()) {
      return u.params !== void 0 && r.Params.encode(u.params, A.uint32(10).fork()).ldelim(), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = C();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.params = r.Params.decode(R, R.uint32());
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = C();
      return (0, f.isSet)(u.params) && (A.params = r.Params.fromJSON(u.params)), A;
    },
    toJSON(u) {
      const A = {};
      return u.params !== void 0 && (A.params = u.params ? r.Params.toJSON(u.params) : void 0), A;
    },
    fromPartial(u) {
      const A = C();
      return u.params !== void 0 && u.params !== null && (A.params = r.Params.fromPartial(u.params)), A;
    }
  };
  function T() {
    return {
      validatorAddress: ""
    };
  }
  e.QueryValidatorDistributionInfoRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorDistributionInfoRequest",
    encode(u, A = i.BinaryWriter.create()) {
      return u.validatorAddress !== "" && A.uint32(10).string(u.validatorAddress), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = T();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.validatorAddress = R.string();
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = T();
      return (0, f.isSet)(u.validatorAddress) && (A.validatorAddress = String(u.validatorAddress)), A;
    },
    toJSON(u) {
      const A = {};
      return u.validatorAddress !== void 0 && (A.validatorAddress = u.validatorAddress), A;
    },
    fromPartial(u) {
      const A = T();
      return A.validatorAddress = u.validatorAddress ?? "", A;
    }
  };
  function U() {
    return {
      operatorAddress: "",
      selfBondRewards: [],
      commission: []
    };
  }
  e.QueryValidatorDistributionInfoResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorDistributionInfoResponse",
    encode(u, A = i.BinaryWriter.create()) {
      u.operatorAddress !== "" && A.uint32(10).string(u.operatorAddress);
      for (const R of u.selfBondRewards)
        t.DecCoin.encode(R, A.uint32(18).fork()).ldelim();
      for (const R of u.commission)
        t.DecCoin.encode(R, A.uint32(26).fork()).ldelim();
      return A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = U();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.operatorAddress = R.string();
            break;
          case 2:
            D.selfBondRewards.push(t.DecCoin.decode(R, R.uint32()));
            break;
          case 3:
            D.commission.push(t.DecCoin.decode(R, R.uint32()));
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = U();
      return (0, f.isSet)(u.operatorAddress) && (A.operatorAddress = String(u.operatorAddress)), Array.isArray(u == null ? void 0 : u.selfBondRewards) && (A.selfBondRewards = u.selfBondRewards.map((R) => t.DecCoin.fromJSON(R))), Array.isArray(u == null ? void 0 : u.commission) && (A.commission = u.commission.map((R) => t.DecCoin.fromJSON(R))), A;
    },
    toJSON(u) {
      const A = {};
      return u.operatorAddress !== void 0 && (A.operatorAddress = u.operatorAddress), u.selfBondRewards ? A.selfBondRewards = u.selfBondRewards.map((R) => R ? t.DecCoin.toJSON(R) : void 0) : A.selfBondRewards = [], u.commission ? A.commission = u.commission.map((R) => R ? t.DecCoin.toJSON(R) : void 0) : A.commission = [], A;
    },
    fromPartial(u) {
      var R, v;
      const A = U();
      return A.operatorAddress = u.operatorAddress ?? "", A.selfBondRewards = ((R = u.selfBondRewards) == null ? void 0 : R.map((D) => t.DecCoin.fromPartial(D))) || [], A.commission = ((v = u.commission) == null ? void 0 : v.map((D) => t.DecCoin.fromPartial(D))) || [], A;
    }
  };
  function w() {
    return {
      validatorAddress: ""
    };
  }
  e.QueryValidatorOutstandingRewardsRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsRequest",
    encode(u, A = i.BinaryWriter.create()) {
      return u.validatorAddress !== "" && A.uint32(10).string(u.validatorAddress), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = w();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.validatorAddress = R.string();
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = w();
      return (0, f.isSet)(u.validatorAddress) && (A.validatorAddress = String(u.validatorAddress)), A;
    },
    toJSON(u) {
      const A = {};
      return u.validatorAddress !== void 0 && (A.validatorAddress = u.validatorAddress), A;
    },
    fromPartial(u) {
      const A = w();
      return A.validatorAddress = u.validatorAddress ?? "", A;
    }
  };
  function N() {
    return {
      rewards: r.ValidatorOutstandingRewards.fromPartial({})
    };
  }
  e.QueryValidatorOutstandingRewardsResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse",
    encode(u, A = i.BinaryWriter.create()) {
      return u.rewards !== void 0 && r.ValidatorOutstandingRewards.encode(u.rewards, A.uint32(10).fork()).ldelim(), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = N();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.rewards = r.ValidatorOutstandingRewards.decode(R, R.uint32());
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = N();
      return (0, f.isSet)(u.rewards) && (A.rewards = r.ValidatorOutstandingRewards.fromJSON(u.rewards)), A;
    },
    toJSON(u) {
      const A = {};
      return u.rewards !== void 0 && (A.rewards = u.rewards ? r.ValidatorOutstandingRewards.toJSON(u.rewards) : void 0), A;
    },
    fromPartial(u) {
      const A = N();
      return u.rewards !== void 0 && u.rewards !== null && (A.rewards = r.ValidatorOutstandingRewards.fromPartial(u.rewards)), A;
    }
  };
  function h() {
    return {
      validatorAddress: ""
    };
  }
  e.QueryValidatorCommissionRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorCommissionRequest",
    encode(u, A = i.BinaryWriter.create()) {
      return u.validatorAddress !== "" && A.uint32(10).string(u.validatorAddress), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = h();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.validatorAddress = R.string();
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = h();
      return (0, f.isSet)(u.validatorAddress) && (A.validatorAddress = String(u.validatorAddress)), A;
    },
    toJSON(u) {
      const A = {};
      return u.validatorAddress !== void 0 && (A.validatorAddress = u.validatorAddress), A;
    },
    fromPartial(u) {
      const A = h();
      return A.validatorAddress = u.validatorAddress ?? "", A;
    }
  };
  function P() {
    return {
      commission: r.ValidatorAccumulatedCommission.fromPartial({})
    };
  }
  e.QueryValidatorCommissionResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorCommissionResponse",
    encode(u, A = i.BinaryWriter.create()) {
      return u.commission !== void 0 && r.ValidatorAccumulatedCommission.encode(u.commission, A.uint32(10).fork()).ldelim(), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = P();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.commission = r.ValidatorAccumulatedCommission.decode(R, R.uint32());
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = P();
      return (0, f.isSet)(u.commission) && (A.commission = r.ValidatorAccumulatedCommission.fromJSON(u.commission)), A;
    },
    toJSON(u) {
      const A = {};
      return u.commission !== void 0 && (A.commission = u.commission ? r.ValidatorAccumulatedCommission.toJSON(u.commission) : void 0), A;
    },
    fromPartial(u) {
      const A = P();
      return u.commission !== void 0 && u.commission !== null && (A.commission = r.ValidatorAccumulatedCommission.fromPartial(u.commission)), A;
    }
  };
  function b() {
    return {
      validatorAddress: "",
      startingHeight: BigInt(0),
      endingHeight: BigInt(0),
      pagination: void 0
    };
  }
  e.QueryValidatorSlashesRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorSlashesRequest",
    encode(u, A = i.BinaryWriter.create()) {
      return u.validatorAddress !== "" && A.uint32(10).string(u.validatorAddress), u.startingHeight !== BigInt(0) && A.uint32(16).uint64(u.startingHeight), u.endingHeight !== BigInt(0) && A.uint32(24).uint64(u.endingHeight), u.pagination !== void 0 && n.PageRequest.encode(u.pagination, A.uint32(34).fork()).ldelim(), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = b();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.validatorAddress = R.string();
            break;
          case 2:
            D.startingHeight = R.uint64();
            break;
          case 3:
            D.endingHeight = R.uint64();
            break;
          case 4:
            D.pagination = n.PageRequest.decode(R, R.uint32());
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = b();
      return (0, f.isSet)(u.validatorAddress) && (A.validatorAddress = String(u.validatorAddress)), (0, f.isSet)(u.startingHeight) && (A.startingHeight = BigInt(u.startingHeight.toString())), (0, f.isSet)(u.endingHeight) && (A.endingHeight = BigInt(u.endingHeight.toString())), (0, f.isSet)(u.pagination) && (A.pagination = n.PageRequest.fromJSON(u.pagination)), A;
    },
    toJSON(u) {
      const A = {};
      return u.validatorAddress !== void 0 && (A.validatorAddress = u.validatorAddress), u.startingHeight !== void 0 && (A.startingHeight = (u.startingHeight || BigInt(0)).toString()), u.endingHeight !== void 0 && (A.endingHeight = (u.endingHeight || BigInt(0)).toString()), u.pagination !== void 0 && (A.pagination = u.pagination ? n.PageRequest.toJSON(u.pagination) : void 0), A;
    },
    fromPartial(u) {
      const A = b();
      return A.validatorAddress = u.validatorAddress ?? "", u.startingHeight !== void 0 && u.startingHeight !== null && (A.startingHeight = BigInt(u.startingHeight.toString())), u.endingHeight !== void 0 && u.endingHeight !== null && (A.endingHeight = BigInt(u.endingHeight.toString())), u.pagination !== void 0 && u.pagination !== null && (A.pagination = n.PageRequest.fromPartial(u.pagination)), A;
    }
  };
  function c() {
    return {
      slashes: [],
      pagination: void 0
    };
  }
  e.QueryValidatorSlashesResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorSlashesResponse",
    encode(u, A = i.BinaryWriter.create()) {
      for (const R of u.slashes)
        r.ValidatorSlashEvent.encode(R, A.uint32(10).fork()).ldelim();
      return u.pagination !== void 0 && n.PageResponse.encode(u.pagination, A.uint32(18).fork()).ldelim(), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = c();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.slashes.push(r.ValidatorSlashEvent.decode(R, R.uint32()));
            break;
          case 2:
            D.pagination = n.PageResponse.decode(R, R.uint32());
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = c();
      return Array.isArray(u == null ? void 0 : u.slashes) && (A.slashes = u.slashes.map((R) => r.ValidatorSlashEvent.fromJSON(R))), (0, f.isSet)(u.pagination) && (A.pagination = n.PageResponse.fromJSON(u.pagination)), A;
    },
    toJSON(u) {
      const A = {};
      return u.slashes ? A.slashes = u.slashes.map((R) => R ? r.ValidatorSlashEvent.toJSON(R) : void 0) : A.slashes = [], u.pagination !== void 0 && (A.pagination = u.pagination ? n.PageResponse.toJSON(u.pagination) : void 0), A;
    },
    fromPartial(u) {
      var R;
      const A = c();
      return A.slashes = ((R = u.slashes) == null ? void 0 : R.map((v) => r.ValidatorSlashEvent.fromPartial(v))) || [], u.pagination !== void 0 && u.pagination !== null && (A.pagination = n.PageResponse.fromPartial(u.pagination)), A;
    }
  };
  function l() {
    return {
      delegatorAddress: "",
      validatorAddress: ""
    };
  }
  e.QueryDelegationRewardsRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationRewardsRequest",
    encode(u, A = i.BinaryWriter.create()) {
      return u.delegatorAddress !== "" && A.uint32(10).string(u.delegatorAddress), u.validatorAddress !== "" && A.uint32(18).string(u.validatorAddress), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = l();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.delegatorAddress = R.string();
            break;
          case 2:
            D.validatorAddress = R.string();
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = l();
      return (0, f.isSet)(u.delegatorAddress) && (A.delegatorAddress = String(u.delegatorAddress)), (0, f.isSet)(u.validatorAddress) && (A.validatorAddress = String(u.validatorAddress)), A;
    },
    toJSON(u) {
      const A = {};
      return u.delegatorAddress !== void 0 && (A.delegatorAddress = u.delegatorAddress), u.validatorAddress !== void 0 && (A.validatorAddress = u.validatorAddress), A;
    },
    fromPartial(u) {
      const A = l();
      return A.delegatorAddress = u.delegatorAddress ?? "", A.validatorAddress = u.validatorAddress ?? "", A;
    }
  };
  function y() {
    return {
      rewards: []
    };
  }
  e.QueryDelegationRewardsResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationRewardsResponse",
    encode(u, A = i.BinaryWriter.create()) {
      for (const R of u.rewards)
        t.DecCoin.encode(R, A.uint32(10).fork()).ldelim();
      return A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = y();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.rewards.push(t.DecCoin.decode(R, R.uint32()));
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = y();
      return Array.isArray(u == null ? void 0 : u.rewards) && (A.rewards = u.rewards.map((R) => t.DecCoin.fromJSON(R))), A;
    },
    toJSON(u) {
      const A = {};
      return u.rewards ? A.rewards = u.rewards.map((R) => R ? t.DecCoin.toJSON(R) : void 0) : A.rewards = [], A;
    },
    fromPartial(u) {
      var R;
      const A = y();
      return A.rewards = ((R = u.rewards) == null ? void 0 : R.map((v) => t.DecCoin.fromPartial(v))) || [], A;
    }
  };
  function E() {
    return {
      delegatorAddress: ""
    };
  }
  e.QueryDelegationTotalRewardsRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationTotalRewardsRequest",
    encode(u, A = i.BinaryWriter.create()) {
      return u.delegatorAddress !== "" && A.uint32(10).string(u.delegatorAddress), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = E();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.delegatorAddress = R.string();
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = E();
      return (0, f.isSet)(u.delegatorAddress) && (A.delegatorAddress = String(u.delegatorAddress)), A;
    },
    toJSON(u) {
      const A = {};
      return u.delegatorAddress !== void 0 && (A.delegatorAddress = u.delegatorAddress), A;
    },
    fromPartial(u) {
      const A = E();
      return A.delegatorAddress = u.delegatorAddress ?? "", A;
    }
  };
  function J() {
    return {
      rewards: [],
      total: []
    };
  }
  e.QueryDelegationTotalRewardsResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse",
    encode(u, A = i.BinaryWriter.create()) {
      for (const R of u.rewards)
        r.DelegationDelegatorReward.encode(R, A.uint32(10).fork()).ldelim();
      for (const R of u.total)
        t.DecCoin.encode(R, A.uint32(18).fork()).ldelim();
      return A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = J();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.rewards.push(r.DelegationDelegatorReward.decode(R, R.uint32()));
            break;
          case 2:
            D.total.push(t.DecCoin.decode(R, R.uint32()));
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = J();
      return Array.isArray(u == null ? void 0 : u.rewards) && (A.rewards = u.rewards.map((R) => r.DelegationDelegatorReward.fromJSON(R))), Array.isArray(u == null ? void 0 : u.total) && (A.total = u.total.map((R) => t.DecCoin.fromJSON(R))), A;
    },
    toJSON(u) {
      const A = {};
      return u.rewards ? A.rewards = u.rewards.map((R) => R ? r.DelegationDelegatorReward.toJSON(R) : void 0) : A.rewards = [], u.total ? A.total = u.total.map((R) => R ? t.DecCoin.toJSON(R) : void 0) : A.total = [], A;
    },
    fromPartial(u) {
      var R, v;
      const A = J();
      return A.rewards = ((R = u.rewards) == null ? void 0 : R.map((D) => r.DelegationDelegatorReward.fromPartial(D))) || [], A.total = ((v = u.total) == null ? void 0 : v.map((D) => t.DecCoin.fromPartial(D))) || [], A;
    }
  };
  function _() {
    return {
      delegatorAddress: ""
    };
  }
  e.QueryDelegatorValidatorsRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorValidatorsRequest",
    encode(u, A = i.BinaryWriter.create()) {
      return u.delegatorAddress !== "" && A.uint32(10).string(u.delegatorAddress), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = _();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.delegatorAddress = R.string();
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = _();
      return (0, f.isSet)(u.delegatorAddress) && (A.delegatorAddress = String(u.delegatorAddress)), A;
    },
    toJSON(u) {
      const A = {};
      return u.delegatorAddress !== void 0 && (A.delegatorAddress = u.delegatorAddress), A;
    },
    fromPartial(u) {
      const A = _();
      return A.delegatorAddress = u.delegatorAddress ?? "", A;
    }
  };
  function V() {
    return {
      validators: []
    };
  }
  e.QueryDelegatorValidatorsResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse",
    encode(u, A = i.BinaryWriter.create()) {
      for (const R of u.validators)
        A.uint32(10).string(R);
      return A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = V();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.validators.push(R.string());
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = V();
      return Array.isArray(u == null ? void 0 : u.validators) && (A.validators = u.validators.map((R) => String(R))), A;
    },
    toJSON(u) {
      const A = {};
      return u.validators ? A.validators = u.validators.map((R) => R) : A.validators = [], A;
    },
    fromPartial(u) {
      var R;
      const A = V();
      return A.validators = ((R = u.validators) == null ? void 0 : R.map((v) => v)) || [], A;
    }
  };
  function o() {
    return {
      delegatorAddress: ""
    };
  }
  e.QueryDelegatorWithdrawAddressRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressRequest",
    encode(u, A = i.BinaryWriter.create()) {
      return u.delegatorAddress !== "" && A.uint32(10).string(u.delegatorAddress), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = o();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.delegatorAddress = R.string();
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = o();
      return (0, f.isSet)(u.delegatorAddress) && (A.delegatorAddress = String(u.delegatorAddress)), A;
    },
    toJSON(u) {
      const A = {};
      return u.delegatorAddress !== void 0 && (A.delegatorAddress = u.delegatorAddress), A;
    },
    fromPartial(u) {
      const A = o();
      return A.delegatorAddress = u.delegatorAddress ?? "", A;
    }
  };
  function p() {
    return {
      withdrawAddress: ""
    };
  }
  e.QueryDelegatorWithdrawAddressResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse",
    encode(u, A = i.BinaryWriter.create()) {
      return u.withdrawAddress !== "" && A.uint32(10).string(u.withdrawAddress), A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = p();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.withdrawAddress = R.string();
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = p();
      return (0, f.isSet)(u.withdrawAddress) && (A.withdrawAddress = String(u.withdrawAddress)), A;
    },
    toJSON(u) {
      const A = {};
      return u.withdrawAddress !== void 0 && (A.withdrawAddress = u.withdrawAddress), A;
    },
    fromPartial(u) {
      const A = p();
      return A.withdrawAddress = u.withdrawAddress ?? "", A;
    }
  };
  function I() {
    return {};
  }
  e.QueryCommunityPoolRequest = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryCommunityPoolRequest",
    encode(u, A = i.BinaryWriter.create()) {
      return A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = I();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      return I();
    },
    toJSON(u) {
      return {};
    },
    fromPartial(u) {
      return I();
    }
  };
  function q() {
    return {
      pool: []
    };
  }
  e.QueryCommunityPoolResponse = {
    typeUrl: "/cosmos.distribution.v1beta1.QueryCommunityPoolResponse",
    encode(u, A = i.BinaryWriter.create()) {
      for (const R of u.pool)
        t.DecCoin.encode(R, A.uint32(10).fork()).ldelim();
      return A;
    },
    decode(u, A) {
      const R = u instanceof i.BinaryReader ? u : new i.BinaryReader(u);
      let v = A === void 0 ? R.len : R.pos + A;
      const D = q();
      for (; R.pos < v; ) {
        const W = R.uint32();
        switch (W >>> 3) {
          case 1:
            D.pool.push(t.DecCoin.decode(R, R.uint32()));
            break;
          default:
            R.skipType(W & 7);
            break;
        }
      }
      return D;
    },
    fromJSON(u) {
      const A = q();
      return Array.isArray(u == null ? void 0 : u.pool) && (A.pool = u.pool.map((R) => t.DecCoin.fromJSON(R))), A;
    },
    toJSON(u) {
      const A = {};
      return u.pool ? A.pool = u.pool.map((R) => R ? t.DecCoin.toJSON(R) : void 0) : A.pool = [], A;
    },
    fromPartial(u) {
      var R;
      const A = q();
      return A.pool = ((R = u.pool) == null ? void 0 : R.map((v) => t.DecCoin.fromPartial(v))) || [], A;
    }
  };
  class s {
    constructor(A) {
      this.rpc = A, this.Params = this.Params.bind(this), this.ValidatorDistributionInfo = this.ValidatorDistributionInfo.bind(this), this.ValidatorOutstandingRewards = this.ValidatorOutstandingRewards.bind(this), this.ValidatorCommission = this.ValidatorCommission.bind(this), this.ValidatorSlashes = this.ValidatorSlashes.bind(this), this.DelegationRewards = this.DelegationRewards.bind(this), this.DelegationTotalRewards = this.DelegationTotalRewards.bind(this), this.DelegatorValidators = this.DelegatorValidators.bind(this), this.DelegatorWithdrawAddress = this.DelegatorWithdrawAddress.bind(this), this.CommunityPool = this.CommunityPool.bind(this);
    }
    Params(A = {}) {
      const R = e.QueryParamsRequest.encode(A).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "Params", R).then((D) => e.QueryParamsResponse.decode(new i.BinaryReader(D)));
    }
    ValidatorDistributionInfo(A) {
      const R = e.QueryValidatorDistributionInfoRequest.encode(A).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorDistributionInfo", R).then((D) => e.QueryValidatorDistributionInfoResponse.decode(new i.BinaryReader(D)));
    }
    ValidatorOutstandingRewards(A) {
      const R = e.QueryValidatorOutstandingRewardsRequest.encode(A).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorOutstandingRewards", R).then((D) => e.QueryValidatorOutstandingRewardsResponse.decode(new i.BinaryReader(D)));
    }
    ValidatorCommission(A) {
      const R = e.QueryValidatorCommissionRequest.encode(A).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorCommission", R).then((D) => e.QueryValidatorCommissionResponse.decode(new i.BinaryReader(D)));
    }
    ValidatorSlashes(A) {
      const R = e.QueryValidatorSlashesRequest.encode(A).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorSlashes", R).then((D) => e.QueryValidatorSlashesResponse.decode(new i.BinaryReader(D)));
    }
    DelegationRewards(A) {
      const R = e.QueryDelegationRewardsRequest.encode(A).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationRewards", R).then((D) => e.QueryDelegationRewardsResponse.decode(new i.BinaryReader(D)));
    }
    DelegationTotalRewards(A) {
      const R = e.QueryDelegationTotalRewardsRequest.encode(A).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationTotalRewards", R).then((D) => e.QueryDelegationTotalRewardsResponse.decode(new i.BinaryReader(D)));
    }
    DelegatorValidators(A) {
      const R = e.QueryDelegatorValidatorsRequest.encode(A).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorValidators", R).then((D) => e.QueryDelegatorValidatorsResponse.decode(new i.BinaryReader(D)));
    }
    DelegatorWithdrawAddress(A) {
      const R = e.QueryDelegatorWithdrawAddressRequest.encode(A).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorWithdrawAddress", R).then((D) => e.QueryDelegatorWithdrawAddressResponse.decode(new i.BinaryReader(D)));
    }
    CommunityPool(A = {}) {
      const R = e.QueryCommunityPoolRequest.encode(A).finish();
      return this.rpc.request("cosmos.distribution.v1beta1.Query", "CommunityPool", R).then((D) => e.QueryCommunityPoolResponse.decode(new i.BinaryReader(D)));
    }
  }
  e.QueryClientImpl = s;
})(Yc);
Object.defineProperty(go, "__esModule", { value: !0 });
go.setupDistributionExtension = void 0;
const cm = Yc, Iu = Ge;
function lm(e) {
  const n = (0, Iu.createProtobufRpcClient)(e), r = new cm.QueryClientImpl(n);
  return {
    distribution: {
      communityPool: async () => await r.CommunityPool({}),
      delegationRewards: async (t, i) => await r.DelegationRewards({
        delegatorAddress: t,
        validatorAddress: i
      }),
      delegationTotalRewards: async (t) => await r.DelegationTotalRewards({
        delegatorAddress: t
      }),
      delegatorValidators: async (t) => await r.DelegatorValidators({
        delegatorAddress: t
      }),
      delegatorWithdrawAddress: async (t) => await r.DelegatorWithdrawAddress({
        delegatorAddress: t
      }),
      params: async () => await r.Params({}),
      validatorCommission: async (t) => await r.ValidatorCommission({
        validatorAddress: t
      }),
      validatorOutstandingRewards: async (t) => await r.ValidatorOutstandingRewards({
        validatorAddress: t
      }),
      validatorSlashes: async (t, i, f, k) => await r.ValidatorSlashes({
        validatorAddress: t,
        startingHeight: BigInt(i),
        endingHeight: BigInt(f),
        pagination: (0, Iu.createPagination)(k)
      })
    }
  };
}
go.setupDistributionExtension = lm;
var rr = {};
Object.defineProperty(rr, "__esModule", { value: !0 });
rr.createEvidenceAminoConverters = rr.isAminoMsgSubmitEvidence = void 0;
function fm(e) {
  return e.type === "cosmos-sdk/MsgSubmitEvidence";
}
rr.isAminoMsgSubmitEvidence = fm;
function pm() {
  throw new Error("Not implemented");
}
rr.createEvidenceAminoConverters = pm;
var So = {};
Object.defineProperty(So, "__esModule", { value: !0 });
So.createFeegrantAminoConverters = void 0;
function hm() {
  return {
    // For Cosmos SDK < 0.46 the Amino JSON codec was broken on chain and thus inaccessible.
    // Now this can be implemented for 0.46+ chains, see
    // https://github.com/cosmos/cosmjs/issues/1092
    //
    // "/cosmos.feegrant.v1beta1.MsgGrantAllowance": IMPLEMENT_ME,
    // "/cosmos.feegrant.v1beta1.MsgRevokeAllowance": IMPLEMENT_ME,
  };
}
So.createFeegrantAminoConverters = hm;
var ko = {}, Xc = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgRevokeAllowanceResponse = e.MsgRevokeAllowance = e.MsgGrantAllowanceResponse = e.MsgGrantAllowance = e.protobufPackage = void 0;
  const n = Be, r = re, t = ie;
  e.protobufPackage = "cosmos.feegrant.v1beta1";
  function i() {
    return {
      granter: "",
      grantee: "",
      allowance: void 0
    };
  }
  e.MsgGrantAllowance = {
    typeUrl: "/cosmos.feegrant.v1beta1.MsgGrantAllowance",
    encode(U, w = r.BinaryWriter.create()) {
      return U.granter !== "" && w.uint32(10).string(U.granter), U.grantee !== "" && w.uint32(18).string(U.grantee), U.allowance !== void 0 && n.Any.encode(U.allowance, w.uint32(26).fork()).ldelim(), w;
    },
    decode(U, w) {
      const N = U instanceof r.BinaryReader ? U : new r.BinaryReader(U);
      let h = w === void 0 ? N.len : N.pos + w;
      const P = i();
      for (; N.pos < h; ) {
        const b = N.uint32();
        switch (b >>> 3) {
          case 1:
            P.granter = N.string();
            break;
          case 2:
            P.grantee = N.string();
            break;
          case 3:
            P.allowance = n.Any.decode(N, N.uint32());
            break;
          default:
            N.skipType(b & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(U) {
      const w = i();
      return (0, t.isSet)(U.granter) && (w.granter = String(U.granter)), (0, t.isSet)(U.grantee) && (w.grantee = String(U.grantee)), (0, t.isSet)(U.allowance) && (w.allowance = n.Any.fromJSON(U.allowance)), w;
    },
    toJSON(U) {
      const w = {};
      return U.granter !== void 0 && (w.granter = U.granter), U.grantee !== void 0 && (w.grantee = U.grantee), U.allowance !== void 0 && (w.allowance = U.allowance ? n.Any.toJSON(U.allowance) : void 0), w;
    },
    fromPartial(U) {
      const w = i();
      return w.granter = U.granter ?? "", w.grantee = U.grantee ?? "", U.allowance !== void 0 && U.allowance !== null && (w.allowance = n.Any.fromPartial(U.allowance)), w;
    }
  };
  function f() {
    return {};
  }
  e.MsgGrantAllowanceResponse = {
    typeUrl: "/cosmos.feegrant.v1beta1.MsgGrantAllowanceResponse",
    encode(U, w = r.BinaryWriter.create()) {
      return w;
    },
    decode(U, w) {
      const N = U instanceof r.BinaryReader ? U : new r.BinaryReader(U);
      let h = w === void 0 ? N.len : N.pos + w;
      const P = f();
      for (; N.pos < h; ) {
        const b = N.uint32();
        switch (b >>> 3) {
          default:
            N.skipType(b & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(U) {
      return f();
    },
    toJSON(U) {
      return {};
    },
    fromPartial(U) {
      return f();
    }
  };
  function k() {
    return {
      granter: "",
      grantee: ""
    };
  }
  e.MsgRevokeAllowance = {
    typeUrl: "/cosmos.feegrant.v1beta1.MsgRevokeAllowance",
    encode(U, w = r.BinaryWriter.create()) {
      return U.granter !== "" && w.uint32(10).string(U.granter), U.grantee !== "" && w.uint32(18).string(U.grantee), w;
    },
    decode(U, w) {
      const N = U instanceof r.BinaryReader ? U : new r.BinaryReader(U);
      let h = w === void 0 ? N.len : N.pos + w;
      const P = k();
      for (; N.pos < h; ) {
        const b = N.uint32();
        switch (b >>> 3) {
          case 1:
            P.granter = N.string();
            break;
          case 2:
            P.grantee = N.string();
            break;
          default:
            N.skipType(b & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(U) {
      const w = k();
      return (0, t.isSet)(U.granter) && (w.granter = String(U.granter)), (0, t.isSet)(U.grantee) && (w.grantee = String(U.grantee)), w;
    },
    toJSON(U) {
      const w = {};
      return U.granter !== void 0 && (w.granter = U.granter), U.grantee !== void 0 && (w.grantee = U.grantee), w;
    },
    fromPartial(U) {
      const w = k();
      return w.granter = U.granter ?? "", w.grantee = U.grantee ?? "", w;
    }
  };
  function C() {
    return {};
  }
  e.MsgRevokeAllowanceResponse = {
    typeUrl: "/cosmos.feegrant.v1beta1.MsgRevokeAllowanceResponse",
    encode(U, w = r.BinaryWriter.create()) {
      return w;
    },
    decode(U, w) {
      const N = U instanceof r.BinaryReader ? U : new r.BinaryReader(U);
      let h = w === void 0 ? N.len : N.pos + w;
      const P = C();
      for (; N.pos < h; ) {
        const b = N.uint32();
        switch (b >>> 3) {
          default:
            N.skipType(b & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(U) {
      return C();
    },
    toJSON(U) {
      return {};
    },
    fromPartial(U) {
      return C();
    }
  };
  class T {
    constructor(w) {
      this.rpc = w, this.GrantAllowance = this.GrantAllowance.bind(this), this.RevokeAllowance = this.RevokeAllowance.bind(this);
    }
    GrantAllowance(w) {
      const N = e.MsgGrantAllowance.encode(w).finish();
      return this.rpc.request("cosmos.feegrant.v1beta1.Msg", "GrantAllowance", N).then((P) => e.MsgGrantAllowanceResponse.decode(new r.BinaryReader(P)));
    }
    RevokeAllowance(w) {
      const N = e.MsgRevokeAllowance.encode(w).finish();
      return this.rpc.request("cosmos.feegrant.v1beta1.Msg", "RevokeAllowance", N).then((P) => e.MsgRevokeAllowanceResponse.decode(new r.BinaryReader(P)));
    }
  }
  e.MsgClientImpl = T;
})(Xc);
Object.defineProperty(ko, "__esModule", { value: !0 });
ko.feegrantTypes = void 0;
const Tu = Xc;
ko.feegrantTypes = [
  ["/cosmos.feegrant.v1beta1.MsgGrantAllowance", Tu.MsgGrantAllowance],
  ["/cosmos.feegrant.v1beta1.MsgRevokeAllowance", Tu.MsgRevokeAllowance]
];
var Po = {}, jc = {}, el = {}, pn = {};
Object.defineProperty(pn, "__esModule", { value: !0 });
pn.Duration = pn.protobufPackage = void 0;
const ts = re, Cu = ie;
pn.protobufPackage = "google.protobuf";
function rs() {
  return {
    seconds: BigInt(0),
    nanos: 0
  };
}
pn.Duration = {
  typeUrl: "/google.protobuf.Duration",
  encode(e, n = ts.BinaryWriter.create()) {
    return e.seconds !== BigInt(0) && n.uint32(8).int64(e.seconds), e.nanos !== 0 && n.uint32(16).int32(e.nanos), n;
  },
  decode(e, n) {
    const r = e instanceof ts.BinaryReader ? e : new ts.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = rs();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.seconds = r.int64();
          break;
        case 2:
          i.nanos = r.int32();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = rs();
    return (0, Cu.isSet)(e.seconds) && (n.seconds = BigInt(e.seconds.toString())), (0, Cu.isSet)(e.nanos) && (n.nanos = Number(e.nanos)), n;
  },
  toJSON(e) {
    const n = {};
    return e.seconds !== void 0 && (n.seconds = (e.seconds || BigInt(0)).toString()), e.nanos !== void 0 && (n.nanos = Math.round(e.nanos)), n;
  },
  fromPartial(e) {
    const n = rs();
    return e.seconds !== void 0 && e.seconds !== null && (n.seconds = BigInt(e.seconds.toString())), n.nanos = e.nanos ?? 0, n;
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Grant = e.AllowedMsgAllowance = e.PeriodicAllowance = e.BasicAllowance = e.protobufPackage = void 0;
  const n = Le, r = _e, t = pn, i = Be, f = re, k = ie;
  e.protobufPackage = "cosmos.feegrant.v1beta1";
  function C() {
    return {
      spendLimit: [],
      expiration: void 0
    };
  }
  e.BasicAllowance = {
    typeUrl: "/cosmos.feegrant.v1beta1.BasicAllowance",
    encode(N, h = f.BinaryWriter.create()) {
      for (const P of N.spendLimit)
        n.Coin.encode(P, h.uint32(10).fork()).ldelim();
      return N.expiration !== void 0 && r.Timestamp.encode(N.expiration, h.uint32(18).fork()).ldelim(), h;
    },
    decode(N, h) {
      const P = N instanceof f.BinaryReader ? N : new f.BinaryReader(N);
      let b = h === void 0 ? P.len : P.pos + h;
      const c = C();
      for (; P.pos < b; ) {
        const l = P.uint32();
        switch (l >>> 3) {
          case 1:
            c.spendLimit.push(n.Coin.decode(P, P.uint32()));
            break;
          case 2:
            c.expiration = r.Timestamp.decode(P, P.uint32());
            break;
          default:
            P.skipType(l & 7);
            break;
        }
      }
      return c;
    },
    fromJSON(N) {
      const h = C();
      return Array.isArray(N == null ? void 0 : N.spendLimit) && (h.spendLimit = N.spendLimit.map((P) => n.Coin.fromJSON(P))), (0, k.isSet)(N.expiration) && (h.expiration = (0, k.fromJsonTimestamp)(N.expiration)), h;
    },
    toJSON(N) {
      const h = {};
      return N.spendLimit ? h.spendLimit = N.spendLimit.map((P) => P ? n.Coin.toJSON(P) : void 0) : h.spendLimit = [], N.expiration !== void 0 && (h.expiration = (0, k.fromTimestamp)(N.expiration).toISOString()), h;
    },
    fromPartial(N) {
      var P;
      const h = C();
      return h.spendLimit = ((P = N.spendLimit) == null ? void 0 : P.map((b) => n.Coin.fromPartial(b))) || [], N.expiration !== void 0 && N.expiration !== null && (h.expiration = r.Timestamp.fromPartial(N.expiration)), h;
    }
  };
  function T() {
    return {
      basic: e.BasicAllowance.fromPartial({}),
      period: t.Duration.fromPartial({}),
      periodSpendLimit: [],
      periodCanSpend: [],
      periodReset: r.Timestamp.fromPartial({})
    };
  }
  e.PeriodicAllowance = {
    typeUrl: "/cosmos.feegrant.v1beta1.PeriodicAllowance",
    encode(N, h = f.BinaryWriter.create()) {
      N.basic !== void 0 && e.BasicAllowance.encode(N.basic, h.uint32(10).fork()).ldelim(), N.period !== void 0 && t.Duration.encode(N.period, h.uint32(18).fork()).ldelim();
      for (const P of N.periodSpendLimit)
        n.Coin.encode(P, h.uint32(26).fork()).ldelim();
      for (const P of N.periodCanSpend)
        n.Coin.encode(P, h.uint32(34).fork()).ldelim();
      return N.periodReset !== void 0 && r.Timestamp.encode(N.periodReset, h.uint32(42).fork()).ldelim(), h;
    },
    decode(N, h) {
      const P = N instanceof f.BinaryReader ? N : new f.BinaryReader(N);
      let b = h === void 0 ? P.len : P.pos + h;
      const c = T();
      for (; P.pos < b; ) {
        const l = P.uint32();
        switch (l >>> 3) {
          case 1:
            c.basic = e.BasicAllowance.decode(P, P.uint32());
            break;
          case 2:
            c.period = t.Duration.decode(P, P.uint32());
            break;
          case 3:
            c.periodSpendLimit.push(n.Coin.decode(P, P.uint32()));
            break;
          case 4:
            c.periodCanSpend.push(n.Coin.decode(P, P.uint32()));
            break;
          case 5:
            c.periodReset = r.Timestamp.decode(P, P.uint32());
            break;
          default:
            P.skipType(l & 7);
            break;
        }
      }
      return c;
    },
    fromJSON(N) {
      const h = T();
      return (0, k.isSet)(N.basic) && (h.basic = e.BasicAllowance.fromJSON(N.basic)), (0, k.isSet)(N.period) && (h.period = t.Duration.fromJSON(N.period)), Array.isArray(N == null ? void 0 : N.periodSpendLimit) && (h.periodSpendLimit = N.periodSpendLimit.map((P) => n.Coin.fromJSON(P))), Array.isArray(N == null ? void 0 : N.periodCanSpend) && (h.periodCanSpend = N.periodCanSpend.map((P) => n.Coin.fromJSON(P))), (0, k.isSet)(N.periodReset) && (h.periodReset = (0, k.fromJsonTimestamp)(N.periodReset)), h;
    },
    toJSON(N) {
      const h = {};
      return N.basic !== void 0 && (h.basic = N.basic ? e.BasicAllowance.toJSON(N.basic) : void 0), N.period !== void 0 && (h.period = N.period ? t.Duration.toJSON(N.period) : void 0), N.periodSpendLimit ? h.periodSpendLimit = N.periodSpendLimit.map((P) => P ? n.Coin.toJSON(P) : void 0) : h.periodSpendLimit = [], N.periodCanSpend ? h.periodCanSpend = N.periodCanSpend.map((P) => P ? n.Coin.toJSON(P) : void 0) : h.periodCanSpend = [], N.periodReset !== void 0 && (h.periodReset = (0, k.fromTimestamp)(N.periodReset).toISOString()), h;
    },
    fromPartial(N) {
      var P, b;
      const h = T();
      return N.basic !== void 0 && N.basic !== null && (h.basic = e.BasicAllowance.fromPartial(N.basic)), N.period !== void 0 && N.period !== null && (h.period = t.Duration.fromPartial(N.period)), h.periodSpendLimit = ((P = N.periodSpendLimit) == null ? void 0 : P.map((c) => n.Coin.fromPartial(c))) || [], h.periodCanSpend = ((b = N.periodCanSpend) == null ? void 0 : b.map((c) => n.Coin.fromPartial(c))) || [], N.periodReset !== void 0 && N.periodReset !== null && (h.periodReset = r.Timestamp.fromPartial(N.periodReset)), h;
    }
  };
  function U() {
    return {
      allowance: void 0,
      allowedMessages: []
    };
  }
  e.AllowedMsgAllowance = {
    typeUrl: "/cosmos.feegrant.v1beta1.AllowedMsgAllowance",
    encode(N, h = f.BinaryWriter.create()) {
      N.allowance !== void 0 && i.Any.encode(N.allowance, h.uint32(10).fork()).ldelim();
      for (const P of N.allowedMessages)
        h.uint32(18).string(P);
      return h;
    },
    decode(N, h) {
      const P = N instanceof f.BinaryReader ? N : new f.BinaryReader(N);
      let b = h === void 0 ? P.len : P.pos + h;
      const c = U();
      for (; P.pos < b; ) {
        const l = P.uint32();
        switch (l >>> 3) {
          case 1:
            c.allowance = i.Any.decode(P, P.uint32());
            break;
          case 2:
            c.allowedMessages.push(P.string());
            break;
          default:
            P.skipType(l & 7);
            break;
        }
      }
      return c;
    },
    fromJSON(N) {
      const h = U();
      return (0, k.isSet)(N.allowance) && (h.allowance = i.Any.fromJSON(N.allowance)), Array.isArray(N == null ? void 0 : N.allowedMessages) && (h.allowedMessages = N.allowedMessages.map((P) => String(P))), h;
    },
    toJSON(N) {
      const h = {};
      return N.allowance !== void 0 && (h.allowance = N.allowance ? i.Any.toJSON(N.allowance) : void 0), N.allowedMessages ? h.allowedMessages = N.allowedMessages.map((P) => P) : h.allowedMessages = [], h;
    },
    fromPartial(N) {
      var P;
      const h = U();
      return N.allowance !== void 0 && N.allowance !== null && (h.allowance = i.Any.fromPartial(N.allowance)), h.allowedMessages = ((P = N.allowedMessages) == null ? void 0 : P.map((b) => b)) || [], h;
    }
  };
  function w() {
    return {
      granter: "",
      grantee: "",
      allowance: void 0
    };
  }
  e.Grant = {
    typeUrl: "/cosmos.feegrant.v1beta1.Grant",
    encode(N, h = f.BinaryWriter.create()) {
      return N.granter !== "" && h.uint32(10).string(N.granter), N.grantee !== "" && h.uint32(18).string(N.grantee), N.allowance !== void 0 && i.Any.encode(N.allowance, h.uint32(26).fork()).ldelim(), h;
    },
    decode(N, h) {
      const P = N instanceof f.BinaryReader ? N : new f.BinaryReader(N);
      let b = h === void 0 ? P.len : P.pos + h;
      const c = w();
      for (; P.pos < b; ) {
        const l = P.uint32();
        switch (l >>> 3) {
          case 1:
            c.granter = P.string();
            break;
          case 2:
            c.grantee = P.string();
            break;
          case 3:
            c.allowance = i.Any.decode(P, P.uint32());
            break;
          default:
            P.skipType(l & 7);
            break;
        }
      }
      return c;
    },
    fromJSON(N) {
      const h = w();
      return (0, k.isSet)(N.granter) && (h.granter = String(N.granter)), (0, k.isSet)(N.grantee) && (h.grantee = String(N.grantee)), (0, k.isSet)(N.allowance) && (h.allowance = i.Any.fromJSON(N.allowance)), h;
    },
    toJSON(N) {
      const h = {};
      return N.granter !== void 0 && (h.granter = N.granter), N.grantee !== void 0 && (h.grantee = N.grantee), N.allowance !== void 0 && (h.allowance = N.allowance ? i.Any.toJSON(N.allowance) : void 0), h;
    },
    fromPartial(N) {
      const h = w();
      return h.granter = N.granter ?? "", h.grantee = N.grantee ?? "", N.allowance !== void 0 && N.allowance !== null && (h.allowance = i.Any.fromPartial(N.allowance)), h;
    }
  };
})(el);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryAllowancesByGranterResponse = e.QueryAllowancesByGranterRequest = e.QueryAllowancesResponse = e.QueryAllowancesRequest = e.QueryAllowanceResponse = e.QueryAllowanceRequest = e.protobufPackage = void 0;
  const n = Ae, r = el, t = re, i = ie;
  e.protobufPackage = "cosmos.feegrant.v1beta1";
  function f() {
    return {
      granter: "",
      grantee: ""
    };
  }
  e.QueryAllowanceRequest = {
    typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowanceRequest",
    encode(h, P = t.BinaryWriter.create()) {
      return h.granter !== "" && P.uint32(10).string(h.granter), h.grantee !== "" && P.uint32(18).string(h.grantee), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = f();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.granter = b.string();
            break;
          case 2:
            l.grantee = b.string();
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = f();
      return (0, i.isSet)(h.granter) && (P.granter = String(h.granter)), (0, i.isSet)(h.grantee) && (P.grantee = String(h.grantee)), P;
    },
    toJSON(h) {
      const P = {};
      return h.granter !== void 0 && (P.granter = h.granter), h.grantee !== void 0 && (P.grantee = h.grantee), P;
    },
    fromPartial(h) {
      const P = f();
      return P.granter = h.granter ?? "", P.grantee = h.grantee ?? "", P;
    }
  };
  function k() {
    return {
      allowance: void 0
    };
  }
  e.QueryAllowanceResponse = {
    typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowanceResponse",
    encode(h, P = t.BinaryWriter.create()) {
      return h.allowance !== void 0 && r.Grant.encode(h.allowance, P.uint32(10).fork()).ldelim(), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = k();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.allowance = r.Grant.decode(b, b.uint32());
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = k();
      return (0, i.isSet)(h.allowance) && (P.allowance = r.Grant.fromJSON(h.allowance)), P;
    },
    toJSON(h) {
      const P = {};
      return h.allowance !== void 0 && (P.allowance = h.allowance ? r.Grant.toJSON(h.allowance) : void 0), P;
    },
    fromPartial(h) {
      const P = k();
      return h.allowance !== void 0 && h.allowance !== null && (P.allowance = r.Grant.fromPartial(h.allowance)), P;
    }
  };
  function C() {
    return {
      grantee: "",
      pagination: void 0
    };
  }
  e.QueryAllowancesRequest = {
    typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesRequest",
    encode(h, P = t.BinaryWriter.create()) {
      return h.grantee !== "" && P.uint32(10).string(h.grantee), h.pagination !== void 0 && n.PageRequest.encode(h.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = C();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.grantee = b.string();
            break;
          case 2:
            l.pagination = n.PageRequest.decode(b, b.uint32());
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = C();
      return (0, i.isSet)(h.grantee) && (P.grantee = String(h.grantee)), (0, i.isSet)(h.pagination) && (P.pagination = n.PageRequest.fromJSON(h.pagination)), P;
    },
    toJSON(h) {
      const P = {};
      return h.grantee !== void 0 && (P.grantee = h.grantee), h.pagination !== void 0 && (P.pagination = h.pagination ? n.PageRequest.toJSON(h.pagination) : void 0), P;
    },
    fromPartial(h) {
      const P = C();
      return P.grantee = h.grantee ?? "", h.pagination !== void 0 && h.pagination !== null && (P.pagination = n.PageRequest.fromPartial(h.pagination)), P;
    }
  };
  function T() {
    return {
      allowances: [],
      pagination: void 0
    };
  }
  e.QueryAllowancesResponse = {
    typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesResponse",
    encode(h, P = t.BinaryWriter.create()) {
      for (const b of h.allowances)
        r.Grant.encode(b, P.uint32(10).fork()).ldelim();
      return h.pagination !== void 0 && n.PageResponse.encode(h.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = T();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.allowances.push(r.Grant.decode(b, b.uint32()));
            break;
          case 2:
            l.pagination = n.PageResponse.decode(b, b.uint32());
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = T();
      return Array.isArray(h == null ? void 0 : h.allowances) && (P.allowances = h.allowances.map((b) => r.Grant.fromJSON(b))), (0, i.isSet)(h.pagination) && (P.pagination = n.PageResponse.fromJSON(h.pagination)), P;
    },
    toJSON(h) {
      const P = {};
      return h.allowances ? P.allowances = h.allowances.map((b) => b ? r.Grant.toJSON(b) : void 0) : P.allowances = [], h.pagination !== void 0 && (P.pagination = h.pagination ? n.PageResponse.toJSON(h.pagination) : void 0), P;
    },
    fromPartial(h) {
      var b;
      const P = T();
      return P.allowances = ((b = h.allowances) == null ? void 0 : b.map((c) => r.Grant.fromPartial(c))) || [], h.pagination !== void 0 && h.pagination !== null && (P.pagination = n.PageResponse.fromPartial(h.pagination)), P;
    }
  };
  function U() {
    return {
      granter: "",
      pagination: void 0
    };
  }
  e.QueryAllowancesByGranterRequest = {
    typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesByGranterRequest",
    encode(h, P = t.BinaryWriter.create()) {
      return h.granter !== "" && P.uint32(10).string(h.granter), h.pagination !== void 0 && n.PageRequest.encode(h.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = U();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.granter = b.string();
            break;
          case 2:
            l.pagination = n.PageRequest.decode(b, b.uint32());
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = U();
      return (0, i.isSet)(h.granter) && (P.granter = String(h.granter)), (0, i.isSet)(h.pagination) && (P.pagination = n.PageRequest.fromJSON(h.pagination)), P;
    },
    toJSON(h) {
      const P = {};
      return h.granter !== void 0 && (P.granter = h.granter), h.pagination !== void 0 && (P.pagination = h.pagination ? n.PageRequest.toJSON(h.pagination) : void 0), P;
    },
    fromPartial(h) {
      const P = U();
      return P.granter = h.granter ?? "", h.pagination !== void 0 && h.pagination !== null && (P.pagination = n.PageRequest.fromPartial(h.pagination)), P;
    }
  };
  function w() {
    return {
      allowances: [],
      pagination: void 0
    };
  }
  e.QueryAllowancesByGranterResponse = {
    typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesByGranterResponse",
    encode(h, P = t.BinaryWriter.create()) {
      for (const b of h.allowances)
        r.Grant.encode(b, P.uint32(10).fork()).ldelim();
      return h.pagination !== void 0 && n.PageResponse.encode(h.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = w();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.allowances.push(r.Grant.decode(b, b.uint32()));
            break;
          case 2:
            l.pagination = n.PageResponse.decode(b, b.uint32());
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = w();
      return Array.isArray(h == null ? void 0 : h.allowances) && (P.allowances = h.allowances.map((b) => r.Grant.fromJSON(b))), (0, i.isSet)(h.pagination) && (P.pagination = n.PageResponse.fromJSON(h.pagination)), P;
    },
    toJSON(h) {
      const P = {};
      return h.allowances ? P.allowances = h.allowances.map((b) => b ? r.Grant.toJSON(b) : void 0) : P.allowances = [], h.pagination !== void 0 && (P.pagination = h.pagination ? n.PageResponse.toJSON(h.pagination) : void 0), P;
    },
    fromPartial(h) {
      var b;
      const P = w();
      return P.allowances = ((b = h.allowances) == null ? void 0 : b.map((c) => r.Grant.fromPartial(c))) || [], h.pagination !== void 0 && h.pagination !== null && (P.pagination = n.PageResponse.fromPartial(h.pagination)), P;
    }
  };
  class N {
    constructor(P) {
      this.rpc = P, this.Allowance = this.Allowance.bind(this), this.Allowances = this.Allowances.bind(this), this.AllowancesByGranter = this.AllowancesByGranter.bind(this);
    }
    Allowance(P) {
      const b = e.QueryAllowanceRequest.encode(P).finish();
      return this.rpc.request("cosmos.feegrant.v1beta1.Query", "Allowance", b).then((l) => e.QueryAllowanceResponse.decode(new t.BinaryReader(l)));
    }
    Allowances(P) {
      const b = e.QueryAllowancesRequest.encode(P).finish();
      return this.rpc.request("cosmos.feegrant.v1beta1.Query", "Allowances", b).then((l) => e.QueryAllowancesResponse.decode(new t.BinaryReader(l)));
    }
    AllowancesByGranter(P) {
      const b = e.QueryAllowancesByGranterRequest.encode(P).finish();
      return this.rpc.request("cosmos.feegrant.v1beta1.Query", "AllowancesByGranter", b).then((l) => e.QueryAllowancesByGranterResponse.decode(new t.BinaryReader(l)));
    }
  }
  e.QueryClientImpl = N;
})(jc);
Object.defineProperty(Po, "__esModule", { value: !0 });
Po.setupFeegrantExtension = void 0;
const ym = jc, Nu = Ge;
function mm(e) {
  const n = (0, Nu.createProtobufRpcClient)(e), r = new ym.QueryClientImpl(n);
  return {
    feegrant: {
      allowance: async (t, i) => await r.Allowance({
        granter: t,
        grantee: i
      }),
      allowances: async (t, i) => await r.Allowances({
        grantee: t,
        pagination: (0, Nu.createPagination)(i)
      })
    }
  };
}
Po.setupFeegrantExtension = mm;
var mn = {}, vo = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.TallyParams = e.VotingParams = e.DepositParams = e.Vote = e.TallyResult = e.Proposal = e.Deposit = e.TextProposal = e.WeightedVoteOption = e.proposalStatusToJSON = e.proposalStatusFromJSON = e.ProposalStatus = e.voteOptionToJSON = e.voteOptionFromJSON = e.VoteOption = e.protobufPackage = void 0;
  const n = Le, r = Be, t = _e, i = pn, f = re, k = ie;
  e.protobufPackage = "cosmos.gov.v1beta1";
  var C;
  (function(o) {
    o[o.VOTE_OPTION_UNSPECIFIED = 0] = "VOTE_OPTION_UNSPECIFIED", o[o.VOTE_OPTION_YES = 1] = "VOTE_OPTION_YES", o[o.VOTE_OPTION_ABSTAIN = 2] = "VOTE_OPTION_ABSTAIN", o[o.VOTE_OPTION_NO = 3] = "VOTE_OPTION_NO", o[o.VOTE_OPTION_NO_WITH_VETO = 4] = "VOTE_OPTION_NO_WITH_VETO", o[o.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(C || (e.VoteOption = C = {}));
  function T(o) {
    switch (o) {
      case 0:
      case "VOTE_OPTION_UNSPECIFIED":
        return C.VOTE_OPTION_UNSPECIFIED;
      case 1:
      case "VOTE_OPTION_YES":
        return C.VOTE_OPTION_YES;
      case 2:
      case "VOTE_OPTION_ABSTAIN":
        return C.VOTE_OPTION_ABSTAIN;
      case 3:
      case "VOTE_OPTION_NO":
        return C.VOTE_OPTION_NO;
      case 4:
      case "VOTE_OPTION_NO_WITH_VETO":
        return C.VOTE_OPTION_NO_WITH_VETO;
      case -1:
      case "UNRECOGNIZED":
      default:
        return C.UNRECOGNIZED;
    }
  }
  e.voteOptionFromJSON = T;
  function U(o) {
    switch (o) {
      case C.VOTE_OPTION_UNSPECIFIED:
        return "VOTE_OPTION_UNSPECIFIED";
      case C.VOTE_OPTION_YES:
        return "VOTE_OPTION_YES";
      case C.VOTE_OPTION_ABSTAIN:
        return "VOTE_OPTION_ABSTAIN";
      case C.VOTE_OPTION_NO:
        return "VOTE_OPTION_NO";
      case C.VOTE_OPTION_NO_WITH_VETO:
        return "VOTE_OPTION_NO_WITH_VETO";
      case C.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.voteOptionToJSON = U;
  var w;
  (function(o) {
    o[o.PROPOSAL_STATUS_UNSPECIFIED = 0] = "PROPOSAL_STATUS_UNSPECIFIED", o[o.PROPOSAL_STATUS_DEPOSIT_PERIOD = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD", o[o.PROPOSAL_STATUS_VOTING_PERIOD = 2] = "PROPOSAL_STATUS_VOTING_PERIOD", o[o.PROPOSAL_STATUS_PASSED = 3] = "PROPOSAL_STATUS_PASSED", o[o.PROPOSAL_STATUS_REJECTED = 4] = "PROPOSAL_STATUS_REJECTED", o[o.PROPOSAL_STATUS_FAILED = 5] = "PROPOSAL_STATUS_FAILED", o[o.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(w || (e.ProposalStatus = w = {}));
  function N(o) {
    switch (o) {
      case 0:
      case "PROPOSAL_STATUS_UNSPECIFIED":
        return w.PROPOSAL_STATUS_UNSPECIFIED;
      case 1:
      case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
        return w.PROPOSAL_STATUS_DEPOSIT_PERIOD;
      case 2:
      case "PROPOSAL_STATUS_VOTING_PERIOD":
        return w.PROPOSAL_STATUS_VOTING_PERIOD;
      case 3:
      case "PROPOSAL_STATUS_PASSED":
        return w.PROPOSAL_STATUS_PASSED;
      case 4:
      case "PROPOSAL_STATUS_REJECTED":
        return w.PROPOSAL_STATUS_REJECTED;
      case 5:
      case "PROPOSAL_STATUS_FAILED":
        return w.PROPOSAL_STATUS_FAILED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return w.UNRECOGNIZED;
    }
  }
  e.proposalStatusFromJSON = N;
  function h(o) {
    switch (o) {
      case w.PROPOSAL_STATUS_UNSPECIFIED:
        return "PROPOSAL_STATUS_UNSPECIFIED";
      case w.PROPOSAL_STATUS_DEPOSIT_PERIOD:
        return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
      case w.PROPOSAL_STATUS_VOTING_PERIOD:
        return "PROPOSAL_STATUS_VOTING_PERIOD";
      case w.PROPOSAL_STATUS_PASSED:
        return "PROPOSAL_STATUS_PASSED";
      case w.PROPOSAL_STATUS_REJECTED:
        return "PROPOSAL_STATUS_REJECTED";
      case w.PROPOSAL_STATUS_FAILED:
        return "PROPOSAL_STATUS_FAILED";
      case w.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.proposalStatusToJSON = h;
  function P() {
    return {
      option: 0,
      weight: ""
    };
  }
  e.WeightedVoteOption = {
    typeUrl: "/cosmos.gov.v1beta1.WeightedVoteOption",
    encode(o, p = f.BinaryWriter.create()) {
      return o.option !== 0 && p.uint32(8).int32(o.option), o.weight !== "" && p.uint32(18).string(o.weight), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = P();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.option = I.int32();
            break;
          case 2:
            s.weight = I.string();
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = P();
      return (0, k.isSet)(o.option) && (p.option = T(o.option)), (0, k.isSet)(o.weight) && (p.weight = String(o.weight)), p;
    },
    toJSON(o) {
      const p = {};
      return o.option !== void 0 && (p.option = U(o.option)), o.weight !== void 0 && (p.weight = o.weight), p;
    },
    fromPartial(o) {
      const p = P();
      return p.option = o.option ?? 0, p.weight = o.weight ?? "", p;
    }
  };
  function b() {
    return {
      title: "",
      description: ""
    };
  }
  e.TextProposal = {
    typeUrl: "/cosmos.gov.v1beta1.TextProposal",
    encode(o, p = f.BinaryWriter.create()) {
      return o.title !== "" && p.uint32(10).string(o.title), o.description !== "" && p.uint32(18).string(o.description), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = b();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.title = I.string();
            break;
          case 2:
            s.description = I.string();
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = b();
      return (0, k.isSet)(o.title) && (p.title = String(o.title)), (0, k.isSet)(o.description) && (p.description = String(o.description)), p;
    },
    toJSON(o) {
      const p = {};
      return o.title !== void 0 && (p.title = o.title), o.description !== void 0 && (p.description = o.description), p;
    },
    fromPartial(o) {
      const p = b();
      return p.title = o.title ?? "", p.description = o.description ?? "", p;
    }
  };
  function c() {
    return {
      proposalId: BigInt(0),
      depositor: "",
      amount: []
    };
  }
  e.Deposit = {
    typeUrl: "/cosmos.gov.v1beta1.Deposit",
    encode(o, p = f.BinaryWriter.create()) {
      o.proposalId !== BigInt(0) && p.uint32(8).uint64(o.proposalId), o.depositor !== "" && p.uint32(18).string(o.depositor);
      for (const I of o.amount)
        n.Coin.encode(I, p.uint32(26).fork()).ldelim();
      return p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = c();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.proposalId = I.uint64();
            break;
          case 2:
            s.depositor = I.string();
            break;
          case 3:
            s.amount.push(n.Coin.decode(I, I.uint32()));
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = c();
      return (0, k.isSet)(o.proposalId) && (p.proposalId = BigInt(o.proposalId.toString())), (0, k.isSet)(o.depositor) && (p.depositor = String(o.depositor)), Array.isArray(o == null ? void 0 : o.amount) && (p.amount = o.amount.map((I) => n.Coin.fromJSON(I))), p;
    },
    toJSON(o) {
      const p = {};
      return o.proposalId !== void 0 && (p.proposalId = (o.proposalId || BigInt(0)).toString()), o.depositor !== void 0 && (p.depositor = o.depositor), o.amount ? p.amount = o.amount.map((I) => I ? n.Coin.toJSON(I) : void 0) : p.amount = [], p;
    },
    fromPartial(o) {
      var I;
      const p = c();
      return o.proposalId !== void 0 && o.proposalId !== null && (p.proposalId = BigInt(o.proposalId.toString())), p.depositor = o.depositor ?? "", p.amount = ((I = o.amount) == null ? void 0 : I.map((q) => n.Coin.fromPartial(q))) || [], p;
    }
  };
  function l() {
    return {
      proposalId: BigInt(0),
      content: void 0,
      status: 0,
      finalTallyResult: e.TallyResult.fromPartial({}),
      submitTime: t.Timestamp.fromPartial({}),
      depositEndTime: t.Timestamp.fromPartial({}),
      totalDeposit: [],
      votingStartTime: t.Timestamp.fromPartial({}),
      votingEndTime: t.Timestamp.fromPartial({})
    };
  }
  e.Proposal = {
    typeUrl: "/cosmos.gov.v1beta1.Proposal",
    encode(o, p = f.BinaryWriter.create()) {
      o.proposalId !== BigInt(0) && p.uint32(8).uint64(o.proposalId), o.content !== void 0 && r.Any.encode(o.content, p.uint32(18).fork()).ldelim(), o.status !== 0 && p.uint32(24).int32(o.status), o.finalTallyResult !== void 0 && e.TallyResult.encode(o.finalTallyResult, p.uint32(34).fork()).ldelim(), o.submitTime !== void 0 && t.Timestamp.encode(o.submitTime, p.uint32(42).fork()).ldelim(), o.depositEndTime !== void 0 && t.Timestamp.encode(o.depositEndTime, p.uint32(50).fork()).ldelim();
      for (const I of o.totalDeposit)
        n.Coin.encode(I, p.uint32(58).fork()).ldelim();
      return o.votingStartTime !== void 0 && t.Timestamp.encode(o.votingStartTime, p.uint32(66).fork()).ldelim(), o.votingEndTime !== void 0 && t.Timestamp.encode(o.votingEndTime, p.uint32(74).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = l();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.proposalId = I.uint64();
            break;
          case 2:
            s.content = r.Any.decode(I, I.uint32());
            break;
          case 3:
            s.status = I.int32();
            break;
          case 4:
            s.finalTallyResult = e.TallyResult.decode(I, I.uint32());
            break;
          case 5:
            s.submitTime = t.Timestamp.decode(I, I.uint32());
            break;
          case 6:
            s.depositEndTime = t.Timestamp.decode(I, I.uint32());
            break;
          case 7:
            s.totalDeposit.push(n.Coin.decode(I, I.uint32()));
            break;
          case 8:
            s.votingStartTime = t.Timestamp.decode(I, I.uint32());
            break;
          case 9:
            s.votingEndTime = t.Timestamp.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = l();
      return (0, k.isSet)(o.proposalId) && (p.proposalId = BigInt(o.proposalId.toString())), (0, k.isSet)(o.content) && (p.content = r.Any.fromJSON(o.content)), (0, k.isSet)(o.status) && (p.status = N(o.status)), (0, k.isSet)(o.finalTallyResult) && (p.finalTallyResult = e.TallyResult.fromJSON(o.finalTallyResult)), (0, k.isSet)(o.submitTime) && (p.submitTime = (0, k.fromJsonTimestamp)(o.submitTime)), (0, k.isSet)(o.depositEndTime) && (p.depositEndTime = (0, k.fromJsonTimestamp)(o.depositEndTime)), Array.isArray(o == null ? void 0 : o.totalDeposit) && (p.totalDeposit = o.totalDeposit.map((I) => n.Coin.fromJSON(I))), (0, k.isSet)(o.votingStartTime) && (p.votingStartTime = (0, k.fromJsonTimestamp)(o.votingStartTime)), (0, k.isSet)(o.votingEndTime) && (p.votingEndTime = (0, k.fromJsonTimestamp)(o.votingEndTime)), p;
    },
    toJSON(o) {
      const p = {};
      return o.proposalId !== void 0 && (p.proposalId = (o.proposalId || BigInt(0)).toString()), o.content !== void 0 && (p.content = o.content ? r.Any.toJSON(o.content) : void 0), o.status !== void 0 && (p.status = h(o.status)), o.finalTallyResult !== void 0 && (p.finalTallyResult = o.finalTallyResult ? e.TallyResult.toJSON(o.finalTallyResult) : void 0), o.submitTime !== void 0 && (p.submitTime = (0, k.fromTimestamp)(o.submitTime).toISOString()), o.depositEndTime !== void 0 && (p.depositEndTime = (0, k.fromTimestamp)(o.depositEndTime).toISOString()), o.totalDeposit ? p.totalDeposit = o.totalDeposit.map((I) => I ? n.Coin.toJSON(I) : void 0) : p.totalDeposit = [], o.votingStartTime !== void 0 && (p.votingStartTime = (0, k.fromTimestamp)(o.votingStartTime).toISOString()), o.votingEndTime !== void 0 && (p.votingEndTime = (0, k.fromTimestamp)(o.votingEndTime).toISOString()), p;
    },
    fromPartial(o) {
      var I;
      const p = l();
      return o.proposalId !== void 0 && o.proposalId !== null && (p.proposalId = BigInt(o.proposalId.toString())), o.content !== void 0 && o.content !== null && (p.content = r.Any.fromPartial(o.content)), p.status = o.status ?? 0, o.finalTallyResult !== void 0 && o.finalTallyResult !== null && (p.finalTallyResult = e.TallyResult.fromPartial(o.finalTallyResult)), o.submitTime !== void 0 && o.submitTime !== null && (p.submitTime = t.Timestamp.fromPartial(o.submitTime)), o.depositEndTime !== void 0 && o.depositEndTime !== null && (p.depositEndTime = t.Timestamp.fromPartial(o.depositEndTime)), p.totalDeposit = ((I = o.totalDeposit) == null ? void 0 : I.map((q) => n.Coin.fromPartial(q))) || [], o.votingStartTime !== void 0 && o.votingStartTime !== null && (p.votingStartTime = t.Timestamp.fromPartial(o.votingStartTime)), o.votingEndTime !== void 0 && o.votingEndTime !== null && (p.votingEndTime = t.Timestamp.fromPartial(o.votingEndTime)), p;
    }
  };
  function y() {
    return {
      yes: "",
      abstain: "",
      no: "",
      noWithVeto: ""
    };
  }
  e.TallyResult = {
    typeUrl: "/cosmos.gov.v1beta1.TallyResult",
    encode(o, p = f.BinaryWriter.create()) {
      return o.yes !== "" && p.uint32(10).string(o.yes), o.abstain !== "" && p.uint32(18).string(o.abstain), o.no !== "" && p.uint32(26).string(o.no), o.noWithVeto !== "" && p.uint32(34).string(o.noWithVeto), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = y();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.yes = I.string();
            break;
          case 2:
            s.abstain = I.string();
            break;
          case 3:
            s.no = I.string();
            break;
          case 4:
            s.noWithVeto = I.string();
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = y();
      return (0, k.isSet)(o.yes) && (p.yes = String(o.yes)), (0, k.isSet)(o.abstain) && (p.abstain = String(o.abstain)), (0, k.isSet)(o.no) && (p.no = String(o.no)), (0, k.isSet)(o.noWithVeto) && (p.noWithVeto = String(o.noWithVeto)), p;
    },
    toJSON(o) {
      const p = {};
      return o.yes !== void 0 && (p.yes = o.yes), o.abstain !== void 0 && (p.abstain = o.abstain), o.no !== void 0 && (p.no = o.no), o.noWithVeto !== void 0 && (p.noWithVeto = o.noWithVeto), p;
    },
    fromPartial(o) {
      const p = y();
      return p.yes = o.yes ?? "", p.abstain = o.abstain ?? "", p.no = o.no ?? "", p.noWithVeto = o.noWithVeto ?? "", p;
    }
  };
  function E() {
    return {
      proposalId: BigInt(0),
      voter: "",
      option: 0,
      options: []
    };
  }
  e.Vote = {
    typeUrl: "/cosmos.gov.v1beta1.Vote",
    encode(o, p = f.BinaryWriter.create()) {
      o.proposalId !== BigInt(0) && p.uint32(8).uint64(o.proposalId), o.voter !== "" && p.uint32(18).string(o.voter), o.option !== 0 && p.uint32(24).int32(o.option);
      for (const I of o.options)
        e.WeightedVoteOption.encode(I, p.uint32(34).fork()).ldelim();
      return p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = E();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.proposalId = I.uint64();
            break;
          case 2:
            s.voter = I.string();
            break;
          case 3:
            s.option = I.int32();
            break;
          case 4:
            s.options.push(e.WeightedVoteOption.decode(I, I.uint32()));
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = E();
      return (0, k.isSet)(o.proposalId) && (p.proposalId = BigInt(o.proposalId.toString())), (0, k.isSet)(o.voter) && (p.voter = String(o.voter)), (0, k.isSet)(o.option) && (p.option = T(o.option)), Array.isArray(o == null ? void 0 : o.options) && (p.options = o.options.map((I) => e.WeightedVoteOption.fromJSON(I))), p;
    },
    toJSON(o) {
      const p = {};
      return o.proposalId !== void 0 && (p.proposalId = (o.proposalId || BigInt(0)).toString()), o.voter !== void 0 && (p.voter = o.voter), o.option !== void 0 && (p.option = U(o.option)), o.options ? p.options = o.options.map((I) => I ? e.WeightedVoteOption.toJSON(I) : void 0) : p.options = [], p;
    },
    fromPartial(o) {
      var I;
      const p = E();
      return o.proposalId !== void 0 && o.proposalId !== null && (p.proposalId = BigInt(o.proposalId.toString())), p.voter = o.voter ?? "", p.option = o.option ?? 0, p.options = ((I = o.options) == null ? void 0 : I.map((q) => e.WeightedVoteOption.fromPartial(q))) || [], p;
    }
  };
  function J() {
    return {
      minDeposit: [],
      maxDepositPeriod: i.Duration.fromPartial({})
    };
  }
  e.DepositParams = {
    typeUrl: "/cosmos.gov.v1beta1.DepositParams",
    encode(o, p = f.BinaryWriter.create()) {
      for (const I of o.minDeposit)
        n.Coin.encode(I, p.uint32(10).fork()).ldelim();
      return o.maxDepositPeriod !== void 0 && i.Duration.encode(o.maxDepositPeriod, p.uint32(18).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = J();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.minDeposit.push(n.Coin.decode(I, I.uint32()));
            break;
          case 2:
            s.maxDepositPeriod = i.Duration.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = J();
      return Array.isArray(o == null ? void 0 : o.minDeposit) && (p.minDeposit = o.minDeposit.map((I) => n.Coin.fromJSON(I))), (0, k.isSet)(o.maxDepositPeriod) && (p.maxDepositPeriod = i.Duration.fromJSON(o.maxDepositPeriod)), p;
    },
    toJSON(o) {
      const p = {};
      return o.minDeposit ? p.minDeposit = o.minDeposit.map((I) => I ? n.Coin.toJSON(I) : void 0) : p.minDeposit = [], o.maxDepositPeriod !== void 0 && (p.maxDepositPeriod = o.maxDepositPeriod ? i.Duration.toJSON(o.maxDepositPeriod) : void 0), p;
    },
    fromPartial(o) {
      var I;
      const p = J();
      return p.minDeposit = ((I = o.minDeposit) == null ? void 0 : I.map((q) => n.Coin.fromPartial(q))) || [], o.maxDepositPeriod !== void 0 && o.maxDepositPeriod !== null && (p.maxDepositPeriod = i.Duration.fromPartial(o.maxDepositPeriod)), p;
    }
  };
  function _() {
    return {
      votingPeriod: i.Duration.fromPartial({})
    };
  }
  e.VotingParams = {
    typeUrl: "/cosmos.gov.v1beta1.VotingParams",
    encode(o, p = f.BinaryWriter.create()) {
      return o.votingPeriod !== void 0 && i.Duration.encode(o.votingPeriod, p.uint32(10).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = _();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.votingPeriod = i.Duration.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = _();
      return (0, k.isSet)(o.votingPeriod) && (p.votingPeriod = i.Duration.fromJSON(o.votingPeriod)), p;
    },
    toJSON(o) {
      const p = {};
      return o.votingPeriod !== void 0 && (p.votingPeriod = o.votingPeriod ? i.Duration.toJSON(o.votingPeriod) : void 0), p;
    },
    fromPartial(o) {
      const p = _();
      return o.votingPeriod !== void 0 && o.votingPeriod !== null && (p.votingPeriod = i.Duration.fromPartial(o.votingPeriod)), p;
    }
  };
  function V() {
    return {
      quorum: new Uint8Array(),
      threshold: new Uint8Array(),
      vetoThreshold: new Uint8Array()
    };
  }
  e.TallyParams = {
    typeUrl: "/cosmos.gov.v1beta1.TallyParams",
    encode(o, p = f.BinaryWriter.create()) {
      return o.quorum.length !== 0 && p.uint32(10).bytes(o.quorum), o.threshold.length !== 0 && p.uint32(18).bytes(o.threshold), o.vetoThreshold.length !== 0 && p.uint32(26).bytes(o.vetoThreshold), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = V();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.quorum = I.bytes();
            break;
          case 2:
            s.threshold = I.bytes();
            break;
          case 3:
            s.vetoThreshold = I.bytes();
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = V();
      return (0, k.isSet)(o.quorum) && (p.quorum = (0, k.bytesFromBase64)(o.quorum)), (0, k.isSet)(o.threshold) && (p.threshold = (0, k.bytesFromBase64)(o.threshold)), (0, k.isSet)(o.vetoThreshold) && (p.vetoThreshold = (0, k.bytesFromBase64)(o.vetoThreshold)), p;
    },
    toJSON(o) {
      const p = {};
      return o.quorum !== void 0 && (p.quorum = (0, k.base64FromBytes)(o.quorum !== void 0 ? o.quorum : new Uint8Array())), o.threshold !== void 0 && (p.threshold = (0, k.base64FromBytes)(o.threshold !== void 0 ? o.threshold : new Uint8Array())), o.vetoThreshold !== void 0 && (p.vetoThreshold = (0, k.base64FromBytes)(o.vetoThreshold !== void 0 ? o.vetoThreshold : new Uint8Array())), p;
    },
    fromPartial(o) {
      const p = V();
      return p.quorum = o.quorum ?? new Uint8Array(), p.threshold = o.threshold ?? new Uint8Array(), p.vetoThreshold = o.vetoThreshold ?? new Uint8Array(), p;
    }
  };
})(vo);
Object.defineProperty(mn, "__esModule", { value: !0 });
mn.createGovAminoConverters = mn.isAminoMsgDeposit = mn.isAminoMsgVoteWeighted = mn.isAminoMsgVote = mn.isAminoMsgSubmitProposal = void 0;
const gm = mt, Cr = an, Nr = vo, Sm = Be, km = Ge;
function Pm(e) {
  return e.type === "cosmos-sdk/MsgSubmitProposal";
}
mn.isAminoMsgSubmitProposal = Pm;
function vm(e) {
  return e.type === "cosmos-sdk/MsgVote";
}
mn.isAminoMsgVote = vm;
function Rm(e) {
  return e.type === "cosmos-sdk/MsgVoteWeighted";
}
mn.isAminoMsgVoteWeighted = Rm;
function Bm(e) {
  return e.type === "cosmos-sdk/MsgDeposit";
}
mn.isAminoMsgDeposit = Bm;
function Om() {
  return {
    "/cosmos.gov.v1beta1.MsgDeposit": {
      aminoType: "cosmos-sdk/MsgDeposit",
      toAmino: ({ amount: e, depositor: n, proposalId: r }) => ({
        amount: e,
        depositor: n,
        proposal_id: r.toString()
      }),
      fromAmino: ({ amount: e, depositor: n, proposal_id: r }) => ({
        amount: Array.from(e),
        depositor: n,
        proposalId: BigInt(r)
      })
    },
    "/cosmos.gov.v1beta1.MsgVote": {
      aminoType: "cosmos-sdk/MsgVote",
      toAmino: ({ option: e, proposalId: n, voter: r }) => ({
        option: e,
        proposal_id: n.toString(),
        voter: r
      }),
      fromAmino: ({ option: e, proposal_id: n, voter: r }) => ({
        option: (0, Nr.voteOptionFromJSON)(e),
        proposalId: BigInt(n),
        voter: r
      })
    },
    "/cosmos.gov.v1beta1.MsgVoteWeighted": {
      aminoType: "cosmos-sdk/MsgVoteWeighted",
      toAmino: ({ options: e, proposalId: n, voter: r }) => ({
        options: e.map((t) => ({
          option: t.option,
          // Weight is between 0 and 1, so we always have 20 characters when printing all trailing
          // zeros (e.g. "0.700000000000000000" or "1.000000000000000000")
          weight: (0, km.decodeCosmosSdkDecFromProto)(t.weight).toString().padEnd(20, "0")
        })),
        proposal_id: n.toString(),
        voter: r
      }),
      fromAmino: ({ options: e, proposal_id: n, voter: r }) => ({
        proposalId: BigInt(n),
        voter: r,
        options: e.map((t) => ({
          option: (0, Nr.voteOptionFromJSON)(t.option),
          weight: gm.Decimal.fromUserInput(t.weight, 18).atomics
        }))
      })
    },
    "/cosmos.gov.v1beta1.MsgSubmitProposal": {
      aminoType: "cosmos-sdk/MsgSubmitProposal",
      toAmino: ({ initialDeposit: e, proposer: n, content: r }) => {
        (0, Cr.assertDefinedAndNotNull)(r);
        let t;
        switch (r.typeUrl) {
          case "/cosmos.gov.v1beta1.TextProposal": {
            const i = Nr.TextProposal.decode(r.value);
            t = {
              type: "cosmos-sdk/TextProposal",
              value: {
                description: i.description,
                title: i.title
              }
            };
            break;
          }
          default:
            throw new Error(`Unsupported proposal type: '${r.typeUrl}'`);
        }
        return {
          initial_deposit: e,
          proposer: n,
          content: t
        };
      },
      fromAmino: ({ initial_deposit: e, proposer: n, content: r }) => {
        let t;
        switch (r.type) {
          case "cosmos-sdk/TextProposal": {
            const { value: i } = r;
            (0, Cr.assert)((0, Cr.isNonNullObject)(i));
            const { title: f, description: k } = i;
            (0, Cr.assert)(typeof f == "string"), (0, Cr.assert)(typeof k == "string"), t = Sm.Any.fromPartial({
              typeUrl: "/cosmos.gov.v1beta1.TextProposal",
              value: Nr.TextProposal.encode(Nr.TextProposal.fromPartial({
                title: f,
                description: k
              })).finish()
            });
            break;
          }
          default:
            throw new Error(`Unsupported proposal type: '${r.type}'`);
        }
        return {
          initialDeposit: Array.from(e),
          proposer: n,
          content: t
        };
      }
    }
  };
}
mn.createGovAminoConverters = Om;
var gn = {}, nl = {}, tl = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Params = e.TallyParams = e.VotingParams = e.DepositParams = e.Vote = e.TallyResult = e.Proposal = e.Deposit = e.WeightedVoteOption = e.proposalStatusToJSON = e.proposalStatusFromJSON = e.ProposalStatus = e.voteOptionToJSON = e.voteOptionFromJSON = e.VoteOption = e.protobufPackage = void 0;
  const n = Le, r = Be, t = _e, i = pn, f = re, k = ie;
  e.protobufPackage = "cosmos.gov.v1";
  var C;
  (function(o) {
    o[o.VOTE_OPTION_UNSPECIFIED = 0] = "VOTE_OPTION_UNSPECIFIED", o[o.VOTE_OPTION_YES = 1] = "VOTE_OPTION_YES", o[o.VOTE_OPTION_ABSTAIN = 2] = "VOTE_OPTION_ABSTAIN", o[o.VOTE_OPTION_NO = 3] = "VOTE_OPTION_NO", o[o.VOTE_OPTION_NO_WITH_VETO = 4] = "VOTE_OPTION_NO_WITH_VETO", o[o.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(C || (e.VoteOption = C = {}));
  function T(o) {
    switch (o) {
      case 0:
      case "VOTE_OPTION_UNSPECIFIED":
        return C.VOTE_OPTION_UNSPECIFIED;
      case 1:
      case "VOTE_OPTION_YES":
        return C.VOTE_OPTION_YES;
      case 2:
      case "VOTE_OPTION_ABSTAIN":
        return C.VOTE_OPTION_ABSTAIN;
      case 3:
      case "VOTE_OPTION_NO":
        return C.VOTE_OPTION_NO;
      case 4:
      case "VOTE_OPTION_NO_WITH_VETO":
        return C.VOTE_OPTION_NO_WITH_VETO;
      case -1:
      case "UNRECOGNIZED":
      default:
        return C.UNRECOGNIZED;
    }
  }
  e.voteOptionFromJSON = T;
  function U(o) {
    switch (o) {
      case C.VOTE_OPTION_UNSPECIFIED:
        return "VOTE_OPTION_UNSPECIFIED";
      case C.VOTE_OPTION_YES:
        return "VOTE_OPTION_YES";
      case C.VOTE_OPTION_ABSTAIN:
        return "VOTE_OPTION_ABSTAIN";
      case C.VOTE_OPTION_NO:
        return "VOTE_OPTION_NO";
      case C.VOTE_OPTION_NO_WITH_VETO:
        return "VOTE_OPTION_NO_WITH_VETO";
      case C.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.voteOptionToJSON = U;
  var w;
  (function(o) {
    o[o.PROPOSAL_STATUS_UNSPECIFIED = 0] = "PROPOSAL_STATUS_UNSPECIFIED", o[o.PROPOSAL_STATUS_DEPOSIT_PERIOD = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD", o[o.PROPOSAL_STATUS_VOTING_PERIOD = 2] = "PROPOSAL_STATUS_VOTING_PERIOD", o[o.PROPOSAL_STATUS_PASSED = 3] = "PROPOSAL_STATUS_PASSED", o[o.PROPOSAL_STATUS_REJECTED = 4] = "PROPOSAL_STATUS_REJECTED", o[o.PROPOSAL_STATUS_FAILED = 5] = "PROPOSAL_STATUS_FAILED", o[o.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(w || (e.ProposalStatus = w = {}));
  function N(o) {
    switch (o) {
      case 0:
      case "PROPOSAL_STATUS_UNSPECIFIED":
        return w.PROPOSAL_STATUS_UNSPECIFIED;
      case 1:
      case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
        return w.PROPOSAL_STATUS_DEPOSIT_PERIOD;
      case 2:
      case "PROPOSAL_STATUS_VOTING_PERIOD":
        return w.PROPOSAL_STATUS_VOTING_PERIOD;
      case 3:
      case "PROPOSAL_STATUS_PASSED":
        return w.PROPOSAL_STATUS_PASSED;
      case 4:
      case "PROPOSAL_STATUS_REJECTED":
        return w.PROPOSAL_STATUS_REJECTED;
      case 5:
      case "PROPOSAL_STATUS_FAILED":
        return w.PROPOSAL_STATUS_FAILED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return w.UNRECOGNIZED;
    }
  }
  e.proposalStatusFromJSON = N;
  function h(o) {
    switch (o) {
      case w.PROPOSAL_STATUS_UNSPECIFIED:
        return "PROPOSAL_STATUS_UNSPECIFIED";
      case w.PROPOSAL_STATUS_DEPOSIT_PERIOD:
        return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
      case w.PROPOSAL_STATUS_VOTING_PERIOD:
        return "PROPOSAL_STATUS_VOTING_PERIOD";
      case w.PROPOSAL_STATUS_PASSED:
        return "PROPOSAL_STATUS_PASSED";
      case w.PROPOSAL_STATUS_REJECTED:
        return "PROPOSAL_STATUS_REJECTED";
      case w.PROPOSAL_STATUS_FAILED:
        return "PROPOSAL_STATUS_FAILED";
      case w.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.proposalStatusToJSON = h;
  function P() {
    return {
      option: 0,
      weight: ""
    };
  }
  e.WeightedVoteOption = {
    typeUrl: "/cosmos.gov.v1.WeightedVoteOption",
    encode(o, p = f.BinaryWriter.create()) {
      return o.option !== 0 && p.uint32(8).int32(o.option), o.weight !== "" && p.uint32(18).string(o.weight), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = P();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.option = I.int32();
            break;
          case 2:
            s.weight = I.string();
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = P();
      return (0, k.isSet)(o.option) && (p.option = T(o.option)), (0, k.isSet)(o.weight) && (p.weight = String(o.weight)), p;
    },
    toJSON(o) {
      const p = {};
      return o.option !== void 0 && (p.option = U(o.option)), o.weight !== void 0 && (p.weight = o.weight), p;
    },
    fromPartial(o) {
      const p = P();
      return p.option = o.option ?? 0, p.weight = o.weight ?? "", p;
    }
  };
  function b() {
    return {
      proposalId: BigInt(0),
      depositor: "",
      amount: []
    };
  }
  e.Deposit = {
    typeUrl: "/cosmos.gov.v1.Deposit",
    encode(o, p = f.BinaryWriter.create()) {
      o.proposalId !== BigInt(0) && p.uint32(8).uint64(o.proposalId), o.depositor !== "" && p.uint32(18).string(o.depositor);
      for (const I of o.amount)
        n.Coin.encode(I, p.uint32(26).fork()).ldelim();
      return p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = b();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.proposalId = I.uint64();
            break;
          case 2:
            s.depositor = I.string();
            break;
          case 3:
            s.amount.push(n.Coin.decode(I, I.uint32()));
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = b();
      return (0, k.isSet)(o.proposalId) && (p.proposalId = BigInt(o.proposalId.toString())), (0, k.isSet)(o.depositor) && (p.depositor = String(o.depositor)), Array.isArray(o == null ? void 0 : o.amount) && (p.amount = o.amount.map((I) => n.Coin.fromJSON(I))), p;
    },
    toJSON(o) {
      const p = {};
      return o.proposalId !== void 0 && (p.proposalId = (o.proposalId || BigInt(0)).toString()), o.depositor !== void 0 && (p.depositor = o.depositor), o.amount ? p.amount = o.amount.map((I) => I ? n.Coin.toJSON(I) : void 0) : p.amount = [], p;
    },
    fromPartial(o) {
      var I;
      const p = b();
      return o.proposalId !== void 0 && o.proposalId !== null && (p.proposalId = BigInt(o.proposalId.toString())), p.depositor = o.depositor ?? "", p.amount = ((I = o.amount) == null ? void 0 : I.map((q) => n.Coin.fromPartial(q))) || [], p;
    }
  };
  function c() {
    return {
      id: BigInt(0),
      messages: [],
      status: 0,
      finalTallyResult: void 0,
      submitTime: void 0,
      depositEndTime: void 0,
      totalDeposit: [],
      votingStartTime: void 0,
      votingEndTime: void 0,
      metadata: "",
      title: "",
      summary: "",
      proposer: ""
    };
  }
  e.Proposal = {
    typeUrl: "/cosmos.gov.v1.Proposal",
    encode(o, p = f.BinaryWriter.create()) {
      o.id !== BigInt(0) && p.uint32(8).uint64(o.id);
      for (const I of o.messages)
        r.Any.encode(I, p.uint32(18).fork()).ldelim();
      o.status !== 0 && p.uint32(24).int32(o.status), o.finalTallyResult !== void 0 && e.TallyResult.encode(o.finalTallyResult, p.uint32(34).fork()).ldelim(), o.submitTime !== void 0 && t.Timestamp.encode(o.submitTime, p.uint32(42).fork()).ldelim(), o.depositEndTime !== void 0 && t.Timestamp.encode(o.depositEndTime, p.uint32(50).fork()).ldelim();
      for (const I of o.totalDeposit)
        n.Coin.encode(I, p.uint32(58).fork()).ldelim();
      return o.votingStartTime !== void 0 && t.Timestamp.encode(o.votingStartTime, p.uint32(66).fork()).ldelim(), o.votingEndTime !== void 0 && t.Timestamp.encode(o.votingEndTime, p.uint32(74).fork()).ldelim(), o.metadata !== "" && p.uint32(82).string(o.metadata), o.title !== "" && p.uint32(90).string(o.title), o.summary !== "" && p.uint32(98).string(o.summary), o.proposer !== "" && p.uint32(106).string(o.proposer), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = c();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.id = I.uint64();
            break;
          case 2:
            s.messages.push(r.Any.decode(I, I.uint32()));
            break;
          case 3:
            s.status = I.int32();
            break;
          case 4:
            s.finalTallyResult = e.TallyResult.decode(I, I.uint32());
            break;
          case 5:
            s.submitTime = t.Timestamp.decode(I, I.uint32());
            break;
          case 6:
            s.depositEndTime = t.Timestamp.decode(I, I.uint32());
            break;
          case 7:
            s.totalDeposit.push(n.Coin.decode(I, I.uint32()));
            break;
          case 8:
            s.votingStartTime = t.Timestamp.decode(I, I.uint32());
            break;
          case 9:
            s.votingEndTime = t.Timestamp.decode(I, I.uint32());
            break;
          case 10:
            s.metadata = I.string();
            break;
          case 11:
            s.title = I.string();
            break;
          case 12:
            s.summary = I.string();
            break;
          case 13:
            s.proposer = I.string();
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = c();
      return (0, k.isSet)(o.id) && (p.id = BigInt(o.id.toString())), Array.isArray(o == null ? void 0 : o.messages) && (p.messages = o.messages.map((I) => r.Any.fromJSON(I))), (0, k.isSet)(o.status) && (p.status = N(o.status)), (0, k.isSet)(o.finalTallyResult) && (p.finalTallyResult = e.TallyResult.fromJSON(o.finalTallyResult)), (0, k.isSet)(o.submitTime) && (p.submitTime = (0, k.fromJsonTimestamp)(o.submitTime)), (0, k.isSet)(o.depositEndTime) && (p.depositEndTime = (0, k.fromJsonTimestamp)(o.depositEndTime)), Array.isArray(o == null ? void 0 : o.totalDeposit) && (p.totalDeposit = o.totalDeposit.map((I) => n.Coin.fromJSON(I))), (0, k.isSet)(o.votingStartTime) && (p.votingStartTime = (0, k.fromJsonTimestamp)(o.votingStartTime)), (0, k.isSet)(o.votingEndTime) && (p.votingEndTime = (0, k.fromJsonTimestamp)(o.votingEndTime)), (0, k.isSet)(o.metadata) && (p.metadata = String(o.metadata)), (0, k.isSet)(o.title) && (p.title = String(o.title)), (0, k.isSet)(o.summary) && (p.summary = String(o.summary)), (0, k.isSet)(o.proposer) && (p.proposer = String(o.proposer)), p;
    },
    toJSON(o) {
      const p = {};
      return o.id !== void 0 && (p.id = (o.id || BigInt(0)).toString()), o.messages ? p.messages = o.messages.map((I) => I ? r.Any.toJSON(I) : void 0) : p.messages = [], o.status !== void 0 && (p.status = h(o.status)), o.finalTallyResult !== void 0 && (p.finalTallyResult = o.finalTallyResult ? e.TallyResult.toJSON(o.finalTallyResult) : void 0), o.submitTime !== void 0 && (p.submitTime = (0, k.fromTimestamp)(o.submitTime).toISOString()), o.depositEndTime !== void 0 && (p.depositEndTime = (0, k.fromTimestamp)(o.depositEndTime).toISOString()), o.totalDeposit ? p.totalDeposit = o.totalDeposit.map((I) => I ? n.Coin.toJSON(I) : void 0) : p.totalDeposit = [], o.votingStartTime !== void 0 && (p.votingStartTime = (0, k.fromTimestamp)(o.votingStartTime).toISOString()), o.votingEndTime !== void 0 && (p.votingEndTime = (0, k.fromTimestamp)(o.votingEndTime).toISOString()), o.metadata !== void 0 && (p.metadata = o.metadata), o.title !== void 0 && (p.title = o.title), o.summary !== void 0 && (p.summary = o.summary), o.proposer !== void 0 && (p.proposer = o.proposer), p;
    },
    fromPartial(o) {
      var I, q;
      const p = c();
      return o.id !== void 0 && o.id !== null && (p.id = BigInt(o.id.toString())), p.messages = ((I = o.messages) == null ? void 0 : I.map((s) => r.Any.fromPartial(s))) || [], p.status = o.status ?? 0, o.finalTallyResult !== void 0 && o.finalTallyResult !== null && (p.finalTallyResult = e.TallyResult.fromPartial(o.finalTallyResult)), o.submitTime !== void 0 && o.submitTime !== null && (p.submitTime = t.Timestamp.fromPartial(o.submitTime)), o.depositEndTime !== void 0 && o.depositEndTime !== null && (p.depositEndTime = t.Timestamp.fromPartial(o.depositEndTime)), p.totalDeposit = ((q = o.totalDeposit) == null ? void 0 : q.map((s) => n.Coin.fromPartial(s))) || [], o.votingStartTime !== void 0 && o.votingStartTime !== null && (p.votingStartTime = t.Timestamp.fromPartial(o.votingStartTime)), o.votingEndTime !== void 0 && o.votingEndTime !== null && (p.votingEndTime = t.Timestamp.fromPartial(o.votingEndTime)), p.metadata = o.metadata ?? "", p.title = o.title ?? "", p.summary = o.summary ?? "", p.proposer = o.proposer ?? "", p;
    }
  };
  function l() {
    return {
      yesCount: "",
      abstainCount: "",
      noCount: "",
      noWithVetoCount: ""
    };
  }
  e.TallyResult = {
    typeUrl: "/cosmos.gov.v1.TallyResult",
    encode(o, p = f.BinaryWriter.create()) {
      return o.yesCount !== "" && p.uint32(10).string(o.yesCount), o.abstainCount !== "" && p.uint32(18).string(o.abstainCount), o.noCount !== "" && p.uint32(26).string(o.noCount), o.noWithVetoCount !== "" && p.uint32(34).string(o.noWithVetoCount), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = l();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.yesCount = I.string();
            break;
          case 2:
            s.abstainCount = I.string();
            break;
          case 3:
            s.noCount = I.string();
            break;
          case 4:
            s.noWithVetoCount = I.string();
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = l();
      return (0, k.isSet)(o.yesCount) && (p.yesCount = String(o.yesCount)), (0, k.isSet)(o.abstainCount) && (p.abstainCount = String(o.abstainCount)), (0, k.isSet)(o.noCount) && (p.noCount = String(o.noCount)), (0, k.isSet)(o.noWithVetoCount) && (p.noWithVetoCount = String(o.noWithVetoCount)), p;
    },
    toJSON(o) {
      const p = {};
      return o.yesCount !== void 0 && (p.yesCount = o.yesCount), o.abstainCount !== void 0 && (p.abstainCount = o.abstainCount), o.noCount !== void 0 && (p.noCount = o.noCount), o.noWithVetoCount !== void 0 && (p.noWithVetoCount = o.noWithVetoCount), p;
    },
    fromPartial(o) {
      const p = l();
      return p.yesCount = o.yesCount ?? "", p.abstainCount = o.abstainCount ?? "", p.noCount = o.noCount ?? "", p.noWithVetoCount = o.noWithVetoCount ?? "", p;
    }
  };
  function y() {
    return {
      proposalId: BigInt(0),
      voter: "",
      options: [],
      metadata: ""
    };
  }
  e.Vote = {
    typeUrl: "/cosmos.gov.v1.Vote",
    encode(o, p = f.BinaryWriter.create()) {
      o.proposalId !== BigInt(0) && p.uint32(8).uint64(o.proposalId), o.voter !== "" && p.uint32(18).string(o.voter);
      for (const I of o.options)
        e.WeightedVoteOption.encode(I, p.uint32(34).fork()).ldelim();
      return o.metadata !== "" && p.uint32(42).string(o.metadata), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = y();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.proposalId = I.uint64();
            break;
          case 2:
            s.voter = I.string();
            break;
          case 4:
            s.options.push(e.WeightedVoteOption.decode(I, I.uint32()));
            break;
          case 5:
            s.metadata = I.string();
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = y();
      return (0, k.isSet)(o.proposalId) && (p.proposalId = BigInt(o.proposalId.toString())), (0, k.isSet)(o.voter) && (p.voter = String(o.voter)), Array.isArray(o == null ? void 0 : o.options) && (p.options = o.options.map((I) => e.WeightedVoteOption.fromJSON(I))), (0, k.isSet)(o.metadata) && (p.metadata = String(o.metadata)), p;
    },
    toJSON(o) {
      const p = {};
      return o.proposalId !== void 0 && (p.proposalId = (o.proposalId || BigInt(0)).toString()), o.voter !== void 0 && (p.voter = o.voter), o.options ? p.options = o.options.map((I) => I ? e.WeightedVoteOption.toJSON(I) : void 0) : p.options = [], o.metadata !== void 0 && (p.metadata = o.metadata), p;
    },
    fromPartial(o) {
      var I;
      const p = y();
      return o.proposalId !== void 0 && o.proposalId !== null && (p.proposalId = BigInt(o.proposalId.toString())), p.voter = o.voter ?? "", p.options = ((I = o.options) == null ? void 0 : I.map((q) => e.WeightedVoteOption.fromPartial(q))) || [], p.metadata = o.metadata ?? "", p;
    }
  };
  function E() {
    return {
      minDeposit: [],
      maxDepositPeriod: void 0
    };
  }
  e.DepositParams = {
    typeUrl: "/cosmos.gov.v1.DepositParams",
    encode(o, p = f.BinaryWriter.create()) {
      for (const I of o.minDeposit)
        n.Coin.encode(I, p.uint32(10).fork()).ldelim();
      return o.maxDepositPeriod !== void 0 && i.Duration.encode(o.maxDepositPeriod, p.uint32(18).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = E();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.minDeposit.push(n.Coin.decode(I, I.uint32()));
            break;
          case 2:
            s.maxDepositPeriod = i.Duration.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = E();
      return Array.isArray(o == null ? void 0 : o.minDeposit) && (p.minDeposit = o.minDeposit.map((I) => n.Coin.fromJSON(I))), (0, k.isSet)(o.maxDepositPeriod) && (p.maxDepositPeriod = i.Duration.fromJSON(o.maxDepositPeriod)), p;
    },
    toJSON(o) {
      const p = {};
      return o.minDeposit ? p.minDeposit = o.minDeposit.map((I) => I ? n.Coin.toJSON(I) : void 0) : p.minDeposit = [], o.maxDepositPeriod !== void 0 && (p.maxDepositPeriod = o.maxDepositPeriod ? i.Duration.toJSON(o.maxDepositPeriod) : void 0), p;
    },
    fromPartial(o) {
      var I;
      const p = E();
      return p.minDeposit = ((I = o.minDeposit) == null ? void 0 : I.map((q) => n.Coin.fromPartial(q))) || [], o.maxDepositPeriod !== void 0 && o.maxDepositPeriod !== null && (p.maxDepositPeriod = i.Duration.fromPartial(o.maxDepositPeriod)), p;
    }
  };
  function J() {
    return {
      votingPeriod: void 0
    };
  }
  e.VotingParams = {
    typeUrl: "/cosmos.gov.v1.VotingParams",
    encode(o, p = f.BinaryWriter.create()) {
      return o.votingPeriod !== void 0 && i.Duration.encode(o.votingPeriod, p.uint32(10).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = J();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.votingPeriod = i.Duration.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = J();
      return (0, k.isSet)(o.votingPeriod) && (p.votingPeriod = i.Duration.fromJSON(o.votingPeriod)), p;
    },
    toJSON(o) {
      const p = {};
      return o.votingPeriod !== void 0 && (p.votingPeriod = o.votingPeriod ? i.Duration.toJSON(o.votingPeriod) : void 0), p;
    },
    fromPartial(o) {
      const p = J();
      return o.votingPeriod !== void 0 && o.votingPeriod !== null && (p.votingPeriod = i.Duration.fromPartial(o.votingPeriod)), p;
    }
  };
  function _() {
    return {
      quorum: "",
      threshold: "",
      vetoThreshold: ""
    };
  }
  e.TallyParams = {
    typeUrl: "/cosmos.gov.v1.TallyParams",
    encode(o, p = f.BinaryWriter.create()) {
      return o.quorum !== "" && p.uint32(10).string(o.quorum), o.threshold !== "" && p.uint32(18).string(o.threshold), o.vetoThreshold !== "" && p.uint32(26).string(o.vetoThreshold), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = _();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.quorum = I.string();
            break;
          case 2:
            s.threshold = I.string();
            break;
          case 3:
            s.vetoThreshold = I.string();
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = _();
      return (0, k.isSet)(o.quorum) && (p.quorum = String(o.quorum)), (0, k.isSet)(o.threshold) && (p.threshold = String(o.threshold)), (0, k.isSet)(o.vetoThreshold) && (p.vetoThreshold = String(o.vetoThreshold)), p;
    },
    toJSON(o) {
      const p = {};
      return o.quorum !== void 0 && (p.quorum = o.quorum), o.threshold !== void 0 && (p.threshold = o.threshold), o.vetoThreshold !== void 0 && (p.vetoThreshold = o.vetoThreshold), p;
    },
    fromPartial(o) {
      const p = _();
      return p.quorum = o.quorum ?? "", p.threshold = o.threshold ?? "", p.vetoThreshold = o.vetoThreshold ?? "", p;
    }
  };
  function V() {
    return {
      minDeposit: [],
      maxDepositPeriod: void 0,
      votingPeriod: void 0,
      quorum: "",
      threshold: "",
      vetoThreshold: "",
      minInitialDepositRatio: "",
      burnVoteQuorum: !1,
      burnProposalDepositPrevote: !1,
      burnVoteVeto: !1
    };
  }
  e.Params = {
    typeUrl: "/cosmos.gov.v1.Params",
    encode(o, p = f.BinaryWriter.create()) {
      for (const I of o.minDeposit)
        n.Coin.encode(I, p.uint32(10).fork()).ldelim();
      return o.maxDepositPeriod !== void 0 && i.Duration.encode(o.maxDepositPeriod, p.uint32(18).fork()).ldelim(), o.votingPeriod !== void 0 && i.Duration.encode(o.votingPeriod, p.uint32(26).fork()).ldelim(), o.quorum !== "" && p.uint32(34).string(o.quorum), o.threshold !== "" && p.uint32(42).string(o.threshold), o.vetoThreshold !== "" && p.uint32(50).string(o.vetoThreshold), o.minInitialDepositRatio !== "" && p.uint32(58).string(o.minInitialDepositRatio), o.burnVoteQuorum === !0 && p.uint32(104).bool(o.burnVoteQuorum), o.burnProposalDepositPrevote === !0 && p.uint32(112).bool(o.burnProposalDepositPrevote), o.burnVoteVeto === !0 && p.uint32(120).bool(o.burnVoteVeto), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = V();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.minDeposit.push(n.Coin.decode(I, I.uint32()));
            break;
          case 2:
            s.maxDepositPeriod = i.Duration.decode(I, I.uint32());
            break;
          case 3:
            s.votingPeriod = i.Duration.decode(I, I.uint32());
            break;
          case 4:
            s.quorum = I.string();
            break;
          case 5:
            s.threshold = I.string();
            break;
          case 6:
            s.vetoThreshold = I.string();
            break;
          case 7:
            s.minInitialDepositRatio = I.string();
            break;
          case 13:
            s.burnVoteQuorum = I.bool();
            break;
          case 14:
            s.burnProposalDepositPrevote = I.bool();
            break;
          case 15:
            s.burnVoteVeto = I.bool();
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = V();
      return Array.isArray(o == null ? void 0 : o.minDeposit) && (p.minDeposit = o.minDeposit.map((I) => n.Coin.fromJSON(I))), (0, k.isSet)(o.maxDepositPeriod) && (p.maxDepositPeriod = i.Duration.fromJSON(o.maxDepositPeriod)), (0, k.isSet)(o.votingPeriod) && (p.votingPeriod = i.Duration.fromJSON(o.votingPeriod)), (0, k.isSet)(o.quorum) && (p.quorum = String(o.quorum)), (0, k.isSet)(o.threshold) && (p.threshold = String(o.threshold)), (0, k.isSet)(o.vetoThreshold) && (p.vetoThreshold = String(o.vetoThreshold)), (0, k.isSet)(o.minInitialDepositRatio) && (p.minInitialDepositRatio = String(o.minInitialDepositRatio)), (0, k.isSet)(o.burnVoteQuorum) && (p.burnVoteQuorum = !!o.burnVoteQuorum), (0, k.isSet)(o.burnProposalDepositPrevote) && (p.burnProposalDepositPrevote = !!o.burnProposalDepositPrevote), (0, k.isSet)(o.burnVoteVeto) && (p.burnVoteVeto = !!o.burnVoteVeto), p;
    },
    toJSON(o) {
      const p = {};
      return o.minDeposit ? p.minDeposit = o.minDeposit.map((I) => I ? n.Coin.toJSON(I) : void 0) : p.minDeposit = [], o.maxDepositPeriod !== void 0 && (p.maxDepositPeriod = o.maxDepositPeriod ? i.Duration.toJSON(o.maxDepositPeriod) : void 0), o.votingPeriod !== void 0 && (p.votingPeriod = o.votingPeriod ? i.Duration.toJSON(o.votingPeriod) : void 0), o.quorum !== void 0 && (p.quorum = o.quorum), o.threshold !== void 0 && (p.threshold = o.threshold), o.vetoThreshold !== void 0 && (p.vetoThreshold = o.vetoThreshold), o.minInitialDepositRatio !== void 0 && (p.minInitialDepositRatio = o.minInitialDepositRatio), o.burnVoteQuorum !== void 0 && (p.burnVoteQuorum = o.burnVoteQuorum), o.burnProposalDepositPrevote !== void 0 && (p.burnProposalDepositPrevote = o.burnProposalDepositPrevote), o.burnVoteVeto !== void 0 && (p.burnVoteVeto = o.burnVoteVeto), p;
    },
    fromPartial(o) {
      var I;
      const p = V();
      return p.minDeposit = ((I = o.minDeposit) == null ? void 0 : I.map((q) => n.Coin.fromPartial(q))) || [], o.maxDepositPeriod !== void 0 && o.maxDepositPeriod !== null && (p.maxDepositPeriod = i.Duration.fromPartial(o.maxDepositPeriod)), o.votingPeriod !== void 0 && o.votingPeriod !== null && (p.votingPeriod = i.Duration.fromPartial(o.votingPeriod)), p.quorum = o.quorum ?? "", p.threshold = o.threshold ?? "", p.vetoThreshold = o.vetoThreshold ?? "", p.minInitialDepositRatio = o.minInitialDepositRatio ?? "", p.burnVoteQuorum = o.burnVoteQuorum ?? !1, p.burnProposalDepositPrevote = o.burnProposalDepositPrevote ?? !1, p.burnVoteVeto = o.burnVoteVeto ?? !1, p;
    }
  };
})(tl);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgUpdateParamsResponse = e.MsgUpdateParams = e.MsgDepositResponse = e.MsgDeposit = e.MsgVoteWeightedResponse = e.MsgVoteWeighted = e.MsgVoteResponse = e.MsgVote = e.MsgExecLegacyContentResponse = e.MsgExecLegacyContent = e.MsgSubmitProposalResponse = e.MsgSubmitProposal = e.protobufPackage = void 0;
  const n = Be, r = Le, t = tl, i = re, f = ie;
  e.protobufPackage = "cosmos.gov.v1";
  function k() {
    return {
      messages: [],
      initialDeposit: [],
      proposer: "",
      metadata: "",
      title: "",
      summary: ""
    };
  }
  e.MsgSubmitProposal = {
    typeUrl: "/cosmos.gov.v1.MsgSubmitProposal",
    encode(J, _ = i.BinaryWriter.create()) {
      for (const V of J.messages)
        n.Any.encode(V, _.uint32(10).fork()).ldelim();
      for (const V of J.initialDeposit)
        r.Coin.encode(V, _.uint32(18).fork()).ldelim();
      return J.proposer !== "" && _.uint32(26).string(J.proposer), J.metadata !== "" && _.uint32(34).string(J.metadata), J.title !== "" && _.uint32(42).string(J.title), J.summary !== "" && _.uint32(50).string(J.summary), _;
    },
    decode(J, _) {
      const V = J instanceof i.BinaryReader ? J : new i.BinaryReader(J);
      let o = _ === void 0 ? V.len : V.pos + _;
      const p = k();
      for (; V.pos < o; ) {
        const I = V.uint32();
        switch (I >>> 3) {
          case 1:
            p.messages.push(n.Any.decode(V, V.uint32()));
            break;
          case 2:
            p.initialDeposit.push(r.Coin.decode(V, V.uint32()));
            break;
          case 3:
            p.proposer = V.string();
            break;
          case 4:
            p.metadata = V.string();
            break;
          case 5:
            p.title = V.string();
            break;
          case 6:
            p.summary = V.string();
            break;
          default:
            V.skipType(I & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(J) {
      const _ = k();
      return Array.isArray(J == null ? void 0 : J.messages) && (_.messages = J.messages.map((V) => n.Any.fromJSON(V))), Array.isArray(J == null ? void 0 : J.initialDeposit) && (_.initialDeposit = J.initialDeposit.map((V) => r.Coin.fromJSON(V))), (0, f.isSet)(J.proposer) && (_.proposer = String(J.proposer)), (0, f.isSet)(J.metadata) && (_.metadata = String(J.metadata)), (0, f.isSet)(J.title) && (_.title = String(J.title)), (0, f.isSet)(J.summary) && (_.summary = String(J.summary)), _;
    },
    toJSON(J) {
      const _ = {};
      return J.messages ? _.messages = J.messages.map((V) => V ? n.Any.toJSON(V) : void 0) : _.messages = [], J.initialDeposit ? _.initialDeposit = J.initialDeposit.map((V) => V ? r.Coin.toJSON(V) : void 0) : _.initialDeposit = [], J.proposer !== void 0 && (_.proposer = J.proposer), J.metadata !== void 0 && (_.metadata = J.metadata), J.title !== void 0 && (_.title = J.title), J.summary !== void 0 && (_.summary = J.summary), _;
    },
    fromPartial(J) {
      var V, o;
      const _ = k();
      return _.messages = ((V = J.messages) == null ? void 0 : V.map((p) => n.Any.fromPartial(p))) || [], _.initialDeposit = ((o = J.initialDeposit) == null ? void 0 : o.map((p) => r.Coin.fromPartial(p))) || [], _.proposer = J.proposer ?? "", _.metadata = J.metadata ?? "", _.title = J.title ?? "", _.summary = J.summary ?? "", _;
    }
  };
  function C() {
    return {
      proposalId: BigInt(0)
    };
  }
  e.MsgSubmitProposalResponse = {
    typeUrl: "/cosmos.gov.v1.MsgSubmitProposalResponse",
    encode(J, _ = i.BinaryWriter.create()) {
      return J.proposalId !== BigInt(0) && _.uint32(8).uint64(J.proposalId), _;
    },
    decode(J, _) {
      const V = J instanceof i.BinaryReader ? J : new i.BinaryReader(J);
      let o = _ === void 0 ? V.len : V.pos + _;
      const p = C();
      for (; V.pos < o; ) {
        const I = V.uint32();
        switch (I >>> 3) {
          case 1:
            p.proposalId = V.uint64();
            break;
          default:
            V.skipType(I & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(J) {
      const _ = C();
      return (0, f.isSet)(J.proposalId) && (_.proposalId = BigInt(J.proposalId.toString())), _;
    },
    toJSON(J) {
      const _ = {};
      return J.proposalId !== void 0 && (_.proposalId = (J.proposalId || BigInt(0)).toString()), _;
    },
    fromPartial(J) {
      const _ = C();
      return J.proposalId !== void 0 && J.proposalId !== null && (_.proposalId = BigInt(J.proposalId.toString())), _;
    }
  };
  function T() {
    return {
      content: void 0,
      authority: ""
    };
  }
  e.MsgExecLegacyContent = {
    typeUrl: "/cosmos.gov.v1.MsgExecLegacyContent",
    encode(J, _ = i.BinaryWriter.create()) {
      return J.content !== void 0 && n.Any.encode(J.content, _.uint32(10).fork()).ldelim(), J.authority !== "" && _.uint32(18).string(J.authority), _;
    },
    decode(J, _) {
      const V = J instanceof i.BinaryReader ? J : new i.BinaryReader(J);
      let o = _ === void 0 ? V.len : V.pos + _;
      const p = T();
      for (; V.pos < o; ) {
        const I = V.uint32();
        switch (I >>> 3) {
          case 1:
            p.content = n.Any.decode(V, V.uint32());
            break;
          case 2:
            p.authority = V.string();
            break;
          default:
            V.skipType(I & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(J) {
      const _ = T();
      return (0, f.isSet)(J.content) && (_.content = n.Any.fromJSON(J.content)), (0, f.isSet)(J.authority) && (_.authority = String(J.authority)), _;
    },
    toJSON(J) {
      const _ = {};
      return J.content !== void 0 && (_.content = J.content ? n.Any.toJSON(J.content) : void 0), J.authority !== void 0 && (_.authority = J.authority), _;
    },
    fromPartial(J) {
      const _ = T();
      return J.content !== void 0 && J.content !== null && (_.content = n.Any.fromPartial(J.content)), _.authority = J.authority ?? "", _;
    }
  };
  function U() {
    return {};
  }
  e.MsgExecLegacyContentResponse = {
    typeUrl: "/cosmos.gov.v1.MsgExecLegacyContentResponse",
    encode(J, _ = i.BinaryWriter.create()) {
      return _;
    },
    decode(J, _) {
      const V = J instanceof i.BinaryReader ? J : new i.BinaryReader(J);
      let o = _ === void 0 ? V.len : V.pos + _;
      const p = U();
      for (; V.pos < o; ) {
        const I = V.uint32();
        switch (I >>> 3) {
          default:
            V.skipType(I & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(J) {
      return U();
    },
    toJSON(J) {
      return {};
    },
    fromPartial(J) {
      return U();
    }
  };
  function w() {
    return {
      proposalId: BigInt(0),
      voter: "",
      option: 0,
      metadata: ""
    };
  }
  e.MsgVote = {
    typeUrl: "/cosmos.gov.v1.MsgVote",
    encode(J, _ = i.BinaryWriter.create()) {
      return J.proposalId !== BigInt(0) && _.uint32(8).uint64(J.proposalId), J.voter !== "" && _.uint32(18).string(J.voter), J.option !== 0 && _.uint32(24).int32(J.option), J.metadata !== "" && _.uint32(34).string(J.metadata), _;
    },
    decode(J, _) {
      const V = J instanceof i.BinaryReader ? J : new i.BinaryReader(J);
      let o = _ === void 0 ? V.len : V.pos + _;
      const p = w();
      for (; V.pos < o; ) {
        const I = V.uint32();
        switch (I >>> 3) {
          case 1:
            p.proposalId = V.uint64();
            break;
          case 2:
            p.voter = V.string();
            break;
          case 3:
            p.option = V.int32();
            break;
          case 4:
            p.metadata = V.string();
            break;
          default:
            V.skipType(I & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(J) {
      const _ = w();
      return (0, f.isSet)(J.proposalId) && (_.proposalId = BigInt(J.proposalId.toString())), (0, f.isSet)(J.voter) && (_.voter = String(J.voter)), (0, f.isSet)(J.option) && (_.option = (0, t.voteOptionFromJSON)(J.option)), (0, f.isSet)(J.metadata) && (_.metadata = String(J.metadata)), _;
    },
    toJSON(J) {
      const _ = {};
      return J.proposalId !== void 0 && (_.proposalId = (J.proposalId || BigInt(0)).toString()), J.voter !== void 0 && (_.voter = J.voter), J.option !== void 0 && (_.option = (0, t.voteOptionToJSON)(J.option)), J.metadata !== void 0 && (_.metadata = J.metadata), _;
    },
    fromPartial(J) {
      const _ = w();
      return J.proposalId !== void 0 && J.proposalId !== null && (_.proposalId = BigInt(J.proposalId.toString())), _.voter = J.voter ?? "", _.option = J.option ?? 0, _.metadata = J.metadata ?? "", _;
    }
  };
  function N() {
    return {};
  }
  e.MsgVoteResponse = {
    typeUrl: "/cosmos.gov.v1.MsgVoteResponse",
    encode(J, _ = i.BinaryWriter.create()) {
      return _;
    },
    decode(J, _) {
      const V = J instanceof i.BinaryReader ? J : new i.BinaryReader(J);
      let o = _ === void 0 ? V.len : V.pos + _;
      const p = N();
      for (; V.pos < o; ) {
        const I = V.uint32();
        switch (I >>> 3) {
          default:
            V.skipType(I & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(J) {
      return N();
    },
    toJSON(J) {
      return {};
    },
    fromPartial(J) {
      return N();
    }
  };
  function h() {
    return {
      proposalId: BigInt(0),
      voter: "",
      options: [],
      metadata: ""
    };
  }
  e.MsgVoteWeighted = {
    typeUrl: "/cosmos.gov.v1.MsgVoteWeighted",
    encode(J, _ = i.BinaryWriter.create()) {
      J.proposalId !== BigInt(0) && _.uint32(8).uint64(J.proposalId), J.voter !== "" && _.uint32(18).string(J.voter);
      for (const V of J.options)
        t.WeightedVoteOption.encode(V, _.uint32(26).fork()).ldelim();
      return J.metadata !== "" && _.uint32(34).string(J.metadata), _;
    },
    decode(J, _) {
      const V = J instanceof i.BinaryReader ? J : new i.BinaryReader(J);
      let o = _ === void 0 ? V.len : V.pos + _;
      const p = h();
      for (; V.pos < o; ) {
        const I = V.uint32();
        switch (I >>> 3) {
          case 1:
            p.proposalId = V.uint64();
            break;
          case 2:
            p.voter = V.string();
            break;
          case 3:
            p.options.push(t.WeightedVoteOption.decode(V, V.uint32()));
            break;
          case 4:
            p.metadata = V.string();
            break;
          default:
            V.skipType(I & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(J) {
      const _ = h();
      return (0, f.isSet)(J.proposalId) && (_.proposalId = BigInt(J.proposalId.toString())), (0, f.isSet)(J.voter) && (_.voter = String(J.voter)), Array.isArray(J == null ? void 0 : J.options) && (_.options = J.options.map((V) => t.WeightedVoteOption.fromJSON(V))), (0, f.isSet)(J.metadata) && (_.metadata = String(J.metadata)), _;
    },
    toJSON(J) {
      const _ = {};
      return J.proposalId !== void 0 && (_.proposalId = (J.proposalId || BigInt(0)).toString()), J.voter !== void 0 && (_.voter = J.voter), J.options ? _.options = J.options.map((V) => V ? t.WeightedVoteOption.toJSON(V) : void 0) : _.options = [], J.metadata !== void 0 && (_.metadata = J.metadata), _;
    },
    fromPartial(J) {
      var V;
      const _ = h();
      return J.proposalId !== void 0 && J.proposalId !== null && (_.proposalId = BigInt(J.proposalId.toString())), _.voter = J.voter ?? "", _.options = ((V = J.options) == null ? void 0 : V.map((o) => t.WeightedVoteOption.fromPartial(o))) || [], _.metadata = J.metadata ?? "", _;
    }
  };
  function P() {
    return {};
  }
  e.MsgVoteWeightedResponse = {
    typeUrl: "/cosmos.gov.v1.MsgVoteWeightedResponse",
    encode(J, _ = i.BinaryWriter.create()) {
      return _;
    },
    decode(J, _) {
      const V = J instanceof i.BinaryReader ? J : new i.BinaryReader(J);
      let o = _ === void 0 ? V.len : V.pos + _;
      const p = P();
      for (; V.pos < o; ) {
        const I = V.uint32();
        switch (I >>> 3) {
          default:
            V.skipType(I & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(J) {
      return P();
    },
    toJSON(J) {
      return {};
    },
    fromPartial(J) {
      return P();
    }
  };
  function b() {
    return {
      proposalId: BigInt(0),
      depositor: "",
      amount: []
    };
  }
  e.MsgDeposit = {
    typeUrl: "/cosmos.gov.v1.MsgDeposit",
    encode(J, _ = i.BinaryWriter.create()) {
      J.proposalId !== BigInt(0) && _.uint32(8).uint64(J.proposalId), J.depositor !== "" && _.uint32(18).string(J.depositor);
      for (const V of J.amount)
        r.Coin.encode(V, _.uint32(26).fork()).ldelim();
      return _;
    },
    decode(J, _) {
      const V = J instanceof i.BinaryReader ? J : new i.BinaryReader(J);
      let o = _ === void 0 ? V.len : V.pos + _;
      const p = b();
      for (; V.pos < o; ) {
        const I = V.uint32();
        switch (I >>> 3) {
          case 1:
            p.proposalId = V.uint64();
            break;
          case 2:
            p.depositor = V.string();
            break;
          case 3:
            p.amount.push(r.Coin.decode(V, V.uint32()));
            break;
          default:
            V.skipType(I & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(J) {
      const _ = b();
      return (0, f.isSet)(J.proposalId) && (_.proposalId = BigInt(J.proposalId.toString())), (0, f.isSet)(J.depositor) && (_.depositor = String(J.depositor)), Array.isArray(J == null ? void 0 : J.amount) && (_.amount = J.amount.map((V) => r.Coin.fromJSON(V))), _;
    },
    toJSON(J) {
      const _ = {};
      return J.proposalId !== void 0 && (_.proposalId = (J.proposalId || BigInt(0)).toString()), J.depositor !== void 0 && (_.depositor = J.depositor), J.amount ? _.amount = J.amount.map((V) => V ? r.Coin.toJSON(V) : void 0) : _.amount = [], _;
    },
    fromPartial(J) {
      var V;
      const _ = b();
      return J.proposalId !== void 0 && J.proposalId !== null && (_.proposalId = BigInt(J.proposalId.toString())), _.depositor = J.depositor ?? "", _.amount = ((V = J.amount) == null ? void 0 : V.map((o) => r.Coin.fromPartial(o))) || [], _;
    }
  };
  function c() {
    return {};
  }
  e.MsgDepositResponse = {
    typeUrl: "/cosmos.gov.v1.MsgDepositResponse",
    encode(J, _ = i.BinaryWriter.create()) {
      return _;
    },
    decode(J, _) {
      const V = J instanceof i.BinaryReader ? J : new i.BinaryReader(J);
      let o = _ === void 0 ? V.len : V.pos + _;
      const p = c();
      for (; V.pos < o; ) {
        const I = V.uint32();
        switch (I >>> 3) {
          default:
            V.skipType(I & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(J) {
      return c();
    },
    toJSON(J) {
      return {};
    },
    fromPartial(J) {
      return c();
    }
  };
  function l() {
    return {
      authority: "",
      params: t.Params.fromPartial({})
    };
  }
  e.MsgUpdateParams = {
    typeUrl: "/cosmos.gov.v1.MsgUpdateParams",
    encode(J, _ = i.BinaryWriter.create()) {
      return J.authority !== "" && _.uint32(10).string(J.authority), J.params !== void 0 && t.Params.encode(J.params, _.uint32(18).fork()).ldelim(), _;
    },
    decode(J, _) {
      const V = J instanceof i.BinaryReader ? J : new i.BinaryReader(J);
      let o = _ === void 0 ? V.len : V.pos + _;
      const p = l();
      for (; V.pos < o; ) {
        const I = V.uint32();
        switch (I >>> 3) {
          case 1:
            p.authority = V.string();
            break;
          case 2:
            p.params = t.Params.decode(V, V.uint32());
            break;
          default:
            V.skipType(I & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(J) {
      const _ = l();
      return (0, f.isSet)(J.authority) && (_.authority = String(J.authority)), (0, f.isSet)(J.params) && (_.params = t.Params.fromJSON(J.params)), _;
    },
    toJSON(J) {
      const _ = {};
      return J.authority !== void 0 && (_.authority = J.authority), J.params !== void 0 && (_.params = J.params ? t.Params.toJSON(J.params) : void 0), _;
    },
    fromPartial(J) {
      const _ = l();
      return _.authority = J.authority ?? "", J.params !== void 0 && J.params !== null && (_.params = t.Params.fromPartial(J.params)), _;
    }
  };
  function y() {
    return {};
  }
  e.MsgUpdateParamsResponse = {
    typeUrl: "/cosmos.gov.v1.MsgUpdateParamsResponse",
    encode(J, _ = i.BinaryWriter.create()) {
      return _;
    },
    decode(J, _) {
      const V = J instanceof i.BinaryReader ? J : new i.BinaryReader(J);
      let o = _ === void 0 ? V.len : V.pos + _;
      const p = y();
      for (; V.pos < o; ) {
        const I = V.uint32();
        switch (I >>> 3) {
          default:
            V.skipType(I & 7);
            break;
        }
      }
      return p;
    },
    fromJSON(J) {
      return y();
    },
    toJSON(J) {
      return {};
    },
    fromPartial(J) {
      return y();
    }
  };
  class E {
    constructor(_) {
      this.rpc = _, this.SubmitProposal = this.SubmitProposal.bind(this), this.ExecLegacyContent = this.ExecLegacyContent.bind(this), this.Vote = this.Vote.bind(this), this.VoteWeighted = this.VoteWeighted.bind(this), this.Deposit = this.Deposit.bind(this), this.UpdateParams = this.UpdateParams.bind(this);
    }
    SubmitProposal(_) {
      const V = e.MsgSubmitProposal.encode(_).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "SubmitProposal", V).then((p) => e.MsgSubmitProposalResponse.decode(new i.BinaryReader(p)));
    }
    ExecLegacyContent(_) {
      const V = e.MsgExecLegacyContent.encode(_).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "ExecLegacyContent", V).then((p) => e.MsgExecLegacyContentResponse.decode(new i.BinaryReader(p)));
    }
    Vote(_) {
      const V = e.MsgVote.encode(_).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "Vote", V).then((p) => e.MsgVoteResponse.decode(new i.BinaryReader(p)));
    }
    VoteWeighted(_) {
      const V = e.MsgVoteWeighted.encode(_).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "VoteWeighted", V).then((p) => e.MsgVoteWeightedResponse.decode(new i.BinaryReader(p)));
    }
    Deposit(_) {
      const V = e.MsgDeposit.encode(_).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "Deposit", V).then((p) => e.MsgDepositResponse.decode(new i.BinaryReader(p)));
    }
    UpdateParams(_) {
      const V = e.MsgUpdateParams.encode(_).finish();
      return this.rpc.request("cosmos.gov.v1.Msg", "UpdateParams", V).then((p) => e.MsgUpdateParamsResponse.decode(new i.BinaryReader(p)));
    }
  }
  e.MsgClientImpl = E;
})(nl);
var rl = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgDepositResponse = e.MsgDeposit = e.MsgVoteWeightedResponse = e.MsgVoteWeighted = e.MsgVoteResponse = e.MsgVote = e.MsgSubmitProposalResponse = e.MsgSubmitProposal = e.protobufPackage = void 0;
  const n = Be, r = Le, t = vo, i = re, f = ie;
  e.protobufPackage = "cosmos.gov.v1beta1";
  function k() {
    return {
      content: void 0,
      initialDeposit: [],
      proposer: ""
    };
  }
  e.MsgSubmitProposal = {
    typeUrl: "/cosmos.gov.v1beta1.MsgSubmitProposal",
    encode(c, l = i.BinaryWriter.create()) {
      c.content !== void 0 && n.Any.encode(c.content, l.uint32(10).fork()).ldelim();
      for (const y of c.initialDeposit)
        r.Coin.encode(y, l.uint32(18).fork()).ldelim();
      return c.proposer !== "" && l.uint32(26).string(c.proposer), l;
    },
    decode(c, l) {
      const y = c instanceof i.BinaryReader ? c : new i.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = k();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.content = n.Any.decode(y, y.uint32());
            break;
          case 2:
            J.initialDeposit.push(r.Coin.decode(y, y.uint32()));
            break;
          case 3:
            J.proposer = y.string();
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = k();
      return (0, f.isSet)(c.content) && (l.content = n.Any.fromJSON(c.content)), Array.isArray(c == null ? void 0 : c.initialDeposit) && (l.initialDeposit = c.initialDeposit.map((y) => r.Coin.fromJSON(y))), (0, f.isSet)(c.proposer) && (l.proposer = String(c.proposer)), l;
    },
    toJSON(c) {
      const l = {};
      return c.content !== void 0 && (l.content = c.content ? n.Any.toJSON(c.content) : void 0), c.initialDeposit ? l.initialDeposit = c.initialDeposit.map((y) => y ? r.Coin.toJSON(y) : void 0) : l.initialDeposit = [], c.proposer !== void 0 && (l.proposer = c.proposer), l;
    },
    fromPartial(c) {
      var y;
      const l = k();
      return c.content !== void 0 && c.content !== null && (l.content = n.Any.fromPartial(c.content)), l.initialDeposit = ((y = c.initialDeposit) == null ? void 0 : y.map((E) => r.Coin.fromPartial(E))) || [], l.proposer = c.proposer ?? "", l;
    }
  };
  function C() {
    return {
      proposalId: BigInt(0)
    };
  }
  e.MsgSubmitProposalResponse = {
    typeUrl: "/cosmos.gov.v1beta1.MsgSubmitProposalResponse",
    encode(c, l = i.BinaryWriter.create()) {
      return c.proposalId !== BigInt(0) && l.uint32(8).uint64(c.proposalId), l;
    },
    decode(c, l) {
      const y = c instanceof i.BinaryReader ? c : new i.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = C();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.proposalId = y.uint64();
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = C();
      return (0, f.isSet)(c.proposalId) && (l.proposalId = BigInt(c.proposalId.toString())), l;
    },
    toJSON(c) {
      const l = {};
      return c.proposalId !== void 0 && (l.proposalId = (c.proposalId || BigInt(0)).toString()), l;
    },
    fromPartial(c) {
      const l = C();
      return c.proposalId !== void 0 && c.proposalId !== null && (l.proposalId = BigInt(c.proposalId.toString())), l;
    }
  };
  function T() {
    return {
      proposalId: BigInt(0),
      voter: "",
      option: 0
    };
  }
  e.MsgVote = {
    typeUrl: "/cosmos.gov.v1beta1.MsgVote",
    encode(c, l = i.BinaryWriter.create()) {
      return c.proposalId !== BigInt(0) && l.uint32(8).uint64(c.proposalId), c.voter !== "" && l.uint32(18).string(c.voter), c.option !== 0 && l.uint32(24).int32(c.option), l;
    },
    decode(c, l) {
      const y = c instanceof i.BinaryReader ? c : new i.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = T();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.proposalId = y.uint64();
            break;
          case 2:
            J.voter = y.string();
            break;
          case 3:
            J.option = y.int32();
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = T();
      return (0, f.isSet)(c.proposalId) && (l.proposalId = BigInt(c.proposalId.toString())), (0, f.isSet)(c.voter) && (l.voter = String(c.voter)), (0, f.isSet)(c.option) && (l.option = (0, t.voteOptionFromJSON)(c.option)), l;
    },
    toJSON(c) {
      const l = {};
      return c.proposalId !== void 0 && (l.proposalId = (c.proposalId || BigInt(0)).toString()), c.voter !== void 0 && (l.voter = c.voter), c.option !== void 0 && (l.option = (0, t.voteOptionToJSON)(c.option)), l;
    },
    fromPartial(c) {
      const l = T();
      return c.proposalId !== void 0 && c.proposalId !== null && (l.proposalId = BigInt(c.proposalId.toString())), l.voter = c.voter ?? "", l.option = c.option ?? 0, l;
    }
  };
  function U() {
    return {};
  }
  e.MsgVoteResponse = {
    typeUrl: "/cosmos.gov.v1beta1.MsgVoteResponse",
    encode(c, l = i.BinaryWriter.create()) {
      return l;
    },
    decode(c, l) {
      const y = c instanceof i.BinaryReader ? c : new i.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = U();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      return U();
    },
    toJSON(c) {
      return {};
    },
    fromPartial(c) {
      return U();
    }
  };
  function w() {
    return {
      proposalId: BigInt(0),
      voter: "",
      options: []
    };
  }
  e.MsgVoteWeighted = {
    typeUrl: "/cosmos.gov.v1beta1.MsgVoteWeighted",
    encode(c, l = i.BinaryWriter.create()) {
      c.proposalId !== BigInt(0) && l.uint32(8).uint64(c.proposalId), c.voter !== "" && l.uint32(18).string(c.voter);
      for (const y of c.options)
        t.WeightedVoteOption.encode(y, l.uint32(26).fork()).ldelim();
      return l;
    },
    decode(c, l) {
      const y = c instanceof i.BinaryReader ? c : new i.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = w();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.proposalId = y.uint64();
            break;
          case 2:
            J.voter = y.string();
            break;
          case 3:
            J.options.push(t.WeightedVoteOption.decode(y, y.uint32()));
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = w();
      return (0, f.isSet)(c.proposalId) && (l.proposalId = BigInt(c.proposalId.toString())), (0, f.isSet)(c.voter) && (l.voter = String(c.voter)), Array.isArray(c == null ? void 0 : c.options) && (l.options = c.options.map((y) => t.WeightedVoteOption.fromJSON(y))), l;
    },
    toJSON(c) {
      const l = {};
      return c.proposalId !== void 0 && (l.proposalId = (c.proposalId || BigInt(0)).toString()), c.voter !== void 0 && (l.voter = c.voter), c.options ? l.options = c.options.map((y) => y ? t.WeightedVoteOption.toJSON(y) : void 0) : l.options = [], l;
    },
    fromPartial(c) {
      var y;
      const l = w();
      return c.proposalId !== void 0 && c.proposalId !== null && (l.proposalId = BigInt(c.proposalId.toString())), l.voter = c.voter ?? "", l.options = ((y = c.options) == null ? void 0 : y.map((E) => t.WeightedVoteOption.fromPartial(E))) || [], l;
    }
  };
  function N() {
    return {};
  }
  e.MsgVoteWeightedResponse = {
    typeUrl: "/cosmos.gov.v1beta1.MsgVoteWeightedResponse",
    encode(c, l = i.BinaryWriter.create()) {
      return l;
    },
    decode(c, l) {
      const y = c instanceof i.BinaryReader ? c : new i.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = N();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      return N();
    },
    toJSON(c) {
      return {};
    },
    fromPartial(c) {
      return N();
    }
  };
  function h() {
    return {
      proposalId: BigInt(0),
      depositor: "",
      amount: []
    };
  }
  e.MsgDeposit = {
    typeUrl: "/cosmos.gov.v1beta1.MsgDeposit",
    encode(c, l = i.BinaryWriter.create()) {
      c.proposalId !== BigInt(0) && l.uint32(8).uint64(c.proposalId), c.depositor !== "" && l.uint32(18).string(c.depositor);
      for (const y of c.amount)
        r.Coin.encode(y, l.uint32(26).fork()).ldelim();
      return l;
    },
    decode(c, l) {
      const y = c instanceof i.BinaryReader ? c : new i.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = h();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.proposalId = y.uint64();
            break;
          case 2:
            J.depositor = y.string();
            break;
          case 3:
            J.amount.push(r.Coin.decode(y, y.uint32()));
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = h();
      return (0, f.isSet)(c.proposalId) && (l.proposalId = BigInt(c.proposalId.toString())), (0, f.isSet)(c.depositor) && (l.depositor = String(c.depositor)), Array.isArray(c == null ? void 0 : c.amount) && (l.amount = c.amount.map((y) => r.Coin.fromJSON(y))), l;
    },
    toJSON(c) {
      const l = {};
      return c.proposalId !== void 0 && (l.proposalId = (c.proposalId || BigInt(0)).toString()), c.depositor !== void 0 && (l.depositor = c.depositor), c.amount ? l.amount = c.amount.map((y) => y ? r.Coin.toJSON(y) : void 0) : l.amount = [], l;
    },
    fromPartial(c) {
      var y;
      const l = h();
      return c.proposalId !== void 0 && c.proposalId !== null && (l.proposalId = BigInt(c.proposalId.toString())), l.depositor = c.depositor ?? "", l.amount = ((y = c.amount) == null ? void 0 : y.map((E) => r.Coin.fromPartial(E))) || [], l;
    }
  };
  function P() {
    return {};
  }
  e.MsgDepositResponse = {
    typeUrl: "/cosmos.gov.v1beta1.MsgDepositResponse",
    encode(c, l = i.BinaryWriter.create()) {
      return l;
    },
    decode(c, l) {
      const y = c instanceof i.BinaryReader ? c : new i.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = P();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      return P();
    },
    toJSON(c) {
      return {};
    },
    fromPartial(c) {
      return P();
    }
  };
  class b {
    constructor(l) {
      this.rpc = l, this.SubmitProposal = this.SubmitProposal.bind(this), this.Vote = this.Vote.bind(this), this.VoteWeighted = this.VoteWeighted.bind(this), this.Deposit = this.Deposit.bind(this);
    }
    SubmitProposal(l) {
      const y = e.MsgSubmitProposal.encode(l).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Msg", "SubmitProposal", y).then((J) => e.MsgSubmitProposalResponse.decode(new i.BinaryReader(J)));
    }
    Vote(l) {
      const y = e.MsgVote.encode(l).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Msg", "Vote", y).then((J) => e.MsgVoteResponse.decode(new i.BinaryReader(J)));
    }
    VoteWeighted(l) {
      const y = e.MsgVoteWeighted.encode(l).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Msg", "VoteWeighted", y).then((J) => e.MsgVoteWeightedResponse.decode(new i.BinaryReader(J)));
    }
    Deposit(l) {
      const y = e.MsgDeposit.encode(l).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Msg", "Deposit", y).then((J) => e.MsgDepositResponse.decode(new i.BinaryReader(J)));
    }
  }
  e.MsgClientImpl = b;
})(rl);
Object.defineProperty(gn, "__esModule", { value: !0 });
gn.isMsgVoteWeightedEncodeObject = gn.isMsgVoteEncodeObject = gn.isMsgSubmitProposalEncodeObject = gn.isMsgDepositEncodeObject = gn.govTypes = void 0;
const wr = nl, mi = rl;
gn.govTypes = [
  ["/cosmos.gov.v1.MsgDeposit", wr.MsgDeposit],
  ["/cosmos.gov.v1.MsgSubmitProposal", wr.MsgSubmitProposal],
  ["/cosmos.gov.v1.MsgUpdateParams", wr.MsgUpdateParams],
  ["/cosmos.gov.v1.MsgVote", wr.MsgVote],
  ["/cosmos.gov.v1.MsgVoteWeighted", wr.MsgVoteWeighted],
  ["/cosmos.gov.v1beta1.MsgDeposit", mi.MsgDeposit],
  ["/cosmos.gov.v1beta1.MsgSubmitProposal", mi.MsgSubmitProposal],
  ["/cosmos.gov.v1beta1.MsgVote", mi.MsgVote],
  ["/cosmos.gov.v1beta1.MsgVoteWeighted", mi.MsgVoteWeighted]
];
function bm(e) {
  return e.typeUrl === "/cosmos.gov.v1beta1.MsgDeposit";
}
gn.isMsgDepositEncodeObject = bm;
function Am(e) {
  return e.typeUrl === "/cosmos.gov.v1beta1.MsgSubmitProposal";
}
gn.isMsgSubmitProposalEncodeObject = Am;
function Im(e) {
  return e.typeUrl === "/cosmos.gov.v1beta1.MsgVote";
}
gn.isMsgVoteEncodeObject = Im;
function Tm(e) {
  return e.typeUrl === "/cosmos.gov.v1beta1.MsgVoteWeighted";
}
gn.isMsgVoteWeightedEncodeObject = Tm;
var Ro = {}, il = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryTallyResultResponse = e.QueryTallyResultRequest = e.QueryDepositsResponse = e.QueryDepositsRequest = e.QueryDepositResponse = e.QueryDepositRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.QueryVotesResponse = e.QueryVotesRequest = e.QueryVoteResponse = e.QueryVoteRequest = e.QueryProposalsResponse = e.QueryProposalsRequest = e.QueryProposalResponse = e.QueryProposalRequest = e.protobufPackage = void 0;
  const n = vo, r = Ae, t = re, i = ie;
  e.protobufPackage = "cosmos.gov.v1beta1";
  function f() {
    return {
      proposalId: BigInt(0)
    };
  }
  e.QueryProposalRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryProposalRequest",
    encode(o, p = t.BinaryWriter.create()) {
      return o.proposalId !== BigInt(0) && p.uint32(8).uint64(o.proposalId), p;
    },
    decode(o, p) {
      const I = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = f();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.proposalId = I.uint64();
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = f();
      return (0, i.isSet)(o.proposalId) && (p.proposalId = BigInt(o.proposalId.toString())), p;
    },
    toJSON(o) {
      const p = {};
      return o.proposalId !== void 0 && (p.proposalId = (o.proposalId || BigInt(0)).toString()), p;
    },
    fromPartial(o) {
      const p = f();
      return o.proposalId !== void 0 && o.proposalId !== null && (p.proposalId = BigInt(o.proposalId.toString())), p;
    }
  };
  function k() {
    return {
      proposal: n.Proposal.fromPartial({})
    };
  }
  e.QueryProposalResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryProposalResponse",
    encode(o, p = t.BinaryWriter.create()) {
      return o.proposal !== void 0 && n.Proposal.encode(o.proposal, p.uint32(10).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = k();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.proposal = n.Proposal.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = k();
      return (0, i.isSet)(o.proposal) && (p.proposal = n.Proposal.fromJSON(o.proposal)), p;
    },
    toJSON(o) {
      const p = {};
      return o.proposal !== void 0 && (p.proposal = o.proposal ? n.Proposal.toJSON(o.proposal) : void 0), p;
    },
    fromPartial(o) {
      const p = k();
      return o.proposal !== void 0 && o.proposal !== null && (p.proposal = n.Proposal.fromPartial(o.proposal)), p;
    }
  };
  function C() {
    return {
      proposalStatus: 0,
      voter: "",
      depositor: "",
      pagination: void 0
    };
  }
  e.QueryProposalsRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryProposalsRequest",
    encode(o, p = t.BinaryWriter.create()) {
      return o.proposalStatus !== 0 && p.uint32(8).int32(o.proposalStatus), o.voter !== "" && p.uint32(18).string(o.voter), o.depositor !== "" && p.uint32(26).string(o.depositor), o.pagination !== void 0 && r.PageRequest.encode(o.pagination, p.uint32(34).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = C();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.proposalStatus = I.int32();
            break;
          case 2:
            s.voter = I.string();
            break;
          case 3:
            s.depositor = I.string();
            break;
          case 4:
            s.pagination = r.PageRequest.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = C();
      return (0, i.isSet)(o.proposalStatus) && (p.proposalStatus = (0, n.proposalStatusFromJSON)(o.proposalStatus)), (0, i.isSet)(o.voter) && (p.voter = String(o.voter)), (0, i.isSet)(o.depositor) && (p.depositor = String(o.depositor)), (0, i.isSet)(o.pagination) && (p.pagination = r.PageRequest.fromJSON(o.pagination)), p;
    },
    toJSON(o) {
      const p = {};
      return o.proposalStatus !== void 0 && (p.proposalStatus = (0, n.proposalStatusToJSON)(o.proposalStatus)), o.voter !== void 0 && (p.voter = o.voter), o.depositor !== void 0 && (p.depositor = o.depositor), o.pagination !== void 0 && (p.pagination = o.pagination ? r.PageRequest.toJSON(o.pagination) : void 0), p;
    },
    fromPartial(o) {
      const p = C();
      return p.proposalStatus = o.proposalStatus ?? 0, p.voter = o.voter ?? "", p.depositor = o.depositor ?? "", o.pagination !== void 0 && o.pagination !== null && (p.pagination = r.PageRequest.fromPartial(o.pagination)), p;
    }
  };
  function T() {
    return {
      proposals: [],
      pagination: void 0
    };
  }
  e.QueryProposalsResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryProposalsResponse",
    encode(o, p = t.BinaryWriter.create()) {
      for (const I of o.proposals)
        n.Proposal.encode(I, p.uint32(10).fork()).ldelim();
      return o.pagination !== void 0 && r.PageResponse.encode(o.pagination, p.uint32(18).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = T();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.proposals.push(n.Proposal.decode(I, I.uint32()));
            break;
          case 2:
            s.pagination = r.PageResponse.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = T();
      return Array.isArray(o == null ? void 0 : o.proposals) && (p.proposals = o.proposals.map((I) => n.Proposal.fromJSON(I))), (0, i.isSet)(o.pagination) && (p.pagination = r.PageResponse.fromJSON(o.pagination)), p;
    },
    toJSON(o) {
      const p = {};
      return o.proposals ? p.proposals = o.proposals.map((I) => I ? n.Proposal.toJSON(I) : void 0) : p.proposals = [], o.pagination !== void 0 && (p.pagination = o.pagination ? r.PageResponse.toJSON(o.pagination) : void 0), p;
    },
    fromPartial(o) {
      var I;
      const p = T();
      return p.proposals = ((I = o.proposals) == null ? void 0 : I.map((q) => n.Proposal.fromPartial(q))) || [], o.pagination !== void 0 && o.pagination !== null && (p.pagination = r.PageResponse.fromPartial(o.pagination)), p;
    }
  };
  function U() {
    return {
      proposalId: BigInt(0),
      voter: ""
    };
  }
  e.QueryVoteRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryVoteRequest",
    encode(o, p = t.BinaryWriter.create()) {
      return o.proposalId !== BigInt(0) && p.uint32(8).uint64(o.proposalId), o.voter !== "" && p.uint32(18).string(o.voter), p;
    },
    decode(o, p) {
      const I = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = U();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.proposalId = I.uint64();
            break;
          case 2:
            s.voter = I.string();
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = U();
      return (0, i.isSet)(o.proposalId) && (p.proposalId = BigInt(o.proposalId.toString())), (0, i.isSet)(o.voter) && (p.voter = String(o.voter)), p;
    },
    toJSON(o) {
      const p = {};
      return o.proposalId !== void 0 && (p.proposalId = (o.proposalId || BigInt(0)).toString()), o.voter !== void 0 && (p.voter = o.voter), p;
    },
    fromPartial(o) {
      const p = U();
      return o.proposalId !== void 0 && o.proposalId !== null && (p.proposalId = BigInt(o.proposalId.toString())), p.voter = o.voter ?? "", p;
    }
  };
  function w() {
    return {
      vote: n.Vote.fromPartial({})
    };
  }
  e.QueryVoteResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryVoteResponse",
    encode(o, p = t.BinaryWriter.create()) {
      return o.vote !== void 0 && n.Vote.encode(o.vote, p.uint32(10).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = w();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.vote = n.Vote.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = w();
      return (0, i.isSet)(o.vote) && (p.vote = n.Vote.fromJSON(o.vote)), p;
    },
    toJSON(o) {
      const p = {};
      return o.vote !== void 0 && (p.vote = o.vote ? n.Vote.toJSON(o.vote) : void 0), p;
    },
    fromPartial(o) {
      const p = w();
      return o.vote !== void 0 && o.vote !== null && (p.vote = n.Vote.fromPartial(o.vote)), p;
    }
  };
  function N() {
    return {
      proposalId: BigInt(0),
      pagination: void 0
    };
  }
  e.QueryVotesRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryVotesRequest",
    encode(o, p = t.BinaryWriter.create()) {
      return o.proposalId !== BigInt(0) && p.uint32(8).uint64(o.proposalId), o.pagination !== void 0 && r.PageRequest.encode(o.pagination, p.uint32(18).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = N();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.proposalId = I.uint64();
            break;
          case 2:
            s.pagination = r.PageRequest.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = N();
      return (0, i.isSet)(o.proposalId) && (p.proposalId = BigInt(o.proposalId.toString())), (0, i.isSet)(o.pagination) && (p.pagination = r.PageRequest.fromJSON(o.pagination)), p;
    },
    toJSON(o) {
      const p = {};
      return o.proposalId !== void 0 && (p.proposalId = (o.proposalId || BigInt(0)).toString()), o.pagination !== void 0 && (p.pagination = o.pagination ? r.PageRequest.toJSON(o.pagination) : void 0), p;
    },
    fromPartial(o) {
      const p = N();
      return o.proposalId !== void 0 && o.proposalId !== null && (p.proposalId = BigInt(o.proposalId.toString())), o.pagination !== void 0 && o.pagination !== null && (p.pagination = r.PageRequest.fromPartial(o.pagination)), p;
    }
  };
  function h() {
    return {
      votes: [],
      pagination: void 0
    };
  }
  e.QueryVotesResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryVotesResponse",
    encode(o, p = t.BinaryWriter.create()) {
      for (const I of o.votes)
        n.Vote.encode(I, p.uint32(10).fork()).ldelim();
      return o.pagination !== void 0 && r.PageResponse.encode(o.pagination, p.uint32(18).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = h();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.votes.push(n.Vote.decode(I, I.uint32()));
            break;
          case 2:
            s.pagination = r.PageResponse.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = h();
      return Array.isArray(o == null ? void 0 : o.votes) && (p.votes = o.votes.map((I) => n.Vote.fromJSON(I))), (0, i.isSet)(o.pagination) && (p.pagination = r.PageResponse.fromJSON(o.pagination)), p;
    },
    toJSON(o) {
      const p = {};
      return o.votes ? p.votes = o.votes.map((I) => I ? n.Vote.toJSON(I) : void 0) : p.votes = [], o.pagination !== void 0 && (p.pagination = o.pagination ? r.PageResponse.toJSON(o.pagination) : void 0), p;
    },
    fromPartial(o) {
      var I;
      const p = h();
      return p.votes = ((I = o.votes) == null ? void 0 : I.map((q) => n.Vote.fromPartial(q))) || [], o.pagination !== void 0 && o.pagination !== null && (p.pagination = r.PageResponse.fromPartial(o.pagination)), p;
    }
  };
  function P() {
    return {
      paramsType: ""
    };
  }
  e.QueryParamsRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryParamsRequest",
    encode(o, p = t.BinaryWriter.create()) {
      return o.paramsType !== "" && p.uint32(10).string(o.paramsType), p;
    },
    decode(o, p) {
      const I = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = P();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.paramsType = I.string();
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = P();
      return (0, i.isSet)(o.paramsType) && (p.paramsType = String(o.paramsType)), p;
    },
    toJSON(o) {
      const p = {};
      return o.paramsType !== void 0 && (p.paramsType = o.paramsType), p;
    },
    fromPartial(o) {
      const p = P();
      return p.paramsType = o.paramsType ?? "", p;
    }
  };
  function b() {
    return {
      votingParams: n.VotingParams.fromPartial({}),
      depositParams: n.DepositParams.fromPartial({}),
      tallyParams: n.TallyParams.fromPartial({})
    };
  }
  e.QueryParamsResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryParamsResponse",
    encode(o, p = t.BinaryWriter.create()) {
      return o.votingParams !== void 0 && n.VotingParams.encode(o.votingParams, p.uint32(10).fork()).ldelim(), o.depositParams !== void 0 && n.DepositParams.encode(o.depositParams, p.uint32(18).fork()).ldelim(), o.tallyParams !== void 0 && n.TallyParams.encode(o.tallyParams, p.uint32(26).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = b();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.votingParams = n.VotingParams.decode(I, I.uint32());
            break;
          case 2:
            s.depositParams = n.DepositParams.decode(I, I.uint32());
            break;
          case 3:
            s.tallyParams = n.TallyParams.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = b();
      return (0, i.isSet)(o.votingParams) && (p.votingParams = n.VotingParams.fromJSON(o.votingParams)), (0, i.isSet)(o.depositParams) && (p.depositParams = n.DepositParams.fromJSON(o.depositParams)), (0, i.isSet)(o.tallyParams) && (p.tallyParams = n.TallyParams.fromJSON(o.tallyParams)), p;
    },
    toJSON(o) {
      const p = {};
      return o.votingParams !== void 0 && (p.votingParams = o.votingParams ? n.VotingParams.toJSON(o.votingParams) : void 0), o.depositParams !== void 0 && (p.depositParams = o.depositParams ? n.DepositParams.toJSON(o.depositParams) : void 0), o.tallyParams !== void 0 && (p.tallyParams = o.tallyParams ? n.TallyParams.toJSON(o.tallyParams) : void 0), p;
    },
    fromPartial(o) {
      const p = b();
      return o.votingParams !== void 0 && o.votingParams !== null && (p.votingParams = n.VotingParams.fromPartial(o.votingParams)), o.depositParams !== void 0 && o.depositParams !== null && (p.depositParams = n.DepositParams.fromPartial(o.depositParams)), o.tallyParams !== void 0 && o.tallyParams !== null && (p.tallyParams = n.TallyParams.fromPartial(o.tallyParams)), p;
    }
  };
  function c() {
    return {
      proposalId: BigInt(0),
      depositor: ""
    };
  }
  e.QueryDepositRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryDepositRequest",
    encode(o, p = t.BinaryWriter.create()) {
      return o.proposalId !== BigInt(0) && p.uint32(8).uint64(o.proposalId), o.depositor !== "" && p.uint32(18).string(o.depositor), p;
    },
    decode(o, p) {
      const I = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = c();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.proposalId = I.uint64();
            break;
          case 2:
            s.depositor = I.string();
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = c();
      return (0, i.isSet)(o.proposalId) && (p.proposalId = BigInt(o.proposalId.toString())), (0, i.isSet)(o.depositor) && (p.depositor = String(o.depositor)), p;
    },
    toJSON(o) {
      const p = {};
      return o.proposalId !== void 0 && (p.proposalId = (o.proposalId || BigInt(0)).toString()), o.depositor !== void 0 && (p.depositor = o.depositor), p;
    },
    fromPartial(o) {
      const p = c();
      return o.proposalId !== void 0 && o.proposalId !== null && (p.proposalId = BigInt(o.proposalId.toString())), p.depositor = o.depositor ?? "", p;
    }
  };
  function l() {
    return {
      deposit: n.Deposit.fromPartial({})
    };
  }
  e.QueryDepositResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryDepositResponse",
    encode(o, p = t.BinaryWriter.create()) {
      return o.deposit !== void 0 && n.Deposit.encode(o.deposit, p.uint32(10).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = l();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.deposit = n.Deposit.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = l();
      return (0, i.isSet)(o.deposit) && (p.deposit = n.Deposit.fromJSON(o.deposit)), p;
    },
    toJSON(o) {
      const p = {};
      return o.deposit !== void 0 && (p.deposit = o.deposit ? n.Deposit.toJSON(o.deposit) : void 0), p;
    },
    fromPartial(o) {
      const p = l();
      return o.deposit !== void 0 && o.deposit !== null && (p.deposit = n.Deposit.fromPartial(o.deposit)), p;
    }
  };
  function y() {
    return {
      proposalId: BigInt(0),
      pagination: void 0
    };
  }
  e.QueryDepositsRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryDepositsRequest",
    encode(o, p = t.BinaryWriter.create()) {
      return o.proposalId !== BigInt(0) && p.uint32(8).uint64(o.proposalId), o.pagination !== void 0 && r.PageRequest.encode(o.pagination, p.uint32(18).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = y();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.proposalId = I.uint64();
            break;
          case 2:
            s.pagination = r.PageRequest.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = y();
      return (0, i.isSet)(o.proposalId) && (p.proposalId = BigInt(o.proposalId.toString())), (0, i.isSet)(o.pagination) && (p.pagination = r.PageRequest.fromJSON(o.pagination)), p;
    },
    toJSON(o) {
      const p = {};
      return o.proposalId !== void 0 && (p.proposalId = (o.proposalId || BigInt(0)).toString()), o.pagination !== void 0 && (p.pagination = o.pagination ? r.PageRequest.toJSON(o.pagination) : void 0), p;
    },
    fromPartial(o) {
      const p = y();
      return o.proposalId !== void 0 && o.proposalId !== null && (p.proposalId = BigInt(o.proposalId.toString())), o.pagination !== void 0 && o.pagination !== null && (p.pagination = r.PageRequest.fromPartial(o.pagination)), p;
    }
  };
  function E() {
    return {
      deposits: [],
      pagination: void 0
    };
  }
  e.QueryDepositsResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryDepositsResponse",
    encode(o, p = t.BinaryWriter.create()) {
      for (const I of o.deposits)
        n.Deposit.encode(I, p.uint32(10).fork()).ldelim();
      return o.pagination !== void 0 && r.PageResponse.encode(o.pagination, p.uint32(18).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = E();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.deposits.push(n.Deposit.decode(I, I.uint32()));
            break;
          case 2:
            s.pagination = r.PageResponse.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = E();
      return Array.isArray(o == null ? void 0 : o.deposits) && (p.deposits = o.deposits.map((I) => n.Deposit.fromJSON(I))), (0, i.isSet)(o.pagination) && (p.pagination = r.PageResponse.fromJSON(o.pagination)), p;
    },
    toJSON(o) {
      const p = {};
      return o.deposits ? p.deposits = o.deposits.map((I) => I ? n.Deposit.toJSON(I) : void 0) : p.deposits = [], o.pagination !== void 0 && (p.pagination = o.pagination ? r.PageResponse.toJSON(o.pagination) : void 0), p;
    },
    fromPartial(o) {
      var I;
      const p = E();
      return p.deposits = ((I = o.deposits) == null ? void 0 : I.map((q) => n.Deposit.fromPartial(q))) || [], o.pagination !== void 0 && o.pagination !== null && (p.pagination = r.PageResponse.fromPartial(o.pagination)), p;
    }
  };
  function J() {
    return {
      proposalId: BigInt(0)
    };
  }
  e.QueryTallyResultRequest = {
    typeUrl: "/cosmos.gov.v1beta1.QueryTallyResultRequest",
    encode(o, p = t.BinaryWriter.create()) {
      return o.proposalId !== BigInt(0) && p.uint32(8).uint64(o.proposalId), p;
    },
    decode(o, p) {
      const I = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = J();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.proposalId = I.uint64();
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = J();
      return (0, i.isSet)(o.proposalId) && (p.proposalId = BigInt(o.proposalId.toString())), p;
    },
    toJSON(o) {
      const p = {};
      return o.proposalId !== void 0 && (p.proposalId = (o.proposalId || BigInt(0)).toString()), p;
    },
    fromPartial(o) {
      const p = J();
      return o.proposalId !== void 0 && o.proposalId !== null && (p.proposalId = BigInt(o.proposalId.toString())), p;
    }
  };
  function _() {
    return {
      tally: n.TallyResult.fromPartial({})
    };
  }
  e.QueryTallyResultResponse = {
    typeUrl: "/cosmos.gov.v1beta1.QueryTallyResultResponse",
    encode(o, p = t.BinaryWriter.create()) {
      return o.tally !== void 0 && n.TallyResult.encode(o.tally, p.uint32(10).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof t.BinaryReader ? o : new t.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = _();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.tally = n.TallyResult.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = _();
      return (0, i.isSet)(o.tally) && (p.tally = n.TallyResult.fromJSON(o.tally)), p;
    },
    toJSON(o) {
      const p = {};
      return o.tally !== void 0 && (p.tally = o.tally ? n.TallyResult.toJSON(o.tally) : void 0), p;
    },
    fromPartial(o) {
      const p = _();
      return o.tally !== void 0 && o.tally !== null && (p.tally = n.TallyResult.fromPartial(o.tally)), p;
    }
  };
  class V {
    constructor(p) {
      this.rpc = p, this.Proposal = this.Proposal.bind(this), this.Proposals = this.Proposals.bind(this), this.Vote = this.Vote.bind(this), this.Votes = this.Votes.bind(this), this.Params = this.Params.bind(this), this.Deposit = this.Deposit.bind(this), this.Deposits = this.Deposits.bind(this), this.TallyResult = this.TallyResult.bind(this);
    }
    Proposal(p) {
      const I = e.QueryProposalRequest.encode(p).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Proposal", I).then((s) => e.QueryProposalResponse.decode(new t.BinaryReader(s)));
    }
    Proposals(p) {
      const I = e.QueryProposalsRequest.encode(p).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Proposals", I).then((s) => e.QueryProposalsResponse.decode(new t.BinaryReader(s)));
    }
    Vote(p) {
      const I = e.QueryVoteRequest.encode(p).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Vote", I).then((s) => e.QueryVoteResponse.decode(new t.BinaryReader(s)));
    }
    Votes(p) {
      const I = e.QueryVotesRequest.encode(p).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Votes", I).then((s) => e.QueryVotesResponse.decode(new t.BinaryReader(s)));
    }
    Params(p) {
      const I = e.QueryParamsRequest.encode(p).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Params", I).then((s) => e.QueryParamsResponse.decode(new t.BinaryReader(s)));
    }
    Deposit(p) {
      const I = e.QueryDepositRequest.encode(p).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Deposit", I).then((s) => e.QueryDepositResponse.decode(new t.BinaryReader(s)));
    }
    Deposits(p) {
      const I = e.QueryDepositsRequest.encode(p).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "Deposits", I).then((s) => e.QueryDepositsResponse.decode(new t.BinaryReader(s)));
    }
    TallyResult(p) {
      const I = e.QueryTallyResultRequest.encode(p).finish();
      return this.rpc.request("cosmos.gov.v1beta1.Query", "TallyResult", I).then((s) => e.QueryTallyResultResponse.decode(new t.BinaryReader(s)));
    }
  }
  e.QueryClientImpl = V;
})(il);
Object.defineProperty(Ro, "__esModule", { value: !0 });
Ro.setupGovExtension = void 0;
const Cm = il, Jn = Ge;
function Nm(e) {
  const n = (0, Jn.createProtobufRpcClient)(e), r = new Cm.QueryClientImpl(n);
  return {
    gov: {
      params: async (t) => await r.Params({ paramsType: t }),
      proposals: async (t, i, f, k) => await r.Proposals({
        proposalStatus: t,
        depositor: i,
        voter: f,
        pagination: (0, Jn.createPagination)(k)
      }),
      proposal: async (t) => await r.Proposal({ proposalId: (0, Jn.longify)(t) }),
      deposits: async (t, i) => await r.Deposits({
        proposalId: (0, Jn.longify)(t),
        pagination: (0, Jn.createPagination)(i)
      }),
      deposit: async (t, i) => await r.Deposit({
        proposalId: (0, Jn.longify)(t),
        depositor: i
      }),
      tally: async (t) => await r.TallyResult({
        proposalId: (0, Jn.longify)(t)
      }),
      votes: async (t, i) => await r.Votes({
        proposalId: (0, Jn.longify)(t),
        pagination: (0, Jn.createPagination)(i)
      }),
      vote: async (t, i) => await r.Vote({
        proposalId: (0, Jn.longify)(t),
        voter: i
      })
    }
  };
}
Ro.setupGovExtension = Nm;
var Bo = {};
Object.defineProperty(Bo, "__esModule", { value: !0 });
Bo.createGroupAminoConverters = void 0;
function wm() {
  return {};
}
Bo.createGroupAminoConverters = wm;
var Oo = {}, ol = {}, al = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Vote = e.TallyResult = e.Proposal = e.GroupPolicyInfo = e.GroupMember = e.GroupInfo = e.DecisionPolicyWindows = e.PercentageDecisionPolicy = e.ThresholdDecisionPolicy = e.MemberRequest = e.Member = e.proposalExecutorResultToJSON = e.proposalExecutorResultFromJSON = e.ProposalExecutorResult = e.proposalStatusToJSON = e.proposalStatusFromJSON = e.ProposalStatus = e.voteOptionToJSON = e.voteOptionFromJSON = e.VoteOption = e.protobufPackage = void 0;
  const n = _e, r = pn, t = Be, i = re, f = ie;
  e.protobufPackage = "cosmos.group.v1";
  var k;
  (function(s) {
    s[s.VOTE_OPTION_UNSPECIFIED = 0] = "VOTE_OPTION_UNSPECIFIED", s[s.VOTE_OPTION_YES = 1] = "VOTE_OPTION_YES", s[s.VOTE_OPTION_ABSTAIN = 2] = "VOTE_OPTION_ABSTAIN", s[s.VOTE_OPTION_NO = 3] = "VOTE_OPTION_NO", s[s.VOTE_OPTION_NO_WITH_VETO = 4] = "VOTE_OPTION_NO_WITH_VETO", s[s.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(k || (e.VoteOption = k = {}));
  function C(s) {
    switch (s) {
      case 0:
      case "VOTE_OPTION_UNSPECIFIED":
        return k.VOTE_OPTION_UNSPECIFIED;
      case 1:
      case "VOTE_OPTION_YES":
        return k.VOTE_OPTION_YES;
      case 2:
      case "VOTE_OPTION_ABSTAIN":
        return k.VOTE_OPTION_ABSTAIN;
      case 3:
      case "VOTE_OPTION_NO":
        return k.VOTE_OPTION_NO;
      case 4:
      case "VOTE_OPTION_NO_WITH_VETO":
        return k.VOTE_OPTION_NO_WITH_VETO;
      case -1:
      case "UNRECOGNIZED":
      default:
        return k.UNRECOGNIZED;
    }
  }
  e.voteOptionFromJSON = C;
  function T(s) {
    switch (s) {
      case k.VOTE_OPTION_UNSPECIFIED:
        return "VOTE_OPTION_UNSPECIFIED";
      case k.VOTE_OPTION_YES:
        return "VOTE_OPTION_YES";
      case k.VOTE_OPTION_ABSTAIN:
        return "VOTE_OPTION_ABSTAIN";
      case k.VOTE_OPTION_NO:
        return "VOTE_OPTION_NO";
      case k.VOTE_OPTION_NO_WITH_VETO:
        return "VOTE_OPTION_NO_WITH_VETO";
      case k.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.voteOptionToJSON = T;
  var U;
  (function(s) {
    s[s.PROPOSAL_STATUS_UNSPECIFIED = 0] = "PROPOSAL_STATUS_UNSPECIFIED", s[s.PROPOSAL_STATUS_SUBMITTED = 1] = "PROPOSAL_STATUS_SUBMITTED", s[s.PROPOSAL_STATUS_ACCEPTED = 2] = "PROPOSAL_STATUS_ACCEPTED", s[s.PROPOSAL_STATUS_REJECTED = 3] = "PROPOSAL_STATUS_REJECTED", s[s.PROPOSAL_STATUS_ABORTED = 4] = "PROPOSAL_STATUS_ABORTED", s[s.PROPOSAL_STATUS_WITHDRAWN = 5] = "PROPOSAL_STATUS_WITHDRAWN", s[s.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(U || (e.ProposalStatus = U = {}));
  function w(s) {
    switch (s) {
      case 0:
      case "PROPOSAL_STATUS_UNSPECIFIED":
        return U.PROPOSAL_STATUS_UNSPECIFIED;
      case 1:
      case "PROPOSAL_STATUS_SUBMITTED":
        return U.PROPOSAL_STATUS_SUBMITTED;
      case 2:
      case "PROPOSAL_STATUS_ACCEPTED":
        return U.PROPOSAL_STATUS_ACCEPTED;
      case 3:
      case "PROPOSAL_STATUS_REJECTED":
        return U.PROPOSAL_STATUS_REJECTED;
      case 4:
      case "PROPOSAL_STATUS_ABORTED":
        return U.PROPOSAL_STATUS_ABORTED;
      case 5:
      case "PROPOSAL_STATUS_WITHDRAWN":
        return U.PROPOSAL_STATUS_WITHDRAWN;
      case -1:
      case "UNRECOGNIZED":
      default:
        return U.UNRECOGNIZED;
    }
  }
  e.proposalStatusFromJSON = w;
  function N(s) {
    switch (s) {
      case U.PROPOSAL_STATUS_UNSPECIFIED:
        return "PROPOSAL_STATUS_UNSPECIFIED";
      case U.PROPOSAL_STATUS_SUBMITTED:
        return "PROPOSAL_STATUS_SUBMITTED";
      case U.PROPOSAL_STATUS_ACCEPTED:
        return "PROPOSAL_STATUS_ACCEPTED";
      case U.PROPOSAL_STATUS_REJECTED:
        return "PROPOSAL_STATUS_REJECTED";
      case U.PROPOSAL_STATUS_ABORTED:
        return "PROPOSAL_STATUS_ABORTED";
      case U.PROPOSAL_STATUS_WITHDRAWN:
        return "PROPOSAL_STATUS_WITHDRAWN";
      case U.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.proposalStatusToJSON = N;
  var h;
  (function(s) {
    s[s.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED = 0] = "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED", s[s.PROPOSAL_EXECUTOR_RESULT_NOT_RUN = 1] = "PROPOSAL_EXECUTOR_RESULT_NOT_RUN", s[s.PROPOSAL_EXECUTOR_RESULT_SUCCESS = 2] = "PROPOSAL_EXECUTOR_RESULT_SUCCESS", s[s.PROPOSAL_EXECUTOR_RESULT_FAILURE = 3] = "PROPOSAL_EXECUTOR_RESULT_FAILURE", s[s.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(h || (e.ProposalExecutorResult = h = {}));
  function P(s) {
    switch (s) {
      case 0:
      case "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED":
        return h.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED;
      case 1:
      case "PROPOSAL_EXECUTOR_RESULT_NOT_RUN":
        return h.PROPOSAL_EXECUTOR_RESULT_NOT_RUN;
      case 2:
      case "PROPOSAL_EXECUTOR_RESULT_SUCCESS":
        return h.PROPOSAL_EXECUTOR_RESULT_SUCCESS;
      case 3:
      case "PROPOSAL_EXECUTOR_RESULT_FAILURE":
        return h.PROPOSAL_EXECUTOR_RESULT_FAILURE;
      case -1:
      case "UNRECOGNIZED":
      default:
        return h.UNRECOGNIZED;
    }
  }
  e.proposalExecutorResultFromJSON = P;
  function b(s) {
    switch (s) {
      case h.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED:
        return "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED";
      case h.PROPOSAL_EXECUTOR_RESULT_NOT_RUN:
        return "PROPOSAL_EXECUTOR_RESULT_NOT_RUN";
      case h.PROPOSAL_EXECUTOR_RESULT_SUCCESS:
        return "PROPOSAL_EXECUTOR_RESULT_SUCCESS";
      case h.PROPOSAL_EXECUTOR_RESULT_FAILURE:
        return "PROPOSAL_EXECUTOR_RESULT_FAILURE";
      case h.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.proposalExecutorResultToJSON = b;
  function c() {
    return {
      address: "",
      weight: "",
      metadata: "",
      addedAt: n.Timestamp.fromPartial({})
    };
  }
  e.Member = {
    typeUrl: "/cosmos.group.v1.Member",
    encode(s, u = i.BinaryWriter.create()) {
      return s.address !== "" && u.uint32(10).string(s.address), s.weight !== "" && u.uint32(18).string(s.weight), s.metadata !== "" && u.uint32(26).string(s.metadata), s.addedAt !== void 0 && n.Timestamp.encode(s.addedAt, u.uint32(34).fork()).ldelim(), u;
    },
    decode(s, u) {
      const A = s instanceof i.BinaryReader ? s : new i.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = c();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.address = A.string();
            break;
          case 2:
            v.weight = A.string();
            break;
          case 3:
            v.metadata = A.string();
            break;
          case 4:
            v.addedAt = n.Timestamp.decode(A, A.uint32());
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = c();
      return (0, f.isSet)(s.address) && (u.address = String(s.address)), (0, f.isSet)(s.weight) && (u.weight = String(s.weight)), (0, f.isSet)(s.metadata) && (u.metadata = String(s.metadata)), (0, f.isSet)(s.addedAt) && (u.addedAt = (0, f.fromJsonTimestamp)(s.addedAt)), u;
    },
    toJSON(s) {
      const u = {};
      return s.address !== void 0 && (u.address = s.address), s.weight !== void 0 && (u.weight = s.weight), s.metadata !== void 0 && (u.metadata = s.metadata), s.addedAt !== void 0 && (u.addedAt = (0, f.fromTimestamp)(s.addedAt).toISOString()), u;
    },
    fromPartial(s) {
      const u = c();
      return u.address = s.address ?? "", u.weight = s.weight ?? "", u.metadata = s.metadata ?? "", s.addedAt !== void 0 && s.addedAt !== null && (u.addedAt = n.Timestamp.fromPartial(s.addedAt)), u;
    }
  };
  function l() {
    return {
      address: "",
      weight: "",
      metadata: ""
    };
  }
  e.MemberRequest = {
    typeUrl: "/cosmos.group.v1.MemberRequest",
    encode(s, u = i.BinaryWriter.create()) {
      return s.address !== "" && u.uint32(10).string(s.address), s.weight !== "" && u.uint32(18).string(s.weight), s.metadata !== "" && u.uint32(26).string(s.metadata), u;
    },
    decode(s, u) {
      const A = s instanceof i.BinaryReader ? s : new i.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = l();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.address = A.string();
            break;
          case 2:
            v.weight = A.string();
            break;
          case 3:
            v.metadata = A.string();
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = l();
      return (0, f.isSet)(s.address) && (u.address = String(s.address)), (0, f.isSet)(s.weight) && (u.weight = String(s.weight)), (0, f.isSet)(s.metadata) && (u.metadata = String(s.metadata)), u;
    },
    toJSON(s) {
      const u = {};
      return s.address !== void 0 && (u.address = s.address), s.weight !== void 0 && (u.weight = s.weight), s.metadata !== void 0 && (u.metadata = s.metadata), u;
    },
    fromPartial(s) {
      const u = l();
      return u.address = s.address ?? "", u.weight = s.weight ?? "", u.metadata = s.metadata ?? "", u;
    }
  };
  function y() {
    return {
      threshold: "",
      windows: void 0
    };
  }
  e.ThresholdDecisionPolicy = {
    typeUrl: "/cosmos.group.v1.ThresholdDecisionPolicy",
    encode(s, u = i.BinaryWriter.create()) {
      return s.threshold !== "" && u.uint32(10).string(s.threshold), s.windows !== void 0 && e.DecisionPolicyWindows.encode(s.windows, u.uint32(18).fork()).ldelim(), u;
    },
    decode(s, u) {
      const A = s instanceof i.BinaryReader ? s : new i.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = y();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.threshold = A.string();
            break;
          case 2:
            v.windows = e.DecisionPolicyWindows.decode(A, A.uint32());
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = y();
      return (0, f.isSet)(s.threshold) && (u.threshold = String(s.threshold)), (0, f.isSet)(s.windows) && (u.windows = e.DecisionPolicyWindows.fromJSON(s.windows)), u;
    },
    toJSON(s) {
      const u = {};
      return s.threshold !== void 0 && (u.threshold = s.threshold), s.windows !== void 0 && (u.windows = s.windows ? e.DecisionPolicyWindows.toJSON(s.windows) : void 0), u;
    },
    fromPartial(s) {
      const u = y();
      return u.threshold = s.threshold ?? "", s.windows !== void 0 && s.windows !== null && (u.windows = e.DecisionPolicyWindows.fromPartial(s.windows)), u;
    }
  };
  function E() {
    return {
      percentage: "",
      windows: void 0
    };
  }
  e.PercentageDecisionPolicy = {
    typeUrl: "/cosmos.group.v1.PercentageDecisionPolicy",
    encode(s, u = i.BinaryWriter.create()) {
      return s.percentage !== "" && u.uint32(10).string(s.percentage), s.windows !== void 0 && e.DecisionPolicyWindows.encode(s.windows, u.uint32(18).fork()).ldelim(), u;
    },
    decode(s, u) {
      const A = s instanceof i.BinaryReader ? s : new i.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = E();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.percentage = A.string();
            break;
          case 2:
            v.windows = e.DecisionPolicyWindows.decode(A, A.uint32());
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = E();
      return (0, f.isSet)(s.percentage) && (u.percentage = String(s.percentage)), (0, f.isSet)(s.windows) && (u.windows = e.DecisionPolicyWindows.fromJSON(s.windows)), u;
    },
    toJSON(s) {
      const u = {};
      return s.percentage !== void 0 && (u.percentage = s.percentage), s.windows !== void 0 && (u.windows = s.windows ? e.DecisionPolicyWindows.toJSON(s.windows) : void 0), u;
    },
    fromPartial(s) {
      const u = E();
      return u.percentage = s.percentage ?? "", s.windows !== void 0 && s.windows !== null && (u.windows = e.DecisionPolicyWindows.fromPartial(s.windows)), u;
    }
  };
  function J() {
    return {
      votingPeriod: r.Duration.fromPartial({}),
      minExecutionPeriod: r.Duration.fromPartial({})
    };
  }
  e.DecisionPolicyWindows = {
    typeUrl: "/cosmos.group.v1.DecisionPolicyWindows",
    encode(s, u = i.BinaryWriter.create()) {
      return s.votingPeriod !== void 0 && r.Duration.encode(s.votingPeriod, u.uint32(10).fork()).ldelim(), s.minExecutionPeriod !== void 0 && r.Duration.encode(s.minExecutionPeriod, u.uint32(18).fork()).ldelim(), u;
    },
    decode(s, u) {
      const A = s instanceof i.BinaryReader ? s : new i.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = J();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.votingPeriod = r.Duration.decode(A, A.uint32());
            break;
          case 2:
            v.minExecutionPeriod = r.Duration.decode(A, A.uint32());
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = J();
      return (0, f.isSet)(s.votingPeriod) && (u.votingPeriod = r.Duration.fromJSON(s.votingPeriod)), (0, f.isSet)(s.minExecutionPeriod) && (u.minExecutionPeriod = r.Duration.fromJSON(s.minExecutionPeriod)), u;
    },
    toJSON(s) {
      const u = {};
      return s.votingPeriod !== void 0 && (u.votingPeriod = s.votingPeriod ? r.Duration.toJSON(s.votingPeriod) : void 0), s.minExecutionPeriod !== void 0 && (u.minExecutionPeriod = s.minExecutionPeriod ? r.Duration.toJSON(s.minExecutionPeriod) : void 0), u;
    },
    fromPartial(s) {
      const u = J();
      return s.votingPeriod !== void 0 && s.votingPeriod !== null && (u.votingPeriod = r.Duration.fromPartial(s.votingPeriod)), s.minExecutionPeriod !== void 0 && s.minExecutionPeriod !== null && (u.minExecutionPeriod = r.Duration.fromPartial(s.minExecutionPeriod)), u;
    }
  };
  function _() {
    return {
      id: BigInt(0),
      admin: "",
      metadata: "",
      version: BigInt(0),
      totalWeight: "",
      createdAt: n.Timestamp.fromPartial({})
    };
  }
  e.GroupInfo = {
    typeUrl: "/cosmos.group.v1.GroupInfo",
    encode(s, u = i.BinaryWriter.create()) {
      return s.id !== BigInt(0) && u.uint32(8).uint64(s.id), s.admin !== "" && u.uint32(18).string(s.admin), s.metadata !== "" && u.uint32(26).string(s.metadata), s.version !== BigInt(0) && u.uint32(32).uint64(s.version), s.totalWeight !== "" && u.uint32(42).string(s.totalWeight), s.createdAt !== void 0 && n.Timestamp.encode(s.createdAt, u.uint32(50).fork()).ldelim(), u;
    },
    decode(s, u) {
      const A = s instanceof i.BinaryReader ? s : new i.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = _();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.id = A.uint64();
            break;
          case 2:
            v.admin = A.string();
            break;
          case 3:
            v.metadata = A.string();
            break;
          case 4:
            v.version = A.uint64();
            break;
          case 5:
            v.totalWeight = A.string();
            break;
          case 6:
            v.createdAt = n.Timestamp.decode(A, A.uint32());
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = _();
      return (0, f.isSet)(s.id) && (u.id = BigInt(s.id.toString())), (0, f.isSet)(s.admin) && (u.admin = String(s.admin)), (0, f.isSet)(s.metadata) && (u.metadata = String(s.metadata)), (0, f.isSet)(s.version) && (u.version = BigInt(s.version.toString())), (0, f.isSet)(s.totalWeight) && (u.totalWeight = String(s.totalWeight)), (0, f.isSet)(s.createdAt) && (u.createdAt = (0, f.fromJsonTimestamp)(s.createdAt)), u;
    },
    toJSON(s) {
      const u = {};
      return s.id !== void 0 && (u.id = (s.id || BigInt(0)).toString()), s.admin !== void 0 && (u.admin = s.admin), s.metadata !== void 0 && (u.metadata = s.metadata), s.version !== void 0 && (u.version = (s.version || BigInt(0)).toString()), s.totalWeight !== void 0 && (u.totalWeight = s.totalWeight), s.createdAt !== void 0 && (u.createdAt = (0, f.fromTimestamp)(s.createdAt).toISOString()), u;
    },
    fromPartial(s) {
      const u = _();
      return s.id !== void 0 && s.id !== null && (u.id = BigInt(s.id.toString())), u.admin = s.admin ?? "", u.metadata = s.metadata ?? "", s.version !== void 0 && s.version !== null && (u.version = BigInt(s.version.toString())), u.totalWeight = s.totalWeight ?? "", s.createdAt !== void 0 && s.createdAt !== null && (u.createdAt = n.Timestamp.fromPartial(s.createdAt)), u;
    }
  };
  function V() {
    return {
      groupId: BigInt(0),
      member: void 0
    };
  }
  e.GroupMember = {
    typeUrl: "/cosmos.group.v1.GroupMember",
    encode(s, u = i.BinaryWriter.create()) {
      return s.groupId !== BigInt(0) && u.uint32(8).uint64(s.groupId), s.member !== void 0 && e.Member.encode(s.member, u.uint32(18).fork()).ldelim(), u;
    },
    decode(s, u) {
      const A = s instanceof i.BinaryReader ? s : new i.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = V();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.groupId = A.uint64();
            break;
          case 2:
            v.member = e.Member.decode(A, A.uint32());
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = V();
      return (0, f.isSet)(s.groupId) && (u.groupId = BigInt(s.groupId.toString())), (0, f.isSet)(s.member) && (u.member = e.Member.fromJSON(s.member)), u;
    },
    toJSON(s) {
      const u = {};
      return s.groupId !== void 0 && (u.groupId = (s.groupId || BigInt(0)).toString()), s.member !== void 0 && (u.member = s.member ? e.Member.toJSON(s.member) : void 0), u;
    },
    fromPartial(s) {
      const u = V();
      return s.groupId !== void 0 && s.groupId !== null && (u.groupId = BigInt(s.groupId.toString())), s.member !== void 0 && s.member !== null && (u.member = e.Member.fromPartial(s.member)), u;
    }
  };
  function o() {
    return {
      address: "",
      groupId: BigInt(0),
      admin: "",
      metadata: "",
      version: BigInt(0),
      decisionPolicy: void 0,
      createdAt: n.Timestamp.fromPartial({})
    };
  }
  e.GroupPolicyInfo = {
    typeUrl: "/cosmos.group.v1.GroupPolicyInfo",
    encode(s, u = i.BinaryWriter.create()) {
      return s.address !== "" && u.uint32(10).string(s.address), s.groupId !== BigInt(0) && u.uint32(16).uint64(s.groupId), s.admin !== "" && u.uint32(26).string(s.admin), s.metadata !== "" && u.uint32(34).string(s.metadata), s.version !== BigInt(0) && u.uint32(40).uint64(s.version), s.decisionPolicy !== void 0 && t.Any.encode(s.decisionPolicy, u.uint32(50).fork()).ldelim(), s.createdAt !== void 0 && n.Timestamp.encode(s.createdAt, u.uint32(58).fork()).ldelim(), u;
    },
    decode(s, u) {
      const A = s instanceof i.BinaryReader ? s : new i.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = o();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.address = A.string();
            break;
          case 2:
            v.groupId = A.uint64();
            break;
          case 3:
            v.admin = A.string();
            break;
          case 4:
            v.metadata = A.string();
            break;
          case 5:
            v.version = A.uint64();
            break;
          case 6:
            v.decisionPolicy = t.Any.decode(A, A.uint32());
            break;
          case 7:
            v.createdAt = n.Timestamp.decode(A, A.uint32());
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = o();
      return (0, f.isSet)(s.address) && (u.address = String(s.address)), (0, f.isSet)(s.groupId) && (u.groupId = BigInt(s.groupId.toString())), (0, f.isSet)(s.admin) && (u.admin = String(s.admin)), (0, f.isSet)(s.metadata) && (u.metadata = String(s.metadata)), (0, f.isSet)(s.version) && (u.version = BigInt(s.version.toString())), (0, f.isSet)(s.decisionPolicy) && (u.decisionPolicy = t.Any.fromJSON(s.decisionPolicy)), (0, f.isSet)(s.createdAt) && (u.createdAt = (0, f.fromJsonTimestamp)(s.createdAt)), u;
    },
    toJSON(s) {
      const u = {};
      return s.address !== void 0 && (u.address = s.address), s.groupId !== void 0 && (u.groupId = (s.groupId || BigInt(0)).toString()), s.admin !== void 0 && (u.admin = s.admin), s.metadata !== void 0 && (u.metadata = s.metadata), s.version !== void 0 && (u.version = (s.version || BigInt(0)).toString()), s.decisionPolicy !== void 0 && (u.decisionPolicy = s.decisionPolicy ? t.Any.toJSON(s.decisionPolicy) : void 0), s.createdAt !== void 0 && (u.createdAt = (0, f.fromTimestamp)(s.createdAt).toISOString()), u;
    },
    fromPartial(s) {
      const u = o();
      return u.address = s.address ?? "", s.groupId !== void 0 && s.groupId !== null && (u.groupId = BigInt(s.groupId.toString())), u.admin = s.admin ?? "", u.metadata = s.metadata ?? "", s.version !== void 0 && s.version !== null && (u.version = BigInt(s.version.toString())), s.decisionPolicy !== void 0 && s.decisionPolicy !== null && (u.decisionPolicy = t.Any.fromPartial(s.decisionPolicy)), s.createdAt !== void 0 && s.createdAt !== null && (u.createdAt = n.Timestamp.fromPartial(s.createdAt)), u;
    }
  };
  function p() {
    return {
      id: BigInt(0),
      groupPolicyAddress: "",
      metadata: "",
      proposers: [],
      submitTime: n.Timestamp.fromPartial({}),
      groupVersion: BigInt(0),
      groupPolicyVersion: BigInt(0),
      status: 0,
      finalTallyResult: e.TallyResult.fromPartial({}),
      votingPeriodEnd: n.Timestamp.fromPartial({}),
      executorResult: 0,
      messages: [],
      title: "",
      summary: ""
    };
  }
  e.Proposal = {
    typeUrl: "/cosmos.group.v1.Proposal",
    encode(s, u = i.BinaryWriter.create()) {
      s.id !== BigInt(0) && u.uint32(8).uint64(s.id), s.groupPolicyAddress !== "" && u.uint32(18).string(s.groupPolicyAddress), s.metadata !== "" && u.uint32(26).string(s.metadata);
      for (const A of s.proposers)
        u.uint32(34).string(A);
      s.submitTime !== void 0 && n.Timestamp.encode(s.submitTime, u.uint32(42).fork()).ldelim(), s.groupVersion !== BigInt(0) && u.uint32(48).uint64(s.groupVersion), s.groupPolicyVersion !== BigInt(0) && u.uint32(56).uint64(s.groupPolicyVersion), s.status !== 0 && u.uint32(64).int32(s.status), s.finalTallyResult !== void 0 && e.TallyResult.encode(s.finalTallyResult, u.uint32(74).fork()).ldelim(), s.votingPeriodEnd !== void 0 && n.Timestamp.encode(s.votingPeriodEnd, u.uint32(82).fork()).ldelim(), s.executorResult !== 0 && u.uint32(88).int32(s.executorResult);
      for (const A of s.messages)
        t.Any.encode(A, u.uint32(98).fork()).ldelim();
      return s.title !== "" && u.uint32(106).string(s.title), s.summary !== "" && u.uint32(114).string(s.summary), u;
    },
    decode(s, u) {
      const A = s instanceof i.BinaryReader ? s : new i.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = p();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.id = A.uint64();
            break;
          case 2:
            v.groupPolicyAddress = A.string();
            break;
          case 3:
            v.metadata = A.string();
            break;
          case 4:
            v.proposers.push(A.string());
            break;
          case 5:
            v.submitTime = n.Timestamp.decode(A, A.uint32());
            break;
          case 6:
            v.groupVersion = A.uint64();
            break;
          case 7:
            v.groupPolicyVersion = A.uint64();
            break;
          case 8:
            v.status = A.int32();
            break;
          case 9:
            v.finalTallyResult = e.TallyResult.decode(A, A.uint32());
            break;
          case 10:
            v.votingPeriodEnd = n.Timestamp.decode(A, A.uint32());
            break;
          case 11:
            v.executorResult = A.int32();
            break;
          case 12:
            v.messages.push(t.Any.decode(A, A.uint32()));
            break;
          case 13:
            v.title = A.string();
            break;
          case 14:
            v.summary = A.string();
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = p();
      return (0, f.isSet)(s.id) && (u.id = BigInt(s.id.toString())), (0, f.isSet)(s.groupPolicyAddress) && (u.groupPolicyAddress = String(s.groupPolicyAddress)), (0, f.isSet)(s.metadata) && (u.metadata = String(s.metadata)), Array.isArray(s == null ? void 0 : s.proposers) && (u.proposers = s.proposers.map((A) => String(A))), (0, f.isSet)(s.submitTime) && (u.submitTime = (0, f.fromJsonTimestamp)(s.submitTime)), (0, f.isSet)(s.groupVersion) && (u.groupVersion = BigInt(s.groupVersion.toString())), (0, f.isSet)(s.groupPolicyVersion) && (u.groupPolicyVersion = BigInt(s.groupPolicyVersion.toString())), (0, f.isSet)(s.status) && (u.status = w(s.status)), (0, f.isSet)(s.finalTallyResult) && (u.finalTallyResult = e.TallyResult.fromJSON(s.finalTallyResult)), (0, f.isSet)(s.votingPeriodEnd) && (u.votingPeriodEnd = (0, f.fromJsonTimestamp)(s.votingPeriodEnd)), (0, f.isSet)(s.executorResult) && (u.executorResult = P(s.executorResult)), Array.isArray(s == null ? void 0 : s.messages) && (u.messages = s.messages.map((A) => t.Any.fromJSON(A))), (0, f.isSet)(s.title) && (u.title = String(s.title)), (0, f.isSet)(s.summary) && (u.summary = String(s.summary)), u;
    },
    toJSON(s) {
      const u = {};
      return s.id !== void 0 && (u.id = (s.id || BigInt(0)).toString()), s.groupPolicyAddress !== void 0 && (u.groupPolicyAddress = s.groupPolicyAddress), s.metadata !== void 0 && (u.metadata = s.metadata), s.proposers ? u.proposers = s.proposers.map((A) => A) : u.proposers = [], s.submitTime !== void 0 && (u.submitTime = (0, f.fromTimestamp)(s.submitTime).toISOString()), s.groupVersion !== void 0 && (u.groupVersion = (s.groupVersion || BigInt(0)).toString()), s.groupPolicyVersion !== void 0 && (u.groupPolicyVersion = (s.groupPolicyVersion || BigInt(0)).toString()), s.status !== void 0 && (u.status = N(s.status)), s.finalTallyResult !== void 0 && (u.finalTallyResult = s.finalTallyResult ? e.TallyResult.toJSON(s.finalTallyResult) : void 0), s.votingPeriodEnd !== void 0 && (u.votingPeriodEnd = (0, f.fromTimestamp)(s.votingPeriodEnd).toISOString()), s.executorResult !== void 0 && (u.executorResult = b(s.executorResult)), s.messages ? u.messages = s.messages.map((A) => A ? t.Any.toJSON(A) : void 0) : u.messages = [], s.title !== void 0 && (u.title = s.title), s.summary !== void 0 && (u.summary = s.summary), u;
    },
    fromPartial(s) {
      var A, R;
      const u = p();
      return s.id !== void 0 && s.id !== null && (u.id = BigInt(s.id.toString())), u.groupPolicyAddress = s.groupPolicyAddress ?? "", u.metadata = s.metadata ?? "", u.proposers = ((A = s.proposers) == null ? void 0 : A.map((v) => v)) || [], s.submitTime !== void 0 && s.submitTime !== null && (u.submitTime = n.Timestamp.fromPartial(s.submitTime)), s.groupVersion !== void 0 && s.groupVersion !== null && (u.groupVersion = BigInt(s.groupVersion.toString())), s.groupPolicyVersion !== void 0 && s.groupPolicyVersion !== null && (u.groupPolicyVersion = BigInt(s.groupPolicyVersion.toString())), u.status = s.status ?? 0, s.finalTallyResult !== void 0 && s.finalTallyResult !== null && (u.finalTallyResult = e.TallyResult.fromPartial(s.finalTallyResult)), s.votingPeriodEnd !== void 0 && s.votingPeriodEnd !== null && (u.votingPeriodEnd = n.Timestamp.fromPartial(s.votingPeriodEnd)), u.executorResult = s.executorResult ?? 0, u.messages = ((R = s.messages) == null ? void 0 : R.map((v) => t.Any.fromPartial(v))) || [], u.title = s.title ?? "", u.summary = s.summary ?? "", u;
    }
  };
  function I() {
    return {
      yesCount: "",
      abstainCount: "",
      noCount: "",
      noWithVetoCount: ""
    };
  }
  e.TallyResult = {
    typeUrl: "/cosmos.group.v1.TallyResult",
    encode(s, u = i.BinaryWriter.create()) {
      return s.yesCount !== "" && u.uint32(10).string(s.yesCount), s.abstainCount !== "" && u.uint32(18).string(s.abstainCount), s.noCount !== "" && u.uint32(26).string(s.noCount), s.noWithVetoCount !== "" && u.uint32(34).string(s.noWithVetoCount), u;
    },
    decode(s, u) {
      const A = s instanceof i.BinaryReader ? s : new i.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = I();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.yesCount = A.string();
            break;
          case 2:
            v.abstainCount = A.string();
            break;
          case 3:
            v.noCount = A.string();
            break;
          case 4:
            v.noWithVetoCount = A.string();
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = I();
      return (0, f.isSet)(s.yesCount) && (u.yesCount = String(s.yesCount)), (0, f.isSet)(s.abstainCount) && (u.abstainCount = String(s.abstainCount)), (0, f.isSet)(s.noCount) && (u.noCount = String(s.noCount)), (0, f.isSet)(s.noWithVetoCount) && (u.noWithVetoCount = String(s.noWithVetoCount)), u;
    },
    toJSON(s) {
      const u = {};
      return s.yesCount !== void 0 && (u.yesCount = s.yesCount), s.abstainCount !== void 0 && (u.abstainCount = s.abstainCount), s.noCount !== void 0 && (u.noCount = s.noCount), s.noWithVetoCount !== void 0 && (u.noWithVetoCount = s.noWithVetoCount), u;
    },
    fromPartial(s) {
      const u = I();
      return u.yesCount = s.yesCount ?? "", u.abstainCount = s.abstainCount ?? "", u.noCount = s.noCount ?? "", u.noWithVetoCount = s.noWithVetoCount ?? "", u;
    }
  };
  function q() {
    return {
      proposalId: BigInt(0),
      voter: "",
      option: 0,
      metadata: "",
      submitTime: n.Timestamp.fromPartial({})
    };
  }
  e.Vote = {
    typeUrl: "/cosmos.group.v1.Vote",
    encode(s, u = i.BinaryWriter.create()) {
      return s.proposalId !== BigInt(0) && u.uint32(8).uint64(s.proposalId), s.voter !== "" && u.uint32(18).string(s.voter), s.option !== 0 && u.uint32(24).int32(s.option), s.metadata !== "" && u.uint32(34).string(s.metadata), s.submitTime !== void 0 && n.Timestamp.encode(s.submitTime, u.uint32(42).fork()).ldelim(), u;
    },
    decode(s, u) {
      const A = s instanceof i.BinaryReader ? s : new i.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = q();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.proposalId = A.uint64();
            break;
          case 2:
            v.voter = A.string();
            break;
          case 3:
            v.option = A.int32();
            break;
          case 4:
            v.metadata = A.string();
            break;
          case 5:
            v.submitTime = n.Timestamp.decode(A, A.uint32());
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = q();
      return (0, f.isSet)(s.proposalId) && (u.proposalId = BigInt(s.proposalId.toString())), (0, f.isSet)(s.voter) && (u.voter = String(s.voter)), (0, f.isSet)(s.option) && (u.option = C(s.option)), (0, f.isSet)(s.metadata) && (u.metadata = String(s.metadata)), (0, f.isSet)(s.submitTime) && (u.submitTime = (0, f.fromJsonTimestamp)(s.submitTime)), u;
    },
    toJSON(s) {
      const u = {};
      return s.proposalId !== void 0 && (u.proposalId = (s.proposalId || BigInt(0)).toString()), s.voter !== void 0 && (u.voter = s.voter), s.option !== void 0 && (u.option = T(s.option)), s.metadata !== void 0 && (u.metadata = s.metadata), s.submitTime !== void 0 && (u.submitTime = (0, f.fromTimestamp)(s.submitTime).toISOString()), u;
    },
    fromPartial(s) {
      const u = q();
      return s.proposalId !== void 0 && s.proposalId !== null && (u.proposalId = BigInt(s.proposalId.toString())), u.voter = s.voter ?? "", u.option = s.option ?? 0, u.metadata = s.metadata ?? "", s.submitTime !== void 0 && s.submitTime !== null && (u.submitTime = n.Timestamp.fromPartial(s.submitTime)), u;
    }
  };
})(al);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgLeaveGroupResponse = e.MsgLeaveGroup = e.MsgExecResponse = e.MsgExec = e.MsgVoteResponse = e.MsgVote = e.MsgWithdrawProposalResponse = e.MsgWithdrawProposal = e.MsgSubmitProposalResponse = e.MsgSubmitProposal = e.MsgUpdateGroupPolicyMetadataResponse = e.MsgUpdateGroupPolicyMetadata = e.MsgUpdateGroupPolicyDecisionPolicyResponse = e.MsgUpdateGroupPolicyDecisionPolicy = e.MsgCreateGroupWithPolicyResponse = e.MsgCreateGroupWithPolicy = e.MsgUpdateGroupPolicyAdminResponse = e.MsgUpdateGroupPolicyAdmin = e.MsgCreateGroupPolicyResponse = e.MsgCreateGroupPolicy = e.MsgUpdateGroupMetadataResponse = e.MsgUpdateGroupMetadata = e.MsgUpdateGroupAdminResponse = e.MsgUpdateGroupAdmin = e.MsgUpdateGroupMembersResponse = e.MsgUpdateGroupMembers = e.MsgCreateGroupResponse = e.MsgCreateGroup = e.execToJSON = e.execFromJSON = e.Exec = e.protobufPackage = void 0;
  const n = al, r = Be, t = re, i = ie;
  e.protobufPackage = "cosmos.group.v1";
  var f;
  (function(S) {
    S[S.EXEC_UNSPECIFIED = 0] = "EXEC_UNSPECIFIED", S[S.EXEC_TRY = 1] = "EXEC_TRY", S[S.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(f || (e.Exec = f = {}));
  function k(S) {
    switch (S) {
      case 0:
      case "EXEC_UNSPECIFIED":
        return f.EXEC_UNSPECIFIED;
      case 1:
      case "EXEC_TRY":
        return f.EXEC_TRY;
      case -1:
      case "UNRECOGNIZED":
      default:
        return f.UNRECOGNIZED;
    }
  }
  e.execFromJSON = k;
  function C(S) {
    switch (S) {
      case f.EXEC_UNSPECIFIED:
        return "EXEC_UNSPECIFIED";
      case f.EXEC_TRY:
        return "EXEC_TRY";
      case f.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.execToJSON = C;
  function T() {
    return {
      admin: "",
      members: [],
      metadata: ""
    };
  }
  e.MsgCreateGroup = {
    typeUrl: "/cosmos.group.v1.MsgCreateGroup",
    encode(S, O = t.BinaryWriter.create()) {
      S.admin !== "" && O.uint32(10).string(S.admin);
      for (const Q of S.members)
        n.MemberRequest.encode(Q, O.uint32(18).fork()).ldelim();
      return S.metadata !== "" && O.uint32(26).string(S.metadata), O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = T();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          case 1:
            L.admin = Q.string();
            break;
          case 2:
            L.members.push(n.MemberRequest.decode(Q, Q.uint32()));
            break;
          case 3:
            L.metadata = Q.string();
            break;
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      const O = T();
      return (0, i.isSet)(S.admin) && (O.admin = String(S.admin)), Array.isArray(S == null ? void 0 : S.members) && (O.members = S.members.map((Q) => n.MemberRequest.fromJSON(Q))), (0, i.isSet)(S.metadata) && (O.metadata = String(S.metadata)), O;
    },
    toJSON(S) {
      const O = {};
      return S.admin !== void 0 && (O.admin = S.admin), S.members ? O.members = S.members.map((Q) => Q ? n.MemberRequest.toJSON(Q) : void 0) : O.members = [], S.metadata !== void 0 && (O.metadata = S.metadata), O;
    },
    fromPartial(S) {
      var Q;
      const O = T();
      return O.admin = S.admin ?? "", O.members = ((Q = S.members) == null ? void 0 : Q.map((G) => n.MemberRequest.fromPartial(G))) || [], O.metadata = S.metadata ?? "", O;
    }
  };
  function U() {
    return {
      groupId: BigInt(0)
    };
  }
  e.MsgCreateGroupResponse = {
    typeUrl: "/cosmos.group.v1.MsgCreateGroupResponse",
    encode(S, O = t.BinaryWriter.create()) {
      return S.groupId !== BigInt(0) && O.uint32(8).uint64(S.groupId), O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = U();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          case 1:
            L.groupId = Q.uint64();
            break;
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      const O = U();
      return (0, i.isSet)(S.groupId) && (O.groupId = BigInt(S.groupId.toString())), O;
    },
    toJSON(S) {
      const O = {};
      return S.groupId !== void 0 && (O.groupId = (S.groupId || BigInt(0)).toString()), O;
    },
    fromPartial(S) {
      const O = U();
      return S.groupId !== void 0 && S.groupId !== null && (O.groupId = BigInt(S.groupId.toString())), O;
    }
  };
  function w() {
    return {
      admin: "",
      groupId: BigInt(0),
      memberUpdates: []
    };
  }
  e.MsgUpdateGroupMembers = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupMembers",
    encode(S, O = t.BinaryWriter.create()) {
      S.admin !== "" && O.uint32(10).string(S.admin), S.groupId !== BigInt(0) && O.uint32(16).uint64(S.groupId);
      for (const Q of S.memberUpdates)
        n.MemberRequest.encode(Q, O.uint32(26).fork()).ldelim();
      return O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = w();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          case 1:
            L.admin = Q.string();
            break;
          case 2:
            L.groupId = Q.uint64();
            break;
          case 3:
            L.memberUpdates.push(n.MemberRequest.decode(Q, Q.uint32()));
            break;
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      const O = w();
      return (0, i.isSet)(S.admin) && (O.admin = String(S.admin)), (0, i.isSet)(S.groupId) && (O.groupId = BigInt(S.groupId.toString())), Array.isArray(S == null ? void 0 : S.memberUpdates) && (O.memberUpdates = S.memberUpdates.map((Q) => n.MemberRequest.fromJSON(Q))), O;
    },
    toJSON(S) {
      const O = {};
      return S.admin !== void 0 && (O.admin = S.admin), S.groupId !== void 0 && (O.groupId = (S.groupId || BigInt(0)).toString()), S.memberUpdates ? O.memberUpdates = S.memberUpdates.map((Q) => Q ? n.MemberRequest.toJSON(Q) : void 0) : O.memberUpdates = [], O;
    },
    fromPartial(S) {
      var Q;
      const O = w();
      return O.admin = S.admin ?? "", S.groupId !== void 0 && S.groupId !== null && (O.groupId = BigInt(S.groupId.toString())), O.memberUpdates = ((Q = S.memberUpdates) == null ? void 0 : Q.map((G) => n.MemberRequest.fromPartial(G))) || [], O;
    }
  };
  function N() {
    return {};
  }
  e.MsgUpdateGroupMembersResponse = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupMembersResponse",
    encode(S, O = t.BinaryWriter.create()) {
      return O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = N();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      return N();
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return N();
    }
  };
  function h() {
    return {
      admin: "",
      groupId: BigInt(0),
      newAdmin: ""
    };
  }
  e.MsgUpdateGroupAdmin = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupAdmin",
    encode(S, O = t.BinaryWriter.create()) {
      return S.admin !== "" && O.uint32(10).string(S.admin), S.groupId !== BigInt(0) && O.uint32(16).uint64(S.groupId), S.newAdmin !== "" && O.uint32(26).string(S.newAdmin), O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = h();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          case 1:
            L.admin = Q.string();
            break;
          case 2:
            L.groupId = Q.uint64();
            break;
          case 3:
            L.newAdmin = Q.string();
            break;
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      const O = h();
      return (0, i.isSet)(S.admin) && (O.admin = String(S.admin)), (0, i.isSet)(S.groupId) && (O.groupId = BigInt(S.groupId.toString())), (0, i.isSet)(S.newAdmin) && (O.newAdmin = String(S.newAdmin)), O;
    },
    toJSON(S) {
      const O = {};
      return S.admin !== void 0 && (O.admin = S.admin), S.groupId !== void 0 && (O.groupId = (S.groupId || BigInt(0)).toString()), S.newAdmin !== void 0 && (O.newAdmin = S.newAdmin), O;
    },
    fromPartial(S) {
      const O = h();
      return O.admin = S.admin ?? "", S.groupId !== void 0 && S.groupId !== null && (O.groupId = BigInt(S.groupId.toString())), O.newAdmin = S.newAdmin ?? "", O;
    }
  };
  function P() {
    return {};
  }
  e.MsgUpdateGroupAdminResponse = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupAdminResponse",
    encode(S, O = t.BinaryWriter.create()) {
      return O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = P();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      return P();
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return P();
    }
  };
  function b() {
    return {
      admin: "",
      groupId: BigInt(0),
      metadata: ""
    };
  }
  e.MsgUpdateGroupMetadata = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupMetadata",
    encode(S, O = t.BinaryWriter.create()) {
      return S.admin !== "" && O.uint32(10).string(S.admin), S.groupId !== BigInt(0) && O.uint32(16).uint64(S.groupId), S.metadata !== "" && O.uint32(26).string(S.metadata), O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = b();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          case 1:
            L.admin = Q.string();
            break;
          case 2:
            L.groupId = Q.uint64();
            break;
          case 3:
            L.metadata = Q.string();
            break;
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      const O = b();
      return (0, i.isSet)(S.admin) && (O.admin = String(S.admin)), (0, i.isSet)(S.groupId) && (O.groupId = BigInt(S.groupId.toString())), (0, i.isSet)(S.metadata) && (O.metadata = String(S.metadata)), O;
    },
    toJSON(S) {
      const O = {};
      return S.admin !== void 0 && (O.admin = S.admin), S.groupId !== void 0 && (O.groupId = (S.groupId || BigInt(0)).toString()), S.metadata !== void 0 && (O.metadata = S.metadata), O;
    },
    fromPartial(S) {
      const O = b();
      return O.admin = S.admin ?? "", S.groupId !== void 0 && S.groupId !== null && (O.groupId = BigInt(S.groupId.toString())), O.metadata = S.metadata ?? "", O;
    }
  };
  function c() {
    return {};
  }
  e.MsgUpdateGroupMetadataResponse = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupMetadataResponse",
    encode(S, O = t.BinaryWriter.create()) {
      return O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = c();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      return c();
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return c();
    }
  };
  function l() {
    return {
      admin: "",
      groupId: BigInt(0),
      metadata: "",
      decisionPolicy: void 0
    };
  }
  e.MsgCreateGroupPolicy = {
    typeUrl: "/cosmos.group.v1.MsgCreateGroupPolicy",
    encode(S, O = t.BinaryWriter.create()) {
      return S.admin !== "" && O.uint32(10).string(S.admin), S.groupId !== BigInt(0) && O.uint32(16).uint64(S.groupId), S.metadata !== "" && O.uint32(26).string(S.metadata), S.decisionPolicy !== void 0 && r.Any.encode(S.decisionPolicy, O.uint32(34).fork()).ldelim(), O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = l();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          case 1:
            L.admin = Q.string();
            break;
          case 2:
            L.groupId = Q.uint64();
            break;
          case 3:
            L.metadata = Q.string();
            break;
          case 4:
            L.decisionPolicy = r.Any.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      const O = l();
      return (0, i.isSet)(S.admin) && (O.admin = String(S.admin)), (0, i.isSet)(S.groupId) && (O.groupId = BigInt(S.groupId.toString())), (0, i.isSet)(S.metadata) && (O.metadata = String(S.metadata)), (0, i.isSet)(S.decisionPolicy) && (O.decisionPolicy = r.Any.fromJSON(S.decisionPolicy)), O;
    },
    toJSON(S) {
      const O = {};
      return S.admin !== void 0 && (O.admin = S.admin), S.groupId !== void 0 && (O.groupId = (S.groupId || BigInt(0)).toString()), S.metadata !== void 0 && (O.metadata = S.metadata), S.decisionPolicy !== void 0 && (O.decisionPolicy = S.decisionPolicy ? r.Any.toJSON(S.decisionPolicy) : void 0), O;
    },
    fromPartial(S) {
      const O = l();
      return O.admin = S.admin ?? "", S.groupId !== void 0 && S.groupId !== null && (O.groupId = BigInt(S.groupId.toString())), O.metadata = S.metadata ?? "", S.decisionPolicy !== void 0 && S.decisionPolicy !== null && (O.decisionPolicy = r.Any.fromPartial(S.decisionPolicy)), O;
    }
  };
  function y() {
    return {
      address: ""
    };
  }
  e.MsgCreateGroupPolicyResponse = {
    typeUrl: "/cosmos.group.v1.MsgCreateGroupPolicyResponse",
    encode(S, O = t.BinaryWriter.create()) {
      return S.address !== "" && O.uint32(10).string(S.address), O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = y();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          case 1:
            L.address = Q.string();
            break;
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      const O = y();
      return (0, i.isSet)(S.address) && (O.address = String(S.address)), O;
    },
    toJSON(S) {
      const O = {};
      return S.address !== void 0 && (O.address = S.address), O;
    },
    fromPartial(S) {
      const O = y();
      return O.address = S.address ?? "", O;
    }
  };
  function E() {
    return {
      admin: "",
      groupPolicyAddress: "",
      newAdmin: ""
    };
  }
  e.MsgUpdateGroupPolicyAdmin = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin",
    encode(S, O = t.BinaryWriter.create()) {
      return S.admin !== "" && O.uint32(10).string(S.admin), S.groupPolicyAddress !== "" && O.uint32(18).string(S.groupPolicyAddress), S.newAdmin !== "" && O.uint32(26).string(S.newAdmin), O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = E();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          case 1:
            L.admin = Q.string();
            break;
          case 2:
            L.groupPolicyAddress = Q.string();
            break;
          case 3:
            L.newAdmin = Q.string();
            break;
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      const O = E();
      return (0, i.isSet)(S.admin) && (O.admin = String(S.admin)), (0, i.isSet)(S.groupPolicyAddress) && (O.groupPolicyAddress = String(S.groupPolicyAddress)), (0, i.isSet)(S.newAdmin) && (O.newAdmin = String(S.newAdmin)), O;
    },
    toJSON(S) {
      const O = {};
      return S.admin !== void 0 && (O.admin = S.admin), S.groupPolicyAddress !== void 0 && (O.groupPolicyAddress = S.groupPolicyAddress), S.newAdmin !== void 0 && (O.newAdmin = S.newAdmin), O;
    },
    fromPartial(S) {
      const O = E();
      return O.admin = S.admin ?? "", O.groupPolicyAddress = S.groupPolicyAddress ?? "", O.newAdmin = S.newAdmin ?? "", O;
    }
  };
  function J() {
    return {};
  }
  e.MsgUpdateGroupPolicyAdminResponse = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyAdminResponse",
    encode(S, O = t.BinaryWriter.create()) {
      return O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = J();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      return J();
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return J();
    }
  };
  function _() {
    return {
      admin: "",
      members: [],
      groupMetadata: "",
      groupPolicyMetadata: "",
      groupPolicyAsAdmin: !1,
      decisionPolicy: void 0
    };
  }
  e.MsgCreateGroupWithPolicy = {
    typeUrl: "/cosmos.group.v1.MsgCreateGroupWithPolicy",
    encode(S, O = t.BinaryWriter.create()) {
      S.admin !== "" && O.uint32(10).string(S.admin);
      for (const Q of S.members)
        n.MemberRequest.encode(Q, O.uint32(18).fork()).ldelim();
      return S.groupMetadata !== "" && O.uint32(26).string(S.groupMetadata), S.groupPolicyMetadata !== "" && O.uint32(34).string(S.groupPolicyMetadata), S.groupPolicyAsAdmin === !0 && O.uint32(40).bool(S.groupPolicyAsAdmin), S.decisionPolicy !== void 0 && r.Any.encode(S.decisionPolicy, O.uint32(50).fork()).ldelim(), O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = _();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          case 1:
            L.admin = Q.string();
            break;
          case 2:
            L.members.push(n.MemberRequest.decode(Q, Q.uint32()));
            break;
          case 3:
            L.groupMetadata = Q.string();
            break;
          case 4:
            L.groupPolicyMetadata = Q.string();
            break;
          case 5:
            L.groupPolicyAsAdmin = Q.bool();
            break;
          case 6:
            L.decisionPolicy = r.Any.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      const O = _();
      return (0, i.isSet)(S.admin) && (O.admin = String(S.admin)), Array.isArray(S == null ? void 0 : S.members) && (O.members = S.members.map((Q) => n.MemberRequest.fromJSON(Q))), (0, i.isSet)(S.groupMetadata) && (O.groupMetadata = String(S.groupMetadata)), (0, i.isSet)(S.groupPolicyMetadata) && (O.groupPolicyMetadata = String(S.groupPolicyMetadata)), (0, i.isSet)(S.groupPolicyAsAdmin) && (O.groupPolicyAsAdmin = !!S.groupPolicyAsAdmin), (0, i.isSet)(S.decisionPolicy) && (O.decisionPolicy = r.Any.fromJSON(S.decisionPolicy)), O;
    },
    toJSON(S) {
      const O = {};
      return S.admin !== void 0 && (O.admin = S.admin), S.members ? O.members = S.members.map((Q) => Q ? n.MemberRequest.toJSON(Q) : void 0) : O.members = [], S.groupMetadata !== void 0 && (O.groupMetadata = S.groupMetadata), S.groupPolicyMetadata !== void 0 && (O.groupPolicyMetadata = S.groupPolicyMetadata), S.groupPolicyAsAdmin !== void 0 && (O.groupPolicyAsAdmin = S.groupPolicyAsAdmin), S.decisionPolicy !== void 0 && (O.decisionPolicy = S.decisionPolicy ? r.Any.toJSON(S.decisionPolicy) : void 0), O;
    },
    fromPartial(S) {
      var Q;
      const O = _();
      return O.admin = S.admin ?? "", O.members = ((Q = S.members) == null ? void 0 : Q.map((G) => n.MemberRequest.fromPartial(G))) || [], O.groupMetadata = S.groupMetadata ?? "", O.groupPolicyMetadata = S.groupPolicyMetadata ?? "", O.groupPolicyAsAdmin = S.groupPolicyAsAdmin ?? !1, S.decisionPolicy !== void 0 && S.decisionPolicy !== null && (O.decisionPolicy = r.Any.fromPartial(S.decisionPolicy)), O;
    }
  };
  function V() {
    return {
      groupId: BigInt(0),
      groupPolicyAddress: ""
    };
  }
  e.MsgCreateGroupWithPolicyResponse = {
    typeUrl: "/cosmos.group.v1.MsgCreateGroupWithPolicyResponse",
    encode(S, O = t.BinaryWriter.create()) {
      return S.groupId !== BigInt(0) && O.uint32(8).uint64(S.groupId), S.groupPolicyAddress !== "" && O.uint32(18).string(S.groupPolicyAddress), O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = V();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          case 1:
            L.groupId = Q.uint64();
            break;
          case 2:
            L.groupPolicyAddress = Q.string();
            break;
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      const O = V();
      return (0, i.isSet)(S.groupId) && (O.groupId = BigInt(S.groupId.toString())), (0, i.isSet)(S.groupPolicyAddress) && (O.groupPolicyAddress = String(S.groupPolicyAddress)), O;
    },
    toJSON(S) {
      const O = {};
      return S.groupId !== void 0 && (O.groupId = (S.groupId || BigInt(0)).toString()), S.groupPolicyAddress !== void 0 && (O.groupPolicyAddress = S.groupPolicyAddress), O;
    },
    fromPartial(S) {
      const O = V();
      return S.groupId !== void 0 && S.groupId !== null && (O.groupId = BigInt(S.groupId.toString())), O.groupPolicyAddress = S.groupPolicyAddress ?? "", O;
    }
  };
  function o() {
    return {
      admin: "",
      groupPolicyAddress: "",
      decisionPolicy: void 0
    };
  }
  e.MsgUpdateGroupPolicyDecisionPolicy = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy",
    encode(S, O = t.BinaryWriter.create()) {
      return S.admin !== "" && O.uint32(10).string(S.admin), S.groupPolicyAddress !== "" && O.uint32(18).string(S.groupPolicyAddress), S.decisionPolicy !== void 0 && r.Any.encode(S.decisionPolicy, O.uint32(26).fork()).ldelim(), O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = o();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          case 1:
            L.admin = Q.string();
            break;
          case 2:
            L.groupPolicyAddress = Q.string();
            break;
          case 3:
            L.decisionPolicy = r.Any.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      const O = o();
      return (0, i.isSet)(S.admin) && (O.admin = String(S.admin)), (0, i.isSet)(S.groupPolicyAddress) && (O.groupPolicyAddress = String(S.groupPolicyAddress)), (0, i.isSet)(S.decisionPolicy) && (O.decisionPolicy = r.Any.fromJSON(S.decisionPolicy)), O;
    },
    toJSON(S) {
      const O = {};
      return S.admin !== void 0 && (O.admin = S.admin), S.groupPolicyAddress !== void 0 && (O.groupPolicyAddress = S.groupPolicyAddress), S.decisionPolicy !== void 0 && (O.decisionPolicy = S.decisionPolicy ? r.Any.toJSON(S.decisionPolicy) : void 0), O;
    },
    fromPartial(S) {
      const O = o();
      return O.admin = S.admin ?? "", O.groupPolicyAddress = S.groupPolicyAddress ?? "", S.decisionPolicy !== void 0 && S.decisionPolicy !== null && (O.decisionPolicy = r.Any.fromPartial(S.decisionPolicy)), O;
    }
  };
  function p() {
    return {};
  }
  e.MsgUpdateGroupPolicyDecisionPolicyResponse = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicyResponse",
    encode(S, O = t.BinaryWriter.create()) {
      return O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = p();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      return p();
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return p();
    }
  };
  function I() {
    return {
      admin: "",
      groupPolicyAddress: "",
      metadata: ""
    };
  }
  e.MsgUpdateGroupPolicyMetadata = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata",
    encode(S, O = t.BinaryWriter.create()) {
      return S.admin !== "" && O.uint32(10).string(S.admin), S.groupPolicyAddress !== "" && O.uint32(18).string(S.groupPolicyAddress), S.metadata !== "" && O.uint32(26).string(S.metadata), O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = I();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          case 1:
            L.admin = Q.string();
            break;
          case 2:
            L.groupPolicyAddress = Q.string();
            break;
          case 3:
            L.metadata = Q.string();
            break;
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      const O = I();
      return (0, i.isSet)(S.admin) && (O.admin = String(S.admin)), (0, i.isSet)(S.groupPolicyAddress) && (O.groupPolicyAddress = String(S.groupPolicyAddress)), (0, i.isSet)(S.metadata) && (O.metadata = String(S.metadata)), O;
    },
    toJSON(S) {
      const O = {};
      return S.admin !== void 0 && (O.admin = S.admin), S.groupPolicyAddress !== void 0 && (O.groupPolicyAddress = S.groupPolicyAddress), S.metadata !== void 0 && (O.metadata = S.metadata), O;
    },
    fromPartial(S) {
      const O = I();
      return O.admin = S.admin ?? "", O.groupPolicyAddress = S.groupPolicyAddress ?? "", O.metadata = S.metadata ?? "", O;
    }
  };
  function q() {
    return {};
  }
  e.MsgUpdateGroupPolicyMetadataResponse = {
    typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyMetadataResponse",
    encode(S, O = t.BinaryWriter.create()) {
      return O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = q();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      return q();
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return q();
    }
  };
  function s() {
    return {
      groupPolicyAddress: "",
      proposers: [],
      metadata: "",
      messages: [],
      exec: 0,
      title: "",
      summary: ""
    };
  }
  e.MsgSubmitProposal = {
    typeUrl: "/cosmos.group.v1.MsgSubmitProposal",
    encode(S, O = t.BinaryWriter.create()) {
      S.groupPolicyAddress !== "" && O.uint32(10).string(S.groupPolicyAddress);
      for (const Q of S.proposers)
        O.uint32(18).string(Q);
      S.metadata !== "" && O.uint32(26).string(S.metadata);
      for (const Q of S.messages)
        r.Any.encode(Q, O.uint32(34).fork()).ldelim();
      return S.exec !== 0 && O.uint32(40).int32(S.exec), S.title !== "" && O.uint32(50).string(S.title), S.summary !== "" && O.uint32(58).string(S.summary), O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = s();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          case 1:
            L.groupPolicyAddress = Q.string();
            break;
          case 2:
            L.proposers.push(Q.string());
            break;
          case 3:
            L.metadata = Q.string();
            break;
          case 4:
            L.messages.push(r.Any.decode(Q, Q.uint32()));
            break;
          case 5:
            L.exec = Q.int32();
            break;
          case 6:
            L.title = Q.string();
            break;
          case 7:
            L.summary = Q.string();
            break;
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      const O = s();
      return (0, i.isSet)(S.groupPolicyAddress) && (O.groupPolicyAddress = String(S.groupPolicyAddress)), Array.isArray(S == null ? void 0 : S.proposers) && (O.proposers = S.proposers.map((Q) => String(Q))), (0, i.isSet)(S.metadata) && (O.metadata = String(S.metadata)), Array.isArray(S == null ? void 0 : S.messages) && (O.messages = S.messages.map((Q) => r.Any.fromJSON(Q))), (0, i.isSet)(S.exec) && (O.exec = k(S.exec)), (0, i.isSet)(S.title) && (O.title = String(S.title)), (0, i.isSet)(S.summary) && (O.summary = String(S.summary)), O;
    },
    toJSON(S) {
      const O = {};
      return S.groupPolicyAddress !== void 0 && (O.groupPolicyAddress = S.groupPolicyAddress), S.proposers ? O.proposers = S.proposers.map((Q) => Q) : O.proposers = [], S.metadata !== void 0 && (O.metadata = S.metadata), S.messages ? O.messages = S.messages.map((Q) => Q ? r.Any.toJSON(Q) : void 0) : O.messages = [], S.exec !== void 0 && (O.exec = C(S.exec)), S.title !== void 0 && (O.title = S.title), S.summary !== void 0 && (O.summary = S.summary), O;
    },
    fromPartial(S) {
      var Q, G;
      const O = s();
      return O.groupPolicyAddress = S.groupPolicyAddress ?? "", O.proposers = ((Q = S.proposers) == null ? void 0 : Q.map((L) => L)) || [], O.metadata = S.metadata ?? "", O.messages = ((G = S.messages) == null ? void 0 : G.map((L) => r.Any.fromPartial(L))) || [], O.exec = S.exec ?? 0, O.title = S.title ?? "", O.summary = S.summary ?? "", O;
    }
  };
  function u() {
    return {
      proposalId: BigInt(0)
    };
  }
  e.MsgSubmitProposalResponse = {
    typeUrl: "/cosmos.group.v1.MsgSubmitProposalResponse",
    encode(S, O = t.BinaryWriter.create()) {
      return S.proposalId !== BigInt(0) && O.uint32(8).uint64(S.proposalId), O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = u();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          case 1:
            L.proposalId = Q.uint64();
            break;
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      const O = u();
      return (0, i.isSet)(S.proposalId) && (O.proposalId = BigInt(S.proposalId.toString())), O;
    },
    toJSON(S) {
      const O = {};
      return S.proposalId !== void 0 && (O.proposalId = (S.proposalId || BigInt(0)).toString()), O;
    },
    fromPartial(S) {
      const O = u();
      return S.proposalId !== void 0 && S.proposalId !== null && (O.proposalId = BigInt(S.proposalId.toString())), O;
    }
  };
  function A() {
    return {
      proposalId: BigInt(0),
      address: ""
    };
  }
  e.MsgWithdrawProposal = {
    typeUrl: "/cosmos.group.v1.MsgWithdrawProposal",
    encode(S, O = t.BinaryWriter.create()) {
      return S.proposalId !== BigInt(0) && O.uint32(8).uint64(S.proposalId), S.address !== "" && O.uint32(18).string(S.address), O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = A();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          case 1:
            L.proposalId = Q.uint64();
            break;
          case 2:
            L.address = Q.string();
            break;
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      const O = A();
      return (0, i.isSet)(S.proposalId) && (O.proposalId = BigInt(S.proposalId.toString())), (0, i.isSet)(S.address) && (O.address = String(S.address)), O;
    },
    toJSON(S) {
      const O = {};
      return S.proposalId !== void 0 && (O.proposalId = (S.proposalId || BigInt(0)).toString()), S.address !== void 0 && (O.address = S.address), O;
    },
    fromPartial(S) {
      const O = A();
      return S.proposalId !== void 0 && S.proposalId !== null && (O.proposalId = BigInt(S.proposalId.toString())), O.address = S.address ?? "", O;
    }
  };
  function R() {
    return {};
  }
  e.MsgWithdrawProposalResponse = {
    typeUrl: "/cosmos.group.v1.MsgWithdrawProposalResponse",
    encode(S, O = t.BinaryWriter.create()) {
      return O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = R();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      return R();
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return R();
    }
  };
  function v() {
    return {
      proposalId: BigInt(0),
      voter: "",
      option: 0,
      metadata: "",
      exec: 0
    };
  }
  e.MsgVote = {
    typeUrl: "/cosmos.group.v1.MsgVote",
    encode(S, O = t.BinaryWriter.create()) {
      return S.proposalId !== BigInt(0) && O.uint32(8).uint64(S.proposalId), S.voter !== "" && O.uint32(18).string(S.voter), S.option !== 0 && O.uint32(24).int32(S.option), S.metadata !== "" && O.uint32(34).string(S.metadata), S.exec !== 0 && O.uint32(40).int32(S.exec), O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = v();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          case 1:
            L.proposalId = Q.uint64();
            break;
          case 2:
            L.voter = Q.string();
            break;
          case 3:
            L.option = Q.int32();
            break;
          case 4:
            L.metadata = Q.string();
            break;
          case 5:
            L.exec = Q.int32();
            break;
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      const O = v();
      return (0, i.isSet)(S.proposalId) && (O.proposalId = BigInt(S.proposalId.toString())), (0, i.isSet)(S.voter) && (O.voter = String(S.voter)), (0, i.isSet)(S.option) && (O.option = (0, n.voteOptionFromJSON)(S.option)), (0, i.isSet)(S.metadata) && (O.metadata = String(S.metadata)), (0, i.isSet)(S.exec) && (O.exec = k(S.exec)), O;
    },
    toJSON(S) {
      const O = {};
      return S.proposalId !== void 0 && (O.proposalId = (S.proposalId || BigInt(0)).toString()), S.voter !== void 0 && (O.voter = S.voter), S.option !== void 0 && (O.option = (0, n.voteOptionToJSON)(S.option)), S.metadata !== void 0 && (O.metadata = S.metadata), S.exec !== void 0 && (O.exec = C(S.exec)), O;
    },
    fromPartial(S) {
      const O = v();
      return S.proposalId !== void 0 && S.proposalId !== null && (O.proposalId = BigInt(S.proposalId.toString())), O.voter = S.voter ?? "", O.option = S.option ?? 0, O.metadata = S.metadata ?? "", O.exec = S.exec ?? 0, O;
    }
  };
  function D() {
    return {};
  }
  e.MsgVoteResponse = {
    typeUrl: "/cosmos.group.v1.MsgVoteResponse",
    encode(S, O = t.BinaryWriter.create()) {
      return O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = D();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      return D();
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return D();
    }
  };
  function W() {
    return {
      proposalId: BigInt(0),
      executor: ""
    };
  }
  e.MsgExec = {
    typeUrl: "/cosmos.group.v1.MsgExec",
    encode(S, O = t.BinaryWriter.create()) {
      return S.proposalId !== BigInt(0) && O.uint32(8).uint64(S.proposalId), S.executor !== "" && O.uint32(18).string(S.executor), O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = W();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          case 1:
            L.proposalId = Q.uint64();
            break;
          case 2:
            L.executor = Q.string();
            break;
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      const O = W();
      return (0, i.isSet)(S.proposalId) && (O.proposalId = BigInt(S.proposalId.toString())), (0, i.isSet)(S.executor) && (O.executor = String(S.executor)), O;
    },
    toJSON(S) {
      const O = {};
      return S.proposalId !== void 0 && (O.proposalId = (S.proposalId || BigInt(0)).toString()), S.executor !== void 0 && (O.executor = S.executor), O;
    },
    fromPartial(S) {
      const O = W();
      return S.proposalId !== void 0 && S.proposalId !== null && (O.proposalId = BigInt(S.proposalId.toString())), O.executor = S.executor ?? "", O;
    }
  };
  function H() {
    return {
      result: 0
    };
  }
  e.MsgExecResponse = {
    typeUrl: "/cosmos.group.v1.MsgExecResponse",
    encode(S, O = t.BinaryWriter.create()) {
      return S.result !== 0 && O.uint32(16).int32(S.result), O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = H();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          case 2:
            L.result = Q.int32();
            break;
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      const O = H();
      return (0, i.isSet)(S.result) && (O.result = (0, n.proposalExecutorResultFromJSON)(S.result)), O;
    },
    toJSON(S) {
      const O = {};
      return S.result !== void 0 && (O.result = (0, n.proposalExecutorResultToJSON)(S.result)), O;
    },
    fromPartial(S) {
      const O = H();
      return O.result = S.result ?? 0, O;
    }
  };
  function a() {
    return {
      address: "",
      groupId: BigInt(0)
    };
  }
  e.MsgLeaveGroup = {
    typeUrl: "/cosmos.group.v1.MsgLeaveGroup",
    encode(S, O = t.BinaryWriter.create()) {
      return S.address !== "" && O.uint32(10).string(S.address), S.groupId !== BigInt(0) && O.uint32(16).uint64(S.groupId), O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = a();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          case 1:
            L.address = Q.string();
            break;
          case 2:
            L.groupId = Q.uint64();
            break;
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      const O = a();
      return (0, i.isSet)(S.address) && (O.address = String(S.address)), (0, i.isSet)(S.groupId) && (O.groupId = BigInt(S.groupId.toString())), O;
    },
    toJSON(S) {
      const O = {};
      return S.address !== void 0 && (O.address = S.address), S.groupId !== void 0 && (O.groupId = (S.groupId || BigInt(0)).toString()), O;
    },
    fromPartial(S) {
      const O = a();
      return O.address = S.address ?? "", S.groupId !== void 0 && S.groupId !== null && (O.groupId = BigInt(S.groupId.toString())), O;
    }
  };
  function g() {
    return {};
  }
  e.MsgLeaveGroupResponse = {
    typeUrl: "/cosmos.group.v1.MsgLeaveGroupResponse",
    encode(S, O = t.BinaryWriter.create()) {
      return O;
    },
    decode(S, O) {
      const Q = S instanceof t.BinaryReader ? S : new t.BinaryReader(S);
      let G = O === void 0 ? Q.len : Q.pos + O;
      const L = g();
      for (; Q.pos < G; ) {
        const ne = Q.uint32();
        switch (ne >>> 3) {
          default:
            Q.skipType(ne & 7);
            break;
        }
      }
      return L;
    },
    fromJSON(S) {
      return g();
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return g();
    }
  };
  class m {
    constructor(O) {
      this.rpc = O, this.CreateGroup = this.CreateGroup.bind(this), this.UpdateGroupMembers = this.UpdateGroupMembers.bind(this), this.UpdateGroupAdmin = this.UpdateGroupAdmin.bind(this), this.UpdateGroupMetadata = this.UpdateGroupMetadata.bind(this), this.CreateGroupPolicy = this.CreateGroupPolicy.bind(this), this.CreateGroupWithPolicy = this.CreateGroupWithPolicy.bind(this), this.UpdateGroupPolicyAdmin = this.UpdateGroupPolicyAdmin.bind(this), this.UpdateGroupPolicyDecisionPolicy = this.UpdateGroupPolicyDecisionPolicy.bind(this), this.UpdateGroupPolicyMetadata = this.UpdateGroupPolicyMetadata.bind(this), this.SubmitProposal = this.SubmitProposal.bind(this), this.WithdrawProposal = this.WithdrawProposal.bind(this), this.Vote = this.Vote.bind(this), this.Exec = this.Exec.bind(this), this.LeaveGroup = this.LeaveGroup.bind(this);
    }
    CreateGroup(O) {
      const Q = e.MsgCreateGroup.encode(O).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "CreateGroup", Q).then((L) => e.MsgCreateGroupResponse.decode(new t.BinaryReader(L)));
    }
    UpdateGroupMembers(O) {
      const Q = e.MsgUpdateGroupMembers.encode(O).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupMembers", Q).then((L) => e.MsgUpdateGroupMembersResponse.decode(new t.BinaryReader(L)));
    }
    UpdateGroupAdmin(O) {
      const Q = e.MsgUpdateGroupAdmin.encode(O).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupAdmin", Q).then((L) => e.MsgUpdateGroupAdminResponse.decode(new t.BinaryReader(L)));
    }
    UpdateGroupMetadata(O) {
      const Q = e.MsgUpdateGroupMetadata.encode(O).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupMetadata", Q).then((L) => e.MsgUpdateGroupMetadataResponse.decode(new t.BinaryReader(L)));
    }
    CreateGroupPolicy(O) {
      const Q = e.MsgCreateGroupPolicy.encode(O).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "CreateGroupPolicy", Q).then((L) => e.MsgCreateGroupPolicyResponse.decode(new t.BinaryReader(L)));
    }
    CreateGroupWithPolicy(O) {
      const Q = e.MsgCreateGroupWithPolicy.encode(O).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "CreateGroupWithPolicy", Q).then((L) => e.MsgCreateGroupWithPolicyResponse.decode(new t.BinaryReader(L)));
    }
    UpdateGroupPolicyAdmin(O) {
      const Q = e.MsgUpdateGroupPolicyAdmin.encode(O).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyAdmin", Q).then((L) => e.MsgUpdateGroupPolicyAdminResponse.decode(new t.BinaryReader(L)));
    }
    UpdateGroupPolicyDecisionPolicy(O) {
      const Q = e.MsgUpdateGroupPolicyDecisionPolicy.encode(O).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyDecisionPolicy", Q).then((L) => e.MsgUpdateGroupPolicyDecisionPolicyResponse.decode(new t.BinaryReader(L)));
    }
    UpdateGroupPolicyMetadata(O) {
      const Q = e.MsgUpdateGroupPolicyMetadata.encode(O).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyMetadata", Q).then((L) => e.MsgUpdateGroupPolicyMetadataResponse.decode(new t.BinaryReader(L)));
    }
    SubmitProposal(O) {
      const Q = e.MsgSubmitProposal.encode(O).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "SubmitProposal", Q).then((L) => e.MsgSubmitProposalResponse.decode(new t.BinaryReader(L)));
    }
    WithdrawProposal(O) {
      const Q = e.MsgWithdrawProposal.encode(O).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "WithdrawProposal", Q).then((L) => e.MsgWithdrawProposalResponse.decode(new t.BinaryReader(L)));
    }
    Vote(O) {
      const Q = e.MsgVote.encode(O).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "Vote", Q).then((L) => e.MsgVoteResponse.decode(new t.BinaryReader(L)));
    }
    Exec(O) {
      const Q = e.MsgExec.encode(O).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "Exec", Q).then((L) => e.MsgExecResponse.decode(new t.BinaryReader(L)));
    }
    LeaveGroup(O) {
      const Q = e.MsgLeaveGroup.encode(O).finish();
      return this.rpc.request("cosmos.group.v1.Msg", "LeaveGroup", Q).then((L) => e.MsgLeaveGroupResponse.decode(new t.BinaryReader(L)));
    }
  }
  e.MsgClientImpl = m;
})(ol);
Object.defineProperty(Oo, "__esModule", { value: !0 });
Oo.groupTypes = void 0;
const ze = ol;
Oo.groupTypes = [
  ["/cosmos.group.v1.MsgCreateGroup", ze.MsgCreateGroup],
  ["/cosmos.group.v1.MsgCreateGroupPolicy", ze.MsgCreateGroupPolicy],
  ["/cosmos.group.v1.MsgCreateGroupWithPolicy", ze.MsgCreateGroupWithPolicy],
  ["/cosmos.group.v1.MsgExec", ze.MsgExec],
  ["/cosmos.group.v1.MsgLeaveGroup", ze.MsgLeaveGroup],
  ["/cosmos.group.v1.MsgSubmitProposal", ze.MsgSubmitProposal],
  ["/cosmos.group.v1.MsgUpdateGroupAdmin", ze.MsgUpdateGroupAdmin],
  ["/cosmos.group.v1.MsgUpdateGroupMembers", ze.MsgUpdateGroupMembers],
  ["/cosmos.group.v1.MsgUpdateGroupMetadata", ze.MsgUpdateGroupMetadata],
  ["/cosmos.group.v1.MsgUpdateGroupPolicyAdmin", ze.MsgUpdateGroupPolicyAdmin],
  ["/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy", ze.MsgUpdateGroupPolicyDecisionPolicy],
  ["/cosmos.group.v1.MsgUpdateGroupPolicyMetadata", ze.MsgUpdateGroupPolicyMetadata],
  ["/cosmos.group.v1.MsgVote", ze.MsgVote],
  ["/cosmos.group.v1.MsgWithdrawProposal", ze.MsgWithdrawProposal]
];
var ir = {}, bo = {}, Yn = {}, sl = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ModuleVersion = e.CancelSoftwareUpgradeProposal = e.SoftwareUpgradeProposal = e.Plan = e.protobufPackage = void 0;
  const n = _e, r = Be, t = re, i = ie;
  e.protobufPackage = "cosmos.upgrade.v1beta1";
  function f() {
    return {
      name: "",
      time: n.Timestamp.fromPartial({}),
      height: BigInt(0),
      info: "",
      upgradedClientState: void 0
    };
  }
  e.Plan = {
    typeUrl: "/cosmos.upgrade.v1beta1.Plan",
    encode(U, w = t.BinaryWriter.create()) {
      return U.name !== "" && w.uint32(10).string(U.name), U.time !== void 0 && n.Timestamp.encode(U.time, w.uint32(18).fork()).ldelim(), U.height !== BigInt(0) && w.uint32(24).int64(U.height), U.info !== "" && w.uint32(34).string(U.info), U.upgradedClientState !== void 0 && r.Any.encode(U.upgradedClientState, w.uint32(42).fork()).ldelim(), w;
    },
    decode(U, w) {
      const N = U instanceof t.BinaryReader ? U : new t.BinaryReader(U);
      let h = w === void 0 ? N.len : N.pos + w;
      const P = f();
      for (; N.pos < h; ) {
        const b = N.uint32();
        switch (b >>> 3) {
          case 1:
            P.name = N.string();
            break;
          case 2:
            P.time = n.Timestamp.decode(N, N.uint32());
            break;
          case 3:
            P.height = N.int64();
            break;
          case 4:
            P.info = N.string();
            break;
          case 5:
            P.upgradedClientState = r.Any.decode(N, N.uint32());
            break;
          default:
            N.skipType(b & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(U) {
      const w = f();
      return (0, i.isSet)(U.name) && (w.name = String(U.name)), (0, i.isSet)(U.time) && (w.time = (0, i.fromJsonTimestamp)(U.time)), (0, i.isSet)(U.height) && (w.height = BigInt(U.height.toString())), (0, i.isSet)(U.info) && (w.info = String(U.info)), (0, i.isSet)(U.upgradedClientState) && (w.upgradedClientState = r.Any.fromJSON(U.upgradedClientState)), w;
    },
    toJSON(U) {
      const w = {};
      return U.name !== void 0 && (w.name = U.name), U.time !== void 0 && (w.time = (0, i.fromTimestamp)(U.time).toISOString()), U.height !== void 0 && (w.height = (U.height || BigInt(0)).toString()), U.info !== void 0 && (w.info = U.info), U.upgradedClientState !== void 0 && (w.upgradedClientState = U.upgradedClientState ? r.Any.toJSON(U.upgradedClientState) : void 0), w;
    },
    fromPartial(U) {
      const w = f();
      return w.name = U.name ?? "", U.time !== void 0 && U.time !== null && (w.time = n.Timestamp.fromPartial(U.time)), U.height !== void 0 && U.height !== null && (w.height = BigInt(U.height.toString())), w.info = U.info ?? "", U.upgradedClientState !== void 0 && U.upgradedClientState !== null && (w.upgradedClientState = r.Any.fromPartial(U.upgradedClientState)), w;
    }
  };
  function k() {
    return {
      title: "",
      description: "",
      plan: e.Plan.fromPartial({})
    };
  }
  e.SoftwareUpgradeProposal = {
    typeUrl: "/cosmos.upgrade.v1beta1.SoftwareUpgradeProposal",
    encode(U, w = t.BinaryWriter.create()) {
      return U.title !== "" && w.uint32(10).string(U.title), U.description !== "" && w.uint32(18).string(U.description), U.plan !== void 0 && e.Plan.encode(U.plan, w.uint32(26).fork()).ldelim(), w;
    },
    decode(U, w) {
      const N = U instanceof t.BinaryReader ? U : new t.BinaryReader(U);
      let h = w === void 0 ? N.len : N.pos + w;
      const P = k();
      for (; N.pos < h; ) {
        const b = N.uint32();
        switch (b >>> 3) {
          case 1:
            P.title = N.string();
            break;
          case 2:
            P.description = N.string();
            break;
          case 3:
            P.plan = e.Plan.decode(N, N.uint32());
            break;
          default:
            N.skipType(b & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(U) {
      const w = k();
      return (0, i.isSet)(U.title) && (w.title = String(U.title)), (0, i.isSet)(U.description) && (w.description = String(U.description)), (0, i.isSet)(U.plan) && (w.plan = e.Plan.fromJSON(U.plan)), w;
    },
    toJSON(U) {
      const w = {};
      return U.title !== void 0 && (w.title = U.title), U.description !== void 0 && (w.description = U.description), U.plan !== void 0 && (w.plan = U.plan ? e.Plan.toJSON(U.plan) : void 0), w;
    },
    fromPartial(U) {
      const w = k();
      return w.title = U.title ?? "", w.description = U.description ?? "", U.plan !== void 0 && U.plan !== null && (w.plan = e.Plan.fromPartial(U.plan)), w;
    }
  };
  function C() {
    return {
      title: "",
      description: ""
    };
  }
  e.CancelSoftwareUpgradeProposal = {
    typeUrl: "/cosmos.upgrade.v1beta1.CancelSoftwareUpgradeProposal",
    encode(U, w = t.BinaryWriter.create()) {
      return U.title !== "" && w.uint32(10).string(U.title), U.description !== "" && w.uint32(18).string(U.description), w;
    },
    decode(U, w) {
      const N = U instanceof t.BinaryReader ? U : new t.BinaryReader(U);
      let h = w === void 0 ? N.len : N.pos + w;
      const P = C();
      for (; N.pos < h; ) {
        const b = N.uint32();
        switch (b >>> 3) {
          case 1:
            P.title = N.string();
            break;
          case 2:
            P.description = N.string();
            break;
          default:
            N.skipType(b & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(U) {
      const w = C();
      return (0, i.isSet)(U.title) && (w.title = String(U.title)), (0, i.isSet)(U.description) && (w.description = String(U.description)), w;
    },
    toJSON(U) {
      const w = {};
      return U.title !== void 0 && (w.title = U.title), U.description !== void 0 && (w.description = U.description), w;
    },
    fromPartial(U) {
      const w = C();
      return w.title = U.title ?? "", w.description = U.description ?? "", w;
    }
  };
  function T() {
    return {
      name: "",
      version: BigInt(0)
    };
  }
  e.ModuleVersion = {
    typeUrl: "/cosmos.upgrade.v1beta1.ModuleVersion",
    encode(U, w = t.BinaryWriter.create()) {
      return U.name !== "" && w.uint32(10).string(U.name), U.version !== BigInt(0) && w.uint32(16).uint64(U.version), w;
    },
    decode(U, w) {
      const N = U instanceof t.BinaryReader ? U : new t.BinaryReader(U);
      let h = w === void 0 ? N.len : N.pos + w;
      const P = T();
      for (; N.pos < h; ) {
        const b = N.uint32();
        switch (b >>> 3) {
          case 1:
            P.name = N.string();
            break;
          case 2:
            P.version = N.uint64();
            break;
          default:
            N.skipType(b & 7);
            break;
        }
      }
      return P;
    },
    fromJSON(U) {
      const w = T();
      return (0, i.isSet)(U.name) && (w.name = String(U.name)), (0, i.isSet)(U.version) && (w.version = BigInt(U.version.toString())), w;
    },
    toJSON(U) {
      const w = {};
      return U.name !== void 0 && (w.name = U.name), U.version !== void 0 && (w.version = (U.version || BigInt(0)).toString()), w;
    },
    fromPartial(U) {
      const w = T();
      return w.name = U.name ?? "", U.version !== void 0 && U.version !== null && (w.version = BigInt(U.version.toString())), w;
    }
  };
})(sl);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Params = e.Height = e.UpgradeProposal = e.ClientUpdateProposal = e.ClientConsensusStates = e.ConsensusStateWithHeight = e.IdentifiedClientState = e.protobufPackage = void 0;
  const n = Be, r = sl, t = re, i = ie;
  e.protobufPackage = "ibc.core.client.v1";
  function f() {
    return {
      clientId: "",
      clientState: void 0
    };
  }
  e.IdentifiedClientState = {
    typeUrl: "/ibc.core.client.v1.IdentifiedClientState",
    encode(h, P = t.BinaryWriter.create()) {
      return h.clientId !== "" && P.uint32(10).string(h.clientId), h.clientState !== void 0 && n.Any.encode(h.clientState, P.uint32(18).fork()).ldelim(), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = f();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.clientId = b.string();
            break;
          case 2:
            l.clientState = n.Any.decode(b, b.uint32());
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = f();
      return (0, i.isSet)(h.clientId) && (P.clientId = String(h.clientId)), (0, i.isSet)(h.clientState) && (P.clientState = n.Any.fromJSON(h.clientState)), P;
    },
    toJSON(h) {
      const P = {};
      return h.clientId !== void 0 && (P.clientId = h.clientId), h.clientState !== void 0 && (P.clientState = h.clientState ? n.Any.toJSON(h.clientState) : void 0), P;
    },
    fromPartial(h) {
      const P = f();
      return P.clientId = h.clientId ?? "", h.clientState !== void 0 && h.clientState !== null && (P.clientState = n.Any.fromPartial(h.clientState)), P;
    }
  };
  function k() {
    return {
      height: e.Height.fromPartial({}),
      consensusState: void 0
    };
  }
  e.ConsensusStateWithHeight = {
    typeUrl: "/ibc.core.client.v1.ConsensusStateWithHeight",
    encode(h, P = t.BinaryWriter.create()) {
      return h.height !== void 0 && e.Height.encode(h.height, P.uint32(10).fork()).ldelim(), h.consensusState !== void 0 && n.Any.encode(h.consensusState, P.uint32(18).fork()).ldelim(), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = k();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.height = e.Height.decode(b, b.uint32());
            break;
          case 2:
            l.consensusState = n.Any.decode(b, b.uint32());
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = k();
      return (0, i.isSet)(h.height) && (P.height = e.Height.fromJSON(h.height)), (0, i.isSet)(h.consensusState) && (P.consensusState = n.Any.fromJSON(h.consensusState)), P;
    },
    toJSON(h) {
      const P = {};
      return h.height !== void 0 && (P.height = h.height ? e.Height.toJSON(h.height) : void 0), h.consensusState !== void 0 && (P.consensusState = h.consensusState ? n.Any.toJSON(h.consensusState) : void 0), P;
    },
    fromPartial(h) {
      const P = k();
      return h.height !== void 0 && h.height !== null && (P.height = e.Height.fromPartial(h.height)), h.consensusState !== void 0 && h.consensusState !== null && (P.consensusState = n.Any.fromPartial(h.consensusState)), P;
    }
  };
  function C() {
    return {
      clientId: "",
      consensusStates: []
    };
  }
  e.ClientConsensusStates = {
    typeUrl: "/ibc.core.client.v1.ClientConsensusStates",
    encode(h, P = t.BinaryWriter.create()) {
      h.clientId !== "" && P.uint32(10).string(h.clientId);
      for (const b of h.consensusStates)
        e.ConsensusStateWithHeight.encode(b, P.uint32(18).fork()).ldelim();
      return P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = C();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.clientId = b.string();
            break;
          case 2:
            l.consensusStates.push(e.ConsensusStateWithHeight.decode(b, b.uint32()));
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = C();
      return (0, i.isSet)(h.clientId) && (P.clientId = String(h.clientId)), Array.isArray(h == null ? void 0 : h.consensusStates) && (P.consensusStates = h.consensusStates.map((b) => e.ConsensusStateWithHeight.fromJSON(b))), P;
    },
    toJSON(h) {
      const P = {};
      return h.clientId !== void 0 && (P.clientId = h.clientId), h.consensusStates ? P.consensusStates = h.consensusStates.map((b) => b ? e.ConsensusStateWithHeight.toJSON(b) : void 0) : P.consensusStates = [], P;
    },
    fromPartial(h) {
      var b;
      const P = C();
      return P.clientId = h.clientId ?? "", P.consensusStates = ((b = h.consensusStates) == null ? void 0 : b.map((c) => e.ConsensusStateWithHeight.fromPartial(c))) || [], P;
    }
  };
  function T() {
    return {
      title: "",
      description: "",
      subjectClientId: "",
      substituteClientId: ""
    };
  }
  e.ClientUpdateProposal = {
    typeUrl: "/ibc.core.client.v1.ClientUpdateProposal",
    encode(h, P = t.BinaryWriter.create()) {
      return h.title !== "" && P.uint32(10).string(h.title), h.description !== "" && P.uint32(18).string(h.description), h.subjectClientId !== "" && P.uint32(26).string(h.subjectClientId), h.substituteClientId !== "" && P.uint32(34).string(h.substituteClientId), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = T();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.title = b.string();
            break;
          case 2:
            l.description = b.string();
            break;
          case 3:
            l.subjectClientId = b.string();
            break;
          case 4:
            l.substituteClientId = b.string();
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = T();
      return (0, i.isSet)(h.title) && (P.title = String(h.title)), (0, i.isSet)(h.description) && (P.description = String(h.description)), (0, i.isSet)(h.subjectClientId) && (P.subjectClientId = String(h.subjectClientId)), (0, i.isSet)(h.substituteClientId) && (P.substituteClientId = String(h.substituteClientId)), P;
    },
    toJSON(h) {
      const P = {};
      return h.title !== void 0 && (P.title = h.title), h.description !== void 0 && (P.description = h.description), h.subjectClientId !== void 0 && (P.subjectClientId = h.subjectClientId), h.substituteClientId !== void 0 && (P.substituteClientId = h.substituteClientId), P;
    },
    fromPartial(h) {
      const P = T();
      return P.title = h.title ?? "", P.description = h.description ?? "", P.subjectClientId = h.subjectClientId ?? "", P.substituteClientId = h.substituteClientId ?? "", P;
    }
  };
  function U() {
    return {
      title: "",
      description: "",
      plan: r.Plan.fromPartial({}),
      upgradedClientState: void 0
    };
  }
  e.UpgradeProposal = {
    typeUrl: "/ibc.core.client.v1.UpgradeProposal",
    encode(h, P = t.BinaryWriter.create()) {
      return h.title !== "" && P.uint32(10).string(h.title), h.description !== "" && P.uint32(18).string(h.description), h.plan !== void 0 && r.Plan.encode(h.plan, P.uint32(26).fork()).ldelim(), h.upgradedClientState !== void 0 && n.Any.encode(h.upgradedClientState, P.uint32(34).fork()).ldelim(), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = U();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.title = b.string();
            break;
          case 2:
            l.description = b.string();
            break;
          case 3:
            l.plan = r.Plan.decode(b, b.uint32());
            break;
          case 4:
            l.upgradedClientState = n.Any.decode(b, b.uint32());
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = U();
      return (0, i.isSet)(h.title) && (P.title = String(h.title)), (0, i.isSet)(h.description) && (P.description = String(h.description)), (0, i.isSet)(h.plan) && (P.plan = r.Plan.fromJSON(h.plan)), (0, i.isSet)(h.upgradedClientState) && (P.upgradedClientState = n.Any.fromJSON(h.upgradedClientState)), P;
    },
    toJSON(h) {
      const P = {};
      return h.title !== void 0 && (P.title = h.title), h.description !== void 0 && (P.description = h.description), h.plan !== void 0 && (P.plan = h.plan ? r.Plan.toJSON(h.plan) : void 0), h.upgradedClientState !== void 0 && (P.upgradedClientState = h.upgradedClientState ? n.Any.toJSON(h.upgradedClientState) : void 0), P;
    },
    fromPartial(h) {
      const P = U();
      return P.title = h.title ?? "", P.description = h.description ?? "", h.plan !== void 0 && h.plan !== null && (P.plan = r.Plan.fromPartial(h.plan)), h.upgradedClientState !== void 0 && h.upgradedClientState !== null && (P.upgradedClientState = n.Any.fromPartial(h.upgradedClientState)), P;
    }
  };
  function w() {
    return {
      revisionNumber: BigInt(0),
      revisionHeight: BigInt(0)
    };
  }
  e.Height = {
    typeUrl: "/ibc.core.client.v1.Height",
    encode(h, P = t.BinaryWriter.create()) {
      return h.revisionNumber !== BigInt(0) && P.uint32(8).uint64(h.revisionNumber), h.revisionHeight !== BigInt(0) && P.uint32(16).uint64(h.revisionHeight), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = w();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.revisionNumber = b.uint64();
            break;
          case 2:
            l.revisionHeight = b.uint64();
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = w();
      return (0, i.isSet)(h.revisionNumber) && (P.revisionNumber = BigInt(h.revisionNumber.toString())), (0, i.isSet)(h.revisionHeight) && (P.revisionHeight = BigInt(h.revisionHeight.toString())), P;
    },
    toJSON(h) {
      const P = {};
      return h.revisionNumber !== void 0 && (P.revisionNumber = (h.revisionNumber || BigInt(0)).toString()), h.revisionHeight !== void 0 && (P.revisionHeight = (h.revisionHeight || BigInt(0)).toString()), P;
    },
    fromPartial(h) {
      const P = w();
      return h.revisionNumber !== void 0 && h.revisionNumber !== null && (P.revisionNumber = BigInt(h.revisionNumber.toString())), h.revisionHeight !== void 0 && h.revisionHeight !== null && (P.revisionHeight = BigInt(h.revisionHeight.toString())), P;
    }
  };
  function N() {
    return {
      allowedClients: []
    };
  }
  e.Params = {
    typeUrl: "/ibc.core.client.v1.Params",
    encode(h, P = t.BinaryWriter.create()) {
      for (const b of h.allowedClients)
        P.uint32(10).string(b);
      return P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = N();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.allowedClients.push(b.string());
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = N();
      return Array.isArray(h == null ? void 0 : h.allowedClients) && (P.allowedClients = h.allowedClients.map((b) => String(b))), P;
    },
    toJSON(h) {
      const P = {};
      return h.allowedClients ? P.allowedClients = h.allowedClients.map((b) => b) : P.allowedClients = [], P;
    },
    fromPartial(h) {
      var b;
      const P = N();
      return P.allowedClients = ((b = h.allowedClients) == null ? void 0 : b.map((c) => c)) || [], P;
    }
  };
})(Yn);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgTransferResponse = e.MsgTransfer = e.protobufPackage = void 0;
  const n = Le, r = Yn, t = re, i = ie;
  e.protobufPackage = "ibc.applications.transfer.v1";
  function f() {
    return {
      sourcePort: "",
      sourceChannel: "",
      token: n.Coin.fromPartial({}),
      sender: "",
      receiver: "",
      timeoutHeight: r.Height.fromPartial({}),
      timeoutTimestamp: BigInt(0),
      memo: ""
    };
  }
  e.MsgTransfer = {
    typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
    encode(T, U = t.BinaryWriter.create()) {
      return T.sourcePort !== "" && U.uint32(10).string(T.sourcePort), T.sourceChannel !== "" && U.uint32(18).string(T.sourceChannel), T.token !== void 0 && n.Coin.encode(T.token, U.uint32(26).fork()).ldelim(), T.sender !== "" && U.uint32(34).string(T.sender), T.receiver !== "" && U.uint32(42).string(T.receiver), T.timeoutHeight !== void 0 && r.Height.encode(T.timeoutHeight, U.uint32(50).fork()).ldelim(), T.timeoutTimestamp !== BigInt(0) && U.uint32(56).uint64(T.timeoutTimestamp), T.memo !== "" && U.uint32(66).string(T.memo), U;
    },
    decode(T, U) {
      const w = T instanceof t.BinaryReader ? T : new t.BinaryReader(T);
      let N = U === void 0 ? w.len : w.pos + U;
      const h = f();
      for (; w.pos < N; ) {
        const P = w.uint32();
        switch (P >>> 3) {
          case 1:
            h.sourcePort = w.string();
            break;
          case 2:
            h.sourceChannel = w.string();
            break;
          case 3:
            h.token = n.Coin.decode(w, w.uint32());
            break;
          case 4:
            h.sender = w.string();
            break;
          case 5:
            h.receiver = w.string();
            break;
          case 6:
            h.timeoutHeight = r.Height.decode(w, w.uint32());
            break;
          case 7:
            h.timeoutTimestamp = w.uint64();
            break;
          case 8:
            h.memo = w.string();
            break;
          default:
            w.skipType(P & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(T) {
      const U = f();
      return (0, i.isSet)(T.sourcePort) && (U.sourcePort = String(T.sourcePort)), (0, i.isSet)(T.sourceChannel) && (U.sourceChannel = String(T.sourceChannel)), (0, i.isSet)(T.token) && (U.token = n.Coin.fromJSON(T.token)), (0, i.isSet)(T.sender) && (U.sender = String(T.sender)), (0, i.isSet)(T.receiver) && (U.receiver = String(T.receiver)), (0, i.isSet)(T.timeoutHeight) && (U.timeoutHeight = r.Height.fromJSON(T.timeoutHeight)), (0, i.isSet)(T.timeoutTimestamp) && (U.timeoutTimestamp = BigInt(T.timeoutTimestamp.toString())), (0, i.isSet)(T.memo) && (U.memo = String(T.memo)), U;
    },
    toJSON(T) {
      const U = {};
      return T.sourcePort !== void 0 && (U.sourcePort = T.sourcePort), T.sourceChannel !== void 0 && (U.sourceChannel = T.sourceChannel), T.token !== void 0 && (U.token = T.token ? n.Coin.toJSON(T.token) : void 0), T.sender !== void 0 && (U.sender = T.sender), T.receiver !== void 0 && (U.receiver = T.receiver), T.timeoutHeight !== void 0 && (U.timeoutHeight = T.timeoutHeight ? r.Height.toJSON(T.timeoutHeight) : void 0), T.timeoutTimestamp !== void 0 && (U.timeoutTimestamp = (T.timeoutTimestamp || BigInt(0)).toString()), T.memo !== void 0 && (U.memo = T.memo), U;
    },
    fromPartial(T) {
      const U = f();
      return U.sourcePort = T.sourcePort ?? "", U.sourceChannel = T.sourceChannel ?? "", T.token !== void 0 && T.token !== null && (U.token = n.Coin.fromPartial(T.token)), U.sender = T.sender ?? "", U.receiver = T.receiver ?? "", T.timeoutHeight !== void 0 && T.timeoutHeight !== null && (U.timeoutHeight = r.Height.fromPartial(T.timeoutHeight)), T.timeoutTimestamp !== void 0 && T.timeoutTimestamp !== null && (U.timeoutTimestamp = BigInt(T.timeoutTimestamp.toString())), U.memo = T.memo ?? "", U;
    }
  };
  function k() {
    return {
      sequence: BigInt(0)
    };
  }
  e.MsgTransferResponse = {
    typeUrl: "/ibc.applications.transfer.v1.MsgTransferResponse",
    encode(T, U = t.BinaryWriter.create()) {
      return T.sequence !== BigInt(0) && U.uint32(8).uint64(T.sequence), U;
    },
    decode(T, U) {
      const w = T instanceof t.BinaryReader ? T : new t.BinaryReader(T);
      let N = U === void 0 ? w.len : w.pos + U;
      const h = k();
      for (; w.pos < N; ) {
        const P = w.uint32();
        switch (P >>> 3) {
          case 1:
            h.sequence = w.uint64();
            break;
          default:
            w.skipType(P & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(T) {
      const U = k();
      return (0, i.isSet)(T.sequence) && (U.sequence = BigInt(T.sequence.toString())), U;
    },
    toJSON(T) {
      const U = {};
      return T.sequence !== void 0 && (U.sequence = (T.sequence || BigInt(0)).toString()), U;
    },
    fromPartial(T) {
      const U = k();
      return T.sequence !== void 0 && T.sequence !== null && (U.sequence = BigInt(T.sequence.toString())), U;
    }
  };
  class C {
    constructor(U) {
      this.rpc = U, this.Transfer = this.Transfer.bind(this);
    }
    Transfer(U) {
      const w = e.MsgTransfer.encode(U).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Msg", "Transfer", w).then((h) => e.MsgTransferResponse.decode(new t.BinaryReader(h)));
    }
  }
  e.MsgClientImpl = C;
})(bo);
Object.defineProperty(ir, "__esModule", { value: !0 });
ir.createIbcAminoConverters = ir.isAminoMsgTransfer = void 0;
const gi = Xi, _m = bo;
function Em(e) {
  return e.type === "cosmos-sdk/MsgTransfer";
}
ir.isAminoMsgTransfer = Em;
function Jm() {
  return {
    "/ibc.applications.transfer.v1.MsgTransfer": {
      aminoType: "cosmos-sdk/MsgTransfer",
      toAmino: ({ sourcePort: e, sourceChannel: n, token: r, sender: t, receiver: i, timeoutHeight: f, timeoutTimestamp: k, memo: C }) => {
        var T, U, w;
        return {
          source_port: e,
          source_channel: n,
          token: r,
          sender: t,
          receiver: i,
          timeout_height: f ? {
            revision_height: (T = (0, gi.omitDefault)(f.revisionHeight)) == null ? void 0 : T.toString(),
            revision_number: (U = (0, gi.omitDefault)(f.revisionNumber)) == null ? void 0 : U.toString()
          } : {},
          timeout_timestamp: (w = (0, gi.omitDefault)(k)) == null ? void 0 : w.toString(),
          memo: (0, gi.omitDefault)(C)
        };
      },
      fromAmino: ({ source_port: e, source_channel: n, token: r, sender: t, receiver: i, timeout_height: f, timeout_timestamp: k, memo: C }) => _m.MsgTransfer.fromPartial({
        sourcePort: e,
        sourceChannel: n,
        token: r,
        sender: t,
        receiver: i,
        timeoutHeight: f ? {
          revisionHeight: BigInt(f.revision_height || "0"),
          revisionNumber: BigInt(f.revision_number || "0")
        } : void 0,
        timeoutTimestamp: BigInt(k || "0"),
        memo: C ?? ""
      })
    }
  };
}
ir.createIbcAminoConverters = Jm;
var or = {}, dl = {}, Ao = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Acknowledgement = e.PacketId = e.PacketState = e.Packet = e.Counterparty = e.IdentifiedChannel = e.Channel = e.orderToJSON = e.orderFromJSON = e.Order = e.stateToJSON = e.stateFromJSON = e.State = e.protobufPackage = void 0;
  const n = Yn, r = re, t = ie;
  e.protobufPackage = "ibc.core.channel.v1";
  var i;
  (function(y) {
    y[y.STATE_UNINITIALIZED_UNSPECIFIED = 0] = "STATE_UNINITIALIZED_UNSPECIFIED", y[y.STATE_INIT = 1] = "STATE_INIT", y[y.STATE_TRYOPEN = 2] = "STATE_TRYOPEN", y[y.STATE_OPEN = 3] = "STATE_OPEN", y[y.STATE_CLOSED = 4] = "STATE_CLOSED", y[y.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(i || (e.State = i = {}));
  function f(y) {
    switch (y) {
      case 0:
      case "STATE_UNINITIALIZED_UNSPECIFIED":
        return i.STATE_UNINITIALIZED_UNSPECIFIED;
      case 1:
      case "STATE_INIT":
        return i.STATE_INIT;
      case 2:
      case "STATE_TRYOPEN":
        return i.STATE_TRYOPEN;
      case 3:
      case "STATE_OPEN":
        return i.STATE_OPEN;
      case 4:
      case "STATE_CLOSED":
        return i.STATE_CLOSED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return i.UNRECOGNIZED;
    }
  }
  e.stateFromJSON = f;
  function k(y) {
    switch (y) {
      case i.STATE_UNINITIALIZED_UNSPECIFIED:
        return "STATE_UNINITIALIZED_UNSPECIFIED";
      case i.STATE_INIT:
        return "STATE_INIT";
      case i.STATE_TRYOPEN:
        return "STATE_TRYOPEN";
      case i.STATE_OPEN:
        return "STATE_OPEN";
      case i.STATE_CLOSED:
        return "STATE_CLOSED";
      case i.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.stateToJSON = k;
  var C;
  (function(y) {
    y[y.ORDER_NONE_UNSPECIFIED = 0] = "ORDER_NONE_UNSPECIFIED", y[y.ORDER_UNORDERED = 1] = "ORDER_UNORDERED", y[y.ORDER_ORDERED = 2] = "ORDER_ORDERED", y[y.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(C || (e.Order = C = {}));
  function T(y) {
    switch (y) {
      case 0:
      case "ORDER_NONE_UNSPECIFIED":
        return C.ORDER_NONE_UNSPECIFIED;
      case 1:
      case "ORDER_UNORDERED":
        return C.ORDER_UNORDERED;
      case 2:
      case "ORDER_ORDERED":
        return C.ORDER_ORDERED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return C.UNRECOGNIZED;
    }
  }
  e.orderFromJSON = T;
  function U(y) {
    switch (y) {
      case C.ORDER_NONE_UNSPECIFIED:
        return "ORDER_NONE_UNSPECIFIED";
      case C.ORDER_UNORDERED:
        return "ORDER_UNORDERED";
      case C.ORDER_ORDERED:
        return "ORDER_ORDERED";
      case C.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.orderToJSON = U;
  function w() {
    return {
      state: 0,
      ordering: 0,
      counterparty: e.Counterparty.fromPartial({}),
      connectionHops: [],
      version: ""
    };
  }
  e.Channel = {
    typeUrl: "/ibc.core.channel.v1.Channel",
    encode(y, E = r.BinaryWriter.create()) {
      y.state !== 0 && E.uint32(8).int32(y.state), y.ordering !== 0 && E.uint32(16).int32(y.ordering), y.counterparty !== void 0 && e.Counterparty.encode(y.counterparty, E.uint32(26).fork()).ldelim();
      for (const J of y.connectionHops)
        E.uint32(34).string(J);
      return y.version !== "" && E.uint32(42).string(y.version), E;
    },
    decode(y, E) {
      const J = y instanceof r.BinaryReader ? y : new r.BinaryReader(y);
      let _ = E === void 0 ? J.len : J.pos + E;
      const V = w();
      for (; J.pos < _; ) {
        const o = J.uint32();
        switch (o >>> 3) {
          case 1:
            V.state = J.int32();
            break;
          case 2:
            V.ordering = J.int32();
            break;
          case 3:
            V.counterparty = e.Counterparty.decode(J, J.uint32());
            break;
          case 4:
            V.connectionHops.push(J.string());
            break;
          case 5:
            V.version = J.string();
            break;
          default:
            J.skipType(o & 7);
            break;
        }
      }
      return V;
    },
    fromJSON(y) {
      const E = w();
      return (0, t.isSet)(y.state) && (E.state = f(y.state)), (0, t.isSet)(y.ordering) && (E.ordering = T(y.ordering)), (0, t.isSet)(y.counterparty) && (E.counterparty = e.Counterparty.fromJSON(y.counterparty)), Array.isArray(y == null ? void 0 : y.connectionHops) && (E.connectionHops = y.connectionHops.map((J) => String(J))), (0, t.isSet)(y.version) && (E.version = String(y.version)), E;
    },
    toJSON(y) {
      const E = {};
      return y.state !== void 0 && (E.state = k(y.state)), y.ordering !== void 0 && (E.ordering = U(y.ordering)), y.counterparty !== void 0 && (E.counterparty = y.counterparty ? e.Counterparty.toJSON(y.counterparty) : void 0), y.connectionHops ? E.connectionHops = y.connectionHops.map((J) => J) : E.connectionHops = [], y.version !== void 0 && (E.version = y.version), E;
    },
    fromPartial(y) {
      var J;
      const E = w();
      return E.state = y.state ?? 0, E.ordering = y.ordering ?? 0, y.counterparty !== void 0 && y.counterparty !== null && (E.counterparty = e.Counterparty.fromPartial(y.counterparty)), E.connectionHops = ((J = y.connectionHops) == null ? void 0 : J.map((_) => _)) || [], E.version = y.version ?? "", E;
    }
  };
  function N() {
    return {
      state: 0,
      ordering: 0,
      counterparty: e.Counterparty.fromPartial({}),
      connectionHops: [],
      version: "",
      portId: "",
      channelId: ""
    };
  }
  e.IdentifiedChannel = {
    typeUrl: "/ibc.core.channel.v1.IdentifiedChannel",
    encode(y, E = r.BinaryWriter.create()) {
      y.state !== 0 && E.uint32(8).int32(y.state), y.ordering !== 0 && E.uint32(16).int32(y.ordering), y.counterparty !== void 0 && e.Counterparty.encode(y.counterparty, E.uint32(26).fork()).ldelim();
      for (const J of y.connectionHops)
        E.uint32(34).string(J);
      return y.version !== "" && E.uint32(42).string(y.version), y.portId !== "" && E.uint32(50).string(y.portId), y.channelId !== "" && E.uint32(58).string(y.channelId), E;
    },
    decode(y, E) {
      const J = y instanceof r.BinaryReader ? y : new r.BinaryReader(y);
      let _ = E === void 0 ? J.len : J.pos + E;
      const V = N();
      for (; J.pos < _; ) {
        const o = J.uint32();
        switch (o >>> 3) {
          case 1:
            V.state = J.int32();
            break;
          case 2:
            V.ordering = J.int32();
            break;
          case 3:
            V.counterparty = e.Counterparty.decode(J, J.uint32());
            break;
          case 4:
            V.connectionHops.push(J.string());
            break;
          case 5:
            V.version = J.string();
            break;
          case 6:
            V.portId = J.string();
            break;
          case 7:
            V.channelId = J.string();
            break;
          default:
            J.skipType(o & 7);
            break;
        }
      }
      return V;
    },
    fromJSON(y) {
      const E = N();
      return (0, t.isSet)(y.state) && (E.state = f(y.state)), (0, t.isSet)(y.ordering) && (E.ordering = T(y.ordering)), (0, t.isSet)(y.counterparty) && (E.counterparty = e.Counterparty.fromJSON(y.counterparty)), Array.isArray(y == null ? void 0 : y.connectionHops) && (E.connectionHops = y.connectionHops.map((J) => String(J))), (0, t.isSet)(y.version) && (E.version = String(y.version)), (0, t.isSet)(y.portId) && (E.portId = String(y.portId)), (0, t.isSet)(y.channelId) && (E.channelId = String(y.channelId)), E;
    },
    toJSON(y) {
      const E = {};
      return y.state !== void 0 && (E.state = k(y.state)), y.ordering !== void 0 && (E.ordering = U(y.ordering)), y.counterparty !== void 0 && (E.counterparty = y.counterparty ? e.Counterparty.toJSON(y.counterparty) : void 0), y.connectionHops ? E.connectionHops = y.connectionHops.map((J) => J) : E.connectionHops = [], y.version !== void 0 && (E.version = y.version), y.portId !== void 0 && (E.portId = y.portId), y.channelId !== void 0 && (E.channelId = y.channelId), E;
    },
    fromPartial(y) {
      var J;
      const E = N();
      return E.state = y.state ?? 0, E.ordering = y.ordering ?? 0, y.counterparty !== void 0 && y.counterparty !== null && (E.counterparty = e.Counterparty.fromPartial(y.counterparty)), E.connectionHops = ((J = y.connectionHops) == null ? void 0 : J.map((_) => _)) || [], E.version = y.version ?? "", E.portId = y.portId ?? "", E.channelId = y.channelId ?? "", E;
    }
  };
  function h() {
    return {
      portId: "",
      channelId: ""
    };
  }
  e.Counterparty = {
    typeUrl: "/ibc.core.channel.v1.Counterparty",
    encode(y, E = r.BinaryWriter.create()) {
      return y.portId !== "" && E.uint32(10).string(y.portId), y.channelId !== "" && E.uint32(18).string(y.channelId), E;
    },
    decode(y, E) {
      const J = y instanceof r.BinaryReader ? y : new r.BinaryReader(y);
      let _ = E === void 0 ? J.len : J.pos + E;
      const V = h();
      for (; J.pos < _; ) {
        const o = J.uint32();
        switch (o >>> 3) {
          case 1:
            V.portId = J.string();
            break;
          case 2:
            V.channelId = J.string();
            break;
          default:
            J.skipType(o & 7);
            break;
        }
      }
      return V;
    },
    fromJSON(y) {
      const E = h();
      return (0, t.isSet)(y.portId) && (E.portId = String(y.portId)), (0, t.isSet)(y.channelId) && (E.channelId = String(y.channelId)), E;
    },
    toJSON(y) {
      const E = {};
      return y.portId !== void 0 && (E.portId = y.portId), y.channelId !== void 0 && (E.channelId = y.channelId), E;
    },
    fromPartial(y) {
      const E = h();
      return E.portId = y.portId ?? "", E.channelId = y.channelId ?? "", E;
    }
  };
  function P() {
    return {
      sequence: BigInt(0),
      sourcePort: "",
      sourceChannel: "",
      destinationPort: "",
      destinationChannel: "",
      data: new Uint8Array(),
      timeoutHeight: n.Height.fromPartial({}),
      timeoutTimestamp: BigInt(0)
    };
  }
  e.Packet = {
    typeUrl: "/ibc.core.channel.v1.Packet",
    encode(y, E = r.BinaryWriter.create()) {
      return y.sequence !== BigInt(0) && E.uint32(8).uint64(y.sequence), y.sourcePort !== "" && E.uint32(18).string(y.sourcePort), y.sourceChannel !== "" && E.uint32(26).string(y.sourceChannel), y.destinationPort !== "" && E.uint32(34).string(y.destinationPort), y.destinationChannel !== "" && E.uint32(42).string(y.destinationChannel), y.data.length !== 0 && E.uint32(50).bytes(y.data), y.timeoutHeight !== void 0 && n.Height.encode(y.timeoutHeight, E.uint32(58).fork()).ldelim(), y.timeoutTimestamp !== BigInt(0) && E.uint32(64).uint64(y.timeoutTimestamp), E;
    },
    decode(y, E) {
      const J = y instanceof r.BinaryReader ? y : new r.BinaryReader(y);
      let _ = E === void 0 ? J.len : J.pos + E;
      const V = P();
      for (; J.pos < _; ) {
        const o = J.uint32();
        switch (o >>> 3) {
          case 1:
            V.sequence = J.uint64();
            break;
          case 2:
            V.sourcePort = J.string();
            break;
          case 3:
            V.sourceChannel = J.string();
            break;
          case 4:
            V.destinationPort = J.string();
            break;
          case 5:
            V.destinationChannel = J.string();
            break;
          case 6:
            V.data = J.bytes();
            break;
          case 7:
            V.timeoutHeight = n.Height.decode(J, J.uint32());
            break;
          case 8:
            V.timeoutTimestamp = J.uint64();
            break;
          default:
            J.skipType(o & 7);
            break;
        }
      }
      return V;
    },
    fromJSON(y) {
      const E = P();
      return (0, t.isSet)(y.sequence) && (E.sequence = BigInt(y.sequence.toString())), (0, t.isSet)(y.sourcePort) && (E.sourcePort = String(y.sourcePort)), (0, t.isSet)(y.sourceChannel) && (E.sourceChannel = String(y.sourceChannel)), (0, t.isSet)(y.destinationPort) && (E.destinationPort = String(y.destinationPort)), (0, t.isSet)(y.destinationChannel) && (E.destinationChannel = String(y.destinationChannel)), (0, t.isSet)(y.data) && (E.data = (0, t.bytesFromBase64)(y.data)), (0, t.isSet)(y.timeoutHeight) && (E.timeoutHeight = n.Height.fromJSON(y.timeoutHeight)), (0, t.isSet)(y.timeoutTimestamp) && (E.timeoutTimestamp = BigInt(y.timeoutTimestamp.toString())), E;
    },
    toJSON(y) {
      const E = {};
      return y.sequence !== void 0 && (E.sequence = (y.sequence || BigInt(0)).toString()), y.sourcePort !== void 0 && (E.sourcePort = y.sourcePort), y.sourceChannel !== void 0 && (E.sourceChannel = y.sourceChannel), y.destinationPort !== void 0 && (E.destinationPort = y.destinationPort), y.destinationChannel !== void 0 && (E.destinationChannel = y.destinationChannel), y.data !== void 0 && (E.data = (0, t.base64FromBytes)(y.data !== void 0 ? y.data : new Uint8Array())), y.timeoutHeight !== void 0 && (E.timeoutHeight = y.timeoutHeight ? n.Height.toJSON(y.timeoutHeight) : void 0), y.timeoutTimestamp !== void 0 && (E.timeoutTimestamp = (y.timeoutTimestamp || BigInt(0)).toString()), E;
    },
    fromPartial(y) {
      const E = P();
      return y.sequence !== void 0 && y.sequence !== null && (E.sequence = BigInt(y.sequence.toString())), E.sourcePort = y.sourcePort ?? "", E.sourceChannel = y.sourceChannel ?? "", E.destinationPort = y.destinationPort ?? "", E.destinationChannel = y.destinationChannel ?? "", E.data = y.data ?? new Uint8Array(), y.timeoutHeight !== void 0 && y.timeoutHeight !== null && (E.timeoutHeight = n.Height.fromPartial(y.timeoutHeight)), y.timeoutTimestamp !== void 0 && y.timeoutTimestamp !== null && (E.timeoutTimestamp = BigInt(y.timeoutTimestamp.toString())), E;
    }
  };
  function b() {
    return {
      portId: "",
      channelId: "",
      sequence: BigInt(0),
      data: new Uint8Array()
    };
  }
  e.PacketState = {
    typeUrl: "/ibc.core.channel.v1.PacketState",
    encode(y, E = r.BinaryWriter.create()) {
      return y.portId !== "" && E.uint32(10).string(y.portId), y.channelId !== "" && E.uint32(18).string(y.channelId), y.sequence !== BigInt(0) && E.uint32(24).uint64(y.sequence), y.data.length !== 0 && E.uint32(34).bytes(y.data), E;
    },
    decode(y, E) {
      const J = y instanceof r.BinaryReader ? y : new r.BinaryReader(y);
      let _ = E === void 0 ? J.len : J.pos + E;
      const V = b();
      for (; J.pos < _; ) {
        const o = J.uint32();
        switch (o >>> 3) {
          case 1:
            V.portId = J.string();
            break;
          case 2:
            V.channelId = J.string();
            break;
          case 3:
            V.sequence = J.uint64();
            break;
          case 4:
            V.data = J.bytes();
            break;
          default:
            J.skipType(o & 7);
            break;
        }
      }
      return V;
    },
    fromJSON(y) {
      const E = b();
      return (0, t.isSet)(y.portId) && (E.portId = String(y.portId)), (0, t.isSet)(y.channelId) && (E.channelId = String(y.channelId)), (0, t.isSet)(y.sequence) && (E.sequence = BigInt(y.sequence.toString())), (0, t.isSet)(y.data) && (E.data = (0, t.bytesFromBase64)(y.data)), E;
    },
    toJSON(y) {
      const E = {};
      return y.portId !== void 0 && (E.portId = y.portId), y.channelId !== void 0 && (E.channelId = y.channelId), y.sequence !== void 0 && (E.sequence = (y.sequence || BigInt(0)).toString()), y.data !== void 0 && (E.data = (0, t.base64FromBytes)(y.data !== void 0 ? y.data : new Uint8Array())), E;
    },
    fromPartial(y) {
      const E = b();
      return E.portId = y.portId ?? "", E.channelId = y.channelId ?? "", y.sequence !== void 0 && y.sequence !== null && (E.sequence = BigInt(y.sequence.toString())), E.data = y.data ?? new Uint8Array(), E;
    }
  };
  function c() {
    return {
      portId: "",
      channelId: "",
      sequence: BigInt(0)
    };
  }
  e.PacketId = {
    typeUrl: "/ibc.core.channel.v1.PacketId",
    encode(y, E = r.BinaryWriter.create()) {
      return y.portId !== "" && E.uint32(10).string(y.portId), y.channelId !== "" && E.uint32(18).string(y.channelId), y.sequence !== BigInt(0) && E.uint32(24).uint64(y.sequence), E;
    },
    decode(y, E) {
      const J = y instanceof r.BinaryReader ? y : new r.BinaryReader(y);
      let _ = E === void 0 ? J.len : J.pos + E;
      const V = c();
      for (; J.pos < _; ) {
        const o = J.uint32();
        switch (o >>> 3) {
          case 1:
            V.portId = J.string();
            break;
          case 2:
            V.channelId = J.string();
            break;
          case 3:
            V.sequence = J.uint64();
            break;
          default:
            J.skipType(o & 7);
            break;
        }
      }
      return V;
    },
    fromJSON(y) {
      const E = c();
      return (0, t.isSet)(y.portId) && (E.portId = String(y.portId)), (0, t.isSet)(y.channelId) && (E.channelId = String(y.channelId)), (0, t.isSet)(y.sequence) && (E.sequence = BigInt(y.sequence.toString())), E;
    },
    toJSON(y) {
      const E = {};
      return y.portId !== void 0 && (E.portId = y.portId), y.channelId !== void 0 && (E.channelId = y.channelId), y.sequence !== void 0 && (E.sequence = (y.sequence || BigInt(0)).toString()), E;
    },
    fromPartial(y) {
      const E = c();
      return E.portId = y.portId ?? "", E.channelId = y.channelId ?? "", y.sequence !== void 0 && y.sequence !== null && (E.sequence = BigInt(y.sequence.toString())), E;
    }
  };
  function l() {
    return {
      result: void 0,
      error: void 0
    };
  }
  e.Acknowledgement = {
    typeUrl: "/ibc.core.channel.v1.Acknowledgement",
    encode(y, E = r.BinaryWriter.create()) {
      return y.result !== void 0 && E.uint32(170).bytes(y.result), y.error !== void 0 && E.uint32(178).string(y.error), E;
    },
    decode(y, E) {
      const J = y instanceof r.BinaryReader ? y : new r.BinaryReader(y);
      let _ = E === void 0 ? J.len : J.pos + E;
      const V = l();
      for (; J.pos < _; ) {
        const o = J.uint32();
        switch (o >>> 3) {
          case 21:
            V.result = J.bytes();
            break;
          case 22:
            V.error = J.string();
            break;
          default:
            J.skipType(o & 7);
            break;
        }
      }
      return V;
    },
    fromJSON(y) {
      const E = l();
      return (0, t.isSet)(y.result) && (E.result = (0, t.bytesFromBase64)(y.result)), (0, t.isSet)(y.error) && (E.error = String(y.error)), E;
    },
    toJSON(y) {
      const E = {};
      return y.result !== void 0 && (E.result = y.result !== void 0 ? (0, t.base64FromBytes)(y.result) : void 0), y.error !== void 0 && (E.error = y.error), E;
    },
    fromPartial(y) {
      const E = l();
      return E.result = y.result ?? void 0, E.error = y.error ?? void 0, E;
    }
  };
})(Ao);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgAcknowledgementResponse = e.MsgAcknowledgement = e.MsgTimeoutOnCloseResponse = e.MsgTimeoutOnClose = e.MsgTimeoutResponse = e.MsgTimeout = e.MsgRecvPacketResponse = e.MsgRecvPacket = e.MsgChannelCloseConfirmResponse = e.MsgChannelCloseConfirm = e.MsgChannelCloseInitResponse = e.MsgChannelCloseInit = e.MsgChannelOpenConfirmResponse = e.MsgChannelOpenConfirm = e.MsgChannelOpenAckResponse = e.MsgChannelOpenAck = e.MsgChannelOpenTryResponse = e.MsgChannelOpenTry = e.MsgChannelOpenInitResponse = e.MsgChannelOpenInit = e.responseResultTypeToJSON = e.responseResultTypeFromJSON = e.ResponseResultType = e.protobufPackage = void 0;
  const n = Ao, r = Yn, t = re, i = ie;
  e.protobufPackage = "ibc.core.channel.v1";
  var f;
  (function(R) {
    R[R.RESPONSE_RESULT_TYPE_UNSPECIFIED = 0] = "RESPONSE_RESULT_TYPE_UNSPECIFIED", R[R.RESPONSE_RESULT_TYPE_NOOP = 1] = "RESPONSE_RESULT_TYPE_NOOP", R[R.RESPONSE_RESULT_TYPE_SUCCESS = 2] = "RESPONSE_RESULT_TYPE_SUCCESS", R[R.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(f || (e.ResponseResultType = f = {}));
  function k(R) {
    switch (R) {
      case 0:
      case "RESPONSE_RESULT_TYPE_UNSPECIFIED":
        return f.RESPONSE_RESULT_TYPE_UNSPECIFIED;
      case 1:
      case "RESPONSE_RESULT_TYPE_NOOP":
        return f.RESPONSE_RESULT_TYPE_NOOP;
      case 2:
      case "RESPONSE_RESULT_TYPE_SUCCESS":
        return f.RESPONSE_RESULT_TYPE_SUCCESS;
      case -1:
      case "UNRECOGNIZED":
      default:
        return f.UNRECOGNIZED;
    }
  }
  e.responseResultTypeFromJSON = k;
  function C(R) {
    switch (R) {
      case f.RESPONSE_RESULT_TYPE_UNSPECIFIED:
        return "RESPONSE_RESULT_TYPE_UNSPECIFIED";
      case f.RESPONSE_RESULT_TYPE_NOOP:
        return "RESPONSE_RESULT_TYPE_NOOP";
      case f.RESPONSE_RESULT_TYPE_SUCCESS:
        return "RESPONSE_RESULT_TYPE_SUCCESS";
      case f.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.responseResultTypeToJSON = C;
  function T() {
    return {
      portId: "",
      channel: n.Channel.fromPartial({}),
      signer: ""
    };
  }
  e.MsgChannelOpenInit = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenInit",
    encode(R, v = t.BinaryWriter.create()) {
      return R.portId !== "" && v.uint32(10).string(R.portId), R.channel !== void 0 && n.Channel.encode(R.channel, v.uint32(18).fork()).ldelim(), R.signer !== "" && v.uint32(26).string(R.signer), v;
    },
    decode(R, v) {
      const D = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let W = v === void 0 ? D.len : D.pos + v;
      const H = T();
      for (; D.pos < W; ) {
        const a = D.uint32();
        switch (a >>> 3) {
          case 1:
            H.portId = D.string();
            break;
          case 2:
            H.channel = n.Channel.decode(D, D.uint32());
            break;
          case 3:
            H.signer = D.string();
            break;
          default:
            D.skipType(a & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(R) {
      const v = T();
      return (0, i.isSet)(R.portId) && (v.portId = String(R.portId)), (0, i.isSet)(R.channel) && (v.channel = n.Channel.fromJSON(R.channel)), (0, i.isSet)(R.signer) && (v.signer = String(R.signer)), v;
    },
    toJSON(R) {
      const v = {};
      return R.portId !== void 0 && (v.portId = R.portId), R.channel !== void 0 && (v.channel = R.channel ? n.Channel.toJSON(R.channel) : void 0), R.signer !== void 0 && (v.signer = R.signer), v;
    },
    fromPartial(R) {
      const v = T();
      return v.portId = R.portId ?? "", R.channel !== void 0 && R.channel !== null && (v.channel = n.Channel.fromPartial(R.channel)), v.signer = R.signer ?? "", v;
    }
  };
  function U() {
    return {
      channelId: "",
      version: ""
    };
  }
  e.MsgChannelOpenInitResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenInitResponse",
    encode(R, v = t.BinaryWriter.create()) {
      return R.channelId !== "" && v.uint32(10).string(R.channelId), R.version !== "" && v.uint32(18).string(R.version), v;
    },
    decode(R, v) {
      const D = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let W = v === void 0 ? D.len : D.pos + v;
      const H = U();
      for (; D.pos < W; ) {
        const a = D.uint32();
        switch (a >>> 3) {
          case 1:
            H.channelId = D.string();
            break;
          case 2:
            H.version = D.string();
            break;
          default:
            D.skipType(a & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(R) {
      const v = U();
      return (0, i.isSet)(R.channelId) && (v.channelId = String(R.channelId)), (0, i.isSet)(R.version) && (v.version = String(R.version)), v;
    },
    toJSON(R) {
      const v = {};
      return R.channelId !== void 0 && (v.channelId = R.channelId), R.version !== void 0 && (v.version = R.version), v;
    },
    fromPartial(R) {
      const v = U();
      return v.channelId = R.channelId ?? "", v.version = R.version ?? "", v;
    }
  };
  function w() {
    return {
      portId: "",
      previousChannelId: "",
      channel: n.Channel.fromPartial({}),
      counterpartyVersion: "",
      proofInit: new Uint8Array(),
      proofHeight: r.Height.fromPartial({}),
      signer: ""
    };
  }
  e.MsgChannelOpenTry = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenTry",
    encode(R, v = t.BinaryWriter.create()) {
      return R.portId !== "" && v.uint32(10).string(R.portId), R.previousChannelId !== "" && v.uint32(18).string(R.previousChannelId), R.channel !== void 0 && n.Channel.encode(R.channel, v.uint32(26).fork()).ldelim(), R.counterpartyVersion !== "" && v.uint32(34).string(R.counterpartyVersion), R.proofInit.length !== 0 && v.uint32(42).bytes(R.proofInit), R.proofHeight !== void 0 && r.Height.encode(R.proofHeight, v.uint32(50).fork()).ldelim(), R.signer !== "" && v.uint32(58).string(R.signer), v;
    },
    decode(R, v) {
      const D = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let W = v === void 0 ? D.len : D.pos + v;
      const H = w();
      for (; D.pos < W; ) {
        const a = D.uint32();
        switch (a >>> 3) {
          case 1:
            H.portId = D.string();
            break;
          case 2:
            H.previousChannelId = D.string();
            break;
          case 3:
            H.channel = n.Channel.decode(D, D.uint32());
            break;
          case 4:
            H.counterpartyVersion = D.string();
            break;
          case 5:
            H.proofInit = D.bytes();
            break;
          case 6:
            H.proofHeight = r.Height.decode(D, D.uint32());
            break;
          case 7:
            H.signer = D.string();
            break;
          default:
            D.skipType(a & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(R) {
      const v = w();
      return (0, i.isSet)(R.portId) && (v.portId = String(R.portId)), (0, i.isSet)(R.previousChannelId) && (v.previousChannelId = String(R.previousChannelId)), (0, i.isSet)(R.channel) && (v.channel = n.Channel.fromJSON(R.channel)), (0, i.isSet)(R.counterpartyVersion) && (v.counterpartyVersion = String(R.counterpartyVersion)), (0, i.isSet)(R.proofInit) && (v.proofInit = (0, i.bytesFromBase64)(R.proofInit)), (0, i.isSet)(R.proofHeight) && (v.proofHeight = r.Height.fromJSON(R.proofHeight)), (0, i.isSet)(R.signer) && (v.signer = String(R.signer)), v;
    },
    toJSON(R) {
      const v = {};
      return R.portId !== void 0 && (v.portId = R.portId), R.previousChannelId !== void 0 && (v.previousChannelId = R.previousChannelId), R.channel !== void 0 && (v.channel = R.channel ? n.Channel.toJSON(R.channel) : void 0), R.counterpartyVersion !== void 0 && (v.counterpartyVersion = R.counterpartyVersion), R.proofInit !== void 0 && (v.proofInit = (0, i.base64FromBytes)(R.proofInit !== void 0 ? R.proofInit : new Uint8Array())), R.proofHeight !== void 0 && (v.proofHeight = R.proofHeight ? r.Height.toJSON(R.proofHeight) : void 0), R.signer !== void 0 && (v.signer = R.signer), v;
    },
    fromPartial(R) {
      const v = w();
      return v.portId = R.portId ?? "", v.previousChannelId = R.previousChannelId ?? "", R.channel !== void 0 && R.channel !== null && (v.channel = n.Channel.fromPartial(R.channel)), v.counterpartyVersion = R.counterpartyVersion ?? "", v.proofInit = R.proofInit ?? new Uint8Array(), R.proofHeight !== void 0 && R.proofHeight !== null && (v.proofHeight = r.Height.fromPartial(R.proofHeight)), v.signer = R.signer ?? "", v;
    }
  };
  function N() {
    return {
      version: ""
    };
  }
  e.MsgChannelOpenTryResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenTryResponse",
    encode(R, v = t.BinaryWriter.create()) {
      return R.version !== "" && v.uint32(10).string(R.version), v;
    },
    decode(R, v) {
      const D = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let W = v === void 0 ? D.len : D.pos + v;
      const H = N();
      for (; D.pos < W; ) {
        const a = D.uint32();
        switch (a >>> 3) {
          case 1:
            H.version = D.string();
            break;
          default:
            D.skipType(a & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(R) {
      const v = N();
      return (0, i.isSet)(R.version) && (v.version = String(R.version)), v;
    },
    toJSON(R) {
      const v = {};
      return R.version !== void 0 && (v.version = R.version), v;
    },
    fromPartial(R) {
      const v = N();
      return v.version = R.version ?? "", v;
    }
  };
  function h() {
    return {
      portId: "",
      channelId: "",
      counterpartyChannelId: "",
      counterpartyVersion: "",
      proofTry: new Uint8Array(),
      proofHeight: r.Height.fromPartial({}),
      signer: ""
    };
  }
  e.MsgChannelOpenAck = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenAck",
    encode(R, v = t.BinaryWriter.create()) {
      return R.portId !== "" && v.uint32(10).string(R.portId), R.channelId !== "" && v.uint32(18).string(R.channelId), R.counterpartyChannelId !== "" && v.uint32(26).string(R.counterpartyChannelId), R.counterpartyVersion !== "" && v.uint32(34).string(R.counterpartyVersion), R.proofTry.length !== 0 && v.uint32(42).bytes(R.proofTry), R.proofHeight !== void 0 && r.Height.encode(R.proofHeight, v.uint32(50).fork()).ldelim(), R.signer !== "" && v.uint32(58).string(R.signer), v;
    },
    decode(R, v) {
      const D = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let W = v === void 0 ? D.len : D.pos + v;
      const H = h();
      for (; D.pos < W; ) {
        const a = D.uint32();
        switch (a >>> 3) {
          case 1:
            H.portId = D.string();
            break;
          case 2:
            H.channelId = D.string();
            break;
          case 3:
            H.counterpartyChannelId = D.string();
            break;
          case 4:
            H.counterpartyVersion = D.string();
            break;
          case 5:
            H.proofTry = D.bytes();
            break;
          case 6:
            H.proofHeight = r.Height.decode(D, D.uint32());
            break;
          case 7:
            H.signer = D.string();
            break;
          default:
            D.skipType(a & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(R) {
      const v = h();
      return (0, i.isSet)(R.portId) && (v.portId = String(R.portId)), (0, i.isSet)(R.channelId) && (v.channelId = String(R.channelId)), (0, i.isSet)(R.counterpartyChannelId) && (v.counterpartyChannelId = String(R.counterpartyChannelId)), (0, i.isSet)(R.counterpartyVersion) && (v.counterpartyVersion = String(R.counterpartyVersion)), (0, i.isSet)(R.proofTry) && (v.proofTry = (0, i.bytesFromBase64)(R.proofTry)), (0, i.isSet)(R.proofHeight) && (v.proofHeight = r.Height.fromJSON(R.proofHeight)), (0, i.isSet)(R.signer) && (v.signer = String(R.signer)), v;
    },
    toJSON(R) {
      const v = {};
      return R.portId !== void 0 && (v.portId = R.portId), R.channelId !== void 0 && (v.channelId = R.channelId), R.counterpartyChannelId !== void 0 && (v.counterpartyChannelId = R.counterpartyChannelId), R.counterpartyVersion !== void 0 && (v.counterpartyVersion = R.counterpartyVersion), R.proofTry !== void 0 && (v.proofTry = (0, i.base64FromBytes)(R.proofTry !== void 0 ? R.proofTry : new Uint8Array())), R.proofHeight !== void 0 && (v.proofHeight = R.proofHeight ? r.Height.toJSON(R.proofHeight) : void 0), R.signer !== void 0 && (v.signer = R.signer), v;
    },
    fromPartial(R) {
      const v = h();
      return v.portId = R.portId ?? "", v.channelId = R.channelId ?? "", v.counterpartyChannelId = R.counterpartyChannelId ?? "", v.counterpartyVersion = R.counterpartyVersion ?? "", v.proofTry = R.proofTry ?? new Uint8Array(), R.proofHeight !== void 0 && R.proofHeight !== null && (v.proofHeight = r.Height.fromPartial(R.proofHeight)), v.signer = R.signer ?? "", v;
    }
  };
  function P() {
    return {};
  }
  e.MsgChannelOpenAckResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenAckResponse",
    encode(R, v = t.BinaryWriter.create()) {
      return v;
    },
    decode(R, v) {
      const D = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let W = v === void 0 ? D.len : D.pos + v;
      const H = P();
      for (; D.pos < W; ) {
        const a = D.uint32();
        switch (a >>> 3) {
          default:
            D.skipType(a & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(R) {
      return P();
    },
    toJSON(R) {
      return {};
    },
    fromPartial(R) {
      return P();
    }
  };
  function b() {
    return {
      portId: "",
      channelId: "",
      proofAck: new Uint8Array(),
      proofHeight: r.Height.fromPartial({}),
      signer: ""
    };
  }
  e.MsgChannelOpenConfirm = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenConfirm",
    encode(R, v = t.BinaryWriter.create()) {
      return R.portId !== "" && v.uint32(10).string(R.portId), R.channelId !== "" && v.uint32(18).string(R.channelId), R.proofAck.length !== 0 && v.uint32(26).bytes(R.proofAck), R.proofHeight !== void 0 && r.Height.encode(R.proofHeight, v.uint32(34).fork()).ldelim(), R.signer !== "" && v.uint32(42).string(R.signer), v;
    },
    decode(R, v) {
      const D = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let W = v === void 0 ? D.len : D.pos + v;
      const H = b();
      for (; D.pos < W; ) {
        const a = D.uint32();
        switch (a >>> 3) {
          case 1:
            H.portId = D.string();
            break;
          case 2:
            H.channelId = D.string();
            break;
          case 3:
            H.proofAck = D.bytes();
            break;
          case 4:
            H.proofHeight = r.Height.decode(D, D.uint32());
            break;
          case 5:
            H.signer = D.string();
            break;
          default:
            D.skipType(a & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(R) {
      const v = b();
      return (0, i.isSet)(R.portId) && (v.portId = String(R.portId)), (0, i.isSet)(R.channelId) && (v.channelId = String(R.channelId)), (0, i.isSet)(R.proofAck) && (v.proofAck = (0, i.bytesFromBase64)(R.proofAck)), (0, i.isSet)(R.proofHeight) && (v.proofHeight = r.Height.fromJSON(R.proofHeight)), (0, i.isSet)(R.signer) && (v.signer = String(R.signer)), v;
    },
    toJSON(R) {
      const v = {};
      return R.portId !== void 0 && (v.portId = R.portId), R.channelId !== void 0 && (v.channelId = R.channelId), R.proofAck !== void 0 && (v.proofAck = (0, i.base64FromBytes)(R.proofAck !== void 0 ? R.proofAck : new Uint8Array())), R.proofHeight !== void 0 && (v.proofHeight = R.proofHeight ? r.Height.toJSON(R.proofHeight) : void 0), R.signer !== void 0 && (v.signer = R.signer), v;
    },
    fromPartial(R) {
      const v = b();
      return v.portId = R.portId ?? "", v.channelId = R.channelId ?? "", v.proofAck = R.proofAck ?? new Uint8Array(), R.proofHeight !== void 0 && R.proofHeight !== null && (v.proofHeight = r.Height.fromPartial(R.proofHeight)), v.signer = R.signer ?? "", v;
    }
  };
  function c() {
    return {};
  }
  e.MsgChannelOpenConfirmResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelOpenConfirmResponse",
    encode(R, v = t.BinaryWriter.create()) {
      return v;
    },
    decode(R, v) {
      const D = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let W = v === void 0 ? D.len : D.pos + v;
      const H = c();
      for (; D.pos < W; ) {
        const a = D.uint32();
        switch (a >>> 3) {
          default:
            D.skipType(a & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(R) {
      return c();
    },
    toJSON(R) {
      return {};
    },
    fromPartial(R) {
      return c();
    }
  };
  function l() {
    return {
      portId: "",
      channelId: "",
      signer: ""
    };
  }
  e.MsgChannelCloseInit = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelCloseInit",
    encode(R, v = t.BinaryWriter.create()) {
      return R.portId !== "" && v.uint32(10).string(R.portId), R.channelId !== "" && v.uint32(18).string(R.channelId), R.signer !== "" && v.uint32(26).string(R.signer), v;
    },
    decode(R, v) {
      const D = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let W = v === void 0 ? D.len : D.pos + v;
      const H = l();
      for (; D.pos < W; ) {
        const a = D.uint32();
        switch (a >>> 3) {
          case 1:
            H.portId = D.string();
            break;
          case 2:
            H.channelId = D.string();
            break;
          case 3:
            H.signer = D.string();
            break;
          default:
            D.skipType(a & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(R) {
      const v = l();
      return (0, i.isSet)(R.portId) && (v.portId = String(R.portId)), (0, i.isSet)(R.channelId) && (v.channelId = String(R.channelId)), (0, i.isSet)(R.signer) && (v.signer = String(R.signer)), v;
    },
    toJSON(R) {
      const v = {};
      return R.portId !== void 0 && (v.portId = R.portId), R.channelId !== void 0 && (v.channelId = R.channelId), R.signer !== void 0 && (v.signer = R.signer), v;
    },
    fromPartial(R) {
      const v = l();
      return v.portId = R.portId ?? "", v.channelId = R.channelId ?? "", v.signer = R.signer ?? "", v;
    }
  };
  function y() {
    return {};
  }
  e.MsgChannelCloseInitResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelCloseInitResponse",
    encode(R, v = t.BinaryWriter.create()) {
      return v;
    },
    decode(R, v) {
      const D = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let W = v === void 0 ? D.len : D.pos + v;
      const H = y();
      for (; D.pos < W; ) {
        const a = D.uint32();
        switch (a >>> 3) {
          default:
            D.skipType(a & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(R) {
      return y();
    },
    toJSON(R) {
      return {};
    },
    fromPartial(R) {
      return y();
    }
  };
  function E() {
    return {
      portId: "",
      channelId: "",
      proofInit: new Uint8Array(),
      proofHeight: r.Height.fromPartial({}),
      signer: ""
    };
  }
  e.MsgChannelCloseConfirm = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelCloseConfirm",
    encode(R, v = t.BinaryWriter.create()) {
      return R.portId !== "" && v.uint32(10).string(R.portId), R.channelId !== "" && v.uint32(18).string(R.channelId), R.proofInit.length !== 0 && v.uint32(26).bytes(R.proofInit), R.proofHeight !== void 0 && r.Height.encode(R.proofHeight, v.uint32(34).fork()).ldelim(), R.signer !== "" && v.uint32(42).string(R.signer), v;
    },
    decode(R, v) {
      const D = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let W = v === void 0 ? D.len : D.pos + v;
      const H = E();
      for (; D.pos < W; ) {
        const a = D.uint32();
        switch (a >>> 3) {
          case 1:
            H.portId = D.string();
            break;
          case 2:
            H.channelId = D.string();
            break;
          case 3:
            H.proofInit = D.bytes();
            break;
          case 4:
            H.proofHeight = r.Height.decode(D, D.uint32());
            break;
          case 5:
            H.signer = D.string();
            break;
          default:
            D.skipType(a & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(R) {
      const v = E();
      return (0, i.isSet)(R.portId) && (v.portId = String(R.portId)), (0, i.isSet)(R.channelId) && (v.channelId = String(R.channelId)), (0, i.isSet)(R.proofInit) && (v.proofInit = (0, i.bytesFromBase64)(R.proofInit)), (0, i.isSet)(R.proofHeight) && (v.proofHeight = r.Height.fromJSON(R.proofHeight)), (0, i.isSet)(R.signer) && (v.signer = String(R.signer)), v;
    },
    toJSON(R) {
      const v = {};
      return R.portId !== void 0 && (v.portId = R.portId), R.channelId !== void 0 && (v.channelId = R.channelId), R.proofInit !== void 0 && (v.proofInit = (0, i.base64FromBytes)(R.proofInit !== void 0 ? R.proofInit : new Uint8Array())), R.proofHeight !== void 0 && (v.proofHeight = R.proofHeight ? r.Height.toJSON(R.proofHeight) : void 0), R.signer !== void 0 && (v.signer = R.signer), v;
    },
    fromPartial(R) {
      const v = E();
      return v.portId = R.portId ?? "", v.channelId = R.channelId ?? "", v.proofInit = R.proofInit ?? new Uint8Array(), R.proofHeight !== void 0 && R.proofHeight !== null && (v.proofHeight = r.Height.fromPartial(R.proofHeight)), v.signer = R.signer ?? "", v;
    }
  };
  function J() {
    return {};
  }
  e.MsgChannelCloseConfirmResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgChannelCloseConfirmResponse",
    encode(R, v = t.BinaryWriter.create()) {
      return v;
    },
    decode(R, v) {
      const D = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let W = v === void 0 ? D.len : D.pos + v;
      const H = J();
      for (; D.pos < W; ) {
        const a = D.uint32();
        switch (a >>> 3) {
          default:
            D.skipType(a & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(R) {
      return J();
    },
    toJSON(R) {
      return {};
    },
    fromPartial(R) {
      return J();
    }
  };
  function _() {
    return {
      packet: n.Packet.fromPartial({}),
      proofCommitment: new Uint8Array(),
      proofHeight: r.Height.fromPartial({}),
      signer: ""
    };
  }
  e.MsgRecvPacket = {
    typeUrl: "/ibc.core.channel.v1.MsgRecvPacket",
    encode(R, v = t.BinaryWriter.create()) {
      return R.packet !== void 0 && n.Packet.encode(R.packet, v.uint32(10).fork()).ldelim(), R.proofCommitment.length !== 0 && v.uint32(18).bytes(R.proofCommitment), R.proofHeight !== void 0 && r.Height.encode(R.proofHeight, v.uint32(26).fork()).ldelim(), R.signer !== "" && v.uint32(34).string(R.signer), v;
    },
    decode(R, v) {
      const D = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let W = v === void 0 ? D.len : D.pos + v;
      const H = _();
      for (; D.pos < W; ) {
        const a = D.uint32();
        switch (a >>> 3) {
          case 1:
            H.packet = n.Packet.decode(D, D.uint32());
            break;
          case 2:
            H.proofCommitment = D.bytes();
            break;
          case 3:
            H.proofHeight = r.Height.decode(D, D.uint32());
            break;
          case 4:
            H.signer = D.string();
            break;
          default:
            D.skipType(a & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(R) {
      const v = _();
      return (0, i.isSet)(R.packet) && (v.packet = n.Packet.fromJSON(R.packet)), (0, i.isSet)(R.proofCommitment) && (v.proofCommitment = (0, i.bytesFromBase64)(R.proofCommitment)), (0, i.isSet)(R.proofHeight) && (v.proofHeight = r.Height.fromJSON(R.proofHeight)), (0, i.isSet)(R.signer) && (v.signer = String(R.signer)), v;
    },
    toJSON(R) {
      const v = {};
      return R.packet !== void 0 && (v.packet = R.packet ? n.Packet.toJSON(R.packet) : void 0), R.proofCommitment !== void 0 && (v.proofCommitment = (0, i.base64FromBytes)(R.proofCommitment !== void 0 ? R.proofCommitment : new Uint8Array())), R.proofHeight !== void 0 && (v.proofHeight = R.proofHeight ? r.Height.toJSON(R.proofHeight) : void 0), R.signer !== void 0 && (v.signer = R.signer), v;
    },
    fromPartial(R) {
      const v = _();
      return R.packet !== void 0 && R.packet !== null && (v.packet = n.Packet.fromPartial(R.packet)), v.proofCommitment = R.proofCommitment ?? new Uint8Array(), R.proofHeight !== void 0 && R.proofHeight !== null && (v.proofHeight = r.Height.fromPartial(R.proofHeight)), v.signer = R.signer ?? "", v;
    }
  };
  function V() {
    return {
      result: 0
    };
  }
  e.MsgRecvPacketResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgRecvPacketResponse",
    encode(R, v = t.BinaryWriter.create()) {
      return R.result !== 0 && v.uint32(8).int32(R.result), v;
    },
    decode(R, v) {
      const D = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let W = v === void 0 ? D.len : D.pos + v;
      const H = V();
      for (; D.pos < W; ) {
        const a = D.uint32();
        switch (a >>> 3) {
          case 1:
            H.result = D.int32();
            break;
          default:
            D.skipType(a & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(R) {
      const v = V();
      return (0, i.isSet)(R.result) && (v.result = k(R.result)), v;
    },
    toJSON(R) {
      const v = {};
      return R.result !== void 0 && (v.result = C(R.result)), v;
    },
    fromPartial(R) {
      const v = V();
      return v.result = R.result ?? 0, v;
    }
  };
  function o() {
    return {
      packet: n.Packet.fromPartial({}),
      proofUnreceived: new Uint8Array(),
      proofHeight: r.Height.fromPartial({}),
      nextSequenceRecv: BigInt(0),
      signer: ""
    };
  }
  e.MsgTimeout = {
    typeUrl: "/ibc.core.channel.v1.MsgTimeout",
    encode(R, v = t.BinaryWriter.create()) {
      return R.packet !== void 0 && n.Packet.encode(R.packet, v.uint32(10).fork()).ldelim(), R.proofUnreceived.length !== 0 && v.uint32(18).bytes(R.proofUnreceived), R.proofHeight !== void 0 && r.Height.encode(R.proofHeight, v.uint32(26).fork()).ldelim(), R.nextSequenceRecv !== BigInt(0) && v.uint32(32).uint64(R.nextSequenceRecv), R.signer !== "" && v.uint32(42).string(R.signer), v;
    },
    decode(R, v) {
      const D = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let W = v === void 0 ? D.len : D.pos + v;
      const H = o();
      for (; D.pos < W; ) {
        const a = D.uint32();
        switch (a >>> 3) {
          case 1:
            H.packet = n.Packet.decode(D, D.uint32());
            break;
          case 2:
            H.proofUnreceived = D.bytes();
            break;
          case 3:
            H.proofHeight = r.Height.decode(D, D.uint32());
            break;
          case 4:
            H.nextSequenceRecv = D.uint64();
            break;
          case 5:
            H.signer = D.string();
            break;
          default:
            D.skipType(a & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(R) {
      const v = o();
      return (0, i.isSet)(R.packet) && (v.packet = n.Packet.fromJSON(R.packet)), (0, i.isSet)(R.proofUnreceived) && (v.proofUnreceived = (0, i.bytesFromBase64)(R.proofUnreceived)), (0, i.isSet)(R.proofHeight) && (v.proofHeight = r.Height.fromJSON(R.proofHeight)), (0, i.isSet)(R.nextSequenceRecv) && (v.nextSequenceRecv = BigInt(R.nextSequenceRecv.toString())), (0, i.isSet)(R.signer) && (v.signer = String(R.signer)), v;
    },
    toJSON(R) {
      const v = {};
      return R.packet !== void 0 && (v.packet = R.packet ? n.Packet.toJSON(R.packet) : void 0), R.proofUnreceived !== void 0 && (v.proofUnreceived = (0, i.base64FromBytes)(R.proofUnreceived !== void 0 ? R.proofUnreceived : new Uint8Array())), R.proofHeight !== void 0 && (v.proofHeight = R.proofHeight ? r.Height.toJSON(R.proofHeight) : void 0), R.nextSequenceRecv !== void 0 && (v.nextSequenceRecv = (R.nextSequenceRecv || BigInt(0)).toString()), R.signer !== void 0 && (v.signer = R.signer), v;
    },
    fromPartial(R) {
      const v = o();
      return R.packet !== void 0 && R.packet !== null && (v.packet = n.Packet.fromPartial(R.packet)), v.proofUnreceived = R.proofUnreceived ?? new Uint8Array(), R.proofHeight !== void 0 && R.proofHeight !== null && (v.proofHeight = r.Height.fromPartial(R.proofHeight)), R.nextSequenceRecv !== void 0 && R.nextSequenceRecv !== null && (v.nextSequenceRecv = BigInt(R.nextSequenceRecv.toString())), v.signer = R.signer ?? "", v;
    }
  };
  function p() {
    return {
      result: 0
    };
  }
  e.MsgTimeoutResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgTimeoutResponse",
    encode(R, v = t.BinaryWriter.create()) {
      return R.result !== 0 && v.uint32(8).int32(R.result), v;
    },
    decode(R, v) {
      const D = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let W = v === void 0 ? D.len : D.pos + v;
      const H = p();
      for (; D.pos < W; ) {
        const a = D.uint32();
        switch (a >>> 3) {
          case 1:
            H.result = D.int32();
            break;
          default:
            D.skipType(a & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(R) {
      const v = p();
      return (0, i.isSet)(R.result) && (v.result = k(R.result)), v;
    },
    toJSON(R) {
      const v = {};
      return R.result !== void 0 && (v.result = C(R.result)), v;
    },
    fromPartial(R) {
      const v = p();
      return v.result = R.result ?? 0, v;
    }
  };
  function I() {
    return {
      packet: n.Packet.fromPartial({}),
      proofUnreceived: new Uint8Array(),
      proofClose: new Uint8Array(),
      proofHeight: r.Height.fromPartial({}),
      nextSequenceRecv: BigInt(0),
      signer: ""
    };
  }
  e.MsgTimeoutOnClose = {
    typeUrl: "/ibc.core.channel.v1.MsgTimeoutOnClose",
    encode(R, v = t.BinaryWriter.create()) {
      return R.packet !== void 0 && n.Packet.encode(R.packet, v.uint32(10).fork()).ldelim(), R.proofUnreceived.length !== 0 && v.uint32(18).bytes(R.proofUnreceived), R.proofClose.length !== 0 && v.uint32(26).bytes(R.proofClose), R.proofHeight !== void 0 && r.Height.encode(R.proofHeight, v.uint32(34).fork()).ldelim(), R.nextSequenceRecv !== BigInt(0) && v.uint32(40).uint64(R.nextSequenceRecv), R.signer !== "" && v.uint32(50).string(R.signer), v;
    },
    decode(R, v) {
      const D = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let W = v === void 0 ? D.len : D.pos + v;
      const H = I();
      for (; D.pos < W; ) {
        const a = D.uint32();
        switch (a >>> 3) {
          case 1:
            H.packet = n.Packet.decode(D, D.uint32());
            break;
          case 2:
            H.proofUnreceived = D.bytes();
            break;
          case 3:
            H.proofClose = D.bytes();
            break;
          case 4:
            H.proofHeight = r.Height.decode(D, D.uint32());
            break;
          case 5:
            H.nextSequenceRecv = D.uint64();
            break;
          case 6:
            H.signer = D.string();
            break;
          default:
            D.skipType(a & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(R) {
      const v = I();
      return (0, i.isSet)(R.packet) && (v.packet = n.Packet.fromJSON(R.packet)), (0, i.isSet)(R.proofUnreceived) && (v.proofUnreceived = (0, i.bytesFromBase64)(R.proofUnreceived)), (0, i.isSet)(R.proofClose) && (v.proofClose = (0, i.bytesFromBase64)(R.proofClose)), (0, i.isSet)(R.proofHeight) && (v.proofHeight = r.Height.fromJSON(R.proofHeight)), (0, i.isSet)(R.nextSequenceRecv) && (v.nextSequenceRecv = BigInt(R.nextSequenceRecv.toString())), (0, i.isSet)(R.signer) && (v.signer = String(R.signer)), v;
    },
    toJSON(R) {
      const v = {};
      return R.packet !== void 0 && (v.packet = R.packet ? n.Packet.toJSON(R.packet) : void 0), R.proofUnreceived !== void 0 && (v.proofUnreceived = (0, i.base64FromBytes)(R.proofUnreceived !== void 0 ? R.proofUnreceived : new Uint8Array())), R.proofClose !== void 0 && (v.proofClose = (0, i.base64FromBytes)(R.proofClose !== void 0 ? R.proofClose : new Uint8Array())), R.proofHeight !== void 0 && (v.proofHeight = R.proofHeight ? r.Height.toJSON(R.proofHeight) : void 0), R.nextSequenceRecv !== void 0 && (v.nextSequenceRecv = (R.nextSequenceRecv || BigInt(0)).toString()), R.signer !== void 0 && (v.signer = R.signer), v;
    },
    fromPartial(R) {
      const v = I();
      return R.packet !== void 0 && R.packet !== null && (v.packet = n.Packet.fromPartial(R.packet)), v.proofUnreceived = R.proofUnreceived ?? new Uint8Array(), v.proofClose = R.proofClose ?? new Uint8Array(), R.proofHeight !== void 0 && R.proofHeight !== null && (v.proofHeight = r.Height.fromPartial(R.proofHeight)), R.nextSequenceRecv !== void 0 && R.nextSequenceRecv !== null && (v.nextSequenceRecv = BigInt(R.nextSequenceRecv.toString())), v.signer = R.signer ?? "", v;
    }
  };
  function q() {
    return {
      result: 0
    };
  }
  e.MsgTimeoutOnCloseResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgTimeoutOnCloseResponse",
    encode(R, v = t.BinaryWriter.create()) {
      return R.result !== 0 && v.uint32(8).int32(R.result), v;
    },
    decode(R, v) {
      const D = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let W = v === void 0 ? D.len : D.pos + v;
      const H = q();
      for (; D.pos < W; ) {
        const a = D.uint32();
        switch (a >>> 3) {
          case 1:
            H.result = D.int32();
            break;
          default:
            D.skipType(a & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(R) {
      const v = q();
      return (0, i.isSet)(R.result) && (v.result = k(R.result)), v;
    },
    toJSON(R) {
      const v = {};
      return R.result !== void 0 && (v.result = C(R.result)), v;
    },
    fromPartial(R) {
      const v = q();
      return v.result = R.result ?? 0, v;
    }
  };
  function s() {
    return {
      packet: n.Packet.fromPartial({}),
      acknowledgement: new Uint8Array(),
      proofAcked: new Uint8Array(),
      proofHeight: r.Height.fromPartial({}),
      signer: ""
    };
  }
  e.MsgAcknowledgement = {
    typeUrl: "/ibc.core.channel.v1.MsgAcknowledgement",
    encode(R, v = t.BinaryWriter.create()) {
      return R.packet !== void 0 && n.Packet.encode(R.packet, v.uint32(10).fork()).ldelim(), R.acknowledgement.length !== 0 && v.uint32(18).bytes(R.acknowledgement), R.proofAcked.length !== 0 && v.uint32(26).bytes(R.proofAcked), R.proofHeight !== void 0 && r.Height.encode(R.proofHeight, v.uint32(34).fork()).ldelim(), R.signer !== "" && v.uint32(42).string(R.signer), v;
    },
    decode(R, v) {
      const D = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let W = v === void 0 ? D.len : D.pos + v;
      const H = s();
      for (; D.pos < W; ) {
        const a = D.uint32();
        switch (a >>> 3) {
          case 1:
            H.packet = n.Packet.decode(D, D.uint32());
            break;
          case 2:
            H.acknowledgement = D.bytes();
            break;
          case 3:
            H.proofAcked = D.bytes();
            break;
          case 4:
            H.proofHeight = r.Height.decode(D, D.uint32());
            break;
          case 5:
            H.signer = D.string();
            break;
          default:
            D.skipType(a & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(R) {
      const v = s();
      return (0, i.isSet)(R.packet) && (v.packet = n.Packet.fromJSON(R.packet)), (0, i.isSet)(R.acknowledgement) && (v.acknowledgement = (0, i.bytesFromBase64)(R.acknowledgement)), (0, i.isSet)(R.proofAcked) && (v.proofAcked = (0, i.bytesFromBase64)(R.proofAcked)), (0, i.isSet)(R.proofHeight) && (v.proofHeight = r.Height.fromJSON(R.proofHeight)), (0, i.isSet)(R.signer) && (v.signer = String(R.signer)), v;
    },
    toJSON(R) {
      const v = {};
      return R.packet !== void 0 && (v.packet = R.packet ? n.Packet.toJSON(R.packet) : void 0), R.acknowledgement !== void 0 && (v.acknowledgement = (0, i.base64FromBytes)(R.acknowledgement !== void 0 ? R.acknowledgement : new Uint8Array())), R.proofAcked !== void 0 && (v.proofAcked = (0, i.base64FromBytes)(R.proofAcked !== void 0 ? R.proofAcked : new Uint8Array())), R.proofHeight !== void 0 && (v.proofHeight = R.proofHeight ? r.Height.toJSON(R.proofHeight) : void 0), R.signer !== void 0 && (v.signer = R.signer), v;
    },
    fromPartial(R) {
      const v = s();
      return R.packet !== void 0 && R.packet !== null && (v.packet = n.Packet.fromPartial(R.packet)), v.acknowledgement = R.acknowledgement ?? new Uint8Array(), v.proofAcked = R.proofAcked ?? new Uint8Array(), R.proofHeight !== void 0 && R.proofHeight !== null && (v.proofHeight = r.Height.fromPartial(R.proofHeight)), v.signer = R.signer ?? "", v;
    }
  };
  function u() {
    return {
      result: 0
    };
  }
  e.MsgAcknowledgementResponse = {
    typeUrl: "/ibc.core.channel.v1.MsgAcknowledgementResponse",
    encode(R, v = t.BinaryWriter.create()) {
      return R.result !== 0 && v.uint32(8).int32(R.result), v;
    },
    decode(R, v) {
      const D = R instanceof t.BinaryReader ? R : new t.BinaryReader(R);
      let W = v === void 0 ? D.len : D.pos + v;
      const H = u();
      for (; D.pos < W; ) {
        const a = D.uint32();
        switch (a >>> 3) {
          case 1:
            H.result = D.int32();
            break;
          default:
            D.skipType(a & 7);
            break;
        }
      }
      return H;
    },
    fromJSON(R) {
      const v = u();
      return (0, i.isSet)(R.result) && (v.result = k(R.result)), v;
    },
    toJSON(R) {
      const v = {};
      return R.result !== void 0 && (v.result = C(R.result)), v;
    },
    fromPartial(R) {
      const v = u();
      return v.result = R.result ?? 0, v;
    }
  };
  class A {
    constructor(v) {
      this.rpc = v, this.ChannelOpenInit = this.ChannelOpenInit.bind(this), this.ChannelOpenTry = this.ChannelOpenTry.bind(this), this.ChannelOpenAck = this.ChannelOpenAck.bind(this), this.ChannelOpenConfirm = this.ChannelOpenConfirm.bind(this), this.ChannelCloseInit = this.ChannelCloseInit.bind(this), this.ChannelCloseConfirm = this.ChannelCloseConfirm.bind(this), this.RecvPacket = this.RecvPacket.bind(this), this.Timeout = this.Timeout.bind(this), this.TimeoutOnClose = this.TimeoutOnClose.bind(this), this.Acknowledgement = this.Acknowledgement.bind(this);
    }
    ChannelOpenInit(v) {
      const D = e.MsgChannelOpenInit.encode(v).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenInit", D).then((H) => e.MsgChannelOpenInitResponse.decode(new t.BinaryReader(H)));
    }
    ChannelOpenTry(v) {
      const D = e.MsgChannelOpenTry.encode(v).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenTry", D).then((H) => e.MsgChannelOpenTryResponse.decode(new t.BinaryReader(H)));
    }
    ChannelOpenAck(v) {
      const D = e.MsgChannelOpenAck.encode(v).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenAck", D).then((H) => e.MsgChannelOpenAckResponse.decode(new t.BinaryReader(H)));
    }
    ChannelOpenConfirm(v) {
      const D = e.MsgChannelOpenConfirm.encode(v).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenConfirm", D).then((H) => e.MsgChannelOpenConfirmResponse.decode(new t.BinaryReader(H)));
    }
    ChannelCloseInit(v) {
      const D = e.MsgChannelCloseInit.encode(v).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseInit", D).then((H) => e.MsgChannelCloseInitResponse.decode(new t.BinaryReader(H)));
    }
    ChannelCloseConfirm(v) {
      const D = e.MsgChannelCloseConfirm.encode(v).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseConfirm", D).then((H) => e.MsgChannelCloseConfirmResponse.decode(new t.BinaryReader(H)));
    }
    RecvPacket(v) {
      const D = e.MsgRecvPacket.encode(v).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "RecvPacket", D).then((H) => e.MsgRecvPacketResponse.decode(new t.BinaryReader(H)));
    }
    Timeout(v) {
      const D = e.MsgTimeout.encode(v).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "Timeout", D).then((H) => e.MsgTimeoutResponse.decode(new t.BinaryReader(H)));
    }
    TimeoutOnClose(v) {
      const D = e.MsgTimeoutOnClose.encode(v).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "TimeoutOnClose", D).then((H) => e.MsgTimeoutOnCloseResponse.decode(new t.BinaryReader(H)));
    }
    Acknowledgement(v) {
      const D = e.MsgAcknowledgement.encode(v).finish();
      return this.rpc.request("ibc.core.channel.v1.Msg", "Acknowledgement", D).then((H) => e.MsgAcknowledgementResponse.decode(new t.BinaryReader(H)));
    }
  }
  e.MsgClientImpl = A;
})(dl);
var ul = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgSubmitMisbehaviourResponse = e.MsgSubmitMisbehaviour = e.MsgUpgradeClientResponse = e.MsgUpgradeClient = e.MsgUpdateClientResponse = e.MsgUpdateClient = e.MsgCreateClientResponse = e.MsgCreateClient = e.protobufPackage = void 0;
  const n = Be, r = re, t = ie;
  e.protobufPackage = "ibc.core.client.v1";
  function i() {
    return {
      clientState: void 0,
      consensusState: void 0,
      signer: ""
    };
  }
  e.MsgCreateClient = {
    typeUrl: "/ibc.core.client.v1.MsgCreateClient",
    encode(P, b = r.BinaryWriter.create()) {
      return P.clientState !== void 0 && n.Any.encode(P.clientState, b.uint32(10).fork()).ldelim(), P.consensusState !== void 0 && n.Any.encode(P.consensusState, b.uint32(18).fork()).ldelim(), P.signer !== "" && b.uint32(26).string(P.signer), b;
    },
    decode(P, b) {
      const c = P instanceof r.BinaryReader ? P : new r.BinaryReader(P);
      let l = b === void 0 ? c.len : c.pos + b;
      const y = i();
      for (; c.pos < l; ) {
        const E = c.uint32();
        switch (E >>> 3) {
          case 1:
            y.clientState = n.Any.decode(c, c.uint32());
            break;
          case 2:
            y.consensusState = n.Any.decode(c, c.uint32());
            break;
          case 3:
            y.signer = c.string();
            break;
          default:
            c.skipType(E & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(P) {
      const b = i();
      return (0, t.isSet)(P.clientState) && (b.clientState = n.Any.fromJSON(P.clientState)), (0, t.isSet)(P.consensusState) && (b.consensusState = n.Any.fromJSON(P.consensusState)), (0, t.isSet)(P.signer) && (b.signer = String(P.signer)), b;
    },
    toJSON(P) {
      const b = {};
      return P.clientState !== void 0 && (b.clientState = P.clientState ? n.Any.toJSON(P.clientState) : void 0), P.consensusState !== void 0 && (b.consensusState = P.consensusState ? n.Any.toJSON(P.consensusState) : void 0), P.signer !== void 0 && (b.signer = P.signer), b;
    },
    fromPartial(P) {
      const b = i();
      return P.clientState !== void 0 && P.clientState !== null && (b.clientState = n.Any.fromPartial(P.clientState)), P.consensusState !== void 0 && P.consensusState !== null && (b.consensusState = n.Any.fromPartial(P.consensusState)), b.signer = P.signer ?? "", b;
    }
  };
  function f() {
    return {};
  }
  e.MsgCreateClientResponse = {
    typeUrl: "/ibc.core.client.v1.MsgCreateClientResponse",
    encode(P, b = r.BinaryWriter.create()) {
      return b;
    },
    decode(P, b) {
      const c = P instanceof r.BinaryReader ? P : new r.BinaryReader(P);
      let l = b === void 0 ? c.len : c.pos + b;
      const y = f();
      for (; c.pos < l; ) {
        const E = c.uint32();
        switch (E >>> 3) {
          default:
            c.skipType(E & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(P) {
      return f();
    },
    toJSON(P) {
      return {};
    },
    fromPartial(P) {
      return f();
    }
  };
  function k() {
    return {
      clientId: "",
      clientMessage: void 0,
      signer: ""
    };
  }
  e.MsgUpdateClient = {
    typeUrl: "/ibc.core.client.v1.MsgUpdateClient",
    encode(P, b = r.BinaryWriter.create()) {
      return P.clientId !== "" && b.uint32(10).string(P.clientId), P.clientMessage !== void 0 && n.Any.encode(P.clientMessage, b.uint32(18).fork()).ldelim(), P.signer !== "" && b.uint32(26).string(P.signer), b;
    },
    decode(P, b) {
      const c = P instanceof r.BinaryReader ? P : new r.BinaryReader(P);
      let l = b === void 0 ? c.len : c.pos + b;
      const y = k();
      for (; c.pos < l; ) {
        const E = c.uint32();
        switch (E >>> 3) {
          case 1:
            y.clientId = c.string();
            break;
          case 2:
            y.clientMessage = n.Any.decode(c, c.uint32());
            break;
          case 3:
            y.signer = c.string();
            break;
          default:
            c.skipType(E & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(P) {
      const b = k();
      return (0, t.isSet)(P.clientId) && (b.clientId = String(P.clientId)), (0, t.isSet)(P.clientMessage) && (b.clientMessage = n.Any.fromJSON(P.clientMessage)), (0, t.isSet)(P.signer) && (b.signer = String(P.signer)), b;
    },
    toJSON(P) {
      const b = {};
      return P.clientId !== void 0 && (b.clientId = P.clientId), P.clientMessage !== void 0 && (b.clientMessage = P.clientMessage ? n.Any.toJSON(P.clientMessage) : void 0), P.signer !== void 0 && (b.signer = P.signer), b;
    },
    fromPartial(P) {
      const b = k();
      return b.clientId = P.clientId ?? "", P.clientMessage !== void 0 && P.clientMessage !== null && (b.clientMessage = n.Any.fromPartial(P.clientMessage)), b.signer = P.signer ?? "", b;
    }
  };
  function C() {
    return {};
  }
  e.MsgUpdateClientResponse = {
    typeUrl: "/ibc.core.client.v1.MsgUpdateClientResponse",
    encode(P, b = r.BinaryWriter.create()) {
      return b;
    },
    decode(P, b) {
      const c = P instanceof r.BinaryReader ? P : new r.BinaryReader(P);
      let l = b === void 0 ? c.len : c.pos + b;
      const y = C();
      for (; c.pos < l; ) {
        const E = c.uint32();
        switch (E >>> 3) {
          default:
            c.skipType(E & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(P) {
      return C();
    },
    toJSON(P) {
      return {};
    },
    fromPartial(P) {
      return C();
    }
  };
  function T() {
    return {
      clientId: "",
      clientState: void 0,
      consensusState: void 0,
      proofUpgradeClient: new Uint8Array(),
      proofUpgradeConsensusState: new Uint8Array(),
      signer: ""
    };
  }
  e.MsgUpgradeClient = {
    typeUrl: "/ibc.core.client.v1.MsgUpgradeClient",
    encode(P, b = r.BinaryWriter.create()) {
      return P.clientId !== "" && b.uint32(10).string(P.clientId), P.clientState !== void 0 && n.Any.encode(P.clientState, b.uint32(18).fork()).ldelim(), P.consensusState !== void 0 && n.Any.encode(P.consensusState, b.uint32(26).fork()).ldelim(), P.proofUpgradeClient.length !== 0 && b.uint32(34).bytes(P.proofUpgradeClient), P.proofUpgradeConsensusState.length !== 0 && b.uint32(42).bytes(P.proofUpgradeConsensusState), P.signer !== "" && b.uint32(50).string(P.signer), b;
    },
    decode(P, b) {
      const c = P instanceof r.BinaryReader ? P : new r.BinaryReader(P);
      let l = b === void 0 ? c.len : c.pos + b;
      const y = T();
      for (; c.pos < l; ) {
        const E = c.uint32();
        switch (E >>> 3) {
          case 1:
            y.clientId = c.string();
            break;
          case 2:
            y.clientState = n.Any.decode(c, c.uint32());
            break;
          case 3:
            y.consensusState = n.Any.decode(c, c.uint32());
            break;
          case 4:
            y.proofUpgradeClient = c.bytes();
            break;
          case 5:
            y.proofUpgradeConsensusState = c.bytes();
            break;
          case 6:
            y.signer = c.string();
            break;
          default:
            c.skipType(E & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(P) {
      const b = T();
      return (0, t.isSet)(P.clientId) && (b.clientId = String(P.clientId)), (0, t.isSet)(P.clientState) && (b.clientState = n.Any.fromJSON(P.clientState)), (0, t.isSet)(P.consensusState) && (b.consensusState = n.Any.fromJSON(P.consensusState)), (0, t.isSet)(P.proofUpgradeClient) && (b.proofUpgradeClient = (0, t.bytesFromBase64)(P.proofUpgradeClient)), (0, t.isSet)(P.proofUpgradeConsensusState) && (b.proofUpgradeConsensusState = (0, t.bytesFromBase64)(P.proofUpgradeConsensusState)), (0, t.isSet)(P.signer) && (b.signer = String(P.signer)), b;
    },
    toJSON(P) {
      const b = {};
      return P.clientId !== void 0 && (b.clientId = P.clientId), P.clientState !== void 0 && (b.clientState = P.clientState ? n.Any.toJSON(P.clientState) : void 0), P.consensusState !== void 0 && (b.consensusState = P.consensusState ? n.Any.toJSON(P.consensusState) : void 0), P.proofUpgradeClient !== void 0 && (b.proofUpgradeClient = (0, t.base64FromBytes)(P.proofUpgradeClient !== void 0 ? P.proofUpgradeClient : new Uint8Array())), P.proofUpgradeConsensusState !== void 0 && (b.proofUpgradeConsensusState = (0, t.base64FromBytes)(P.proofUpgradeConsensusState !== void 0 ? P.proofUpgradeConsensusState : new Uint8Array())), P.signer !== void 0 && (b.signer = P.signer), b;
    },
    fromPartial(P) {
      const b = T();
      return b.clientId = P.clientId ?? "", P.clientState !== void 0 && P.clientState !== null && (b.clientState = n.Any.fromPartial(P.clientState)), P.consensusState !== void 0 && P.consensusState !== null && (b.consensusState = n.Any.fromPartial(P.consensusState)), b.proofUpgradeClient = P.proofUpgradeClient ?? new Uint8Array(), b.proofUpgradeConsensusState = P.proofUpgradeConsensusState ?? new Uint8Array(), b.signer = P.signer ?? "", b;
    }
  };
  function U() {
    return {};
  }
  e.MsgUpgradeClientResponse = {
    typeUrl: "/ibc.core.client.v1.MsgUpgradeClientResponse",
    encode(P, b = r.BinaryWriter.create()) {
      return b;
    },
    decode(P, b) {
      const c = P instanceof r.BinaryReader ? P : new r.BinaryReader(P);
      let l = b === void 0 ? c.len : c.pos + b;
      const y = U();
      for (; c.pos < l; ) {
        const E = c.uint32();
        switch (E >>> 3) {
          default:
            c.skipType(E & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(P) {
      return U();
    },
    toJSON(P) {
      return {};
    },
    fromPartial(P) {
      return U();
    }
  };
  function w() {
    return {
      clientId: "",
      misbehaviour: void 0,
      signer: ""
    };
  }
  e.MsgSubmitMisbehaviour = {
    typeUrl: "/ibc.core.client.v1.MsgSubmitMisbehaviour",
    encode(P, b = r.BinaryWriter.create()) {
      return P.clientId !== "" && b.uint32(10).string(P.clientId), P.misbehaviour !== void 0 && n.Any.encode(P.misbehaviour, b.uint32(18).fork()).ldelim(), P.signer !== "" && b.uint32(26).string(P.signer), b;
    },
    decode(P, b) {
      const c = P instanceof r.BinaryReader ? P : new r.BinaryReader(P);
      let l = b === void 0 ? c.len : c.pos + b;
      const y = w();
      for (; c.pos < l; ) {
        const E = c.uint32();
        switch (E >>> 3) {
          case 1:
            y.clientId = c.string();
            break;
          case 2:
            y.misbehaviour = n.Any.decode(c, c.uint32());
            break;
          case 3:
            y.signer = c.string();
            break;
          default:
            c.skipType(E & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(P) {
      const b = w();
      return (0, t.isSet)(P.clientId) && (b.clientId = String(P.clientId)), (0, t.isSet)(P.misbehaviour) && (b.misbehaviour = n.Any.fromJSON(P.misbehaviour)), (0, t.isSet)(P.signer) && (b.signer = String(P.signer)), b;
    },
    toJSON(P) {
      const b = {};
      return P.clientId !== void 0 && (b.clientId = P.clientId), P.misbehaviour !== void 0 && (b.misbehaviour = P.misbehaviour ? n.Any.toJSON(P.misbehaviour) : void 0), P.signer !== void 0 && (b.signer = P.signer), b;
    },
    fromPartial(P) {
      const b = w();
      return b.clientId = P.clientId ?? "", P.misbehaviour !== void 0 && P.misbehaviour !== null && (b.misbehaviour = n.Any.fromPartial(P.misbehaviour)), b.signer = P.signer ?? "", b;
    }
  };
  function N() {
    return {};
  }
  e.MsgSubmitMisbehaviourResponse = {
    typeUrl: "/ibc.core.client.v1.MsgSubmitMisbehaviourResponse",
    encode(P, b = r.BinaryWriter.create()) {
      return b;
    },
    decode(P, b) {
      const c = P instanceof r.BinaryReader ? P : new r.BinaryReader(P);
      let l = b === void 0 ? c.len : c.pos + b;
      const y = N();
      for (; c.pos < l; ) {
        const E = c.uint32();
        switch (E >>> 3) {
          default:
            c.skipType(E & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(P) {
      return N();
    },
    toJSON(P) {
      return {};
    },
    fromPartial(P) {
      return N();
    }
  };
  class h {
    constructor(b) {
      this.rpc = b, this.CreateClient = this.CreateClient.bind(this), this.UpdateClient = this.UpdateClient.bind(this), this.UpgradeClient = this.UpgradeClient.bind(this), this.SubmitMisbehaviour = this.SubmitMisbehaviour.bind(this);
    }
    CreateClient(b) {
      const c = e.MsgCreateClient.encode(b).finish();
      return this.rpc.request("ibc.core.client.v1.Msg", "CreateClient", c).then((y) => e.MsgCreateClientResponse.decode(new r.BinaryReader(y)));
    }
    UpdateClient(b) {
      const c = e.MsgUpdateClient.encode(b).finish();
      return this.rpc.request("ibc.core.client.v1.Msg", "UpdateClient", c).then((y) => e.MsgUpdateClientResponse.decode(new r.BinaryReader(y)));
    }
    UpgradeClient(b) {
      const c = e.MsgUpgradeClient.encode(b).finish();
      return this.rpc.request("ibc.core.client.v1.Msg", "UpgradeClient", c).then((y) => e.MsgUpgradeClientResponse.decode(new r.BinaryReader(y)));
    }
    SubmitMisbehaviour(b) {
      const c = e.MsgSubmitMisbehaviour.encode(b).finish();
      return this.rpc.request("ibc.core.client.v1.Msg", "SubmitMisbehaviour", c).then((y) => e.MsgSubmitMisbehaviourResponse.decode(new r.BinaryReader(y)));
    }
  }
  e.MsgClientImpl = h;
})(ul);
var cl = {}, Sd = {}, ln = {}, kd = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CompressedNonExistenceProof = e.CompressedExistenceProof = e.CompressedBatchEntry = e.CompressedBatchProof = e.BatchEntry = e.BatchProof = e.InnerSpec = e.ProofSpec = e.InnerOp = e.LeafOp = e.CommitmentProof = e.NonExistenceProof = e.ExistenceProof = e.lengthOpToJSON = e.lengthOpFromJSON = e.LengthOp = e.hashOpToJSON = e.hashOpFromJSON = e.HashOp = e.protobufPackage = void 0;
  const n = re, r = ie;
  e.protobufPackage = "cosmos.ics23.v1";
  var t;
  (function(o) {
    o[o.NO_HASH = 0] = "NO_HASH", o[o.SHA256 = 1] = "SHA256", o[o.SHA512 = 2] = "SHA512", o[o.KECCAK = 3] = "KECCAK", o[o.RIPEMD160 = 4] = "RIPEMD160", o[o.BITCOIN = 5] = "BITCOIN", o[o.SHA512_256 = 6] = "SHA512_256", o[o.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(t || (e.HashOp = t = {}));
  function i(o) {
    switch (o) {
      case 0:
      case "NO_HASH":
        return t.NO_HASH;
      case 1:
      case "SHA256":
        return t.SHA256;
      case 2:
      case "SHA512":
        return t.SHA512;
      case 3:
      case "KECCAK":
        return t.KECCAK;
      case 4:
      case "RIPEMD160":
        return t.RIPEMD160;
      case 5:
      case "BITCOIN":
        return t.BITCOIN;
      case 6:
      case "SHA512_256":
        return t.SHA512_256;
      case -1:
      case "UNRECOGNIZED":
      default:
        return t.UNRECOGNIZED;
    }
  }
  e.hashOpFromJSON = i;
  function f(o) {
    switch (o) {
      case t.NO_HASH:
        return "NO_HASH";
      case t.SHA256:
        return "SHA256";
      case t.SHA512:
        return "SHA512";
      case t.KECCAK:
        return "KECCAK";
      case t.RIPEMD160:
        return "RIPEMD160";
      case t.BITCOIN:
        return "BITCOIN";
      case t.SHA512_256:
        return "SHA512_256";
      case t.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.hashOpToJSON = f;
  var k;
  (function(o) {
    o[o.NO_PREFIX = 0] = "NO_PREFIX", o[o.VAR_PROTO = 1] = "VAR_PROTO", o[o.VAR_RLP = 2] = "VAR_RLP", o[o.FIXED32_BIG = 3] = "FIXED32_BIG", o[o.FIXED32_LITTLE = 4] = "FIXED32_LITTLE", o[o.FIXED64_BIG = 5] = "FIXED64_BIG", o[o.FIXED64_LITTLE = 6] = "FIXED64_LITTLE", o[o.REQUIRE_32_BYTES = 7] = "REQUIRE_32_BYTES", o[o.REQUIRE_64_BYTES = 8] = "REQUIRE_64_BYTES", o[o.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(k || (e.LengthOp = k = {}));
  function C(o) {
    switch (o) {
      case 0:
      case "NO_PREFIX":
        return k.NO_PREFIX;
      case 1:
      case "VAR_PROTO":
        return k.VAR_PROTO;
      case 2:
      case "VAR_RLP":
        return k.VAR_RLP;
      case 3:
      case "FIXED32_BIG":
        return k.FIXED32_BIG;
      case 4:
      case "FIXED32_LITTLE":
        return k.FIXED32_LITTLE;
      case 5:
      case "FIXED64_BIG":
        return k.FIXED64_BIG;
      case 6:
      case "FIXED64_LITTLE":
        return k.FIXED64_LITTLE;
      case 7:
      case "REQUIRE_32_BYTES":
        return k.REQUIRE_32_BYTES;
      case 8:
      case "REQUIRE_64_BYTES":
        return k.REQUIRE_64_BYTES;
      case -1:
      case "UNRECOGNIZED":
      default:
        return k.UNRECOGNIZED;
    }
  }
  e.lengthOpFromJSON = C;
  function T(o) {
    switch (o) {
      case k.NO_PREFIX:
        return "NO_PREFIX";
      case k.VAR_PROTO:
        return "VAR_PROTO";
      case k.VAR_RLP:
        return "VAR_RLP";
      case k.FIXED32_BIG:
        return "FIXED32_BIG";
      case k.FIXED32_LITTLE:
        return "FIXED32_LITTLE";
      case k.FIXED64_BIG:
        return "FIXED64_BIG";
      case k.FIXED64_LITTLE:
        return "FIXED64_LITTLE";
      case k.REQUIRE_32_BYTES:
        return "REQUIRE_32_BYTES";
      case k.REQUIRE_64_BYTES:
        return "REQUIRE_64_BYTES";
      case k.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.lengthOpToJSON = T;
  function U() {
    return {
      key: new Uint8Array(),
      value: new Uint8Array(),
      leaf: void 0,
      path: []
    };
  }
  e.ExistenceProof = {
    typeUrl: "/cosmos.ics23.v1.ExistenceProof",
    encode(o, p = n.BinaryWriter.create()) {
      o.key.length !== 0 && p.uint32(10).bytes(o.key), o.value.length !== 0 && p.uint32(18).bytes(o.value), o.leaf !== void 0 && e.LeafOp.encode(o.leaf, p.uint32(26).fork()).ldelim();
      for (const I of o.path)
        e.InnerOp.encode(I, p.uint32(34).fork()).ldelim();
      return p;
    },
    decode(o, p) {
      const I = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = U();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.key = I.bytes();
            break;
          case 2:
            s.value = I.bytes();
            break;
          case 3:
            s.leaf = e.LeafOp.decode(I, I.uint32());
            break;
          case 4:
            s.path.push(e.InnerOp.decode(I, I.uint32()));
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = U();
      return (0, r.isSet)(o.key) && (p.key = (0, r.bytesFromBase64)(o.key)), (0, r.isSet)(o.value) && (p.value = (0, r.bytesFromBase64)(o.value)), (0, r.isSet)(o.leaf) && (p.leaf = e.LeafOp.fromJSON(o.leaf)), Array.isArray(o == null ? void 0 : o.path) && (p.path = o.path.map((I) => e.InnerOp.fromJSON(I))), p;
    },
    toJSON(o) {
      const p = {};
      return o.key !== void 0 && (p.key = (0, r.base64FromBytes)(o.key !== void 0 ? o.key : new Uint8Array())), o.value !== void 0 && (p.value = (0, r.base64FromBytes)(o.value !== void 0 ? o.value : new Uint8Array())), o.leaf !== void 0 && (p.leaf = o.leaf ? e.LeafOp.toJSON(o.leaf) : void 0), o.path ? p.path = o.path.map((I) => I ? e.InnerOp.toJSON(I) : void 0) : p.path = [], p;
    },
    fromPartial(o) {
      var I;
      const p = U();
      return p.key = o.key ?? new Uint8Array(), p.value = o.value ?? new Uint8Array(), o.leaf !== void 0 && o.leaf !== null && (p.leaf = e.LeafOp.fromPartial(o.leaf)), p.path = ((I = o.path) == null ? void 0 : I.map((q) => e.InnerOp.fromPartial(q))) || [], p;
    }
  };
  function w() {
    return {
      key: new Uint8Array(),
      left: void 0,
      right: void 0
    };
  }
  e.NonExistenceProof = {
    typeUrl: "/cosmos.ics23.v1.NonExistenceProof",
    encode(o, p = n.BinaryWriter.create()) {
      return o.key.length !== 0 && p.uint32(10).bytes(o.key), o.left !== void 0 && e.ExistenceProof.encode(o.left, p.uint32(18).fork()).ldelim(), o.right !== void 0 && e.ExistenceProof.encode(o.right, p.uint32(26).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = w();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.key = I.bytes();
            break;
          case 2:
            s.left = e.ExistenceProof.decode(I, I.uint32());
            break;
          case 3:
            s.right = e.ExistenceProof.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = w();
      return (0, r.isSet)(o.key) && (p.key = (0, r.bytesFromBase64)(o.key)), (0, r.isSet)(o.left) && (p.left = e.ExistenceProof.fromJSON(o.left)), (0, r.isSet)(o.right) && (p.right = e.ExistenceProof.fromJSON(o.right)), p;
    },
    toJSON(o) {
      const p = {};
      return o.key !== void 0 && (p.key = (0, r.base64FromBytes)(o.key !== void 0 ? o.key : new Uint8Array())), o.left !== void 0 && (p.left = o.left ? e.ExistenceProof.toJSON(o.left) : void 0), o.right !== void 0 && (p.right = o.right ? e.ExistenceProof.toJSON(o.right) : void 0), p;
    },
    fromPartial(o) {
      const p = w();
      return p.key = o.key ?? new Uint8Array(), o.left !== void 0 && o.left !== null && (p.left = e.ExistenceProof.fromPartial(o.left)), o.right !== void 0 && o.right !== null && (p.right = e.ExistenceProof.fromPartial(o.right)), p;
    }
  };
  function N() {
    return {
      exist: void 0,
      nonexist: void 0,
      batch: void 0,
      compressed: void 0
    };
  }
  e.CommitmentProof = {
    typeUrl: "/cosmos.ics23.v1.CommitmentProof",
    encode(o, p = n.BinaryWriter.create()) {
      return o.exist !== void 0 && e.ExistenceProof.encode(o.exist, p.uint32(10).fork()).ldelim(), o.nonexist !== void 0 && e.NonExistenceProof.encode(o.nonexist, p.uint32(18).fork()).ldelim(), o.batch !== void 0 && e.BatchProof.encode(o.batch, p.uint32(26).fork()).ldelim(), o.compressed !== void 0 && e.CompressedBatchProof.encode(o.compressed, p.uint32(34).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = N();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.exist = e.ExistenceProof.decode(I, I.uint32());
            break;
          case 2:
            s.nonexist = e.NonExistenceProof.decode(I, I.uint32());
            break;
          case 3:
            s.batch = e.BatchProof.decode(I, I.uint32());
            break;
          case 4:
            s.compressed = e.CompressedBatchProof.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = N();
      return (0, r.isSet)(o.exist) && (p.exist = e.ExistenceProof.fromJSON(o.exist)), (0, r.isSet)(o.nonexist) && (p.nonexist = e.NonExistenceProof.fromJSON(o.nonexist)), (0, r.isSet)(o.batch) && (p.batch = e.BatchProof.fromJSON(o.batch)), (0, r.isSet)(o.compressed) && (p.compressed = e.CompressedBatchProof.fromJSON(o.compressed)), p;
    },
    toJSON(o) {
      const p = {};
      return o.exist !== void 0 && (p.exist = o.exist ? e.ExistenceProof.toJSON(o.exist) : void 0), o.nonexist !== void 0 && (p.nonexist = o.nonexist ? e.NonExistenceProof.toJSON(o.nonexist) : void 0), o.batch !== void 0 && (p.batch = o.batch ? e.BatchProof.toJSON(o.batch) : void 0), o.compressed !== void 0 && (p.compressed = o.compressed ? e.CompressedBatchProof.toJSON(o.compressed) : void 0), p;
    },
    fromPartial(o) {
      const p = N();
      return o.exist !== void 0 && o.exist !== null && (p.exist = e.ExistenceProof.fromPartial(o.exist)), o.nonexist !== void 0 && o.nonexist !== null && (p.nonexist = e.NonExistenceProof.fromPartial(o.nonexist)), o.batch !== void 0 && o.batch !== null && (p.batch = e.BatchProof.fromPartial(o.batch)), o.compressed !== void 0 && o.compressed !== null && (p.compressed = e.CompressedBatchProof.fromPartial(o.compressed)), p;
    }
  };
  function h() {
    return {
      hash: 0,
      prehashKey: 0,
      prehashValue: 0,
      length: 0,
      prefix: new Uint8Array()
    };
  }
  e.LeafOp = {
    typeUrl: "/cosmos.ics23.v1.LeafOp",
    encode(o, p = n.BinaryWriter.create()) {
      return o.hash !== 0 && p.uint32(8).int32(o.hash), o.prehashKey !== 0 && p.uint32(16).int32(o.prehashKey), o.prehashValue !== 0 && p.uint32(24).int32(o.prehashValue), o.length !== 0 && p.uint32(32).int32(o.length), o.prefix.length !== 0 && p.uint32(42).bytes(o.prefix), p;
    },
    decode(o, p) {
      const I = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = h();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.hash = I.int32();
            break;
          case 2:
            s.prehashKey = I.int32();
            break;
          case 3:
            s.prehashValue = I.int32();
            break;
          case 4:
            s.length = I.int32();
            break;
          case 5:
            s.prefix = I.bytes();
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = h();
      return (0, r.isSet)(o.hash) && (p.hash = i(o.hash)), (0, r.isSet)(o.prehashKey) && (p.prehashKey = i(o.prehashKey)), (0, r.isSet)(o.prehashValue) && (p.prehashValue = i(o.prehashValue)), (0, r.isSet)(o.length) && (p.length = C(o.length)), (0, r.isSet)(o.prefix) && (p.prefix = (0, r.bytesFromBase64)(o.prefix)), p;
    },
    toJSON(o) {
      const p = {};
      return o.hash !== void 0 && (p.hash = f(o.hash)), o.prehashKey !== void 0 && (p.prehashKey = f(o.prehashKey)), o.prehashValue !== void 0 && (p.prehashValue = f(o.prehashValue)), o.length !== void 0 && (p.length = T(o.length)), o.prefix !== void 0 && (p.prefix = (0, r.base64FromBytes)(o.prefix !== void 0 ? o.prefix : new Uint8Array())), p;
    },
    fromPartial(o) {
      const p = h();
      return p.hash = o.hash ?? 0, p.prehashKey = o.prehashKey ?? 0, p.prehashValue = o.prehashValue ?? 0, p.length = o.length ?? 0, p.prefix = o.prefix ?? new Uint8Array(), p;
    }
  };
  function P() {
    return {
      hash: 0,
      prefix: new Uint8Array(),
      suffix: new Uint8Array()
    };
  }
  e.InnerOp = {
    typeUrl: "/cosmos.ics23.v1.InnerOp",
    encode(o, p = n.BinaryWriter.create()) {
      return o.hash !== 0 && p.uint32(8).int32(o.hash), o.prefix.length !== 0 && p.uint32(18).bytes(o.prefix), o.suffix.length !== 0 && p.uint32(26).bytes(o.suffix), p;
    },
    decode(o, p) {
      const I = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = P();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.hash = I.int32();
            break;
          case 2:
            s.prefix = I.bytes();
            break;
          case 3:
            s.suffix = I.bytes();
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = P();
      return (0, r.isSet)(o.hash) && (p.hash = i(o.hash)), (0, r.isSet)(o.prefix) && (p.prefix = (0, r.bytesFromBase64)(o.prefix)), (0, r.isSet)(o.suffix) && (p.suffix = (0, r.bytesFromBase64)(o.suffix)), p;
    },
    toJSON(o) {
      const p = {};
      return o.hash !== void 0 && (p.hash = f(o.hash)), o.prefix !== void 0 && (p.prefix = (0, r.base64FromBytes)(o.prefix !== void 0 ? o.prefix : new Uint8Array())), o.suffix !== void 0 && (p.suffix = (0, r.base64FromBytes)(o.suffix !== void 0 ? o.suffix : new Uint8Array())), p;
    },
    fromPartial(o) {
      const p = P();
      return p.hash = o.hash ?? 0, p.prefix = o.prefix ?? new Uint8Array(), p.suffix = o.suffix ?? new Uint8Array(), p;
    }
  };
  function b() {
    return {
      leafSpec: void 0,
      innerSpec: void 0,
      maxDepth: 0,
      minDepth: 0
    };
  }
  e.ProofSpec = {
    typeUrl: "/cosmos.ics23.v1.ProofSpec",
    encode(o, p = n.BinaryWriter.create()) {
      return o.leafSpec !== void 0 && e.LeafOp.encode(o.leafSpec, p.uint32(10).fork()).ldelim(), o.innerSpec !== void 0 && e.InnerSpec.encode(o.innerSpec, p.uint32(18).fork()).ldelim(), o.maxDepth !== 0 && p.uint32(24).int32(o.maxDepth), o.minDepth !== 0 && p.uint32(32).int32(o.minDepth), p;
    },
    decode(o, p) {
      const I = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = b();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.leafSpec = e.LeafOp.decode(I, I.uint32());
            break;
          case 2:
            s.innerSpec = e.InnerSpec.decode(I, I.uint32());
            break;
          case 3:
            s.maxDepth = I.int32();
            break;
          case 4:
            s.minDepth = I.int32();
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = b();
      return (0, r.isSet)(o.leafSpec) && (p.leafSpec = e.LeafOp.fromJSON(o.leafSpec)), (0, r.isSet)(o.innerSpec) && (p.innerSpec = e.InnerSpec.fromJSON(o.innerSpec)), (0, r.isSet)(o.maxDepth) && (p.maxDepth = Number(o.maxDepth)), (0, r.isSet)(o.minDepth) && (p.minDepth = Number(o.minDepth)), p;
    },
    toJSON(o) {
      const p = {};
      return o.leafSpec !== void 0 && (p.leafSpec = o.leafSpec ? e.LeafOp.toJSON(o.leafSpec) : void 0), o.innerSpec !== void 0 && (p.innerSpec = o.innerSpec ? e.InnerSpec.toJSON(o.innerSpec) : void 0), o.maxDepth !== void 0 && (p.maxDepth = Math.round(o.maxDepth)), o.minDepth !== void 0 && (p.minDepth = Math.round(o.minDepth)), p;
    },
    fromPartial(o) {
      const p = b();
      return o.leafSpec !== void 0 && o.leafSpec !== null && (p.leafSpec = e.LeafOp.fromPartial(o.leafSpec)), o.innerSpec !== void 0 && o.innerSpec !== null && (p.innerSpec = e.InnerSpec.fromPartial(o.innerSpec)), p.maxDepth = o.maxDepth ?? 0, p.minDepth = o.minDepth ?? 0, p;
    }
  };
  function c() {
    return {
      childOrder: [],
      childSize: 0,
      minPrefixLength: 0,
      maxPrefixLength: 0,
      emptyChild: new Uint8Array(),
      hash: 0
    };
  }
  e.InnerSpec = {
    typeUrl: "/cosmos.ics23.v1.InnerSpec",
    encode(o, p = n.BinaryWriter.create()) {
      p.uint32(10).fork();
      for (const I of o.childOrder)
        p.int32(I);
      return p.ldelim(), o.childSize !== 0 && p.uint32(16).int32(o.childSize), o.minPrefixLength !== 0 && p.uint32(24).int32(o.minPrefixLength), o.maxPrefixLength !== 0 && p.uint32(32).int32(o.maxPrefixLength), o.emptyChild.length !== 0 && p.uint32(42).bytes(o.emptyChild), o.hash !== 0 && p.uint32(48).int32(o.hash), p;
    },
    decode(o, p) {
      const I = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = c();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            if ((u & 7) === 2) {
              const A = I.uint32() + I.pos;
              for (; I.pos < A; )
                s.childOrder.push(I.int32());
            } else
              s.childOrder.push(I.int32());
            break;
          case 2:
            s.childSize = I.int32();
            break;
          case 3:
            s.minPrefixLength = I.int32();
            break;
          case 4:
            s.maxPrefixLength = I.int32();
            break;
          case 5:
            s.emptyChild = I.bytes();
            break;
          case 6:
            s.hash = I.int32();
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = c();
      return Array.isArray(o == null ? void 0 : o.childOrder) && (p.childOrder = o.childOrder.map((I) => Number(I))), (0, r.isSet)(o.childSize) && (p.childSize = Number(o.childSize)), (0, r.isSet)(o.minPrefixLength) && (p.minPrefixLength = Number(o.minPrefixLength)), (0, r.isSet)(o.maxPrefixLength) && (p.maxPrefixLength = Number(o.maxPrefixLength)), (0, r.isSet)(o.emptyChild) && (p.emptyChild = (0, r.bytesFromBase64)(o.emptyChild)), (0, r.isSet)(o.hash) && (p.hash = i(o.hash)), p;
    },
    toJSON(o) {
      const p = {};
      return o.childOrder ? p.childOrder = o.childOrder.map((I) => Math.round(I)) : p.childOrder = [], o.childSize !== void 0 && (p.childSize = Math.round(o.childSize)), o.minPrefixLength !== void 0 && (p.minPrefixLength = Math.round(o.minPrefixLength)), o.maxPrefixLength !== void 0 && (p.maxPrefixLength = Math.round(o.maxPrefixLength)), o.emptyChild !== void 0 && (p.emptyChild = (0, r.base64FromBytes)(o.emptyChild !== void 0 ? o.emptyChild : new Uint8Array())), o.hash !== void 0 && (p.hash = f(o.hash)), p;
    },
    fromPartial(o) {
      var I;
      const p = c();
      return p.childOrder = ((I = o.childOrder) == null ? void 0 : I.map((q) => q)) || [], p.childSize = o.childSize ?? 0, p.minPrefixLength = o.minPrefixLength ?? 0, p.maxPrefixLength = o.maxPrefixLength ?? 0, p.emptyChild = o.emptyChild ?? new Uint8Array(), p.hash = o.hash ?? 0, p;
    }
  };
  function l() {
    return {
      entries: []
    };
  }
  e.BatchProof = {
    typeUrl: "/cosmos.ics23.v1.BatchProof",
    encode(o, p = n.BinaryWriter.create()) {
      for (const I of o.entries)
        e.BatchEntry.encode(I, p.uint32(10).fork()).ldelim();
      return p;
    },
    decode(o, p) {
      const I = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = l();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.entries.push(e.BatchEntry.decode(I, I.uint32()));
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = l();
      return Array.isArray(o == null ? void 0 : o.entries) && (p.entries = o.entries.map((I) => e.BatchEntry.fromJSON(I))), p;
    },
    toJSON(o) {
      const p = {};
      return o.entries ? p.entries = o.entries.map((I) => I ? e.BatchEntry.toJSON(I) : void 0) : p.entries = [], p;
    },
    fromPartial(o) {
      var I;
      const p = l();
      return p.entries = ((I = o.entries) == null ? void 0 : I.map((q) => e.BatchEntry.fromPartial(q))) || [], p;
    }
  };
  function y() {
    return {
      exist: void 0,
      nonexist: void 0
    };
  }
  e.BatchEntry = {
    typeUrl: "/cosmos.ics23.v1.BatchEntry",
    encode(o, p = n.BinaryWriter.create()) {
      return o.exist !== void 0 && e.ExistenceProof.encode(o.exist, p.uint32(10).fork()).ldelim(), o.nonexist !== void 0 && e.NonExistenceProof.encode(o.nonexist, p.uint32(18).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = y();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.exist = e.ExistenceProof.decode(I, I.uint32());
            break;
          case 2:
            s.nonexist = e.NonExistenceProof.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = y();
      return (0, r.isSet)(o.exist) && (p.exist = e.ExistenceProof.fromJSON(o.exist)), (0, r.isSet)(o.nonexist) && (p.nonexist = e.NonExistenceProof.fromJSON(o.nonexist)), p;
    },
    toJSON(o) {
      const p = {};
      return o.exist !== void 0 && (p.exist = o.exist ? e.ExistenceProof.toJSON(o.exist) : void 0), o.nonexist !== void 0 && (p.nonexist = o.nonexist ? e.NonExistenceProof.toJSON(o.nonexist) : void 0), p;
    },
    fromPartial(o) {
      const p = y();
      return o.exist !== void 0 && o.exist !== null && (p.exist = e.ExistenceProof.fromPartial(o.exist)), o.nonexist !== void 0 && o.nonexist !== null && (p.nonexist = e.NonExistenceProof.fromPartial(o.nonexist)), p;
    }
  };
  function E() {
    return {
      entries: [],
      lookupInners: []
    };
  }
  e.CompressedBatchProof = {
    typeUrl: "/cosmos.ics23.v1.CompressedBatchProof",
    encode(o, p = n.BinaryWriter.create()) {
      for (const I of o.entries)
        e.CompressedBatchEntry.encode(I, p.uint32(10).fork()).ldelim();
      for (const I of o.lookupInners)
        e.InnerOp.encode(I, p.uint32(18).fork()).ldelim();
      return p;
    },
    decode(o, p) {
      const I = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = E();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.entries.push(e.CompressedBatchEntry.decode(I, I.uint32()));
            break;
          case 2:
            s.lookupInners.push(e.InnerOp.decode(I, I.uint32()));
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = E();
      return Array.isArray(o == null ? void 0 : o.entries) && (p.entries = o.entries.map((I) => e.CompressedBatchEntry.fromJSON(I))), Array.isArray(o == null ? void 0 : o.lookupInners) && (p.lookupInners = o.lookupInners.map((I) => e.InnerOp.fromJSON(I))), p;
    },
    toJSON(o) {
      const p = {};
      return o.entries ? p.entries = o.entries.map((I) => I ? e.CompressedBatchEntry.toJSON(I) : void 0) : p.entries = [], o.lookupInners ? p.lookupInners = o.lookupInners.map((I) => I ? e.InnerOp.toJSON(I) : void 0) : p.lookupInners = [], p;
    },
    fromPartial(o) {
      var I, q;
      const p = E();
      return p.entries = ((I = o.entries) == null ? void 0 : I.map((s) => e.CompressedBatchEntry.fromPartial(s))) || [], p.lookupInners = ((q = o.lookupInners) == null ? void 0 : q.map((s) => e.InnerOp.fromPartial(s))) || [], p;
    }
  };
  function J() {
    return {
      exist: void 0,
      nonexist: void 0
    };
  }
  e.CompressedBatchEntry = {
    typeUrl: "/cosmos.ics23.v1.CompressedBatchEntry",
    encode(o, p = n.BinaryWriter.create()) {
      return o.exist !== void 0 && e.CompressedExistenceProof.encode(o.exist, p.uint32(10).fork()).ldelim(), o.nonexist !== void 0 && e.CompressedNonExistenceProof.encode(o.nonexist, p.uint32(18).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = J();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.exist = e.CompressedExistenceProof.decode(I, I.uint32());
            break;
          case 2:
            s.nonexist = e.CompressedNonExistenceProof.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = J();
      return (0, r.isSet)(o.exist) && (p.exist = e.CompressedExistenceProof.fromJSON(o.exist)), (0, r.isSet)(o.nonexist) && (p.nonexist = e.CompressedNonExistenceProof.fromJSON(o.nonexist)), p;
    },
    toJSON(o) {
      const p = {};
      return o.exist !== void 0 && (p.exist = o.exist ? e.CompressedExistenceProof.toJSON(o.exist) : void 0), o.nonexist !== void 0 && (p.nonexist = o.nonexist ? e.CompressedNonExistenceProof.toJSON(o.nonexist) : void 0), p;
    },
    fromPartial(o) {
      const p = J();
      return o.exist !== void 0 && o.exist !== null && (p.exist = e.CompressedExistenceProof.fromPartial(o.exist)), o.nonexist !== void 0 && o.nonexist !== null && (p.nonexist = e.CompressedNonExistenceProof.fromPartial(o.nonexist)), p;
    }
  };
  function _() {
    return {
      key: new Uint8Array(),
      value: new Uint8Array(),
      leaf: void 0,
      path: []
    };
  }
  e.CompressedExistenceProof = {
    typeUrl: "/cosmos.ics23.v1.CompressedExistenceProof",
    encode(o, p = n.BinaryWriter.create()) {
      o.key.length !== 0 && p.uint32(10).bytes(o.key), o.value.length !== 0 && p.uint32(18).bytes(o.value), o.leaf !== void 0 && e.LeafOp.encode(o.leaf, p.uint32(26).fork()).ldelim(), p.uint32(34).fork();
      for (const I of o.path)
        p.int32(I);
      return p.ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = _();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.key = I.bytes();
            break;
          case 2:
            s.value = I.bytes();
            break;
          case 3:
            s.leaf = e.LeafOp.decode(I, I.uint32());
            break;
          case 4:
            if ((u & 7) === 2) {
              const A = I.uint32() + I.pos;
              for (; I.pos < A; )
                s.path.push(I.int32());
            } else
              s.path.push(I.int32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = _();
      return (0, r.isSet)(o.key) && (p.key = (0, r.bytesFromBase64)(o.key)), (0, r.isSet)(o.value) && (p.value = (0, r.bytesFromBase64)(o.value)), (0, r.isSet)(o.leaf) && (p.leaf = e.LeafOp.fromJSON(o.leaf)), Array.isArray(o == null ? void 0 : o.path) && (p.path = o.path.map((I) => Number(I))), p;
    },
    toJSON(o) {
      const p = {};
      return o.key !== void 0 && (p.key = (0, r.base64FromBytes)(o.key !== void 0 ? o.key : new Uint8Array())), o.value !== void 0 && (p.value = (0, r.base64FromBytes)(o.value !== void 0 ? o.value : new Uint8Array())), o.leaf !== void 0 && (p.leaf = o.leaf ? e.LeafOp.toJSON(o.leaf) : void 0), o.path ? p.path = o.path.map((I) => Math.round(I)) : p.path = [], p;
    },
    fromPartial(o) {
      var I;
      const p = _();
      return p.key = o.key ?? new Uint8Array(), p.value = o.value ?? new Uint8Array(), o.leaf !== void 0 && o.leaf !== null && (p.leaf = e.LeafOp.fromPartial(o.leaf)), p.path = ((I = o.path) == null ? void 0 : I.map((q) => q)) || [], p;
    }
  };
  function V() {
    return {
      key: new Uint8Array(),
      left: void 0,
      right: void 0
    };
  }
  e.CompressedNonExistenceProof = {
    typeUrl: "/cosmos.ics23.v1.CompressedNonExistenceProof",
    encode(o, p = n.BinaryWriter.create()) {
      return o.key.length !== 0 && p.uint32(10).bytes(o.key), o.left !== void 0 && e.CompressedExistenceProof.encode(o.left, p.uint32(18).fork()).ldelim(), o.right !== void 0 && e.CompressedExistenceProof.encode(o.right, p.uint32(26).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof n.BinaryReader ? o : new n.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = V();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.key = I.bytes();
            break;
          case 2:
            s.left = e.CompressedExistenceProof.decode(I, I.uint32());
            break;
          case 3:
            s.right = e.CompressedExistenceProof.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = V();
      return (0, r.isSet)(o.key) && (p.key = (0, r.bytesFromBase64)(o.key)), (0, r.isSet)(o.left) && (p.left = e.CompressedExistenceProof.fromJSON(o.left)), (0, r.isSet)(o.right) && (p.right = e.CompressedExistenceProof.fromJSON(o.right)), p;
    },
    toJSON(o) {
      const p = {};
      return o.key !== void 0 && (p.key = (0, r.base64FromBytes)(o.key !== void 0 ? o.key : new Uint8Array())), o.left !== void 0 && (p.left = o.left ? e.CompressedExistenceProof.toJSON(o.left) : void 0), o.right !== void 0 && (p.right = o.right ? e.CompressedExistenceProof.toJSON(o.right) : void 0), p;
    },
    fromPartial(o) {
      const p = V();
      return p.key = o.key ?? new Uint8Array(), o.left !== void 0 && o.left !== null && (p.left = e.CompressedExistenceProof.fromPartial(o.left)), o.right !== void 0 && o.right !== null && (p.right = e.CompressedExistenceProof.fromPartial(o.right)), p;
    }
  };
})(kd);
Object.defineProperty(ln, "__esModule", { value: !0 });
ln.MerkleProof = ln.MerklePath = ln.MerklePrefix = ln.MerkleRoot = ln.protobufPackage = void 0;
const _r = kd, bn = re, Kt = ie;
ln.protobufPackage = "ibc.core.commitment.v1";
function is() {
  return {
    hash: new Uint8Array()
  };
}
ln.MerkleRoot = {
  typeUrl: "/ibc.core.commitment.v1.MerkleRoot",
  encode(e, n = bn.BinaryWriter.create()) {
    return e.hash.length !== 0 && n.uint32(10).bytes(e.hash), n;
  },
  decode(e, n) {
    const r = e instanceof bn.BinaryReader ? e : new bn.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = is();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.hash = r.bytes();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = is();
    return (0, Kt.isSet)(e.hash) && (n.hash = (0, Kt.bytesFromBase64)(e.hash)), n;
  },
  toJSON(e) {
    const n = {};
    return e.hash !== void 0 && (n.hash = (0, Kt.base64FromBytes)(e.hash !== void 0 ? e.hash : new Uint8Array())), n;
  },
  fromPartial(e) {
    const n = is();
    return n.hash = e.hash ?? new Uint8Array(), n;
  }
};
function os() {
  return {
    keyPrefix: new Uint8Array()
  };
}
ln.MerklePrefix = {
  typeUrl: "/ibc.core.commitment.v1.MerklePrefix",
  encode(e, n = bn.BinaryWriter.create()) {
    return e.keyPrefix.length !== 0 && n.uint32(10).bytes(e.keyPrefix), n;
  },
  decode(e, n) {
    const r = e instanceof bn.BinaryReader ? e : new bn.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = os();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.keyPrefix = r.bytes();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = os();
    return (0, Kt.isSet)(e.keyPrefix) && (n.keyPrefix = (0, Kt.bytesFromBase64)(e.keyPrefix)), n;
  },
  toJSON(e) {
    const n = {};
    return e.keyPrefix !== void 0 && (n.keyPrefix = (0, Kt.base64FromBytes)(e.keyPrefix !== void 0 ? e.keyPrefix : new Uint8Array())), n;
  },
  fromPartial(e) {
    const n = os();
    return n.keyPrefix = e.keyPrefix ?? new Uint8Array(), n;
  }
};
function as() {
  return {
    keyPath: []
  };
}
ln.MerklePath = {
  typeUrl: "/ibc.core.commitment.v1.MerklePath",
  encode(e, n = bn.BinaryWriter.create()) {
    for (const r of e.keyPath)
      n.uint32(10).string(r);
    return n;
  },
  decode(e, n) {
    const r = e instanceof bn.BinaryReader ? e : new bn.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = as();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.keyPath.push(r.string());
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = as();
    return Array.isArray(e == null ? void 0 : e.keyPath) && (n.keyPath = e.keyPath.map((r) => String(r))), n;
  },
  toJSON(e) {
    const n = {};
    return e.keyPath ? n.keyPath = e.keyPath.map((r) => r) : n.keyPath = [], n;
  },
  fromPartial(e) {
    var r;
    const n = as();
    return n.keyPath = ((r = e.keyPath) == null ? void 0 : r.map((t) => t)) || [], n;
  }
};
function ss() {
  return {
    proofs: []
  };
}
ln.MerkleProof = {
  typeUrl: "/ibc.core.commitment.v1.MerkleProof",
  encode(e, n = bn.BinaryWriter.create()) {
    for (const r of e.proofs)
      _r.CommitmentProof.encode(r, n.uint32(10).fork()).ldelim();
    return n;
  },
  decode(e, n) {
    const r = e instanceof bn.BinaryReader ? e : new bn.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = ss();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.proofs.push(_r.CommitmentProof.decode(r, r.uint32()));
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = ss();
    return Array.isArray(e == null ? void 0 : e.proofs) && (n.proofs = e.proofs.map((r) => _r.CommitmentProof.fromJSON(r))), n;
  },
  toJSON(e) {
    const n = {};
    return e.proofs ? n.proofs = e.proofs.map((r) => r ? _r.CommitmentProof.toJSON(r) : void 0) : n.proofs = [], n;
  },
  fromPartial(e) {
    var r;
    const n = ss();
    return n.proofs = ((r = e.proofs) == null ? void 0 : r.map((t) => _r.CommitmentProof.fromPartial(t))) || [], n;
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Params = e.Version = e.ConnectionPaths = e.ClientPaths = e.Counterparty = e.IdentifiedConnection = e.ConnectionEnd = e.stateToJSON = e.stateFromJSON = e.State = e.protobufPackage = void 0;
  const n = ln, r = re, t = ie;
  e.protobufPackage = "ibc.core.connection.v1";
  var i;
  (function(b) {
    b[b.STATE_UNINITIALIZED_UNSPECIFIED = 0] = "STATE_UNINITIALIZED_UNSPECIFIED", b[b.STATE_INIT = 1] = "STATE_INIT", b[b.STATE_TRYOPEN = 2] = "STATE_TRYOPEN", b[b.STATE_OPEN = 3] = "STATE_OPEN", b[b.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(i || (e.State = i = {}));
  function f(b) {
    switch (b) {
      case 0:
      case "STATE_UNINITIALIZED_UNSPECIFIED":
        return i.STATE_UNINITIALIZED_UNSPECIFIED;
      case 1:
      case "STATE_INIT":
        return i.STATE_INIT;
      case 2:
      case "STATE_TRYOPEN":
        return i.STATE_TRYOPEN;
      case 3:
      case "STATE_OPEN":
        return i.STATE_OPEN;
      case -1:
      case "UNRECOGNIZED":
      default:
        return i.UNRECOGNIZED;
    }
  }
  e.stateFromJSON = f;
  function k(b) {
    switch (b) {
      case i.STATE_UNINITIALIZED_UNSPECIFIED:
        return "STATE_UNINITIALIZED_UNSPECIFIED";
      case i.STATE_INIT:
        return "STATE_INIT";
      case i.STATE_TRYOPEN:
        return "STATE_TRYOPEN";
      case i.STATE_OPEN:
        return "STATE_OPEN";
      case i.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.stateToJSON = k;
  function C() {
    return {
      clientId: "",
      versions: [],
      state: 0,
      counterparty: e.Counterparty.fromPartial({}),
      delayPeriod: BigInt(0)
    };
  }
  e.ConnectionEnd = {
    typeUrl: "/ibc.core.connection.v1.ConnectionEnd",
    encode(b, c = r.BinaryWriter.create()) {
      b.clientId !== "" && c.uint32(10).string(b.clientId);
      for (const l of b.versions)
        e.Version.encode(l, c.uint32(18).fork()).ldelim();
      return b.state !== 0 && c.uint32(24).int32(b.state), b.counterparty !== void 0 && e.Counterparty.encode(b.counterparty, c.uint32(34).fork()).ldelim(), b.delayPeriod !== BigInt(0) && c.uint32(40).uint64(b.delayPeriod), c;
    },
    decode(b, c) {
      const l = b instanceof r.BinaryReader ? b : new r.BinaryReader(b);
      let y = c === void 0 ? l.len : l.pos + c;
      const E = C();
      for (; l.pos < y; ) {
        const J = l.uint32();
        switch (J >>> 3) {
          case 1:
            E.clientId = l.string();
            break;
          case 2:
            E.versions.push(e.Version.decode(l, l.uint32()));
            break;
          case 3:
            E.state = l.int32();
            break;
          case 4:
            E.counterparty = e.Counterparty.decode(l, l.uint32());
            break;
          case 5:
            E.delayPeriod = l.uint64();
            break;
          default:
            l.skipType(J & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(b) {
      const c = C();
      return (0, t.isSet)(b.clientId) && (c.clientId = String(b.clientId)), Array.isArray(b == null ? void 0 : b.versions) && (c.versions = b.versions.map((l) => e.Version.fromJSON(l))), (0, t.isSet)(b.state) && (c.state = f(b.state)), (0, t.isSet)(b.counterparty) && (c.counterparty = e.Counterparty.fromJSON(b.counterparty)), (0, t.isSet)(b.delayPeriod) && (c.delayPeriod = BigInt(b.delayPeriod.toString())), c;
    },
    toJSON(b) {
      const c = {};
      return b.clientId !== void 0 && (c.clientId = b.clientId), b.versions ? c.versions = b.versions.map((l) => l ? e.Version.toJSON(l) : void 0) : c.versions = [], b.state !== void 0 && (c.state = k(b.state)), b.counterparty !== void 0 && (c.counterparty = b.counterparty ? e.Counterparty.toJSON(b.counterparty) : void 0), b.delayPeriod !== void 0 && (c.delayPeriod = (b.delayPeriod || BigInt(0)).toString()), c;
    },
    fromPartial(b) {
      var l;
      const c = C();
      return c.clientId = b.clientId ?? "", c.versions = ((l = b.versions) == null ? void 0 : l.map((y) => e.Version.fromPartial(y))) || [], c.state = b.state ?? 0, b.counterparty !== void 0 && b.counterparty !== null && (c.counterparty = e.Counterparty.fromPartial(b.counterparty)), b.delayPeriod !== void 0 && b.delayPeriod !== null && (c.delayPeriod = BigInt(b.delayPeriod.toString())), c;
    }
  };
  function T() {
    return {
      id: "",
      clientId: "",
      versions: [],
      state: 0,
      counterparty: e.Counterparty.fromPartial({}),
      delayPeriod: BigInt(0)
    };
  }
  e.IdentifiedConnection = {
    typeUrl: "/ibc.core.connection.v1.IdentifiedConnection",
    encode(b, c = r.BinaryWriter.create()) {
      b.id !== "" && c.uint32(10).string(b.id), b.clientId !== "" && c.uint32(18).string(b.clientId);
      for (const l of b.versions)
        e.Version.encode(l, c.uint32(26).fork()).ldelim();
      return b.state !== 0 && c.uint32(32).int32(b.state), b.counterparty !== void 0 && e.Counterparty.encode(b.counterparty, c.uint32(42).fork()).ldelim(), b.delayPeriod !== BigInt(0) && c.uint32(48).uint64(b.delayPeriod), c;
    },
    decode(b, c) {
      const l = b instanceof r.BinaryReader ? b : new r.BinaryReader(b);
      let y = c === void 0 ? l.len : l.pos + c;
      const E = T();
      for (; l.pos < y; ) {
        const J = l.uint32();
        switch (J >>> 3) {
          case 1:
            E.id = l.string();
            break;
          case 2:
            E.clientId = l.string();
            break;
          case 3:
            E.versions.push(e.Version.decode(l, l.uint32()));
            break;
          case 4:
            E.state = l.int32();
            break;
          case 5:
            E.counterparty = e.Counterparty.decode(l, l.uint32());
            break;
          case 6:
            E.delayPeriod = l.uint64();
            break;
          default:
            l.skipType(J & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(b) {
      const c = T();
      return (0, t.isSet)(b.id) && (c.id = String(b.id)), (0, t.isSet)(b.clientId) && (c.clientId = String(b.clientId)), Array.isArray(b == null ? void 0 : b.versions) && (c.versions = b.versions.map((l) => e.Version.fromJSON(l))), (0, t.isSet)(b.state) && (c.state = f(b.state)), (0, t.isSet)(b.counterparty) && (c.counterparty = e.Counterparty.fromJSON(b.counterparty)), (0, t.isSet)(b.delayPeriod) && (c.delayPeriod = BigInt(b.delayPeriod.toString())), c;
    },
    toJSON(b) {
      const c = {};
      return b.id !== void 0 && (c.id = b.id), b.clientId !== void 0 && (c.clientId = b.clientId), b.versions ? c.versions = b.versions.map((l) => l ? e.Version.toJSON(l) : void 0) : c.versions = [], b.state !== void 0 && (c.state = k(b.state)), b.counterparty !== void 0 && (c.counterparty = b.counterparty ? e.Counterparty.toJSON(b.counterparty) : void 0), b.delayPeriod !== void 0 && (c.delayPeriod = (b.delayPeriod || BigInt(0)).toString()), c;
    },
    fromPartial(b) {
      var l;
      const c = T();
      return c.id = b.id ?? "", c.clientId = b.clientId ?? "", c.versions = ((l = b.versions) == null ? void 0 : l.map((y) => e.Version.fromPartial(y))) || [], c.state = b.state ?? 0, b.counterparty !== void 0 && b.counterparty !== null && (c.counterparty = e.Counterparty.fromPartial(b.counterparty)), b.delayPeriod !== void 0 && b.delayPeriod !== null && (c.delayPeriod = BigInt(b.delayPeriod.toString())), c;
    }
  };
  function U() {
    return {
      clientId: "",
      connectionId: "",
      prefix: n.MerklePrefix.fromPartial({})
    };
  }
  e.Counterparty = {
    typeUrl: "/ibc.core.connection.v1.Counterparty",
    encode(b, c = r.BinaryWriter.create()) {
      return b.clientId !== "" && c.uint32(10).string(b.clientId), b.connectionId !== "" && c.uint32(18).string(b.connectionId), b.prefix !== void 0 && n.MerklePrefix.encode(b.prefix, c.uint32(26).fork()).ldelim(), c;
    },
    decode(b, c) {
      const l = b instanceof r.BinaryReader ? b : new r.BinaryReader(b);
      let y = c === void 0 ? l.len : l.pos + c;
      const E = U();
      for (; l.pos < y; ) {
        const J = l.uint32();
        switch (J >>> 3) {
          case 1:
            E.clientId = l.string();
            break;
          case 2:
            E.connectionId = l.string();
            break;
          case 3:
            E.prefix = n.MerklePrefix.decode(l, l.uint32());
            break;
          default:
            l.skipType(J & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(b) {
      const c = U();
      return (0, t.isSet)(b.clientId) && (c.clientId = String(b.clientId)), (0, t.isSet)(b.connectionId) && (c.connectionId = String(b.connectionId)), (0, t.isSet)(b.prefix) && (c.prefix = n.MerklePrefix.fromJSON(b.prefix)), c;
    },
    toJSON(b) {
      const c = {};
      return b.clientId !== void 0 && (c.clientId = b.clientId), b.connectionId !== void 0 && (c.connectionId = b.connectionId), b.prefix !== void 0 && (c.prefix = b.prefix ? n.MerklePrefix.toJSON(b.prefix) : void 0), c;
    },
    fromPartial(b) {
      const c = U();
      return c.clientId = b.clientId ?? "", c.connectionId = b.connectionId ?? "", b.prefix !== void 0 && b.prefix !== null && (c.prefix = n.MerklePrefix.fromPartial(b.prefix)), c;
    }
  };
  function w() {
    return {
      paths: []
    };
  }
  e.ClientPaths = {
    typeUrl: "/ibc.core.connection.v1.ClientPaths",
    encode(b, c = r.BinaryWriter.create()) {
      for (const l of b.paths)
        c.uint32(10).string(l);
      return c;
    },
    decode(b, c) {
      const l = b instanceof r.BinaryReader ? b : new r.BinaryReader(b);
      let y = c === void 0 ? l.len : l.pos + c;
      const E = w();
      for (; l.pos < y; ) {
        const J = l.uint32();
        switch (J >>> 3) {
          case 1:
            E.paths.push(l.string());
            break;
          default:
            l.skipType(J & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(b) {
      const c = w();
      return Array.isArray(b == null ? void 0 : b.paths) && (c.paths = b.paths.map((l) => String(l))), c;
    },
    toJSON(b) {
      const c = {};
      return b.paths ? c.paths = b.paths.map((l) => l) : c.paths = [], c;
    },
    fromPartial(b) {
      var l;
      const c = w();
      return c.paths = ((l = b.paths) == null ? void 0 : l.map((y) => y)) || [], c;
    }
  };
  function N() {
    return {
      clientId: "",
      paths: []
    };
  }
  e.ConnectionPaths = {
    typeUrl: "/ibc.core.connection.v1.ConnectionPaths",
    encode(b, c = r.BinaryWriter.create()) {
      b.clientId !== "" && c.uint32(10).string(b.clientId);
      for (const l of b.paths)
        c.uint32(18).string(l);
      return c;
    },
    decode(b, c) {
      const l = b instanceof r.BinaryReader ? b : new r.BinaryReader(b);
      let y = c === void 0 ? l.len : l.pos + c;
      const E = N();
      for (; l.pos < y; ) {
        const J = l.uint32();
        switch (J >>> 3) {
          case 1:
            E.clientId = l.string();
            break;
          case 2:
            E.paths.push(l.string());
            break;
          default:
            l.skipType(J & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(b) {
      const c = N();
      return (0, t.isSet)(b.clientId) && (c.clientId = String(b.clientId)), Array.isArray(b == null ? void 0 : b.paths) && (c.paths = b.paths.map((l) => String(l))), c;
    },
    toJSON(b) {
      const c = {};
      return b.clientId !== void 0 && (c.clientId = b.clientId), b.paths ? c.paths = b.paths.map((l) => l) : c.paths = [], c;
    },
    fromPartial(b) {
      var l;
      const c = N();
      return c.clientId = b.clientId ?? "", c.paths = ((l = b.paths) == null ? void 0 : l.map((y) => y)) || [], c;
    }
  };
  function h() {
    return {
      identifier: "",
      features: []
    };
  }
  e.Version = {
    typeUrl: "/ibc.core.connection.v1.Version",
    encode(b, c = r.BinaryWriter.create()) {
      b.identifier !== "" && c.uint32(10).string(b.identifier);
      for (const l of b.features)
        c.uint32(18).string(l);
      return c;
    },
    decode(b, c) {
      const l = b instanceof r.BinaryReader ? b : new r.BinaryReader(b);
      let y = c === void 0 ? l.len : l.pos + c;
      const E = h();
      for (; l.pos < y; ) {
        const J = l.uint32();
        switch (J >>> 3) {
          case 1:
            E.identifier = l.string();
            break;
          case 2:
            E.features.push(l.string());
            break;
          default:
            l.skipType(J & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(b) {
      const c = h();
      return (0, t.isSet)(b.identifier) && (c.identifier = String(b.identifier)), Array.isArray(b == null ? void 0 : b.features) && (c.features = b.features.map((l) => String(l))), c;
    },
    toJSON(b) {
      const c = {};
      return b.identifier !== void 0 && (c.identifier = b.identifier), b.features ? c.features = b.features.map((l) => l) : c.features = [], c;
    },
    fromPartial(b) {
      var l;
      const c = h();
      return c.identifier = b.identifier ?? "", c.features = ((l = b.features) == null ? void 0 : l.map((y) => y)) || [], c;
    }
  };
  function P() {
    return {
      maxExpectedTimePerBlock: BigInt(0)
    };
  }
  e.Params = {
    typeUrl: "/ibc.core.connection.v1.Params",
    encode(b, c = r.BinaryWriter.create()) {
      return b.maxExpectedTimePerBlock !== BigInt(0) && c.uint32(8).uint64(b.maxExpectedTimePerBlock), c;
    },
    decode(b, c) {
      const l = b instanceof r.BinaryReader ? b : new r.BinaryReader(b);
      let y = c === void 0 ? l.len : l.pos + c;
      const E = P();
      for (; l.pos < y; ) {
        const J = l.uint32();
        switch (J >>> 3) {
          case 1:
            E.maxExpectedTimePerBlock = l.uint64();
            break;
          default:
            l.skipType(J & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(b) {
      const c = P();
      return (0, t.isSet)(b.maxExpectedTimePerBlock) && (c.maxExpectedTimePerBlock = BigInt(b.maxExpectedTimePerBlock.toString())), c;
    },
    toJSON(b) {
      const c = {};
      return b.maxExpectedTimePerBlock !== void 0 && (c.maxExpectedTimePerBlock = (b.maxExpectedTimePerBlock || BigInt(0)).toString()), c;
    },
    fromPartial(b) {
      const c = P();
      return b.maxExpectedTimePerBlock !== void 0 && b.maxExpectedTimePerBlock !== null && (c.maxExpectedTimePerBlock = BigInt(b.maxExpectedTimePerBlock.toString())), c;
    }
  };
})(Sd);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgConnectionOpenConfirmResponse = e.MsgConnectionOpenConfirm = e.MsgConnectionOpenAckResponse = e.MsgConnectionOpenAck = e.MsgConnectionOpenTryResponse = e.MsgConnectionOpenTry = e.MsgConnectionOpenInitResponse = e.MsgConnectionOpenInit = e.protobufPackage = void 0;
  const n = Sd, r = Be, t = Yn, i = re, f = ie;
  e.protobufPackage = "ibc.core.connection.v1";
  function k() {
    return {
      clientId: "",
      counterparty: n.Counterparty.fromPartial({}),
      version: void 0,
      delayPeriod: BigInt(0),
      signer: ""
    };
  }
  e.MsgConnectionOpenInit = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenInit",
    encode(c, l = i.BinaryWriter.create()) {
      return c.clientId !== "" && l.uint32(10).string(c.clientId), c.counterparty !== void 0 && n.Counterparty.encode(c.counterparty, l.uint32(18).fork()).ldelim(), c.version !== void 0 && n.Version.encode(c.version, l.uint32(26).fork()).ldelim(), c.delayPeriod !== BigInt(0) && l.uint32(32).uint64(c.delayPeriod), c.signer !== "" && l.uint32(42).string(c.signer), l;
    },
    decode(c, l) {
      const y = c instanceof i.BinaryReader ? c : new i.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = k();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.clientId = y.string();
            break;
          case 2:
            J.counterparty = n.Counterparty.decode(y, y.uint32());
            break;
          case 3:
            J.version = n.Version.decode(y, y.uint32());
            break;
          case 4:
            J.delayPeriod = y.uint64();
            break;
          case 5:
            J.signer = y.string();
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = k();
      return (0, f.isSet)(c.clientId) && (l.clientId = String(c.clientId)), (0, f.isSet)(c.counterparty) && (l.counterparty = n.Counterparty.fromJSON(c.counterparty)), (0, f.isSet)(c.version) && (l.version = n.Version.fromJSON(c.version)), (0, f.isSet)(c.delayPeriod) && (l.delayPeriod = BigInt(c.delayPeriod.toString())), (0, f.isSet)(c.signer) && (l.signer = String(c.signer)), l;
    },
    toJSON(c) {
      const l = {};
      return c.clientId !== void 0 && (l.clientId = c.clientId), c.counterparty !== void 0 && (l.counterparty = c.counterparty ? n.Counterparty.toJSON(c.counterparty) : void 0), c.version !== void 0 && (l.version = c.version ? n.Version.toJSON(c.version) : void 0), c.delayPeriod !== void 0 && (l.delayPeriod = (c.delayPeriod || BigInt(0)).toString()), c.signer !== void 0 && (l.signer = c.signer), l;
    },
    fromPartial(c) {
      const l = k();
      return l.clientId = c.clientId ?? "", c.counterparty !== void 0 && c.counterparty !== null && (l.counterparty = n.Counterparty.fromPartial(c.counterparty)), c.version !== void 0 && c.version !== null && (l.version = n.Version.fromPartial(c.version)), c.delayPeriod !== void 0 && c.delayPeriod !== null && (l.delayPeriod = BigInt(c.delayPeriod.toString())), l.signer = c.signer ?? "", l;
    }
  };
  function C() {
    return {};
  }
  e.MsgConnectionOpenInitResponse = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenInitResponse",
    encode(c, l = i.BinaryWriter.create()) {
      return l;
    },
    decode(c, l) {
      const y = c instanceof i.BinaryReader ? c : new i.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = C();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      return C();
    },
    toJSON(c) {
      return {};
    },
    fromPartial(c) {
      return C();
    }
  };
  function T() {
    return {
      clientId: "",
      previousConnectionId: "",
      clientState: void 0,
      counterparty: n.Counterparty.fromPartial({}),
      delayPeriod: BigInt(0),
      counterpartyVersions: [],
      proofHeight: t.Height.fromPartial({}),
      proofInit: new Uint8Array(),
      proofClient: new Uint8Array(),
      proofConsensus: new Uint8Array(),
      consensusHeight: t.Height.fromPartial({}),
      signer: "",
      hostConsensusStateProof: new Uint8Array()
    };
  }
  e.MsgConnectionOpenTry = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenTry",
    encode(c, l = i.BinaryWriter.create()) {
      c.clientId !== "" && l.uint32(10).string(c.clientId), c.previousConnectionId !== "" && l.uint32(18).string(c.previousConnectionId), c.clientState !== void 0 && r.Any.encode(c.clientState, l.uint32(26).fork()).ldelim(), c.counterparty !== void 0 && n.Counterparty.encode(c.counterparty, l.uint32(34).fork()).ldelim(), c.delayPeriod !== BigInt(0) && l.uint32(40).uint64(c.delayPeriod);
      for (const y of c.counterpartyVersions)
        n.Version.encode(y, l.uint32(50).fork()).ldelim();
      return c.proofHeight !== void 0 && t.Height.encode(c.proofHeight, l.uint32(58).fork()).ldelim(), c.proofInit.length !== 0 && l.uint32(66).bytes(c.proofInit), c.proofClient.length !== 0 && l.uint32(74).bytes(c.proofClient), c.proofConsensus.length !== 0 && l.uint32(82).bytes(c.proofConsensus), c.consensusHeight !== void 0 && t.Height.encode(c.consensusHeight, l.uint32(90).fork()).ldelim(), c.signer !== "" && l.uint32(98).string(c.signer), c.hostConsensusStateProof.length !== 0 && l.uint32(106).bytes(c.hostConsensusStateProof), l;
    },
    decode(c, l) {
      const y = c instanceof i.BinaryReader ? c : new i.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = T();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.clientId = y.string();
            break;
          case 2:
            J.previousConnectionId = y.string();
            break;
          case 3:
            J.clientState = r.Any.decode(y, y.uint32());
            break;
          case 4:
            J.counterparty = n.Counterparty.decode(y, y.uint32());
            break;
          case 5:
            J.delayPeriod = y.uint64();
            break;
          case 6:
            J.counterpartyVersions.push(n.Version.decode(y, y.uint32()));
            break;
          case 7:
            J.proofHeight = t.Height.decode(y, y.uint32());
            break;
          case 8:
            J.proofInit = y.bytes();
            break;
          case 9:
            J.proofClient = y.bytes();
            break;
          case 10:
            J.proofConsensus = y.bytes();
            break;
          case 11:
            J.consensusHeight = t.Height.decode(y, y.uint32());
            break;
          case 12:
            J.signer = y.string();
            break;
          case 13:
            J.hostConsensusStateProof = y.bytes();
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = T();
      return (0, f.isSet)(c.clientId) && (l.clientId = String(c.clientId)), (0, f.isSet)(c.previousConnectionId) && (l.previousConnectionId = String(c.previousConnectionId)), (0, f.isSet)(c.clientState) && (l.clientState = r.Any.fromJSON(c.clientState)), (0, f.isSet)(c.counterparty) && (l.counterparty = n.Counterparty.fromJSON(c.counterparty)), (0, f.isSet)(c.delayPeriod) && (l.delayPeriod = BigInt(c.delayPeriod.toString())), Array.isArray(c == null ? void 0 : c.counterpartyVersions) && (l.counterpartyVersions = c.counterpartyVersions.map((y) => n.Version.fromJSON(y))), (0, f.isSet)(c.proofHeight) && (l.proofHeight = t.Height.fromJSON(c.proofHeight)), (0, f.isSet)(c.proofInit) && (l.proofInit = (0, f.bytesFromBase64)(c.proofInit)), (0, f.isSet)(c.proofClient) && (l.proofClient = (0, f.bytesFromBase64)(c.proofClient)), (0, f.isSet)(c.proofConsensus) && (l.proofConsensus = (0, f.bytesFromBase64)(c.proofConsensus)), (0, f.isSet)(c.consensusHeight) && (l.consensusHeight = t.Height.fromJSON(c.consensusHeight)), (0, f.isSet)(c.signer) && (l.signer = String(c.signer)), (0, f.isSet)(c.hostConsensusStateProof) && (l.hostConsensusStateProof = (0, f.bytesFromBase64)(c.hostConsensusStateProof)), l;
    },
    toJSON(c) {
      const l = {};
      return c.clientId !== void 0 && (l.clientId = c.clientId), c.previousConnectionId !== void 0 && (l.previousConnectionId = c.previousConnectionId), c.clientState !== void 0 && (l.clientState = c.clientState ? r.Any.toJSON(c.clientState) : void 0), c.counterparty !== void 0 && (l.counterparty = c.counterparty ? n.Counterparty.toJSON(c.counterparty) : void 0), c.delayPeriod !== void 0 && (l.delayPeriod = (c.delayPeriod || BigInt(0)).toString()), c.counterpartyVersions ? l.counterpartyVersions = c.counterpartyVersions.map((y) => y ? n.Version.toJSON(y) : void 0) : l.counterpartyVersions = [], c.proofHeight !== void 0 && (l.proofHeight = c.proofHeight ? t.Height.toJSON(c.proofHeight) : void 0), c.proofInit !== void 0 && (l.proofInit = (0, f.base64FromBytes)(c.proofInit !== void 0 ? c.proofInit : new Uint8Array())), c.proofClient !== void 0 && (l.proofClient = (0, f.base64FromBytes)(c.proofClient !== void 0 ? c.proofClient : new Uint8Array())), c.proofConsensus !== void 0 && (l.proofConsensus = (0, f.base64FromBytes)(c.proofConsensus !== void 0 ? c.proofConsensus : new Uint8Array())), c.consensusHeight !== void 0 && (l.consensusHeight = c.consensusHeight ? t.Height.toJSON(c.consensusHeight) : void 0), c.signer !== void 0 && (l.signer = c.signer), c.hostConsensusStateProof !== void 0 && (l.hostConsensusStateProof = (0, f.base64FromBytes)(c.hostConsensusStateProof !== void 0 ? c.hostConsensusStateProof : new Uint8Array())), l;
    },
    fromPartial(c) {
      var y;
      const l = T();
      return l.clientId = c.clientId ?? "", l.previousConnectionId = c.previousConnectionId ?? "", c.clientState !== void 0 && c.clientState !== null && (l.clientState = r.Any.fromPartial(c.clientState)), c.counterparty !== void 0 && c.counterparty !== null && (l.counterparty = n.Counterparty.fromPartial(c.counterparty)), c.delayPeriod !== void 0 && c.delayPeriod !== null && (l.delayPeriod = BigInt(c.delayPeriod.toString())), l.counterpartyVersions = ((y = c.counterpartyVersions) == null ? void 0 : y.map((E) => n.Version.fromPartial(E))) || [], c.proofHeight !== void 0 && c.proofHeight !== null && (l.proofHeight = t.Height.fromPartial(c.proofHeight)), l.proofInit = c.proofInit ?? new Uint8Array(), l.proofClient = c.proofClient ?? new Uint8Array(), l.proofConsensus = c.proofConsensus ?? new Uint8Array(), c.consensusHeight !== void 0 && c.consensusHeight !== null && (l.consensusHeight = t.Height.fromPartial(c.consensusHeight)), l.signer = c.signer ?? "", l.hostConsensusStateProof = c.hostConsensusStateProof ?? new Uint8Array(), l;
    }
  };
  function U() {
    return {};
  }
  e.MsgConnectionOpenTryResponse = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenTryResponse",
    encode(c, l = i.BinaryWriter.create()) {
      return l;
    },
    decode(c, l) {
      const y = c instanceof i.BinaryReader ? c : new i.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = U();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      return U();
    },
    toJSON(c) {
      return {};
    },
    fromPartial(c) {
      return U();
    }
  };
  function w() {
    return {
      connectionId: "",
      counterpartyConnectionId: "",
      version: void 0,
      clientState: void 0,
      proofHeight: t.Height.fromPartial({}),
      proofTry: new Uint8Array(),
      proofClient: new Uint8Array(),
      proofConsensus: new Uint8Array(),
      consensusHeight: t.Height.fromPartial({}),
      signer: "",
      hostConsensusStateProof: new Uint8Array()
    };
  }
  e.MsgConnectionOpenAck = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenAck",
    encode(c, l = i.BinaryWriter.create()) {
      return c.connectionId !== "" && l.uint32(10).string(c.connectionId), c.counterpartyConnectionId !== "" && l.uint32(18).string(c.counterpartyConnectionId), c.version !== void 0 && n.Version.encode(c.version, l.uint32(26).fork()).ldelim(), c.clientState !== void 0 && r.Any.encode(c.clientState, l.uint32(34).fork()).ldelim(), c.proofHeight !== void 0 && t.Height.encode(c.proofHeight, l.uint32(42).fork()).ldelim(), c.proofTry.length !== 0 && l.uint32(50).bytes(c.proofTry), c.proofClient.length !== 0 && l.uint32(58).bytes(c.proofClient), c.proofConsensus.length !== 0 && l.uint32(66).bytes(c.proofConsensus), c.consensusHeight !== void 0 && t.Height.encode(c.consensusHeight, l.uint32(74).fork()).ldelim(), c.signer !== "" && l.uint32(82).string(c.signer), c.hostConsensusStateProof.length !== 0 && l.uint32(90).bytes(c.hostConsensusStateProof), l;
    },
    decode(c, l) {
      const y = c instanceof i.BinaryReader ? c : new i.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = w();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.connectionId = y.string();
            break;
          case 2:
            J.counterpartyConnectionId = y.string();
            break;
          case 3:
            J.version = n.Version.decode(y, y.uint32());
            break;
          case 4:
            J.clientState = r.Any.decode(y, y.uint32());
            break;
          case 5:
            J.proofHeight = t.Height.decode(y, y.uint32());
            break;
          case 6:
            J.proofTry = y.bytes();
            break;
          case 7:
            J.proofClient = y.bytes();
            break;
          case 8:
            J.proofConsensus = y.bytes();
            break;
          case 9:
            J.consensusHeight = t.Height.decode(y, y.uint32());
            break;
          case 10:
            J.signer = y.string();
            break;
          case 11:
            J.hostConsensusStateProof = y.bytes();
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = w();
      return (0, f.isSet)(c.connectionId) && (l.connectionId = String(c.connectionId)), (0, f.isSet)(c.counterpartyConnectionId) && (l.counterpartyConnectionId = String(c.counterpartyConnectionId)), (0, f.isSet)(c.version) && (l.version = n.Version.fromJSON(c.version)), (0, f.isSet)(c.clientState) && (l.clientState = r.Any.fromJSON(c.clientState)), (0, f.isSet)(c.proofHeight) && (l.proofHeight = t.Height.fromJSON(c.proofHeight)), (0, f.isSet)(c.proofTry) && (l.proofTry = (0, f.bytesFromBase64)(c.proofTry)), (0, f.isSet)(c.proofClient) && (l.proofClient = (0, f.bytesFromBase64)(c.proofClient)), (0, f.isSet)(c.proofConsensus) && (l.proofConsensus = (0, f.bytesFromBase64)(c.proofConsensus)), (0, f.isSet)(c.consensusHeight) && (l.consensusHeight = t.Height.fromJSON(c.consensusHeight)), (0, f.isSet)(c.signer) && (l.signer = String(c.signer)), (0, f.isSet)(c.hostConsensusStateProof) && (l.hostConsensusStateProof = (0, f.bytesFromBase64)(c.hostConsensusStateProof)), l;
    },
    toJSON(c) {
      const l = {};
      return c.connectionId !== void 0 && (l.connectionId = c.connectionId), c.counterpartyConnectionId !== void 0 && (l.counterpartyConnectionId = c.counterpartyConnectionId), c.version !== void 0 && (l.version = c.version ? n.Version.toJSON(c.version) : void 0), c.clientState !== void 0 && (l.clientState = c.clientState ? r.Any.toJSON(c.clientState) : void 0), c.proofHeight !== void 0 && (l.proofHeight = c.proofHeight ? t.Height.toJSON(c.proofHeight) : void 0), c.proofTry !== void 0 && (l.proofTry = (0, f.base64FromBytes)(c.proofTry !== void 0 ? c.proofTry : new Uint8Array())), c.proofClient !== void 0 && (l.proofClient = (0, f.base64FromBytes)(c.proofClient !== void 0 ? c.proofClient : new Uint8Array())), c.proofConsensus !== void 0 && (l.proofConsensus = (0, f.base64FromBytes)(c.proofConsensus !== void 0 ? c.proofConsensus : new Uint8Array())), c.consensusHeight !== void 0 && (l.consensusHeight = c.consensusHeight ? t.Height.toJSON(c.consensusHeight) : void 0), c.signer !== void 0 && (l.signer = c.signer), c.hostConsensusStateProof !== void 0 && (l.hostConsensusStateProof = (0, f.base64FromBytes)(c.hostConsensusStateProof !== void 0 ? c.hostConsensusStateProof : new Uint8Array())), l;
    },
    fromPartial(c) {
      const l = w();
      return l.connectionId = c.connectionId ?? "", l.counterpartyConnectionId = c.counterpartyConnectionId ?? "", c.version !== void 0 && c.version !== null && (l.version = n.Version.fromPartial(c.version)), c.clientState !== void 0 && c.clientState !== null && (l.clientState = r.Any.fromPartial(c.clientState)), c.proofHeight !== void 0 && c.proofHeight !== null && (l.proofHeight = t.Height.fromPartial(c.proofHeight)), l.proofTry = c.proofTry ?? new Uint8Array(), l.proofClient = c.proofClient ?? new Uint8Array(), l.proofConsensus = c.proofConsensus ?? new Uint8Array(), c.consensusHeight !== void 0 && c.consensusHeight !== null && (l.consensusHeight = t.Height.fromPartial(c.consensusHeight)), l.signer = c.signer ?? "", l.hostConsensusStateProof = c.hostConsensusStateProof ?? new Uint8Array(), l;
    }
  };
  function N() {
    return {};
  }
  e.MsgConnectionOpenAckResponse = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenAckResponse",
    encode(c, l = i.BinaryWriter.create()) {
      return l;
    },
    decode(c, l) {
      const y = c instanceof i.BinaryReader ? c : new i.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = N();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      return N();
    },
    toJSON(c) {
      return {};
    },
    fromPartial(c) {
      return N();
    }
  };
  function h() {
    return {
      connectionId: "",
      proofAck: new Uint8Array(),
      proofHeight: t.Height.fromPartial({}),
      signer: ""
    };
  }
  e.MsgConnectionOpenConfirm = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenConfirm",
    encode(c, l = i.BinaryWriter.create()) {
      return c.connectionId !== "" && l.uint32(10).string(c.connectionId), c.proofAck.length !== 0 && l.uint32(18).bytes(c.proofAck), c.proofHeight !== void 0 && t.Height.encode(c.proofHeight, l.uint32(26).fork()).ldelim(), c.signer !== "" && l.uint32(34).string(c.signer), l;
    },
    decode(c, l) {
      const y = c instanceof i.BinaryReader ? c : new i.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = h();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.connectionId = y.string();
            break;
          case 2:
            J.proofAck = y.bytes();
            break;
          case 3:
            J.proofHeight = t.Height.decode(y, y.uint32());
            break;
          case 4:
            J.signer = y.string();
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = h();
      return (0, f.isSet)(c.connectionId) && (l.connectionId = String(c.connectionId)), (0, f.isSet)(c.proofAck) && (l.proofAck = (0, f.bytesFromBase64)(c.proofAck)), (0, f.isSet)(c.proofHeight) && (l.proofHeight = t.Height.fromJSON(c.proofHeight)), (0, f.isSet)(c.signer) && (l.signer = String(c.signer)), l;
    },
    toJSON(c) {
      const l = {};
      return c.connectionId !== void 0 && (l.connectionId = c.connectionId), c.proofAck !== void 0 && (l.proofAck = (0, f.base64FromBytes)(c.proofAck !== void 0 ? c.proofAck : new Uint8Array())), c.proofHeight !== void 0 && (l.proofHeight = c.proofHeight ? t.Height.toJSON(c.proofHeight) : void 0), c.signer !== void 0 && (l.signer = c.signer), l;
    },
    fromPartial(c) {
      const l = h();
      return l.connectionId = c.connectionId ?? "", l.proofAck = c.proofAck ?? new Uint8Array(), c.proofHeight !== void 0 && c.proofHeight !== null && (l.proofHeight = t.Height.fromPartial(c.proofHeight)), l.signer = c.signer ?? "", l;
    }
  };
  function P() {
    return {};
  }
  e.MsgConnectionOpenConfirmResponse = {
    typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenConfirmResponse",
    encode(c, l = i.BinaryWriter.create()) {
      return l;
    },
    decode(c, l) {
      const y = c instanceof i.BinaryReader ? c : new i.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = P();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      return P();
    },
    toJSON(c) {
      return {};
    },
    fromPartial(c) {
      return P();
    }
  };
  class b {
    constructor(l) {
      this.rpc = l, this.ConnectionOpenInit = this.ConnectionOpenInit.bind(this), this.ConnectionOpenTry = this.ConnectionOpenTry.bind(this), this.ConnectionOpenAck = this.ConnectionOpenAck.bind(this), this.ConnectionOpenConfirm = this.ConnectionOpenConfirm.bind(this);
    }
    ConnectionOpenInit(l) {
      const y = e.MsgConnectionOpenInit.encode(l).finish();
      return this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenInit", y).then((J) => e.MsgConnectionOpenInitResponse.decode(new i.BinaryReader(J)));
    }
    ConnectionOpenTry(l) {
      const y = e.MsgConnectionOpenTry.encode(l).finish();
      return this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenTry", y).then((J) => e.MsgConnectionOpenTryResponse.decode(new i.BinaryReader(J)));
    }
    ConnectionOpenAck(l) {
      const y = e.MsgConnectionOpenAck.encode(l).finish();
      return this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenAck", y).then((J) => e.MsgConnectionOpenAckResponse.decode(new i.BinaryReader(J)));
    }
    ConnectionOpenConfirm(l) {
      const y = e.MsgConnectionOpenConfirm.encode(l).finish();
      return this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenConfirm", y).then((J) => e.MsgConnectionOpenConfirmResponse.decode(new i.BinaryReader(J)));
    }
  }
  e.MsgClientImpl = b;
})(cl);
Object.defineProperty(or, "__esModule", { value: !0 });
or.isMsgTransferEncodeObject = or.ibcTypes = void 0;
const Um = bo, Un = dl, Si = ul, ki = cl;
or.ibcTypes = [
  ["/ibc.applications.transfer.v1.MsgTransfer", Um.MsgTransfer],
  ["/ibc.core.channel.v1.MsgAcknowledgement", Un.MsgAcknowledgement],
  ["/ibc.core.channel.v1.MsgChannelCloseConfirm", Un.MsgChannelCloseConfirm],
  ["/ibc.core.channel.v1.MsgChannelCloseInit", Un.MsgChannelCloseInit],
  ["/ibc.core.channel.v1.MsgChannelOpenAck", Un.MsgChannelOpenAck],
  ["/ibc.core.channel.v1.MsgChannelOpenConfirm", Un.MsgChannelOpenConfirm],
  ["/ibc.core.channel.v1.MsgChannelOpenInit", Un.MsgChannelOpenInit],
  ["/ibc.core.channel.v1.MsgChannelOpenTry", Un.MsgChannelOpenTry],
  ["/ibc.core.channel.v1.MsgRecvPacket", Un.MsgRecvPacket],
  ["/ibc.core.channel.v1.MsgTimeout", Un.MsgTimeout],
  ["/ibc.core.channel.v1.MsgTimeoutOnClose", Un.MsgTimeoutOnClose],
  ["/ibc.core.client.v1.MsgCreateClient", Si.MsgCreateClient],
  ["/ibc.core.client.v1.MsgSubmitMisbehaviour", Si.MsgSubmitMisbehaviour],
  ["/ibc.core.client.v1.MsgUpdateClient", Si.MsgUpdateClient],
  ["/ibc.core.client.v1.MsgUpgradeClient", Si.MsgUpgradeClient],
  ["/ibc.core.connection.v1.MsgConnectionOpenAck", ki.MsgConnectionOpenAck],
  ["/ibc.core.connection.v1.MsgConnectionOpenConfirm", ki.MsgConnectionOpenConfirm],
  ["/ibc.core.connection.v1.MsgConnectionOpenInit", ki.MsgConnectionOpenInit],
  ["/ibc.core.connection.v1.MsgConnectionOpenTry", ki.MsgConnectionOpenTry]
];
function Dm(e) {
  return e.typeUrl === "/ibc.applications.transfer.v1.MsgTransfer";
}
or.isMsgTransferEncodeObject = Dm;
var Io = {}, ll = {}, dt = {};
Object.defineProperty(dt, "__esModule", { value: !0 });
dt.Params = dt.DenomTrace = dt.protobufPackage = void 0;
const xt = re, Vi = ie;
dt.protobufPackage = "ibc.applications.transfer.v1";
function ds() {
  return {
    path: "",
    baseDenom: ""
  };
}
dt.DenomTrace = {
  typeUrl: "/ibc.applications.transfer.v1.DenomTrace",
  encode(e, n = xt.BinaryWriter.create()) {
    return e.path !== "" && n.uint32(10).string(e.path), e.baseDenom !== "" && n.uint32(18).string(e.baseDenom), n;
  },
  decode(e, n) {
    const r = e instanceof xt.BinaryReader ? e : new xt.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = ds();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.path = r.string();
          break;
        case 2:
          i.baseDenom = r.string();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = ds();
    return (0, Vi.isSet)(e.path) && (n.path = String(e.path)), (0, Vi.isSet)(e.baseDenom) && (n.baseDenom = String(e.baseDenom)), n;
  },
  toJSON(e) {
    const n = {};
    return e.path !== void 0 && (n.path = e.path), e.baseDenom !== void 0 && (n.baseDenom = e.baseDenom), n;
  },
  fromPartial(e) {
    const n = ds();
    return n.path = e.path ?? "", n.baseDenom = e.baseDenom ?? "", n;
  }
};
function us() {
  return {
    sendEnabled: !1,
    receiveEnabled: !1
  };
}
dt.Params = {
  typeUrl: "/ibc.applications.transfer.v1.Params",
  encode(e, n = xt.BinaryWriter.create()) {
    return e.sendEnabled === !0 && n.uint32(8).bool(e.sendEnabled), e.receiveEnabled === !0 && n.uint32(16).bool(e.receiveEnabled), n;
  },
  decode(e, n) {
    const r = e instanceof xt.BinaryReader ? e : new xt.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = us();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.sendEnabled = r.bool();
          break;
        case 2:
          i.receiveEnabled = r.bool();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = us();
    return (0, Vi.isSet)(e.sendEnabled) && (n.sendEnabled = !!e.sendEnabled), (0, Vi.isSet)(e.receiveEnabled) && (n.receiveEnabled = !!e.receiveEnabled), n;
  },
  toJSON(e) {
    const n = {};
    return e.sendEnabled !== void 0 && (n.sendEnabled = e.sendEnabled), e.receiveEnabled !== void 0 && (n.receiveEnabled = e.receiveEnabled), n;
  },
  fromPartial(e) {
    const n = us();
    return n.sendEnabled = e.sendEnabled ?? !1, n.receiveEnabled = e.receiveEnabled ?? !1, n;
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryEscrowAddressResponse = e.QueryEscrowAddressRequest = e.QueryDenomHashResponse = e.QueryDenomHashRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.QueryDenomTracesResponse = e.QueryDenomTracesRequest = e.QueryDenomTraceResponse = e.QueryDenomTraceRequest = e.protobufPackage = void 0;
  const n = Ae, r = dt, t = re, i = ie;
  e.protobufPackage = "ibc.applications.transfer.v1";
  function f() {
    return {
      hash: ""
    };
  }
  e.QueryDenomTraceRequest = {
    typeUrl: "/ibc.applications.transfer.v1.QueryDenomTraceRequest",
    encode(l, y = t.BinaryWriter.create()) {
      return l.hash !== "" && y.uint32(10).string(l.hash), y;
    },
    decode(l, y) {
      const E = l instanceof t.BinaryReader ? l : new t.BinaryReader(l);
      let J = y === void 0 ? E.len : E.pos + y;
      const _ = f();
      for (; E.pos < J; ) {
        const V = E.uint32();
        switch (V >>> 3) {
          case 1:
            _.hash = E.string();
            break;
          default:
            E.skipType(V & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(l) {
      const y = f();
      return (0, i.isSet)(l.hash) && (y.hash = String(l.hash)), y;
    },
    toJSON(l) {
      const y = {};
      return l.hash !== void 0 && (y.hash = l.hash), y;
    },
    fromPartial(l) {
      const y = f();
      return y.hash = l.hash ?? "", y;
    }
  };
  function k() {
    return {
      denomTrace: void 0
    };
  }
  e.QueryDenomTraceResponse = {
    typeUrl: "/ibc.applications.transfer.v1.QueryDenomTraceResponse",
    encode(l, y = t.BinaryWriter.create()) {
      return l.denomTrace !== void 0 && r.DenomTrace.encode(l.denomTrace, y.uint32(10).fork()).ldelim(), y;
    },
    decode(l, y) {
      const E = l instanceof t.BinaryReader ? l : new t.BinaryReader(l);
      let J = y === void 0 ? E.len : E.pos + y;
      const _ = k();
      for (; E.pos < J; ) {
        const V = E.uint32();
        switch (V >>> 3) {
          case 1:
            _.denomTrace = r.DenomTrace.decode(E, E.uint32());
            break;
          default:
            E.skipType(V & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(l) {
      const y = k();
      return (0, i.isSet)(l.denomTrace) && (y.denomTrace = r.DenomTrace.fromJSON(l.denomTrace)), y;
    },
    toJSON(l) {
      const y = {};
      return l.denomTrace !== void 0 && (y.denomTrace = l.denomTrace ? r.DenomTrace.toJSON(l.denomTrace) : void 0), y;
    },
    fromPartial(l) {
      const y = k();
      return l.denomTrace !== void 0 && l.denomTrace !== null && (y.denomTrace = r.DenomTrace.fromPartial(l.denomTrace)), y;
    }
  };
  function C() {
    return {
      pagination: void 0
    };
  }
  e.QueryDenomTracesRequest = {
    typeUrl: "/ibc.applications.transfer.v1.QueryDenomTracesRequest",
    encode(l, y = t.BinaryWriter.create()) {
      return l.pagination !== void 0 && n.PageRequest.encode(l.pagination, y.uint32(10).fork()).ldelim(), y;
    },
    decode(l, y) {
      const E = l instanceof t.BinaryReader ? l : new t.BinaryReader(l);
      let J = y === void 0 ? E.len : E.pos + y;
      const _ = C();
      for (; E.pos < J; ) {
        const V = E.uint32();
        switch (V >>> 3) {
          case 1:
            _.pagination = n.PageRequest.decode(E, E.uint32());
            break;
          default:
            E.skipType(V & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(l) {
      const y = C();
      return (0, i.isSet)(l.pagination) && (y.pagination = n.PageRequest.fromJSON(l.pagination)), y;
    },
    toJSON(l) {
      const y = {};
      return l.pagination !== void 0 && (y.pagination = l.pagination ? n.PageRequest.toJSON(l.pagination) : void 0), y;
    },
    fromPartial(l) {
      const y = C();
      return l.pagination !== void 0 && l.pagination !== null && (y.pagination = n.PageRequest.fromPartial(l.pagination)), y;
    }
  };
  function T() {
    return {
      denomTraces: [],
      pagination: void 0
    };
  }
  e.QueryDenomTracesResponse = {
    typeUrl: "/ibc.applications.transfer.v1.QueryDenomTracesResponse",
    encode(l, y = t.BinaryWriter.create()) {
      for (const E of l.denomTraces)
        r.DenomTrace.encode(E, y.uint32(10).fork()).ldelim();
      return l.pagination !== void 0 && n.PageResponse.encode(l.pagination, y.uint32(18).fork()).ldelim(), y;
    },
    decode(l, y) {
      const E = l instanceof t.BinaryReader ? l : new t.BinaryReader(l);
      let J = y === void 0 ? E.len : E.pos + y;
      const _ = T();
      for (; E.pos < J; ) {
        const V = E.uint32();
        switch (V >>> 3) {
          case 1:
            _.denomTraces.push(r.DenomTrace.decode(E, E.uint32()));
            break;
          case 2:
            _.pagination = n.PageResponse.decode(E, E.uint32());
            break;
          default:
            E.skipType(V & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(l) {
      const y = T();
      return Array.isArray(l == null ? void 0 : l.denomTraces) && (y.denomTraces = l.denomTraces.map((E) => r.DenomTrace.fromJSON(E))), (0, i.isSet)(l.pagination) && (y.pagination = n.PageResponse.fromJSON(l.pagination)), y;
    },
    toJSON(l) {
      const y = {};
      return l.denomTraces ? y.denomTraces = l.denomTraces.map((E) => E ? r.DenomTrace.toJSON(E) : void 0) : y.denomTraces = [], l.pagination !== void 0 && (y.pagination = l.pagination ? n.PageResponse.toJSON(l.pagination) : void 0), y;
    },
    fromPartial(l) {
      var E;
      const y = T();
      return y.denomTraces = ((E = l.denomTraces) == null ? void 0 : E.map((J) => r.DenomTrace.fromPartial(J))) || [], l.pagination !== void 0 && l.pagination !== null && (y.pagination = n.PageResponse.fromPartial(l.pagination)), y;
    }
  };
  function U() {
    return {};
  }
  e.QueryParamsRequest = {
    typeUrl: "/ibc.applications.transfer.v1.QueryParamsRequest",
    encode(l, y = t.BinaryWriter.create()) {
      return y;
    },
    decode(l, y) {
      const E = l instanceof t.BinaryReader ? l : new t.BinaryReader(l);
      let J = y === void 0 ? E.len : E.pos + y;
      const _ = U();
      for (; E.pos < J; ) {
        const V = E.uint32();
        switch (V >>> 3) {
          default:
            E.skipType(V & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(l) {
      return U();
    },
    toJSON(l) {
      return {};
    },
    fromPartial(l) {
      return U();
    }
  };
  function w() {
    return {
      params: void 0
    };
  }
  e.QueryParamsResponse = {
    typeUrl: "/ibc.applications.transfer.v1.QueryParamsResponse",
    encode(l, y = t.BinaryWriter.create()) {
      return l.params !== void 0 && r.Params.encode(l.params, y.uint32(10).fork()).ldelim(), y;
    },
    decode(l, y) {
      const E = l instanceof t.BinaryReader ? l : new t.BinaryReader(l);
      let J = y === void 0 ? E.len : E.pos + y;
      const _ = w();
      for (; E.pos < J; ) {
        const V = E.uint32();
        switch (V >>> 3) {
          case 1:
            _.params = r.Params.decode(E, E.uint32());
            break;
          default:
            E.skipType(V & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(l) {
      const y = w();
      return (0, i.isSet)(l.params) && (y.params = r.Params.fromJSON(l.params)), y;
    },
    toJSON(l) {
      const y = {};
      return l.params !== void 0 && (y.params = l.params ? r.Params.toJSON(l.params) : void 0), y;
    },
    fromPartial(l) {
      const y = w();
      return l.params !== void 0 && l.params !== null && (y.params = r.Params.fromPartial(l.params)), y;
    }
  };
  function N() {
    return {
      trace: ""
    };
  }
  e.QueryDenomHashRequest = {
    typeUrl: "/ibc.applications.transfer.v1.QueryDenomHashRequest",
    encode(l, y = t.BinaryWriter.create()) {
      return l.trace !== "" && y.uint32(10).string(l.trace), y;
    },
    decode(l, y) {
      const E = l instanceof t.BinaryReader ? l : new t.BinaryReader(l);
      let J = y === void 0 ? E.len : E.pos + y;
      const _ = N();
      for (; E.pos < J; ) {
        const V = E.uint32();
        switch (V >>> 3) {
          case 1:
            _.trace = E.string();
            break;
          default:
            E.skipType(V & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(l) {
      const y = N();
      return (0, i.isSet)(l.trace) && (y.trace = String(l.trace)), y;
    },
    toJSON(l) {
      const y = {};
      return l.trace !== void 0 && (y.trace = l.trace), y;
    },
    fromPartial(l) {
      const y = N();
      return y.trace = l.trace ?? "", y;
    }
  };
  function h() {
    return {
      hash: ""
    };
  }
  e.QueryDenomHashResponse = {
    typeUrl: "/ibc.applications.transfer.v1.QueryDenomHashResponse",
    encode(l, y = t.BinaryWriter.create()) {
      return l.hash !== "" && y.uint32(10).string(l.hash), y;
    },
    decode(l, y) {
      const E = l instanceof t.BinaryReader ? l : new t.BinaryReader(l);
      let J = y === void 0 ? E.len : E.pos + y;
      const _ = h();
      for (; E.pos < J; ) {
        const V = E.uint32();
        switch (V >>> 3) {
          case 1:
            _.hash = E.string();
            break;
          default:
            E.skipType(V & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(l) {
      const y = h();
      return (0, i.isSet)(l.hash) && (y.hash = String(l.hash)), y;
    },
    toJSON(l) {
      const y = {};
      return l.hash !== void 0 && (y.hash = l.hash), y;
    },
    fromPartial(l) {
      const y = h();
      return y.hash = l.hash ?? "", y;
    }
  };
  function P() {
    return {
      portId: "",
      channelId: ""
    };
  }
  e.QueryEscrowAddressRequest = {
    typeUrl: "/ibc.applications.transfer.v1.QueryEscrowAddressRequest",
    encode(l, y = t.BinaryWriter.create()) {
      return l.portId !== "" && y.uint32(10).string(l.portId), l.channelId !== "" && y.uint32(18).string(l.channelId), y;
    },
    decode(l, y) {
      const E = l instanceof t.BinaryReader ? l : new t.BinaryReader(l);
      let J = y === void 0 ? E.len : E.pos + y;
      const _ = P();
      for (; E.pos < J; ) {
        const V = E.uint32();
        switch (V >>> 3) {
          case 1:
            _.portId = E.string();
            break;
          case 2:
            _.channelId = E.string();
            break;
          default:
            E.skipType(V & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(l) {
      const y = P();
      return (0, i.isSet)(l.portId) && (y.portId = String(l.portId)), (0, i.isSet)(l.channelId) && (y.channelId = String(l.channelId)), y;
    },
    toJSON(l) {
      const y = {};
      return l.portId !== void 0 && (y.portId = l.portId), l.channelId !== void 0 && (y.channelId = l.channelId), y;
    },
    fromPartial(l) {
      const y = P();
      return y.portId = l.portId ?? "", y.channelId = l.channelId ?? "", y;
    }
  };
  function b() {
    return {
      escrowAddress: ""
    };
  }
  e.QueryEscrowAddressResponse = {
    typeUrl: "/ibc.applications.transfer.v1.QueryEscrowAddressResponse",
    encode(l, y = t.BinaryWriter.create()) {
      return l.escrowAddress !== "" && y.uint32(10).string(l.escrowAddress), y;
    },
    decode(l, y) {
      const E = l instanceof t.BinaryReader ? l : new t.BinaryReader(l);
      let J = y === void 0 ? E.len : E.pos + y;
      const _ = b();
      for (; E.pos < J; ) {
        const V = E.uint32();
        switch (V >>> 3) {
          case 1:
            _.escrowAddress = E.string();
            break;
          default:
            E.skipType(V & 7);
            break;
        }
      }
      return _;
    },
    fromJSON(l) {
      const y = b();
      return (0, i.isSet)(l.escrowAddress) && (y.escrowAddress = String(l.escrowAddress)), y;
    },
    toJSON(l) {
      const y = {};
      return l.escrowAddress !== void 0 && (y.escrowAddress = l.escrowAddress), y;
    },
    fromPartial(l) {
      const y = b();
      return y.escrowAddress = l.escrowAddress ?? "", y;
    }
  };
  class c {
    constructor(y) {
      this.rpc = y, this.DenomTrace = this.DenomTrace.bind(this), this.DenomTraces = this.DenomTraces.bind(this), this.Params = this.Params.bind(this), this.DenomHash = this.DenomHash.bind(this), this.EscrowAddress = this.EscrowAddress.bind(this);
    }
    DenomTrace(y) {
      const E = e.QueryDenomTraceRequest.encode(y).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTrace", E).then((_) => e.QueryDenomTraceResponse.decode(new t.BinaryReader(_)));
    }
    DenomTraces(y = {
      pagination: n.PageRequest.fromPartial({})
    }) {
      const E = e.QueryDenomTracesRequest.encode(y).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTraces", E).then((_) => e.QueryDenomTracesResponse.decode(new t.BinaryReader(_)));
    }
    Params(y = {}) {
      const E = e.QueryParamsRequest.encode(y).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Query", "Params", E).then((_) => e.QueryParamsResponse.decode(new t.BinaryReader(_)));
    }
    DenomHash(y) {
      const E = e.QueryDenomHashRequest.encode(y).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Query", "DenomHash", E).then((_) => e.QueryDenomHashResponse.decode(new t.BinaryReader(_)));
    }
    EscrowAddress(y) {
      const E = e.QueryEscrowAddressRequest.encode(y).finish();
      return this.rpc.request("ibc.applications.transfer.v1.Query", "EscrowAddress", E).then((_) => e.QueryEscrowAddressResponse.decode(new t.BinaryReader(_)));
    }
  }
  e.QueryClientImpl = c;
})(ll);
var fl = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryNextSequenceReceiveResponse = e.QueryNextSequenceReceiveRequest = e.QueryUnreceivedAcksResponse = e.QueryUnreceivedAcksRequest = e.QueryUnreceivedPacketsResponse = e.QueryUnreceivedPacketsRequest = e.QueryPacketAcknowledgementsResponse = e.QueryPacketAcknowledgementsRequest = e.QueryPacketAcknowledgementResponse = e.QueryPacketAcknowledgementRequest = e.QueryPacketReceiptResponse = e.QueryPacketReceiptRequest = e.QueryPacketCommitmentsResponse = e.QueryPacketCommitmentsRequest = e.QueryPacketCommitmentResponse = e.QueryPacketCommitmentRequest = e.QueryChannelConsensusStateResponse = e.QueryChannelConsensusStateRequest = e.QueryChannelClientStateResponse = e.QueryChannelClientStateRequest = e.QueryConnectionChannelsResponse = e.QueryConnectionChannelsRequest = e.QueryChannelsResponse = e.QueryChannelsRequest = e.QueryChannelResponse = e.QueryChannelRequest = e.protobufPackage = void 0;
  const n = Ae, r = Ao, t = Yn, i = Be, f = re, k = ie;
  e.protobufPackage = "ibc.core.channel.v1";
  function C() {
    return {
      portId: "",
      channelId: ""
    };
  }
  e.QueryChannelRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelRequest",
    encode(a, g = f.BinaryWriter.create()) {
      return a.portId !== "" && g.uint32(10).string(a.portId), a.channelId !== "" && g.uint32(18).string(a.channelId), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = C();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.portId = m.string();
            break;
          case 2:
            O.channelId = m.string();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = C();
      return (0, k.isSet)(a.portId) && (g.portId = String(a.portId)), (0, k.isSet)(a.channelId) && (g.channelId = String(a.channelId)), g;
    },
    toJSON(a) {
      const g = {};
      return a.portId !== void 0 && (g.portId = a.portId), a.channelId !== void 0 && (g.channelId = a.channelId), g;
    },
    fromPartial(a) {
      const g = C();
      return g.portId = a.portId ?? "", g.channelId = a.channelId ?? "", g;
    }
  };
  function T() {
    return {
      channel: void 0,
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryChannelResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelResponse",
    encode(a, g = f.BinaryWriter.create()) {
      return a.channel !== void 0 && r.Channel.encode(a.channel, g.uint32(10).fork()).ldelim(), a.proof.length !== 0 && g.uint32(18).bytes(a.proof), a.proofHeight !== void 0 && t.Height.encode(a.proofHeight, g.uint32(26).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = T();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.channel = r.Channel.decode(m, m.uint32());
            break;
          case 2:
            O.proof = m.bytes();
            break;
          case 3:
            O.proofHeight = t.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = T();
      return (0, k.isSet)(a.channel) && (g.channel = r.Channel.fromJSON(a.channel)), (0, k.isSet)(a.proof) && (g.proof = (0, k.bytesFromBase64)(a.proof)), (0, k.isSet)(a.proofHeight) && (g.proofHeight = t.Height.fromJSON(a.proofHeight)), g;
    },
    toJSON(a) {
      const g = {};
      return a.channel !== void 0 && (g.channel = a.channel ? r.Channel.toJSON(a.channel) : void 0), a.proof !== void 0 && (g.proof = (0, k.base64FromBytes)(a.proof !== void 0 ? a.proof : new Uint8Array())), a.proofHeight !== void 0 && (g.proofHeight = a.proofHeight ? t.Height.toJSON(a.proofHeight) : void 0), g;
    },
    fromPartial(a) {
      const g = T();
      return a.channel !== void 0 && a.channel !== null && (g.channel = r.Channel.fromPartial(a.channel)), g.proof = a.proof ?? new Uint8Array(), a.proofHeight !== void 0 && a.proofHeight !== null && (g.proofHeight = t.Height.fromPartial(a.proofHeight)), g;
    }
  };
  function U() {
    return {
      pagination: void 0
    };
  }
  e.QueryChannelsRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelsRequest",
    encode(a, g = f.BinaryWriter.create()) {
      return a.pagination !== void 0 && n.PageRequest.encode(a.pagination, g.uint32(10).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = U();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.pagination = n.PageRequest.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = U();
      return (0, k.isSet)(a.pagination) && (g.pagination = n.PageRequest.fromJSON(a.pagination)), g;
    },
    toJSON(a) {
      const g = {};
      return a.pagination !== void 0 && (g.pagination = a.pagination ? n.PageRequest.toJSON(a.pagination) : void 0), g;
    },
    fromPartial(a) {
      const g = U();
      return a.pagination !== void 0 && a.pagination !== null && (g.pagination = n.PageRequest.fromPartial(a.pagination)), g;
    }
  };
  function w() {
    return {
      channels: [],
      pagination: void 0,
      height: t.Height.fromPartial({})
    };
  }
  e.QueryChannelsResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelsResponse",
    encode(a, g = f.BinaryWriter.create()) {
      for (const m of a.channels)
        r.IdentifiedChannel.encode(m, g.uint32(10).fork()).ldelim();
      return a.pagination !== void 0 && n.PageResponse.encode(a.pagination, g.uint32(18).fork()).ldelim(), a.height !== void 0 && t.Height.encode(a.height, g.uint32(26).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = w();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.channels.push(r.IdentifiedChannel.decode(m, m.uint32()));
            break;
          case 2:
            O.pagination = n.PageResponse.decode(m, m.uint32());
            break;
          case 3:
            O.height = t.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = w();
      return Array.isArray(a == null ? void 0 : a.channels) && (g.channels = a.channels.map((m) => r.IdentifiedChannel.fromJSON(m))), (0, k.isSet)(a.pagination) && (g.pagination = n.PageResponse.fromJSON(a.pagination)), (0, k.isSet)(a.height) && (g.height = t.Height.fromJSON(a.height)), g;
    },
    toJSON(a) {
      const g = {};
      return a.channels ? g.channels = a.channels.map((m) => m ? r.IdentifiedChannel.toJSON(m) : void 0) : g.channels = [], a.pagination !== void 0 && (g.pagination = a.pagination ? n.PageResponse.toJSON(a.pagination) : void 0), a.height !== void 0 && (g.height = a.height ? t.Height.toJSON(a.height) : void 0), g;
    },
    fromPartial(a) {
      var m;
      const g = w();
      return g.channels = ((m = a.channels) == null ? void 0 : m.map((S) => r.IdentifiedChannel.fromPartial(S))) || [], a.pagination !== void 0 && a.pagination !== null && (g.pagination = n.PageResponse.fromPartial(a.pagination)), a.height !== void 0 && a.height !== null && (g.height = t.Height.fromPartial(a.height)), g;
    }
  };
  function N() {
    return {
      connection: "",
      pagination: void 0
    };
  }
  e.QueryConnectionChannelsRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryConnectionChannelsRequest",
    encode(a, g = f.BinaryWriter.create()) {
      return a.connection !== "" && g.uint32(10).string(a.connection), a.pagination !== void 0 && n.PageRequest.encode(a.pagination, g.uint32(18).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = N();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.connection = m.string();
            break;
          case 2:
            O.pagination = n.PageRequest.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = N();
      return (0, k.isSet)(a.connection) && (g.connection = String(a.connection)), (0, k.isSet)(a.pagination) && (g.pagination = n.PageRequest.fromJSON(a.pagination)), g;
    },
    toJSON(a) {
      const g = {};
      return a.connection !== void 0 && (g.connection = a.connection), a.pagination !== void 0 && (g.pagination = a.pagination ? n.PageRequest.toJSON(a.pagination) : void 0), g;
    },
    fromPartial(a) {
      const g = N();
      return g.connection = a.connection ?? "", a.pagination !== void 0 && a.pagination !== null && (g.pagination = n.PageRequest.fromPartial(a.pagination)), g;
    }
  };
  function h() {
    return {
      channels: [],
      pagination: void 0,
      height: t.Height.fromPartial({})
    };
  }
  e.QueryConnectionChannelsResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryConnectionChannelsResponse",
    encode(a, g = f.BinaryWriter.create()) {
      for (const m of a.channels)
        r.IdentifiedChannel.encode(m, g.uint32(10).fork()).ldelim();
      return a.pagination !== void 0 && n.PageResponse.encode(a.pagination, g.uint32(18).fork()).ldelim(), a.height !== void 0 && t.Height.encode(a.height, g.uint32(26).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = h();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.channels.push(r.IdentifiedChannel.decode(m, m.uint32()));
            break;
          case 2:
            O.pagination = n.PageResponse.decode(m, m.uint32());
            break;
          case 3:
            O.height = t.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = h();
      return Array.isArray(a == null ? void 0 : a.channels) && (g.channels = a.channels.map((m) => r.IdentifiedChannel.fromJSON(m))), (0, k.isSet)(a.pagination) && (g.pagination = n.PageResponse.fromJSON(a.pagination)), (0, k.isSet)(a.height) && (g.height = t.Height.fromJSON(a.height)), g;
    },
    toJSON(a) {
      const g = {};
      return a.channels ? g.channels = a.channels.map((m) => m ? r.IdentifiedChannel.toJSON(m) : void 0) : g.channels = [], a.pagination !== void 0 && (g.pagination = a.pagination ? n.PageResponse.toJSON(a.pagination) : void 0), a.height !== void 0 && (g.height = a.height ? t.Height.toJSON(a.height) : void 0), g;
    },
    fromPartial(a) {
      var m;
      const g = h();
      return g.channels = ((m = a.channels) == null ? void 0 : m.map((S) => r.IdentifiedChannel.fromPartial(S))) || [], a.pagination !== void 0 && a.pagination !== null && (g.pagination = n.PageResponse.fromPartial(a.pagination)), a.height !== void 0 && a.height !== null && (g.height = t.Height.fromPartial(a.height)), g;
    }
  };
  function P() {
    return {
      portId: "",
      channelId: ""
    };
  }
  e.QueryChannelClientStateRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelClientStateRequest",
    encode(a, g = f.BinaryWriter.create()) {
      return a.portId !== "" && g.uint32(10).string(a.portId), a.channelId !== "" && g.uint32(18).string(a.channelId), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = P();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.portId = m.string();
            break;
          case 2:
            O.channelId = m.string();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = P();
      return (0, k.isSet)(a.portId) && (g.portId = String(a.portId)), (0, k.isSet)(a.channelId) && (g.channelId = String(a.channelId)), g;
    },
    toJSON(a) {
      const g = {};
      return a.portId !== void 0 && (g.portId = a.portId), a.channelId !== void 0 && (g.channelId = a.channelId), g;
    },
    fromPartial(a) {
      const g = P();
      return g.portId = a.portId ?? "", g.channelId = a.channelId ?? "", g;
    }
  };
  function b() {
    return {
      identifiedClientState: void 0,
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryChannelClientStateResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelClientStateResponse",
    encode(a, g = f.BinaryWriter.create()) {
      return a.identifiedClientState !== void 0 && t.IdentifiedClientState.encode(a.identifiedClientState, g.uint32(10).fork()).ldelim(), a.proof.length !== 0 && g.uint32(18).bytes(a.proof), a.proofHeight !== void 0 && t.Height.encode(a.proofHeight, g.uint32(26).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = b();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.identifiedClientState = t.IdentifiedClientState.decode(m, m.uint32());
            break;
          case 2:
            O.proof = m.bytes();
            break;
          case 3:
            O.proofHeight = t.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = b();
      return (0, k.isSet)(a.identifiedClientState) && (g.identifiedClientState = t.IdentifiedClientState.fromJSON(a.identifiedClientState)), (0, k.isSet)(a.proof) && (g.proof = (0, k.bytesFromBase64)(a.proof)), (0, k.isSet)(a.proofHeight) && (g.proofHeight = t.Height.fromJSON(a.proofHeight)), g;
    },
    toJSON(a) {
      const g = {};
      return a.identifiedClientState !== void 0 && (g.identifiedClientState = a.identifiedClientState ? t.IdentifiedClientState.toJSON(a.identifiedClientState) : void 0), a.proof !== void 0 && (g.proof = (0, k.base64FromBytes)(a.proof !== void 0 ? a.proof : new Uint8Array())), a.proofHeight !== void 0 && (g.proofHeight = a.proofHeight ? t.Height.toJSON(a.proofHeight) : void 0), g;
    },
    fromPartial(a) {
      const g = b();
      return a.identifiedClientState !== void 0 && a.identifiedClientState !== null && (g.identifiedClientState = t.IdentifiedClientState.fromPartial(a.identifiedClientState)), g.proof = a.proof ?? new Uint8Array(), a.proofHeight !== void 0 && a.proofHeight !== null && (g.proofHeight = t.Height.fromPartial(a.proofHeight)), g;
    }
  };
  function c() {
    return {
      portId: "",
      channelId: "",
      revisionNumber: BigInt(0),
      revisionHeight: BigInt(0)
    };
  }
  e.QueryChannelConsensusStateRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelConsensusStateRequest",
    encode(a, g = f.BinaryWriter.create()) {
      return a.portId !== "" && g.uint32(10).string(a.portId), a.channelId !== "" && g.uint32(18).string(a.channelId), a.revisionNumber !== BigInt(0) && g.uint32(24).uint64(a.revisionNumber), a.revisionHeight !== BigInt(0) && g.uint32(32).uint64(a.revisionHeight), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = c();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.portId = m.string();
            break;
          case 2:
            O.channelId = m.string();
            break;
          case 3:
            O.revisionNumber = m.uint64();
            break;
          case 4:
            O.revisionHeight = m.uint64();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = c();
      return (0, k.isSet)(a.portId) && (g.portId = String(a.portId)), (0, k.isSet)(a.channelId) && (g.channelId = String(a.channelId)), (0, k.isSet)(a.revisionNumber) && (g.revisionNumber = BigInt(a.revisionNumber.toString())), (0, k.isSet)(a.revisionHeight) && (g.revisionHeight = BigInt(a.revisionHeight.toString())), g;
    },
    toJSON(a) {
      const g = {};
      return a.portId !== void 0 && (g.portId = a.portId), a.channelId !== void 0 && (g.channelId = a.channelId), a.revisionNumber !== void 0 && (g.revisionNumber = (a.revisionNumber || BigInt(0)).toString()), a.revisionHeight !== void 0 && (g.revisionHeight = (a.revisionHeight || BigInt(0)).toString()), g;
    },
    fromPartial(a) {
      const g = c();
      return g.portId = a.portId ?? "", g.channelId = a.channelId ?? "", a.revisionNumber !== void 0 && a.revisionNumber !== null && (g.revisionNumber = BigInt(a.revisionNumber.toString())), a.revisionHeight !== void 0 && a.revisionHeight !== null && (g.revisionHeight = BigInt(a.revisionHeight.toString())), g;
    }
  };
  function l() {
    return {
      consensusState: void 0,
      clientId: "",
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryChannelConsensusStateResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryChannelConsensusStateResponse",
    encode(a, g = f.BinaryWriter.create()) {
      return a.consensusState !== void 0 && i.Any.encode(a.consensusState, g.uint32(10).fork()).ldelim(), a.clientId !== "" && g.uint32(18).string(a.clientId), a.proof.length !== 0 && g.uint32(26).bytes(a.proof), a.proofHeight !== void 0 && t.Height.encode(a.proofHeight, g.uint32(34).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = l();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.consensusState = i.Any.decode(m, m.uint32());
            break;
          case 2:
            O.clientId = m.string();
            break;
          case 3:
            O.proof = m.bytes();
            break;
          case 4:
            O.proofHeight = t.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = l();
      return (0, k.isSet)(a.consensusState) && (g.consensusState = i.Any.fromJSON(a.consensusState)), (0, k.isSet)(a.clientId) && (g.clientId = String(a.clientId)), (0, k.isSet)(a.proof) && (g.proof = (0, k.bytesFromBase64)(a.proof)), (0, k.isSet)(a.proofHeight) && (g.proofHeight = t.Height.fromJSON(a.proofHeight)), g;
    },
    toJSON(a) {
      const g = {};
      return a.consensusState !== void 0 && (g.consensusState = a.consensusState ? i.Any.toJSON(a.consensusState) : void 0), a.clientId !== void 0 && (g.clientId = a.clientId), a.proof !== void 0 && (g.proof = (0, k.base64FromBytes)(a.proof !== void 0 ? a.proof : new Uint8Array())), a.proofHeight !== void 0 && (g.proofHeight = a.proofHeight ? t.Height.toJSON(a.proofHeight) : void 0), g;
    },
    fromPartial(a) {
      const g = l();
      return a.consensusState !== void 0 && a.consensusState !== null && (g.consensusState = i.Any.fromPartial(a.consensusState)), g.clientId = a.clientId ?? "", g.proof = a.proof ?? new Uint8Array(), a.proofHeight !== void 0 && a.proofHeight !== null && (g.proofHeight = t.Height.fromPartial(a.proofHeight)), g;
    }
  };
  function y() {
    return {
      portId: "",
      channelId: "",
      sequence: BigInt(0)
    };
  }
  e.QueryPacketCommitmentRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentRequest",
    encode(a, g = f.BinaryWriter.create()) {
      return a.portId !== "" && g.uint32(10).string(a.portId), a.channelId !== "" && g.uint32(18).string(a.channelId), a.sequence !== BigInt(0) && g.uint32(24).uint64(a.sequence), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = y();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.portId = m.string();
            break;
          case 2:
            O.channelId = m.string();
            break;
          case 3:
            O.sequence = m.uint64();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = y();
      return (0, k.isSet)(a.portId) && (g.portId = String(a.portId)), (0, k.isSet)(a.channelId) && (g.channelId = String(a.channelId)), (0, k.isSet)(a.sequence) && (g.sequence = BigInt(a.sequence.toString())), g;
    },
    toJSON(a) {
      const g = {};
      return a.portId !== void 0 && (g.portId = a.portId), a.channelId !== void 0 && (g.channelId = a.channelId), a.sequence !== void 0 && (g.sequence = (a.sequence || BigInt(0)).toString()), g;
    },
    fromPartial(a) {
      const g = y();
      return g.portId = a.portId ?? "", g.channelId = a.channelId ?? "", a.sequence !== void 0 && a.sequence !== null && (g.sequence = BigInt(a.sequence.toString())), g;
    }
  };
  function E() {
    return {
      commitment: new Uint8Array(),
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryPacketCommitmentResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentResponse",
    encode(a, g = f.BinaryWriter.create()) {
      return a.commitment.length !== 0 && g.uint32(10).bytes(a.commitment), a.proof.length !== 0 && g.uint32(18).bytes(a.proof), a.proofHeight !== void 0 && t.Height.encode(a.proofHeight, g.uint32(26).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = E();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.commitment = m.bytes();
            break;
          case 2:
            O.proof = m.bytes();
            break;
          case 3:
            O.proofHeight = t.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = E();
      return (0, k.isSet)(a.commitment) && (g.commitment = (0, k.bytesFromBase64)(a.commitment)), (0, k.isSet)(a.proof) && (g.proof = (0, k.bytesFromBase64)(a.proof)), (0, k.isSet)(a.proofHeight) && (g.proofHeight = t.Height.fromJSON(a.proofHeight)), g;
    },
    toJSON(a) {
      const g = {};
      return a.commitment !== void 0 && (g.commitment = (0, k.base64FromBytes)(a.commitment !== void 0 ? a.commitment : new Uint8Array())), a.proof !== void 0 && (g.proof = (0, k.base64FromBytes)(a.proof !== void 0 ? a.proof : new Uint8Array())), a.proofHeight !== void 0 && (g.proofHeight = a.proofHeight ? t.Height.toJSON(a.proofHeight) : void 0), g;
    },
    fromPartial(a) {
      const g = E();
      return g.commitment = a.commitment ?? new Uint8Array(), g.proof = a.proof ?? new Uint8Array(), a.proofHeight !== void 0 && a.proofHeight !== null && (g.proofHeight = t.Height.fromPartial(a.proofHeight)), g;
    }
  };
  function J() {
    return {
      portId: "",
      channelId: "",
      pagination: void 0
    };
  }
  e.QueryPacketCommitmentsRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentsRequest",
    encode(a, g = f.BinaryWriter.create()) {
      return a.portId !== "" && g.uint32(10).string(a.portId), a.channelId !== "" && g.uint32(18).string(a.channelId), a.pagination !== void 0 && n.PageRequest.encode(a.pagination, g.uint32(26).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = J();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.portId = m.string();
            break;
          case 2:
            O.channelId = m.string();
            break;
          case 3:
            O.pagination = n.PageRequest.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = J();
      return (0, k.isSet)(a.portId) && (g.portId = String(a.portId)), (0, k.isSet)(a.channelId) && (g.channelId = String(a.channelId)), (0, k.isSet)(a.pagination) && (g.pagination = n.PageRequest.fromJSON(a.pagination)), g;
    },
    toJSON(a) {
      const g = {};
      return a.portId !== void 0 && (g.portId = a.portId), a.channelId !== void 0 && (g.channelId = a.channelId), a.pagination !== void 0 && (g.pagination = a.pagination ? n.PageRequest.toJSON(a.pagination) : void 0), g;
    },
    fromPartial(a) {
      const g = J();
      return g.portId = a.portId ?? "", g.channelId = a.channelId ?? "", a.pagination !== void 0 && a.pagination !== null && (g.pagination = n.PageRequest.fromPartial(a.pagination)), g;
    }
  };
  function _() {
    return {
      commitments: [],
      pagination: void 0,
      height: t.Height.fromPartial({})
    };
  }
  e.QueryPacketCommitmentsResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentsResponse",
    encode(a, g = f.BinaryWriter.create()) {
      for (const m of a.commitments)
        r.PacketState.encode(m, g.uint32(10).fork()).ldelim();
      return a.pagination !== void 0 && n.PageResponse.encode(a.pagination, g.uint32(18).fork()).ldelim(), a.height !== void 0 && t.Height.encode(a.height, g.uint32(26).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = _();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.commitments.push(r.PacketState.decode(m, m.uint32()));
            break;
          case 2:
            O.pagination = n.PageResponse.decode(m, m.uint32());
            break;
          case 3:
            O.height = t.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = _();
      return Array.isArray(a == null ? void 0 : a.commitments) && (g.commitments = a.commitments.map((m) => r.PacketState.fromJSON(m))), (0, k.isSet)(a.pagination) && (g.pagination = n.PageResponse.fromJSON(a.pagination)), (0, k.isSet)(a.height) && (g.height = t.Height.fromJSON(a.height)), g;
    },
    toJSON(a) {
      const g = {};
      return a.commitments ? g.commitments = a.commitments.map((m) => m ? r.PacketState.toJSON(m) : void 0) : g.commitments = [], a.pagination !== void 0 && (g.pagination = a.pagination ? n.PageResponse.toJSON(a.pagination) : void 0), a.height !== void 0 && (g.height = a.height ? t.Height.toJSON(a.height) : void 0), g;
    },
    fromPartial(a) {
      var m;
      const g = _();
      return g.commitments = ((m = a.commitments) == null ? void 0 : m.map((S) => r.PacketState.fromPartial(S))) || [], a.pagination !== void 0 && a.pagination !== null && (g.pagination = n.PageResponse.fromPartial(a.pagination)), a.height !== void 0 && a.height !== null && (g.height = t.Height.fromPartial(a.height)), g;
    }
  };
  function V() {
    return {
      portId: "",
      channelId: "",
      sequence: BigInt(0)
    };
  }
  e.QueryPacketReceiptRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketReceiptRequest",
    encode(a, g = f.BinaryWriter.create()) {
      return a.portId !== "" && g.uint32(10).string(a.portId), a.channelId !== "" && g.uint32(18).string(a.channelId), a.sequence !== BigInt(0) && g.uint32(24).uint64(a.sequence), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = V();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.portId = m.string();
            break;
          case 2:
            O.channelId = m.string();
            break;
          case 3:
            O.sequence = m.uint64();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = V();
      return (0, k.isSet)(a.portId) && (g.portId = String(a.portId)), (0, k.isSet)(a.channelId) && (g.channelId = String(a.channelId)), (0, k.isSet)(a.sequence) && (g.sequence = BigInt(a.sequence.toString())), g;
    },
    toJSON(a) {
      const g = {};
      return a.portId !== void 0 && (g.portId = a.portId), a.channelId !== void 0 && (g.channelId = a.channelId), a.sequence !== void 0 && (g.sequence = (a.sequence || BigInt(0)).toString()), g;
    },
    fromPartial(a) {
      const g = V();
      return g.portId = a.portId ?? "", g.channelId = a.channelId ?? "", a.sequence !== void 0 && a.sequence !== null && (g.sequence = BigInt(a.sequence.toString())), g;
    }
  };
  function o() {
    return {
      received: !1,
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryPacketReceiptResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketReceiptResponse",
    encode(a, g = f.BinaryWriter.create()) {
      return a.received === !0 && g.uint32(16).bool(a.received), a.proof.length !== 0 && g.uint32(26).bytes(a.proof), a.proofHeight !== void 0 && t.Height.encode(a.proofHeight, g.uint32(34).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = o();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 2:
            O.received = m.bool();
            break;
          case 3:
            O.proof = m.bytes();
            break;
          case 4:
            O.proofHeight = t.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = o();
      return (0, k.isSet)(a.received) && (g.received = !!a.received), (0, k.isSet)(a.proof) && (g.proof = (0, k.bytesFromBase64)(a.proof)), (0, k.isSet)(a.proofHeight) && (g.proofHeight = t.Height.fromJSON(a.proofHeight)), g;
    },
    toJSON(a) {
      const g = {};
      return a.received !== void 0 && (g.received = a.received), a.proof !== void 0 && (g.proof = (0, k.base64FromBytes)(a.proof !== void 0 ? a.proof : new Uint8Array())), a.proofHeight !== void 0 && (g.proofHeight = a.proofHeight ? t.Height.toJSON(a.proofHeight) : void 0), g;
    },
    fromPartial(a) {
      const g = o();
      return g.received = a.received ?? !1, g.proof = a.proof ?? new Uint8Array(), a.proofHeight !== void 0 && a.proofHeight !== null && (g.proofHeight = t.Height.fromPartial(a.proofHeight)), g;
    }
  };
  function p() {
    return {
      portId: "",
      channelId: "",
      sequence: BigInt(0)
    };
  }
  e.QueryPacketAcknowledgementRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementRequest",
    encode(a, g = f.BinaryWriter.create()) {
      return a.portId !== "" && g.uint32(10).string(a.portId), a.channelId !== "" && g.uint32(18).string(a.channelId), a.sequence !== BigInt(0) && g.uint32(24).uint64(a.sequence), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = p();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.portId = m.string();
            break;
          case 2:
            O.channelId = m.string();
            break;
          case 3:
            O.sequence = m.uint64();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = p();
      return (0, k.isSet)(a.portId) && (g.portId = String(a.portId)), (0, k.isSet)(a.channelId) && (g.channelId = String(a.channelId)), (0, k.isSet)(a.sequence) && (g.sequence = BigInt(a.sequence.toString())), g;
    },
    toJSON(a) {
      const g = {};
      return a.portId !== void 0 && (g.portId = a.portId), a.channelId !== void 0 && (g.channelId = a.channelId), a.sequence !== void 0 && (g.sequence = (a.sequence || BigInt(0)).toString()), g;
    },
    fromPartial(a) {
      const g = p();
      return g.portId = a.portId ?? "", g.channelId = a.channelId ?? "", a.sequence !== void 0 && a.sequence !== null && (g.sequence = BigInt(a.sequence.toString())), g;
    }
  };
  function I() {
    return {
      acknowledgement: new Uint8Array(),
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryPacketAcknowledgementResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementResponse",
    encode(a, g = f.BinaryWriter.create()) {
      return a.acknowledgement.length !== 0 && g.uint32(10).bytes(a.acknowledgement), a.proof.length !== 0 && g.uint32(18).bytes(a.proof), a.proofHeight !== void 0 && t.Height.encode(a.proofHeight, g.uint32(26).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = I();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.acknowledgement = m.bytes();
            break;
          case 2:
            O.proof = m.bytes();
            break;
          case 3:
            O.proofHeight = t.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = I();
      return (0, k.isSet)(a.acknowledgement) && (g.acknowledgement = (0, k.bytesFromBase64)(a.acknowledgement)), (0, k.isSet)(a.proof) && (g.proof = (0, k.bytesFromBase64)(a.proof)), (0, k.isSet)(a.proofHeight) && (g.proofHeight = t.Height.fromJSON(a.proofHeight)), g;
    },
    toJSON(a) {
      const g = {};
      return a.acknowledgement !== void 0 && (g.acknowledgement = (0, k.base64FromBytes)(a.acknowledgement !== void 0 ? a.acknowledgement : new Uint8Array())), a.proof !== void 0 && (g.proof = (0, k.base64FromBytes)(a.proof !== void 0 ? a.proof : new Uint8Array())), a.proofHeight !== void 0 && (g.proofHeight = a.proofHeight ? t.Height.toJSON(a.proofHeight) : void 0), g;
    },
    fromPartial(a) {
      const g = I();
      return g.acknowledgement = a.acknowledgement ?? new Uint8Array(), g.proof = a.proof ?? new Uint8Array(), a.proofHeight !== void 0 && a.proofHeight !== null && (g.proofHeight = t.Height.fromPartial(a.proofHeight)), g;
    }
  };
  function q() {
    return {
      portId: "",
      channelId: "",
      pagination: void 0,
      packetCommitmentSequences: []
    };
  }
  e.QueryPacketAcknowledgementsRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementsRequest",
    encode(a, g = f.BinaryWriter.create()) {
      a.portId !== "" && g.uint32(10).string(a.portId), a.channelId !== "" && g.uint32(18).string(a.channelId), a.pagination !== void 0 && n.PageRequest.encode(a.pagination, g.uint32(26).fork()).ldelim(), g.uint32(34).fork();
      for (const m of a.packetCommitmentSequences)
        g.uint64(m);
      return g.ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = q();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.portId = m.string();
            break;
          case 2:
            O.channelId = m.string();
            break;
          case 3:
            O.pagination = n.PageRequest.decode(m, m.uint32());
            break;
          case 4:
            if ((Q & 7) === 2) {
              const G = m.uint32() + m.pos;
              for (; m.pos < G; )
                O.packetCommitmentSequences.push(m.uint64());
            } else
              O.packetCommitmentSequences.push(m.uint64());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = q();
      return (0, k.isSet)(a.portId) && (g.portId = String(a.portId)), (0, k.isSet)(a.channelId) && (g.channelId = String(a.channelId)), (0, k.isSet)(a.pagination) && (g.pagination = n.PageRequest.fromJSON(a.pagination)), Array.isArray(a == null ? void 0 : a.packetCommitmentSequences) && (g.packetCommitmentSequences = a.packetCommitmentSequences.map((m) => BigInt(m.toString()))), g;
    },
    toJSON(a) {
      const g = {};
      return a.portId !== void 0 && (g.portId = a.portId), a.channelId !== void 0 && (g.channelId = a.channelId), a.pagination !== void 0 && (g.pagination = a.pagination ? n.PageRequest.toJSON(a.pagination) : void 0), a.packetCommitmentSequences ? g.packetCommitmentSequences = a.packetCommitmentSequences.map((m) => (m || BigInt(0)).toString()) : g.packetCommitmentSequences = [], g;
    },
    fromPartial(a) {
      var m;
      const g = q();
      return g.portId = a.portId ?? "", g.channelId = a.channelId ?? "", a.pagination !== void 0 && a.pagination !== null && (g.pagination = n.PageRequest.fromPartial(a.pagination)), g.packetCommitmentSequences = ((m = a.packetCommitmentSequences) == null ? void 0 : m.map((S) => BigInt(S.toString()))) || [], g;
    }
  };
  function s() {
    return {
      acknowledgements: [],
      pagination: void 0,
      height: t.Height.fromPartial({})
    };
  }
  e.QueryPacketAcknowledgementsResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementsResponse",
    encode(a, g = f.BinaryWriter.create()) {
      for (const m of a.acknowledgements)
        r.PacketState.encode(m, g.uint32(10).fork()).ldelim();
      return a.pagination !== void 0 && n.PageResponse.encode(a.pagination, g.uint32(18).fork()).ldelim(), a.height !== void 0 && t.Height.encode(a.height, g.uint32(26).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = s();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.acknowledgements.push(r.PacketState.decode(m, m.uint32()));
            break;
          case 2:
            O.pagination = n.PageResponse.decode(m, m.uint32());
            break;
          case 3:
            O.height = t.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = s();
      return Array.isArray(a == null ? void 0 : a.acknowledgements) && (g.acknowledgements = a.acknowledgements.map((m) => r.PacketState.fromJSON(m))), (0, k.isSet)(a.pagination) && (g.pagination = n.PageResponse.fromJSON(a.pagination)), (0, k.isSet)(a.height) && (g.height = t.Height.fromJSON(a.height)), g;
    },
    toJSON(a) {
      const g = {};
      return a.acknowledgements ? g.acknowledgements = a.acknowledgements.map((m) => m ? r.PacketState.toJSON(m) : void 0) : g.acknowledgements = [], a.pagination !== void 0 && (g.pagination = a.pagination ? n.PageResponse.toJSON(a.pagination) : void 0), a.height !== void 0 && (g.height = a.height ? t.Height.toJSON(a.height) : void 0), g;
    },
    fromPartial(a) {
      var m;
      const g = s();
      return g.acknowledgements = ((m = a.acknowledgements) == null ? void 0 : m.map((S) => r.PacketState.fromPartial(S))) || [], a.pagination !== void 0 && a.pagination !== null && (g.pagination = n.PageResponse.fromPartial(a.pagination)), a.height !== void 0 && a.height !== null && (g.height = t.Height.fromPartial(a.height)), g;
    }
  };
  function u() {
    return {
      portId: "",
      channelId: "",
      packetCommitmentSequences: []
    };
  }
  e.QueryUnreceivedPacketsRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryUnreceivedPacketsRequest",
    encode(a, g = f.BinaryWriter.create()) {
      a.portId !== "" && g.uint32(10).string(a.portId), a.channelId !== "" && g.uint32(18).string(a.channelId), g.uint32(26).fork();
      for (const m of a.packetCommitmentSequences)
        g.uint64(m);
      return g.ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = u();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.portId = m.string();
            break;
          case 2:
            O.channelId = m.string();
            break;
          case 3:
            if ((Q & 7) === 2) {
              const G = m.uint32() + m.pos;
              for (; m.pos < G; )
                O.packetCommitmentSequences.push(m.uint64());
            } else
              O.packetCommitmentSequences.push(m.uint64());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = u();
      return (0, k.isSet)(a.portId) && (g.portId = String(a.portId)), (0, k.isSet)(a.channelId) && (g.channelId = String(a.channelId)), Array.isArray(a == null ? void 0 : a.packetCommitmentSequences) && (g.packetCommitmentSequences = a.packetCommitmentSequences.map((m) => BigInt(m.toString()))), g;
    },
    toJSON(a) {
      const g = {};
      return a.portId !== void 0 && (g.portId = a.portId), a.channelId !== void 0 && (g.channelId = a.channelId), a.packetCommitmentSequences ? g.packetCommitmentSequences = a.packetCommitmentSequences.map((m) => (m || BigInt(0)).toString()) : g.packetCommitmentSequences = [], g;
    },
    fromPartial(a) {
      var m;
      const g = u();
      return g.portId = a.portId ?? "", g.channelId = a.channelId ?? "", g.packetCommitmentSequences = ((m = a.packetCommitmentSequences) == null ? void 0 : m.map((S) => BigInt(S.toString()))) || [], g;
    }
  };
  function A() {
    return {
      sequences: [],
      height: t.Height.fromPartial({})
    };
  }
  e.QueryUnreceivedPacketsResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryUnreceivedPacketsResponse",
    encode(a, g = f.BinaryWriter.create()) {
      g.uint32(10).fork();
      for (const m of a.sequences)
        g.uint64(m);
      return g.ldelim(), a.height !== void 0 && t.Height.encode(a.height, g.uint32(18).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = A();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            if ((Q & 7) === 2) {
              const G = m.uint32() + m.pos;
              for (; m.pos < G; )
                O.sequences.push(m.uint64());
            } else
              O.sequences.push(m.uint64());
            break;
          case 2:
            O.height = t.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = A();
      return Array.isArray(a == null ? void 0 : a.sequences) && (g.sequences = a.sequences.map((m) => BigInt(m.toString()))), (0, k.isSet)(a.height) && (g.height = t.Height.fromJSON(a.height)), g;
    },
    toJSON(a) {
      const g = {};
      return a.sequences ? g.sequences = a.sequences.map((m) => (m || BigInt(0)).toString()) : g.sequences = [], a.height !== void 0 && (g.height = a.height ? t.Height.toJSON(a.height) : void 0), g;
    },
    fromPartial(a) {
      var m;
      const g = A();
      return g.sequences = ((m = a.sequences) == null ? void 0 : m.map((S) => BigInt(S.toString()))) || [], a.height !== void 0 && a.height !== null && (g.height = t.Height.fromPartial(a.height)), g;
    }
  };
  function R() {
    return {
      portId: "",
      channelId: "",
      packetAckSequences: []
    };
  }
  e.QueryUnreceivedAcksRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryUnreceivedAcksRequest",
    encode(a, g = f.BinaryWriter.create()) {
      a.portId !== "" && g.uint32(10).string(a.portId), a.channelId !== "" && g.uint32(18).string(a.channelId), g.uint32(26).fork();
      for (const m of a.packetAckSequences)
        g.uint64(m);
      return g.ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = R();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.portId = m.string();
            break;
          case 2:
            O.channelId = m.string();
            break;
          case 3:
            if ((Q & 7) === 2) {
              const G = m.uint32() + m.pos;
              for (; m.pos < G; )
                O.packetAckSequences.push(m.uint64());
            } else
              O.packetAckSequences.push(m.uint64());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = R();
      return (0, k.isSet)(a.portId) && (g.portId = String(a.portId)), (0, k.isSet)(a.channelId) && (g.channelId = String(a.channelId)), Array.isArray(a == null ? void 0 : a.packetAckSequences) && (g.packetAckSequences = a.packetAckSequences.map((m) => BigInt(m.toString()))), g;
    },
    toJSON(a) {
      const g = {};
      return a.portId !== void 0 && (g.portId = a.portId), a.channelId !== void 0 && (g.channelId = a.channelId), a.packetAckSequences ? g.packetAckSequences = a.packetAckSequences.map((m) => (m || BigInt(0)).toString()) : g.packetAckSequences = [], g;
    },
    fromPartial(a) {
      var m;
      const g = R();
      return g.portId = a.portId ?? "", g.channelId = a.channelId ?? "", g.packetAckSequences = ((m = a.packetAckSequences) == null ? void 0 : m.map((S) => BigInt(S.toString()))) || [], g;
    }
  };
  function v() {
    return {
      sequences: [],
      height: t.Height.fromPartial({})
    };
  }
  e.QueryUnreceivedAcksResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryUnreceivedAcksResponse",
    encode(a, g = f.BinaryWriter.create()) {
      g.uint32(10).fork();
      for (const m of a.sequences)
        g.uint64(m);
      return g.ldelim(), a.height !== void 0 && t.Height.encode(a.height, g.uint32(18).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = v();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            if ((Q & 7) === 2) {
              const G = m.uint32() + m.pos;
              for (; m.pos < G; )
                O.sequences.push(m.uint64());
            } else
              O.sequences.push(m.uint64());
            break;
          case 2:
            O.height = t.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = v();
      return Array.isArray(a == null ? void 0 : a.sequences) && (g.sequences = a.sequences.map((m) => BigInt(m.toString()))), (0, k.isSet)(a.height) && (g.height = t.Height.fromJSON(a.height)), g;
    },
    toJSON(a) {
      const g = {};
      return a.sequences ? g.sequences = a.sequences.map((m) => (m || BigInt(0)).toString()) : g.sequences = [], a.height !== void 0 && (g.height = a.height ? t.Height.toJSON(a.height) : void 0), g;
    },
    fromPartial(a) {
      var m;
      const g = v();
      return g.sequences = ((m = a.sequences) == null ? void 0 : m.map((S) => BigInt(S.toString()))) || [], a.height !== void 0 && a.height !== null && (g.height = t.Height.fromPartial(a.height)), g;
    }
  };
  function D() {
    return {
      portId: "",
      channelId: ""
    };
  }
  e.QueryNextSequenceReceiveRequest = {
    typeUrl: "/ibc.core.channel.v1.QueryNextSequenceReceiveRequest",
    encode(a, g = f.BinaryWriter.create()) {
      return a.portId !== "" && g.uint32(10).string(a.portId), a.channelId !== "" && g.uint32(18).string(a.channelId), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = D();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.portId = m.string();
            break;
          case 2:
            O.channelId = m.string();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = D();
      return (0, k.isSet)(a.portId) && (g.portId = String(a.portId)), (0, k.isSet)(a.channelId) && (g.channelId = String(a.channelId)), g;
    },
    toJSON(a) {
      const g = {};
      return a.portId !== void 0 && (g.portId = a.portId), a.channelId !== void 0 && (g.channelId = a.channelId), g;
    },
    fromPartial(a) {
      const g = D();
      return g.portId = a.portId ?? "", g.channelId = a.channelId ?? "", g;
    }
  };
  function W() {
    return {
      nextSequenceReceive: BigInt(0),
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryNextSequenceReceiveResponse = {
    typeUrl: "/ibc.core.channel.v1.QueryNextSequenceReceiveResponse",
    encode(a, g = f.BinaryWriter.create()) {
      return a.nextSequenceReceive !== BigInt(0) && g.uint32(8).uint64(a.nextSequenceReceive), a.proof.length !== 0 && g.uint32(18).bytes(a.proof), a.proofHeight !== void 0 && t.Height.encode(a.proofHeight, g.uint32(26).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof f.BinaryReader ? a : new f.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = W();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.nextSequenceReceive = m.uint64();
            break;
          case 2:
            O.proof = m.bytes();
            break;
          case 3:
            O.proofHeight = t.Height.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = W();
      return (0, k.isSet)(a.nextSequenceReceive) && (g.nextSequenceReceive = BigInt(a.nextSequenceReceive.toString())), (0, k.isSet)(a.proof) && (g.proof = (0, k.bytesFromBase64)(a.proof)), (0, k.isSet)(a.proofHeight) && (g.proofHeight = t.Height.fromJSON(a.proofHeight)), g;
    },
    toJSON(a) {
      const g = {};
      return a.nextSequenceReceive !== void 0 && (g.nextSequenceReceive = (a.nextSequenceReceive || BigInt(0)).toString()), a.proof !== void 0 && (g.proof = (0, k.base64FromBytes)(a.proof !== void 0 ? a.proof : new Uint8Array())), a.proofHeight !== void 0 && (g.proofHeight = a.proofHeight ? t.Height.toJSON(a.proofHeight) : void 0), g;
    },
    fromPartial(a) {
      const g = W();
      return a.nextSequenceReceive !== void 0 && a.nextSequenceReceive !== null && (g.nextSequenceReceive = BigInt(a.nextSequenceReceive.toString())), g.proof = a.proof ?? new Uint8Array(), a.proofHeight !== void 0 && a.proofHeight !== null && (g.proofHeight = t.Height.fromPartial(a.proofHeight)), g;
    }
  };
  class H {
    constructor(g) {
      this.rpc = g, this.Channel = this.Channel.bind(this), this.Channels = this.Channels.bind(this), this.ConnectionChannels = this.ConnectionChannels.bind(this), this.ChannelClientState = this.ChannelClientState.bind(this), this.ChannelConsensusState = this.ChannelConsensusState.bind(this), this.PacketCommitment = this.PacketCommitment.bind(this), this.PacketCommitments = this.PacketCommitments.bind(this), this.PacketReceipt = this.PacketReceipt.bind(this), this.PacketAcknowledgement = this.PacketAcknowledgement.bind(this), this.PacketAcknowledgements = this.PacketAcknowledgements.bind(this), this.UnreceivedPackets = this.UnreceivedPackets.bind(this), this.UnreceivedAcks = this.UnreceivedAcks.bind(this), this.NextSequenceReceive = this.NextSequenceReceive.bind(this);
    }
    Channel(g) {
      const m = e.QueryChannelRequest.encode(g).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "Channel", m).then((O) => e.QueryChannelResponse.decode(new f.BinaryReader(O)));
    }
    Channels(g = {
      pagination: n.PageRequest.fromPartial({})
    }) {
      const m = e.QueryChannelsRequest.encode(g).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "Channels", m).then((O) => e.QueryChannelsResponse.decode(new f.BinaryReader(O)));
    }
    ConnectionChannels(g) {
      const m = e.QueryConnectionChannelsRequest.encode(g).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "ConnectionChannels", m).then((O) => e.QueryConnectionChannelsResponse.decode(new f.BinaryReader(O)));
    }
    ChannelClientState(g) {
      const m = e.QueryChannelClientStateRequest.encode(g).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "ChannelClientState", m).then((O) => e.QueryChannelClientStateResponse.decode(new f.BinaryReader(O)));
    }
    ChannelConsensusState(g) {
      const m = e.QueryChannelConsensusStateRequest.encode(g).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "ChannelConsensusState", m).then((O) => e.QueryChannelConsensusStateResponse.decode(new f.BinaryReader(O)));
    }
    PacketCommitment(g) {
      const m = e.QueryPacketCommitmentRequest.encode(g).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitment", m).then((O) => e.QueryPacketCommitmentResponse.decode(new f.BinaryReader(O)));
    }
    PacketCommitments(g) {
      const m = e.QueryPacketCommitmentsRequest.encode(g).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitments", m).then((O) => e.QueryPacketCommitmentsResponse.decode(new f.BinaryReader(O)));
    }
    PacketReceipt(g) {
      const m = e.QueryPacketReceiptRequest.encode(g).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "PacketReceipt", m).then((O) => e.QueryPacketReceiptResponse.decode(new f.BinaryReader(O)));
    }
    PacketAcknowledgement(g) {
      const m = e.QueryPacketAcknowledgementRequest.encode(g).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgement", m).then((O) => e.QueryPacketAcknowledgementResponse.decode(new f.BinaryReader(O)));
    }
    PacketAcknowledgements(g) {
      const m = e.QueryPacketAcknowledgementsRequest.encode(g).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgements", m).then((O) => e.QueryPacketAcknowledgementsResponse.decode(new f.BinaryReader(O)));
    }
    UnreceivedPackets(g) {
      const m = e.QueryUnreceivedPacketsRequest.encode(g).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedPackets", m).then((O) => e.QueryUnreceivedPacketsResponse.decode(new f.BinaryReader(O)));
    }
    UnreceivedAcks(g) {
      const m = e.QueryUnreceivedAcksRequest.encode(g).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedAcks", m).then((O) => e.QueryUnreceivedAcksResponse.decode(new f.BinaryReader(O)));
    }
    NextSequenceReceive(g) {
      const m = e.QueryNextSequenceReceiveRequest.encode(g).finish();
      return this.rpc.request("ibc.core.channel.v1.Query", "NextSequenceReceive", m).then((O) => e.QueryNextSequenceReceiveResponse.decode(new f.BinaryReader(O)));
    }
  }
  e.QueryClientImpl = H;
})(fl);
var pl = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryUpgradedConsensusStateResponse = e.QueryUpgradedConsensusStateRequest = e.QueryUpgradedClientStateResponse = e.QueryUpgradedClientStateRequest = e.QueryClientParamsResponse = e.QueryClientParamsRequest = e.QueryClientStatusResponse = e.QueryClientStatusRequest = e.QueryConsensusStateHeightsResponse = e.QueryConsensusStateHeightsRequest = e.QueryConsensusStatesResponse = e.QueryConsensusStatesRequest = e.QueryConsensusStateResponse = e.QueryConsensusStateRequest = e.QueryClientStatesResponse = e.QueryClientStatesRequest = e.QueryClientStateResponse = e.QueryClientStateRequest = e.protobufPackage = void 0;
  const n = Ae, r = Be, t = Yn, i = re, f = ie;
  e.protobufPackage = "ibc.core.client.v1";
  function k() {
    return {
      clientId: ""
    };
  }
  e.QueryClientStateRequest = {
    typeUrl: "/ibc.core.client.v1.QueryClientStateRequest",
    encode(q, s = i.BinaryWriter.create()) {
      return q.clientId !== "" && s.uint32(10).string(q.clientId), s;
    },
    decode(q, s) {
      const u = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let A = s === void 0 ? u.len : u.pos + s;
      const R = k();
      for (; u.pos < A; ) {
        const v = u.uint32();
        switch (v >>> 3) {
          case 1:
            R.clientId = u.string();
            break;
          default:
            u.skipType(v & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      const s = k();
      return (0, f.isSet)(q.clientId) && (s.clientId = String(q.clientId)), s;
    },
    toJSON(q) {
      const s = {};
      return q.clientId !== void 0 && (s.clientId = q.clientId), s;
    },
    fromPartial(q) {
      const s = k();
      return s.clientId = q.clientId ?? "", s;
    }
  };
  function C() {
    return {
      clientState: void 0,
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryClientStateResponse = {
    typeUrl: "/ibc.core.client.v1.QueryClientStateResponse",
    encode(q, s = i.BinaryWriter.create()) {
      return q.clientState !== void 0 && r.Any.encode(q.clientState, s.uint32(10).fork()).ldelim(), q.proof.length !== 0 && s.uint32(18).bytes(q.proof), q.proofHeight !== void 0 && t.Height.encode(q.proofHeight, s.uint32(26).fork()).ldelim(), s;
    },
    decode(q, s) {
      const u = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let A = s === void 0 ? u.len : u.pos + s;
      const R = C();
      for (; u.pos < A; ) {
        const v = u.uint32();
        switch (v >>> 3) {
          case 1:
            R.clientState = r.Any.decode(u, u.uint32());
            break;
          case 2:
            R.proof = u.bytes();
            break;
          case 3:
            R.proofHeight = t.Height.decode(u, u.uint32());
            break;
          default:
            u.skipType(v & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      const s = C();
      return (0, f.isSet)(q.clientState) && (s.clientState = r.Any.fromJSON(q.clientState)), (0, f.isSet)(q.proof) && (s.proof = (0, f.bytesFromBase64)(q.proof)), (0, f.isSet)(q.proofHeight) && (s.proofHeight = t.Height.fromJSON(q.proofHeight)), s;
    },
    toJSON(q) {
      const s = {};
      return q.clientState !== void 0 && (s.clientState = q.clientState ? r.Any.toJSON(q.clientState) : void 0), q.proof !== void 0 && (s.proof = (0, f.base64FromBytes)(q.proof !== void 0 ? q.proof : new Uint8Array())), q.proofHeight !== void 0 && (s.proofHeight = q.proofHeight ? t.Height.toJSON(q.proofHeight) : void 0), s;
    },
    fromPartial(q) {
      const s = C();
      return q.clientState !== void 0 && q.clientState !== null && (s.clientState = r.Any.fromPartial(q.clientState)), s.proof = q.proof ?? new Uint8Array(), q.proofHeight !== void 0 && q.proofHeight !== null && (s.proofHeight = t.Height.fromPartial(q.proofHeight)), s;
    }
  };
  function T() {
    return {
      pagination: void 0
    };
  }
  e.QueryClientStatesRequest = {
    typeUrl: "/ibc.core.client.v1.QueryClientStatesRequest",
    encode(q, s = i.BinaryWriter.create()) {
      return q.pagination !== void 0 && n.PageRequest.encode(q.pagination, s.uint32(10).fork()).ldelim(), s;
    },
    decode(q, s) {
      const u = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let A = s === void 0 ? u.len : u.pos + s;
      const R = T();
      for (; u.pos < A; ) {
        const v = u.uint32();
        switch (v >>> 3) {
          case 1:
            R.pagination = n.PageRequest.decode(u, u.uint32());
            break;
          default:
            u.skipType(v & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      const s = T();
      return (0, f.isSet)(q.pagination) && (s.pagination = n.PageRequest.fromJSON(q.pagination)), s;
    },
    toJSON(q) {
      const s = {};
      return q.pagination !== void 0 && (s.pagination = q.pagination ? n.PageRequest.toJSON(q.pagination) : void 0), s;
    },
    fromPartial(q) {
      const s = T();
      return q.pagination !== void 0 && q.pagination !== null && (s.pagination = n.PageRequest.fromPartial(q.pagination)), s;
    }
  };
  function U() {
    return {
      clientStates: [],
      pagination: void 0
    };
  }
  e.QueryClientStatesResponse = {
    typeUrl: "/ibc.core.client.v1.QueryClientStatesResponse",
    encode(q, s = i.BinaryWriter.create()) {
      for (const u of q.clientStates)
        t.IdentifiedClientState.encode(u, s.uint32(10).fork()).ldelim();
      return q.pagination !== void 0 && n.PageResponse.encode(q.pagination, s.uint32(18).fork()).ldelim(), s;
    },
    decode(q, s) {
      const u = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let A = s === void 0 ? u.len : u.pos + s;
      const R = U();
      for (; u.pos < A; ) {
        const v = u.uint32();
        switch (v >>> 3) {
          case 1:
            R.clientStates.push(t.IdentifiedClientState.decode(u, u.uint32()));
            break;
          case 2:
            R.pagination = n.PageResponse.decode(u, u.uint32());
            break;
          default:
            u.skipType(v & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      const s = U();
      return Array.isArray(q == null ? void 0 : q.clientStates) && (s.clientStates = q.clientStates.map((u) => t.IdentifiedClientState.fromJSON(u))), (0, f.isSet)(q.pagination) && (s.pagination = n.PageResponse.fromJSON(q.pagination)), s;
    },
    toJSON(q) {
      const s = {};
      return q.clientStates ? s.clientStates = q.clientStates.map((u) => u ? t.IdentifiedClientState.toJSON(u) : void 0) : s.clientStates = [], q.pagination !== void 0 && (s.pagination = q.pagination ? n.PageResponse.toJSON(q.pagination) : void 0), s;
    },
    fromPartial(q) {
      var u;
      const s = U();
      return s.clientStates = ((u = q.clientStates) == null ? void 0 : u.map((A) => t.IdentifiedClientState.fromPartial(A))) || [], q.pagination !== void 0 && q.pagination !== null && (s.pagination = n.PageResponse.fromPartial(q.pagination)), s;
    }
  };
  function w() {
    return {
      clientId: "",
      revisionNumber: BigInt(0),
      revisionHeight: BigInt(0),
      latestHeight: !1
    };
  }
  e.QueryConsensusStateRequest = {
    typeUrl: "/ibc.core.client.v1.QueryConsensusStateRequest",
    encode(q, s = i.BinaryWriter.create()) {
      return q.clientId !== "" && s.uint32(10).string(q.clientId), q.revisionNumber !== BigInt(0) && s.uint32(16).uint64(q.revisionNumber), q.revisionHeight !== BigInt(0) && s.uint32(24).uint64(q.revisionHeight), q.latestHeight === !0 && s.uint32(32).bool(q.latestHeight), s;
    },
    decode(q, s) {
      const u = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let A = s === void 0 ? u.len : u.pos + s;
      const R = w();
      for (; u.pos < A; ) {
        const v = u.uint32();
        switch (v >>> 3) {
          case 1:
            R.clientId = u.string();
            break;
          case 2:
            R.revisionNumber = u.uint64();
            break;
          case 3:
            R.revisionHeight = u.uint64();
            break;
          case 4:
            R.latestHeight = u.bool();
            break;
          default:
            u.skipType(v & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      const s = w();
      return (0, f.isSet)(q.clientId) && (s.clientId = String(q.clientId)), (0, f.isSet)(q.revisionNumber) && (s.revisionNumber = BigInt(q.revisionNumber.toString())), (0, f.isSet)(q.revisionHeight) && (s.revisionHeight = BigInt(q.revisionHeight.toString())), (0, f.isSet)(q.latestHeight) && (s.latestHeight = !!q.latestHeight), s;
    },
    toJSON(q) {
      const s = {};
      return q.clientId !== void 0 && (s.clientId = q.clientId), q.revisionNumber !== void 0 && (s.revisionNumber = (q.revisionNumber || BigInt(0)).toString()), q.revisionHeight !== void 0 && (s.revisionHeight = (q.revisionHeight || BigInt(0)).toString()), q.latestHeight !== void 0 && (s.latestHeight = q.latestHeight), s;
    },
    fromPartial(q) {
      const s = w();
      return s.clientId = q.clientId ?? "", q.revisionNumber !== void 0 && q.revisionNumber !== null && (s.revisionNumber = BigInt(q.revisionNumber.toString())), q.revisionHeight !== void 0 && q.revisionHeight !== null && (s.revisionHeight = BigInt(q.revisionHeight.toString())), s.latestHeight = q.latestHeight ?? !1, s;
    }
  };
  function N() {
    return {
      consensusState: void 0,
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryConsensusStateResponse = {
    typeUrl: "/ibc.core.client.v1.QueryConsensusStateResponse",
    encode(q, s = i.BinaryWriter.create()) {
      return q.consensusState !== void 0 && r.Any.encode(q.consensusState, s.uint32(10).fork()).ldelim(), q.proof.length !== 0 && s.uint32(18).bytes(q.proof), q.proofHeight !== void 0 && t.Height.encode(q.proofHeight, s.uint32(26).fork()).ldelim(), s;
    },
    decode(q, s) {
      const u = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let A = s === void 0 ? u.len : u.pos + s;
      const R = N();
      for (; u.pos < A; ) {
        const v = u.uint32();
        switch (v >>> 3) {
          case 1:
            R.consensusState = r.Any.decode(u, u.uint32());
            break;
          case 2:
            R.proof = u.bytes();
            break;
          case 3:
            R.proofHeight = t.Height.decode(u, u.uint32());
            break;
          default:
            u.skipType(v & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      const s = N();
      return (0, f.isSet)(q.consensusState) && (s.consensusState = r.Any.fromJSON(q.consensusState)), (0, f.isSet)(q.proof) && (s.proof = (0, f.bytesFromBase64)(q.proof)), (0, f.isSet)(q.proofHeight) && (s.proofHeight = t.Height.fromJSON(q.proofHeight)), s;
    },
    toJSON(q) {
      const s = {};
      return q.consensusState !== void 0 && (s.consensusState = q.consensusState ? r.Any.toJSON(q.consensusState) : void 0), q.proof !== void 0 && (s.proof = (0, f.base64FromBytes)(q.proof !== void 0 ? q.proof : new Uint8Array())), q.proofHeight !== void 0 && (s.proofHeight = q.proofHeight ? t.Height.toJSON(q.proofHeight) : void 0), s;
    },
    fromPartial(q) {
      const s = N();
      return q.consensusState !== void 0 && q.consensusState !== null && (s.consensusState = r.Any.fromPartial(q.consensusState)), s.proof = q.proof ?? new Uint8Array(), q.proofHeight !== void 0 && q.proofHeight !== null && (s.proofHeight = t.Height.fromPartial(q.proofHeight)), s;
    }
  };
  function h() {
    return {
      clientId: "",
      pagination: void 0
    };
  }
  e.QueryConsensusStatesRequest = {
    typeUrl: "/ibc.core.client.v1.QueryConsensusStatesRequest",
    encode(q, s = i.BinaryWriter.create()) {
      return q.clientId !== "" && s.uint32(10).string(q.clientId), q.pagination !== void 0 && n.PageRequest.encode(q.pagination, s.uint32(18).fork()).ldelim(), s;
    },
    decode(q, s) {
      const u = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let A = s === void 0 ? u.len : u.pos + s;
      const R = h();
      for (; u.pos < A; ) {
        const v = u.uint32();
        switch (v >>> 3) {
          case 1:
            R.clientId = u.string();
            break;
          case 2:
            R.pagination = n.PageRequest.decode(u, u.uint32());
            break;
          default:
            u.skipType(v & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      const s = h();
      return (0, f.isSet)(q.clientId) && (s.clientId = String(q.clientId)), (0, f.isSet)(q.pagination) && (s.pagination = n.PageRequest.fromJSON(q.pagination)), s;
    },
    toJSON(q) {
      const s = {};
      return q.clientId !== void 0 && (s.clientId = q.clientId), q.pagination !== void 0 && (s.pagination = q.pagination ? n.PageRequest.toJSON(q.pagination) : void 0), s;
    },
    fromPartial(q) {
      const s = h();
      return s.clientId = q.clientId ?? "", q.pagination !== void 0 && q.pagination !== null && (s.pagination = n.PageRequest.fromPartial(q.pagination)), s;
    }
  };
  function P() {
    return {
      consensusStates: [],
      pagination: void 0
    };
  }
  e.QueryConsensusStatesResponse = {
    typeUrl: "/ibc.core.client.v1.QueryConsensusStatesResponse",
    encode(q, s = i.BinaryWriter.create()) {
      for (const u of q.consensusStates)
        t.ConsensusStateWithHeight.encode(u, s.uint32(10).fork()).ldelim();
      return q.pagination !== void 0 && n.PageResponse.encode(q.pagination, s.uint32(18).fork()).ldelim(), s;
    },
    decode(q, s) {
      const u = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let A = s === void 0 ? u.len : u.pos + s;
      const R = P();
      for (; u.pos < A; ) {
        const v = u.uint32();
        switch (v >>> 3) {
          case 1:
            R.consensusStates.push(t.ConsensusStateWithHeight.decode(u, u.uint32()));
            break;
          case 2:
            R.pagination = n.PageResponse.decode(u, u.uint32());
            break;
          default:
            u.skipType(v & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      const s = P();
      return Array.isArray(q == null ? void 0 : q.consensusStates) && (s.consensusStates = q.consensusStates.map((u) => t.ConsensusStateWithHeight.fromJSON(u))), (0, f.isSet)(q.pagination) && (s.pagination = n.PageResponse.fromJSON(q.pagination)), s;
    },
    toJSON(q) {
      const s = {};
      return q.consensusStates ? s.consensusStates = q.consensusStates.map((u) => u ? t.ConsensusStateWithHeight.toJSON(u) : void 0) : s.consensusStates = [], q.pagination !== void 0 && (s.pagination = q.pagination ? n.PageResponse.toJSON(q.pagination) : void 0), s;
    },
    fromPartial(q) {
      var u;
      const s = P();
      return s.consensusStates = ((u = q.consensusStates) == null ? void 0 : u.map((A) => t.ConsensusStateWithHeight.fromPartial(A))) || [], q.pagination !== void 0 && q.pagination !== null && (s.pagination = n.PageResponse.fromPartial(q.pagination)), s;
    }
  };
  function b() {
    return {
      clientId: "",
      pagination: void 0
    };
  }
  e.QueryConsensusStateHeightsRequest = {
    typeUrl: "/ibc.core.client.v1.QueryConsensusStateHeightsRequest",
    encode(q, s = i.BinaryWriter.create()) {
      return q.clientId !== "" && s.uint32(10).string(q.clientId), q.pagination !== void 0 && n.PageRequest.encode(q.pagination, s.uint32(18).fork()).ldelim(), s;
    },
    decode(q, s) {
      const u = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let A = s === void 0 ? u.len : u.pos + s;
      const R = b();
      for (; u.pos < A; ) {
        const v = u.uint32();
        switch (v >>> 3) {
          case 1:
            R.clientId = u.string();
            break;
          case 2:
            R.pagination = n.PageRequest.decode(u, u.uint32());
            break;
          default:
            u.skipType(v & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      const s = b();
      return (0, f.isSet)(q.clientId) && (s.clientId = String(q.clientId)), (0, f.isSet)(q.pagination) && (s.pagination = n.PageRequest.fromJSON(q.pagination)), s;
    },
    toJSON(q) {
      const s = {};
      return q.clientId !== void 0 && (s.clientId = q.clientId), q.pagination !== void 0 && (s.pagination = q.pagination ? n.PageRequest.toJSON(q.pagination) : void 0), s;
    },
    fromPartial(q) {
      const s = b();
      return s.clientId = q.clientId ?? "", q.pagination !== void 0 && q.pagination !== null && (s.pagination = n.PageRequest.fromPartial(q.pagination)), s;
    }
  };
  function c() {
    return {
      consensusStateHeights: [],
      pagination: void 0
    };
  }
  e.QueryConsensusStateHeightsResponse = {
    typeUrl: "/ibc.core.client.v1.QueryConsensusStateHeightsResponse",
    encode(q, s = i.BinaryWriter.create()) {
      for (const u of q.consensusStateHeights)
        t.Height.encode(u, s.uint32(10).fork()).ldelim();
      return q.pagination !== void 0 && n.PageResponse.encode(q.pagination, s.uint32(18).fork()).ldelim(), s;
    },
    decode(q, s) {
      const u = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let A = s === void 0 ? u.len : u.pos + s;
      const R = c();
      for (; u.pos < A; ) {
        const v = u.uint32();
        switch (v >>> 3) {
          case 1:
            R.consensusStateHeights.push(t.Height.decode(u, u.uint32()));
            break;
          case 2:
            R.pagination = n.PageResponse.decode(u, u.uint32());
            break;
          default:
            u.skipType(v & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      const s = c();
      return Array.isArray(q == null ? void 0 : q.consensusStateHeights) && (s.consensusStateHeights = q.consensusStateHeights.map((u) => t.Height.fromJSON(u))), (0, f.isSet)(q.pagination) && (s.pagination = n.PageResponse.fromJSON(q.pagination)), s;
    },
    toJSON(q) {
      const s = {};
      return q.consensusStateHeights ? s.consensusStateHeights = q.consensusStateHeights.map((u) => u ? t.Height.toJSON(u) : void 0) : s.consensusStateHeights = [], q.pagination !== void 0 && (s.pagination = q.pagination ? n.PageResponse.toJSON(q.pagination) : void 0), s;
    },
    fromPartial(q) {
      var u;
      const s = c();
      return s.consensusStateHeights = ((u = q.consensusStateHeights) == null ? void 0 : u.map((A) => t.Height.fromPartial(A))) || [], q.pagination !== void 0 && q.pagination !== null && (s.pagination = n.PageResponse.fromPartial(q.pagination)), s;
    }
  };
  function l() {
    return {
      clientId: ""
    };
  }
  e.QueryClientStatusRequest = {
    typeUrl: "/ibc.core.client.v1.QueryClientStatusRequest",
    encode(q, s = i.BinaryWriter.create()) {
      return q.clientId !== "" && s.uint32(10).string(q.clientId), s;
    },
    decode(q, s) {
      const u = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let A = s === void 0 ? u.len : u.pos + s;
      const R = l();
      for (; u.pos < A; ) {
        const v = u.uint32();
        switch (v >>> 3) {
          case 1:
            R.clientId = u.string();
            break;
          default:
            u.skipType(v & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      const s = l();
      return (0, f.isSet)(q.clientId) && (s.clientId = String(q.clientId)), s;
    },
    toJSON(q) {
      const s = {};
      return q.clientId !== void 0 && (s.clientId = q.clientId), s;
    },
    fromPartial(q) {
      const s = l();
      return s.clientId = q.clientId ?? "", s;
    }
  };
  function y() {
    return {
      status: ""
    };
  }
  e.QueryClientStatusResponse = {
    typeUrl: "/ibc.core.client.v1.QueryClientStatusResponse",
    encode(q, s = i.BinaryWriter.create()) {
      return q.status !== "" && s.uint32(10).string(q.status), s;
    },
    decode(q, s) {
      const u = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let A = s === void 0 ? u.len : u.pos + s;
      const R = y();
      for (; u.pos < A; ) {
        const v = u.uint32();
        switch (v >>> 3) {
          case 1:
            R.status = u.string();
            break;
          default:
            u.skipType(v & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      const s = y();
      return (0, f.isSet)(q.status) && (s.status = String(q.status)), s;
    },
    toJSON(q) {
      const s = {};
      return q.status !== void 0 && (s.status = q.status), s;
    },
    fromPartial(q) {
      const s = y();
      return s.status = q.status ?? "", s;
    }
  };
  function E() {
    return {};
  }
  e.QueryClientParamsRequest = {
    typeUrl: "/ibc.core.client.v1.QueryClientParamsRequest",
    encode(q, s = i.BinaryWriter.create()) {
      return s;
    },
    decode(q, s) {
      const u = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let A = s === void 0 ? u.len : u.pos + s;
      const R = E();
      for (; u.pos < A; ) {
        const v = u.uint32();
        switch (v >>> 3) {
          default:
            u.skipType(v & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      return E();
    },
    toJSON(q) {
      return {};
    },
    fromPartial(q) {
      return E();
    }
  };
  function J() {
    return {
      params: void 0
    };
  }
  e.QueryClientParamsResponse = {
    typeUrl: "/ibc.core.client.v1.QueryClientParamsResponse",
    encode(q, s = i.BinaryWriter.create()) {
      return q.params !== void 0 && t.Params.encode(q.params, s.uint32(10).fork()).ldelim(), s;
    },
    decode(q, s) {
      const u = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let A = s === void 0 ? u.len : u.pos + s;
      const R = J();
      for (; u.pos < A; ) {
        const v = u.uint32();
        switch (v >>> 3) {
          case 1:
            R.params = t.Params.decode(u, u.uint32());
            break;
          default:
            u.skipType(v & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      const s = J();
      return (0, f.isSet)(q.params) && (s.params = t.Params.fromJSON(q.params)), s;
    },
    toJSON(q) {
      const s = {};
      return q.params !== void 0 && (s.params = q.params ? t.Params.toJSON(q.params) : void 0), s;
    },
    fromPartial(q) {
      const s = J();
      return q.params !== void 0 && q.params !== null && (s.params = t.Params.fromPartial(q.params)), s;
    }
  };
  function _() {
    return {};
  }
  e.QueryUpgradedClientStateRequest = {
    typeUrl: "/ibc.core.client.v1.QueryUpgradedClientStateRequest",
    encode(q, s = i.BinaryWriter.create()) {
      return s;
    },
    decode(q, s) {
      const u = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let A = s === void 0 ? u.len : u.pos + s;
      const R = _();
      for (; u.pos < A; ) {
        const v = u.uint32();
        switch (v >>> 3) {
          default:
            u.skipType(v & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      return _();
    },
    toJSON(q) {
      return {};
    },
    fromPartial(q) {
      return _();
    }
  };
  function V() {
    return {
      upgradedClientState: void 0
    };
  }
  e.QueryUpgradedClientStateResponse = {
    typeUrl: "/ibc.core.client.v1.QueryUpgradedClientStateResponse",
    encode(q, s = i.BinaryWriter.create()) {
      return q.upgradedClientState !== void 0 && r.Any.encode(q.upgradedClientState, s.uint32(10).fork()).ldelim(), s;
    },
    decode(q, s) {
      const u = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let A = s === void 0 ? u.len : u.pos + s;
      const R = V();
      for (; u.pos < A; ) {
        const v = u.uint32();
        switch (v >>> 3) {
          case 1:
            R.upgradedClientState = r.Any.decode(u, u.uint32());
            break;
          default:
            u.skipType(v & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      const s = V();
      return (0, f.isSet)(q.upgradedClientState) && (s.upgradedClientState = r.Any.fromJSON(q.upgradedClientState)), s;
    },
    toJSON(q) {
      const s = {};
      return q.upgradedClientState !== void 0 && (s.upgradedClientState = q.upgradedClientState ? r.Any.toJSON(q.upgradedClientState) : void 0), s;
    },
    fromPartial(q) {
      const s = V();
      return q.upgradedClientState !== void 0 && q.upgradedClientState !== null && (s.upgradedClientState = r.Any.fromPartial(q.upgradedClientState)), s;
    }
  };
  function o() {
    return {};
  }
  e.QueryUpgradedConsensusStateRequest = {
    typeUrl: "/ibc.core.client.v1.QueryUpgradedConsensusStateRequest",
    encode(q, s = i.BinaryWriter.create()) {
      return s;
    },
    decode(q, s) {
      const u = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let A = s === void 0 ? u.len : u.pos + s;
      const R = o();
      for (; u.pos < A; ) {
        const v = u.uint32();
        switch (v >>> 3) {
          default:
            u.skipType(v & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      return o();
    },
    toJSON(q) {
      return {};
    },
    fromPartial(q) {
      return o();
    }
  };
  function p() {
    return {
      upgradedConsensusState: void 0
    };
  }
  e.QueryUpgradedConsensusStateResponse = {
    typeUrl: "/ibc.core.client.v1.QueryUpgradedConsensusStateResponse",
    encode(q, s = i.BinaryWriter.create()) {
      return q.upgradedConsensusState !== void 0 && r.Any.encode(q.upgradedConsensusState, s.uint32(10).fork()).ldelim(), s;
    },
    decode(q, s) {
      const u = q instanceof i.BinaryReader ? q : new i.BinaryReader(q);
      let A = s === void 0 ? u.len : u.pos + s;
      const R = p();
      for (; u.pos < A; ) {
        const v = u.uint32();
        switch (v >>> 3) {
          case 1:
            R.upgradedConsensusState = r.Any.decode(u, u.uint32());
            break;
          default:
            u.skipType(v & 7);
            break;
        }
      }
      return R;
    },
    fromJSON(q) {
      const s = p();
      return (0, f.isSet)(q.upgradedConsensusState) && (s.upgradedConsensusState = r.Any.fromJSON(q.upgradedConsensusState)), s;
    },
    toJSON(q) {
      const s = {};
      return q.upgradedConsensusState !== void 0 && (s.upgradedConsensusState = q.upgradedConsensusState ? r.Any.toJSON(q.upgradedConsensusState) : void 0), s;
    },
    fromPartial(q) {
      const s = p();
      return q.upgradedConsensusState !== void 0 && q.upgradedConsensusState !== null && (s.upgradedConsensusState = r.Any.fromPartial(q.upgradedConsensusState)), s;
    }
  };
  class I {
    constructor(s) {
      this.rpc = s, this.ClientState = this.ClientState.bind(this), this.ClientStates = this.ClientStates.bind(this), this.ConsensusState = this.ConsensusState.bind(this), this.ConsensusStates = this.ConsensusStates.bind(this), this.ConsensusStateHeights = this.ConsensusStateHeights.bind(this), this.ClientStatus = this.ClientStatus.bind(this), this.ClientParams = this.ClientParams.bind(this), this.UpgradedClientState = this.UpgradedClientState.bind(this), this.UpgradedConsensusState = this.UpgradedConsensusState.bind(this);
    }
    ClientState(s) {
      const u = e.QueryClientStateRequest.encode(s).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ClientState", u).then((R) => e.QueryClientStateResponse.decode(new i.BinaryReader(R)));
    }
    ClientStates(s = {
      pagination: n.PageRequest.fromPartial({})
    }) {
      const u = e.QueryClientStatesRequest.encode(s).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ClientStates", u).then((R) => e.QueryClientStatesResponse.decode(new i.BinaryReader(R)));
    }
    ConsensusState(s) {
      const u = e.QueryConsensusStateRequest.encode(s).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ConsensusState", u).then((R) => e.QueryConsensusStateResponse.decode(new i.BinaryReader(R)));
    }
    ConsensusStates(s) {
      const u = e.QueryConsensusStatesRequest.encode(s).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ConsensusStates", u).then((R) => e.QueryConsensusStatesResponse.decode(new i.BinaryReader(R)));
    }
    ConsensusStateHeights(s) {
      const u = e.QueryConsensusStateHeightsRequest.encode(s).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ConsensusStateHeights", u).then((R) => e.QueryConsensusStateHeightsResponse.decode(new i.BinaryReader(R)));
    }
    ClientStatus(s) {
      const u = e.QueryClientStatusRequest.encode(s).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ClientStatus", u).then((R) => e.QueryClientStatusResponse.decode(new i.BinaryReader(R)));
    }
    ClientParams(s = {}) {
      const u = e.QueryClientParamsRequest.encode(s).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "ClientParams", u).then((R) => e.QueryClientParamsResponse.decode(new i.BinaryReader(R)));
    }
    UpgradedClientState(s = {}) {
      const u = e.QueryUpgradedClientStateRequest.encode(s).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "UpgradedClientState", u).then((R) => e.QueryUpgradedClientStateResponse.decode(new i.BinaryReader(R)));
    }
    UpgradedConsensusState(s = {}) {
      const u = e.QueryUpgradedConsensusStateRequest.encode(s).finish();
      return this.rpc.request("ibc.core.client.v1.Query", "UpgradedConsensusState", u).then((R) => e.QueryUpgradedConsensusStateResponse.decode(new i.BinaryReader(R)));
    }
  }
  e.QueryClientImpl = I;
})(pl);
var hl = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryConnectionParamsResponse = e.QueryConnectionParamsRequest = e.QueryConnectionConsensusStateResponse = e.QueryConnectionConsensusStateRequest = e.QueryConnectionClientStateResponse = e.QueryConnectionClientStateRequest = e.QueryClientConnectionsResponse = e.QueryClientConnectionsRequest = e.QueryConnectionsResponse = e.QueryConnectionsRequest = e.QueryConnectionResponse = e.QueryConnectionRequest = e.protobufPackage = void 0;
  const n = Ae, r = Sd, t = Yn, i = Be, f = re, k = ie;
  e.protobufPackage = "ibc.core.connection.v1";
  function C() {
    return {
      connectionId: ""
    };
  }
  e.QueryConnectionRequest = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionRequest",
    encode(_, V = f.BinaryWriter.create()) {
      return _.connectionId !== "" && V.uint32(10).string(_.connectionId), V;
    },
    decode(_, V) {
      const o = _ instanceof f.BinaryReader ? _ : new f.BinaryReader(_);
      let p = V === void 0 ? o.len : o.pos + V;
      const I = C();
      for (; o.pos < p; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          case 1:
            I.connectionId = o.string();
            break;
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(_) {
      const V = C();
      return (0, k.isSet)(_.connectionId) && (V.connectionId = String(_.connectionId)), V;
    },
    toJSON(_) {
      const V = {};
      return _.connectionId !== void 0 && (V.connectionId = _.connectionId), V;
    },
    fromPartial(_) {
      const V = C();
      return V.connectionId = _.connectionId ?? "", V;
    }
  };
  function T() {
    return {
      connection: void 0,
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryConnectionResponse = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionResponse",
    encode(_, V = f.BinaryWriter.create()) {
      return _.connection !== void 0 && r.ConnectionEnd.encode(_.connection, V.uint32(10).fork()).ldelim(), _.proof.length !== 0 && V.uint32(18).bytes(_.proof), _.proofHeight !== void 0 && t.Height.encode(_.proofHeight, V.uint32(26).fork()).ldelim(), V;
    },
    decode(_, V) {
      const o = _ instanceof f.BinaryReader ? _ : new f.BinaryReader(_);
      let p = V === void 0 ? o.len : o.pos + V;
      const I = T();
      for (; o.pos < p; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          case 1:
            I.connection = r.ConnectionEnd.decode(o, o.uint32());
            break;
          case 2:
            I.proof = o.bytes();
            break;
          case 3:
            I.proofHeight = t.Height.decode(o, o.uint32());
            break;
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(_) {
      const V = T();
      return (0, k.isSet)(_.connection) && (V.connection = r.ConnectionEnd.fromJSON(_.connection)), (0, k.isSet)(_.proof) && (V.proof = (0, k.bytesFromBase64)(_.proof)), (0, k.isSet)(_.proofHeight) && (V.proofHeight = t.Height.fromJSON(_.proofHeight)), V;
    },
    toJSON(_) {
      const V = {};
      return _.connection !== void 0 && (V.connection = _.connection ? r.ConnectionEnd.toJSON(_.connection) : void 0), _.proof !== void 0 && (V.proof = (0, k.base64FromBytes)(_.proof !== void 0 ? _.proof : new Uint8Array())), _.proofHeight !== void 0 && (V.proofHeight = _.proofHeight ? t.Height.toJSON(_.proofHeight) : void 0), V;
    },
    fromPartial(_) {
      const V = T();
      return _.connection !== void 0 && _.connection !== null && (V.connection = r.ConnectionEnd.fromPartial(_.connection)), V.proof = _.proof ?? new Uint8Array(), _.proofHeight !== void 0 && _.proofHeight !== null && (V.proofHeight = t.Height.fromPartial(_.proofHeight)), V;
    }
  };
  function U() {
    return {
      pagination: void 0
    };
  }
  e.QueryConnectionsRequest = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionsRequest",
    encode(_, V = f.BinaryWriter.create()) {
      return _.pagination !== void 0 && n.PageRequest.encode(_.pagination, V.uint32(10).fork()).ldelim(), V;
    },
    decode(_, V) {
      const o = _ instanceof f.BinaryReader ? _ : new f.BinaryReader(_);
      let p = V === void 0 ? o.len : o.pos + V;
      const I = U();
      for (; o.pos < p; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          case 1:
            I.pagination = n.PageRequest.decode(o, o.uint32());
            break;
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(_) {
      const V = U();
      return (0, k.isSet)(_.pagination) && (V.pagination = n.PageRequest.fromJSON(_.pagination)), V;
    },
    toJSON(_) {
      const V = {};
      return _.pagination !== void 0 && (V.pagination = _.pagination ? n.PageRequest.toJSON(_.pagination) : void 0), V;
    },
    fromPartial(_) {
      const V = U();
      return _.pagination !== void 0 && _.pagination !== null && (V.pagination = n.PageRequest.fromPartial(_.pagination)), V;
    }
  };
  function w() {
    return {
      connections: [],
      pagination: void 0,
      height: t.Height.fromPartial({})
    };
  }
  e.QueryConnectionsResponse = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionsResponse",
    encode(_, V = f.BinaryWriter.create()) {
      for (const o of _.connections)
        r.IdentifiedConnection.encode(o, V.uint32(10).fork()).ldelim();
      return _.pagination !== void 0 && n.PageResponse.encode(_.pagination, V.uint32(18).fork()).ldelim(), _.height !== void 0 && t.Height.encode(_.height, V.uint32(26).fork()).ldelim(), V;
    },
    decode(_, V) {
      const o = _ instanceof f.BinaryReader ? _ : new f.BinaryReader(_);
      let p = V === void 0 ? o.len : o.pos + V;
      const I = w();
      for (; o.pos < p; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          case 1:
            I.connections.push(r.IdentifiedConnection.decode(o, o.uint32()));
            break;
          case 2:
            I.pagination = n.PageResponse.decode(o, o.uint32());
            break;
          case 3:
            I.height = t.Height.decode(o, o.uint32());
            break;
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(_) {
      const V = w();
      return Array.isArray(_ == null ? void 0 : _.connections) && (V.connections = _.connections.map((o) => r.IdentifiedConnection.fromJSON(o))), (0, k.isSet)(_.pagination) && (V.pagination = n.PageResponse.fromJSON(_.pagination)), (0, k.isSet)(_.height) && (V.height = t.Height.fromJSON(_.height)), V;
    },
    toJSON(_) {
      const V = {};
      return _.connections ? V.connections = _.connections.map((o) => o ? r.IdentifiedConnection.toJSON(o) : void 0) : V.connections = [], _.pagination !== void 0 && (V.pagination = _.pagination ? n.PageResponse.toJSON(_.pagination) : void 0), _.height !== void 0 && (V.height = _.height ? t.Height.toJSON(_.height) : void 0), V;
    },
    fromPartial(_) {
      var o;
      const V = w();
      return V.connections = ((o = _.connections) == null ? void 0 : o.map((p) => r.IdentifiedConnection.fromPartial(p))) || [], _.pagination !== void 0 && _.pagination !== null && (V.pagination = n.PageResponse.fromPartial(_.pagination)), _.height !== void 0 && _.height !== null && (V.height = t.Height.fromPartial(_.height)), V;
    }
  };
  function N() {
    return {
      clientId: ""
    };
  }
  e.QueryClientConnectionsRequest = {
    typeUrl: "/ibc.core.connection.v1.QueryClientConnectionsRequest",
    encode(_, V = f.BinaryWriter.create()) {
      return _.clientId !== "" && V.uint32(10).string(_.clientId), V;
    },
    decode(_, V) {
      const o = _ instanceof f.BinaryReader ? _ : new f.BinaryReader(_);
      let p = V === void 0 ? o.len : o.pos + V;
      const I = N();
      for (; o.pos < p; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          case 1:
            I.clientId = o.string();
            break;
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(_) {
      const V = N();
      return (0, k.isSet)(_.clientId) && (V.clientId = String(_.clientId)), V;
    },
    toJSON(_) {
      const V = {};
      return _.clientId !== void 0 && (V.clientId = _.clientId), V;
    },
    fromPartial(_) {
      const V = N();
      return V.clientId = _.clientId ?? "", V;
    }
  };
  function h() {
    return {
      connectionPaths: [],
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryClientConnectionsResponse = {
    typeUrl: "/ibc.core.connection.v1.QueryClientConnectionsResponse",
    encode(_, V = f.BinaryWriter.create()) {
      for (const o of _.connectionPaths)
        V.uint32(10).string(o);
      return _.proof.length !== 0 && V.uint32(18).bytes(_.proof), _.proofHeight !== void 0 && t.Height.encode(_.proofHeight, V.uint32(26).fork()).ldelim(), V;
    },
    decode(_, V) {
      const o = _ instanceof f.BinaryReader ? _ : new f.BinaryReader(_);
      let p = V === void 0 ? o.len : o.pos + V;
      const I = h();
      for (; o.pos < p; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          case 1:
            I.connectionPaths.push(o.string());
            break;
          case 2:
            I.proof = o.bytes();
            break;
          case 3:
            I.proofHeight = t.Height.decode(o, o.uint32());
            break;
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(_) {
      const V = h();
      return Array.isArray(_ == null ? void 0 : _.connectionPaths) && (V.connectionPaths = _.connectionPaths.map((o) => String(o))), (0, k.isSet)(_.proof) && (V.proof = (0, k.bytesFromBase64)(_.proof)), (0, k.isSet)(_.proofHeight) && (V.proofHeight = t.Height.fromJSON(_.proofHeight)), V;
    },
    toJSON(_) {
      const V = {};
      return _.connectionPaths ? V.connectionPaths = _.connectionPaths.map((o) => o) : V.connectionPaths = [], _.proof !== void 0 && (V.proof = (0, k.base64FromBytes)(_.proof !== void 0 ? _.proof : new Uint8Array())), _.proofHeight !== void 0 && (V.proofHeight = _.proofHeight ? t.Height.toJSON(_.proofHeight) : void 0), V;
    },
    fromPartial(_) {
      var o;
      const V = h();
      return V.connectionPaths = ((o = _.connectionPaths) == null ? void 0 : o.map((p) => p)) || [], V.proof = _.proof ?? new Uint8Array(), _.proofHeight !== void 0 && _.proofHeight !== null && (V.proofHeight = t.Height.fromPartial(_.proofHeight)), V;
    }
  };
  function P() {
    return {
      connectionId: ""
    };
  }
  e.QueryConnectionClientStateRequest = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionClientStateRequest",
    encode(_, V = f.BinaryWriter.create()) {
      return _.connectionId !== "" && V.uint32(10).string(_.connectionId), V;
    },
    decode(_, V) {
      const o = _ instanceof f.BinaryReader ? _ : new f.BinaryReader(_);
      let p = V === void 0 ? o.len : o.pos + V;
      const I = P();
      for (; o.pos < p; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          case 1:
            I.connectionId = o.string();
            break;
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(_) {
      const V = P();
      return (0, k.isSet)(_.connectionId) && (V.connectionId = String(_.connectionId)), V;
    },
    toJSON(_) {
      const V = {};
      return _.connectionId !== void 0 && (V.connectionId = _.connectionId), V;
    },
    fromPartial(_) {
      const V = P();
      return V.connectionId = _.connectionId ?? "", V;
    }
  };
  function b() {
    return {
      identifiedClientState: void 0,
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryConnectionClientStateResponse = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionClientStateResponse",
    encode(_, V = f.BinaryWriter.create()) {
      return _.identifiedClientState !== void 0 && t.IdentifiedClientState.encode(_.identifiedClientState, V.uint32(10).fork()).ldelim(), _.proof.length !== 0 && V.uint32(18).bytes(_.proof), _.proofHeight !== void 0 && t.Height.encode(_.proofHeight, V.uint32(26).fork()).ldelim(), V;
    },
    decode(_, V) {
      const o = _ instanceof f.BinaryReader ? _ : new f.BinaryReader(_);
      let p = V === void 0 ? o.len : o.pos + V;
      const I = b();
      for (; o.pos < p; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          case 1:
            I.identifiedClientState = t.IdentifiedClientState.decode(o, o.uint32());
            break;
          case 2:
            I.proof = o.bytes();
            break;
          case 3:
            I.proofHeight = t.Height.decode(o, o.uint32());
            break;
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(_) {
      const V = b();
      return (0, k.isSet)(_.identifiedClientState) && (V.identifiedClientState = t.IdentifiedClientState.fromJSON(_.identifiedClientState)), (0, k.isSet)(_.proof) && (V.proof = (0, k.bytesFromBase64)(_.proof)), (0, k.isSet)(_.proofHeight) && (V.proofHeight = t.Height.fromJSON(_.proofHeight)), V;
    },
    toJSON(_) {
      const V = {};
      return _.identifiedClientState !== void 0 && (V.identifiedClientState = _.identifiedClientState ? t.IdentifiedClientState.toJSON(_.identifiedClientState) : void 0), _.proof !== void 0 && (V.proof = (0, k.base64FromBytes)(_.proof !== void 0 ? _.proof : new Uint8Array())), _.proofHeight !== void 0 && (V.proofHeight = _.proofHeight ? t.Height.toJSON(_.proofHeight) : void 0), V;
    },
    fromPartial(_) {
      const V = b();
      return _.identifiedClientState !== void 0 && _.identifiedClientState !== null && (V.identifiedClientState = t.IdentifiedClientState.fromPartial(_.identifiedClientState)), V.proof = _.proof ?? new Uint8Array(), _.proofHeight !== void 0 && _.proofHeight !== null && (V.proofHeight = t.Height.fromPartial(_.proofHeight)), V;
    }
  };
  function c() {
    return {
      connectionId: "",
      revisionNumber: BigInt(0),
      revisionHeight: BigInt(0)
    };
  }
  e.QueryConnectionConsensusStateRequest = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionConsensusStateRequest",
    encode(_, V = f.BinaryWriter.create()) {
      return _.connectionId !== "" && V.uint32(10).string(_.connectionId), _.revisionNumber !== BigInt(0) && V.uint32(16).uint64(_.revisionNumber), _.revisionHeight !== BigInt(0) && V.uint32(24).uint64(_.revisionHeight), V;
    },
    decode(_, V) {
      const o = _ instanceof f.BinaryReader ? _ : new f.BinaryReader(_);
      let p = V === void 0 ? o.len : o.pos + V;
      const I = c();
      for (; o.pos < p; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          case 1:
            I.connectionId = o.string();
            break;
          case 2:
            I.revisionNumber = o.uint64();
            break;
          case 3:
            I.revisionHeight = o.uint64();
            break;
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(_) {
      const V = c();
      return (0, k.isSet)(_.connectionId) && (V.connectionId = String(_.connectionId)), (0, k.isSet)(_.revisionNumber) && (V.revisionNumber = BigInt(_.revisionNumber.toString())), (0, k.isSet)(_.revisionHeight) && (V.revisionHeight = BigInt(_.revisionHeight.toString())), V;
    },
    toJSON(_) {
      const V = {};
      return _.connectionId !== void 0 && (V.connectionId = _.connectionId), _.revisionNumber !== void 0 && (V.revisionNumber = (_.revisionNumber || BigInt(0)).toString()), _.revisionHeight !== void 0 && (V.revisionHeight = (_.revisionHeight || BigInt(0)).toString()), V;
    },
    fromPartial(_) {
      const V = c();
      return V.connectionId = _.connectionId ?? "", _.revisionNumber !== void 0 && _.revisionNumber !== null && (V.revisionNumber = BigInt(_.revisionNumber.toString())), _.revisionHeight !== void 0 && _.revisionHeight !== null && (V.revisionHeight = BigInt(_.revisionHeight.toString())), V;
    }
  };
  function l() {
    return {
      consensusState: void 0,
      clientId: "",
      proof: new Uint8Array(),
      proofHeight: t.Height.fromPartial({})
    };
  }
  e.QueryConnectionConsensusStateResponse = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionConsensusStateResponse",
    encode(_, V = f.BinaryWriter.create()) {
      return _.consensusState !== void 0 && i.Any.encode(_.consensusState, V.uint32(10).fork()).ldelim(), _.clientId !== "" && V.uint32(18).string(_.clientId), _.proof.length !== 0 && V.uint32(26).bytes(_.proof), _.proofHeight !== void 0 && t.Height.encode(_.proofHeight, V.uint32(34).fork()).ldelim(), V;
    },
    decode(_, V) {
      const o = _ instanceof f.BinaryReader ? _ : new f.BinaryReader(_);
      let p = V === void 0 ? o.len : o.pos + V;
      const I = l();
      for (; o.pos < p; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          case 1:
            I.consensusState = i.Any.decode(o, o.uint32());
            break;
          case 2:
            I.clientId = o.string();
            break;
          case 3:
            I.proof = o.bytes();
            break;
          case 4:
            I.proofHeight = t.Height.decode(o, o.uint32());
            break;
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(_) {
      const V = l();
      return (0, k.isSet)(_.consensusState) && (V.consensusState = i.Any.fromJSON(_.consensusState)), (0, k.isSet)(_.clientId) && (V.clientId = String(_.clientId)), (0, k.isSet)(_.proof) && (V.proof = (0, k.bytesFromBase64)(_.proof)), (0, k.isSet)(_.proofHeight) && (V.proofHeight = t.Height.fromJSON(_.proofHeight)), V;
    },
    toJSON(_) {
      const V = {};
      return _.consensusState !== void 0 && (V.consensusState = _.consensusState ? i.Any.toJSON(_.consensusState) : void 0), _.clientId !== void 0 && (V.clientId = _.clientId), _.proof !== void 0 && (V.proof = (0, k.base64FromBytes)(_.proof !== void 0 ? _.proof : new Uint8Array())), _.proofHeight !== void 0 && (V.proofHeight = _.proofHeight ? t.Height.toJSON(_.proofHeight) : void 0), V;
    },
    fromPartial(_) {
      const V = l();
      return _.consensusState !== void 0 && _.consensusState !== null && (V.consensusState = i.Any.fromPartial(_.consensusState)), V.clientId = _.clientId ?? "", V.proof = _.proof ?? new Uint8Array(), _.proofHeight !== void 0 && _.proofHeight !== null && (V.proofHeight = t.Height.fromPartial(_.proofHeight)), V;
    }
  };
  function y() {
    return {};
  }
  e.QueryConnectionParamsRequest = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionParamsRequest",
    encode(_, V = f.BinaryWriter.create()) {
      return V;
    },
    decode(_, V) {
      const o = _ instanceof f.BinaryReader ? _ : new f.BinaryReader(_);
      let p = V === void 0 ? o.len : o.pos + V;
      const I = y();
      for (; o.pos < p; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(_) {
      return y();
    },
    toJSON(_) {
      return {};
    },
    fromPartial(_) {
      return y();
    }
  };
  function E() {
    return {
      params: void 0
    };
  }
  e.QueryConnectionParamsResponse = {
    typeUrl: "/ibc.core.connection.v1.QueryConnectionParamsResponse",
    encode(_, V = f.BinaryWriter.create()) {
      return _.params !== void 0 && t.Params.encode(_.params, V.uint32(10).fork()).ldelim(), V;
    },
    decode(_, V) {
      const o = _ instanceof f.BinaryReader ? _ : new f.BinaryReader(_);
      let p = V === void 0 ? o.len : o.pos + V;
      const I = E();
      for (; o.pos < p; ) {
        const q = o.uint32();
        switch (q >>> 3) {
          case 1:
            I.params = t.Params.decode(o, o.uint32());
            break;
          default:
            o.skipType(q & 7);
            break;
        }
      }
      return I;
    },
    fromJSON(_) {
      const V = E();
      return (0, k.isSet)(_.params) && (V.params = t.Params.fromJSON(_.params)), V;
    },
    toJSON(_) {
      const V = {};
      return _.params !== void 0 && (V.params = _.params ? t.Params.toJSON(_.params) : void 0), V;
    },
    fromPartial(_) {
      const V = E();
      return _.params !== void 0 && _.params !== null && (V.params = t.Params.fromPartial(_.params)), V;
    }
  };
  class J {
    constructor(V) {
      this.rpc = V, this.Connection = this.Connection.bind(this), this.Connections = this.Connections.bind(this), this.ClientConnections = this.ClientConnections.bind(this), this.ConnectionClientState = this.ConnectionClientState.bind(this), this.ConnectionConsensusState = this.ConnectionConsensusState.bind(this), this.ConnectionParams = this.ConnectionParams.bind(this);
    }
    Connection(V) {
      const o = e.QueryConnectionRequest.encode(V).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "Connection", o).then((I) => e.QueryConnectionResponse.decode(new f.BinaryReader(I)));
    }
    Connections(V = {
      pagination: n.PageRequest.fromPartial({})
    }) {
      const o = e.QueryConnectionsRequest.encode(V).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "Connections", o).then((I) => e.QueryConnectionsResponse.decode(new f.BinaryReader(I)));
    }
    ClientConnections(V) {
      const o = e.QueryClientConnectionsRequest.encode(V).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "ClientConnections", o).then((I) => e.QueryClientConnectionsResponse.decode(new f.BinaryReader(I)));
    }
    ConnectionClientState(V) {
      const o = e.QueryConnectionClientStateRequest.encode(V).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "ConnectionClientState", o).then((I) => e.QueryConnectionClientStateResponse.decode(new f.BinaryReader(I)));
    }
    ConnectionConsensusState(V) {
      const o = e.QueryConnectionConsensusStateRequest.encode(V).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "ConnectionConsensusState", o).then((I) => e.QueryConnectionConsensusStateResponse.decode(new f.BinaryReader(I)));
    }
    ConnectionParams(V = {}) {
      const o = e.QueryConnectionParamsRequest.encode(V).finish();
      return this.rpc.request("ibc.core.connection.v1.Query", "ConnectionParams", o).then((I) => e.QueryConnectionParamsResponse.decode(new f.BinaryReader(I)));
    }
  }
  e.QueryClientImpl = J;
})(hl);
var yl = {}, _t = {}, Pd = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ProofOps = e.ProofOp = e.DominoOp = e.ValueOp = e.Proof = e.protobufPackage = void 0;
  const n = re, r = ie;
  e.protobufPackage = "tendermint.crypto";
  function t() {
    return {
      total: BigInt(0),
      index: BigInt(0),
      leafHash: new Uint8Array(),
      aunts: []
    };
  }
  e.Proof = {
    typeUrl: "/tendermint.crypto.Proof",
    encode(T, U = n.BinaryWriter.create()) {
      T.total !== BigInt(0) && U.uint32(8).int64(T.total), T.index !== BigInt(0) && U.uint32(16).int64(T.index), T.leafHash.length !== 0 && U.uint32(26).bytes(T.leafHash);
      for (const w of T.aunts)
        U.uint32(34).bytes(w);
      return U;
    },
    decode(T, U) {
      const w = T instanceof n.BinaryReader ? T : new n.BinaryReader(T);
      let N = U === void 0 ? w.len : w.pos + U;
      const h = t();
      for (; w.pos < N; ) {
        const P = w.uint32();
        switch (P >>> 3) {
          case 1:
            h.total = w.int64();
            break;
          case 2:
            h.index = w.int64();
            break;
          case 3:
            h.leafHash = w.bytes();
            break;
          case 4:
            h.aunts.push(w.bytes());
            break;
          default:
            w.skipType(P & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(T) {
      const U = t();
      return (0, r.isSet)(T.total) && (U.total = BigInt(T.total.toString())), (0, r.isSet)(T.index) && (U.index = BigInt(T.index.toString())), (0, r.isSet)(T.leafHash) && (U.leafHash = (0, r.bytesFromBase64)(T.leafHash)), Array.isArray(T == null ? void 0 : T.aunts) && (U.aunts = T.aunts.map((w) => (0, r.bytesFromBase64)(w))), U;
    },
    toJSON(T) {
      const U = {};
      return T.total !== void 0 && (U.total = (T.total || BigInt(0)).toString()), T.index !== void 0 && (U.index = (T.index || BigInt(0)).toString()), T.leafHash !== void 0 && (U.leafHash = (0, r.base64FromBytes)(T.leafHash !== void 0 ? T.leafHash : new Uint8Array())), T.aunts ? U.aunts = T.aunts.map((w) => (0, r.base64FromBytes)(w !== void 0 ? w : new Uint8Array())) : U.aunts = [], U;
    },
    fromPartial(T) {
      var w;
      const U = t();
      return T.total !== void 0 && T.total !== null && (U.total = BigInt(T.total.toString())), T.index !== void 0 && T.index !== null && (U.index = BigInt(T.index.toString())), U.leafHash = T.leafHash ?? new Uint8Array(), U.aunts = ((w = T.aunts) == null ? void 0 : w.map((N) => N)) || [], U;
    }
  };
  function i() {
    return {
      key: new Uint8Array(),
      proof: void 0
    };
  }
  e.ValueOp = {
    typeUrl: "/tendermint.crypto.ValueOp",
    encode(T, U = n.BinaryWriter.create()) {
      return T.key.length !== 0 && U.uint32(10).bytes(T.key), T.proof !== void 0 && e.Proof.encode(T.proof, U.uint32(18).fork()).ldelim(), U;
    },
    decode(T, U) {
      const w = T instanceof n.BinaryReader ? T : new n.BinaryReader(T);
      let N = U === void 0 ? w.len : w.pos + U;
      const h = i();
      for (; w.pos < N; ) {
        const P = w.uint32();
        switch (P >>> 3) {
          case 1:
            h.key = w.bytes();
            break;
          case 2:
            h.proof = e.Proof.decode(w, w.uint32());
            break;
          default:
            w.skipType(P & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(T) {
      const U = i();
      return (0, r.isSet)(T.key) && (U.key = (0, r.bytesFromBase64)(T.key)), (0, r.isSet)(T.proof) && (U.proof = e.Proof.fromJSON(T.proof)), U;
    },
    toJSON(T) {
      const U = {};
      return T.key !== void 0 && (U.key = (0, r.base64FromBytes)(T.key !== void 0 ? T.key : new Uint8Array())), T.proof !== void 0 && (U.proof = T.proof ? e.Proof.toJSON(T.proof) : void 0), U;
    },
    fromPartial(T) {
      const U = i();
      return U.key = T.key ?? new Uint8Array(), T.proof !== void 0 && T.proof !== null && (U.proof = e.Proof.fromPartial(T.proof)), U;
    }
  };
  function f() {
    return {
      key: "",
      input: "",
      output: ""
    };
  }
  e.DominoOp = {
    typeUrl: "/tendermint.crypto.DominoOp",
    encode(T, U = n.BinaryWriter.create()) {
      return T.key !== "" && U.uint32(10).string(T.key), T.input !== "" && U.uint32(18).string(T.input), T.output !== "" && U.uint32(26).string(T.output), U;
    },
    decode(T, U) {
      const w = T instanceof n.BinaryReader ? T : new n.BinaryReader(T);
      let N = U === void 0 ? w.len : w.pos + U;
      const h = f();
      for (; w.pos < N; ) {
        const P = w.uint32();
        switch (P >>> 3) {
          case 1:
            h.key = w.string();
            break;
          case 2:
            h.input = w.string();
            break;
          case 3:
            h.output = w.string();
            break;
          default:
            w.skipType(P & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(T) {
      const U = f();
      return (0, r.isSet)(T.key) && (U.key = String(T.key)), (0, r.isSet)(T.input) && (U.input = String(T.input)), (0, r.isSet)(T.output) && (U.output = String(T.output)), U;
    },
    toJSON(T) {
      const U = {};
      return T.key !== void 0 && (U.key = T.key), T.input !== void 0 && (U.input = T.input), T.output !== void 0 && (U.output = T.output), U;
    },
    fromPartial(T) {
      const U = f();
      return U.key = T.key ?? "", U.input = T.input ?? "", U.output = T.output ?? "", U;
    }
  };
  function k() {
    return {
      type: "",
      key: new Uint8Array(),
      data: new Uint8Array()
    };
  }
  e.ProofOp = {
    typeUrl: "/tendermint.crypto.ProofOp",
    encode(T, U = n.BinaryWriter.create()) {
      return T.type !== "" && U.uint32(10).string(T.type), T.key.length !== 0 && U.uint32(18).bytes(T.key), T.data.length !== 0 && U.uint32(26).bytes(T.data), U;
    },
    decode(T, U) {
      const w = T instanceof n.BinaryReader ? T : new n.BinaryReader(T);
      let N = U === void 0 ? w.len : w.pos + U;
      const h = k();
      for (; w.pos < N; ) {
        const P = w.uint32();
        switch (P >>> 3) {
          case 1:
            h.type = w.string();
            break;
          case 2:
            h.key = w.bytes();
            break;
          case 3:
            h.data = w.bytes();
            break;
          default:
            w.skipType(P & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(T) {
      const U = k();
      return (0, r.isSet)(T.type) && (U.type = String(T.type)), (0, r.isSet)(T.key) && (U.key = (0, r.bytesFromBase64)(T.key)), (0, r.isSet)(T.data) && (U.data = (0, r.bytesFromBase64)(T.data)), U;
    },
    toJSON(T) {
      const U = {};
      return T.type !== void 0 && (U.type = T.type), T.key !== void 0 && (U.key = (0, r.base64FromBytes)(T.key !== void 0 ? T.key : new Uint8Array())), T.data !== void 0 && (U.data = (0, r.base64FromBytes)(T.data !== void 0 ? T.data : new Uint8Array())), U;
    },
    fromPartial(T) {
      const U = k();
      return U.type = T.type ?? "", U.key = T.key ?? new Uint8Array(), U.data = T.data ?? new Uint8Array(), U;
    }
  };
  function C() {
    return {
      ops: []
    };
  }
  e.ProofOps = {
    typeUrl: "/tendermint.crypto.ProofOps",
    encode(T, U = n.BinaryWriter.create()) {
      for (const w of T.ops)
        e.ProofOp.encode(w, U.uint32(10).fork()).ldelim();
      return U;
    },
    decode(T, U) {
      const w = T instanceof n.BinaryReader ? T : new n.BinaryReader(T);
      let N = U === void 0 ? w.len : w.pos + U;
      const h = C();
      for (; w.pos < N; ) {
        const P = w.uint32();
        switch (P >>> 3) {
          case 1:
            h.ops.push(e.ProofOp.decode(w, w.uint32()));
            break;
          default:
            w.skipType(P & 7);
            break;
        }
      }
      return h;
    },
    fromJSON(T) {
      const U = C();
      return Array.isArray(T == null ? void 0 : T.ops) && (U.ops = T.ops.map((w) => e.ProofOp.fromJSON(w))), U;
    },
    toJSON(T) {
      const U = {};
      return T.ops ? U.ops = T.ops.map((w) => w ? e.ProofOp.toJSON(w) : void 0) : U.ops = [], U;
    },
    fromPartial(T) {
      var w;
      const U = C();
      return U.ops = ((w = T.ops) == null ? void 0 : w.map((N) => e.ProofOp.fromPartial(N))) || [], U;
    }
  };
})(Pd);
var ut = {};
Object.defineProperty(ut, "__esModule", { value: !0 });
ut.Consensus = ut.App = ut.protobufPackage = void 0;
const Zt = re, Qi = ie;
ut.protobufPackage = "tendermint.version";
function cs() {
  return {
    protocol: BigInt(0),
    software: ""
  };
}
ut.App = {
  typeUrl: "/tendermint.version.App",
  encode(e, n = Zt.BinaryWriter.create()) {
    return e.protocol !== BigInt(0) && n.uint32(8).uint64(e.protocol), e.software !== "" && n.uint32(18).string(e.software), n;
  },
  decode(e, n) {
    const r = e instanceof Zt.BinaryReader ? e : new Zt.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = cs();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.protocol = r.uint64();
          break;
        case 2:
          i.software = r.string();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = cs();
    return (0, Qi.isSet)(e.protocol) && (n.protocol = BigInt(e.protocol.toString())), (0, Qi.isSet)(e.software) && (n.software = String(e.software)), n;
  },
  toJSON(e) {
    const n = {};
    return e.protocol !== void 0 && (n.protocol = (e.protocol || BigInt(0)).toString()), e.software !== void 0 && (n.software = e.software), n;
  },
  fromPartial(e) {
    const n = cs();
    return e.protocol !== void 0 && e.protocol !== null && (n.protocol = BigInt(e.protocol.toString())), n.software = e.software ?? "", n;
  }
};
function ls() {
  return {
    block: BigInt(0),
    app: BigInt(0)
  };
}
ut.Consensus = {
  typeUrl: "/tendermint.version.Consensus",
  encode(e, n = Zt.BinaryWriter.create()) {
    return e.block !== BigInt(0) && n.uint32(8).uint64(e.block), e.app !== BigInt(0) && n.uint32(16).uint64(e.app), n;
  },
  decode(e, n) {
    const r = e instanceof Zt.BinaryReader ? e : new Zt.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = ls();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.block = r.uint64();
          break;
        case 2:
          i.app = r.uint64();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = ls();
    return (0, Qi.isSet)(e.block) && (n.block = BigInt(e.block.toString())), (0, Qi.isSet)(e.app) && (n.app = BigInt(e.app.toString())), n;
  },
  toJSON(e) {
    const n = {};
    return e.block !== void 0 && (n.block = (e.block || BigInt(0)).toString()), e.app !== void 0 && (n.app = (e.app || BigInt(0)).toString()), n;
  },
  fromPartial(e) {
    const n = ls();
    return e.block !== void 0 && e.block !== null && (n.block = BigInt(e.block.toString())), e.app !== void 0 && e.app !== null && (n.app = BigInt(e.app.toString())), n;
  }
};
var To = {}, At = {};
Object.defineProperty(At, "__esModule", { value: !0 });
At.PublicKey = At.protobufPackage = void 0;
const fs = re, Ht = ie;
At.protobufPackage = "tendermint.crypto";
function ps() {
  return {
    ed25519: void 0,
    secp256k1: void 0
  };
}
At.PublicKey = {
  typeUrl: "/tendermint.crypto.PublicKey",
  encode(e, n = fs.BinaryWriter.create()) {
    return e.ed25519 !== void 0 && n.uint32(10).bytes(e.ed25519), e.secp256k1 !== void 0 && n.uint32(18).bytes(e.secp256k1), n;
  },
  decode(e, n) {
    const r = e instanceof fs.BinaryReader ? e : new fs.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = ps();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.ed25519 = r.bytes();
          break;
        case 2:
          i.secp256k1 = r.bytes();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = ps();
    return (0, Ht.isSet)(e.ed25519) && (n.ed25519 = (0, Ht.bytesFromBase64)(e.ed25519)), (0, Ht.isSet)(e.secp256k1) && (n.secp256k1 = (0, Ht.bytesFromBase64)(e.secp256k1)), n;
  },
  toJSON(e) {
    const n = {};
    return e.ed25519 !== void 0 && (n.ed25519 = e.ed25519 !== void 0 ? (0, Ht.base64FromBytes)(e.ed25519) : void 0), e.secp256k1 !== void 0 && (n.secp256k1 = e.secp256k1 !== void 0 ? (0, Ht.base64FromBytes)(e.secp256k1) : void 0), n;
  },
  fromPartial(e) {
    const n = ps();
    return n.ed25519 = e.ed25519 ?? void 0, n.secp256k1 = e.secp256k1 ?? void 0, n;
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.SimpleValidator = e.Validator = e.ValidatorSet = e.protobufPackage = void 0;
  const n = At, r = re, t = ie;
  e.protobufPackage = "tendermint.types";
  function i() {
    return {
      validators: [],
      proposer: void 0,
      totalVotingPower: BigInt(0)
    };
  }
  e.ValidatorSet = {
    typeUrl: "/tendermint.types.ValidatorSet",
    encode(C, T = r.BinaryWriter.create()) {
      for (const U of C.validators)
        e.Validator.encode(U, T.uint32(10).fork()).ldelim();
      return C.proposer !== void 0 && e.Validator.encode(C.proposer, T.uint32(18).fork()).ldelim(), C.totalVotingPower !== BigInt(0) && T.uint32(24).int64(C.totalVotingPower), T;
    },
    decode(C, T) {
      const U = C instanceof r.BinaryReader ? C : new r.BinaryReader(C);
      let w = T === void 0 ? U.len : U.pos + T;
      const N = i();
      for (; U.pos < w; ) {
        const h = U.uint32();
        switch (h >>> 3) {
          case 1:
            N.validators.push(e.Validator.decode(U, U.uint32()));
            break;
          case 2:
            N.proposer = e.Validator.decode(U, U.uint32());
            break;
          case 3:
            N.totalVotingPower = U.int64();
            break;
          default:
            U.skipType(h & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(C) {
      const T = i();
      return Array.isArray(C == null ? void 0 : C.validators) && (T.validators = C.validators.map((U) => e.Validator.fromJSON(U))), (0, t.isSet)(C.proposer) && (T.proposer = e.Validator.fromJSON(C.proposer)), (0, t.isSet)(C.totalVotingPower) && (T.totalVotingPower = BigInt(C.totalVotingPower.toString())), T;
    },
    toJSON(C) {
      const T = {};
      return C.validators ? T.validators = C.validators.map((U) => U ? e.Validator.toJSON(U) : void 0) : T.validators = [], C.proposer !== void 0 && (T.proposer = C.proposer ? e.Validator.toJSON(C.proposer) : void 0), C.totalVotingPower !== void 0 && (T.totalVotingPower = (C.totalVotingPower || BigInt(0)).toString()), T;
    },
    fromPartial(C) {
      var U;
      const T = i();
      return T.validators = ((U = C.validators) == null ? void 0 : U.map((w) => e.Validator.fromPartial(w))) || [], C.proposer !== void 0 && C.proposer !== null && (T.proposer = e.Validator.fromPartial(C.proposer)), C.totalVotingPower !== void 0 && C.totalVotingPower !== null && (T.totalVotingPower = BigInt(C.totalVotingPower.toString())), T;
    }
  };
  function f() {
    return {
      address: new Uint8Array(),
      pubKey: n.PublicKey.fromPartial({}),
      votingPower: BigInt(0),
      proposerPriority: BigInt(0)
    };
  }
  e.Validator = {
    typeUrl: "/tendermint.types.Validator",
    encode(C, T = r.BinaryWriter.create()) {
      return C.address.length !== 0 && T.uint32(10).bytes(C.address), C.pubKey !== void 0 && n.PublicKey.encode(C.pubKey, T.uint32(18).fork()).ldelim(), C.votingPower !== BigInt(0) && T.uint32(24).int64(C.votingPower), C.proposerPriority !== BigInt(0) && T.uint32(32).int64(C.proposerPriority), T;
    },
    decode(C, T) {
      const U = C instanceof r.BinaryReader ? C : new r.BinaryReader(C);
      let w = T === void 0 ? U.len : U.pos + T;
      const N = f();
      for (; U.pos < w; ) {
        const h = U.uint32();
        switch (h >>> 3) {
          case 1:
            N.address = U.bytes();
            break;
          case 2:
            N.pubKey = n.PublicKey.decode(U, U.uint32());
            break;
          case 3:
            N.votingPower = U.int64();
            break;
          case 4:
            N.proposerPriority = U.int64();
            break;
          default:
            U.skipType(h & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(C) {
      const T = f();
      return (0, t.isSet)(C.address) && (T.address = (0, t.bytesFromBase64)(C.address)), (0, t.isSet)(C.pubKey) && (T.pubKey = n.PublicKey.fromJSON(C.pubKey)), (0, t.isSet)(C.votingPower) && (T.votingPower = BigInt(C.votingPower.toString())), (0, t.isSet)(C.proposerPriority) && (T.proposerPriority = BigInt(C.proposerPriority.toString())), T;
    },
    toJSON(C) {
      const T = {};
      return C.address !== void 0 && (T.address = (0, t.base64FromBytes)(C.address !== void 0 ? C.address : new Uint8Array())), C.pubKey !== void 0 && (T.pubKey = C.pubKey ? n.PublicKey.toJSON(C.pubKey) : void 0), C.votingPower !== void 0 && (T.votingPower = (C.votingPower || BigInt(0)).toString()), C.proposerPriority !== void 0 && (T.proposerPriority = (C.proposerPriority || BigInt(0)).toString()), T;
    },
    fromPartial(C) {
      const T = f();
      return T.address = C.address ?? new Uint8Array(), C.pubKey !== void 0 && C.pubKey !== null && (T.pubKey = n.PublicKey.fromPartial(C.pubKey)), C.votingPower !== void 0 && C.votingPower !== null && (T.votingPower = BigInt(C.votingPower.toString())), C.proposerPriority !== void 0 && C.proposerPriority !== null && (T.proposerPriority = BigInt(C.proposerPriority.toString())), T;
    }
  };
  function k() {
    return {
      pubKey: void 0,
      votingPower: BigInt(0)
    };
  }
  e.SimpleValidator = {
    typeUrl: "/tendermint.types.SimpleValidator",
    encode(C, T = r.BinaryWriter.create()) {
      return C.pubKey !== void 0 && n.PublicKey.encode(C.pubKey, T.uint32(10).fork()).ldelim(), C.votingPower !== BigInt(0) && T.uint32(16).int64(C.votingPower), T;
    },
    decode(C, T) {
      const U = C instanceof r.BinaryReader ? C : new r.BinaryReader(C);
      let w = T === void 0 ? U.len : U.pos + T;
      const N = k();
      for (; U.pos < w; ) {
        const h = U.uint32();
        switch (h >>> 3) {
          case 1:
            N.pubKey = n.PublicKey.decode(U, U.uint32());
            break;
          case 2:
            N.votingPower = U.int64();
            break;
          default:
            U.skipType(h & 7);
            break;
        }
      }
      return N;
    },
    fromJSON(C) {
      const T = k();
      return (0, t.isSet)(C.pubKey) && (T.pubKey = n.PublicKey.fromJSON(C.pubKey)), (0, t.isSet)(C.votingPower) && (T.votingPower = BigInt(C.votingPower.toString())), T;
    },
    toJSON(C) {
      const T = {};
      return C.pubKey !== void 0 && (T.pubKey = C.pubKey ? n.PublicKey.toJSON(C.pubKey) : void 0), C.votingPower !== void 0 && (T.votingPower = (C.votingPower || BigInt(0)).toString()), T;
    },
    fromPartial(C) {
      const T = k();
      return C.pubKey !== void 0 && C.pubKey !== null && (T.pubKey = n.PublicKey.fromPartial(C.pubKey)), C.votingPower !== void 0 && C.votingPower !== null && (T.votingPower = BigInt(C.votingPower.toString())), T;
    }
  };
})(To);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.TxProof = e.BlockMeta = e.LightBlock = e.SignedHeader = e.Proposal = e.CommitSig = e.Commit = e.Vote = e.Data = e.Header = e.BlockID = e.Part = e.PartSetHeader = e.signedMsgTypeToJSON = e.signedMsgTypeFromJSON = e.SignedMsgType = e.blockIDFlagToJSON = e.blockIDFlagFromJSON = e.BlockIDFlag = e.protobufPackage = void 0;
  const n = Pd, r = ut, t = _e, i = To, f = re, k = ie;
  e.protobufPackage = "tendermint.types";
  var C;
  (function(s) {
    s[s.BLOCK_ID_FLAG_UNKNOWN = 0] = "BLOCK_ID_FLAG_UNKNOWN", s[s.BLOCK_ID_FLAG_ABSENT = 1] = "BLOCK_ID_FLAG_ABSENT", s[s.BLOCK_ID_FLAG_COMMIT = 2] = "BLOCK_ID_FLAG_COMMIT", s[s.BLOCK_ID_FLAG_NIL = 3] = "BLOCK_ID_FLAG_NIL", s[s.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(C || (e.BlockIDFlag = C = {}));
  function T(s) {
    switch (s) {
      case 0:
      case "BLOCK_ID_FLAG_UNKNOWN":
        return C.BLOCK_ID_FLAG_UNKNOWN;
      case 1:
      case "BLOCK_ID_FLAG_ABSENT":
        return C.BLOCK_ID_FLAG_ABSENT;
      case 2:
      case "BLOCK_ID_FLAG_COMMIT":
        return C.BLOCK_ID_FLAG_COMMIT;
      case 3:
      case "BLOCK_ID_FLAG_NIL":
        return C.BLOCK_ID_FLAG_NIL;
      case -1:
      case "UNRECOGNIZED":
      default:
        return C.UNRECOGNIZED;
    }
  }
  e.blockIDFlagFromJSON = T;
  function U(s) {
    switch (s) {
      case C.BLOCK_ID_FLAG_UNKNOWN:
        return "BLOCK_ID_FLAG_UNKNOWN";
      case C.BLOCK_ID_FLAG_ABSENT:
        return "BLOCK_ID_FLAG_ABSENT";
      case C.BLOCK_ID_FLAG_COMMIT:
        return "BLOCK_ID_FLAG_COMMIT";
      case C.BLOCK_ID_FLAG_NIL:
        return "BLOCK_ID_FLAG_NIL";
      case C.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.blockIDFlagToJSON = U;
  var w;
  (function(s) {
    s[s.SIGNED_MSG_TYPE_UNKNOWN = 0] = "SIGNED_MSG_TYPE_UNKNOWN", s[s.SIGNED_MSG_TYPE_PREVOTE = 1] = "SIGNED_MSG_TYPE_PREVOTE", s[s.SIGNED_MSG_TYPE_PRECOMMIT = 2] = "SIGNED_MSG_TYPE_PRECOMMIT", s[s.SIGNED_MSG_TYPE_PROPOSAL = 32] = "SIGNED_MSG_TYPE_PROPOSAL", s[s.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(w || (e.SignedMsgType = w = {}));
  function N(s) {
    switch (s) {
      case 0:
      case "SIGNED_MSG_TYPE_UNKNOWN":
        return w.SIGNED_MSG_TYPE_UNKNOWN;
      case 1:
      case "SIGNED_MSG_TYPE_PREVOTE":
        return w.SIGNED_MSG_TYPE_PREVOTE;
      case 2:
      case "SIGNED_MSG_TYPE_PRECOMMIT":
        return w.SIGNED_MSG_TYPE_PRECOMMIT;
      case 32:
      case "SIGNED_MSG_TYPE_PROPOSAL":
        return w.SIGNED_MSG_TYPE_PROPOSAL;
      case -1:
      case "UNRECOGNIZED":
      default:
        return w.UNRECOGNIZED;
    }
  }
  e.signedMsgTypeFromJSON = N;
  function h(s) {
    switch (s) {
      case w.SIGNED_MSG_TYPE_UNKNOWN:
        return "SIGNED_MSG_TYPE_UNKNOWN";
      case w.SIGNED_MSG_TYPE_PREVOTE:
        return "SIGNED_MSG_TYPE_PREVOTE";
      case w.SIGNED_MSG_TYPE_PRECOMMIT:
        return "SIGNED_MSG_TYPE_PRECOMMIT";
      case w.SIGNED_MSG_TYPE_PROPOSAL:
        return "SIGNED_MSG_TYPE_PROPOSAL";
      case w.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.signedMsgTypeToJSON = h;
  function P() {
    return {
      total: 0,
      hash: new Uint8Array()
    };
  }
  e.PartSetHeader = {
    typeUrl: "/tendermint.types.PartSetHeader",
    encode(s, u = f.BinaryWriter.create()) {
      return s.total !== 0 && u.uint32(8).uint32(s.total), s.hash.length !== 0 && u.uint32(18).bytes(s.hash), u;
    },
    decode(s, u) {
      const A = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = P();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.total = A.uint32();
            break;
          case 2:
            v.hash = A.bytes();
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = P();
      return (0, k.isSet)(s.total) && (u.total = Number(s.total)), (0, k.isSet)(s.hash) && (u.hash = (0, k.bytesFromBase64)(s.hash)), u;
    },
    toJSON(s) {
      const u = {};
      return s.total !== void 0 && (u.total = Math.round(s.total)), s.hash !== void 0 && (u.hash = (0, k.base64FromBytes)(s.hash !== void 0 ? s.hash : new Uint8Array())), u;
    },
    fromPartial(s) {
      const u = P();
      return u.total = s.total ?? 0, u.hash = s.hash ?? new Uint8Array(), u;
    }
  };
  function b() {
    return {
      index: 0,
      bytes: new Uint8Array(),
      proof: n.Proof.fromPartial({})
    };
  }
  e.Part = {
    typeUrl: "/tendermint.types.Part",
    encode(s, u = f.BinaryWriter.create()) {
      return s.index !== 0 && u.uint32(8).uint32(s.index), s.bytes.length !== 0 && u.uint32(18).bytes(s.bytes), s.proof !== void 0 && n.Proof.encode(s.proof, u.uint32(26).fork()).ldelim(), u;
    },
    decode(s, u) {
      const A = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = b();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.index = A.uint32();
            break;
          case 2:
            v.bytes = A.bytes();
            break;
          case 3:
            v.proof = n.Proof.decode(A, A.uint32());
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = b();
      return (0, k.isSet)(s.index) && (u.index = Number(s.index)), (0, k.isSet)(s.bytes) && (u.bytes = (0, k.bytesFromBase64)(s.bytes)), (0, k.isSet)(s.proof) && (u.proof = n.Proof.fromJSON(s.proof)), u;
    },
    toJSON(s) {
      const u = {};
      return s.index !== void 0 && (u.index = Math.round(s.index)), s.bytes !== void 0 && (u.bytes = (0, k.base64FromBytes)(s.bytes !== void 0 ? s.bytes : new Uint8Array())), s.proof !== void 0 && (u.proof = s.proof ? n.Proof.toJSON(s.proof) : void 0), u;
    },
    fromPartial(s) {
      const u = b();
      return u.index = s.index ?? 0, u.bytes = s.bytes ?? new Uint8Array(), s.proof !== void 0 && s.proof !== null && (u.proof = n.Proof.fromPartial(s.proof)), u;
    }
  };
  function c() {
    return {
      hash: new Uint8Array(),
      partSetHeader: e.PartSetHeader.fromPartial({})
    };
  }
  e.BlockID = {
    typeUrl: "/tendermint.types.BlockID",
    encode(s, u = f.BinaryWriter.create()) {
      return s.hash.length !== 0 && u.uint32(10).bytes(s.hash), s.partSetHeader !== void 0 && e.PartSetHeader.encode(s.partSetHeader, u.uint32(18).fork()).ldelim(), u;
    },
    decode(s, u) {
      const A = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = c();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.hash = A.bytes();
            break;
          case 2:
            v.partSetHeader = e.PartSetHeader.decode(A, A.uint32());
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = c();
      return (0, k.isSet)(s.hash) && (u.hash = (0, k.bytesFromBase64)(s.hash)), (0, k.isSet)(s.partSetHeader) && (u.partSetHeader = e.PartSetHeader.fromJSON(s.partSetHeader)), u;
    },
    toJSON(s) {
      const u = {};
      return s.hash !== void 0 && (u.hash = (0, k.base64FromBytes)(s.hash !== void 0 ? s.hash : new Uint8Array())), s.partSetHeader !== void 0 && (u.partSetHeader = s.partSetHeader ? e.PartSetHeader.toJSON(s.partSetHeader) : void 0), u;
    },
    fromPartial(s) {
      const u = c();
      return u.hash = s.hash ?? new Uint8Array(), s.partSetHeader !== void 0 && s.partSetHeader !== null && (u.partSetHeader = e.PartSetHeader.fromPartial(s.partSetHeader)), u;
    }
  };
  function l() {
    return {
      version: r.Consensus.fromPartial({}),
      chainId: "",
      height: BigInt(0),
      time: t.Timestamp.fromPartial({}),
      lastBlockId: e.BlockID.fromPartial({}),
      lastCommitHash: new Uint8Array(),
      dataHash: new Uint8Array(),
      validatorsHash: new Uint8Array(),
      nextValidatorsHash: new Uint8Array(),
      consensusHash: new Uint8Array(),
      appHash: new Uint8Array(),
      lastResultsHash: new Uint8Array(),
      evidenceHash: new Uint8Array(),
      proposerAddress: new Uint8Array()
    };
  }
  e.Header = {
    typeUrl: "/tendermint.types.Header",
    encode(s, u = f.BinaryWriter.create()) {
      return s.version !== void 0 && r.Consensus.encode(s.version, u.uint32(10).fork()).ldelim(), s.chainId !== "" && u.uint32(18).string(s.chainId), s.height !== BigInt(0) && u.uint32(24).int64(s.height), s.time !== void 0 && t.Timestamp.encode(s.time, u.uint32(34).fork()).ldelim(), s.lastBlockId !== void 0 && e.BlockID.encode(s.lastBlockId, u.uint32(42).fork()).ldelim(), s.lastCommitHash.length !== 0 && u.uint32(50).bytes(s.lastCommitHash), s.dataHash.length !== 0 && u.uint32(58).bytes(s.dataHash), s.validatorsHash.length !== 0 && u.uint32(66).bytes(s.validatorsHash), s.nextValidatorsHash.length !== 0 && u.uint32(74).bytes(s.nextValidatorsHash), s.consensusHash.length !== 0 && u.uint32(82).bytes(s.consensusHash), s.appHash.length !== 0 && u.uint32(90).bytes(s.appHash), s.lastResultsHash.length !== 0 && u.uint32(98).bytes(s.lastResultsHash), s.evidenceHash.length !== 0 && u.uint32(106).bytes(s.evidenceHash), s.proposerAddress.length !== 0 && u.uint32(114).bytes(s.proposerAddress), u;
    },
    decode(s, u) {
      const A = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = l();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.version = r.Consensus.decode(A, A.uint32());
            break;
          case 2:
            v.chainId = A.string();
            break;
          case 3:
            v.height = A.int64();
            break;
          case 4:
            v.time = t.Timestamp.decode(A, A.uint32());
            break;
          case 5:
            v.lastBlockId = e.BlockID.decode(A, A.uint32());
            break;
          case 6:
            v.lastCommitHash = A.bytes();
            break;
          case 7:
            v.dataHash = A.bytes();
            break;
          case 8:
            v.validatorsHash = A.bytes();
            break;
          case 9:
            v.nextValidatorsHash = A.bytes();
            break;
          case 10:
            v.consensusHash = A.bytes();
            break;
          case 11:
            v.appHash = A.bytes();
            break;
          case 12:
            v.lastResultsHash = A.bytes();
            break;
          case 13:
            v.evidenceHash = A.bytes();
            break;
          case 14:
            v.proposerAddress = A.bytes();
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = l();
      return (0, k.isSet)(s.version) && (u.version = r.Consensus.fromJSON(s.version)), (0, k.isSet)(s.chainId) && (u.chainId = String(s.chainId)), (0, k.isSet)(s.height) && (u.height = BigInt(s.height.toString())), (0, k.isSet)(s.time) && (u.time = (0, k.fromJsonTimestamp)(s.time)), (0, k.isSet)(s.lastBlockId) && (u.lastBlockId = e.BlockID.fromJSON(s.lastBlockId)), (0, k.isSet)(s.lastCommitHash) && (u.lastCommitHash = (0, k.bytesFromBase64)(s.lastCommitHash)), (0, k.isSet)(s.dataHash) && (u.dataHash = (0, k.bytesFromBase64)(s.dataHash)), (0, k.isSet)(s.validatorsHash) && (u.validatorsHash = (0, k.bytesFromBase64)(s.validatorsHash)), (0, k.isSet)(s.nextValidatorsHash) && (u.nextValidatorsHash = (0, k.bytesFromBase64)(s.nextValidatorsHash)), (0, k.isSet)(s.consensusHash) && (u.consensusHash = (0, k.bytesFromBase64)(s.consensusHash)), (0, k.isSet)(s.appHash) && (u.appHash = (0, k.bytesFromBase64)(s.appHash)), (0, k.isSet)(s.lastResultsHash) && (u.lastResultsHash = (0, k.bytesFromBase64)(s.lastResultsHash)), (0, k.isSet)(s.evidenceHash) && (u.evidenceHash = (0, k.bytesFromBase64)(s.evidenceHash)), (0, k.isSet)(s.proposerAddress) && (u.proposerAddress = (0, k.bytesFromBase64)(s.proposerAddress)), u;
    },
    toJSON(s) {
      const u = {};
      return s.version !== void 0 && (u.version = s.version ? r.Consensus.toJSON(s.version) : void 0), s.chainId !== void 0 && (u.chainId = s.chainId), s.height !== void 0 && (u.height = (s.height || BigInt(0)).toString()), s.time !== void 0 && (u.time = (0, k.fromTimestamp)(s.time).toISOString()), s.lastBlockId !== void 0 && (u.lastBlockId = s.lastBlockId ? e.BlockID.toJSON(s.lastBlockId) : void 0), s.lastCommitHash !== void 0 && (u.lastCommitHash = (0, k.base64FromBytes)(s.lastCommitHash !== void 0 ? s.lastCommitHash : new Uint8Array())), s.dataHash !== void 0 && (u.dataHash = (0, k.base64FromBytes)(s.dataHash !== void 0 ? s.dataHash : new Uint8Array())), s.validatorsHash !== void 0 && (u.validatorsHash = (0, k.base64FromBytes)(s.validatorsHash !== void 0 ? s.validatorsHash : new Uint8Array())), s.nextValidatorsHash !== void 0 && (u.nextValidatorsHash = (0, k.base64FromBytes)(s.nextValidatorsHash !== void 0 ? s.nextValidatorsHash : new Uint8Array())), s.consensusHash !== void 0 && (u.consensusHash = (0, k.base64FromBytes)(s.consensusHash !== void 0 ? s.consensusHash : new Uint8Array())), s.appHash !== void 0 && (u.appHash = (0, k.base64FromBytes)(s.appHash !== void 0 ? s.appHash : new Uint8Array())), s.lastResultsHash !== void 0 && (u.lastResultsHash = (0, k.base64FromBytes)(s.lastResultsHash !== void 0 ? s.lastResultsHash : new Uint8Array())), s.evidenceHash !== void 0 && (u.evidenceHash = (0, k.base64FromBytes)(s.evidenceHash !== void 0 ? s.evidenceHash : new Uint8Array())), s.proposerAddress !== void 0 && (u.proposerAddress = (0, k.base64FromBytes)(s.proposerAddress !== void 0 ? s.proposerAddress : new Uint8Array())), u;
    },
    fromPartial(s) {
      const u = l();
      return s.version !== void 0 && s.version !== null && (u.version = r.Consensus.fromPartial(s.version)), u.chainId = s.chainId ?? "", s.height !== void 0 && s.height !== null && (u.height = BigInt(s.height.toString())), s.time !== void 0 && s.time !== null && (u.time = t.Timestamp.fromPartial(s.time)), s.lastBlockId !== void 0 && s.lastBlockId !== null && (u.lastBlockId = e.BlockID.fromPartial(s.lastBlockId)), u.lastCommitHash = s.lastCommitHash ?? new Uint8Array(), u.dataHash = s.dataHash ?? new Uint8Array(), u.validatorsHash = s.validatorsHash ?? new Uint8Array(), u.nextValidatorsHash = s.nextValidatorsHash ?? new Uint8Array(), u.consensusHash = s.consensusHash ?? new Uint8Array(), u.appHash = s.appHash ?? new Uint8Array(), u.lastResultsHash = s.lastResultsHash ?? new Uint8Array(), u.evidenceHash = s.evidenceHash ?? new Uint8Array(), u.proposerAddress = s.proposerAddress ?? new Uint8Array(), u;
    }
  };
  function y() {
    return {
      txs: []
    };
  }
  e.Data = {
    typeUrl: "/tendermint.types.Data",
    encode(s, u = f.BinaryWriter.create()) {
      for (const A of s.txs)
        u.uint32(10).bytes(A);
      return u;
    },
    decode(s, u) {
      const A = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = y();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.txs.push(A.bytes());
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = y();
      return Array.isArray(s == null ? void 0 : s.txs) && (u.txs = s.txs.map((A) => (0, k.bytesFromBase64)(A))), u;
    },
    toJSON(s) {
      const u = {};
      return s.txs ? u.txs = s.txs.map((A) => (0, k.base64FromBytes)(A !== void 0 ? A : new Uint8Array())) : u.txs = [], u;
    },
    fromPartial(s) {
      var A;
      const u = y();
      return u.txs = ((A = s.txs) == null ? void 0 : A.map((R) => R)) || [], u;
    }
  };
  function E() {
    return {
      type: 0,
      height: BigInt(0),
      round: 0,
      blockId: e.BlockID.fromPartial({}),
      timestamp: t.Timestamp.fromPartial({}),
      validatorAddress: new Uint8Array(),
      validatorIndex: 0,
      signature: new Uint8Array()
    };
  }
  e.Vote = {
    typeUrl: "/tendermint.types.Vote",
    encode(s, u = f.BinaryWriter.create()) {
      return s.type !== 0 && u.uint32(8).int32(s.type), s.height !== BigInt(0) && u.uint32(16).int64(s.height), s.round !== 0 && u.uint32(24).int32(s.round), s.blockId !== void 0 && e.BlockID.encode(s.blockId, u.uint32(34).fork()).ldelim(), s.timestamp !== void 0 && t.Timestamp.encode(s.timestamp, u.uint32(42).fork()).ldelim(), s.validatorAddress.length !== 0 && u.uint32(50).bytes(s.validatorAddress), s.validatorIndex !== 0 && u.uint32(56).int32(s.validatorIndex), s.signature.length !== 0 && u.uint32(66).bytes(s.signature), u;
    },
    decode(s, u) {
      const A = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = E();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.type = A.int32();
            break;
          case 2:
            v.height = A.int64();
            break;
          case 3:
            v.round = A.int32();
            break;
          case 4:
            v.blockId = e.BlockID.decode(A, A.uint32());
            break;
          case 5:
            v.timestamp = t.Timestamp.decode(A, A.uint32());
            break;
          case 6:
            v.validatorAddress = A.bytes();
            break;
          case 7:
            v.validatorIndex = A.int32();
            break;
          case 8:
            v.signature = A.bytes();
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = E();
      return (0, k.isSet)(s.type) && (u.type = N(s.type)), (0, k.isSet)(s.height) && (u.height = BigInt(s.height.toString())), (0, k.isSet)(s.round) && (u.round = Number(s.round)), (0, k.isSet)(s.blockId) && (u.blockId = e.BlockID.fromJSON(s.blockId)), (0, k.isSet)(s.timestamp) && (u.timestamp = (0, k.fromJsonTimestamp)(s.timestamp)), (0, k.isSet)(s.validatorAddress) && (u.validatorAddress = (0, k.bytesFromBase64)(s.validatorAddress)), (0, k.isSet)(s.validatorIndex) && (u.validatorIndex = Number(s.validatorIndex)), (0, k.isSet)(s.signature) && (u.signature = (0, k.bytesFromBase64)(s.signature)), u;
    },
    toJSON(s) {
      const u = {};
      return s.type !== void 0 && (u.type = h(s.type)), s.height !== void 0 && (u.height = (s.height || BigInt(0)).toString()), s.round !== void 0 && (u.round = Math.round(s.round)), s.blockId !== void 0 && (u.blockId = s.blockId ? e.BlockID.toJSON(s.blockId) : void 0), s.timestamp !== void 0 && (u.timestamp = (0, k.fromTimestamp)(s.timestamp).toISOString()), s.validatorAddress !== void 0 && (u.validatorAddress = (0, k.base64FromBytes)(s.validatorAddress !== void 0 ? s.validatorAddress : new Uint8Array())), s.validatorIndex !== void 0 && (u.validatorIndex = Math.round(s.validatorIndex)), s.signature !== void 0 && (u.signature = (0, k.base64FromBytes)(s.signature !== void 0 ? s.signature : new Uint8Array())), u;
    },
    fromPartial(s) {
      const u = E();
      return u.type = s.type ?? 0, s.height !== void 0 && s.height !== null && (u.height = BigInt(s.height.toString())), u.round = s.round ?? 0, s.blockId !== void 0 && s.blockId !== null && (u.blockId = e.BlockID.fromPartial(s.blockId)), s.timestamp !== void 0 && s.timestamp !== null && (u.timestamp = t.Timestamp.fromPartial(s.timestamp)), u.validatorAddress = s.validatorAddress ?? new Uint8Array(), u.validatorIndex = s.validatorIndex ?? 0, u.signature = s.signature ?? new Uint8Array(), u;
    }
  };
  function J() {
    return {
      height: BigInt(0),
      round: 0,
      blockId: e.BlockID.fromPartial({}),
      signatures: []
    };
  }
  e.Commit = {
    typeUrl: "/tendermint.types.Commit",
    encode(s, u = f.BinaryWriter.create()) {
      s.height !== BigInt(0) && u.uint32(8).int64(s.height), s.round !== 0 && u.uint32(16).int32(s.round), s.blockId !== void 0 && e.BlockID.encode(s.blockId, u.uint32(26).fork()).ldelim();
      for (const A of s.signatures)
        e.CommitSig.encode(A, u.uint32(34).fork()).ldelim();
      return u;
    },
    decode(s, u) {
      const A = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = J();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.height = A.int64();
            break;
          case 2:
            v.round = A.int32();
            break;
          case 3:
            v.blockId = e.BlockID.decode(A, A.uint32());
            break;
          case 4:
            v.signatures.push(e.CommitSig.decode(A, A.uint32()));
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = J();
      return (0, k.isSet)(s.height) && (u.height = BigInt(s.height.toString())), (0, k.isSet)(s.round) && (u.round = Number(s.round)), (0, k.isSet)(s.blockId) && (u.blockId = e.BlockID.fromJSON(s.blockId)), Array.isArray(s == null ? void 0 : s.signatures) && (u.signatures = s.signatures.map((A) => e.CommitSig.fromJSON(A))), u;
    },
    toJSON(s) {
      const u = {};
      return s.height !== void 0 && (u.height = (s.height || BigInt(0)).toString()), s.round !== void 0 && (u.round = Math.round(s.round)), s.blockId !== void 0 && (u.blockId = s.blockId ? e.BlockID.toJSON(s.blockId) : void 0), s.signatures ? u.signatures = s.signatures.map((A) => A ? e.CommitSig.toJSON(A) : void 0) : u.signatures = [], u;
    },
    fromPartial(s) {
      var A;
      const u = J();
      return s.height !== void 0 && s.height !== null && (u.height = BigInt(s.height.toString())), u.round = s.round ?? 0, s.blockId !== void 0 && s.blockId !== null && (u.blockId = e.BlockID.fromPartial(s.blockId)), u.signatures = ((A = s.signatures) == null ? void 0 : A.map((R) => e.CommitSig.fromPartial(R))) || [], u;
    }
  };
  function _() {
    return {
      blockIdFlag: 0,
      validatorAddress: new Uint8Array(),
      timestamp: t.Timestamp.fromPartial({}),
      signature: new Uint8Array()
    };
  }
  e.CommitSig = {
    typeUrl: "/tendermint.types.CommitSig",
    encode(s, u = f.BinaryWriter.create()) {
      return s.blockIdFlag !== 0 && u.uint32(8).int32(s.blockIdFlag), s.validatorAddress.length !== 0 && u.uint32(18).bytes(s.validatorAddress), s.timestamp !== void 0 && t.Timestamp.encode(s.timestamp, u.uint32(26).fork()).ldelim(), s.signature.length !== 0 && u.uint32(34).bytes(s.signature), u;
    },
    decode(s, u) {
      const A = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = _();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.blockIdFlag = A.int32();
            break;
          case 2:
            v.validatorAddress = A.bytes();
            break;
          case 3:
            v.timestamp = t.Timestamp.decode(A, A.uint32());
            break;
          case 4:
            v.signature = A.bytes();
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = _();
      return (0, k.isSet)(s.blockIdFlag) && (u.blockIdFlag = T(s.blockIdFlag)), (0, k.isSet)(s.validatorAddress) && (u.validatorAddress = (0, k.bytesFromBase64)(s.validatorAddress)), (0, k.isSet)(s.timestamp) && (u.timestamp = (0, k.fromJsonTimestamp)(s.timestamp)), (0, k.isSet)(s.signature) && (u.signature = (0, k.bytesFromBase64)(s.signature)), u;
    },
    toJSON(s) {
      const u = {};
      return s.blockIdFlag !== void 0 && (u.blockIdFlag = U(s.blockIdFlag)), s.validatorAddress !== void 0 && (u.validatorAddress = (0, k.base64FromBytes)(s.validatorAddress !== void 0 ? s.validatorAddress : new Uint8Array())), s.timestamp !== void 0 && (u.timestamp = (0, k.fromTimestamp)(s.timestamp).toISOString()), s.signature !== void 0 && (u.signature = (0, k.base64FromBytes)(s.signature !== void 0 ? s.signature : new Uint8Array())), u;
    },
    fromPartial(s) {
      const u = _();
      return u.blockIdFlag = s.blockIdFlag ?? 0, u.validatorAddress = s.validatorAddress ?? new Uint8Array(), s.timestamp !== void 0 && s.timestamp !== null && (u.timestamp = t.Timestamp.fromPartial(s.timestamp)), u.signature = s.signature ?? new Uint8Array(), u;
    }
  };
  function V() {
    return {
      type: 0,
      height: BigInt(0),
      round: 0,
      polRound: 0,
      blockId: e.BlockID.fromPartial({}),
      timestamp: t.Timestamp.fromPartial({}),
      signature: new Uint8Array()
    };
  }
  e.Proposal = {
    typeUrl: "/tendermint.types.Proposal",
    encode(s, u = f.BinaryWriter.create()) {
      return s.type !== 0 && u.uint32(8).int32(s.type), s.height !== BigInt(0) && u.uint32(16).int64(s.height), s.round !== 0 && u.uint32(24).int32(s.round), s.polRound !== 0 && u.uint32(32).int32(s.polRound), s.blockId !== void 0 && e.BlockID.encode(s.blockId, u.uint32(42).fork()).ldelim(), s.timestamp !== void 0 && t.Timestamp.encode(s.timestamp, u.uint32(50).fork()).ldelim(), s.signature.length !== 0 && u.uint32(58).bytes(s.signature), u;
    },
    decode(s, u) {
      const A = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = V();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.type = A.int32();
            break;
          case 2:
            v.height = A.int64();
            break;
          case 3:
            v.round = A.int32();
            break;
          case 4:
            v.polRound = A.int32();
            break;
          case 5:
            v.blockId = e.BlockID.decode(A, A.uint32());
            break;
          case 6:
            v.timestamp = t.Timestamp.decode(A, A.uint32());
            break;
          case 7:
            v.signature = A.bytes();
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = V();
      return (0, k.isSet)(s.type) && (u.type = N(s.type)), (0, k.isSet)(s.height) && (u.height = BigInt(s.height.toString())), (0, k.isSet)(s.round) && (u.round = Number(s.round)), (0, k.isSet)(s.polRound) && (u.polRound = Number(s.polRound)), (0, k.isSet)(s.blockId) && (u.blockId = e.BlockID.fromJSON(s.blockId)), (0, k.isSet)(s.timestamp) && (u.timestamp = (0, k.fromJsonTimestamp)(s.timestamp)), (0, k.isSet)(s.signature) && (u.signature = (0, k.bytesFromBase64)(s.signature)), u;
    },
    toJSON(s) {
      const u = {};
      return s.type !== void 0 && (u.type = h(s.type)), s.height !== void 0 && (u.height = (s.height || BigInt(0)).toString()), s.round !== void 0 && (u.round = Math.round(s.round)), s.polRound !== void 0 && (u.polRound = Math.round(s.polRound)), s.blockId !== void 0 && (u.blockId = s.blockId ? e.BlockID.toJSON(s.blockId) : void 0), s.timestamp !== void 0 && (u.timestamp = (0, k.fromTimestamp)(s.timestamp).toISOString()), s.signature !== void 0 && (u.signature = (0, k.base64FromBytes)(s.signature !== void 0 ? s.signature : new Uint8Array())), u;
    },
    fromPartial(s) {
      const u = V();
      return u.type = s.type ?? 0, s.height !== void 0 && s.height !== null && (u.height = BigInt(s.height.toString())), u.round = s.round ?? 0, u.polRound = s.polRound ?? 0, s.blockId !== void 0 && s.blockId !== null && (u.blockId = e.BlockID.fromPartial(s.blockId)), s.timestamp !== void 0 && s.timestamp !== null && (u.timestamp = t.Timestamp.fromPartial(s.timestamp)), u.signature = s.signature ?? new Uint8Array(), u;
    }
  };
  function o() {
    return {
      header: void 0,
      commit: void 0
    };
  }
  e.SignedHeader = {
    typeUrl: "/tendermint.types.SignedHeader",
    encode(s, u = f.BinaryWriter.create()) {
      return s.header !== void 0 && e.Header.encode(s.header, u.uint32(10).fork()).ldelim(), s.commit !== void 0 && e.Commit.encode(s.commit, u.uint32(18).fork()).ldelim(), u;
    },
    decode(s, u) {
      const A = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = o();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.header = e.Header.decode(A, A.uint32());
            break;
          case 2:
            v.commit = e.Commit.decode(A, A.uint32());
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = o();
      return (0, k.isSet)(s.header) && (u.header = e.Header.fromJSON(s.header)), (0, k.isSet)(s.commit) && (u.commit = e.Commit.fromJSON(s.commit)), u;
    },
    toJSON(s) {
      const u = {};
      return s.header !== void 0 && (u.header = s.header ? e.Header.toJSON(s.header) : void 0), s.commit !== void 0 && (u.commit = s.commit ? e.Commit.toJSON(s.commit) : void 0), u;
    },
    fromPartial(s) {
      const u = o();
      return s.header !== void 0 && s.header !== null && (u.header = e.Header.fromPartial(s.header)), s.commit !== void 0 && s.commit !== null && (u.commit = e.Commit.fromPartial(s.commit)), u;
    }
  };
  function p() {
    return {
      signedHeader: void 0,
      validatorSet: void 0
    };
  }
  e.LightBlock = {
    typeUrl: "/tendermint.types.LightBlock",
    encode(s, u = f.BinaryWriter.create()) {
      return s.signedHeader !== void 0 && e.SignedHeader.encode(s.signedHeader, u.uint32(10).fork()).ldelim(), s.validatorSet !== void 0 && i.ValidatorSet.encode(s.validatorSet, u.uint32(18).fork()).ldelim(), u;
    },
    decode(s, u) {
      const A = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = p();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.signedHeader = e.SignedHeader.decode(A, A.uint32());
            break;
          case 2:
            v.validatorSet = i.ValidatorSet.decode(A, A.uint32());
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = p();
      return (0, k.isSet)(s.signedHeader) && (u.signedHeader = e.SignedHeader.fromJSON(s.signedHeader)), (0, k.isSet)(s.validatorSet) && (u.validatorSet = i.ValidatorSet.fromJSON(s.validatorSet)), u;
    },
    toJSON(s) {
      const u = {};
      return s.signedHeader !== void 0 && (u.signedHeader = s.signedHeader ? e.SignedHeader.toJSON(s.signedHeader) : void 0), s.validatorSet !== void 0 && (u.validatorSet = s.validatorSet ? i.ValidatorSet.toJSON(s.validatorSet) : void 0), u;
    },
    fromPartial(s) {
      const u = p();
      return s.signedHeader !== void 0 && s.signedHeader !== null && (u.signedHeader = e.SignedHeader.fromPartial(s.signedHeader)), s.validatorSet !== void 0 && s.validatorSet !== null && (u.validatorSet = i.ValidatorSet.fromPartial(s.validatorSet)), u;
    }
  };
  function I() {
    return {
      blockId: e.BlockID.fromPartial({}),
      blockSize: BigInt(0),
      header: e.Header.fromPartial({}),
      numTxs: BigInt(0)
    };
  }
  e.BlockMeta = {
    typeUrl: "/tendermint.types.BlockMeta",
    encode(s, u = f.BinaryWriter.create()) {
      return s.blockId !== void 0 && e.BlockID.encode(s.blockId, u.uint32(10).fork()).ldelim(), s.blockSize !== BigInt(0) && u.uint32(16).int64(s.blockSize), s.header !== void 0 && e.Header.encode(s.header, u.uint32(26).fork()).ldelim(), s.numTxs !== BigInt(0) && u.uint32(32).int64(s.numTxs), u;
    },
    decode(s, u) {
      const A = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = I();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.blockId = e.BlockID.decode(A, A.uint32());
            break;
          case 2:
            v.blockSize = A.int64();
            break;
          case 3:
            v.header = e.Header.decode(A, A.uint32());
            break;
          case 4:
            v.numTxs = A.int64();
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = I();
      return (0, k.isSet)(s.blockId) && (u.blockId = e.BlockID.fromJSON(s.blockId)), (0, k.isSet)(s.blockSize) && (u.blockSize = BigInt(s.blockSize.toString())), (0, k.isSet)(s.header) && (u.header = e.Header.fromJSON(s.header)), (0, k.isSet)(s.numTxs) && (u.numTxs = BigInt(s.numTxs.toString())), u;
    },
    toJSON(s) {
      const u = {};
      return s.blockId !== void 0 && (u.blockId = s.blockId ? e.BlockID.toJSON(s.blockId) : void 0), s.blockSize !== void 0 && (u.blockSize = (s.blockSize || BigInt(0)).toString()), s.header !== void 0 && (u.header = s.header ? e.Header.toJSON(s.header) : void 0), s.numTxs !== void 0 && (u.numTxs = (s.numTxs || BigInt(0)).toString()), u;
    },
    fromPartial(s) {
      const u = I();
      return s.blockId !== void 0 && s.blockId !== null && (u.blockId = e.BlockID.fromPartial(s.blockId)), s.blockSize !== void 0 && s.blockSize !== null && (u.blockSize = BigInt(s.blockSize.toString())), s.header !== void 0 && s.header !== null && (u.header = e.Header.fromPartial(s.header)), s.numTxs !== void 0 && s.numTxs !== null && (u.numTxs = BigInt(s.numTxs.toString())), u;
    }
  };
  function q() {
    return {
      rootHash: new Uint8Array(),
      data: new Uint8Array(),
      proof: void 0
    };
  }
  e.TxProof = {
    typeUrl: "/tendermint.types.TxProof",
    encode(s, u = f.BinaryWriter.create()) {
      return s.rootHash.length !== 0 && u.uint32(10).bytes(s.rootHash), s.data.length !== 0 && u.uint32(18).bytes(s.data), s.proof !== void 0 && n.Proof.encode(s.proof, u.uint32(26).fork()).ldelim(), u;
    },
    decode(s, u) {
      const A = s instanceof f.BinaryReader ? s : new f.BinaryReader(s);
      let R = u === void 0 ? A.len : A.pos + u;
      const v = q();
      for (; A.pos < R; ) {
        const D = A.uint32();
        switch (D >>> 3) {
          case 1:
            v.rootHash = A.bytes();
            break;
          case 2:
            v.data = A.bytes();
            break;
          case 3:
            v.proof = n.Proof.decode(A, A.uint32());
            break;
          default:
            A.skipType(D & 7);
            break;
        }
      }
      return v;
    },
    fromJSON(s) {
      const u = q();
      return (0, k.isSet)(s.rootHash) && (u.rootHash = (0, k.bytesFromBase64)(s.rootHash)), (0, k.isSet)(s.data) && (u.data = (0, k.bytesFromBase64)(s.data)), (0, k.isSet)(s.proof) && (u.proof = n.Proof.fromJSON(s.proof)), u;
    },
    toJSON(s) {
      const u = {};
      return s.rootHash !== void 0 && (u.rootHash = (0, k.base64FromBytes)(s.rootHash !== void 0 ? s.rootHash : new Uint8Array())), s.data !== void 0 && (u.data = (0, k.base64FromBytes)(s.data !== void 0 ? s.data : new Uint8Array())), s.proof !== void 0 && (u.proof = s.proof ? n.Proof.toJSON(s.proof) : void 0), u;
    },
    fromPartial(s) {
      const u = q();
      return u.rootHash = s.rootHash ?? new Uint8Array(), u.data = s.data ?? new Uint8Array(), s.proof !== void 0 && s.proof !== null && (u.proof = n.Proof.fromPartial(s.proof)), u;
    }
  };
})(_t);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Fraction = e.Header = e.Misbehaviour = e.ConsensusState = e.ClientState = e.protobufPackage = void 0;
  const n = pn, r = Yn, t = kd, i = _e, f = ln, k = _t, C = To, T = re, U = ie;
  e.protobufPackage = "ibc.lightclients.tendermint.v1";
  function w() {
    return {
      chainId: "",
      trustLevel: e.Fraction.fromPartial({}),
      trustingPeriod: n.Duration.fromPartial({}),
      unbondingPeriod: n.Duration.fromPartial({}),
      maxClockDrift: n.Duration.fromPartial({}),
      frozenHeight: r.Height.fromPartial({}),
      latestHeight: r.Height.fromPartial({}),
      proofSpecs: [],
      upgradePath: [],
      allowUpdateAfterExpiry: !1,
      allowUpdateAfterMisbehaviour: !1
    };
  }
  e.ClientState = {
    typeUrl: "/ibc.lightclients.tendermint.v1.ClientState",
    encode(c, l = T.BinaryWriter.create()) {
      c.chainId !== "" && l.uint32(10).string(c.chainId), c.trustLevel !== void 0 && e.Fraction.encode(c.trustLevel, l.uint32(18).fork()).ldelim(), c.trustingPeriod !== void 0 && n.Duration.encode(c.trustingPeriod, l.uint32(26).fork()).ldelim(), c.unbondingPeriod !== void 0 && n.Duration.encode(c.unbondingPeriod, l.uint32(34).fork()).ldelim(), c.maxClockDrift !== void 0 && n.Duration.encode(c.maxClockDrift, l.uint32(42).fork()).ldelim(), c.frozenHeight !== void 0 && r.Height.encode(c.frozenHeight, l.uint32(50).fork()).ldelim(), c.latestHeight !== void 0 && r.Height.encode(c.latestHeight, l.uint32(58).fork()).ldelim();
      for (const y of c.proofSpecs)
        t.ProofSpec.encode(y, l.uint32(66).fork()).ldelim();
      for (const y of c.upgradePath)
        l.uint32(74).string(y);
      return c.allowUpdateAfterExpiry === !0 && l.uint32(80).bool(c.allowUpdateAfterExpiry), c.allowUpdateAfterMisbehaviour === !0 && l.uint32(88).bool(c.allowUpdateAfterMisbehaviour), l;
    },
    decode(c, l) {
      const y = c instanceof T.BinaryReader ? c : new T.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = w();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.chainId = y.string();
            break;
          case 2:
            J.trustLevel = e.Fraction.decode(y, y.uint32());
            break;
          case 3:
            J.trustingPeriod = n.Duration.decode(y, y.uint32());
            break;
          case 4:
            J.unbondingPeriod = n.Duration.decode(y, y.uint32());
            break;
          case 5:
            J.maxClockDrift = n.Duration.decode(y, y.uint32());
            break;
          case 6:
            J.frozenHeight = r.Height.decode(y, y.uint32());
            break;
          case 7:
            J.latestHeight = r.Height.decode(y, y.uint32());
            break;
          case 8:
            J.proofSpecs.push(t.ProofSpec.decode(y, y.uint32()));
            break;
          case 9:
            J.upgradePath.push(y.string());
            break;
          case 10:
            J.allowUpdateAfterExpiry = y.bool();
            break;
          case 11:
            J.allowUpdateAfterMisbehaviour = y.bool();
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = w();
      return (0, U.isSet)(c.chainId) && (l.chainId = String(c.chainId)), (0, U.isSet)(c.trustLevel) && (l.trustLevel = e.Fraction.fromJSON(c.trustLevel)), (0, U.isSet)(c.trustingPeriod) && (l.trustingPeriod = n.Duration.fromJSON(c.trustingPeriod)), (0, U.isSet)(c.unbondingPeriod) && (l.unbondingPeriod = n.Duration.fromJSON(c.unbondingPeriod)), (0, U.isSet)(c.maxClockDrift) && (l.maxClockDrift = n.Duration.fromJSON(c.maxClockDrift)), (0, U.isSet)(c.frozenHeight) && (l.frozenHeight = r.Height.fromJSON(c.frozenHeight)), (0, U.isSet)(c.latestHeight) && (l.latestHeight = r.Height.fromJSON(c.latestHeight)), Array.isArray(c == null ? void 0 : c.proofSpecs) && (l.proofSpecs = c.proofSpecs.map((y) => t.ProofSpec.fromJSON(y))), Array.isArray(c == null ? void 0 : c.upgradePath) && (l.upgradePath = c.upgradePath.map((y) => String(y))), (0, U.isSet)(c.allowUpdateAfterExpiry) && (l.allowUpdateAfterExpiry = !!c.allowUpdateAfterExpiry), (0, U.isSet)(c.allowUpdateAfterMisbehaviour) && (l.allowUpdateAfterMisbehaviour = !!c.allowUpdateAfterMisbehaviour), l;
    },
    toJSON(c) {
      const l = {};
      return c.chainId !== void 0 && (l.chainId = c.chainId), c.trustLevel !== void 0 && (l.trustLevel = c.trustLevel ? e.Fraction.toJSON(c.trustLevel) : void 0), c.trustingPeriod !== void 0 && (l.trustingPeriod = c.trustingPeriod ? n.Duration.toJSON(c.trustingPeriod) : void 0), c.unbondingPeriod !== void 0 && (l.unbondingPeriod = c.unbondingPeriod ? n.Duration.toJSON(c.unbondingPeriod) : void 0), c.maxClockDrift !== void 0 && (l.maxClockDrift = c.maxClockDrift ? n.Duration.toJSON(c.maxClockDrift) : void 0), c.frozenHeight !== void 0 && (l.frozenHeight = c.frozenHeight ? r.Height.toJSON(c.frozenHeight) : void 0), c.latestHeight !== void 0 && (l.latestHeight = c.latestHeight ? r.Height.toJSON(c.latestHeight) : void 0), c.proofSpecs ? l.proofSpecs = c.proofSpecs.map((y) => y ? t.ProofSpec.toJSON(y) : void 0) : l.proofSpecs = [], c.upgradePath ? l.upgradePath = c.upgradePath.map((y) => y) : l.upgradePath = [], c.allowUpdateAfterExpiry !== void 0 && (l.allowUpdateAfterExpiry = c.allowUpdateAfterExpiry), c.allowUpdateAfterMisbehaviour !== void 0 && (l.allowUpdateAfterMisbehaviour = c.allowUpdateAfterMisbehaviour), l;
    },
    fromPartial(c) {
      var y, E;
      const l = w();
      return l.chainId = c.chainId ?? "", c.trustLevel !== void 0 && c.trustLevel !== null && (l.trustLevel = e.Fraction.fromPartial(c.trustLevel)), c.trustingPeriod !== void 0 && c.trustingPeriod !== null && (l.trustingPeriod = n.Duration.fromPartial(c.trustingPeriod)), c.unbondingPeriod !== void 0 && c.unbondingPeriod !== null && (l.unbondingPeriod = n.Duration.fromPartial(c.unbondingPeriod)), c.maxClockDrift !== void 0 && c.maxClockDrift !== null && (l.maxClockDrift = n.Duration.fromPartial(c.maxClockDrift)), c.frozenHeight !== void 0 && c.frozenHeight !== null && (l.frozenHeight = r.Height.fromPartial(c.frozenHeight)), c.latestHeight !== void 0 && c.latestHeight !== null && (l.latestHeight = r.Height.fromPartial(c.latestHeight)), l.proofSpecs = ((y = c.proofSpecs) == null ? void 0 : y.map((J) => t.ProofSpec.fromPartial(J))) || [], l.upgradePath = ((E = c.upgradePath) == null ? void 0 : E.map((J) => J)) || [], l.allowUpdateAfterExpiry = c.allowUpdateAfterExpiry ?? !1, l.allowUpdateAfterMisbehaviour = c.allowUpdateAfterMisbehaviour ?? !1, l;
    }
  };
  function N() {
    return {
      timestamp: i.Timestamp.fromPartial({}),
      root: f.MerkleRoot.fromPartial({}),
      nextValidatorsHash: new Uint8Array()
    };
  }
  e.ConsensusState = {
    typeUrl: "/ibc.lightclients.tendermint.v1.ConsensusState",
    encode(c, l = T.BinaryWriter.create()) {
      return c.timestamp !== void 0 && i.Timestamp.encode(c.timestamp, l.uint32(10).fork()).ldelim(), c.root !== void 0 && f.MerkleRoot.encode(c.root, l.uint32(18).fork()).ldelim(), c.nextValidatorsHash.length !== 0 && l.uint32(26).bytes(c.nextValidatorsHash), l;
    },
    decode(c, l) {
      const y = c instanceof T.BinaryReader ? c : new T.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = N();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.timestamp = i.Timestamp.decode(y, y.uint32());
            break;
          case 2:
            J.root = f.MerkleRoot.decode(y, y.uint32());
            break;
          case 3:
            J.nextValidatorsHash = y.bytes();
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = N();
      return (0, U.isSet)(c.timestamp) && (l.timestamp = (0, U.fromJsonTimestamp)(c.timestamp)), (0, U.isSet)(c.root) && (l.root = f.MerkleRoot.fromJSON(c.root)), (0, U.isSet)(c.nextValidatorsHash) && (l.nextValidatorsHash = (0, U.bytesFromBase64)(c.nextValidatorsHash)), l;
    },
    toJSON(c) {
      const l = {};
      return c.timestamp !== void 0 && (l.timestamp = (0, U.fromTimestamp)(c.timestamp).toISOString()), c.root !== void 0 && (l.root = c.root ? f.MerkleRoot.toJSON(c.root) : void 0), c.nextValidatorsHash !== void 0 && (l.nextValidatorsHash = (0, U.base64FromBytes)(c.nextValidatorsHash !== void 0 ? c.nextValidatorsHash : new Uint8Array())), l;
    },
    fromPartial(c) {
      const l = N();
      return c.timestamp !== void 0 && c.timestamp !== null && (l.timestamp = i.Timestamp.fromPartial(c.timestamp)), c.root !== void 0 && c.root !== null && (l.root = f.MerkleRoot.fromPartial(c.root)), l.nextValidatorsHash = c.nextValidatorsHash ?? new Uint8Array(), l;
    }
  };
  function h() {
    return {
      clientId: "",
      header1: void 0,
      header2: void 0
    };
  }
  e.Misbehaviour = {
    typeUrl: "/ibc.lightclients.tendermint.v1.Misbehaviour",
    encode(c, l = T.BinaryWriter.create()) {
      return c.clientId !== "" && l.uint32(10).string(c.clientId), c.header1 !== void 0 && e.Header.encode(c.header1, l.uint32(18).fork()).ldelim(), c.header2 !== void 0 && e.Header.encode(c.header2, l.uint32(26).fork()).ldelim(), l;
    },
    decode(c, l) {
      const y = c instanceof T.BinaryReader ? c : new T.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = h();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.clientId = y.string();
            break;
          case 2:
            J.header1 = e.Header.decode(y, y.uint32());
            break;
          case 3:
            J.header2 = e.Header.decode(y, y.uint32());
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = h();
      return (0, U.isSet)(c.clientId) && (l.clientId = String(c.clientId)), (0, U.isSet)(c.header1) && (l.header1 = e.Header.fromJSON(c.header1)), (0, U.isSet)(c.header2) && (l.header2 = e.Header.fromJSON(c.header2)), l;
    },
    toJSON(c) {
      const l = {};
      return c.clientId !== void 0 && (l.clientId = c.clientId), c.header1 !== void 0 && (l.header1 = c.header1 ? e.Header.toJSON(c.header1) : void 0), c.header2 !== void 0 && (l.header2 = c.header2 ? e.Header.toJSON(c.header2) : void 0), l;
    },
    fromPartial(c) {
      const l = h();
      return l.clientId = c.clientId ?? "", c.header1 !== void 0 && c.header1 !== null && (l.header1 = e.Header.fromPartial(c.header1)), c.header2 !== void 0 && c.header2 !== null && (l.header2 = e.Header.fromPartial(c.header2)), l;
    }
  };
  function P() {
    return {
      signedHeader: void 0,
      validatorSet: void 0,
      trustedHeight: r.Height.fromPartial({}),
      trustedValidators: void 0
    };
  }
  e.Header = {
    typeUrl: "/ibc.lightclients.tendermint.v1.Header",
    encode(c, l = T.BinaryWriter.create()) {
      return c.signedHeader !== void 0 && k.SignedHeader.encode(c.signedHeader, l.uint32(10).fork()).ldelim(), c.validatorSet !== void 0 && C.ValidatorSet.encode(c.validatorSet, l.uint32(18).fork()).ldelim(), c.trustedHeight !== void 0 && r.Height.encode(c.trustedHeight, l.uint32(26).fork()).ldelim(), c.trustedValidators !== void 0 && C.ValidatorSet.encode(c.trustedValidators, l.uint32(34).fork()).ldelim(), l;
    },
    decode(c, l) {
      const y = c instanceof T.BinaryReader ? c : new T.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = P();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.signedHeader = k.SignedHeader.decode(y, y.uint32());
            break;
          case 2:
            J.validatorSet = C.ValidatorSet.decode(y, y.uint32());
            break;
          case 3:
            J.trustedHeight = r.Height.decode(y, y.uint32());
            break;
          case 4:
            J.trustedValidators = C.ValidatorSet.decode(y, y.uint32());
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = P();
      return (0, U.isSet)(c.signedHeader) && (l.signedHeader = k.SignedHeader.fromJSON(c.signedHeader)), (0, U.isSet)(c.validatorSet) && (l.validatorSet = C.ValidatorSet.fromJSON(c.validatorSet)), (0, U.isSet)(c.trustedHeight) && (l.trustedHeight = r.Height.fromJSON(c.trustedHeight)), (0, U.isSet)(c.trustedValidators) && (l.trustedValidators = C.ValidatorSet.fromJSON(c.trustedValidators)), l;
    },
    toJSON(c) {
      const l = {};
      return c.signedHeader !== void 0 && (l.signedHeader = c.signedHeader ? k.SignedHeader.toJSON(c.signedHeader) : void 0), c.validatorSet !== void 0 && (l.validatorSet = c.validatorSet ? C.ValidatorSet.toJSON(c.validatorSet) : void 0), c.trustedHeight !== void 0 && (l.trustedHeight = c.trustedHeight ? r.Height.toJSON(c.trustedHeight) : void 0), c.trustedValidators !== void 0 && (l.trustedValidators = c.trustedValidators ? C.ValidatorSet.toJSON(c.trustedValidators) : void 0), l;
    },
    fromPartial(c) {
      const l = P();
      return c.signedHeader !== void 0 && c.signedHeader !== null && (l.signedHeader = k.SignedHeader.fromPartial(c.signedHeader)), c.validatorSet !== void 0 && c.validatorSet !== null && (l.validatorSet = C.ValidatorSet.fromPartial(c.validatorSet)), c.trustedHeight !== void 0 && c.trustedHeight !== null && (l.trustedHeight = r.Height.fromPartial(c.trustedHeight)), c.trustedValidators !== void 0 && c.trustedValidators !== null && (l.trustedValidators = C.ValidatorSet.fromPartial(c.trustedValidators)), l;
    }
  };
  function b() {
    return {
      numerator: BigInt(0),
      denominator: BigInt(0)
    };
  }
  e.Fraction = {
    typeUrl: "/ibc.lightclients.tendermint.v1.Fraction",
    encode(c, l = T.BinaryWriter.create()) {
      return c.numerator !== BigInt(0) && l.uint32(8).uint64(c.numerator), c.denominator !== BigInt(0) && l.uint32(16).uint64(c.denominator), l;
    },
    decode(c, l) {
      const y = c instanceof T.BinaryReader ? c : new T.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = b();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.numerator = y.uint64();
            break;
          case 2:
            J.denominator = y.uint64();
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = b();
      return (0, U.isSet)(c.numerator) && (l.numerator = BigInt(c.numerator.toString())), (0, U.isSet)(c.denominator) && (l.denominator = BigInt(c.denominator.toString())), l;
    },
    toJSON(c) {
      const l = {};
      return c.numerator !== void 0 && (l.numerator = (c.numerator || BigInt(0)).toString()), c.denominator !== void 0 && (l.denominator = (c.denominator || BigInt(0)).toString()), l;
    },
    fromPartial(c) {
      const l = b();
      return c.numerator !== void 0 && c.numerator !== null && (l.numerator = BigInt(c.numerator.toString())), c.denominator !== void 0 && c.denominator !== null && (l.denominator = BigInt(c.denominator.toString())), l;
    }
  };
})(yl);
Object.defineProperty(Io, "__esModule", { value: !0 });
Io.setupIbcExtension = void 0;
const Pi = Ct, Mm = mt, wu = ll, Hm = Ao, gt = fl, Er = pl, hs = hl, ml = yl, Oe = Ge;
function ys(e) {
  if ((e == null ? void 0 : e.typeUrl) !== "/ibc.lightclients.tendermint.v1.ClientState")
    throw new Error(`Unexpected client state type: ${e == null ? void 0 : e.typeUrl}`);
  return ml.ClientState.decode(e.value);
}
function qm(e) {
  if ((e == null ? void 0 : e.typeUrl) !== "/ibc.lightclients.tendermint.v1.ConsensusState")
    throw new Error(`Unexpected client state type: ${e == null ? void 0 : e.typeUrl}`);
  return ml.ConsensusState.decode(e.value);
}
function Vm(e) {
  const n = (0, Oe.createProtobufRpcClient)(e), r = new gt.QueryClientImpl(n), t = new Er.QueryClientImpl(n), i = new hs.QueryClientImpl(n), f = new wu.QueryClientImpl(n);
  return {
    ibc: {
      channel: {
        channel: async (k, C) => r.Channel({
          portId: k,
          channelId: C
        }),
        channels: async (k) => r.Channels({
          pagination: (0, Oe.createPagination)(k)
        }),
        allChannels: async () => {
          var U;
          const k = [];
          let C, T;
          do
            C = await r.Channels({
              pagination: (0, Oe.createPagination)(T)
            }), k.push(...C.channels), T = (U = C.pagination) == null ? void 0 : U.nextKey;
          while (T && T.length);
          return gt.QueryChannelsResponse.fromPartial({
            channels: k,
            height: C.height
          });
        },
        connectionChannels: async (k, C) => r.ConnectionChannels({
          connection: k,
          pagination: (0, Oe.createPagination)(C)
        }),
        allConnectionChannels: async (k) => {
          var w;
          const C = [];
          let T, U;
          do
            T = await r.ConnectionChannels({
              connection: k,
              pagination: (0, Oe.createPagination)(U)
            }), C.push(...T.channels), U = (w = T.pagination) == null ? void 0 : w.nextKey;
          while (U && U.length);
          return gt.QueryConnectionChannelsResponse.fromPartial({
            channels: C,
            height: T.height
          });
        },
        clientState: async (k, C) => r.ChannelClientState({
          portId: k,
          channelId: C
        }),
        consensusState: async (k, C, T, U) => r.ChannelConsensusState({
          portId: k,
          channelId: C,
          revisionNumber: BigInt(T),
          revisionHeight: BigInt(U)
        }),
        packetCommitment: async (k, C, T) => r.PacketCommitment({
          portId: k,
          channelId: C,
          sequence: (0, Oe.longify)(T)
        }),
        packetCommitments: async (k, C, T) => r.PacketCommitments({
          channelId: C,
          portId: k,
          pagination: (0, Oe.createPagination)(T)
        }),
        allPacketCommitments: async (k, C) => {
          var N;
          const T = [];
          let U, w;
          do
            U = await r.PacketCommitments({
              channelId: C,
              portId: k,
              pagination: (0, Oe.createPagination)(w)
            }), T.push(...U.commitments), w = (N = U.pagination) == null ? void 0 : N.nextKey;
          while (w && w.length);
          return gt.QueryPacketCommitmentsResponse.fromPartial({
            commitments: T,
            height: U.height
          });
        },
        packetReceipt: async (k, C, T) => r.PacketReceipt({
          portId: k,
          channelId: C,
          sequence: (0, Oe.longify)(T)
        }),
        packetAcknowledgement: async (k, C, T) => r.PacketAcknowledgement({
          portId: k,
          channelId: C,
          sequence: (0, Oe.longify)(T)
        }),
        packetAcknowledgements: async (k, C, T) => {
          const U = gt.QueryPacketAcknowledgementsRequest.fromPartial({
            portId: k,
            channelId: C,
            pagination: (0, Oe.createPagination)(T)
          });
          return r.PacketAcknowledgements(U);
        },
        allPacketAcknowledgements: async (k, C) => {
          var N;
          const T = [];
          let U, w;
          do {
            const h = gt.QueryPacketAcknowledgementsRequest.fromPartial({
              channelId: C,
              portId: k,
              pagination: (0, Oe.createPagination)(w)
            });
            U = await r.PacketAcknowledgements(h), T.push(...U.acknowledgements), w = (N = U.pagination) == null ? void 0 : N.nextKey;
          } while (w && w.length);
          return gt.QueryPacketAcknowledgementsResponse.fromPartial({
            acknowledgements: T,
            height: U.height
          });
        },
        unreceivedPackets: async (k, C, T) => r.UnreceivedPackets({
          portId: k,
          channelId: C,
          packetCommitmentSequences: T.map((U) => BigInt(U))
        }),
        unreceivedAcks: async (k, C, T) => r.UnreceivedAcks({
          portId: k,
          channelId: C,
          packetAckSequences: T.map((U) => BigInt(U))
        }),
        nextSequenceReceive: async (k, C) => r.NextSequenceReceive({
          portId: k,
          channelId: C
        })
      },
      client: {
        state: async (k) => t.ClientState({ clientId: k }),
        states: async (k) => t.ClientStates({
          pagination: (0, Oe.createPagination)(k)
        }),
        allStates: async () => {
          var U;
          const k = [];
          let C, T;
          do
            C = await t.ClientStates({
              pagination: (0, Oe.createPagination)(T)
            }), k.push(...C.clientStates), T = (U = C.pagination) == null ? void 0 : U.nextKey;
          while (T && T.length);
          return Er.QueryClientStatesResponse.fromPartial({
            clientStates: k
          });
        },
        consensusState: async (k, C) => t.ConsensusState(Er.QueryConsensusStateRequest.fromPartial({
          clientId: k,
          revisionHeight: C !== void 0 ? BigInt(C) : void 0,
          latestHeight: C === void 0
        })),
        consensusStates: async (k, C) => t.ConsensusStates({
          clientId: k,
          pagination: (0, Oe.createPagination)(C)
        }),
        allConsensusStates: async (k) => {
          var w;
          const C = [];
          let T, U;
          do
            T = await t.ConsensusStates({
              clientId: k,
              pagination: (0, Oe.createPagination)(U)
            }), C.push(...T.consensusStates), U = (w = T.pagination) == null ? void 0 : w.nextKey;
          while (U && U.length);
          return Er.QueryConsensusStatesResponse.fromPartial({
            consensusStates: C
          });
        },
        params: async () => t.ClientParams({}),
        stateTm: async (k) => {
          const C = await t.ClientState({ clientId: k });
          return ys(C.clientState);
        },
        statesTm: async (k) => {
          const { clientStates: C } = await t.ClientStates({
            pagination: (0, Oe.createPagination)(k)
          });
          return C.map(({ clientState: T }) => ys(T));
        },
        allStatesTm: async () => {
          var U;
          const k = [];
          let C, T;
          do
            C = await t.ClientStates({
              pagination: (0, Oe.createPagination)(T)
            }), k.push(...C.clientStates), T = (U = C.pagination) == null ? void 0 : U.nextKey;
          while (T && T.length);
          return k.map(({ clientState: w }) => ys(w));
        },
        consensusStateTm: async (k, C) => {
          const T = await t.ConsensusState(Er.QueryConsensusStateRequest.fromPartial({
            clientId: k,
            revisionHeight: C == null ? void 0 : C.revisionHeight,
            revisionNumber: C == null ? void 0 : C.revisionNumber,
            latestHeight: C === void 0
          }));
          return qm(T.consensusState);
        }
      },
      connection: {
        connection: async (k) => i.Connection({
          connectionId: k
        }),
        connections: async (k) => i.Connections({
          pagination: (0, Oe.createPagination)(k)
        }),
        allConnections: async () => {
          var U;
          const k = [];
          let C, T;
          do
            C = await i.Connections({
              pagination: (0, Oe.createPagination)(T)
            }), k.push(...C.connections), T = (U = C.pagination) == null ? void 0 : U.nextKey;
          while (T && T.length);
          return hs.QueryConnectionsResponse.fromPartial({
            connections: k,
            height: C.height
          });
        },
        clientConnections: async (k) => i.ClientConnections({
          clientId: k
        }),
        clientState: async (k) => i.ConnectionClientState({
          connectionId: k
        }),
        consensusState: async (k, C) => i.ConnectionConsensusState(hs.QueryConnectionConsensusStateRequest.fromPartial({
          connectionId: k,
          revisionHeight: BigInt(C)
        }))
      },
      transfer: {
        denomTrace: async (k) => f.DenomTrace({ hash: k }),
        denomTraces: async (k) => f.DenomTraces({
          pagination: (0, Oe.createPagination)(k)
        }),
        allDenomTraces: async () => {
          var U;
          const k = [];
          let C, T;
          do
            C = await f.DenomTraces({
              pagination: (0, Oe.createPagination)(T)
            }), k.push(...C.denomTraces), T = (U = C.pagination) == null ? void 0 : U.nextKey;
          while (T && T.length);
          return wu.QueryDenomTracesResponse.fromPartial({
            denomTraces: k
          });
        },
        params: async () => f.Params({})
      },
      verified: {
        channel: {
          channel: async (k, C) => {
            const T = (0, Pi.toAscii)(`channelEnds/ports/${k}/channels/${C}`), { value: U } = await e.queryStoreVerified("ibc", T);
            return U.length ? Hm.Channel.decode(U) : null;
          },
          packetCommitment: async (k, C, T) => {
            const U = (0, Pi.toAscii)(`commitments/ports/${k}/channels/${C}/packets/${T}`), { value: w } = await e.queryStoreVerified("ibc", U);
            return w;
          },
          packetAcknowledgement: async (k, C, T) => {
            const U = (0, Pi.toAscii)(`acks/ports/${k}/channels/${C}/acknowledgements/${T}`), { value: w } = await e.queryStoreVerified("ibc", U);
            return w;
          },
          nextSequenceReceive: async (k, C) => {
            const T = (0, Pi.toAscii)(`seqAcks/ports/${k}/channels/${C}/nextSequenceAck`), { value: U } = await e.queryStoreVerified("ibc", T);
            return U.length ? Mm.Uint64.fromBytes(U).toNumber() : null;
          }
        }
      }
    }
  };
}
Io.setupIbcExtension = Vm;
var Co = {}, gl = {}, ct = {};
Object.defineProperty(ct, "__esModule", { value: !0 });
ct.Params = ct.Minter = ct.protobufPackage = void 0;
const Yt = re, rt = ie;
ct.protobufPackage = "cosmos.mint.v1beta1";
function ms() {
  return {
    inflation: "",
    annualProvisions: ""
  };
}
ct.Minter = {
  typeUrl: "/cosmos.mint.v1beta1.Minter",
  encode(e, n = Yt.BinaryWriter.create()) {
    return e.inflation !== "" && n.uint32(10).string(e.inflation), e.annualProvisions !== "" && n.uint32(18).string(e.annualProvisions), n;
  },
  decode(e, n) {
    const r = e instanceof Yt.BinaryReader ? e : new Yt.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = ms();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.inflation = r.string();
          break;
        case 2:
          i.annualProvisions = r.string();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = ms();
    return (0, rt.isSet)(e.inflation) && (n.inflation = String(e.inflation)), (0, rt.isSet)(e.annualProvisions) && (n.annualProvisions = String(e.annualProvisions)), n;
  },
  toJSON(e) {
    const n = {};
    return e.inflation !== void 0 && (n.inflation = e.inflation), e.annualProvisions !== void 0 && (n.annualProvisions = e.annualProvisions), n;
  },
  fromPartial(e) {
    const n = ms();
    return n.inflation = e.inflation ?? "", n.annualProvisions = e.annualProvisions ?? "", n;
  }
};
function gs() {
  return {
    mintDenom: "",
    inflationRateChange: "",
    inflationMax: "",
    inflationMin: "",
    goalBonded: "",
    blocksPerYear: BigInt(0)
  };
}
ct.Params = {
  typeUrl: "/cosmos.mint.v1beta1.Params",
  encode(e, n = Yt.BinaryWriter.create()) {
    return e.mintDenom !== "" && n.uint32(10).string(e.mintDenom), e.inflationRateChange !== "" && n.uint32(18).string(e.inflationRateChange), e.inflationMax !== "" && n.uint32(26).string(e.inflationMax), e.inflationMin !== "" && n.uint32(34).string(e.inflationMin), e.goalBonded !== "" && n.uint32(42).string(e.goalBonded), e.blocksPerYear !== BigInt(0) && n.uint32(48).uint64(e.blocksPerYear), n;
  },
  decode(e, n) {
    const r = e instanceof Yt.BinaryReader ? e : new Yt.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = gs();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.mintDenom = r.string();
          break;
        case 2:
          i.inflationRateChange = r.string();
          break;
        case 3:
          i.inflationMax = r.string();
          break;
        case 4:
          i.inflationMin = r.string();
          break;
        case 5:
          i.goalBonded = r.string();
          break;
        case 6:
          i.blocksPerYear = r.uint64();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = gs();
    return (0, rt.isSet)(e.mintDenom) && (n.mintDenom = String(e.mintDenom)), (0, rt.isSet)(e.inflationRateChange) && (n.inflationRateChange = String(e.inflationRateChange)), (0, rt.isSet)(e.inflationMax) && (n.inflationMax = String(e.inflationMax)), (0, rt.isSet)(e.inflationMin) && (n.inflationMin = String(e.inflationMin)), (0, rt.isSet)(e.goalBonded) && (n.goalBonded = String(e.goalBonded)), (0, rt.isSet)(e.blocksPerYear) && (n.blocksPerYear = BigInt(e.blocksPerYear.toString())), n;
  },
  toJSON(e) {
    const n = {};
    return e.mintDenom !== void 0 && (n.mintDenom = e.mintDenom), e.inflationRateChange !== void 0 && (n.inflationRateChange = e.inflationRateChange), e.inflationMax !== void 0 && (n.inflationMax = e.inflationMax), e.inflationMin !== void 0 && (n.inflationMin = e.inflationMin), e.goalBonded !== void 0 && (n.goalBonded = e.goalBonded), e.blocksPerYear !== void 0 && (n.blocksPerYear = (e.blocksPerYear || BigInt(0)).toString()), n;
  },
  fromPartial(e) {
    const n = gs();
    return n.mintDenom = e.mintDenom ?? "", n.inflationRateChange = e.inflationRateChange ?? "", n.inflationMax = e.inflationMax ?? "", n.inflationMin = e.inflationMin ?? "", n.goalBonded = e.goalBonded ?? "", e.blocksPerYear !== void 0 && e.blocksPerYear !== null && (n.blocksPerYear = BigInt(e.blocksPerYear.toString())), n;
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryAnnualProvisionsResponse = e.QueryAnnualProvisionsRequest = e.QueryInflationResponse = e.QueryInflationRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.protobufPackage = void 0;
  const n = ct, r = re, t = ie;
  e.protobufPackage = "cosmos.mint.v1beta1";
  function i() {
    return {};
  }
  e.QueryParamsRequest = {
    typeUrl: "/cosmos.mint.v1beta1.QueryParamsRequest",
    encode(N, h = r.BinaryWriter.create()) {
      return h;
    },
    decode(N, h) {
      const P = N instanceof r.BinaryReader ? N : new r.BinaryReader(N);
      let b = h === void 0 ? P.len : P.pos + h;
      const c = i();
      for (; P.pos < b; ) {
        const l = P.uint32();
        switch (l >>> 3) {
          default:
            P.skipType(l & 7);
            break;
        }
      }
      return c;
    },
    fromJSON(N) {
      return i();
    },
    toJSON(N) {
      return {};
    },
    fromPartial(N) {
      return i();
    }
  };
  function f() {
    return {
      params: n.Params.fromPartial({})
    };
  }
  e.QueryParamsResponse = {
    typeUrl: "/cosmos.mint.v1beta1.QueryParamsResponse",
    encode(N, h = r.BinaryWriter.create()) {
      return N.params !== void 0 && n.Params.encode(N.params, h.uint32(10).fork()).ldelim(), h;
    },
    decode(N, h) {
      const P = N instanceof r.BinaryReader ? N : new r.BinaryReader(N);
      let b = h === void 0 ? P.len : P.pos + h;
      const c = f();
      for (; P.pos < b; ) {
        const l = P.uint32();
        switch (l >>> 3) {
          case 1:
            c.params = n.Params.decode(P, P.uint32());
            break;
          default:
            P.skipType(l & 7);
            break;
        }
      }
      return c;
    },
    fromJSON(N) {
      const h = f();
      return (0, t.isSet)(N.params) && (h.params = n.Params.fromJSON(N.params)), h;
    },
    toJSON(N) {
      const h = {};
      return N.params !== void 0 && (h.params = N.params ? n.Params.toJSON(N.params) : void 0), h;
    },
    fromPartial(N) {
      const h = f();
      return N.params !== void 0 && N.params !== null && (h.params = n.Params.fromPartial(N.params)), h;
    }
  };
  function k() {
    return {};
  }
  e.QueryInflationRequest = {
    typeUrl: "/cosmos.mint.v1beta1.QueryInflationRequest",
    encode(N, h = r.BinaryWriter.create()) {
      return h;
    },
    decode(N, h) {
      const P = N instanceof r.BinaryReader ? N : new r.BinaryReader(N);
      let b = h === void 0 ? P.len : P.pos + h;
      const c = k();
      for (; P.pos < b; ) {
        const l = P.uint32();
        switch (l >>> 3) {
          default:
            P.skipType(l & 7);
            break;
        }
      }
      return c;
    },
    fromJSON(N) {
      return k();
    },
    toJSON(N) {
      return {};
    },
    fromPartial(N) {
      return k();
    }
  };
  function C() {
    return {
      inflation: new Uint8Array()
    };
  }
  e.QueryInflationResponse = {
    typeUrl: "/cosmos.mint.v1beta1.QueryInflationResponse",
    encode(N, h = r.BinaryWriter.create()) {
      return N.inflation.length !== 0 && h.uint32(10).bytes(N.inflation), h;
    },
    decode(N, h) {
      const P = N instanceof r.BinaryReader ? N : new r.BinaryReader(N);
      let b = h === void 0 ? P.len : P.pos + h;
      const c = C();
      for (; P.pos < b; ) {
        const l = P.uint32();
        switch (l >>> 3) {
          case 1:
            c.inflation = P.bytes();
            break;
          default:
            P.skipType(l & 7);
            break;
        }
      }
      return c;
    },
    fromJSON(N) {
      const h = C();
      return (0, t.isSet)(N.inflation) && (h.inflation = (0, t.bytesFromBase64)(N.inflation)), h;
    },
    toJSON(N) {
      const h = {};
      return N.inflation !== void 0 && (h.inflation = (0, t.base64FromBytes)(N.inflation !== void 0 ? N.inflation : new Uint8Array())), h;
    },
    fromPartial(N) {
      const h = C();
      return h.inflation = N.inflation ?? new Uint8Array(), h;
    }
  };
  function T() {
    return {};
  }
  e.QueryAnnualProvisionsRequest = {
    typeUrl: "/cosmos.mint.v1beta1.QueryAnnualProvisionsRequest",
    encode(N, h = r.BinaryWriter.create()) {
      return h;
    },
    decode(N, h) {
      const P = N instanceof r.BinaryReader ? N : new r.BinaryReader(N);
      let b = h === void 0 ? P.len : P.pos + h;
      const c = T();
      for (; P.pos < b; ) {
        const l = P.uint32();
        switch (l >>> 3) {
          default:
            P.skipType(l & 7);
            break;
        }
      }
      return c;
    },
    fromJSON(N) {
      return T();
    },
    toJSON(N) {
      return {};
    },
    fromPartial(N) {
      return T();
    }
  };
  function U() {
    return {
      annualProvisions: new Uint8Array()
    };
  }
  e.QueryAnnualProvisionsResponse = {
    typeUrl: "/cosmos.mint.v1beta1.QueryAnnualProvisionsResponse",
    encode(N, h = r.BinaryWriter.create()) {
      return N.annualProvisions.length !== 0 && h.uint32(10).bytes(N.annualProvisions), h;
    },
    decode(N, h) {
      const P = N instanceof r.BinaryReader ? N : new r.BinaryReader(N);
      let b = h === void 0 ? P.len : P.pos + h;
      const c = U();
      for (; P.pos < b; ) {
        const l = P.uint32();
        switch (l >>> 3) {
          case 1:
            c.annualProvisions = P.bytes();
            break;
          default:
            P.skipType(l & 7);
            break;
        }
      }
      return c;
    },
    fromJSON(N) {
      const h = U();
      return (0, t.isSet)(N.annualProvisions) && (h.annualProvisions = (0, t.bytesFromBase64)(N.annualProvisions)), h;
    },
    toJSON(N) {
      const h = {};
      return N.annualProvisions !== void 0 && (h.annualProvisions = (0, t.base64FromBytes)(N.annualProvisions !== void 0 ? N.annualProvisions : new Uint8Array())), h;
    },
    fromPartial(N) {
      const h = U();
      return h.annualProvisions = N.annualProvisions ?? new Uint8Array(), h;
    }
  };
  class w {
    constructor(h) {
      this.rpc = h, this.Params = this.Params.bind(this), this.Inflation = this.Inflation.bind(this), this.AnnualProvisions = this.AnnualProvisions.bind(this);
    }
    Params(h = {}) {
      const P = e.QueryParamsRequest.encode(h).finish();
      return this.rpc.request("cosmos.mint.v1beta1.Query", "Params", P).then((c) => e.QueryParamsResponse.decode(new r.BinaryReader(c)));
    }
    Inflation(h = {}) {
      const P = e.QueryInflationRequest.encode(h).finish();
      return this.rpc.request("cosmos.mint.v1beta1.Query", "Inflation", P).then((c) => e.QueryInflationResponse.decode(new r.BinaryReader(c)));
    }
    AnnualProvisions(h = {}) {
      const P = e.QueryAnnualProvisionsRequest.encode(h).finish();
      return this.rpc.request("cosmos.mint.v1beta1.Query", "AnnualProvisions", P).then((c) => e.QueryAnnualProvisionsResponse.decode(new r.BinaryReader(c)));
    }
  }
  e.QueryClientImpl = w;
})(gl);
Object.defineProperty(Co, "__esModule", { value: !0 });
Co.setupMintExtension = void 0;
const Qm = an, Wm = gl, St = Ge;
function Fm(e) {
  const n = (0, St.createProtobufRpcClient)(e), r = new Wm.QueryClientImpl(n);
  return {
    mint: {
      params: async () => {
        const { params: t } = await r.Params({});
        return (0, Qm.assert)(t), {
          blocksPerYear: t.blocksPerYear,
          goalBonded: (0, St.decodeCosmosSdkDecFromProto)(t.goalBonded),
          inflationMin: (0, St.decodeCosmosSdkDecFromProto)(t.inflationMin),
          inflationMax: (0, St.decodeCosmosSdkDecFromProto)(t.inflationMax),
          inflationRateChange: (0, St.decodeCosmosSdkDecFromProto)(t.inflationRateChange),
          mintDenom: t.mintDenom
        };
      },
      inflation: async () => {
        const { inflation: t } = await r.Inflation({});
        return (0, St.decodeCosmosSdkDecFromProto)(t);
      },
      annualProvisions: async () => {
        const { annualProvisions: t } = await r.AnnualProvisions({});
        return (0, St.decodeCosmosSdkDecFromProto)(t);
      }
    }
  };
}
Co.setupMintExtension = Fm;
var ar = {};
Object.defineProperty(ar, "__esModule", { value: !0 });
ar.createSlashingAminoConverters = ar.isAminoMsgUnjail = void 0;
function Lm(e) {
  return e.type === "cosmos-sdk/MsgUnjail";
}
ar.isAminoMsgUnjail = Lm;
function Gm() {
  throw new Error("Not implemented");
}
ar.createSlashingAminoConverters = Gm;
var No = {}, Sl = {}, lt = {};
Object.defineProperty(lt, "__esModule", { value: !0 });
lt.Params = lt.ValidatorSigningInfo = lt.protobufPackage = void 0;
const Ji = _e, Qt = pn, Xt = re, Ce = ie;
lt.protobufPackage = "cosmos.slashing.v1beta1";
function Ss() {
  return {
    address: "",
    startHeight: BigInt(0),
    indexOffset: BigInt(0),
    jailedUntil: Ji.Timestamp.fromPartial({}),
    tombstoned: !1,
    missedBlocksCounter: BigInt(0)
  };
}
lt.ValidatorSigningInfo = {
  typeUrl: "/cosmos.slashing.v1beta1.ValidatorSigningInfo",
  encode(e, n = Xt.BinaryWriter.create()) {
    return e.address !== "" && n.uint32(10).string(e.address), e.startHeight !== BigInt(0) && n.uint32(16).int64(e.startHeight), e.indexOffset !== BigInt(0) && n.uint32(24).int64(e.indexOffset), e.jailedUntil !== void 0 && Ji.Timestamp.encode(e.jailedUntil, n.uint32(34).fork()).ldelim(), e.tombstoned === !0 && n.uint32(40).bool(e.tombstoned), e.missedBlocksCounter !== BigInt(0) && n.uint32(48).int64(e.missedBlocksCounter), n;
  },
  decode(e, n) {
    const r = e instanceof Xt.BinaryReader ? e : new Xt.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = Ss();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.address = r.string();
          break;
        case 2:
          i.startHeight = r.int64();
          break;
        case 3:
          i.indexOffset = r.int64();
          break;
        case 4:
          i.jailedUntil = Ji.Timestamp.decode(r, r.uint32());
          break;
        case 5:
          i.tombstoned = r.bool();
          break;
        case 6:
          i.missedBlocksCounter = r.int64();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = Ss();
    return (0, Ce.isSet)(e.address) && (n.address = String(e.address)), (0, Ce.isSet)(e.startHeight) && (n.startHeight = BigInt(e.startHeight.toString())), (0, Ce.isSet)(e.indexOffset) && (n.indexOffset = BigInt(e.indexOffset.toString())), (0, Ce.isSet)(e.jailedUntil) && (n.jailedUntil = (0, Ce.fromJsonTimestamp)(e.jailedUntil)), (0, Ce.isSet)(e.tombstoned) && (n.tombstoned = !!e.tombstoned), (0, Ce.isSet)(e.missedBlocksCounter) && (n.missedBlocksCounter = BigInt(e.missedBlocksCounter.toString())), n;
  },
  toJSON(e) {
    const n = {};
    return e.address !== void 0 && (n.address = e.address), e.startHeight !== void 0 && (n.startHeight = (e.startHeight || BigInt(0)).toString()), e.indexOffset !== void 0 && (n.indexOffset = (e.indexOffset || BigInt(0)).toString()), e.jailedUntil !== void 0 && (n.jailedUntil = (0, Ce.fromTimestamp)(e.jailedUntil).toISOString()), e.tombstoned !== void 0 && (n.tombstoned = e.tombstoned), e.missedBlocksCounter !== void 0 && (n.missedBlocksCounter = (e.missedBlocksCounter || BigInt(0)).toString()), n;
  },
  fromPartial(e) {
    const n = Ss();
    return n.address = e.address ?? "", e.startHeight !== void 0 && e.startHeight !== null && (n.startHeight = BigInt(e.startHeight.toString())), e.indexOffset !== void 0 && e.indexOffset !== null && (n.indexOffset = BigInt(e.indexOffset.toString())), e.jailedUntil !== void 0 && e.jailedUntil !== null && (n.jailedUntil = Ji.Timestamp.fromPartial(e.jailedUntil)), n.tombstoned = e.tombstoned ?? !1, e.missedBlocksCounter !== void 0 && e.missedBlocksCounter !== null && (n.missedBlocksCounter = BigInt(e.missedBlocksCounter.toString())), n;
  }
};
function ks() {
  return {
    signedBlocksWindow: BigInt(0),
    minSignedPerWindow: new Uint8Array(),
    downtimeJailDuration: Qt.Duration.fromPartial({}),
    slashFractionDoubleSign: new Uint8Array(),
    slashFractionDowntime: new Uint8Array()
  };
}
lt.Params = {
  typeUrl: "/cosmos.slashing.v1beta1.Params",
  encode(e, n = Xt.BinaryWriter.create()) {
    return e.signedBlocksWindow !== BigInt(0) && n.uint32(8).int64(e.signedBlocksWindow), e.minSignedPerWindow.length !== 0 && n.uint32(18).bytes(e.minSignedPerWindow), e.downtimeJailDuration !== void 0 && Qt.Duration.encode(e.downtimeJailDuration, n.uint32(26).fork()).ldelim(), e.slashFractionDoubleSign.length !== 0 && n.uint32(34).bytes(e.slashFractionDoubleSign), e.slashFractionDowntime.length !== 0 && n.uint32(42).bytes(e.slashFractionDowntime), n;
  },
  decode(e, n) {
    const r = e instanceof Xt.BinaryReader ? e : new Xt.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = ks();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.signedBlocksWindow = r.int64();
          break;
        case 2:
          i.minSignedPerWindow = r.bytes();
          break;
        case 3:
          i.downtimeJailDuration = Qt.Duration.decode(r, r.uint32());
          break;
        case 4:
          i.slashFractionDoubleSign = r.bytes();
          break;
        case 5:
          i.slashFractionDowntime = r.bytes();
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = ks();
    return (0, Ce.isSet)(e.signedBlocksWindow) && (n.signedBlocksWindow = BigInt(e.signedBlocksWindow.toString())), (0, Ce.isSet)(e.minSignedPerWindow) && (n.minSignedPerWindow = (0, Ce.bytesFromBase64)(e.minSignedPerWindow)), (0, Ce.isSet)(e.downtimeJailDuration) && (n.downtimeJailDuration = Qt.Duration.fromJSON(e.downtimeJailDuration)), (0, Ce.isSet)(e.slashFractionDoubleSign) && (n.slashFractionDoubleSign = (0, Ce.bytesFromBase64)(e.slashFractionDoubleSign)), (0, Ce.isSet)(e.slashFractionDowntime) && (n.slashFractionDowntime = (0, Ce.bytesFromBase64)(e.slashFractionDowntime)), n;
  },
  toJSON(e) {
    const n = {};
    return e.signedBlocksWindow !== void 0 && (n.signedBlocksWindow = (e.signedBlocksWindow || BigInt(0)).toString()), e.minSignedPerWindow !== void 0 && (n.minSignedPerWindow = (0, Ce.base64FromBytes)(e.minSignedPerWindow !== void 0 ? e.minSignedPerWindow : new Uint8Array())), e.downtimeJailDuration !== void 0 && (n.downtimeJailDuration = e.downtimeJailDuration ? Qt.Duration.toJSON(e.downtimeJailDuration) : void 0), e.slashFractionDoubleSign !== void 0 && (n.slashFractionDoubleSign = (0, Ce.base64FromBytes)(e.slashFractionDoubleSign !== void 0 ? e.slashFractionDoubleSign : new Uint8Array())), e.slashFractionDowntime !== void 0 && (n.slashFractionDowntime = (0, Ce.base64FromBytes)(e.slashFractionDowntime !== void 0 ? e.slashFractionDowntime : new Uint8Array())), n;
  },
  fromPartial(e) {
    const n = ks();
    return e.signedBlocksWindow !== void 0 && e.signedBlocksWindow !== null && (n.signedBlocksWindow = BigInt(e.signedBlocksWindow.toString())), n.minSignedPerWindow = e.minSignedPerWindow ?? new Uint8Array(), e.downtimeJailDuration !== void 0 && e.downtimeJailDuration !== null && (n.downtimeJailDuration = Qt.Duration.fromPartial(e.downtimeJailDuration)), n.slashFractionDoubleSign = e.slashFractionDoubleSign ?? new Uint8Array(), n.slashFractionDowntime = e.slashFractionDowntime ?? new Uint8Array(), n;
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QuerySigningInfosResponse = e.QuerySigningInfosRequest = e.QuerySigningInfoResponse = e.QuerySigningInfoRequest = e.QueryParamsResponse = e.QueryParamsRequest = e.protobufPackage = void 0;
  const n = Ae, r = lt, t = re, i = ie;
  e.protobufPackage = "cosmos.slashing.v1beta1";
  function f() {
    return {};
  }
  e.QueryParamsRequest = {
    typeUrl: "/cosmos.slashing.v1beta1.QueryParamsRequest",
    encode(h, P = t.BinaryWriter.create()) {
      return P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = f();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      return f();
    },
    toJSON(h) {
      return {};
    },
    fromPartial(h) {
      return f();
    }
  };
  function k() {
    return {
      params: r.Params.fromPartial({})
    };
  }
  e.QueryParamsResponse = {
    typeUrl: "/cosmos.slashing.v1beta1.QueryParamsResponse",
    encode(h, P = t.BinaryWriter.create()) {
      return h.params !== void 0 && r.Params.encode(h.params, P.uint32(10).fork()).ldelim(), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = k();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.params = r.Params.decode(b, b.uint32());
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = k();
      return (0, i.isSet)(h.params) && (P.params = r.Params.fromJSON(h.params)), P;
    },
    toJSON(h) {
      const P = {};
      return h.params !== void 0 && (P.params = h.params ? r.Params.toJSON(h.params) : void 0), P;
    },
    fromPartial(h) {
      const P = k();
      return h.params !== void 0 && h.params !== null && (P.params = r.Params.fromPartial(h.params)), P;
    }
  };
  function C() {
    return {
      consAddress: ""
    };
  }
  e.QuerySigningInfoRequest = {
    typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfoRequest",
    encode(h, P = t.BinaryWriter.create()) {
      return h.consAddress !== "" && P.uint32(10).string(h.consAddress), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = C();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.consAddress = b.string();
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = C();
      return (0, i.isSet)(h.consAddress) && (P.consAddress = String(h.consAddress)), P;
    },
    toJSON(h) {
      const P = {};
      return h.consAddress !== void 0 && (P.consAddress = h.consAddress), P;
    },
    fromPartial(h) {
      const P = C();
      return P.consAddress = h.consAddress ?? "", P;
    }
  };
  function T() {
    return {
      valSigningInfo: r.ValidatorSigningInfo.fromPartial({})
    };
  }
  e.QuerySigningInfoResponse = {
    typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfoResponse",
    encode(h, P = t.BinaryWriter.create()) {
      return h.valSigningInfo !== void 0 && r.ValidatorSigningInfo.encode(h.valSigningInfo, P.uint32(10).fork()).ldelim(), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = T();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.valSigningInfo = r.ValidatorSigningInfo.decode(b, b.uint32());
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = T();
      return (0, i.isSet)(h.valSigningInfo) && (P.valSigningInfo = r.ValidatorSigningInfo.fromJSON(h.valSigningInfo)), P;
    },
    toJSON(h) {
      const P = {};
      return h.valSigningInfo !== void 0 && (P.valSigningInfo = h.valSigningInfo ? r.ValidatorSigningInfo.toJSON(h.valSigningInfo) : void 0), P;
    },
    fromPartial(h) {
      const P = T();
      return h.valSigningInfo !== void 0 && h.valSigningInfo !== null && (P.valSigningInfo = r.ValidatorSigningInfo.fromPartial(h.valSigningInfo)), P;
    }
  };
  function U() {
    return {
      pagination: void 0
    };
  }
  e.QuerySigningInfosRequest = {
    typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfosRequest",
    encode(h, P = t.BinaryWriter.create()) {
      return h.pagination !== void 0 && n.PageRequest.encode(h.pagination, P.uint32(10).fork()).ldelim(), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = U();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.pagination = n.PageRequest.decode(b, b.uint32());
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = U();
      return (0, i.isSet)(h.pagination) && (P.pagination = n.PageRequest.fromJSON(h.pagination)), P;
    },
    toJSON(h) {
      const P = {};
      return h.pagination !== void 0 && (P.pagination = h.pagination ? n.PageRequest.toJSON(h.pagination) : void 0), P;
    },
    fromPartial(h) {
      const P = U();
      return h.pagination !== void 0 && h.pagination !== null && (P.pagination = n.PageRequest.fromPartial(h.pagination)), P;
    }
  };
  function w() {
    return {
      info: [],
      pagination: void 0
    };
  }
  e.QuerySigningInfosResponse = {
    typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfosResponse",
    encode(h, P = t.BinaryWriter.create()) {
      for (const b of h.info)
        r.ValidatorSigningInfo.encode(b, P.uint32(10).fork()).ldelim();
      return h.pagination !== void 0 && n.PageResponse.encode(h.pagination, P.uint32(18).fork()).ldelim(), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = w();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.info.push(r.ValidatorSigningInfo.decode(b, b.uint32()));
            break;
          case 2:
            l.pagination = n.PageResponse.decode(b, b.uint32());
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = w();
      return Array.isArray(h == null ? void 0 : h.info) && (P.info = h.info.map((b) => r.ValidatorSigningInfo.fromJSON(b))), (0, i.isSet)(h.pagination) && (P.pagination = n.PageResponse.fromJSON(h.pagination)), P;
    },
    toJSON(h) {
      const P = {};
      return h.info ? P.info = h.info.map((b) => b ? r.ValidatorSigningInfo.toJSON(b) : void 0) : P.info = [], h.pagination !== void 0 && (P.pagination = h.pagination ? n.PageResponse.toJSON(h.pagination) : void 0), P;
    },
    fromPartial(h) {
      var b;
      const P = w();
      return P.info = ((b = h.info) == null ? void 0 : b.map((c) => r.ValidatorSigningInfo.fromPartial(c))) || [], h.pagination !== void 0 && h.pagination !== null && (P.pagination = n.PageResponse.fromPartial(h.pagination)), P;
    }
  };
  class N {
    constructor(P) {
      this.rpc = P, this.Params = this.Params.bind(this), this.SigningInfo = this.SigningInfo.bind(this), this.SigningInfos = this.SigningInfos.bind(this);
    }
    Params(P = {}) {
      const b = e.QueryParamsRequest.encode(P).finish();
      return this.rpc.request("cosmos.slashing.v1beta1.Query", "Params", b).then((l) => e.QueryParamsResponse.decode(new t.BinaryReader(l)));
    }
    SigningInfo(P) {
      const b = e.QuerySigningInfoRequest.encode(P).finish();
      return this.rpc.request("cosmos.slashing.v1beta1.Query", "SigningInfo", b).then((l) => e.QuerySigningInfoResponse.decode(new t.BinaryReader(l)));
    }
    SigningInfos(P = {
      pagination: n.PageRequest.fromPartial({})
    }) {
      const b = e.QuerySigningInfosRequest.encode(P).finish();
      return this.rpc.request("cosmos.slashing.v1beta1.Query", "SigningInfos", b).then((l) => e.QuerySigningInfosResponse.decode(new t.BinaryReader(l)));
    }
  }
  e.QueryClientImpl = N;
})(Sl);
Object.defineProperty(No, "__esModule", { value: !0 });
No.setupSlashingExtension = void 0;
const $m = Sl, _u = Ge;
function zm(e) {
  const n = (0, _u.createProtobufRpcClient)(e), r = new $m.QueryClientImpl(n);
  return {
    slashing: {
      signingInfo: async (t) => await r.SigningInfo({
        consAddress: t
      }),
      signingInfos: async (t) => await r.SigningInfos({
        pagination: (0, _u.createPagination)(t)
      }),
      params: async () => await r.Params({})
    }
  };
}
No.setupSlashingExtension = zm;
var Ve = {};
Object.defineProperty(Ve, "__esModule", { value: !0 });
Ve.createStakingAminoConverters = Ve.isAminoMsgUndelegate = Ve.isAminoMsgBeginRedelegate = Ve.isAminoMsgDelegate = Ve.isAminoMsgEditValidator = Ve.isAminoMsgCreateValidator = Ve.protoDecimalToJson = void 0;
const kl = mt, Eu = Nt, jn = an;
function Mr(e) {
  const n = kl.Decimal.fromAtomics(e, 18), [r, t] = n.toString().split(".");
  return `${r}.${(t ?? "").padEnd(18, "0")}`;
}
Ve.protoDecimalToJson = Mr;
function vi(e) {
  return kl.Decimal.fromUserInput(e, 18).atomics;
}
function Km(e) {
  return e.type === "cosmos-sdk/MsgCreateValidator";
}
Ve.isAminoMsgCreateValidator = Km;
function xm(e) {
  return e.type === "cosmos-sdk/MsgEditValidator";
}
Ve.isAminoMsgEditValidator = xm;
function Zm(e) {
  return e.type === "cosmos-sdk/MsgDelegate";
}
Ve.isAminoMsgDelegate = Zm;
function Ym(e) {
  return e.type === "cosmos-sdk/MsgBeginRedelegate";
}
Ve.isAminoMsgBeginRedelegate = Ym;
function Xm(e) {
  return e.type === "cosmos-sdk/MsgUndelegate";
}
Ve.isAminoMsgUndelegate = Xm;
function jm() {
  return {
    "/cosmos.staking.v1beta1.MsgBeginRedelegate": {
      aminoType: "cosmos-sdk/MsgBeginRedelegate",
      toAmino: ({ delegatorAddress: e, validatorSrcAddress: n, validatorDstAddress: r, amount: t }) => ((0, jn.assertDefinedAndNotNull)(t, "missing amount"), {
        delegator_address: e,
        validator_src_address: n,
        validator_dst_address: r,
        amount: t
      }),
      fromAmino: ({ delegator_address: e, validator_src_address: n, validator_dst_address: r, amount: t }) => ({
        delegatorAddress: e,
        validatorSrcAddress: n,
        validatorDstAddress: r,
        amount: t
      })
    },
    "/cosmos.staking.v1beta1.MsgCreateValidator": {
      aminoType: "cosmos-sdk/MsgCreateValidator",
      toAmino: ({ description: e, commission: n, minSelfDelegation: r, delegatorAddress: t, validatorAddress: i, pubkey: f, value: k }) => ((0, jn.assertDefinedAndNotNull)(e, "missing description"), (0, jn.assertDefinedAndNotNull)(n, "missing commission"), (0, jn.assertDefinedAndNotNull)(f, "missing pubkey"), (0, jn.assertDefinedAndNotNull)(k, "missing value"), {
        description: {
          moniker: e.moniker,
          identity: e.identity,
          website: e.website,
          security_contact: e.securityContact,
          details: e.details
        },
        commission: {
          rate: Mr(n.rate),
          max_rate: Mr(n.maxRate),
          max_change_rate: Mr(n.maxChangeRate)
        },
        min_self_delegation: r,
        delegator_address: t,
        validator_address: i,
        pubkey: (0, Eu.decodePubkey)(f),
        value: k
      }),
      fromAmino: ({ description: e, commission: n, min_self_delegation: r, delegator_address: t, validator_address: i, pubkey: f, value: k }) => ({
        description: {
          moniker: e.moniker,
          identity: e.identity,
          website: e.website,
          securityContact: e.security_contact,
          details: e.details
        },
        commission: {
          rate: vi(n.rate),
          maxRate: vi(n.max_rate),
          maxChangeRate: vi(n.max_change_rate)
        },
        minSelfDelegation: r,
        delegatorAddress: t,
        validatorAddress: i,
        pubkey: (0, Eu.encodePubkey)(f),
        value: k
      })
    },
    "/cosmos.staking.v1beta1.MsgDelegate": {
      aminoType: "cosmos-sdk/MsgDelegate",
      toAmino: ({ delegatorAddress: e, validatorAddress: n, amount: r }) => ((0, jn.assertDefinedAndNotNull)(r, "missing amount"), {
        delegator_address: e,
        validator_address: n,
        amount: r
      }),
      fromAmino: ({ delegator_address: e, validator_address: n, amount: r }) => ({
        delegatorAddress: e,
        validatorAddress: n,
        amount: r
      })
    },
    "/cosmos.staking.v1beta1.MsgEditValidator": {
      aminoType: "cosmos-sdk/MsgEditValidator",
      toAmino: ({ description: e, commissionRate: n, minSelfDelegation: r, validatorAddress: t }) => ((0, jn.assertDefinedAndNotNull)(e, "missing description"), {
        description: {
          moniker: e.moniker,
          identity: e.identity,
          website: e.website,
          security_contact: e.securityContact,
          details: e.details
        },
        // empty string in the protobuf document means "do not change"
        commission_rate: n ? Mr(n) : void 0,
        // empty string in the protobuf document means "do not change"
        min_self_delegation: r || void 0,
        validator_address: t
      }),
      fromAmino: ({ description: e, commission_rate: n, min_self_delegation: r, validator_address: t }) => ({
        description: {
          moniker: e.moniker,
          identity: e.identity,
          website: e.website,
          securityContact: e.security_contact,
          details: e.details
        },
        // empty string in the protobuf document means "do not change"
        commissionRate: n ? vi(n) : "",
        // empty string in the protobuf document means "do not change"
        minSelfDelegation: r ?? "",
        validatorAddress: t
      })
    },
    "/cosmos.staking.v1beta1.MsgUndelegate": {
      aminoType: "cosmos-sdk/MsgUndelegate",
      toAmino: ({ delegatorAddress: e, validatorAddress: n, amount: r }) => ((0, jn.assertDefinedAndNotNull)(r, "missing amount"), {
        delegator_address: e,
        validator_address: n,
        amount: r
      }),
      fromAmino: ({ delegator_address: e, validator_address: n, amount: r }) => ({
        delegatorAddress: e,
        validatorAddress: n,
        amount: r
      })
    }
  };
}
Ve.createStakingAminoConverters = jm;
var je = {}, vd = {}, Rd = {}, Bd = {}, Pl = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.HashedParams = e.VersionParams = e.ValidatorParams = e.EvidenceParams = e.BlockParams = e.ConsensusParams = e.protobufPackage = void 0;
  const n = pn, r = re, t = ie;
  e.protobufPackage = "tendermint.types";
  function i() {
    return {
      block: void 0,
      evidence: void 0,
      validator: void 0,
      version: void 0
    };
  }
  e.ConsensusParams = {
    typeUrl: "/tendermint.types.ConsensusParams",
    encode(w, N = r.BinaryWriter.create()) {
      return w.block !== void 0 && e.BlockParams.encode(w.block, N.uint32(10).fork()).ldelim(), w.evidence !== void 0 && e.EvidenceParams.encode(w.evidence, N.uint32(18).fork()).ldelim(), w.validator !== void 0 && e.ValidatorParams.encode(w.validator, N.uint32(26).fork()).ldelim(), w.version !== void 0 && e.VersionParams.encode(w.version, N.uint32(34).fork()).ldelim(), N;
    },
    decode(w, N) {
      const h = w instanceof r.BinaryReader ? w : new r.BinaryReader(w);
      let P = N === void 0 ? h.len : h.pos + N;
      const b = i();
      for (; h.pos < P; ) {
        const c = h.uint32();
        switch (c >>> 3) {
          case 1:
            b.block = e.BlockParams.decode(h, h.uint32());
            break;
          case 2:
            b.evidence = e.EvidenceParams.decode(h, h.uint32());
            break;
          case 3:
            b.validator = e.ValidatorParams.decode(h, h.uint32());
            break;
          case 4:
            b.version = e.VersionParams.decode(h, h.uint32());
            break;
          default:
            h.skipType(c & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(w) {
      const N = i();
      return (0, t.isSet)(w.block) && (N.block = e.BlockParams.fromJSON(w.block)), (0, t.isSet)(w.evidence) && (N.evidence = e.EvidenceParams.fromJSON(w.evidence)), (0, t.isSet)(w.validator) && (N.validator = e.ValidatorParams.fromJSON(w.validator)), (0, t.isSet)(w.version) && (N.version = e.VersionParams.fromJSON(w.version)), N;
    },
    toJSON(w) {
      const N = {};
      return w.block !== void 0 && (N.block = w.block ? e.BlockParams.toJSON(w.block) : void 0), w.evidence !== void 0 && (N.evidence = w.evidence ? e.EvidenceParams.toJSON(w.evidence) : void 0), w.validator !== void 0 && (N.validator = w.validator ? e.ValidatorParams.toJSON(w.validator) : void 0), w.version !== void 0 && (N.version = w.version ? e.VersionParams.toJSON(w.version) : void 0), N;
    },
    fromPartial(w) {
      const N = i();
      return w.block !== void 0 && w.block !== null && (N.block = e.BlockParams.fromPartial(w.block)), w.evidence !== void 0 && w.evidence !== null && (N.evidence = e.EvidenceParams.fromPartial(w.evidence)), w.validator !== void 0 && w.validator !== null && (N.validator = e.ValidatorParams.fromPartial(w.validator)), w.version !== void 0 && w.version !== null && (N.version = e.VersionParams.fromPartial(w.version)), N;
    }
  };
  function f() {
    return {
      maxBytes: BigInt(0),
      maxGas: BigInt(0)
    };
  }
  e.BlockParams = {
    typeUrl: "/tendermint.types.BlockParams",
    encode(w, N = r.BinaryWriter.create()) {
      return w.maxBytes !== BigInt(0) && N.uint32(8).int64(w.maxBytes), w.maxGas !== BigInt(0) && N.uint32(16).int64(w.maxGas), N;
    },
    decode(w, N) {
      const h = w instanceof r.BinaryReader ? w : new r.BinaryReader(w);
      let P = N === void 0 ? h.len : h.pos + N;
      const b = f();
      for (; h.pos < P; ) {
        const c = h.uint32();
        switch (c >>> 3) {
          case 1:
            b.maxBytes = h.int64();
            break;
          case 2:
            b.maxGas = h.int64();
            break;
          default:
            h.skipType(c & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(w) {
      const N = f();
      return (0, t.isSet)(w.maxBytes) && (N.maxBytes = BigInt(w.maxBytes.toString())), (0, t.isSet)(w.maxGas) && (N.maxGas = BigInt(w.maxGas.toString())), N;
    },
    toJSON(w) {
      const N = {};
      return w.maxBytes !== void 0 && (N.maxBytes = (w.maxBytes || BigInt(0)).toString()), w.maxGas !== void 0 && (N.maxGas = (w.maxGas || BigInt(0)).toString()), N;
    },
    fromPartial(w) {
      const N = f();
      return w.maxBytes !== void 0 && w.maxBytes !== null && (N.maxBytes = BigInt(w.maxBytes.toString())), w.maxGas !== void 0 && w.maxGas !== null && (N.maxGas = BigInt(w.maxGas.toString())), N;
    }
  };
  function k() {
    return {
      maxAgeNumBlocks: BigInt(0),
      maxAgeDuration: n.Duration.fromPartial({}),
      maxBytes: BigInt(0)
    };
  }
  e.EvidenceParams = {
    typeUrl: "/tendermint.types.EvidenceParams",
    encode(w, N = r.BinaryWriter.create()) {
      return w.maxAgeNumBlocks !== BigInt(0) && N.uint32(8).int64(w.maxAgeNumBlocks), w.maxAgeDuration !== void 0 && n.Duration.encode(w.maxAgeDuration, N.uint32(18).fork()).ldelim(), w.maxBytes !== BigInt(0) && N.uint32(24).int64(w.maxBytes), N;
    },
    decode(w, N) {
      const h = w instanceof r.BinaryReader ? w : new r.BinaryReader(w);
      let P = N === void 0 ? h.len : h.pos + N;
      const b = k();
      for (; h.pos < P; ) {
        const c = h.uint32();
        switch (c >>> 3) {
          case 1:
            b.maxAgeNumBlocks = h.int64();
            break;
          case 2:
            b.maxAgeDuration = n.Duration.decode(h, h.uint32());
            break;
          case 3:
            b.maxBytes = h.int64();
            break;
          default:
            h.skipType(c & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(w) {
      const N = k();
      return (0, t.isSet)(w.maxAgeNumBlocks) && (N.maxAgeNumBlocks = BigInt(w.maxAgeNumBlocks.toString())), (0, t.isSet)(w.maxAgeDuration) && (N.maxAgeDuration = n.Duration.fromJSON(w.maxAgeDuration)), (0, t.isSet)(w.maxBytes) && (N.maxBytes = BigInt(w.maxBytes.toString())), N;
    },
    toJSON(w) {
      const N = {};
      return w.maxAgeNumBlocks !== void 0 && (N.maxAgeNumBlocks = (w.maxAgeNumBlocks || BigInt(0)).toString()), w.maxAgeDuration !== void 0 && (N.maxAgeDuration = w.maxAgeDuration ? n.Duration.toJSON(w.maxAgeDuration) : void 0), w.maxBytes !== void 0 && (N.maxBytes = (w.maxBytes || BigInt(0)).toString()), N;
    },
    fromPartial(w) {
      const N = k();
      return w.maxAgeNumBlocks !== void 0 && w.maxAgeNumBlocks !== null && (N.maxAgeNumBlocks = BigInt(w.maxAgeNumBlocks.toString())), w.maxAgeDuration !== void 0 && w.maxAgeDuration !== null && (N.maxAgeDuration = n.Duration.fromPartial(w.maxAgeDuration)), w.maxBytes !== void 0 && w.maxBytes !== null && (N.maxBytes = BigInt(w.maxBytes.toString())), N;
    }
  };
  function C() {
    return {
      pubKeyTypes: []
    };
  }
  e.ValidatorParams = {
    typeUrl: "/tendermint.types.ValidatorParams",
    encode(w, N = r.BinaryWriter.create()) {
      for (const h of w.pubKeyTypes)
        N.uint32(10).string(h);
      return N;
    },
    decode(w, N) {
      const h = w instanceof r.BinaryReader ? w : new r.BinaryReader(w);
      let P = N === void 0 ? h.len : h.pos + N;
      const b = C();
      for (; h.pos < P; ) {
        const c = h.uint32();
        switch (c >>> 3) {
          case 1:
            b.pubKeyTypes.push(h.string());
            break;
          default:
            h.skipType(c & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(w) {
      const N = C();
      return Array.isArray(w == null ? void 0 : w.pubKeyTypes) && (N.pubKeyTypes = w.pubKeyTypes.map((h) => String(h))), N;
    },
    toJSON(w) {
      const N = {};
      return w.pubKeyTypes ? N.pubKeyTypes = w.pubKeyTypes.map((h) => h) : N.pubKeyTypes = [], N;
    },
    fromPartial(w) {
      var h;
      const N = C();
      return N.pubKeyTypes = ((h = w.pubKeyTypes) == null ? void 0 : h.map((P) => P)) || [], N;
    }
  };
  function T() {
    return {
      app: BigInt(0)
    };
  }
  e.VersionParams = {
    typeUrl: "/tendermint.types.VersionParams",
    encode(w, N = r.BinaryWriter.create()) {
      return w.app !== BigInt(0) && N.uint32(8).uint64(w.app), N;
    },
    decode(w, N) {
      const h = w instanceof r.BinaryReader ? w : new r.BinaryReader(w);
      let P = N === void 0 ? h.len : h.pos + N;
      const b = T();
      for (; h.pos < P; ) {
        const c = h.uint32();
        switch (c >>> 3) {
          case 1:
            b.app = h.uint64();
            break;
          default:
            h.skipType(c & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(w) {
      const N = T();
      return (0, t.isSet)(w.app) && (N.app = BigInt(w.app.toString())), N;
    },
    toJSON(w) {
      const N = {};
      return w.app !== void 0 && (N.app = (w.app || BigInt(0)).toString()), N;
    },
    fromPartial(w) {
      const N = T();
      return w.app !== void 0 && w.app !== null && (N.app = BigInt(w.app.toString())), N;
    }
  };
  function U() {
    return {
      blockMaxBytes: BigInt(0),
      blockMaxGas: BigInt(0)
    };
  }
  e.HashedParams = {
    typeUrl: "/tendermint.types.HashedParams",
    encode(w, N = r.BinaryWriter.create()) {
      return w.blockMaxBytes !== BigInt(0) && N.uint32(8).int64(w.blockMaxBytes), w.blockMaxGas !== BigInt(0) && N.uint32(16).int64(w.blockMaxGas), N;
    },
    decode(w, N) {
      const h = w instanceof r.BinaryReader ? w : new r.BinaryReader(w);
      let P = N === void 0 ? h.len : h.pos + N;
      const b = U();
      for (; h.pos < P; ) {
        const c = h.uint32();
        switch (c >>> 3) {
          case 1:
            b.blockMaxBytes = h.int64();
            break;
          case 2:
            b.blockMaxGas = h.int64();
            break;
          default:
            h.skipType(c & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(w) {
      const N = U();
      return (0, t.isSet)(w.blockMaxBytes) && (N.blockMaxBytes = BigInt(w.blockMaxBytes.toString())), (0, t.isSet)(w.blockMaxGas) && (N.blockMaxGas = BigInt(w.blockMaxGas.toString())), N;
    },
    toJSON(w) {
      const N = {};
      return w.blockMaxBytes !== void 0 && (N.blockMaxBytes = (w.blockMaxBytes || BigInt(0)).toString()), w.blockMaxGas !== void 0 && (N.blockMaxGas = (w.blockMaxGas || BigInt(0)).toString()), N;
    },
    fromPartial(w) {
      const N = U();
      return w.blockMaxBytes !== void 0 && w.blockMaxBytes !== null && (N.blockMaxBytes = BigInt(w.blockMaxBytes.toString())), w.blockMaxGas !== void 0 && w.blockMaxGas !== null && (N.blockMaxGas = BigInt(w.blockMaxGas.toString())), N;
    }
  };
})(Pl);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ResponsePrepareProposal = e.ResponseApplySnapshotChunk = e.ResponseLoadSnapshotChunk = e.ResponseOfferSnapshot = e.ResponseListSnapshots = e.ResponseCommit = e.ResponseEndBlock = e.ResponseDeliverTx = e.ResponseCheckTx = e.ResponseBeginBlock = e.ResponseQuery = e.ResponseInitChain = e.ResponseInfo = e.ResponseFlush = e.ResponseEcho = e.ResponseException = e.Response = e.RequestProcessProposal = e.RequestPrepareProposal = e.RequestApplySnapshotChunk = e.RequestLoadSnapshotChunk = e.RequestOfferSnapshot = e.RequestListSnapshots = e.RequestCommit = e.RequestEndBlock = e.RequestDeliverTx = e.RequestCheckTx = e.RequestBeginBlock = e.RequestQuery = e.RequestInitChain = e.RequestInfo = e.RequestFlush = e.RequestEcho = e.Request = e.misbehaviorTypeToJSON = e.misbehaviorTypeFromJSON = e.MisbehaviorType = e.responseProcessProposal_ProposalStatusToJSON = e.responseProcessProposal_ProposalStatusFromJSON = e.ResponseProcessProposal_ProposalStatus = e.responseApplySnapshotChunk_ResultToJSON = e.responseApplySnapshotChunk_ResultFromJSON = e.ResponseApplySnapshotChunk_Result = e.responseOfferSnapshot_ResultToJSON = e.responseOfferSnapshot_ResultFromJSON = e.ResponseOfferSnapshot_Result = e.checkTxTypeToJSON = e.checkTxTypeFromJSON = e.CheckTxType = e.protobufPackage = void 0, e.ABCIApplicationClientImpl = e.Snapshot = e.Misbehavior = e.ExtendedVoteInfo = e.VoteInfo = e.ValidatorUpdate = e.Validator = e.TxResult = e.EventAttribute = e.Event = e.ExtendedCommitInfo = e.CommitInfo = e.ResponseProcessProposal = void 0;
  const n = _e, r = Pl, t = _t, i = Pd, f = At, k = re, C = ie;
  e.protobufPackage = "tendermint.abci";
  var T;
  (function(d) {
    d[d.NEW = 0] = "NEW", d[d.RECHECK = 1] = "RECHECK", d[d.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(T || (e.CheckTxType = T = {}));
  function U(d) {
    switch (d) {
      case 0:
      case "NEW":
        return T.NEW;
      case 1:
      case "RECHECK":
        return T.RECHECK;
      case -1:
      case "UNRECOGNIZED":
      default:
        return T.UNRECOGNIZED;
    }
  }
  e.checkTxTypeFromJSON = U;
  function w(d) {
    switch (d) {
      case T.NEW:
        return "NEW";
      case T.RECHECK:
        return "RECHECK";
      case T.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.checkTxTypeToJSON = w;
  var N;
  (function(d) {
    d[d.UNKNOWN = 0] = "UNKNOWN", d[d.ACCEPT = 1] = "ACCEPT", d[d.ABORT = 2] = "ABORT", d[d.REJECT = 3] = "REJECT", d[d.REJECT_FORMAT = 4] = "REJECT_FORMAT", d[d.REJECT_SENDER = 5] = "REJECT_SENDER", d[d.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(N || (e.ResponseOfferSnapshot_Result = N = {}));
  function h(d) {
    switch (d) {
      case 0:
      case "UNKNOWN":
        return N.UNKNOWN;
      case 1:
      case "ACCEPT":
        return N.ACCEPT;
      case 2:
      case "ABORT":
        return N.ABORT;
      case 3:
      case "REJECT":
        return N.REJECT;
      case 4:
      case "REJECT_FORMAT":
        return N.REJECT_FORMAT;
      case 5:
      case "REJECT_SENDER":
        return N.REJECT_SENDER;
      case -1:
      case "UNRECOGNIZED":
      default:
        return N.UNRECOGNIZED;
    }
  }
  e.responseOfferSnapshot_ResultFromJSON = h;
  function P(d) {
    switch (d) {
      case N.UNKNOWN:
        return "UNKNOWN";
      case N.ACCEPT:
        return "ACCEPT";
      case N.ABORT:
        return "ABORT";
      case N.REJECT:
        return "REJECT";
      case N.REJECT_FORMAT:
        return "REJECT_FORMAT";
      case N.REJECT_SENDER:
        return "REJECT_SENDER";
      case N.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.responseOfferSnapshot_ResultToJSON = P;
  var b;
  (function(d) {
    d[d.UNKNOWN = 0] = "UNKNOWN", d[d.ACCEPT = 1] = "ACCEPT", d[d.ABORT = 2] = "ABORT", d[d.RETRY = 3] = "RETRY", d[d.RETRY_SNAPSHOT = 4] = "RETRY_SNAPSHOT", d[d.REJECT_SNAPSHOT = 5] = "REJECT_SNAPSHOT", d[d.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(b || (e.ResponseApplySnapshotChunk_Result = b = {}));
  function c(d) {
    switch (d) {
      case 0:
      case "UNKNOWN":
        return b.UNKNOWN;
      case 1:
      case "ACCEPT":
        return b.ACCEPT;
      case 2:
      case "ABORT":
        return b.ABORT;
      case 3:
      case "RETRY":
        return b.RETRY;
      case 4:
      case "RETRY_SNAPSHOT":
        return b.RETRY_SNAPSHOT;
      case 5:
      case "REJECT_SNAPSHOT":
        return b.REJECT_SNAPSHOT;
      case -1:
      case "UNRECOGNIZED":
      default:
        return b.UNRECOGNIZED;
    }
  }
  e.responseApplySnapshotChunk_ResultFromJSON = c;
  function l(d) {
    switch (d) {
      case b.UNKNOWN:
        return "UNKNOWN";
      case b.ACCEPT:
        return "ACCEPT";
      case b.ABORT:
        return "ABORT";
      case b.RETRY:
        return "RETRY";
      case b.RETRY_SNAPSHOT:
        return "RETRY_SNAPSHOT";
      case b.REJECT_SNAPSHOT:
        return "REJECT_SNAPSHOT";
      case b.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.responseApplySnapshotChunk_ResultToJSON = l;
  var y;
  (function(d) {
    d[d.UNKNOWN = 0] = "UNKNOWN", d[d.ACCEPT = 1] = "ACCEPT", d[d.REJECT = 2] = "REJECT", d[d.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(y || (e.ResponseProcessProposal_ProposalStatus = y = {}));
  function E(d) {
    switch (d) {
      case 0:
      case "UNKNOWN":
        return y.UNKNOWN;
      case 1:
      case "ACCEPT":
        return y.ACCEPT;
      case 2:
      case "REJECT":
        return y.REJECT;
      case -1:
      case "UNRECOGNIZED":
      default:
        return y.UNRECOGNIZED;
    }
  }
  e.responseProcessProposal_ProposalStatusFromJSON = E;
  function J(d) {
    switch (d) {
      case y.UNKNOWN:
        return "UNKNOWN";
      case y.ACCEPT:
        return "ACCEPT";
      case y.REJECT:
        return "REJECT";
      case y.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.responseProcessProposal_ProposalStatusToJSON = J;
  var _;
  (function(d) {
    d[d.UNKNOWN = 0] = "UNKNOWN", d[d.DUPLICATE_VOTE = 1] = "DUPLICATE_VOTE", d[d.LIGHT_CLIENT_ATTACK = 2] = "LIGHT_CLIENT_ATTACK", d[d.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(_ || (e.MisbehaviorType = _ = {}));
  function V(d) {
    switch (d) {
      case 0:
      case "UNKNOWN":
        return _.UNKNOWN;
      case 1:
      case "DUPLICATE_VOTE":
        return _.DUPLICATE_VOTE;
      case 2:
      case "LIGHT_CLIENT_ATTACK":
        return _.LIGHT_CLIENT_ATTACK;
      case -1:
      case "UNRECOGNIZED":
      default:
        return _.UNRECOGNIZED;
    }
  }
  e.misbehaviorTypeFromJSON = V;
  function o(d) {
    switch (d) {
      case _.UNKNOWN:
        return "UNKNOWN";
      case _.DUPLICATE_VOTE:
        return "DUPLICATE_VOTE";
      case _.LIGHT_CLIENT_ATTACK:
        return "LIGHT_CLIENT_ATTACK";
      case _.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.misbehaviorTypeToJSON = o;
  function p() {
    return {
      echo: void 0,
      flush: void 0,
      info: void 0,
      initChain: void 0,
      query: void 0,
      beginBlock: void 0,
      checkTx: void 0,
      deliverTx: void 0,
      endBlock: void 0,
      commit: void 0,
      listSnapshots: void 0,
      offerSnapshot: void 0,
      loadSnapshotChunk: void 0,
      applySnapshotChunk: void 0,
      prepareProposal: void 0,
      processProposal: void 0
    };
  }
  e.Request = {
    typeUrl: "/tendermint.abci.Request",
    encode(d, B = k.BinaryWriter.create()) {
      return d.echo !== void 0 && e.RequestEcho.encode(d.echo, B.uint32(10).fork()).ldelim(), d.flush !== void 0 && e.RequestFlush.encode(d.flush, B.uint32(18).fork()).ldelim(), d.info !== void 0 && e.RequestInfo.encode(d.info, B.uint32(26).fork()).ldelim(), d.initChain !== void 0 && e.RequestInitChain.encode(d.initChain, B.uint32(42).fork()).ldelim(), d.query !== void 0 && e.RequestQuery.encode(d.query, B.uint32(50).fork()).ldelim(), d.beginBlock !== void 0 && e.RequestBeginBlock.encode(d.beginBlock, B.uint32(58).fork()).ldelim(), d.checkTx !== void 0 && e.RequestCheckTx.encode(d.checkTx, B.uint32(66).fork()).ldelim(), d.deliverTx !== void 0 && e.RequestDeliverTx.encode(d.deliverTx, B.uint32(74).fork()).ldelim(), d.endBlock !== void 0 && e.RequestEndBlock.encode(d.endBlock, B.uint32(82).fork()).ldelim(), d.commit !== void 0 && e.RequestCommit.encode(d.commit, B.uint32(90).fork()).ldelim(), d.listSnapshots !== void 0 && e.RequestListSnapshots.encode(d.listSnapshots, B.uint32(98).fork()).ldelim(), d.offerSnapshot !== void 0 && e.RequestOfferSnapshot.encode(d.offerSnapshot, B.uint32(106).fork()).ldelim(), d.loadSnapshotChunk !== void 0 && e.RequestLoadSnapshotChunk.encode(d.loadSnapshotChunk, B.uint32(114).fork()).ldelim(), d.applySnapshotChunk !== void 0 && e.RequestApplySnapshotChunk.encode(d.applySnapshotChunk, B.uint32(122).fork()).ldelim(), d.prepareProposal !== void 0 && e.RequestPrepareProposal.encode(d.prepareProposal, B.uint32(130).fork()).ldelim(), d.processProposal !== void 0 && e.RequestProcessProposal.encode(d.processProposal, B.uint32(138).fork()).ldelim(), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = p();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.echo = e.RequestEcho.decode(M, M.uint32());
            break;
          case 2:
            F.flush = e.RequestFlush.decode(M, M.uint32());
            break;
          case 3:
            F.info = e.RequestInfo.decode(M, M.uint32());
            break;
          case 5:
            F.initChain = e.RequestInitChain.decode(M, M.uint32());
            break;
          case 6:
            F.query = e.RequestQuery.decode(M, M.uint32());
            break;
          case 7:
            F.beginBlock = e.RequestBeginBlock.decode(M, M.uint32());
            break;
          case 8:
            F.checkTx = e.RequestCheckTx.decode(M, M.uint32());
            break;
          case 9:
            F.deliverTx = e.RequestDeliverTx.decode(M, M.uint32());
            break;
          case 10:
            F.endBlock = e.RequestEndBlock.decode(M, M.uint32());
            break;
          case 11:
            F.commit = e.RequestCommit.decode(M, M.uint32());
            break;
          case 12:
            F.listSnapshots = e.RequestListSnapshots.decode(M, M.uint32());
            break;
          case 13:
            F.offerSnapshot = e.RequestOfferSnapshot.decode(M, M.uint32());
            break;
          case 14:
            F.loadSnapshotChunk = e.RequestLoadSnapshotChunk.decode(M, M.uint32());
            break;
          case 15:
            F.applySnapshotChunk = e.RequestApplySnapshotChunk.decode(M, M.uint32());
            break;
          case 16:
            F.prepareProposal = e.RequestPrepareProposal.decode(M, M.uint32());
            break;
          case 17:
            F.processProposal = e.RequestProcessProposal.decode(M, M.uint32());
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = p();
      return (0, C.isSet)(d.echo) && (B.echo = e.RequestEcho.fromJSON(d.echo)), (0, C.isSet)(d.flush) && (B.flush = e.RequestFlush.fromJSON(d.flush)), (0, C.isSet)(d.info) && (B.info = e.RequestInfo.fromJSON(d.info)), (0, C.isSet)(d.initChain) && (B.initChain = e.RequestInitChain.fromJSON(d.initChain)), (0, C.isSet)(d.query) && (B.query = e.RequestQuery.fromJSON(d.query)), (0, C.isSet)(d.beginBlock) && (B.beginBlock = e.RequestBeginBlock.fromJSON(d.beginBlock)), (0, C.isSet)(d.checkTx) && (B.checkTx = e.RequestCheckTx.fromJSON(d.checkTx)), (0, C.isSet)(d.deliverTx) && (B.deliverTx = e.RequestDeliverTx.fromJSON(d.deliverTx)), (0, C.isSet)(d.endBlock) && (B.endBlock = e.RequestEndBlock.fromJSON(d.endBlock)), (0, C.isSet)(d.commit) && (B.commit = e.RequestCommit.fromJSON(d.commit)), (0, C.isSet)(d.listSnapshots) && (B.listSnapshots = e.RequestListSnapshots.fromJSON(d.listSnapshots)), (0, C.isSet)(d.offerSnapshot) && (B.offerSnapshot = e.RequestOfferSnapshot.fromJSON(d.offerSnapshot)), (0, C.isSet)(d.loadSnapshotChunk) && (B.loadSnapshotChunk = e.RequestLoadSnapshotChunk.fromJSON(d.loadSnapshotChunk)), (0, C.isSet)(d.applySnapshotChunk) && (B.applySnapshotChunk = e.RequestApplySnapshotChunk.fromJSON(d.applySnapshotChunk)), (0, C.isSet)(d.prepareProposal) && (B.prepareProposal = e.RequestPrepareProposal.fromJSON(d.prepareProposal)), (0, C.isSet)(d.processProposal) && (B.processProposal = e.RequestProcessProposal.fromJSON(d.processProposal)), B;
    },
    toJSON(d) {
      const B = {};
      return d.echo !== void 0 && (B.echo = d.echo ? e.RequestEcho.toJSON(d.echo) : void 0), d.flush !== void 0 && (B.flush = d.flush ? e.RequestFlush.toJSON(d.flush) : void 0), d.info !== void 0 && (B.info = d.info ? e.RequestInfo.toJSON(d.info) : void 0), d.initChain !== void 0 && (B.initChain = d.initChain ? e.RequestInitChain.toJSON(d.initChain) : void 0), d.query !== void 0 && (B.query = d.query ? e.RequestQuery.toJSON(d.query) : void 0), d.beginBlock !== void 0 && (B.beginBlock = d.beginBlock ? e.RequestBeginBlock.toJSON(d.beginBlock) : void 0), d.checkTx !== void 0 && (B.checkTx = d.checkTx ? e.RequestCheckTx.toJSON(d.checkTx) : void 0), d.deliverTx !== void 0 && (B.deliverTx = d.deliverTx ? e.RequestDeliverTx.toJSON(d.deliverTx) : void 0), d.endBlock !== void 0 && (B.endBlock = d.endBlock ? e.RequestEndBlock.toJSON(d.endBlock) : void 0), d.commit !== void 0 && (B.commit = d.commit ? e.RequestCommit.toJSON(d.commit) : void 0), d.listSnapshots !== void 0 && (B.listSnapshots = d.listSnapshots ? e.RequestListSnapshots.toJSON(d.listSnapshots) : void 0), d.offerSnapshot !== void 0 && (B.offerSnapshot = d.offerSnapshot ? e.RequestOfferSnapshot.toJSON(d.offerSnapshot) : void 0), d.loadSnapshotChunk !== void 0 && (B.loadSnapshotChunk = d.loadSnapshotChunk ? e.RequestLoadSnapshotChunk.toJSON(d.loadSnapshotChunk) : void 0), d.applySnapshotChunk !== void 0 && (B.applySnapshotChunk = d.applySnapshotChunk ? e.RequestApplySnapshotChunk.toJSON(d.applySnapshotChunk) : void 0), d.prepareProposal !== void 0 && (B.prepareProposal = d.prepareProposal ? e.RequestPrepareProposal.toJSON(d.prepareProposal) : void 0), d.processProposal !== void 0 && (B.processProposal = d.processProposal ? e.RequestProcessProposal.toJSON(d.processProposal) : void 0), B;
    },
    fromPartial(d) {
      const B = p();
      return d.echo !== void 0 && d.echo !== null && (B.echo = e.RequestEcho.fromPartial(d.echo)), d.flush !== void 0 && d.flush !== null && (B.flush = e.RequestFlush.fromPartial(d.flush)), d.info !== void 0 && d.info !== null && (B.info = e.RequestInfo.fromPartial(d.info)), d.initChain !== void 0 && d.initChain !== null && (B.initChain = e.RequestInitChain.fromPartial(d.initChain)), d.query !== void 0 && d.query !== null && (B.query = e.RequestQuery.fromPartial(d.query)), d.beginBlock !== void 0 && d.beginBlock !== null && (B.beginBlock = e.RequestBeginBlock.fromPartial(d.beginBlock)), d.checkTx !== void 0 && d.checkTx !== null && (B.checkTx = e.RequestCheckTx.fromPartial(d.checkTx)), d.deliverTx !== void 0 && d.deliverTx !== null && (B.deliverTx = e.RequestDeliverTx.fromPartial(d.deliverTx)), d.endBlock !== void 0 && d.endBlock !== null && (B.endBlock = e.RequestEndBlock.fromPartial(d.endBlock)), d.commit !== void 0 && d.commit !== null && (B.commit = e.RequestCommit.fromPartial(d.commit)), d.listSnapshots !== void 0 && d.listSnapshots !== null && (B.listSnapshots = e.RequestListSnapshots.fromPartial(d.listSnapshots)), d.offerSnapshot !== void 0 && d.offerSnapshot !== null && (B.offerSnapshot = e.RequestOfferSnapshot.fromPartial(d.offerSnapshot)), d.loadSnapshotChunk !== void 0 && d.loadSnapshotChunk !== null && (B.loadSnapshotChunk = e.RequestLoadSnapshotChunk.fromPartial(d.loadSnapshotChunk)), d.applySnapshotChunk !== void 0 && d.applySnapshotChunk !== null && (B.applySnapshotChunk = e.RequestApplySnapshotChunk.fromPartial(d.applySnapshotChunk)), d.prepareProposal !== void 0 && d.prepareProposal !== null && (B.prepareProposal = e.RequestPrepareProposal.fromPartial(d.prepareProposal)), d.processProposal !== void 0 && d.processProposal !== null && (B.processProposal = e.RequestProcessProposal.fromPartial(d.processProposal)), B;
    }
  };
  function I() {
    return {
      message: ""
    };
  }
  e.RequestEcho = {
    typeUrl: "/tendermint.abci.RequestEcho",
    encode(d, B = k.BinaryWriter.create()) {
      return d.message !== "" && B.uint32(10).string(d.message), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = I();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.message = M.string();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = I();
      return (0, C.isSet)(d.message) && (B.message = String(d.message)), B;
    },
    toJSON(d) {
      const B = {};
      return d.message !== void 0 && (B.message = d.message), B;
    },
    fromPartial(d) {
      const B = I();
      return B.message = d.message ?? "", B;
    }
  };
  function q() {
    return {};
  }
  e.RequestFlush = {
    typeUrl: "/tendermint.abci.RequestFlush",
    encode(d, B = k.BinaryWriter.create()) {
      return B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = q();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      return q();
    },
    toJSON(d) {
      return {};
    },
    fromPartial(d) {
      return q();
    }
  };
  function s() {
    return {
      version: "",
      blockVersion: BigInt(0),
      p2pVersion: BigInt(0),
      abciVersion: ""
    };
  }
  e.RequestInfo = {
    typeUrl: "/tendermint.abci.RequestInfo",
    encode(d, B = k.BinaryWriter.create()) {
      return d.version !== "" && B.uint32(10).string(d.version), d.blockVersion !== BigInt(0) && B.uint32(16).uint64(d.blockVersion), d.p2pVersion !== BigInt(0) && B.uint32(24).uint64(d.p2pVersion), d.abciVersion !== "" && B.uint32(34).string(d.abciVersion), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = s();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.version = M.string();
            break;
          case 2:
            F.blockVersion = M.uint64();
            break;
          case 3:
            F.p2pVersion = M.uint64();
            break;
          case 4:
            F.abciVersion = M.string();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = s();
      return (0, C.isSet)(d.version) && (B.version = String(d.version)), (0, C.isSet)(d.blockVersion) && (B.blockVersion = BigInt(d.blockVersion.toString())), (0, C.isSet)(d.p2pVersion) && (B.p2pVersion = BigInt(d.p2pVersion.toString())), (0, C.isSet)(d.abciVersion) && (B.abciVersion = String(d.abciVersion)), B;
    },
    toJSON(d) {
      const B = {};
      return d.version !== void 0 && (B.version = d.version), d.blockVersion !== void 0 && (B.blockVersion = (d.blockVersion || BigInt(0)).toString()), d.p2pVersion !== void 0 && (B.p2pVersion = (d.p2pVersion || BigInt(0)).toString()), d.abciVersion !== void 0 && (B.abciVersion = d.abciVersion), B;
    },
    fromPartial(d) {
      const B = s();
      return B.version = d.version ?? "", d.blockVersion !== void 0 && d.blockVersion !== null && (B.blockVersion = BigInt(d.blockVersion.toString())), d.p2pVersion !== void 0 && d.p2pVersion !== null && (B.p2pVersion = BigInt(d.p2pVersion.toString())), B.abciVersion = d.abciVersion ?? "", B;
    }
  };
  function u() {
    return {
      time: n.Timestamp.fromPartial({}),
      chainId: "",
      consensusParams: void 0,
      validators: [],
      appStateBytes: new Uint8Array(),
      initialHeight: BigInt(0)
    };
  }
  e.RequestInitChain = {
    typeUrl: "/tendermint.abci.RequestInitChain",
    encode(d, B = k.BinaryWriter.create()) {
      d.time !== void 0 && n.Timestamp.encode(d.time, B.uint32(10).fork()).ldelim(), d.chainId !== "" && B.uint32(18).string(d.chainId), d.consensusParams !== void 0 && r.ConsensusParams.encode(d.consensusParams, B.uint32(26).fork()).ldelim();
      for (const M of d.validators)
        e.ValidatorUpdate.encode(M, B.uint32(34).fork()).ldelim();
      return d.appStateBytes.length !== 0 && B.uint32(42).bytes(d.appStateBytes), d.initialHeight !== BigInt(0) && B.uint32(48).int64(d.initialHeight), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = u();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.time = n.Timestamp.decode(M, M.uint32());
            break;
          case 2:
            F.chainId = M.string();
            break;
          case 3:
            F.consensusParams = r.ConsensusParams.decode(M, M.uint32());
            break;
          case 4:
            F.validators.push(e.ValidatorUpdate.decode(M, M.uint32()));
            break;
          case 5:
            F.appStateBytes = M.bytes();
            break;
          case 6:
            F.initialHeight = M.int64();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = u();
      return (0, C.isSet)(d.time) && (B.time = (0, C.fromJsonTimestamp)(d.time)), (0, C.isSet)(d.chainId) && (B.chainId = String(d.chainId)), (0, C.isSet)(d.consensusParams) && (B.consensusParams = r.ConsensusParams.fromJSON(d.consensusParams)), Array.isArray(d == null ? void 0 : d.validators) && (B.validators = d.validators.map((M) => e.ValidatorUpdate.fromJSON(M))), (0, C.isSet)(d.appStateBytes) && (B.appStateBytes = (0, C.bytesFromBase64)(d.appStateBytes)), (0, C.isSet)(d.initialHeight) && (B.initialHeight = BigInt(d.initialHeight.toString())), B;
    },
    toJSON(d) {
      const B = {};
      return d.time !== void 0 && (B.time = (0, C.fromTimestamp)(d.time).toISOString()), d.chainId !== void 0 && (B.chainId = d.chainId), d.consensusParams !== void 0 && (B.consensusParams = d.consensusParams ? r.ConsensusParams.toJSON(d.consensusParams) : void 0), d.validators ? B.validators = d.validators.map((M) => M ? e.ValidatorUpdate.toJSON(M) : void 0) : B.validators = [], d.appStateBytes !== void 0 && (B.appStateBytes = (0, C.base64FromBytes)(d.appStateBytes !== void 0 ? d.appStateBytes : new Uint8Array())), d.initialHeight !== void 0 && (B.initialHeight = (d.initialHeight || BigInt(0)).toString()), B;
    },
    fromPartial(d) {
      var M;
      const B = u();
      return d.time !== void 0 && d.time !== null && (B.time = n.Timestamp.fromPartial(d.time)), B.chainId = d.chainId ?? "", d.consensusParams !== void 0 && d.consensusParams !== null && (B.consensusParams = r.ConsensusParams.fromPartial(d.consensusParams)), B.validators = ((M = d.validators) == null ? void 0 : M.map((z) => e.ValidatorUpdate.fromPartial(z))) || [], B.appStateBytes = d.appStateBytes ?? new Uint8Array(), d.initialHeight !== void 0 && d.initialHeight !== null && (B.initialHeight = BigInt(d.initialHeight.toString())), B;
    }
  };
  function A() {
    return {
      data: new Uint8Array(),
      path: "",
      height: BigInt(0),
      prove: !1
    };
  }
  e.RequestQuery = {
    typeUrl: "/tendermint.abci.RequestQuery",
    encode(d, B = k.BinaryWriter.create()) {
      return d.data.length !== 0 && B.uint32(10).bytes(d.data), d.path !== "" && B.uint32(18).string(d.path), d.height !== BigInt(0) && B.uint32(24).int64(d.height), d.prove === !0 && B.uint32(32).bool(d.prove), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = A();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.data = M.bytes();
            break;
          case 2:
            F.path = M.string();
            break;
          case 3:
            F.height = M.int64();
            break;
          case 4:
            F.prove = M.bool();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = A();
      return (0, C.isSet)(d.data) && (B.data = (0, C.bytesFromBase64)(d.data)), (0, C.isSet)(d.path) && (B.path = String(d.path)), (0, C.isSet)(d.height) && (B.height = BigInt(d.height.toString())), (0, C.isSet)(d.prove) && (B.prove = !!d.prove), B;
    },
    toJSON(d) {
      const B = {};
      return d.data !== void 0 && (B.data = (0, C.base64FromBytes)(d.data !== void 0 ? d.data : new Uint8Array())), d.path !== void 0 && (B.path = d.path), d.height !== void 0 && (B.height = (d.height || BigInt(0)).toString()), d.prove !== void 0 && (B.prove = d.prove), B;
    },
    fromPartial(d) {
      const B = A();
      return B.data = d.data ?? new Uint8Array(), B.path = d.path ?? "", d.height !== void 0 && d.height !== null && (B.height = BigInt(d.height.toString())), B.prove = d.prove ?? !1, B;
    }
  };
  function R() {
    return {
      hash: new Uint8Array(),
      header: t.Header.fromPartial({}),
      lastCommitInfo: e.CommitInfo.fromPartial({}),
      byzantineValidators: []
    };
  }
  e.RequestBeginBlock = {
    typeUrl: "/tendermint.abci.RequestBeginBlock",
    encode(d, B = k.BinaryWriter.create()) {
      d.hash.length !== 0 && B.uint32(10).bytes(d.hash), d.header !== void 0 && t.Header.encode(d.header, B.uint32(18).fork()).ldelim(), d.lastCommitInfo !== void 0 && e.CommitInfo.encode(d.lastCommitInfo, B.uint32(26).fork()).ldelim();
      for (const M of d.byzantineValidators)
        e.Misbehavior.encode(M, B.uint32(34).fork()).ldelim();
      return B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = R();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.hash = M.bytes();
            break;
          case 2:
            F.header = t.Header.decode(M, M.uint32());
            break;
          case 3:
            F.lastCommitInfo = e.CommitInfo.decode(M, M.uint32());
            break;
          case 4:
            F.byzantineValidators.push(e.Misbehavior.decode(M, M.uint32()));
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = R();
      return (0, C.isSet)(d.hash) && (B.hash = (0, C.bytesFromBase64)(d.hash)), (0, C.isSet)(d.header) && (B.header = t.Header.fromJSON(d.header)), (0, C.isSet)(d.lastCommitInfo) && (B.lastCommitInfo = e.CommitInfo.fromJSON(d.lastCommitInfo)), Array.isArray(d == null ? void 0 : d.byzantineValidators) && (B.byzantineValidators = d.byzantineValidators.map((M) => e.Misbehavior.fromJSON(M))), B;
    },
    toJSON(d) {
      const B = {};
      return d.hash !== void 0 && (B.hash = (0, C.base64FromBytes)(d.hash !== void 0 ? d.hash : new Uint8Array())), d.header !== void 0 && (B.header = d.header ? t.Header.toJSON(d.header) : void 0), d.lastCommitInfo !== void 0 && (B.lastCommitInfo = d.lastCommitInfo ? e.CommitInfo.toJSON(d.lastCommitInfo) : void 0), d.byzantineValidators ? B.byzantineValidators = d.byzantineValidators.map((M) => M ? e.Misbehavior.toJSON(M) : void 0) : B.byzantineValidators = [], B;
    },
    fromPartial(d) {
      var M;
      const B = R();
      return B.hash = d.hash ?? new Uint8Array(), d.header !== void 0 && d.header !== null && (B.header = t.Header.fromPartial(d.header)), d.lastCommitInfo !== void 0 && d.lastCommitInfo !== null && (B.lastCommitInfo = e.CommitInfo.fromPartial(d.lastCommitInfo)), B.byzantineValidators = ((M = d.byzantineValidators) == null ? void 0 : M.map((z) => e.Misbehavior.fromPartial(z))) || [], B;
    }
  };
  function v() {
    return {
      tx: new Uint8Array(),
      type: 0
    };
  }
  e.RequestCheckTx = {
    typeUrl: "/tendermint.abci.RequestCheckTx",
    encode(d, B = k.BinaryWriter.create()) {
      return d.tx.length !== 0 && B.uint32(10).bytes(d.tx), d.type !== 0 && B.uint32(16).int32(d.type), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = v();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.tx = M.bytes();
            break;
          case 2:
            F.type = M.int32();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = v();
      return (0, C.isSet)(d.tx) && (B.tx = (0, C.bytesFromBase64)(d.tx)), (0, C.isSet)(d.type) && (B.type = U(d.type)), B;
    },
    toJSON(d) {
      const B = {};
      return d.tx !== void 0 && (B.tx = (0, C.base64FromBytes)(d.tx !== void 0 ? d.tx : new Uint8Array())), d.type !== void 0 && (B.type = w(d.type)), B;
    },
    fromPartial(d) {
      const B = v();
      return B.tx = d.tx ?? new Uint8Array(), B.type = d.type ?? 0, B;
    }
  };
  function D() {
    return {
      tx: new Uint8Array()
    };
  }
  e.RequestDeliverTx = {
    typeUrl: "/tendermint.abci.RequestDeliverTx",
    encode(d, B = k.BinaryWriter.create()) {
      return d.tx.length !== 0 && B.uint32(10).bytes(d.tx), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = D();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.tx = M.bytes();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = D();
      return (0, C.isSet)(d.tx) && (B.tx = (0, C.bytesFromBase64)(d.tx)), B;
    },
    toJSON(d) {
      const B = {};
      return d.tx !== void 0 && (B.tx = (0, C.base64FromBytes)(d.tx !== void 0 ? d.tx : new Uint8Array())), B;
    },
    fromPartial(d) {
      const B = D();
      return B.tx = d.tx ?? new Uint8Array(), B;
    }
  };
  function W() {
    return {
      height: BigInt(0)
    };
  }
  e.RequestEndBlock = {
    typeUrl: "/tendermint.abci.RequestEndBlock",
    encode(d, B = k.BinaryWriter.create()) {
      return d.height !== BigInt(0) && B.uint32(8).int64(d.height), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = W();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.height = M.int64();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = W();
      return (0, C.isSet)(d.height) && (B.height = BigInt(d.height.toString())), B;
    },
    toJSON(d) {
      const B = {};
      return d.height !== void 0 && (B.height = (d.height || BigInt(0)).toString()), B;
    },
    fromPartial(d) {
      const B = W();
      return d.height !== void 0 && d.height !== null && (B.height = BigInt(d.height.toString())), B;
    }
  };
  function H() {
    return {};
  }
  e.RequestCommit = {
    typeUrl: "/tendermint.abci.RequestCommit",
    encode(d, B = k.BinaryWriter.create()) {
      return B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = H();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      return H();
    },
    toJSON(d) {
      return {};
    },
    fromPartial(d) {
      return H();
    }
  };
  function a() {
    return {};
  }
  e.RequestListSnapshots = {
    typeUrl: "/tendermint.abci.RequestListSnapshots",
    encode(d, B = k.BinaryWriter.create()) {
      return B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = a();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      return a();
    },
    toJSON(d) {
      return {};
    },
    fromPartial(d) {
      return a();
    }
  };
  function g() {
    return {
      snapshot: void 0,
      appHash: new Uint8Array()
    };
  }
  e.RequestOfferSnapshot = {
    typeUrl: "/tendermint.abci.RequestOfferSnapshot",
    encode(d, B = k.BinaryWriter.create()) {
      return d.snapshot !== void 0 && e.Snapshot.encode(d.snapshot, B.uint32(10).fork()).ldelim(), d.appHash.length !== 0 && B.uint32(18).bytes(d.appHash), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = g();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.snapshot = e.Snapshot.decode(M, M.uint32());
            break;
          case 2:
            F.appHash = M.bytes();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = g();
      return (0, C.isSet)(d.snapshot) && (B.snapshot = e.Snapshot.fromJSON(d.snapshot)), (0, C.isSet)(d.appHash) && (B.appHash = (0, C.bytesFromBase64)(d.appHash)), B;
    },
    toJSON(d) {
      const B = {};
      return d.snapshot !== void 0 && (B.snapshot = d.snapshot ? e.Snapshot.toJSON(d.snapshot) : void 0), d.appHash !== void 0 && (B.appHash = (0, C.base64FromBytes)(d.appHash !== void 0 ? d.appHash : new Uint8Array())), B;
    },
    fromPartial(d) {
      const B = g();
      return d.snapshot !== void 0 && d.snapshot !== null && (B.snapshot = e.Snapshot.fromPartial(d.snapshot)), B.appHash = d.appHash ?? new Uint8Array(), B;
    }
  };
  function m() {
    return {
      height: BigInt(0),
      format: 0,
      chunk: 0
    };
  }
  e.RequestLoadSnapshotChunk = {
    typeUrl: "/tendermint.abci.RequestLoadSnapshotChunk",
    encode(d, B = k.BinaryWriter.create()) {
      return d.height !== BigInt(0) && B.uint32(8).uint64(d.height), d.format !== 0 && B.uint32(16).uint32(d.format), d.chunk !== 0 && B.uint32(24).uint32(d.chunk), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = m();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.height = M.uint64();
            break;
          case 2:
            F.format = M.uint32();
            break;
          case 3:
            F.chunk = M.uint32();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = m();
      return (0, C.isSet)(d.height) && (B.height = BigInt(d.height.toString())), (0, C.isSet)(d.format) && (B.format = Number(d.format)), (0, C.isSet)(d.chunk) && (B.chunk = Number(d.chunk)), B;
    },
    toJSON(d) {
      const B = {};
      return d.height !== void 0 && (B.height = (d.height || BigInt(0)).toString()), d.format !== void 0 && (B.format = Math.round(d.format)), d.chunk !== void 0 && (B.chunk = Math.round(d.chunk)), B;
    },
    fromPartial(d) {
      const B = m();
      return d.height !== void 0 && d.height !== null && (B.height = BigInt(d.height.toString())), B.format = d.format ?? 0, B.chunk = d.chunk ?? 0, B;
    }
  };
  function S() {
    return {
      index: 0,
      chunk: new Uint8Array(),
      sender: ""
    };
  }
  e.RequestApplySnapshotChunk = {
    typeUrl: "/tendermint.abci.RequestApplySnapshotChunk",
    encode(d, B = k.BinaryWriter.create()) {
      return d.index !== 0 && B.uint32(8).uint32(d.index), d.chunk.length !== 0 && B.uint32(18).bytes(d.chunk), d.sender !== "" && B.uint32(26).string(d.sender), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = S();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.index = M.uint32();
            break;
          case 2:
            F.chunk = M.bytes();
            break;
          case 3:
            F.sender = M.string();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = S();
      return (0, C.isSet)(d.index) && (B.index = Number(d.index)), (0, C.isSet)(d.chunk) && (B.chunk = (0, C.bytesFromBase64)(d.chunk)), (0, C.isSet)(d.sender) && (B.sender = String(d.sender)), B;
    },
    toJSON(d) {
      const B = {};
      return d.index !== void 0 && (B.index = Math.round(d.index)), d.chunk !== void 0 && (B.chunk = (0, C.base64FromBytes)(d.chunk !== void 0 ? d.chunk : new Uint8Array())), d.sender !== void 0 && (B.sender = d.sender), B;
    },
    fromPartial(d) {
      const B = S();
      return B.index = d.index ?? 0, B.chunk = d.chunk ?? new Uint8Array(), B.sender = d.sender ?? "", B;
    }
  };
  function O() {
    return {
      maxTxBytes: BigInt(0),
      txs: [],
      localLastCommit: e.ExtendedCommitInfo.fromPartial({}),
      misbehavior: [],
      height: BigInt(0),
      time: n.Timestamp.fromPartial({}),
      nextValidatorsHash: new Uint8Array(),
      proposerAddress: new Uint8Array()
    };
  }
  e.RequestPrepareProposal = {
    typeUrl: "/tendermint.abci.RequestPrepareProposal",
    encode(d, B = k.BinaryWriter.create()) {
      d.maxTxBytes !== BigInt(0) && B.uint32(8).int64(d.maxTxBytes);
      for (const M of d.txs)
        B.uint32(18).bytes(M);
      d.localLastCommit !== void 0 && e.ExtendedCommitInfo.encode(d.localLastCommit, B.uint32(26).fork()).ldelim();
      for (const M of d.misbehavior)
        e.Misbehavior.encode(M, B.uint32(34).fork()).ldelim();
      return d.height !== BigInt(0) && B.uint32(40).int64(d.height), d.time !== void 0 && n.Timestamp.encode(d.time, B.uint32(50).fork()).ldelim(), d.nextValidatorsHash.length !== 0 && B.uint32(58).bytes(d.nextValidatorsHash), d.proposerAddress.length !== 0 && B.uint32(66).bytes(d.proposerAddress), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = O();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.maxTxBytes = M.int64();
            break;
          case 2:
            F.txs.push(M.bytes());
            break;
          case 3:
            F.localLastCommit = e.ExtendedCommitInfo.decode(M, M.uint32());
            break;
          case 4:
            F.misbehavior.push(e.Misbehavior.decode(M, M.uint32()));
            break;
          case 5:
            F.height = M.int64();
            break;
          case 6:
            F.time = n.Timestamp.decode(M, M.uint32());
            break;
          case 7:
            F.nextValidatorsHash = M.bytes();
            break;
          case 8:
            F.proposerAddress = M.bytes();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = O();
      return (0, C.isSet)(d.maxTxBytes) && (B.maxTxBytes = BigInt(d.maxTxBytes.toString())), Array.isArray(d == null ? void 0 : d.txs) && (B.txs = d.txs.map((M) => (0, C.bytesFromBase64)(M))), (0, C.isSet)(d.localLastCommit) && (B.localLastCommit = e.ExtendedCommitInfo.fromJSON(d.localLastCommit)), Array.isArray(d == null ? void 0 : d.misbehavior) && (B.misbehavior = d.misbehavior.map((M) => e.Misbehavior.fromJSON(M))), (0, C.isSet)(d.height) && (B.height = BigInt(d.height.toString())), (0, C.isSet)(d.time) && (B.time = (0, C.fromJsonTimestamp)(d.time)), (0, C.isSet)(d.nextValidatorsHash) && (B.nextValidatorsHash = (0, C.bytesFromBase64)(d.nextValidatorsHash)), (0, C.isSet)(d.proposerAddress) && (B.proposerAddress = (0, C.bytesFromBase64)(d.proposerAddress)), B;
    },
    toJSON(d) {
      const B = {};
      return d.maxTxBytes !== void 0 && (B.maxTxBytes = (d.maxTxBytes || BigInt(0)).toString()), d.txs ? B.txs = d.txs.map((M) => (0, C.base64FromBytes)(M !== void 0 ? M : new Uint8Array())) : B.txs = [], d.localLastCommit !== void 0 && (B.localLastCommit = d.localLastCommit ? e.ExtendedCommitInfo.toJSON(d.localLastCommit) : void 0), d.misbehavior ? B.misbehavior = d.misbehavior.map((M) => M ? e.Misbehavior.toJSON(M) : void 0) : B.misbehavior = [], d.height !== void 0 && (B.height = (d.height || BigInt(0)).toString()), d.time !== void 0 && (B.time = (0, C.fromTimestamp)(d.time).toISOString()), d.nextValidatorsHash !== void 0 && (B.nextValidatorsHash = (0, C.base64FromBytes)(d.nextValidatorsHash !== void 0 ? d.nextValidatorsHash : new Uint8Array())), d.proposerAddress !== void 0 && (B.proposerAddress = (0, C.base64FromBytes)(d.proposerAddress !== void 0 ? d.proposerAddress : new Uint8Array())), B;
    },
    fromPartial(d) {
      var M, z;
      const B = O();
      return d.maxTxBytes !== void 0 && d.maxTxBytes !== null && (B.maxTxBytes = BigInt(d.maxTxBytes.toString())), B.txs = ((M = d.txs) == null ? void 0 : M.map((F) => F)) || [], d.localLastCommit !== void 0 && d.localLastCommit !== null && (B.localLastCommit = e.ExtendedCommitInfo.fromPartial(d.localLastCommit)), B.misbehavior = ((z = d.misbehavior) == null ? void 0 : z.map((F) => e.Misbehavior.fromPartial(F))) || [], d.height !== void 0 && d.height !== null && (B.height = BigInt(d.height.toString())), d.time !== void 0 && d.time !== null && (B.time = n.Timestamp.fromPartial(d.time)), B.nextValidatorsHash = d.nextValidatorsHash ?? new Uint8Array(), B.proposerAddress = d.proposerAddress ?? new Uint8Array(), B;
    }
  };
  function Q() {
    return {
      txs: [],
      proposedLastCommit: e.CommitInfo.fromPartial({}),
      misbehavior: [],
      hash: new Uint8Array(),
      height: BigInt(0),
      time: n.Timestamp.fromPartial({}),
      nextValidatorsHash: new Uint8Array(),
      proposerAddress: new Uint8Array()
    };
  }
  e.RequestProcessProposal = {
    typeUrl: "/tendermint.abci.RequestProcessProposal",
    encode(d, B = k.BinaryWriter.create()) {
      for (const M of d.txs)
        B.uint32(10).bytes(M);
      d.proposedLastCommit !== void 0 && e.CommitInfo.encode(d.proposedLastCommit, B.uint32(18).fork()).ldelim();
      for (const M of d.misbehavior)
        e.Misbehavior.encode(M, B.uint32(26).fork()).ldelim();
      return d.hash.length !== 0 && B.uint32(34).bytes(d.hash), d.height !== BigInt(0) && B.uint32(40).int64(d.height), d.time !== void 0 && n.Timestamp.encode(d.time, B.uint32(50).fork()).ldelim(), d.nextValidatorsHash.length !== 0 && B.uint32(58).bytes(d.nextValidatorsHash), d.proposerAddress.length !== 0 && B.uint32(66).bytes(d.proposerAddress), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = Q();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.txs.push(M.bytes());
            break;
          case 2:
            F.proposedLastCommit = e.CommitInfo.decode(M, M.uint32());
            break;
          case 3:
            F.misbehavior.push(e.Misbehavior.decode(M, M.uint32()));
            break;
          case 4:
            F.hash = M.bytes();
            break;
          case 5:
            F.height = M.int64();
            break;
          case 6:
            F.time = n.Timestamp.decode(M, M.uint32());
            break;
          case 7:
            F.nextValidatorsHash = M.bytes();
            break;
          case 8:
            F.proposerAddress = M.bytes();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = Q();
      return Array.isArray(d == null ? void 0 : d.txs) && (B.txs = d.txs.map((M) => (0, C.bytesFromBase64)(M))), (0, C.isSet)(d.proposedLastCommit) && (B.proposedLastCommit = e.CommitInfo.fromJSON(d.proposedLastCommit)), Array.isArray(d == null ? void 0 : d.misbehavior) && (B.misbehavior = d.misbehavior.map((M) => e.Misbehavior.fromJSON(M))), (0, C.isSet)(d.hash) && (B.hash = (0, C.bytesFromBase64)(d.hash)), (0, C.isSet)(d.height) && (B.height = BigInt(d.height.toString())), (0, C.isSet)(d.time) && (B.time = (0, C.fromJsonTimestamp)(d.time)), (0, C.isSet)(d.nextValidatorsHash) && (B.nextValidatorsHash = (0, C.bytesFromBase64)(d.nextValidatorsHash)), (0, C.isSet)(d.proposerAddress) && (B.proposerAddress = (0, C.bytesFromBase64)(d.proposerAddress)), B;
    },
    toJSON(d) {
      const B = {};
      return d.txs ? B.txs = d.txs.map((M) => (0, C.base64FromBytes)(M !== void 0 ? M : new Uint8Array())) : B.txs = [], d.proposedLastCommit !== void 0 && (B.proposedLastCommit = d.proposedLastCommit ? e.CommitInfo.toJSON(d.proposedLastCommit) : void 0), d.misbehavior ? B.misbehavior = d.misbehavior.map((M) => M ? e.Misbehavior.toJSON(M) : void 0) : B.misbehavior = [], d.hash !== void 0 && (B.hash = (0, C.base64FromBytes)(d.hash !== void 0 ? d.hash : new Uint8Array())), d.height !== void 0 && (B.height = (d.height || BigInt(0)).toString()), d.time !== void 0 && (B.time = (0, C.fromTimestamp)(d.time).toISOString()), d.nextValidatorsHash !== void 0 && (B.nextValidatorsHash = (0, C.base64FromBytes)(d.nextValidatorsHash !== void 0 ? d.nextValidatorsHash : new Uint8Array())), d.proposerAddress !== void 0 && (B.proposerAddress = (0, C.base64FromBytes)(d.proposerAddress !== void 0 ? d.proposerAddress : new Uint8Array())), B;
    },
    fromPartial(d) {
      var M, z;
      const B = Q();
      return B.txs = ((M = d.txs) == null ? void 0 : M.map((F) => F)) || [], d.proposedLastCommit !== void 0 && d.proposedLastCommit !== null && (B.proposedLastCommit = e.CommitInfo.fromPartial(d.proposedLastCommit)), B.misbehavior = ((z = d.misbehavior) == null ? void 0 : z.map((F) => e.Misbehavior.fromPartial(F))) || [], B.hash = d.hash ?? new Uint8Array(), d.height !== void 0 && d.height !== null && (B.height = BigInt(d.height.toString())), d.time !== void 0 && d.time !== null && (B.time = n.Timestamp.fromPartial(d.time)), B.nextValidatorsHash = d.nextValidatorsHash ?? new Uint8Array(), B.proposerAddress = d.proposerAddress ?? new Uint8Array(), B;
    }
  };
  function G() {
    return {
      exception: void 0,
      echo: void 0,
      flush: void 0,
      info: void 0,
      initChain: void 0,
      query: void 0,
      beginBlock: void 0,
      checkTx: void 0,
      deliverTx: void 0,
      endBlock: void 0,
      commit: void 0,
      listSnapshots: void 0,
      offerSnapshot: void 0,
      loadSnapshotChunk: void 0,
      applySnapshotChunk: void 0,
      prepareProposal: void 0,
      processProposal: void 0
    };
  }
  e.Response = {
    typeUrl: "/tendermint.abci.Response",
    encode(d, B = k.BinaryWriter.create()) {
      return d.exception !== void 0 && e.ResponseException.encode(d.exception, B.uint32(10).fork()).ldelim(), d.echo !== void 0 && e.ResponseEcho.encode(d.echo, B.uint32(18).fork()).ldelim(), d.flush !== void 0 && e.ResponseFlush.encode(d.flush, B.uint32(26).fork()).ldelim(), d.info !== void 0 && e.ResponseInfo.encode(d.info, B.uint32(34).fork()).ldelim(), d.initChain !== void 0 && e.ResponseInitChain.encode(d.initChain, B.uint32(50).fork()).ldelim(), d.query !== void 0 && e.ResponseQuery.encode(d.query, B.uint32(58).fork()).ldelim(), d.beginBlock !== void 0 && e.ResponseBeginBlock.encode(d.beginBlock, B.uint32(66).fork()).ldelim(), d.checkTx !== void 0 && e.ResponseCheckTx.encode(d.checkTx, B.uint32(74).fork()).ldelim(), d.deliverTx !== void 0 && e.ResponseDeliverTx.encode(d.deliverTx, B.uint32(82).fork()).ldelim(), d.endBlock !== void 0 && e.ResponseEndBlock.encode(d.endBlock, B.uint32(90).fork()).ldelim(), d.commit !== void 0 && e.ResponseCommit.encode(d.commit, B.uint32(98).fork()).ldelim(), d.listSnapshots !== void 0 && e.ResponseListSnapshots.encode(d.listSnapshots, B.uint32(106).fork()).ldelim(), d.offerSnapshot !== void 0 && e.ResponseOfferSnapshot.encode(d.offerSnapshot, B.uint32(114).fork()).ldelim(), d.loadSnapshotChunk !== void 0 && e.ResponseLoadSnapshotChunk.encode(d.loadSnapshotChunk, B.uint32(122).fork()).ldelim(), d.applySnapshotChunk !== void 0 && e.ResponseApplySnapshotChunk.encode(d.applySnapshotChunk, B.uint32(130).fork()).ldelim(), d.prepareProposal !== void 0 && e.ResponsePrepareProposal.encode(d.prepareProposal, B.uint32(138).fork()).ldelim(), d.processProposal !== void 0 && e.ResponseProcessProposal.encode(d.processProposal, B.uint32(146).fork()).ldelim(), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = G();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.exception = e.ResponseException.decode(M, M.uint32());
            break;
          case 2:
            F.echo = e.ResponseEcho.decode(M, M.uint32());
            break;
          case 3:
            F.flush = e.ResponseFlush.decode(M, M.uint32());
            break;
          case 4:
            F.info = e.ResponseInfo.decode(M, M.uint32());
            break;
          case 6:
            F.initChain = e.ResponseInitChain.decode(M, M.uint32());
            break;
          case 7:
            F.query = e.ResponseQuery.decode(M, M.uint32());
            break;
          case 8:
            F.beginBlock = e.ResponseBeginBlock.decode(M, M.uint32());
            break;
          case 9:
            F.checkTx = e.ResponseCheckTx.decode(M, M.uint32());
            break;
          case 10:
            F.deliverTx = e.ResponseDeliverTx.decode(M, M.uint32());
            break;
          case 11:
            F.endBlock = e.ResponseEndBlock.decode(M, M.uint32());
            break;
          case 12:
            F.commit = e.ResponseCommit.decode(M, M.uint32());
            break;
          case 13:
            F.listSnapshots = e.ResponseListSnapshots.decode(M, M.uint32());
            break;
          case 14:
            F.offerSnapshot = e.ResponseOfferSnapshot.decode(M, M.uint32());
            break;
          case 15:
            F.loadSnapshotChunk = e.ResponseLoadSnapshotChunk.decode(M, M.uint32());
            break;
          case 16:
            F.applySnapshotChunk = e.ResponseApplySnapshotChunk.decode(M, M.uint32());
            break;
          case 17:
            F.prepareProposal = e.ResponsePrepareProposal.decode(M, M.uint32());
            break;
          case 18:
            F.processProposal = e.ResponseProcessProposal.decode(M, M.uint32());
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = G();
      return (0, C.isSet)(d.exception) && (B.exception = e.ResponseException.fromJSON(d.exception)), (0, C.isSet)(d.echo) && (B.echo = e.ResponseEcho.fromJSON(d.echo)), (0, C.isSet)(d.flush) && (B.flush = e.ResponseFlush.fromJSON(d.flush)), (0, C.isSet)(d.info) && (B.info = e.ResponseInfo.fromJSON(d.info)), (0, C.isSet)(d.initChain) && (B.initChain = e.ResponseInitChain.fromJSON(d.initChain)), (0, C.isSet)(d.query) && (B.query = e.ResponseQuery.fromJSON(d.query)), (0, C.isSet)(d.beginBlock) && (B.beginBlock = e.ResponseBeginBlock.fromJSON(d.beginBlock)), (0, C.isSet)(d.checkTx) && (B.checkTx = e.ResponseCheckTx.fromJSON(d.checkTx)), (0, C.isSet)(d.deliverTx) && (B.deliverTx = e.ResponseDeliverTx.fromJSON(d.deliverTx)), (0, C.isSet)(d.endBlock) && (B.endBlock = e.ResponseEndBlock.fromJSON(d.endBlock)), (0, C.isSet)(d.commit) && (B.commit = e.ResponseCommit.fromJSON(d.commit)), (0, C.isSet)(d.listSnapshots) && (B.listSnapshots = e.ResponseListSnapshots.fromJSON(d.listSnapshots)), (0, C.isSet)(d.offerSnapshot) && (B.offerSnapshot = e.ResponseOfferSnapshot.fromJSON(d.offerSnapshot)), (0, C.isSet)(d.loadSnapshotChunk) && (B.loadSnapshotChunk = e.ResponseLoadSnapshotChunk.fromJSON(d.loadSnapshotChunk)), (0, C.isSet)(d.applySnapshotChunk) && (B.applySnapshotChunk = e.ResponseApplySnapshotChunk.fromJSON(d.applySnapshotChunk)), (0, C.isSet)(d.prepareProposal) && (B.prepareProposal = e.ResponsePrepareProposal.fromJSON(d.prepareProposal)), (0, C.isSet)(d.processProposal) && (B.processProposal = e.ResponseProcessProposal.fromJSON(d.processProposal)), B;
    },
    toJSON(d) {
      const B = {};
      return d.exception !== void 0 && (B.exception = d.exception ? e.ResponseException.toJSON(d.exception) : void 0), d.echo !== void 0 && (B.echo = d.echo ? e.ResponseEcho.toJSON(d.echo) : void 0), d.flush !== void 0 && (B.flush = d.flush ? e.ResponseFlush.toJSON(d.flush) : void 0), d.info !== void 0 && (B.info = d.info ? e.ResponseInfo.toJSON(d.info) : void 0), d.initChain !== void 0 && (B.initChain = d.initChain ? e.ResponseInitChain.toJSON(d.initChain) : void 0), d.query !== void 0 && (B.query = d.query ? e.ResponseQuery.toJSON(d.query) : void 0), d.beginBlock !== void 0 && (B.beginBlock = d.beginBlock ? e.ResponseBeginBlock.toJSON(d.beginBlock) : void 0), d.checkTx !== void 0 && (B.checkTx = d.checkTx ? e.ResponseCheckTx.toJSON(d.checkTx) : void 0), d.deliverTx !== void 0 && (B.deliverTx = d.deliverTx ? e.ResponseDeliverTx.toJSON(d.deliverTx) : void 0), d.endBlock !== void 0 && (B.endBlock = d.endBlock ? e.ResponseEndBlock.toJSON(d.endBlock) : void 0), d.commit !== void 0 && (B.commit = d.commit ? e.ResponseCommit.toJSON(d.commit) : void 0), d.listSnapshots !== void 0 && (B.listSnapshots = d.listSnapshots ? e.ResponseListSnapshots.toJSON(d.listSnapshots) : void 0), d.offerSnapshot !== void 0 && (B.offerSnapshot = d.offerSnapshot ? e.ResponseOfferSnapshot.toJSON(d.offerSnapshot) : void 0), d.loadSnapshotChunk !== void 0 && (B.loadSnapshotChunk = d.loadSnapshotChunk ? e.ResponseLoadSnapshotChunk.toJSON(d.loadSnapshotChunk) : void 0), d.applySnapshotChunk !== void 0 && (B.applySnapshotChunk = d.applySnapshotChunk ? e.ResponseApplySnapshotChunk.toJSON(d.applySnapshotChunk) : void 0), d.prepareProposal !== void 0 && (B.prepareProposal = d.prepareProposal ? e.ResponsePrepareProposal.toJSON(d.prepareProposal) : void 0), d.processProposal !== void 0 && (B.processProposal = d.processProposal ? e.ResponseProcessProposal.toJSON(d.processProposal) : void 0), B;
    },
    fromPartial(d) {
      const B = G();
      return d.exception !== void 0 && d.exception !== null && (B.exception = e.ResponseException.fromPartial(d.exception)), d.echo !== void 0 && d.echo !== null && (B.echo = e.ResponseEcho.fromPartial(d.echo)), d.flush !== void 0 && d.flush !== null && (B.flush = e.ResponseFlush.fromPartial(d.flush)), d.info !== void 0 && d.info !== null && (B.info = e.ResponseInfo.fromPartial(d.info)), d.initChain !== void 0 && d.initChain !== null && (B.initChain = e.ResponseInitChain.fromPartial(d.initChain)), d.query !== void 0 && d.query !== null && (B.query = e.ResponseQuery.fromPartial(d.query)), d.beginBlock !== void 0 && d.beginBlock !== null && (B.beginBlock = e.ResponseBeginBlock.fromPartial(d.beginBlock)), d.checkTx !== void 0 && d.checkTx !== null && (B.checkTx = e.ResponseCheckTx.fromPartial(d.checkTx)), d.deliverTx !== void 0 && d.deliverTx !== null && (B.deliverTx = e.ResponseDeliverTx.fromPartial(d.deliverTx)), d.endBlock !== void 0 && d.endBlock !== null && (B.endBlock = e.ResponseEndBlock.fromPartial(d.endBlock)), d.commit !== void 0 && d.commit !== null && (B.commit = e.ResponseCommit.fromPartial(d.commit)), d.listSnapshots !== void 0 && d.listSnapshots !== null && (B.listSnapshots = e.ResponseListSnapshots.fromPartial(d.listSnapshots)), d.offerSnapshot !== void 0 && d.offerSnapshot !== null && (B.offerSnapshot = e.ResponseOfferSnapshot.fromPartial(d.offerSnapshot)), d.loadSnapshotChunk !== void 0 && d.loadSnapshotChunk !== null && (B.loadSnapshotChunk = e.ResponseLoadSnapshotChunk.fromPartial(d.loadSnapshotChunk)), d.applySnapshotChunk !== void 0 && d.applySnapshotChunk !== null && (B.applySnapshotChunk = e.ResponseApplySnapshotChunk.fromPartial(d.applySnapshotChunk)), d.prepareProposal !== void 0 && d.prepareProposal !== null && (B.prepareProposal = e.ResponsePrepareProposal.fromPartial(d.prepareProposal)), d.processProposal !== void 0 && d.processProposal !== null && (B.processProposal = e.ResponseProcessProposal.fromPartial(d.processProposal)), B;
    }
  };
  function L() {
    return {
      error: ""
    };
  }
  e.ResponseException = {
    typeUrl: "/tendermint.abci.ResponseException",
    encode(d, B = k.BinaryWriter.create()) {
      return d.error !== "" && B.uint32(10).string(d.error), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = L();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.error = M.string();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = L();
      return (0, C.isSet)(d.error) && (B.error = String(d.error)), B;
    },
    toJSON(d) {
      const B = {};
      return d.error !== void 0 && (B.error = d.error), B;
    },
    fromPartial(d) {
      const B = L();
      return B.error = d.error ?? "", B;
    }
  };
  function ne() {
    return {
      message: ""
    };
  }
  e.ResponseEcho = {
    typeUrl: "/tendermint.abci.ResponseEcho",
    encode(d, B = k.BinaryWriter.create()) {
      return d.message !== "" && B.uint32(10).string(d.message), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = ne();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.message = M.string();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = ne();
      return (0, C.isSet)(d.message) && (B.message = String(d.message)), B;
    },
    toJSON(d) {
      const B = {};
      return d.message !== void 0 && (B.message = d.message), B;
    },
    fromPartial(d) {
      const B = ne();
      return B.message = d.message ?? "", B;
    }
  };
  function fa() {
    return {};
  }
  e.ResponseFlush = {
    typeUrl: "/tendermint.abci.ResponseFlush",
    encode(d, B = k.BinaryWriter.create()) {
      return B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = fa();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      return fa();
    },
    toJSON(d) {
      return {};
    },
    fromPartial(d) {
      return fa();
    }
  };
  function pa() {
    return {
      data: "",
      version: "",
      appVersion: BigInt(0),
      lastBlockHeight: BigInt(0),
      lastBlockAppHash: new Uint8Array()
    };
  }
  e.ResponseInfo = {
    typeUrl: "/tendermint.abci.ResponseInfo",
    encode(d, B = k.BinaryWriter.create()) {
      return d.data !== "" && B.uint32(10).string(d.data), d.version !== "" && B.uint32(18).string(d.version), d.appVersion !== BigInt(0) && B.uint32(24).uint64(d.appVersion), d.lastBlockHeight !== BigInt(0) && B.uint32(32).int64(d.lastBlockHeight), d.lastBlockAppHash.length !== 0 && B.uint32(42).bytes(d.lastBlockAppHash), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = pa();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.data = M.string();
            break;
          case 2:
            F.version = M.string();
            break;
          case 3:
            F.appVersion = M.uint64();
            break;
          case 4:
            F.lastBlockHeight = M.int64();
            break;
          case 5:
            F.lastBlockAppHash = M.bytes();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = pa();
      return (0, C.isSet)(d.data) && (B.data = String(d.data)), (0, C.isSet)(d.version) && (B.version = String(d.version)), (0, C.isSet)(d.appVersion) && (B.appVersion = BigInt(d.appVersion.toString())), (0, C.isSet)(d.lastBlockHeight) && (B.lastBlockHeight = BigInt(d.lastBlockHeight.toString())), (0, C.isSet)(d.lastBlockAppHash) && (B.lastBlockAppHash = (0, C.bytesFromBase64)(d.lastBlockAppHash)), B;
    },
    toJSON(d) {
      const B = {};
      return d.data !== void 0 && (B.data = d.data), d.version !== void 0 && (B.version = d.version), d.appVersion !== void 0 && (B.appVersion = (d.appVersion || BigInt(0)).toString()), d.lastBlockHeight !== void 0 && (B.lastBlockHeight = (d.lastBlockHeight || BigInt(0)).toString()), d.lastBlockAppHash !== void 0 && (B.lastBlockAppHash = (0, C.base64FromBytes)(d.lastBlockAppHash !== void 0 ? d.lastBlockAppHash : new Uint8Array())), B;
    },
    fromPartial(d) {
      const B = pa();
      return B.data = d.data ?? "", B.version = d.version ?? "", d.appVersion !== void 0 && d.appVersion !== null && (B.appVersion = BigInt(d.appVersion.toString())), d.lastBlockHeight !== void 0 && d.lastBlockHeight !== null && (B.lastBlockHeight = BigInt(d.lastBlockHeight.toString())), B.lastBlockAppHash = d.lastBlockAppHash ?? new Uint8Array(), B;
    }
  };
  function ha() {
    return {
      consensusParams: void 0,
      validators: [],
      appHash: new Uint8Array()
    };
  }
  e.ResponseInitChain = {
    typeUrl: "/tendermint.abci.ResponseInitChain",
    encode(d, B = k.BinaryWriter.create()) {
      d.consensusParams !== void 0 && r.ConsensusParams.encode(d.consensusParams, B.uint32(10).fork()).ldelim();
      for (const M of d.validators)
        e.ValidatorUpdate.encode(M, B.uint32(18).fork()).ldelim();
      return d.appHash.length !== 0 && B.uint32(26).bytes(d.appHash), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = ha();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.consensusParams = r.ConsensusParams.decode(M, M.uint32());
            break;
          case 2:
            F.validators.push(e.ValidatorUpdate.decode(M, M.uint32()));
            break;
          case 3:
            F.appHash = M.bytes();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = ha();
      return (0, C.isSet)(d.consensusParams) && (B.consensusParams = r.ConsensusParams.fromJSON(d.consensusParams)), Array.isArray(d == null ? void 0 : d.validators) && (B.validators = d.validators.map((M) => e.ValidatorUpdate.fromJSON(M))), (0, C.isSet)(d.appHash) && (B.appHash = (0, C.bytesFromBase64)(d.appHash)), B;
    },
    toJSON(d) {
      const B = {};
      return d.consensusParams !== void 0 && (B.consensusParams = d.consensusParams ? r.ConsensusParams.toJSON(d.consensusParams) : void 0), d.validators ? B.validators = d.validators.map((M) => M ? e.ValidatorUpdate.toJSON(M) : void 0) : B.validators = [], d.appHash !== void 0 && (B.appHash = (0, C.base64FromBytes)(d.appHash !== void 0 ? d.appHash : new Uint8Array())), B;
    },
    fromPartial(d) {
      var M;
      const B = ha();
      return d.consensusParams !== void 0 && d.consensusParams !== null && (B.consensusParams = r.ConsensusParams.fromPartial(d.consensusParams)), B.validators = ((M = d.validators) == null ? void 0 : M.map((z) => e.ValidatorUpdate.fromPartial(z))) || [], B.appHash = d.appHash ?? new Uint8Array(), B;
    }
  };
  function ya() {
    return {
      code: 0,
      log: "",
      info: "",
      index: BigInt(0),
      key: new Uint8Array(),
      value: new Uint8Array(),
      proofOps: void 0,
      height: BigInt(0),
      codespace: ""
    };
  }
  e.ResponseQuery = {
    typeUrl: "/tendermint.abci.ResponseQuery",
    encode(d, B = k.BinaryWriter.create()) {
      return d.code !== 0 && B.uint32(8).uint32(d.code), d.log !== "" && B.uint32(26).string(d.log), d.info !== "" && B.uint32(34).string(d.info), d.index !== BigInt(0) && B.uint32(40).int64(d.index), d.key.length !== 0 && B.uint32(50).bytes(d.key), d.value.length !== 0 && B.uint32(58).bytes(d.value), d.proofOps !== void 0 && i.ProofOps.encode(d.proofOps, B.uint32(66).fork()).ldelim(), d.height !== BigInt(0) && B.uint32(72).int64(d.height), d.codespace !== "" && B.uint32(82).string(d.codespace), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = ya();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.code = M.uint32();
            break;
          case 3:
            F.log = M.string();
            break;
          case 4:
            F.info = M.string();
            break;
          case 5:
            F.index = M.int64();
            break;
          case 6:
            F.key = M.bytes();
            break;
          case 7:
            F.value = M.bytes();
            break;
          case 8:
            F.proofOps = i.ProofOps.decode(M, M.uint32());
            break;
          case 9:
            F.height = M.int64();
            break;
          case 10:
            F.codespace = M.string();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = ya();
      return (0, C.isSet)(d.code) && (B.code = Number(d.code)), (0, C.isSet)(d.log) && (B.log = String(d.log)), (0, C.isSet)(d.info) && (B.info = String(d.info)), (0, C.isSet)(d.index) && (B.index = BigInt(d.index.toString())), (0, C.isSet)(d.key) && (B.key = (0, C.bytesFromBase64)(d.key)), (0, C.isSet)(d.value) && (B.value = (0, C.bytesFromBase64)(d.value)), (0, C.isSet)(d.proofOps) && (B.proofOps = i.ProofOps.fromJSON(d.proofOps)), (0, C.isSet)(d.height) && (B.height = BigInt(d.height.toString())), (0, C.isSet)(d.codespace) && (B.codespace = String(d.codespace)), B;
    },
    toJSON(d) {
      const B = {};
      return d.code !== void 0 && (B.code = Math.round(d.code)), d.log !== void 0 && (B.log = d.log), d.info !== void 0 && (B.info = d.info), d.index !== void 0 && (B.index = (d.index || BigInt(0)).toString()), d.key !== void 0 && (B.key = (0, C.base64FromBytes)(d.key !== void 0 ? d.key : new Uint8Array())), d.value !== void 0 && (B.value = (0, C.base64FromBytes)(d.value !== void 0 ? d.value : new Uint8Array())), d.proofOps !== void 0 && (B.proofOps = d.proofOps ? i.ProofOps.toJSON(d.proofOps) : void 0), d.height !== void 0 && (B.height = (d.height || BigInt(0)).toString()), d.codespace !== void 0 && (B.codespace = d.codespace), B;
    },
    fromPartial(d) {
      const B = ya();
      return B.code = d.code ?? 0, B.log = d.log ?? "", B.info = d.info ?? "", d.index !== void 0 && d.index !== null && (B.index = BigInt(d.index.toString())), B.key = d.key ?? new Uint8Array(), B.value = d.value ?? new Uint8Array(), d.proofOps !== void 0 && d.proofOps !== null && (B.proofOps = i.ProofOps.fromPartial(d.proofOps)), d.height !== void 0 && d.height !== null && (B.height = BigInt(d.height.toString())), B.codespace = d.codespace ?? "", B;
    }
  };
  function ma() {
    return {
      events: []
    };
  }
  e.ResponseBeginBlock = {
    typeUrl: "/tendermint.abci.ResponseBeginBlock",
    encode(d, B = k.BinaryWriter.create()) {
      for (const M of d.events)
        e.Event.encode(M, B.uint32(10).fork()).ldelim();
      return B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = ma();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.events.push(e.Event.decode(M, M.uint32()));
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = ma();
      return Array.isArray(d == null ? void 0 : d.events) && (B.events = d.events.map((M) => e.Event.fromJSON(M))), B;
    },
    toJSON(d) {
      const B = {};
      return d.events ? B.events = d.events.map((M) => M ? e.Event.toJSON(M) : void 0) : B.events = [], B;
    },
    fromPartial(d) {
      var M;
      const B = ma();
      return B.events = ((M = d.events) == null ? void 0 : M.map((z) => e.Event.fromPartial(z))) || [], B;
    }
  };
  function ga() {
    return {
      code: 0,
      data: new Uint8Array(),
      log: "",
      info: "",
      gasWanted: BigInt(0),
      gasUsed: BigInt(0),
      events: [],
      codespace: "",
      sender: "",
      priority: BigInt(0),
      mempoolError: ""
    };
  }
  e.ResponseCheckTx = {
    typeUrl: "/tendermint.abci.ResponseCheckTx",
    encode(d, B = k.BinaryWriter.create()) {
      d.code !== 0 && B.uint32(8).uint32(d.code), d.data.length !== 0 && B.uint32(18).bytes(d.data), d.log !== "" && B.uint32(26).string(d.log), d.info !== "" && B.uint32(34).string(d.info), d.gasWanted !== BigInt(0) && B.uint32(40).int64(d.gasWanted), d.gasUsed !== BigInt(0) && B.uint32(48).int64(d.gasUsed);
      for (const M of d.events)
        e.Event.encode(M, B.uint32(58).fork()).ldelim();
      return d.codespace !== "" && B.uint32(66).string(d.codespace), d.sender !== "" && B.uint32(74).string(d.sender), d.priority !== BigInt(0) && B.uint32(80).int64(d.priority), d.mempoolError !== "" && B.uint32(90).string(d.mempoolError), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = ga();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.code = M.uint32();
            break;
          case 2:
            F.data = M.bytes();
            break;
          case 3:
            F.log = M.string();
            break;
          case 4:
            F.info = M.string();
            break;
          case 5:
            F.gasWanted = M.int64();
            break;
          case 6:
            F.gasUsed = M.int64();
            break;
          case 7:
            F.events.push(e.Event.decode(M, M.uint32()));
            break;
          case 8:
            F.codespace = M.string();
            break;
          case 9:
            F.sender = M.string();
            break;
          case 10:
            F.priority = M.int64();
            break;
          case 11:
            F.mempoolError = M.string();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = ga();
      return (0, C.isSet)(d.code) && (B.code = Number(d.code)), (0, C.isSet)(d.data) && (B.data = (0, C.bytesFromBase64)(d.data)), (0, C.isSet)(d.log) && (B.log = String(d.log)), (0, C.isSet)(d.info) && (B.info = String(d.info)), (0, C.isSet)(d.gas_wanted) && (B.gasWanted = BigInt(d.gas_wanted.toString())), (0, C.isSet)(d.gas_used) && (B.gasUsed = BigInt(d.gas_used.toString())), Array.isArray(d == null ? void 0 : d.events) && (B.events = d.events.map((M) => e.Event.fromJSON(M))), (0, C.isSet)(d.codespace) && (B.codespace = String(d.codespace)), (0, C.isSet)(d.sender) && (B.sender = String(d.sender)), (0, C.isSet)(d.priority) && (B.priority = BigInt(d.priority.toString())), (0, C.isSet)(d.mempoolError) && (B.mempoolError = String(d.mempoolError)), B;
    },
    toJSON(d) {
      const B = {};
      return d.code !== void 0 && (B.code = Math.round(d.code)), d.data !== void 0 && (B.data = (0, C.base64FromBytes)(d.data !== void 0 ? d.data : new Uint8Array())), d.log !== void 0 && (B.log = d.log), d.info !== void 0 && (B.info = d.info), d.gasWanted !== void 0 && (B.gas_wanted = (d.gasWanted || BigInt(0)).toString()), d.gasUsed !== void 0 && (B.gas_used = (d.gasUsed || BigInt(0)).toString()), d.events ? B.events = d.events.map((M) => M ? e.Event.toJSON(M) : void 0) : B.events = [], d.codespace !== void 0 && (B.codespace = d.codespace), d.sender !== void 0 && (B.sender = d.sender), d.priority !== void 0 && (B.priority = (d.priority || BigInt(0)).toString()), d.mempoolError !== void 0 && (B.mempoolError = d.mempoolError), B;
    },
    fromPartial(d) {
      var M;
      const B = ga();
      return B.code = d.code ?? 0, B.data = d.data ?? new Uint8Array(), B.log = d.log ?? "", B.info = d.info ?? "", d.gasWanted !== void 0 && d.gasWanted !== null && (B.gasWanted = BigInt(d.gasWanted.toString())), d.gasUsed !== void 0 && d.gasUsed !== null && (B.gasUsed = BigInt(d.gasUsed.toString())), B.events = ((M = d.events) == null ? void 0 : M.map((z) => e.Event.fromPartial(z))) || [], B.codespace = d.codespace ?? "", B.sender = d.sender ?? "", d.priority !== void 0 && d.priority !== null && (B.priority = BigInt(d.priority.toString())), B.mempoolError = d.mempoolError ?? "", B;
    }
  };
  function Sa() {
    return {
      code: 0,
      data: new Uint8Array(),
      log: "",
      info: "",
      gasWanted: BigInt(0),
      gasUsed: BigInt(0),
      events: [],
      codespace: ""
    };
  }
  e.ResponseDeliverTx = {
    typeUrl: "/tendermint.abci.ResponseDeliverTx",
    encode(d, B = k.BinaryWriter.create()) {
      d.code !== 0 && B.uint32(8).uint32(d.code), d.data.length !== 0 && B.uint32(18).bytes(d.data), d.log !== "" && B.uint32(26).string(d.log), d.info !== "" && B.uint32(34).string(d.info), d.gasWanted !== BigInt(0) && B.uint32(40).int64(d.gasWanted), d.gasUsed !== BigInt(0) && B.uint32(48).int64(d.gasUsed);
      for (const M of d.events)
        e.Event.encode(M, B.uint32(58).fork()).ldelim();
      return d.codespace !== "" && B.uint32(66).string(d.codespace), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = Sa();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.code = M.uint32();
            break;
          case 2:
            F.data = M.bytes();
            break;
          case 3:
            F.log = M.string();
            break;
          case 4:
            F.info = M.string();
            break;
          case 5:
            F.gasWanted = M.int64();
            break;
          case 6:
            F.gasUsed = M.int64();
            break;
          case 7:
            F.events.push(e.Event.decode(M, M.uint32()));
            break;
          case 8:
            F.codespace = M.string();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = Sa();
      return (0, C.isSet)(d.code) && (B.code = Number(d.code)), (0, C.isSet)(d.data) && (B.data = (0, C.bytesFromBase64)(d.data)), (0, C.isSet)(d.log) && (B.log = String(d.log)), (0, C.isSet)(d.info) && (B.info = String(d.info)), (0, C.isSet)(d.gas_wanted) && (B.gasWanted = BigInt(d.gas_wanted.toString())), (0, C.isSet)(d.gas_used) && (B.gasUsed = BigInt(d.gas_used.toString())), Array.isArray(d == null ? void 0 : d.events) && (B.events = d.events.map((M) => e.Event.fromJSON(M))), (0, C.isSet)(d.codespace) && (B.codespace = String(d.codespace)), B;
    },
    toJSON(d) {
      const B = {};
      return d.code !== void 0 && (B.code = Math.round(d.code)), d.data !== void 0 && (B.data = (0, C.base64FromBytes)(d.data !== void 0 ? d.data : new Uint8Array())), d.log !== void 0 && (B.log = d.log), d.info !== void 0 && (B.info = d.info), d.gasWanted !== void 0 && (B.gas_wanted = (d.gasWanted || BigInt(0)).toString()), d.gasUsed !== void 0 && (B.gas_used = (d.gasUsed || BigInt(0)).toString()), d.events ? B.events = d.events.map((M) => M ? e.Event.toJSON(M) : void 0) : B.events = [], d.codespace !== void 0 && (B.codespace = d.codespace), B;
    },
    fromPartial(d) {
      var M;
      const B = Sa();
      return B.code = d.code ?? 0, B.data = d.data ?? new Uint8Array(), B.log = d.log ?? "", B.info = d.info ?? "", d.gasWanted !== void 0 && d.gasWanted !== null && (B.gasWanted = BigInt(d.gasWanted.toString())), d.gasUsed !== void 0 && d.gasUsed !== null && (B.gasUsed = BigInt(d.gasUsed.toString())), B.events = ((M = d.events) == null ? void 0 : M.map((z) => e.Event.fromPartial(z))) || [], B.codespace = d.codespace ?? "", B;
    }
  };
  function ka() {
    return {
      validatorUpdates: [],
      consensusParamUpdates: void 0,
      events: []
    };
  }
  e.ResponseEndBlock = {
    typeUrl: "/tendermint.abci.ResponseEndBlock",
    encode(d, B = k.BinaryWriter.create()) {
      for (const M of d.validatorUpdates)
        e.ValidatorUpdate.encode(M, B.uint32(10).fork()).ldelim();
      d.consensusParamUpdates !== void 0 && r.ConsensusParams.encode(d.consensusParamUpdates, B.uint32(18).fork()).ldelim();
      for (const M of d.events)
        e.Event.encode(M, B.uint32(26).fork()).ldelim();
      return B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = ka();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.validatorUpdates.push(e.ValidatorUpdate.decode(M, M.uint32()));
            break;
          case 2:
            F.consensusParamUpdates = r.ConsensusParams.decode(M, M.uint32());
            break;
          case 3:
            F.events.push(e.Event.decode(M, M.uint32()));
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = ka();
      return Array.isArray(d == null ? void 0 : d.validatorUpdates) && (B.validatorUpdates = d.validatorUpdates.map((M) => e.ValidatorUpdate.fromJSON(M))), (0, C.isSet)(d.consensusParamUpdates) && (B.consensusParamUpdates = r.ConsensusParams.fromJSON(d.consensusParamUpdates)), Array.isArray(d == null ? void 0 : d.events) && (B.events = d.events.map((M) => e.Event.fromJSON(M))), B;
    },
    toJSON(d) {
      const B = {};
      return d.validatorUpdates ? B.validatorUpdates = d.validatorUpdates.map((M) => M ? e.ValidatorUpdate.toJSON(M) : void 0) : B.validatorUpdates = [], d.consensusParamUpdates !== void 0 && (B.consensusParamUpdates = d.consensusParamUpdates ? r.ConsensusParams.toJSON(d.consensusParamUpdates) : void 0), d.events ? B.events = d.events.map((M) => M ? e.Event.toJSON(M) : void 0) : B.events = [], B;
    },
    fromPartial(d) {
      var M, z;
      const B = ka();
      return B.validatorUpdates = ((M = d.validatorUpdates) == null ? void 0 : M.map((F) => e.ValidatorUpdate.fromPartial(F))) || [], d.consensusParamUpdates !== void 0 && d.consensusParamUpdates !== null && (B.consensusParamUpdates = r.ConsensusParams.fromPartial(d.consensusParamUpdates)), B.events = ((z = d.events) == null ? void 0 : z.map((F) => e.Event.fromPartial(F))) || [], B;
    }
  };
  function Pa() {
    return {
      data: new Uint8Array(),
      retainHeight: BigInt(0)
    };
  }
  e.ResponseCommit = {
    typeUrl: "/tendermint.abci.ResponseCommit",
    encode(d, B = k.BinaryWriter.create()) {
      return d.data.length !== 0 && B.uint32(18).bytes(d.data), d.retainHeight !== BigInt(0) && B.uint32(24).int64(d.retainHeight), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = Pa();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 2:
            F.data = M.bytes();
            break;
          case 3:
            F.retainHeight = M.int64();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = Pa();
      return (0, C.isSet)(d.data) && (B.data = (0, C.bytesFromBase64)(d.data)), (0, C.isSet)(d.retainHeight) && (B.retainHeight = BigInt(d.retainHeight.toString())), B;
    },
    toJSON(d) {
      const B = {};
      return d.data !== void 0 && (B.data = (0, C.base64FromBytes)(d.data !== void 0 ? d.data : new Uint8Array())), d.retainHeight !== void 0 && (B.retainHeight = (d.retainHeight || BigInt(0)).toString()), B;
    },
    fromPartial(d) {
      const B = Pa();
      return B.data = d.data ?? new Uint8Array(), d.retainHeight !== void 0 && d.retainHeight !== null && (B.retainHeight = BigInt(d.retainHeight.toString())), B;
    }
  };
  function va() {
    return {
      snapshots: []
    };
  }
  e.ResponseListSnapshots = {
    typeUrl: "/tendermint.abci.ResponseListSnapshots",
    encode(d, B = k.BinaryWriter.create()) {
      for (const M of d.snapshots)
        e.Snapshot.encode(M, B.uint32(10).fork()).ldelim();
      return B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = va();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.snapshots.push(e.Snapshot.decode(M, M.uint32()));
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = va();
      return Array.isArray(d == null ? void 0 : d.snapshots) && (B.snapshots = d.snapshots.map((M) => e.Snapshot.fromJSON(M))), B;
    },
    toJSON(d) {
      const B = {};
      return d.snapshots ? B.snapshots = d.snapshots.map((M) => M ? e.Snapshot.toJSON(M) : void 0) : B.snapshots = [], B;
    },
    fromPartial(d) {
      var M;
      const B = va();
      return B.snapshots = ((M = d.snapshots) == null ? void 0 : M.map((z) => e.Snapshot.fromPartial(z))) || [], B;
    }
  };
  function Ra() {
    return {
      result: 0
    };
  }
  e.ResponseOfferSnapshot = {
    typeUrl: "/tendermint.abci.ResponseOfferSnapshot",
    encode(d, B = k.BinaryWriter.create()) {
      return d.result !== 0 && B.uint32(8).int32(d.result), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = Ra();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.result = M.int32();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = Ra();
      return (0, C.isSet)(d.result) && (B.result = h(d.result)), B;
    },
    toJSON(d) {
      const B = {};
      return d.result !== void 0 && (B.result = P(d.result)), B;
    },
    fromPartial(d) {
      const B = Ra();
      return B.result = d.result ?? 0, B;
    }
  };
  function Ba() {
    return {
      chunk: new Uint8Array()
    };
  }
  e.ResponseLoadSnapshotChunk = {
    typeUrl: "/tendermint.abci.ResponseLoadSnapshotChunk",
    encode(d, B = k.BinaryWriter.create()) {
      return d.chunk.length !== 0 && B.uint32(10).bytes(d.chunk), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = Ba();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.chunk = M.bytes();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = Ba();
      return (0, C.isSet)(d.chunk) && (B.chunk = (0, C.bytesFromBase64)(d.chunk)), B;
    },
    toJSON(d) {
      const B = {};
      return d.chunk !== void 0 && (B.chunk = (0, C.base64FromBytes)(d.chunk !== void 0 ? d.chunk : new Uint8Array())), B;
    },
    fromPartial(d) {
      const B = Ba();
      return B.chunk = d.chunk ?? new Uint8Array(), B;
    }
  };
  function Oa() {
    return {
      result: 0,
      refetchChunks: [],
      rejectSenders: []
    };
  }
  e.ResponseApplySnapshotChunk = {
    typeUrl: "/tendermint.abci.ResponseApplySnapshotChunk",
    encode(d, B = k.BinaryWriter.create()) {
      d.result !== 0 && B.uint32(8).int32(d.result), B.uint32(18).fork();
      for (const M of d.refetchChunks)
        B.uint32(M);
      B.ldelim();
      for (const M of d.rejectSenders)
        B.uint32(26).string(M);
      return B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = Oa();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.result = M.int32();
            break;
          case 2:
            if ((K & 7) === 2) {
              const Sp = M.uint32() + M.pos;
              for (; M.pos < Sp; )
                F.refetchChunks.push(M.uint32());
            } else
              F.refetchChunks.push(M.uint32());
            break;
          case 3:
            F.rejectSenders.push(M.string());
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = Oa();
      return (0, C.isSet)(d.result) && (B.result = c(d.result)), Array.isArray(d == null ? void 0 : d.refetchChunks) && (B.refetchChunks = d.refetchChunks.map((M) => Number(M))), Array.isArray(d == null ? void 0 : d.rejectSenders) && (B.rejectSenders = d.rejectSenders.map((M) => String(M))), B;
    },
    toJSON(d) {
      const B = {};
      return d.result !== void 0 && (B.result = l(d.result)), d.refetchChunks ? B.refetchChunks = d.refetchChunks.map((M) => Math.round(M)) : B.refetchChunks = [], d.rejectSenders ? B.rejectSenders = d.rejectSenders.map((M) => M) : B.rejectSenders = [], B;
    },
    fromPartial(d) {
      var M, z;
      const B = Oa();
      return B.result = d.result ?? 0, B.refetchChunks = ((M = d.refetchChunks) == null ? void 0 : M.map((F) => F)) || [], B.rejectSenders = ((z = d.rejectSenders) == null ? void 0 : z.map((F) => F)) || [], B;
    }
  };
  function ba() {
    return {
      txs: []
    };
  }
  e.ResponsePrepareProposal = {
    typeUrl: "/tendermint.abci.ResponsePrepareProposal",
    encode(d, B = k.BinaryWriter.create()) {
      for (const M of d.txs)
        B.uint32(10).bytes(M);
      return B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = ba();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.txs.push(M.bytes());
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = ba();
      return Array.isArray(d == null ? void 0 : d.txs) && (B.txs = d.txs.map((M) => (0, C.bytesFromBase64)(M))), B;
    },
    toJSON(d) {
      const B = {};
      return d.txs ? B.txs = d.txs.map((M) => (0, C.base64FromBytes)(M !== void 0 ? M : new Uint8Array())) : B.txs = [], B;
    },
    fromPartial(d) {
      var M;
      const B = ba();
      return B.txs = ((M = d.txs) == null ? void 0 : M.map((z) => z)) || [], B;
    }
  };
  function Aa() {
    return {
      status: 0
    };
  }
  e.ResponseProcessProposal = {
    typeUrl: "/tendermint.abci.ResponseProcessProposal",
    encode(d, B = k.BinaryWriter.create()) {
      return d.status !== 0 && B.uint32(8).int32(d.status), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = Aa();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.status = M.int32();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = Aa();
      return (0, C.isSet)(d.status) && (B.status = E(d.status)), B;
    },
    toJSON(d) {
      const B = {};
      return d.status !== void 0 && (B.status = J(d.status)), B;
    },
    fromPartial(d) {
      const B = Aa();
      return B.status = d.status ?? 0, B;
    }
  };
  function Ia() {
    return {
      round: 0,
      votes: []
    };
  }
  e.CommitInfo = {
    typeUrl: "/tendermint.abci.CommitInfo",
    encode(d, B = k.BinaryWriter.create()) {
      d.round !== 0 && B.uint32(8).int32(d.round);
      for (const M of d.votes)
        e.VoteInfo.encode(M, B.uint32(18).fork()).ldelim();
      return B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = Ia();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.round = M.int32();
            break;
          case 2:
            F.votes.push(e.VoteInfo.decode(M, M.uint32()));
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = Ia();
      return (0, C.isSet)(d.round) && (B.round = Number(d.round)), Array.isArray(d == null ? void 0 : d.votes) && (B.votes = d.votes.map((M) => e.VoteInfo.fromJSON(M))), B;
    },
    toJSON(d) {
      const B = {};
      return d.round !== void 0 && (B.round = Math.round(d.round)), d.votes ? B.votes = d.votes.map((M) => M ? e.VoteInfo.toJSON(M) : void 0) : B.votes = [], B;
    },
    fromPartial(d) {
      var M;
      const B = Ia();
      return B.round = d.round ?? 0, B.votes = ((M = d.votes) == null ? void 0 : M.map((z) => e.VoteInfo.fromPartial(z))) || [], B;
    }
  };
  function Ta() {
    return {
      round: 0,
      votes: []
    };
  }
  e.ExtendedCommitInfo = {
    typeUrl: "/tendermint.abci.ExtendedCommitInfo",
    encode(d, B = k.BinaryWriter.create()) {
      d.round !== 0 && B.uint32(8).int32(d.round);
      for (const M of d.votes)
        e.ExtendedVoteInfo.encode(M, B.uint32(18).fork()).ldelim();
      return B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = Ta();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.round = M.int32();
            break;
          case 2:
            F.votes.push(e.ExtendedVoteInfo.decode(M, M.uint32()));
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = Ta();
      return (0, C.isSet)(d.round) && (B.round = Number(d.round)), Array.isArray(d == null ? void 0 : d.votes) && (B.votes = d.votes.map((M) => e.ExtendedVoteInfo.fromJSON(M))), B;
    },
    toJSON(d) {
      const B = {};
      return d.round !== void 0 && (B.round = Math.round(d.round)), d.votes ? B.votes = d.votes.map((M) => M ? e.ExtendedVoteInfo.toJSON(M) : void 0) : B.votes = [], B;
    },
    fromPartial(d) {
      var M;
      const B = Ta();
      return B.round = d.round ?? 0, B.votes = ((M = d.votes) == null ? void 0 : M.map((z) => e.ExtendedVoteInfo.fromPartial(z))) || [], B;
    }
  };
  function Ca() {
    return {
      type: "",
      attributes: []
    };
  }
  e.Event = {
    typeUrl: "/tendermint.abci.Event",
    encode(d, B = k.BinaryWriter.create()) {
      d.type !== "" && B.uint32(10).string(d.type);
      for (const M of d.attributes)
        e.EventAttribute.encode(M, B.uint32(18).fork()).ldelim();
      return B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = Ca();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.type = M.string();
            break;
          case 2:
            F.attributes.push(e.EventAttribute.decode(M, M.uint32()));
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = Ca();
      return (0, C.isSet)(d.type) && (B.type = String(d.type)), Array.isArray(d == null ? void 0 : d.attributes) && (B.attributes = d.attributes.map((M) => e.EventAttribute.fromJSON(M))), B;
    },
    toJSON(d) {
      const B = {};
      return d.type !== void 0 && (B.type = d.type), d.attributes ? B.attributes = d.attributes.map((M) => M ? e.EventAttribute.toJSON(M) : void 0) : B.attributes = [], B;
    },
    fromPartial(d) {
      var M;
      const B = Ca();
      return B.type = d.type ?? "", B.attributes = ((M = d.attributes) == null ? void 0 : M.map((z) => e.EventAttribute.fromPartial(z))) || [], B;
    }
  };
  function Na() {
    return {
      key: "",
      value: "",
      index: !1
    };
  }
  e.EventAttribute = {
    typeUrl: "/tendermint.abci.EventAttribute",
    encode(d, B = k.BinaryWriter.create()) {
      return d.key !== "" && B.uint32(10).string(d.key), d.value !== "" && B.uint32(18).string(d.value), d.index === !0 && B.uint32(24).bool(d.index), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = Na();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.key = M.string();
            break;
          case 2:
            F.value = M.string();
            break;
          case 3:
            F.index = M.bool();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = Na();
      return (0, C.isSet)(d.key) && (B.key = String(d.key)), (0, C.isSet)(d.value) && (B.value = String(d.value)), (0, C.isSet)(d.index) && (B.index = !!d.index), B;
    },
    toJSON(d) {
      const B = {};
      return d.key !== void 0 && (B.key = d.key), d.value !== void 0 && (B.value = d.value), d.index !== void 0 && (B.index = d.index), B;
    },
    fromPartial(d) {
      const B = Na();
      return B.key = d.key ?? "", B.value = d.value ?? "", B.index = d.index ?? !1, B;
    }
  };
  function wa() {
    return {
      height: BigInt(0),
      index: 0,
      tx: new Uint8Array(),
      result: e.ResponseDeliverTx.fromPartial({})
    };
  }
  e.TxResult = {
    typeUrl: "/tendermint.abci.TxResult",
    encode(d, B = k.BinaryWriter.create()) {
      return d.height !== BigInt(0) && B.uint32(8).int64(d.height), d.index !== 0 && B.uint32(16).uint32(d.index), d.tx.length !== 0 && B.uint32(26).bytes(d.tx), d.result !== void 0 && e.ResponseDeliverTx.encode(d.result, B.uint32(34).fork()).ldelim(), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = wa();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.height = M.int64();
            break;
          case 2:
            F.index = M.uint32();
            break;
          case 3:
            F.tx = M.bytes();
            break;
          case 4:
            F.result = e.ResponseDeliverTx.decode(M, M.uint32());
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = wa();
      return (0, C.isSet)(d.height) && (B.height = BigInt(d.height.toString())), (0, C.isSet)(d.index) && (B.index = Number(d.index)), (0, C.isSet)(d.tx) && (B.tx = (0, C.bytesFromBase64)(d.tx)), (0, C.isSet)(d.result) && (B.result = e.ResponseDeliverTx.fromJSON(d.result)), B;
    },
    toJSON(d) {
      const B = {};
      return d.height !== void 0 && (B.height = (d.height || BigInt(0)).toString()), d.index !== void 0 && (B.index = Math.round(d.index)), d.tx !== void 0 && (B.tx = (0, C.base64FromBytes)(d.tx !== void 0 ? d.tx : new Uint8Array())), d.result !== void 0 && (B.result = d.result ? e.ResponseDeliverTx.toJSON(d.result) : void 0), B;
    },
    fromPartial(d) {
      const B = wa();
      return d.height !== void 0 && d.height !== null && (B.height = BigInt(d.height.toString())), B.index = d.index ?? 0, B.tx = d.tx ?? new Uint8Array(), d.result !== void 0 && d.result !== null && (B.result = e.ResponseDeliverTx.fromPartial(d.result)), B;
    }
  };
  function _a() {
    return {
      address: new Uint8Array(),
      power: BigInt(0)
    };
  }
  e.Validator = {
    typeUrl: "/tendermint.abci.Validator",
    encode(d, B = k.BinaryWriter.create()) {
      return d.address.length !== 0 && B.uint32(10).bytes(d.address), d.power !== BigInt(0) && B.uint32(24).int64(d.power), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = _a();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.address = M.bytes();
            break;
          case 3:
            F.power = M.int64();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = _a();
      return (0, C.isSet)(d.address) && (B.address = (0, C.bytesFromBase64)(d.address)), (0, C.isSet)(d.power) && (B.power = BigInt(d.power.toString())), B;
    },
    toJSON(d) {
      const B = {};
      return d.address !== void 0 && (B.address = (0, C.base64FromBytes)(d.address !== void 0 ? d.address : new Uint8Array())), d.power !== void 0 && (B.power = (d.power || BigInt(0)).toString()), B;
    },
    fromPartial(d) {
      const B = _a();
      return B.address = d.address ?? new Uint8Array(), d.power !== void 0 && d.power !== null && (B.power = BigInt(d.power.toString())), B;
    }
  };
  function Ea() {
    return {
      pubKey: f.PublicKey.fromPartial({}),
      power: BigInt(0)
    };
  }
  e.ValidatorUpdate = {
    typeUrl: "/tendermint.abci.ValidatorUpdate",
    encode(d, B = k.BinaryWriter.create()) {
      return d.pubKey !== void 0 && f.PublicKey.encode(d.pubKey, B.uint32(10).fork()).ldelim(), d.power !== BigInt(0) && B.uint32(16).int64(d.power), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = Ea();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.pubKey = f.PublicKey.decode(M, M.uint32());
            break;
          case 2:
            F.power = M.int64();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = Ea();
      return (0, C.isSet)(d.pubKey) && (B.pubKey = f.PublicKey.fromJSON(d.pubKey)), (0, C.isSet)(d.power) && (B.power = BigInt(d.power.toString())), B;
    },
    toJSON(d) {
      const B = {};
      return d.pubKey !== void 0 && (B.pubKey = d.pubKey ? f.PublicKey.toJSON(d.pubKey) : void 0), d.power !== void 0 && (B.power = (d.power || BigInt(0)).toString()), B;
    },
    fromPartial(d) {
      const B = Ea();
      return d.pubKey !== void 0 && d.pubKey !== null && (B.pubKey = f.PublicKey.fromPartial(d.pubKey)), d.power !== void 0 && d.power !== null && (B.power = BigInt(d.power.toString())), B;
    }
  };
  function Ja() {
    return {
      validator: e.Validator.fromPartial({}),
      signedLastBlock: !1
    };
  }
  e.VoteInfo = {
    typeUrl: "/tendermint.abci.VoteInfo",
    encode(d, B = k.BinaryWriter.create()) {
      return d.validator !== void 0 && e.Validator.encode(d.validator, B.uint32(10).fork()).ldelim(), d.signedLastBlock === !0 && B.uint32(16).bool(d.signedLastBlock), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = Ja();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.validator = e.Validator.decode(M, M.uint32());
            break;
          case 2:
            F.signedLastBlock = M.bool();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = Ja();
      return (0, C.isSet)(d.validator) && (B.validator = e.Validator.fromJSON(d.validator)), (0, C.isSet)(d.signedLastBlock) && (B.signedLastBlock = !!d.signedLastBlock), B;
    },
    toJSON(d) {
      const B = {};
      return d.validator !== void 0 && (B.validator = d.validator ? e.Validator.toJSON(d.validator) : void 0), d.signedLastBlock !== void 0 && (B.signedLastBlock = d.signedLastBlock), B;
    },
    fromPartial(d) {
      const B = Ja();
      return d.validator !== void 0 && d.validator !== null && (B.validator = e.Validator.fromPartial(d.validator)), B.signedLastBlock = d.signedLastBlock ?? !1, B;
    }
  };
  function Ua() {
    return {
      validator: e.Validator.fromPartial({}),
      signedLastBlock: !1,
      voteExtension: new Uint8Array()
    };
  }
  e.ExtendedVoteInfo = {
    typeUrl: "/tendermint.abci.ExtendedVoteInfo",
    encode(d, B = k.BinaryWriter.create()) {
      return d.validator !== void 0 && e.Validator.encode(d.validator, B.uint32(10).fork()).ldelim(), d.signedLastBlock === !0 && B.uint32(16).bool(d.signedLastBlock), d.voteExtension.length !== 0 && B.uint32(26).bytes(d.voteExtension), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = Ua();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.validator = e.Validator.decode(M, M.uint32());
            break;
          case 2:
            F.signedLastBlock = M.bool();
            break;
          case 3:
            F.voteExtension = M.bytes();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = Ua();
      return (0, C.isSet)(d.validator) && (B.validator = e.Validator.fromJSON(d.validator)), (0, C.isSet)(d.signedLastBlock) && (B.signedLastBlock = !!d.signedLastBlock), (0, C.isSet)(d.voteExtension) && (B.voteExtension = (0, C.bytesFromBase64)(d.voteExtension)), B;
    },
    toJSON(d) {
      const B = {};
      return d.validator !== void 0 && (B.validator = d.validator ? e.Validator.toJSON(d.validator) : void 0), d.signedLastBlock !== void 0 && (B.signedLastBlock = d.signedLastBlock), d.voteExtension !== void 0 && (B.voteExtension = (0, C.base64FromBytes)(d.voteExtension !== void 0 ? d.voteExtension : new Uint8Array())), B;
    },
    fromPartial(d) {
      const B = Ua();
      return d.validator !== void 0 && d.validator !== null && (B.validator = e.Validator.fromPartial(d.validator)), B.signedLastBlock = d.signedLastBlock ?? !1, B.voteExtension = d.voteExtension ?? new Uint8Array(), B;
    }
  };
  function Da() {
    return {
      type: 0,
      validator: e.Validator.fromPartial({}),
      height: BigInt(0),
      time: n.Timestamp.fromPartial({}),
      totalVotingPower: BigInt(0)
    };
  }
  e.Misbehavior = {
    typeUrl: "/tendermint.abci.Misbehavior",
    encode(d, B = k.BinaryWriter.create()) {
      return d.type !== 0 && B.uint32(8).int32(d.type), d.validator !== void 0 && e.Validator.encode(d.validator, B.uint32(18).fork()).ldelim(), d.height !== BigInt(0) && B.uint32(24).int64(d.height), d.time !== void 0 && n.Timestamp.encode(d.time, B.uint32(34).fork()).ldelim(), d.totalVotingPower !== BigInt(0) && B.uint32(40).int64(d.totalVotingPower), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = Da();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.type = M.int32();
            break;
          case 2:
            F.validator = e.Validator.decode(M, M.uint32());
            break;
          case 3:
            F.height = M.int64();
            break;
          case 4:
            F.time = n.Timestamp.decode(M, M.uint32());
            break;
          case 5:
            F.totalVotingPower = M.int64();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = Da();
      return (0, C.isSet)(d.type) && (B.type = V(d.type)), (0, C.isSet)(d.validator) && (B.validator = e.Validator.fromJSON(d.validator)), (0, C.isSet)(d.height) && (B.height = BigInt(d.height.toString())), (0, C.isSet)(d.time) && (B.time = (0, C.fromJsonTimestamp)(d.time)), (0, C.isSet)(d.totalVotingPower) && (B.totalVotingPower = BigInt(d.totalVotingPower.toString())), B;
    },
    toJSON(d) {
      const B = {};
      return d.type !== void 0 && (B.type = o(d.type)), d.validator !== void 0 && (B.validator = d.validator ? e.Validator.toJSON(d.validator) : void 0), d.height !== void 0 && (B.height = (d.height || BigInt(0)).toString()), d.time !== void 0 && (B.time = (0, C.fromTimestamp)(d.time).toISOString()), d.totalVotingPower !== void 0 && (B.totalVotingPower = (d.totalVotingPower || BigInt(0)).toString()), B;
    },
    fromPartial(d) {
      const B = Da();
      return B.type = d.type ?? 0, d.validator !== void 0 && d.validator !== null && (B.validator = e.Validator.fromPartial(d.validator)), d.height !== void 0 && d.height !== null && (B.height = BigInt(d.height.toString())), d.time !== void 0 && d.time !== null && (B.time = n.Timestamp.fromPartial(d.time)), d.totalVotingPower !== void 0 && d.totalVotingPower !== null && (B.totalVotingPower = BigInt(d.totalVotingPower.toString())), B;
    }
  };
  function Ma() {
    return {
      height: BigInt(0),
      format: 0,
      chunks: 0,
      hash: new Uint8Array(),
      metadata: new Uint8Array()
    };
  }
  e.Snapshot = {
    typeUrl: "/tendermint.abci.Snapshot",
    encode(d, B = k.BinaryWriter.create()) {
      return d.height !== BigInt(0) && B.uint32(8).uint64(d.height), d.format !== 0 && B.uint32(16).uint32(d.format), d.chunks !== 0 && B.uint32(24).uint32(d.chunks), d.hash.length !== 0 && B.uint32(34).bytes(d.hash), d.metadata.length !== 0 && B.uint32(42).bytes(d.metadata), B;
    },
    decode(d, B) {
      const M = d instanceof k.BinaryReader ? d : new k.BinaryReader(d);
      let z = B === void 0 ? M.len : M.pos + B;
      const F = Ma();
      for (; M.pos < z; ) {
        const K = M.uint32();
        switch (K >>> 3) {
          case 1:
            F.height = M.uint64();
            break;
          case 2:
            F.format = M.uint32();
            break;
          case 3:
            F.chunks = M.uint32();
            break;
          case 4:
            F.hash = M.bytes();
            break;
          case 5:
            F.metadata = M.bytes();
            break;
          default:
            M.skipType(K & 7);
            break;
        }
      }
      return F;
    },
    fromJSON(d) {
      const B = Ma();
      return (0, C.isSet)(d.height) && (B.height = BigInt(d.height.toString())), (0, C.isSet)(d.format) && (B.format = Number(d.format)), (0, C.isSet)(d.chunks) && (B.chunks = Number(d.chunks)), (0, C.isSet)(d.hash) && (B.hash = (0, C.bytesFromBase64)(d.hash)), (0, C.isSet)(d.metadata) && (B.metadata = (0, C.bytesFromBase64)(d.metadata)), B;
    },
    toJSON(d) {
      const B = {};
      return d.height !== void 0 && (B.height = (d.height || BigInt(0)).toString()), d.format !== void 0 && (B.format = Math.round(d.format)), d.chunks !== void 0 && (B.chunks = Math.round(d.chunks)), d.hash !== void 0 && (B.hash = (0, C.base64FromBytes)(d.hash !== void 0 ? d.hash : new Uint8Array())), d.metadata !== void 0 && (B.metadata = (0, C.base64FromBytes)(d.metadata !== void 0 ? d.metadata : new Uint8Array())), B;
    },
    fromPartial(d) {
      const B = Ma();
      return d.height !== void 0 && d.height !== null && (B.height = BigInt(d.height.toString())), B.format = d.format ?? 0, B.chunks = d.chunks ?? 0, B.hash = d.hash ?? new Uint8Array(), B.metadata = d.metadata ?? new Uint8Array(), B;
    }
  };
  class gp {
    constructor(B) {
      this.rpc = B, this.Echo = this.Echo.bind(this), this.Flush = this.Flush.bind(this), this.Info = this.Info.bind(this), this.DeliverTx = this.DeliverTx.bind(this), this.CheckTx = this.CheckTx.bind(this), this.Query = this.Query.bind(this), this.Commit = this.Commit.bind(this), this.InitChain = this.InitChain.bind(this), this.BeginBlock = this.BeginBlock.bind(this), this.EndBlock = this.EndBlock.bind(this), this.ListSnapshots = this.ListSnapshots.bind(this), this.OfferSnapshot = this.OfferSnapshot.bind(this), this.LoadSnapshotChunk = this.LoadSnapshotChunk.bind(this), this.ApplySnapshotChunk = this.ApplySnapshotChunk.bind(this), this.PrepareProposal = this.PrepareProposal.bind(this), this.ProcessProposal = this.ProcessProposal.bind(this);
    }
    Echo(B) {
      const M = e.RequestEcho.encode(B).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "Echo", M).then((F) => e.ResponseEcho.decode(new k.BinaryReader(F)));
    }
    Flush(B = {}) {
      const M = e.RequestFlush.encode(B).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "Flush", M).then((F) => e.ResponseFlush.decode(new k.BinaryReader(F)));
    }
    Info(B) {
      const M = e.RequestInfo.encode(B).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "Info", M).then((F) => e.ResponseInfo.decode(new k.BinaryReader(F)));
    }
    DeliverTx(B) {
      const M = e.RequestDeliverTx.encode(B).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "DeliverTx", M).then((F) => e.ResponseDeliverTx.decode(new k.BinaryReader(F)));
    }
    CheckTx(B) {
      const M = e.RequestCheckTx.encode(B).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "CheckTx", M).then((F) => e.ResponseCheckTx.decode(new k.BinaryReader(F)));
    }
    Query(B) {
      const M = e.RequestQuery.encode(B).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "Query", M).then((F) => e.ResponseQuery.decode(new k.BinaryReader(F)));
    }
    Commit(B = {}) {
      const M = e.RequestCommit.encode(B).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "Commit", M).then((F) => e.ResponseCommit.decode(new k.BinaryReader(F)));
    }
    InitChain(B) {
      const M = e.RequestInitChain.encode(B).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "InitChain", M).then((F) => e.ResponseInitChain.decode(new k.BinaryReader(F)));
    }
    BeginBlock(B) {
      const M = e.RequestBeginBlock.encode(B).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "BeginBlock", M).then((F) => e.ResponseBeginBlock.decode(new k.BinaryReader(F)));
    }
    EndBlock(B) {
      const M = e.RequestEndBlock.encode(B).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "EndBlock", M).then((F) => e.ResponseEndBlock.decode(new k.BinaryReader(F)));
    }
    ListSnapshots(B = {}) {
      const M = e.RequestListSnapshots.encode(B).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "ListSnapshots", M).then((F) => e.ResponseListSnapshots.decode(new k.BinaryReader(F)));
    }
    OfferSnapshot(B) {
      const M = e.RequestOfferSnapshot.encode(B).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "OfferSnapshot", M).then((F) => e.ResponseOfferSnapshot.decode(new k.BinaryReader(F)));
    }
    LoadSnapshotChunk(B) {
      const M = e.RequestLoadSnapshotChunk.encode(B).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "LoadSnapshotChunk", M).then((F) => e.ResponseLoadSnapshotChunk.decode(new k.BinaryReader(F)));
    }
    ApplySnapshotChunk(B) {
      const M = e.RequestApplySnapshotChunk.encode(B).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "ApplySnapshotChunk", M).then((F) => e.ResponseApplySnapshotChunk.decode(new k.BinaryReader(F)));
    }
    PrepareProposal(B) {
      const M = e.RequestPrepareProposal.encode(B).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "PrepareProposal", M).then((F) => e.ResponsePrepareProposal.decode(new k.BinaryReader(F)));
    }
    ProcessProposal(B) {
      const M = e.RequestProcessProposal.encode(B).finish();
      return this.rpc.request("tendermint.abci.ABCIApplication", "ProcessProposal", M).then((F) => e.ResponseProcessProposal.decode(new k.BinaryReader(F)));
    }
  }
  e.ABCIApplicationClientImpl = gp;
})(Bd);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ValidatorUpdates = e.Pool = e.RedelegationResponse = e.RedelegationEntryResponse = e.DelegationResponse = e.Params = e.Redelegation = e.RedelegationEntry = e.UnbondingDelegationEntry = e.UnbondingDelegation = e.Delegation = e.DVVTriplets = e.DVVTriplet = e.DVPairs = e.DVPair = e.ValAddresses = e.Validator = e.Description = e.Commission = e.CommissionRates = e.HistoricalInfo = e.infractionToJSON = e.infractionFromJSON = e.Infraction = e.bondStatusToJSON = e.bondStatusFromJSON = e.BondStatus = e.protobufPackage = void 0;
  const n = _t, r = _e, t = Be, i = pn, f = Le, k = Bd, C = re, T = ie;
  e.protobufPackage = "cosmos.staking.v1beta1";
  var U;
  (function(m) {
    m[m.BOND_STATUS_UNSPECIFIED = 0] = "BOND_STATUS_UNSPECIFIED", m[m.BOND_STATUS_UNBONDED = 1] = "BOND_STATUS_UNBONDED", m[m.BOND_STATUS_UNBONDING = 2] = "BOND_STATUS_UNBONDING", m[m.BOND_STATUS_BONDED = 3] = "BOND_STATUS_BONDED", m[m.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(U || (e.BondStatus = U = {}));
  function w(m) {
    switch (m) {
      case 0:
      case "BOND_STATUS_UNSPECIFIED":
        return U.BOND_STATUS_UNSPECIFIED;
      case 1:
      case "BOND_STATUS_UNBONDED":
        return U.BOND_STATUS_UNBONDED;
      case 2:
      case "BOND_STATUS_UNBONDING":
        return U.BOND_STATUS_UNBONDING;
      case 3:
      case "BOND_STATUS_BONDED":
        return U.BOND_STATUS_BONDED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return U.UNRECOGNIZED;
    }
  }
  e.bondStatusFromJSON = w;
  function N(m) {
    switch (m) {
      case U.BOND_STATUS_UNSPECIFIED:
        return "BOND_STATUS_UNSPECIFIED";
      case U.BOND_STATUS_UNBONDED:
        return "BOND_STATUS_UNBONDED";
      case U.BOND_STATUS_UNBONDING:
        return "BOND_STATUS_UNBONDING";
      case U.BOND_STATUS_BONDED:
        return "BOND_STATUS_BONDED";
      case U.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.bondStatusToJSON = N;
  var h;
  (function(m) {
    m[m.INFRACTION_UNSPECIFIED = 0] = "INFRACTION_UNSPECIFIED", m[m.INFRACTION_DOUBLE_SIGN = 1] = "INFRACTION_DOUBLE_SIGN", m[m.INFRACTION_DOWNTIME = 2] = "INFRACTION_DOWNTIME", m[m.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(h || (e.Infraction = h = {}));
  function P(m) {
    switch (m) {
      case 0:
      case "INFRACTION_UNSPECIFIED":
        return h.INFRACTION_UNSPECIFIED;
      case 1:
      case "INFRACTION_DOUBLE_SIGN":
        return h.INFRACTION_DOUBLE_SIGN;
      case 2:
      case "INFRACTION_DOWNTIME":
        return h.INFRACTION_DOWNTIME;
      case -1:
      case "UNRECOGNIZED":
      default:
        return h.UNRECOGNIZED;
    }
  }
  e.infractionFromJSON = P;
  function b(m) {
    switch (m) {
      case h.INFRACTION_UNSPECIFIED:
        return "INFRACTION_UNSPECIFIED";
      case h.INFRACTION_DOUBLE_SIGN:
        return "INFRACTION_DOUBLE_SIGN";
      case h.INFRACTION_DOWNTIME:
        return "INFRACTION_DOWNTIME";
      case h.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.infractionToJSON = b;
  function c() {
    return {
      header: n.Header.fromPartial({}),
      valset: []
    };
  }
  e.HistoricalInfo = {
    typeUrl: "/cosmos.staking.v1beta1.HistoricalInfo",
    encode(m, S = C.BinaryWriter.create()) {
      m.header !== void 0 && n.Header.encode(m.header, S.uint32(10).fork()).ldelim();
      for (const O of m.valset)
        e.Validator.encode(O, S.uint32(18).fork()).ldelim();
      return S;
    },
    decode(m, S) {
      const O = m instanceof C.BinaryReader ? m : new C.BinaryReader(m);
      let Q = S === void 0 ? O.len : O.pos + S;
      const G = c();
      for (; O.pos < Q; ) {
        const L = O.uint32();
        switch (L >>> 3) {
          case 1:
            G.header = n.Header.decode(O, O.uint32());
            break;
          case 2:
            G.valset.push(e.Validator.decode(O, O.uint32()));
            break;
          default:
            O.skipType(L & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(m) {
      const S = c();
      return (0, T.isSet)(m.header) && (S.header = n.Header.fromJSON(m.header)), Array.isArray(m == null ? void 0 : m.valset) && (S.valset = m.valset.map((O) => e.Validator.fromJSON(O))), S;
    },
    toJSON(m) {
      const S = {};
      return m.header !== void 0 && (S.header = m.header ? n.Header.toJSON(m.header) : void 0), m.valset ? S.valset = m.valset.map((O) => O ? e.Validator.toJSON(O) : void 0) : S.valset = [], S;
    },
    fromPartial(m) {
      var O;
      const S = c();
      return m.header !== void 0 && m.header !== null && (S.header = n.Header.fromPartial(m.header)), S.valset = ((O = m.valset) == null ? void 0 : O.map((Q) => e.Validator.fromPartial(Q))) || [], S;
    }
  };
  function l() {
    return {
      rate: "",
      maxRate: "",
      maxChangeRate: ""
    };
  }
  e.CommissionRates = {
    typeUrl: "/cosmos.staking.v1beta1.CommissionRates",
    encode(m, S = C.BinaryWriter.create()) {
      return m.rate !== "" && S.uint32(10).string(m.rate), m.maxRate !== "" && S.uint32(18).string(m.maxRate), m.maxChangeRate !== "" && S.uint32(26).string(m.maxChangeRate), S;
    },
    decode(m, S) {
      const O = m instanceof C.BinaryReader ? m : new C.BinaryReader(m);
      let Q = S === void 0 ? O.len : O.pos + S;
      const G = l();
      for (; O.pos < Q; ) {
        const L = O.uint32();
        switch (L >>> 3) {
          case 1:
            G.rate = O.string();
            break;
          case 2:
            G.maxRate = O.string();
            break;
          case 3:
            G.maxChangeRate = O.string();
            break;
          default:
            O.skipType(L & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(m) {
      const S = l();
      return (0, T.isSet)(m.rate) && (S.rate = String(m.rate)), (0, T.isSet)(m.maxRate) && (S.maxRate = String(m.maxRate)), (0, T.isSet)(m.maxChangeRate) && (S.maxChangeRate = String(m.maxChangeRate)), S;
    },
    toJSON(m) {
      const S = {};
      return m.rate !== void 0 && (S.rate = m.rate), m.maxRate !== void 0 && (S.maxRate = m.maxRate), m.maxChangeRate !== void 0 && (S.maxChangeRate = m.maxChangeRate), S;
    },
    fromPartial(m) {
      const S = l();
      return S.rate = m.rate ?? "", S.maxRate = m.maxRate ?? "", S.maxChangeRate = m.maxChangeRate ?? "", S;
    }
  };
  function y() {
    return {
      commissionRates: e.CommissionRates.fromPartial({}),
      updateTime: r.Timestamp.fromPartial({})
    };
  }
  e.Commission = {
    typeUrl: "/cosmos.staking.v1beta1.Commission",
    encode(m, S = C.BinaryWriter.create()) {
      return m.commissionRates !== void 0 && e.CommissionRates.encode(m.commissionRates, S.uint32(10).fork()).ldelim(), m.updateTime !== void 0 && r.Timestamp.encode(m.updateTime, S.uint32(18).fork()).ldelim(), S;
    },
    decode(m, S) {
      const O = m instanceof C.BinaryReader ? m : new C.BinaryReader(m);
      let Q = S === void 0 ? O.len : O.pos + S;
      const G = y();
      for (; O.pos < Q; ) {
        const L = O.uint32();
        switch (L >>> 3) {
          case 1:
            G.commissionRates = e.CommissionRates.decode(O, O.uint32());
            break;
          case 2:
            G.updateTime = r.Timestamp.decode(O, O.uint32());
            break;
          default:
            O.skipType(L & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(m) {
      const S = y();
      return (0, T.isSet)(m.commissionRates) && (S.commissionRates = e.CommissionRates.fromJSON(m.commissionRates)), (0, T.isSet)(m.updateTime) && (S.updateTime = (0, T.fromJsonTimestamp)(m.updateTime)), S;
    },
    toJSON(m) {
      const S = {};
      return m.commissionRates !== void 0 && (S.commissionRates = m.commissionRates ? e.CommissionRates.toJSON(m.commissionRates) : void 0), m.updateTime !== void 0 && (S.updateTime = (0, T.fromTimestamp)(m.updateTime).toISOString()), S;
    },
    fromPartial(m) {
      const S = y();
      return m.commissionRates !== void 0 && m.commissionRates !== null && (S.commissionRates = e.CommissionRates.fromPartial(m.commissionRates)), m.updateTime !== void 0 && m.updateTime !== null && (S.updateTime = r.Timestamp.fromPartial(m.updateTime)), S;
    }
  };
  function E() {
    return {
      moniker: "",
      identity: "",
      website: "",
      securityContact: "",
      details: ""
    };
  }
  e.Description = {
    typeUrl: "/cosmos.staking.v1beta1.Description",
    encode(m, S = C.BinaryWriter.create()) {
      return m.moniker !== "" && S.uint32(10).string(m.moniker), m.identity !== "" && S.uint32(18).string(m.identity), m.website !== "" && S.uint32(26).string(m.website), m.securityContact !== "" && S.uint32(34).string(m.securityContact), m.details !== "" && S.uint32(42).string(m.details), S;
    },
    decode(m, S) {
      const O = m instanceof C.BinaryReader ? m : new C.BinaryReader(m);
      let Q = S === void 0 ? O.len : O.pos + S;
      const G = E();
      for (; O.pos < Q; ) {
        const L = O.uint32();
        switch (L >>> 3) {
          case 1:
            G.moniker = O.string();
            break;
          case 2:
            G.identity = O.string();
            break;
          case 3:
            G.website = O.string();
            break;
          case 4:
            G.securityContact = O.string();
            break;
          case 5:
            G.details = O.string();
            break;
          default:
            O.skipType(L & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(m) {
      const S = E();
      return (0, T.isSet)(m.moniker) && (S.moniker = String(m.moniker)), (0, T.isSet)(m.identity) && (S.identity = String(m.identity)), (0, T.isSet)(m.website) && (S.website = String(m.website)), (0, T.isSet)(m.securityContact) && (S.securityContact = String(m.securityContact)), (0, T.isSet)(m.details) && (S.details = String(m.details)), S;
    },
    toJSON(m) {
      const S = {};
      return m.moniker !== void 0 && (S.moniker = m.moniker), m.identity !== void 0 && (S.identity = m.identity), m.website !== void 0 && (S.website = m.website), m.securityContact !== void 0 && (S.securityContact = m.securityContact), m.details !== void 0 && (S.details = m.details), S;
    },
    fromPartial(m) {
      const S = E();
      return S.moniker = m.moniker ?? "", S.identity = m.identity ?? "", S.website = m.website ?? "", S.securityContact = m.securityContact ?? "", S.details = m.details ?? "", S;
    }
  };
  function J() {
    return {
      operatorAddress: "",
      consensusPubkey: void 0,
      jailed: !1,
      status: 0,
      tokens: "",
      delegatorShares: "",
      description: e.Description.fromPartial({}),
      unbondingHeight: BigInt(0),
      unbondingTime: r.Timestamp.fromPartial({}),
      commission: e.Commission.fromPartial({}),
      minSelfDelegation: "",
      unbondingOnHoldRefCount: BigInt(0),
      unbondingIds: []
    };
  }
  e.Validator = {
    typeUrl: "/cosmos.staking.v1beta1.Validator",
    encode(m, S = C.BinaryWriter.create()) {
      m.operatorAddress !== "" && S.uint32(10).string(m.operatorAddress), m.consensusPubkey !== void 0 && t.Any.encode(m.consensusPubkey, S.uint32(18).fork()).ldelim(), m.jailed === !0 && S.uint32(24).bool(m.jailed), m.status !== 0 && S.uint32(32).int32(m.status), m.tokens !== "" && S.uint32(42).string(m.tokens), m.delegatorShares !== "" && S.uint32(50).string(m.delegatorShares), m.description !== void 0 && e.Description.encode(m.description, S.uint32(58).fork()).ldelim(), m.unbondingHeight !== BigInt(0) && S.uint32(64).int64(m.unbondingHeight), m.unbondingTime !== void 0 && r.Timestamp.encode(m.unbondingTime, S.uint32(74).fork()).ldelim(), m.commission !== void 0 && e.Commission.encode(m.commission, S.uint32(82).fork()).ldelim(), m.minSelfDelegation !== "" && S.uint32(90).string(m.minSelfDelegation), m.unbondingOnHoldRefCount !== BigInt(0) && S.uint32(96).int64(m.unbondingOnHoldRefCount), S.uint32(106).fork();
      for (const O of m.unbondingIds)
        S.uint64(O);
      return S.ldelim(), S;
    },
    decode(m, S) {
      const O = m instanceof C.BinaryReader ? m : new C.BinaryReader(m);
      let Q = S === void 0 ? O.len : O.pos + S;
      const G = J();
      for (; O.pos < Q; ) {
        const L = O.uint32();
        switch (L >>> 3) {
          case 1:
            G.operatorAddress = O.string();
            break;
          case 2:
            G.consensusPubkey = t.Any.decode(O, O.uint32());
            break;
          case 3:
            G.jailed = O.bool();
            break;
          case 4:
            G.status = O.int32();
            break;
          case 5:
            G.tokens = O.string();
            break;
          case 6:
            G.delegatorShares = O.string();
            break;
          case 7:
            G.description = e.Description.decode(O, O.uint32());
            break;
          case 8:
            G.unbondingHeight = O.int64();
            break;
          case 9:
            G.unbondingTime = r.Timestamp.decode(O, O.uint32());
            break;
          case 10:
            G.commission = e.Commission.decode(O, O.uint32());
            break;
          case 11:
            G.minSelfDelegation = O.string();
            break;
          case 12:
            G.unbondingOnHoldRefCount = O.int64();
            break;
          case 13:
            if ((L & 7) === 2) {
              const ne = O.uint32() + O.pos;
              for (; O.pos < ne; )
                G.unbondingIds.push(O.uint64());
            } else
              G.unbondingIds.push(O.uint64());
            break;
          default:
            O.skipType(L & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(m) {
      const S = J();
      return (0, T.isSet)(m.operatorAddress) && (S.operatorAddress = String(m.operatorAddress)), (0, T.isSet)(m.consensusPubkey) && (S.consensusPubkey = t.Any.fromJSON(m.consensusPubkey)), (0, T.isSet)(m.jailed) && (S.jailed = !!m.jailed), (0, T.isSet)(m.status) && (S.status = w(m.status)), (0, T.isSet)(m.tokens) && (S.tokens = String(m.tokens)), (0, T.isSet)(m.delegatorShares) && (S.delegatorShares = String(m.delegatorShares)), (0, T.isSet)(m.description) && (S.description = e.Description.fromJSON(m.description)), (0, T.isSet)(m.unbondingHeight) && (S.unbondingHeight = BigInt(m.unbondingHeight.toString())), (0, T.isSet)(m.unbondingTime) && (S.unbondingTime = (0, T.fromJsonTimestamp)(m.unbondingTime)), (0, T.isSet)(m.commission) && (S.commission = e.Commission.fromJSON(m.commission)), (0, T.isSet)(m.minSelfDelegation) && (S.minSelfDelegation = String(m.minSelfDelegation)), (0, T.isSet)(m.unbondingOnHoldRefCount) && (S.unbondingOnHoldRefCount = BigInt(m.unbondingOnHoldRefCount.toString())), Array.isArray(m == null ? void 0 : m.unbondingIds) && (S.unbondingIds = m.unbondingIds.map((O) => BigInt(O.toString()))), S;
    },
    toJSON(m) {
      const S = {};
      return m.operatorAddress !== void 0 && (S.operatorAddress = m.operatorAddress), m.consensusPubkey !== void 0 && (S.consensusPubkey = m.consensusPubkey ? t.Any.toJSON(m.consensusPubkey) : void 0), m.jailed !== void 0 && (S.jailed = m.jailed), m.status !== void 0 && (S.status = N(m.status)), m.tokens !== void 0 && (S.tokens = m.tokens), m.delegatorShares !== void 0 && (S.delegatorShares = m.delegatorShares), m.description !== void 0 && (S.description = m.description ? e.Description.toJSON(m.description) : void 0), m.unbondingHeight !== void 0 && (S.unbondingHeight = (m.unbondingHeight || BigInt(0)).toString()), m.unbondingTime !== void 0 && (S.unbondingTime = (0, T.fromTimestamp)(m.unbondingTime).toISOString()), m.commission !== void 0 && (S.commission = m.commission ? e.Commission.toJSON(m.commission) : void 0), m.minSelfDelegation !== void 0 && (S.minSelfDelegation = m.minSelfDelegation), m.unbondingOnHoldRefCount !== void 0 && (S.unbondingOnHoldRefCount = (m.unbondingOnHoldRefCount || BigInt(0)).toString()), m.unbondingIds ? S.unbondingIds = m.unbondingIds.map((O) => (O || BigInt(0)).toString()) : S.unbondingIds = [], S;
    },
    fromPartial(m) {
      var O;
      const S = J();
      return S.operatorAddress = m.operatorAddress ?? "", m.consensusPubkey !== void 0 && m.consensusPubkey !== null && (S.consensusPubkey = t.Any.fromPartial(m.consensusPubkey)), S.jailed = m.jailed ?? !1, S.status = m.status ?? 0, S.tokens = m.tokens ?? "", S.delegatorShares = m.delegatorShares ?? "", m.description !== void 0 && m.description !== null && (S.description = e.Description.fromPartial(m.description)), m.unbondingHeight !== void 0 && m.unbondingHeight !== null && (S.unbondingHeight = BigInt(m.unbondingHeight.toString())), m.unbondingTime !== void 0 && m.unbondingTime !== null && (S.unbondingTime = r.Timestamp.fromPartial(m.unbondingTime)), m.commission !== void 0 && m.commission !== null && (S.commission = e.Commission.fromPartial(m.commission)), S.minSelfDelegation = m.minSelfDelegation ?? "", m.unbondingOnHoldRefCount !== void 0 && m.unbondingOnHoldRefCount !== null && (S.unbondingOnHoldRefCount = BigInt(m.unbondingOnHoldRefCount.toString())), S.unbondingIds = ((O = m.unbondingIds) == null ? void 0 : O.map((Q) => BigInt(Q.toString()))) || [], S;
    }
  };
  function _() {
    return {
      addresses: []
    };
  }
  e.ValAddresses = {
    typeUrl: "/cosmos.staking.v1beta1.ValAddresses",
    encode(m, S = C.BinaryWriter.create()) {
      for (const O of m.addresses)
        S.uint32(10).string(O);
      return S;
    },
    decode(m, S) {
      const O = m instanceof C.BinaryReader ? m : new C.BinaryReader(m);
      let Q = S === void 0 ? O.len : O.pos + S;
      const G = _();
      for (; O.pos < Q; ) {
        const L = O.uint32();
        switch (L >>> 3) {
          case 1:
            G.addresses.push(O.string());
            break;
          default:
            O.skipType(L & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(m) {
      const S = _();
      return Array.isArray(m == null ? void 0 : m.addresses) && (S.addresses = m.addresses.map((O) => String(O))), S;
    },
    toJSON(m) {
      const S = {};
      return m.addresses ? S.addresses = m.addresses.map((O) => O) : S.addresses = [], S;
    },
    fromPartial(m) {
      var O;
      const S = _();
      return S.addresses = ((O = m.addresses) == null ? void 0 : O.map((Q) => Q)) || [], S;
    }
  };
  function V() {
    return {
      delegatorAddress: "",
      validatorAddress: ""
    };
  }
  e.DVPair = {
    typeUrl: "/cosmos.staking.v1beta1.DVPair",
    encode(m, S = C.BinaryWriter.create()) {
      return m.delegatorAddress !== "" && S.uint32(10).string(m.delegatorAddress), m.validatorAddress !== "" && S.uint32(18).string(m.validatorAddress), S;
    },
    decode(m, S) {
      const O = m instanceof C.BinaryReader ? m : new C.BinaryReader(m);
      let Q = S === void 0 ? O.len : O.pos + S;
      const G = V();
      for (; O.pos < Q; ) {
        const L = O.uint32();
        switch (L >>> 3) {
          case 1:
            G.delegatorAddress = O.string();
            break;
          case 2:
            G.validatorAddress = O.string();
            break;
          default:
            O.skipType(L & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(m) {
      const S = V();
      return (0, T.isSet)(m.delegatorAddress) && (S.delegatorAddress = String(m.delegatorAddress)), (0, T.isSet)(m.validatorAddress) && (S.validatorAddress = String(m.validatorAddress)), S;
    },
    toJSON(m) {
      const S = {};
      return m.delegatorAddress !== void 0 && (S.delegatorAddress = m.delegatorAddress), m.validatorAddress !== void 0 && (S.validatorAddress = m.validatorAddress), S;
    },
    fromPartial(m) {
      const S = V();
      return S.delegatorAddress = m.delegatorAddress ?? "", S.validatorAddress = m.validatorAddress ?? "", S;
    }
  };
  function o() {
    return {
      pairs: []
    };
  }
  e.DVPairs = {
    typeUrl: "/cosmos.staking.v1beta1.DVPairs",
    encode(m, S = C.BinaryWriter.create()) {
      for (const O of m.pairs)
        e.DVPair.encode(O, S.uint32(10).fork()).ldelim();
      return S;
    },
    decode(m, S) {
      const O = m instanceof C.BinaryReader ? m : new C.BinaryReader(m);
      let Q = S === void 0 ? O.len : O.pos + S;
      const G = o();
      for (; O.pos < Q; ) {
        const L = O.uint32();
        switch (L >>> 3) {
          case 1:
            G.pairs.push(e.DVPair.decode(O, O.uint32()));
            break;
          default:
            O.skipType(L & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(m) {
      const S = o();
      return Array.isArray(m == null ? void 0 : m.pairs) && (S.pairs = m.pairs.map((O) => e.DVPair.fromJSON(O))), S;
    },
    toJSON(m) {
      const S = {};
      return m.pairs ? S.pairs = m.pairs.map((O) => O ? e.DVPair.toJSON(O) : void 0) : S.pairs = [], S;
    },
    fromPartial(m) {
      var O;
      const S = o();
      return S.pairs = ((O = m.pairs) == null ? void 0 : O.map((Q) => e.DVPair.fromPartial(Q))) || [], S;
    }
  };
  function p() {
    return {
      delegatorAddress: "",
      validatorSrcAddress: "",
      validatorDstAddress: ""
    };
  }
  e.DVVTriplet = {
    typeUrl: "/cosmos.staking.v1beta1.DVVTriplet",
    encode(m, S = C.BinaryWriter.create()) {
      return m.delegatorAddress !== "" && S.uint32(10).string(m.delegatorAddress), m.validatorSrcAddress !== "" && S.uint32(18).string(m.validatorSrcAddress), m.validatorDstAddress !== "" && S.uint32(26).string(m.validatorDstAddress), S;
    },
    decode(m, S) {
      const O = m instanceof C.BinaryReader ? m : new C.BinaryReader(m);
      let Q = S === void 0 ? O.len : O.pos + S;
      const G = p();
      for (; O.pos < Q; ) {
        const L = O.uint32();
        switch (L >>> 3) {
          case 1:
            G.delegatorAddress = O.string();
            break;
          case 2:
            G.validatorSrcAddress = O.string();
            break;
          case 3:
            G.validatorDstAddress = O.string();
            break;
          default:
            O.skipType(L & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(m) {
      const S = p();
      return (0, T.isSet)(m.delegatorAddress) && (S.delegatorAddress = String(m.delegatorAddress)), (0, T.isSet)(m.validatorSrcAddress) && (S.validatorSrcAddress = String(m.validatorSrcAddress)), (0, T.isSet)(m.validatorDstAddress) && (S.validatorDstAddress = String(m.validatorDstAddress)), S;
    },
    toJSON(m) {
      const S = {};
      return m.delegatorAddress !== void 0 && (S.delegatorAddress = m.delegatorAddress), m.validatorSrcAddress !== void 0 && (S.validatorSrcAddress = m.validatorSrcAddress), m.validatorDstAddress !== void 0 && (S.validatorDstAddress = m.validatorDstAddress), S;
    },
    fromPartial(m) {
      const S = p();
      return S.delegatorAddress = m.delegatorAddress ?? "", S.validatorSrcAddress = m.validatorSrcAddress ?? "", S.validatorDstAddress = m.validatorDstAddress ?? "", S;
    }
  };
  function I() {
    return {
      triplets: []
    };
  }
  e.DVVTriplets = {
    typeUrl: "/cosmos.staking.v1beta1.DVVTriplets",
    encode(m, S = C.BinaryWriter.create()) {
      for (const O of m.triplets)
        e.DVVTriplet.encode(O, S.uint32(10).fork()).ldelim();
      return S;
    },
    decode(m, S) {
      const O = m instanceof C.BinaryReader ? m : new C.BinaryReader(m);
      let Q = S === void 0 ? O.len : O.pos + S;
      const G = I();
      for (; O.pos < Q; ) {
        const L = O.uint32();
        switch (L >>> 3) {
          case 1:
            G.triplets.push(e.DVVTriplet.decode(O, O.uint32()));
            break;
          default:
            O.skipType(L & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(m) {
      const S = I();
      return Array.isArray(m == null ? void 0 : m.triplets) && (S.triplets = m.triplets.map((O) => e.DVVTriplet.fromJSON(O))), S;
    },
    toJSON(m) {
      const S = {};
      return m.triplets ? S.triplets = m.triplets.map((O) => O ? e.DVVTriplet.toJSON(O) : void 0) : S.triplets = [], S;
    },
    fromPartial(m) {
      var O;
      const S = I();
      return S.triplets = ((O = m.triplets) == null ? void 0 : O.map((Q) => e.DVVTriplet.fromPartial(Q))) || [], S;
    }
  };
  function q() {
    return {
      delegatorAddress: "",
      validatorAddress: "",
      shares: ""
    };
  }
  e.Delegation = {
    typeUrl: "/cosmos.staking.v1beta1.Delegation",
    encode(m, S = C.BinaryWriter.create()) {
      return m.delegatorAddress !== "" && S.uint32(10).string(m.delegatorAddress), m.validatorAddress !== "" && S.uint32(18).string(m.validatorAddress), m.shares !== "" && S.uint32(26).string(m.shares), S;
    },
    decode(m, S) {
      const O = m instanceof C.BinaryReader ? m : new C.BinaryReader(m);
      let Q = S === void 0 ? O.len : O.pos + S;
      const G = q();
      for (; O.pos < Q; ) {
        const L = O.uint32();
        switch (L >>> 3) {
          case 1:
            G.delegatorAddress = O.string();
            break;
          case 2:
            G.validatorAddress = O.string();
            break;
          case 3:
            G.shares = O.string();
            break;
          default:
            O.skipType(L & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(m) {
      const S = q();
      return (0, T.isSet)(m.delegatorAddress) && (S.delegatorAddress = String(m.delegatorAddress)), (0, T.isSet)(m.validatorAddress) && (S.validatorAddress = String(m.validatorAddress)), (0, T.isSet)(m.shares) && (S.shares = String(m.shares)), S;
    },
    toJSON(m) {
      const S = {};
      return m.delegatorAddress !== void 0 && (S.delegatorAddress = m.delegatorAddress), m.validatorAddress !== void 0 && (S.validatorAddress = m.validatorAddress), m.shares !== void 0 && (S.shares = m.shares), S;
    },
    fromPartial(m) {
      const S = q();
      return S.delegatorAddress = m.delegatorAddress ?? "", S.validatorAddress = m.validatorAddress ?? "", S.shares = m.shares ?? "", S;
    }
  };
  function s() {
    return {
      delegatorAddress: "",
      validatorAddress: "",
      entries: []
    };
  }
  e.UnbondingDelegation = {
    typeUrl: "/cosmos.staking.v1beta1.UnbondingDelegation",
    encode(m, S = C.BinaryWriter.create()) {
      m.delegatorAddress !== "" && S.uint32(10).string(m.delegatorAddress), m.validatorAddress !== "" && S.uint32(18).string(m.validatorAddress);
      for (const O of m.entries)
        e.UnbondingDelegationEntry.encode(O, S.uint32(26).fork()).ldelim();
      return S;
    },
    decode(m, S) {
      const O = m instanceof C.BinaryReader ? m : new C.BinaryReader(m);
      let Q = S === void 0 ? O.len : O.pos + S;
      const G = s();
      for (; O.pos < Q; ) {
        const L = O.uint32();
        switch (L >>> 3) {
          case 1:
            G.delegatorAddress = O.string();
            break;
          case 2:
            G.validatorAddress = O.string();
            break;
          case 3:
            G.entries.push(e.UnbondingDelegationEntry.decode(O, O.uint32()));
            break;
          default:
            O.skipType(L & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(m) {
      const S = s();
      return (0, T.isSet)(m.delegatorAddress) && (S.delegatorAddress = String(m.delegatorAddress)), (0, T.isSet)(m.validatorAddress) && (S.validatorAddress = String(m.validatorAddress)), Array.isArray(m == null ? void 0 : m.entries) && (S.entries = m.entries.map((O) => e.UnbondingDelegationEntry.fromJSON(O))), S;
    },
    toJSON(m) {
      const S = {};
      return m.delegatorAddress !== void 0 && (S.delegatorAddress = m.delegatorAddress), m.validatorAddress !== void 0 && (S.validatorAddress = m.validatorAddress), m.entries ? S.entries = m.entries.map((O) => O ? e.UnbondingDelegationEntry.toJSON(O) : void 0) : S.entries = [], S;
    },
    fromPartial(m) {
      var O;
      const S = s();
      return S.delegatorAddress = m.delegatorAddress ?? "", S.validatorAddress = m.validatorAddress ?? "", S.entries = ((O = m.entries) == null ? void 0 : O.map((Q) => e.UnbondingDelegationEntry.fromPartial(Q))) || [], S;
    }
  };
  function u() {
    return {
      creationHeight: BigInt(0),
      completionTime: r.Timestamp.fromPartial({}),
      initialBalance: "",
      balance: "",
      unbondingId: BigInt(0),
      unbondingOnHoldRefCount: BigInt(0)
    };
  }
  e.UnbondingDelegationEntry = {
    typeUrl: "/cosmos.staking.v1beta1.UnbondingDelegationEntry",
    encode(m, S = C.BinaryWriter.create()) {
      return m.creationHeight !== BigInt(0) && S.uint32(8).int64(m.creationHeight), m.completionTime !== void 0 && r.Timestamp.encode(m.completionTime, S.uint32(18).fork()).ldelim(), m.initialBalance !== "" && S.uint32(26).string(m.initialBalance), m.balance !== "" && S.uint32(34).string(m.balance), m.unbondingId !== BigInt(0) && S.uint32(40).uint64(m.unbondingId), m.unbondingOnHoldRefCount !== BigInt(0) && S.uint32(48).int64(m.unbondingOnHoldRefCount), S;
    },
    decode(m, S) {
      const O = m instanceof C.BinaryReader ? m : new C.BinaryReader(m);
      let Q = S === void 0 ? O.len : O.pos + S;
      const G = u();
      for (; O.pos < Q; ) {
        const L = O.uint32();
        switch (L >>> 3) {
          case 1:
            G.creationHeight = O.int64();
            break;
          case 2:
            G.completionTime = r.Timestamp.decode(O, O.uint32());
            break;
          case 3:
            G.initialBalance = O.string();
            break;
          case 4:
            G.balance = O.string();
            break;
          case 5:
            G.unbondingId = O.uint64();
            break;
          case 6:
            G.unbondingOnHoldRefCount = O.int64();
            break;
          default:
            O.skipType(L & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(m) {
      const S = u();
      return (0, T.isSet)(m.creationHeight) && (S.creationHeight = BigInt(m.creationHeight.toString())), (0, T.isSet)(m.completionTime) && (S.completionTime = (0, T.fromJsonTimestamp)(m.completionTime)), (0, T.isSet)(m.initialBalance) && (S.initialBalance = String(m.initialBalance)), (0, T.isSet)(m.balance) && (S.balance = String(m.balance)), (0, T.isSet)(m.unbondingId) && (S.unbondingId = BigInt(m.unbondingId.toString())), (0, T.isSet)(m.unbondingOnHoldRefCount) && (S.unbondingOnHoldRefCount = BigInt(m.unbondingOnHoldRefCount.toString())), S;
    },
    toJSON(m) {
      const S = {};
      return m.creationHeight !== void 0 && (S.creationHeight = (m.creationHeight || BigInt(0)).toString()), m.completionTime !== void 0 && (S.completionTime = (0, T.fromTimestamp)(m.completionTime).toISOString()), m.initialBalance !== void 0 && (S.initialBalance = m.initialBalance), m.balance !== void 0 && (S.balance = m.balance), m.unbondingId !== void 0 && (S.unbondingId = (m.unbondingId || BigInt(0)).toString()), m.unbondingOnHoldRefCount !== void 0 && (S.unbondingOnHoldRefCount = (m.unbondingOnHoldRefCount || BigInt(0)).toString()), S;
    },
    fromPartial(m) {
      const S = u();
      return m.creationHeight !== void 0 && m.creationHeight !== null && (S.creationHeight = BigInt(m.creationHeight.toString())), m.completionTime !== void 0 && m.completionTime !== null && (S.completionTime = r.Timestamp.fromPartial(m.completionTime)), S.initialBalance = m.initialBalance ?? "", S.balance = m.balance ?? "", m.unbondingId !== void 0 && m.unbondingId !== null && (S.unbondingId = BigInt(m.unbondingId.toString())), m.unbondingOnHoldRefCount !== void 0 && m.unbondingOnHoldRefCount !== null && (S.unbondingOnHoldRefCount = BigInt(m.unbondingOnHoldRefCount.toString())), S;
    }
  };
  function A() {
    return {
      creationHeight: BigInt(0),
      completionTime: r.Timestamp.fromPartial({}),
      initialBalance: "",
      sharesDst: "",
      unbondingId: BigInt(0),
      unbondingOnHoldRefCount: BigInt(0)
    };
  }
  e.RedelegationEntry = {
    typeUrl: "/cosmos.staking.v1beta1.RedelegationEntry",
    encode(m, S = C.BinaryWriter.create()) {
      return m.creationHeight !== BigInt(0) && S.uint32(8).int64(m.creationHeight), m.completionTime !== void 0 && r.Timestamp.encode(m.completionTime, S.uint32(18).fork()).ldelim(), m.initialBalance !== "" && S.uint32(26).string(m.initialBalance), m.sharesDst !== "" && S.uint32(34).string(m.sharesDst), m.unbondingId !== BigInt(0) && S.uint32(40).uint64(m.unbondingId), m.unbondingOnHoldRefCount !== BigInt(0) && S.uint32(48).int64(m.unbondingOnHoldRefCount), S;
    },
    decode(m, S) {
      const O = m instanceof C.BinaryReader ? m : new C.BinaryReader(m);
      let Q = S === void 0 ? O.len : O.pos + S;
      const G = A();
      for (; O.pos < Q; ) {
        const L = O.uint32();
        switch (L >>> 3) {
          case 1:
            G.creationHeight = O.int64();
            break;
          case 2:
            G.completionTime = r.Timestamp.decode(O, O.uint32());
            break;
          case 3:
            G.initialBalance = O.string();
            break;
          case 4:
            G.sharesDst = O.string();
            break;
          case 5:
            G.unbondingId = O.uint64();
            break;
          case 6:
            G.unbondingOnHoldRefCount = O.int64();
            break;
          default:
            O.skipType(L & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(m) {
      const S = A();
      return (0, T.isSet)(m.creationHeight) && (S.creationHeight = BigInt(m.creationHeight.toString())), (0, T.isSet)(m.completionTime) && (S.completionTime = (0, T.fromJsonTimestamp)(m.completionTime)), (0, T.isSet)(m.initialBalance) && (S.initialBalance = String(m.initialBalance)), (0, T.isSet)(m.sharesDst) && (S.sharesDst = String(m.sharesDst)), (0, T.isSet)(m.unbondingId) && (S.unbondingId = BigInt(m.unbondingId.toString())), (0, T.isSet)(m.unbondingOnHoldRefCount) && (S.unbondingOnHoldRefCount = BigInt(m.unbondingOnHoldRefCount.toString())), S;
    },
    toJSON(m) {
      const S = {};
      return m.creationHeight !== void 0 && (S.creationHeight = (m.creationHeight || BigInt(0)).toString()), m.completionTime !== void 0 && (S.completionTime = (0, T.fromTimestamp)(m.completionTime).toISOString()), m.initialBalance !== void 0 && (S.initialBalance = m.initialBalance), m.sharesDst !== void 0 && (S.sharesDst = m.sharesDst), m.unbondingId !== void 0 && (S.unbondingId = (m.unbondingId || BigInt(0)).toString()), m.unbondingOnHoldRefCount !== void 0 && (S.unbondingOnHoldRefCount = (m.unbondingOnHoldRefCount || BigInt(0)).toString()), S;
    },
    fromPartial(m) {
      const S = A();
      return m.creationHeight !== void 0 && m.creationHeight !== null && (S.creationHeight = BigInt(m.creationHeight.toString())), m.completionTime !== void 0 && m.completionTime !== null && (S.completionTime = r.Timestamp.fromPartial(m.completionTime)), S.initialBalance = m.initialBalance ?? "", S.sharesDst = m.sharesDst ?? "", m.unbondingId !== void 0 && m.unbondingId !== null && (S.unbondingId = BigInt(m.unbondingId.toString())), m.unbondingOnHoldRefCount !== void 0 && m.unbondingOnHoldRefCount !== null && (S.unbondingOnHoldRefCount = BigInt(m.unbondingOnHoldRefCount.toString())), S;
    }
  };
  function R() {
    return {
      delegatorAddress: "",
      validatorSrcAddress: "",
      validatorDstAddress: "",
      entries: []
    };
  }
  e.Redelegation = {
    typeUrl: "/cosmos.staking.v1beta1.Redelegation",
    encode(m, S = C.BinaryWriter.create()) {
      m.delegatorAddress !== "" && S.uint32(10).string(m.delegatorAddress), m.validatorSrcAddress !== "" && S.uint32(18).string(m.validatorSrcAddress), m.validatorDstAddress !== "" && S.uint32(26).string(m.validatorDstAddress);
      for (const O of m.entries)
        e.RedelegationEntry.encode(O, S.uint32(34).fork()).ldelim();
      return S;
    },
    decode(m, S) {
      const O = m instanceof C.BinaryReader ? m : new C.BinaryReader(m);
      let Q = S === void 0 ? O.len : O.pos + S;
      const G = R();
      for (; O.pos < Q; ) {
        const L = O.uint32();
        switch (L >>> 3) {
          case 1:
            G.delegatorAddress = O.string();
            break;
          case 2:
            G.validatorSrcAddress = O.string();
            break;
          case 3:
            G.validatorDstAddress = O.string();
            break;
          case 4:
            G.entries.push(e.RedelegationEntry.decode(O, O.uint32()));
            break;
          default:
            O.skipType(L & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(m) {
      const S = R();
      return (0, T.isSet)(m.delegatorAddress) && (S.delegatorAddress = String(m.delegatorAddress)), (0, T.isSet)(m.validatorSrcAddress) && (S.validatorSrcAddress = String(m.validatorSrcAddress)), (0, T.isSet)(m.validatorDstAddress) && (S.validatorDstAddress = String(m.validatorDstAddress)), Array.isArray(m == null ? void 0 : m.entries) && (S.entries = m.entries.map((O) => e.RedelegationEntry.fromJSON(O))), S;
    },
    toJSON(m) {
      const S = {};
      return m.delegatorAddress !== void 0 && (S.delegatorAddress = m.delegatorAddress), m.validatorSrcAddress !== void 0 && (S.validatorSrcAddress = m.validatorSrcAddress), m.validatorDstAddress !== void 0 && (S.validatorDstAddress = m.validatorDstAddress), m.entries ? S.entries = m.entries.map((O) => O ? e.RedelegationEntry.toJSON(O) : void 0) : S.entries = [], S;
    },
    fromPartial(m) {
      var O;
      const S = R();
      return S.delegatorAddress = m.delegatorAddress ?? "", S.validatorSrcAddress = m.validatorSrcAddress ?? "", S.validatorDstAddress = m.validatorDstAddress ?? "", S.entries = ((O = m.entries) == null ? void 0 : O.map((Q) => e.RedelegationEntry.fromPartial(Q))) || [], S;
    }
  };
  function v() {
    return {
      unbondingTime: i.Duration.fromPartial({}),
      maxValidators: 0,
      maxEntries: 0,
      historicalEntries: 0,
      bondDenom: "",
      minCommissionRate: ""
    };
  }
  e.Params = {
    typeUrl: "/cosmos.staking.v1beta1.Params",
    encode(m, S = C.BinaryWriter.create()) {
      return m.unbondingTime !== void 0 && i.Duration.encode(m.unbondingTime, S.uint32(10).fork()).ldelim(), m.maxValidators !== 0 && S.uint32(16).uint32(m.maxValidators), m.maxEntries !== 0 && S.uint32(24).uint32(m.maxEntries), m.historicalEntries !== 0 && S.uint32(32).uint32(m.historicalEntries), m.bondDenom !== "" && S.uint32(42).string(m.bondDenom), m.minCommissionRate !== "" && S.uint32(50).string(m.minCommissionRate), S;
    },
    decode(m, S) {
      const O = m instanceof C.BinaryReader ? m : new C.BinaryReader(m);
      let Q = S === void 0 ? O.len : O.pos + S;
      const G = v();
      for (; O.pos < Q; ) {
        const L = O.uint32();
        switch (L >>> 3) {
          case 1:
            G.unbondingTime = i.Duration.decode(O, O.uint32());
            break;
          case 2:
            G.maxValidators = O.uint32();
            break;
          case 3:
            G.maxEntries = O.uint32();
            break;
          case 4:
            G.historicalEntries = O.uint32();
            break;
          case 5:
            G.bondDenom = O.string();
            break;
          case 6:
            G.minCommissionRate = O.string();
            break;
          default:
            O.skipType(L & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(m) {
      const S = v();
      return (0, T.isSet)(m.unbondingTime) && (S.unbondingTime = i.Duration.fromJSON(m.unbondingTime)), (0, T.isSet)(m.maxValidators) && (S.maxValidators = Number(m.maxValidators)), (0, T.isSet)(m.maxEntries) && (S.maxEntries = Number(m.maxEntries)), (0, T.isSet)(m.historicalEntries) && (S.historicalEntries = Number(m.historicalEntries)), (0, T.isSet)(m.bondDenom) && (S.bondDenom = String(m.bondDenom)), (0, T.isSet)(m.minCommissionRate) && (S.minCommissionRate = String(m.minCommissionRate)), S;
    },
    toJSON(m) {
      const S = {};
      return m.unbondingTime !== void 0 && (S.unbondingTime = m.unbondingTime ? i.Duration.toJSON(m.unbondingTime) : void 0), m.maxValidators !== void 0 && (S.maxValidators = Math.round(m.maxValidators)), m.maxEntries !== void 0 && (S.maxEntries = Math.round(m.maxEntries)), m.historicalEntries !== void 0 && (S.historicalEntries = Math.round(m.historicalEntries)), m.bondDenom !== void 0 && (S.bondDenom = m.bondDenom), m.minCommissionRate !== void 0 && (S.minCommissionRate = m.minCommissionRate), S;
    },
    fromPartial(m) {
      const S = v();
      return m.unbondingTime !== void 0 && m.unbondingTime !== null && (S.unbondingTime = i.Duration.fromPartial(m.unbondingTime)), S.maxValidators = m.maxValidators ?? 0, S.maxEntries = m.maxEntries ?? 0, S.historicalEntries = m.historicalEntries ?? 0, S.bondDenom = m.bondDenom ?? "", S.minCommissionRate = m.minCommissionRate ?? "", S;
    }
  };
  function D() {
    return {
      delegation: e.Delegation.fromPartial({}),
      balance: f.Coin.fromPartial({})
    };
  }
  e.DelegationResponse = {
    typeUrl: "/cosmos.staking.v1beta1.DelegationResponse",
    encode(m, S = C.BinaryWriter.create()) {
      return m.delegation !== void 0 && e.Delegation.encode(m.delegation, S.uint32(10).fork()).ldelim(), m.balance !== void 0 && f.Coin.encode(m.balance, S.uint32(18).fork()).ldelim(), S;
    },
    decode(m, S) {
      const O = m instanceof C.BinaryReader ? m : new C.BinaryReader(m);
      let Q = S === void 0 ? O.len : O.pos + S;
      const G = D();
      for (; O.pos < Q; ) {
        const L = O.uint32();
        switch (L >>> 3) {
          case 1:
            G.delegation = e.Delegation.decode(O, O.uint32());
            break;
          case 2:
            G.balance = f.Coin.decode(O, O.uint32());
            break;
          default:
            O.skipType(L & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(m) {
      const S = D();
      return (0, T.isSet)(m.delegation) && (S.delegation = e.Delegation.fromJSON(m.delegation)), (0, T.isSet)(m.balance) && (S.balance = f.Coin.fromJSON(m.balance)), S;
    },
    toJSON(m) {
      const S = {};
      return m.delegation !== void 0 && (S.delegation = m.delegation ? e.Delegation.toJSON(m.delegation) : void 0), m.balance !== void 0 && (S.balance = m.balance ? f.Coin.toJSON(m.balance) : void 0), S;
    },
    fromPartial(m) {
      const S = D();
      return m.delegation !== void 0 && m.delegation !== null && (S.delegation = e.Delegation.fromPartial(m.delegation)), m.balance !== void 0 && m.balance !== null && (S.balance = f.Coin.fromPartial(m.balance)), S;
    }
  };
  function W() {
    return {
      redelegationEntry: e.RedelegationEntry.fromPartial({}),
      balance: ""
    };
  }
  e.RedelegationEntryResponse = {
    typeUrl: "/cosmos.staking.v1beta1.RedelegationEntryResponse",
    encode(m, S = C.BinaryWriter.create()) {
      return m.redelegationEntry !== void 0 && e.RedelegationEntry.encode(m.redelegationEntry, S.uint32(10).fork()).ldelim(), m.balance !== "" && S.uint32(34).string(m.balance), S;
    },
    decode(m, S) {
      const O = m instanceof C.BinaryReader ? m : new C.BinaryReader(m);
      let Q = S === void 0 ? O.len : O.pos + S;
      const G = W();
      for (; O.pos < Q; ) {
        const L = O.uint32();
        switch (L >>> 3) {
          case 1:
            G.redelegationEntry = e.RedelegationEntry.decode(O, O.uint32());
            break;
          case 4:
            G.balance = O.string();
            break;
          default:
            O.skipType(L & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(m) {
      const S = W();
      return (0, T.isSet)(m.redelegationEntry) && (S.redelegationEntry = e.RedelegationEntry.fromJSON(m.redelegationEntry)), (0, T.isSet)(m.balance) && (S.balance = String(m.balance)), S;
    },
    toJSON(m) {
      const S = {};
      return m.redelegationEntry !== void 0 && (S.redelegationEntry = m.redelegationEntry ? e.RedelegationEntry.toJSON(m.redelegationEntry) : void 0), m.balance !== void 0 && (S.balance = m.balance), S;
    },
    fromPartial(m) {
      const S = W();
      return m.redelegationEntry !== void 0 && m.redelegationEntry !== null && (S.redelegationEntry = e.RedelegationEntry.fromPartial(m.redelegationEntry)), S.balance = m.balance ?? "", S;
    }
  };
  function H() {
    return {
      redelegation: e.Redelegation.fromPartial({}),
      entries: []
    };
  }
  e.RedelegationResponse = {
    typeUrl: "/cosmos.staking.v1beta1.RedelegationResponse",
    encode(m, S = C.BinaryWriter.create()) {
      m.redelegation !== void 0 && e.Redelegation.encode(m.redelegation, S.uint32(10).fork()).ldelim();
      for (const O of m.entries)
        e.RedelegationEntryResponse.encode(O, S.uint32(18).fork()).ldelim();
      return S;
    },
    decode(m, S) {
      const O = m instanceof C.BinaryReader ? m : new C.BinaryReader(m);
      let Q = S === void 0 ? O.len : O.pos + S;
      const G = H();
      for (; O.pos < Q; ) {
        const L = O.uint32();
        switch (L >>> 3) {
          case 1:
            G.redelegation = e.Redelegation.decode(O, O.uint32());
            break;
          case 2:
            G.entries.push(e.RedelegationEntryResponse.decode(O, O.uint32()));
            break;
          default:
            O.skipType(L & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(m) {
      const S = H();
      return (0, T.isSet)(m.redelegation) && (S.redelegation = e.Redelegation.fromJSON(m.redelegation)), Array.isArray(m == null ? void 0 : m.entries) && (S.entries = m.entries.map((O) => e.RedelegationEntryResponse.fromJSON(O))), S;
    },
    toJSON(m) {
      const S = {};
      return m.redelegation !== void 0 && (S.redelegation = m.redelegation ? e.Redelegation.toJSON(m.redelegation) : void 0), m.entries ? S.entries = m.entries.map((O) => O ? e.RedelegationEntryResponse.toJSON(O) : void 0) : S.entries = [], S;
    },
    fromPartial(m) {
      var O;
      const S = H();
      return m.redelegation !== void 0 && m.redelegation !== null && (S.redelegation = e.Redelegation.fromPartial(m.redelegation)), S.entries = ((O = m.entries) == null ? void 0 : O.map((Q) => e.RedelegationEntryResponse.fromPartial(Q))) || [], S;
    }
  };
  function a() {
    return {
      notBondedTokens: "",
      bondedTokens: ""
    };
  }
  e.Pool = {
    typeUrl: "/cosmos.staking.v1beta1.Pool",
    encode(m, S = C.BinaryWriter.create()) {
      return m.notBondedTokens !== "" && S.uint32(10).string(m.notBondedTokens), m.bondedTokens !== "" && S.uint32(18).string(m.bondedTokens), S;
    },
    decode(m, S) {
      const O = m instanceof C.BinaryReader ? m : new C.BinaryReader(m);
      let Q = S === void 0 ? O.len : O.pos + S;
      const G = a();
      for (; O.pos < Q; ) {
        const L = O.uint32();
        switch (L >>> 3) {
          case 1:
            G.notBondedTokens = O.string();
            break;
          case 2:
            G.bondedTokens = O.string();
            break;
          default:
            O.skipType(L & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(m) {
      const S = a();
      return (0, T.isSet)(m.notBondedTokens) && (S.notBondedTokens = String(m.notBondedTokens)), (0, T.isSet)(m.bondedTokens) && (S.bondedTokens = String(m.bondedTokens)), S;
    },
    toJSON(m) {
      const S = {};
      return m.notBondedTokens !== void 0 && (S.notBondedTokens = m.notBondedTokens), m.bondedTokens !== void 0 && (S.bondedTokens = m.bondedTokens), S;
    },
    fromPartial(m) {
      const S = a();
      return S.notBondedTokens = m.notBondedTokens ?? "", S.bondedTokens = m.bondedTokens ?? "", S;
    }
  };
  function g() {
    return {
      updates: []
    };
  }
  e.ValidatorUpdates = {
    typeUrl: "/cosmos.staking.v1beta1.ValidatorUpdates",
    encode(m, S = C.BinaryWriter.create()) {
      for (const O of m.updates)
        k.ValidatorUpdate.encode(O, S.uint32(10).fork()).ldelim();
      return S;
    },
    decode(m, S) {
      const O = m instanceof C.BinaryReader ? m : new C.BinaryReader(m);
      let Q = S === void 0 ? O.len : O.pos + S;
      const G = g();
      for (; O.pos < Q; ) {
        const L = O.uint32();
        switch (L >>> 3) {
          case 1:
            G.updates.push(k.ValidatorUpdate.decode(O, O.uint32()));
            break;
          default:
            O.skipType(L & 7);
            break;
        }
      }
      return G;
    },
    fromJSON(m) {
      const S = g();
      return Array.isArray(m == null ? void 0 : m.updates) && (S.updates = m.updates.map((O) => k.ValidatorUpdate.fromJSON(O))), S;
    },
    toJSON(m) {
      const S = {};
      return m.updates ? S.updates = m.updates.map((O) => O ? k.ValidatorUpdate.toJSON(O) : void 0) : S.updates = [], S;
    },
    fromPartial(m) {
      var O;
      const S = g();
      return S.updates = ((O = m.updates) == null ? void 0 : O.map((Q) => k.ValidatorUpdate.fromPartial(Q))) || [], S;
    }
  };
})(Rd);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgUpdateParamsResponse = e.MsgUpdateParams = e.MsgCancelUnbondingDelegationResponse = e.MsgCancelUnbondingDelegation = e.MsgUndelegateResponse = e.MsgUndelegate = e.MsgBeginRedelegateResponse = e.MsgBeginRedelegate = e.MsgDelegateResponse = e.MsgDelegate = e.MsgEditValidatorResponse = e.MsgEditValidator = e.MsgCreateValidatorResponse = e.MsgCreateValidator = e.protobufPackage = void 0;
  const n = Rd, r = Be, t = Le, i = _e, f = re, k = ie;
  e.protobufPackage = "cosmos.staking.v1beta1";
  function C() {
    return {
      description: n.Description.fromPartial({}),
      commission: n.CommissionRates.fromPartial({}),
      minSelfDelegation: "",
      delegatorAddress: "",
      validatorAddress: "",
      pubkey: void 0,
      value: t.Coin.fromPartial({})
    };
  }
  e.MsgCreateValidator = {
    typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidator",
    encode(o, p = f.BinaryWriter.create()) {
      return o.description !== void 0 && n.Description.encode(o.description, p.uint32(10).fork()).ldelim(), o.commission !== void 0 && n.CommissionRates.encode(o.commission, p.uint32(18).fork()).ldelim(), o.minSelfDelegation !== "" && p.uint32(26).string(o.minSelfDelegation), o.delegatorAddress !== "" && p.uint32(34).string(o.delegatorAddress), o.validatorAddress !== "" && p.uint32(42).string(o.validatorAddress), o.pubkey !== void 0 && r.Any.encode(o.pubkey, p.uint32(50).fork()).ldelim(), o.value !== void 0 && t.Coin.encode(o.value, p.uint32(58).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = C();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.description = n.Description.decode(I, I.uint32());
            break;
          case 2:
            s.commission = n.CommissionRates.decode(I, I.uint32());
            break;
          case 3:
            s.minSelfDelegation = I.string();
            break;
          case 4:
            s.delegatorAddress = I.string();
            break;
          case 5:
            s.validatorAddress = I.string();
            break;
          case 6:
            s.pubkey = r.Any.decode(I, I.uint32());
            break;
          case 7:
            s.value = t.Coin.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = C();
      return (0, k.isSet)(o.description) && (p.description = n.Description.fromJSON(o.description)), (0, k.isSet)(o.commission) && (p.commission = n.CommissionRates.fromJSON(o.commission)), (0, k.isSet)(o.minSelfDelegation) && (p.minSelfDelegation = String(o.minSelfDelegation)), (0, k.isSet)(o.delegatorAddress) && (p.delegatorAddress = String(o.delegatorAddress)), (0, k.isSet)(o.validatorAddress) && (p.validatorAddress = String(o.validatorAddress)), (0, k.isSet)(o.pubkey) && (p.pubkey = r.Any.fromJSON(o.pubkey)), (0, k.isSet)(o.value) && (p.value = t.Coin.fromJSON(o.value)), p;
    },
    toJSON(o) {
      const p = {};
      return o.description !== void 0 && (p.description = o.description ? n.Description.toJSON(o.description) : void 0), o.commission !== void 0 && (p.commission = o.commission ? n.CommissionRates.toJSON(o.commission) : void 0), o.minSelfDelegation !== void 0 && (p.minSelfDelegation = o.minSelfDelegation), o.delegatorAddress !== void 0 && (p.delegatorAddress = o.delegatorAddress), o.validatorAddress !== void 0 && (p.validatorAddress = o.validatorAddress), o.pubkey !== void 0 && (p.pubkey = o.pubkey ? r.Any.toJSON(o.pubkey) : void 0), o.value !== void 0 && (p.value = o.value ? t.Coin.toJSON(o.value) : void 0), p;
    },
    fromPartial(o) {
      const p = C();
      return o.description !== void 0 && o.description !== null && (p.description = n.Description.fromPartial(o.description)), o.commission !== void 0 && o.commission !== null && (p.commission = n.CommissionRates.fromPartial(o.commission)), p.minSelfDelegation = o.minSelfDelegation ?? "", p.delegatorAddress = o.delegatorAddress ?? "", p.validatorAddress = o.validatorAddress ?? "", o.pubkey !== void 0 && o.pubkey !== null && (p.pubkey = r.Any.fromPartial(o.pubkey)), o.value !== void 0 && o.value !== null && (p.value = t.Coin.fromPartial(o.value)), p;
    }
  };
  function T() {
    return {};
  }
  e.MsgCreateValidatorResponse = {
    typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidatorResponse",
    encode(o, p = f.BinaryWriter.create()) {
      return p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = T();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      return T();
    },
    toJSON(o) {
      return {};
    },
    fromPartial(o) {
      return T();
    }
  };
  function U() {
    return {
      description: n.Description.fromPartial({}),
      validatorAddress: "",
      commissionRate: "",
      minSelfDelegation: ""
    };
  }
  e.MsgEditValidator = {
    typeUrl: "/cosmos.staking.v1beta1.MsgEditValidator",
    encode(o, p = f.BinaryWriter.create()) {
      return o.description !== void 0 && n.Description.encode(o.description, p.uint32(10).fork()).ldelim(), o.validatorAddress !== "" && p.uint32(18).string(o.validatorAddress), o.commissionRate !== "" && p.uint32(26).string(o.commissionRate), o.minSelfDelegation !== "" && p.uint32(34).string(o.minSelfDelegation), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = U();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.description = n.Description.decode(I, I.uint32());
            break;
          case 2:
            s.validatorAddress = I.string();
            break;
          case 3:
            s.commissionRate = I.string();
            break;
          case 4:
            s.minSelfDelegation = I.string();
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = U();
      return (0, k.isSet)(o.description) && (p.description = n.Description.fromJSON(o.description)), (0, k.isSet)(o.validatorAddress) && (p.validatorAddress = String(o.validatorAddress)), (0, k.isSet)(o.commissionRate) && (p.commissionRate = String(o.commissionRate)), (0, k.isSet)(o.minSelfDelegation) && (p.minSelfDelegation = String(o.minSelfDelegation)), p;
    },
    toJSON(o) {
      const p = {};
      return o.description !== void 0 && (p.description = o.description ? n.Description.toJSON(o.description) : void 0), o.validatorAddress !== void 0 && (p.validatorAddress = o.validatorAddress), o.commissionRate !== void 0 && (p.commissionRate = o.commissionRate), o.minSelfDelegation !== void 0 && (p.minSelfDelegation = o.minSelfDelegation), p;
    },
    fromPartial(o) {
      const p = U();
      return o.description !== void 0 && o.description !== null && (p.description = n.Description.fromPartial(o.description)), p.validatorAddress = o.validatorAddress ?? "", p.commissionRate = o.commissionRate ?? "", p.minSelfDelegation = o.minSelfDelegation ?? "", p;
    }
  };
  function w() {
    return {};
  }
  e.MsgEditValidatorResponse = {
    typeUrl: "/cosmos.staking.v1beta1.MsgEditValidatorResponse",
    encode(o, p = f.BinaryWriter.create()) {
      return p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = w();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      return w();
    },
    toJSON(o) {
      return {};
    },
    fromPartial(o) {
      return w();
    }
  };
  function N() {
    return {
      delegatorAddress: "",
      validatorAddress: "",
      amount: t.Coin.fromPartial({})
    };
  }
  e.MsgDelegate = {
    typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
    encode(o, p = f.BinaryWriter.create()) {
      return o.delegatorAddress !== "" && p.uint32(10).string(o.delegatorAddress), o.validatorAddress !== "" && p.uint32(18).string(o.validatorAddress), o.amount !== void 0 && t.Coin.encode(o.amount, p.uint32(26).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = N();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.delegatorAddress = I.string();
            break;
          case 2:
            s.validatorAddress = I.string();
            break;
          case 3:
            s.amount = t.Coin.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = N();
      return (0, k.isSet)(o.delegatorAddress) && (p.delegatorAddress = String(o.delegatorAddress)), (0, k.isSet)(o.validatorAddress) && (p.validatorAddress = String(o.validatorAddress)), (0, k.isSet)(o.amount) && (p.amount = t.Coin.fromJSON(o.amount)), p;
    },
    toJSON(o) {
      const p = {};
      return o.delegatorAddress !== void 0 && (p.delegatorAddress = o.delegatorAddress), o.validatorAddress !== void 0 && (p.validatorAddress = o.validatorAddress), o.amount !== void 0 && (p.amount = o.amount ? t.Coin.toJSON(o.amount) : void 0), p;
    },
    fromPartial(o) {
      const p = N();
      return p.delegatorAddress = o.delegatorAddress ?? "", p.validatorAddress = o.validatorAddress ?? "", o.amount !== void 0 && o.amount !== null && (p.amount = t.Coin.fromPartial(o.amount)), p;
    }
  };
  function h() {
    return {};
  }
  e.MsgDelegateResponse = {
    typeUrl: "/cosmos.staking.v1beta1.MsgDelegateResponse",
    encode(o, p = f.BinaryWriter.create()) {
      return p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = h();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      return h();
    },
    toJSON(o) {
      return {};
    },
    fromPartial(o) {
      return h();
    }
  };
  function P() {
    return {
      delegatorAddress: "",
      validatorSrcAddress: "",
      validatorDstAddress: "",
      amount: t.Coin.fromPartial({})
    };
  }
  e.MsgBeginRedelegate = {
    typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegate",
    encode(o, p = f.BinaryWriter.create()) {
      return o.delegatorAddress !== "" && p.uint32(10).string(o.delegatorAddress), o.validatorSrcAddress !== "" && p.uint32(18).string(o.validatorSrcAddress), o.validatorDstAddress !== "" && p.uint32(26).string(o.validatorDstAddress), o.amount !== void 0 && t.Coin.encode(o.amount, p.uint32(34).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = P();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.delegatorAddress = I.string();
            break;
          case 2:
            s.validatorSrcAddress = I.string();
            break;
          case 3:
            s.validatorDstAddress = I.string();
            break;
          case 4:
            s.amount = t.Coin.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = P();
      return (0, k.isSet)(o.delegatorAddress) && (p.delegatorAddress = String(o.delegatorAddress)), (0, k.isSet)(o.validatorSrcAddress) && (p.validatorSrcAddress = String(o.validatorSrcAddress)), (0, k.isSet)(o.validatorDstAddress) && (p.validatorDstAddress = String(o.validatorDstAddress)), (0, k.isSet)(o.amount) && (p.amount = t.Coin.fromJSON(o.amount)), p;
    },
    toJSON(o) {
      const p = {};
      return o.delegatorAddress !== void 0 && (p.delegatorAddress = o.delegatorAddress), o.validatorSrcAddress !== void 0 && (p.validatorSrcAddress = o.validatorSrcAddress), o.validatorDstAddress !== void 0 && (p.validatorDstAddress = o.validatorDstAddress), o.amount !== void 0 && (p.amount = o.amount ? t.Coin.toJSON(o.amount) : void 0), p;
    },
    fromPartial(o) {
      const p = P();
      return p.delegatorAddress = o.delegatorAddress ?? "", p.validatorSrcAddress = o.validatorSrcAddress ?? "", p.validatorDstAddress = o.validatorDstAddress ?? "", o.amount !== void 0 && o.amount !== null && (p.amount = t.Coin.fromPartial(o.amount)), p;
    }
  };
  function b() {
    return {
      completionTime: i.Timestamp.fromPartial({})
    };
  }
  e.MsgBeginRedelegateResponse = {
    typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegateResponse",
    encode(o, p = f.BinaryWriter.create()) {
      return o.completionTime !== void 0 && i.Timestamp.encode(o.completionTime, p.uint32(10).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = b();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.completionTime = i.Timestamp.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = b();
      return (0, k.isSet)(o.completionTime) && (p.completionTime = (0, k.fromJsonTimestamp)(o.completionTime)), p;
    },
    toJSON(o) {
      const p = {};
      return o.completionTime !== void 0 && (p.completionTime = (0, k.fromTimestamp)(o.completionTime).toISOString()), p;
    },
    fromPartial(o) {
      const p = b();
      return o.completionTime !== void 0 && o.completionTime !== null && (p.completionTime = i.Timestamp.fromPartial(o.completionTime)), p;
    }
  };
  function c() {
    return {
      delegatorAddress: "",
      validatorAddress: "",
      amount: t.Coin.fromPartial({})
    };
  }
  e.MsgUndelegate = {
    typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
    encode(o, p = f.BinaryWriter.create()) {
      return o.delegatorAddress !== "" && p.uint32(10).string(o.delegatorAddress), o.validatorAddress !== "" && p.uint32(18).string(o.validatorAddress), o.amount !== void 0 && t.Coin.encode(o.amount, p.uint32(26).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = c();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.delegatorAddress = I.string();
            break;
          case 2:
            s.validatorAddress = I.string();
            break;
          case 3:
            s.amount = t.Coin.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = c();
      return (0, k.isSet)(o.delegatorAddress) && (p.delegatorAddress = String(o.delegatorAddress)), (0, k.isSet)(o.validatorAddress) && (p.validatorAddress = String(o.validatorAddress)), (0, k.isSet)(o.amount) && (p.amount = t.Coin.fromJSON(o.amount)), p;
    },
    toJSON(o) {
      const p = {};
      return o.delegatorAddress !== void 0 && (p.delegatorAddress = o.delegatorAddress), o.validatorAddress !== void 0 && (p.validatorAddress = o.validatorAddress), o.amount !== void 0 && (p.amount = o.amount ? t.Coin.toJSON(o.amount) : void 0), p;
    },
    fromPartial(o) {
      const p = c();
      return p.delegatorAddress = o.delegatorAddress ?? "", p.validatorAddress = o.validatorAddress ?? "", o.amount !== void 0 && o.amount !== null && (p.amount = t.Coin.fromPartial(o.amount)), p;
    }
  };
  function l() {
    return {
      completionTime: i.Timestamp.fromPartial({})
    };
  }
  e.MsgUndelegateResponse = {
    typeUrl: "/cosmos.staking.v1beta1.MsgUndelegateResponse",
    encode(o, p = f.BinaryWriter.create()) {
      return o.completionTime !== void 0 && i.Timestamp.encode(o.completionTime, p.uint32(10).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = l();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.completionTime = i.Timestamp.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = l();
      return (0, k.isSet)(o.completionTime) && (p.completionTime = (0, k.fromJsonTimestamp)(o.completionTime)), p;
    },
    toJSON(o) {
      const p = {};
      return o.completionTime !== void 0 && (p.completionTime = (0, k.fromTimestamp)(o.completionTime).toISOString()), p;
    },
    fromPartial(o) {
      const p = l();
      return o.completionTime !== void 0 && o.completionTime !== null && (p.completionTime = i.Timestamp.fromPartial(o.completionTime)), p;
    }
  };
  function y() {
    return {
      delegatorAddress: "",
      validatorAddress: "",
      amount: t.Coin.fromPartial({}),
      creationHeight: BigInt(0)
    };
  }
  e.MsgCancelUnbondingDelegation = {
    typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
    encode(o, p = f.BinaryWriter.create()) {
      return o.delegatorAddress !== "" && p.uint32(10).string(o.delegatorAddress), o.validatorAddress !== "" && p.uint32(18).string(o.validatorAddress), o.amount !== void 0 && t.Coin.encode(o.amount, p.uint32(26).fork()).ldelim(), o.creationHeight !== BigInt(0) && p.uint32(32).int64(o.creationHeight), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = y();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.delegatorAddress = I.string();
            break;
          case 2:
            s.validatorAddress = I.string();
            break;
          case 3:
            s.amount = t.Coin.decode(I, I.uint32());
            break;
          case 4:
            s.creationHeight = I.int64();
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = y();
      return (0, k.isSet)(o.delegatorAddress) && (p.delegatorAddress = String(o.delegatorAddress)), (0, k.isSet)(o.validatorAddress) && (p.validatorAddress = String(o.validatorAddress)), (0, k.isSet)(o.amount) && (p.amount = t.Coin.fromJSON(o.amount)), (0, k.isSet)(o.creationHeight) && (p.creationHeight = BigInt(o.creationHeight.toString())), p;
    },
    toJSON(o) {
      const p = {};
      return o.delegatorAddress !== void 0 && (p.delegatorAddress = o.delegatorAddress), o.validatorAddress !== void 0 && (p.validatorAddress = o.validatorAddress), o.amount !== void 0 && (p.amount = o.amount ? t.Coin.toJSON(o.amount) : void 0), o.creationHeight !== void 0 && (p.creationHeight = (o.creationHeight || BigInt(0)).toString()), p;
    },
    fromPartial(o) {
      const p = y();
      return p.delegatorAddress = o.delegatorAddress ?? "", p.validatorAddress = o.validatorAddress ?? "", o.amount !== void 0 && o.amount !== null && (p.amount = t.Coin.fromPartial(o.amount)), o.creationHeight !== void 0 && o.creationHeight !== null && (p.creationHeight = BigInt(o.creationHeight.toString())), p;
    }
  };
  function E() {
    return {};
  }
  e.MsgCancelUnbondingDelegationResponse = {
    typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegationResponse",
    encode(o, p = f.BinaryWriter.create()) {
      return p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = E();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      return E();
    },
    toJSON(o) {
      return {};
    },
    fromPartial(o) {
      return E();
    }
  };
  function J() {
    return {
      authority: "",
      params: n.Params.fromPartial({})
    };
  }
  e.MsgUpdateParams = {
    typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParams",
    encode(o, p = f.BinaryWriter.create()) {
      return o.authority !== "" && p.uint32(10).string(o.authority), o.params !== void 0 && n.Params.encode(o.params, p.uint32(18).fork()).ldelim(), p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = J();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          case 1:
            s.authority = I.string();
            break;
          case 2:
            s.params = n.Params.decode(I, I.uint32());
            break;
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      const p = J();
      return (0, k.isSet)(o.authority) && (p.authority = String(o.authority)), (0, k.isSet)(o.params) && (p.params = n.Params.fromJSON(o.params)), p;
    },
    toJSON(o) {
      const p = {};
      return o.authority !== void 0 && (p.authority = o.authority), o.params !== void 0 && (p.params = o.params ? n.Params.toJSON(o.params) : void 0), p;
    },
    fromPartial(o) {
      const p = J();
      return p.authority = o.authority ?? "", o.params !== void 0 && o.params !== null && (p.params = n.Params.fromPartial(o.params)), p;
    }
  };
  function _() {
    return {};
  }
  e.MsgUpdateParamsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParamsResponse",
    encode(o, p = f.BinaryWriter.create()) {
      return p;
    },
    decode(o, p) {
      const I = o instanceof f.BinaryReader ? o : new f.BinaryReader(o);
      let q = p === void 0 ? I.len : I.pos + p;
      const s = _();
      for (; I.pos < q; ) {
        const u = I.uint32();
        switch (u >>> 3) {
          default:
            I.skipType(u & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(o) {
      return _();
    },
    toJSON(o) {
      return {};
    },
    fromPartial(o) {
      return _();
    }
  };
  class V {
    constructor(p) {
      this.rpc = p, this.CreateValidator = this.CreateValidator.bind(this), this.EditValidator = this.EditValidator.bind(this), this.Delegate = this.Delegate.bind(this), this.BeginRedelegate = this.BeginRedelegate.bind(this), this.Undelegate = this.Undelegate.bind(this), this.CancelUnbondingDelegation = this.CancelUnbondingDelegation.bind(this), this.UpdateParams = this.UpdateParams.bind(this);
    }
    CreateValidator(p) {
      const I = e.MsgCreateValidator.encode(p).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "CreateValidator", I).then((s) => e.MsgCreateValidatorResponse.decode(new f.BinaryReader(s)));
    }
    EditValidator(p) {
      const I = e.MsgEditValidator.encode(p).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "EditValidator", I).then((s) => e.MsgEditValidatorResponse.decode(new f.BinaryReader(s)));
    }
    Delegate(p) {
      const I = e.MsgDelegate.encode(p).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "Delegate", I).then((s) => e.MsgDelegateResponse.decode(new f.BinaryReader(s)));
    }
    BeginRedelegate(p) {
      const I = e.MsgBeginRedelegate.encode(p).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "BeginRedelegate", I).then((s) => e.MsgBeginRedelegateResponse.decode(new f.BinaryReader(s)));
    }
    Undelegate(p) {
      const I = e.MsgUndelegate.encode(p).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "Undelegate", I).then((s) => e.MsgUndelegateResponse.decode(new f.BinaryReader(s)));
    }
    CancelUnbondingDelegation(p) {
      const I = e.MsgCancelUnbondingDelegation.encode(p).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "CancelUnbondingDelegation", I).then((s) => e.MsgCancelUnbondingDelegationResponse.decode(new f.BinaryReader(s)));
    }
    UpdateParams(p) {
      const I = e.MsgUpdateParams.encode(p).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Msg", "UpdateParams", I).then((s) => e.MsgUpdateParamsResponse.decode(new f.BinaryReader(s)));
    }
  }
  e.MsgClientImpl = V;
})(vd);
Object.defineProperty(je, "__esModule", { value: !0 });
je.isMsgUndelegateEncodeObject = je.isMsgEditValidatorEncodeObject = je.isMsgDelegateEncodeObject = je.isMsgCreateValidatorEncodeObject = je.isMsgBeginRedelegateEncodeObject = je.stakingTypes = void 0;
const Jr = vd;
je.stakingTypes = [
  ["/cosmos.staking.v1beta1.MsgBeginRedelegate", Jr.MsgBeginRedelegate],
  ["/cosmos.staking.v1beta1.MsgCreateValidator", Jr.MsgCreateValidator],
  ["/cosmos.staking.v1beta1.MsgDelegate", Jr.MsgDelegate],
  ["/cosmos.staking.v1beta1.MsgEditValidator", Jr.MsgEditValidator],
  ["/cosmos.staking.v1beta1.MsgUndelegate", Jr.MsgUndelegate]
];
function eg(e) {
  return e.typeUrl === "/cosmos.staking.v1beta1.MsgBeginRedelegate";
}
je.isMsgBeginRedelegateEncodeObject = eg;
function ng(e) {
  return e.typeUrl === "/cosmos.staking.v1beta1.MsgCreateValidator";
}
je.isMsgCreateValidatorEncodeObject = ng;
function tg(e) {
  return e.typeUrl === "/cosmos.staking.v1beta1.MsgDelegate";
}
je.isMsgDelegateEncodeObject = tg;
function rg(e) {
  return e.typeUrl === "/cosmos.staking.v1beta1.MsgEditValidator";
}
je.isMsgEditValidatorEncodeObject = rg;
function ig(e) {
  return e.typeUrl === "/cosmos.staking.v1beta1.MsgUndelegate";
}
je.isMsgUndelegateEncodeObject = ig;
var wo = {}, vl = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueryClientImpl = e.QueryParamsResponse = e.QueryParamsRequest = e.QueryPoolResponse = e.QueryPoolRequest = e.QueryHistoricalInfoResponse = e.QueryHistoricalInfoRequest = e.QueryDelegatorValidatorResponse = e.QueryDelegatorValidatorRequest = e.QueryDelegatorValidatorsResponse = e.QueryDelegatorValidatorsRequest = e.QueryRedelegationsResponse = e.QueryRedelegationsRequest = e.QueryDelegatorUnbondingDelegationsResponse = e.QueryDelegatorUnbondingDelegationsRequest = e.QueryDelegatorDelegationsResponse = e.QueryDelegatorDelegationsRequest = e.QueryUnbondingDelegationResponse = e.QueryUnbondingDelegationRequest = e.QueryDelegationResponse = e.QueryDelegationRequest = e.QueryValidatorUnbondingDelegationsResponse = e.QueryValidatorUnbondingDelegationsRequest = e.QueryValidatorDelegationsResponse = e.QueryValidatorDelegationsRequest = e.QueryValidatorResponse = e.QueryValidatorRequest = e.QueryValidatorsResponse = e.QueryValidatorsRequest = e.protobufPackage = void 0;
  const n = Ae, r = Rd, t = re, i = ie;
  e.protobufPackage = "cosmos.staking.v1beta1";
  function f() {
    return {
      status: "",
      pagination: void 0
    };
  }
  e.QueryValidatorsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorsRequest",
    encode(a, g = t.BinaryWriter.create()) {
      return a.status !== "" && g.uint32(10).string(a.status), a.pagination !== void 0 && n.PageRequest.encode(a.pagination, g.uint32(18).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = f();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.status = m.string();
            break;
          case 2:
            O.pagination = n.PageRequest.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = f();
      return (0, i.isSet)(a.status) && (g.status = String(a.status)), (0, i.isSet)(a.pagination) && (g.pagination = n.PageRequest.fromJSON(a.pagination)), g;
    },
    toJSON(a) {
      const g = {};
      return a.status !== void 0 && (g.status = a.status), a.pagination !== void 0 && (g.pagination = a.pagination ? n.PageRequest.toJSON(a.pagination) : void 0), g;
    },
    fromPartial(a) {
      const g = f();
      return g.status = a.status ?? "", a.pagination !== void 0 && a.pagination !== null && (g.pagination = n.PageRequest.fromPartial(a.pagination)), g;
    }
  };
  function k() {
    return {
      validators: [],
      pagination: void 0
    };
  }
  e.QueryValidatorsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorsResponse",
    encode(a, g = t.BinaryWriter.create()) {
      for (const m of a.validators)
        r.Validator.encode(m, g.uint32(10).fork()).ldelim();
      return a.pagination !== void 0 && n.PageResponse.encode(a.pagination, g.uint32(18).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = k();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.validators.push(r.Validator.decode(m, m.uint32()));
            break;
          case 2:
            O.pagination = n.PageResponse.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = k();
      return Array.isArray(a == null ? void 0 : a.validators) && (g.validators = a.validators.map((m) => r.Validator.fromJSON(m))), (0, i.isSet)(a.pagination) && (g.pagination = n.PageResponse.fromJSON(a.pagination)), g;
    },
    toJSON(a) {
      const g = {};
      return a.validators ? g.validators = a.validators.map((m) => m ? r.Validator.toJSON(m) : void 0) : g.validators = [], a.pagination !== void 0 && (g.pagination = a.pagination ? n.PageResponse.toJSON(a.pagination) : void 0), g;
    },
    fromPartial(a) {
      var m;
      const g = k();
      return g.validators = ((m = a.validators) == null ? void 0 : m.map((S) => r.Validator.fromPartial(S))) || [], a.pagination !== void 0 && a.pagination !== null && (g.pagination = n.PageResponse.fromPartial(a.pagination)), g;
    }
  };
  function C() {
    return {
      validatorAddr: ""
    };
  }
  e.QueryValidatorRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorRequest",
    encode(a, g = t.BinaryWriter.create()) {
      return a.validatorAddr !== "" && g.uint32(10).string(a.validatorAddr), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = C();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.validatorAddr = m.string();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = C();
      return (0, i.isSet)(a.validatorAddr) && (g.validatorAddr = String(a.validatorAddr)), g;
    },
    toJSON(a) {
      const g = {};
      return a.validatorAddr !== void 0 && (g.validatorAddr = a.validatorAddr), g;
    },
    fromPartial(a) {
      const g = C();
      return g.validatorAddr = a.validatorAddr ?? "", g;
    }
  };
  function T() {
    return {
      validator: r.Validator.fromPartial({})
    };
  }
  e.QueryValidatorResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorResponse",
    encode(a, g = t.BinaryWriter.create()) {
      return a.validator !== void 0 && r.Validator.encode(a.validator, g.uint32(10).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = T();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.validator = r.Validator.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = T();
      return (0, i.isSet)(a.validator) && (g.validator = r.Validator.fromJSON(a.validator)), g;
    },
    toJSON(a) {
      const g = {};
      return a.validator !== void 0 && (g.validator = a.validator ? r.Validator.toJSON(a.validator) : void 0), g;
    },
    fromPartial(a) {
      const g = T();
      return a.validator !== void 0 && a.validator !== null && (g.validator = r.Validator.fromPartial(a.validator)), g;
    }
  };
  function U() {
    return {
      validatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryValidatorDelegationsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorDelegationsRequest",
    encode(a, g = t.BinaryWriter.create()) {
      return a.validatorAddr !== "" && g.uint32(10).string(a.validatorAddr), a.pagination !== void 0 && n.PageRequest.encode(a.pagination, g.uint32(18).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = U();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.validatorAddr = m.string();
            break;
          case 2:
            O.pagination = n.PageRequest.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = U();
      return (0, i.isSet)(a.validatorAddr) && (g.validatorAddr = String(a.validatorAddr)), (0, i.isSet)(a.pagination) && (g.pagination = n.PageRequest.fromJSON(a.pagination)), g;
    },
    toJSON(a) {
      const g = {};
      return a.validatorAddr !== void 0 && (g.validatorAddr = a.validatorAddr), a.pagination !== void 0 && (g.pagination = a.pagination ? n.PageRequest.toJSON(a.pagination) : void 0), g;
    },
    fromPartial(a) {
      const g = U();
      return g.validatorAddr = a.validatorAddr ?? "", a.pagination !== void 0 && a.pagination !== null && (g.pagination = n.PageRequest.fromPartial(a.pagination)), g;
    }
  };
  function w() {
    return {
      delegationResponses: [],
      pagination: void 0
    };
  }
  e.QueryValidatorDelegationsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorDelegationsResponse",
    encode(a, g = t.BinaryWriter.create()) {
      for (const m of a.delegationResponses)
        r.DelegationResponse.encode(m, g.uint32(10).fork()).ldelim();
      return a.pagination !== void 0 && n.PageResponse.encode(a.pagination, g.uint32(18).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = w();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.delegationResponses.push(r.DelegationResponse.decode(m, m.uint32()));
            break;
          case 2:
            O.pagination = n.PageResponse.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = w();
      return Array.isArray(a == null ? void 0 : a.delegationResponses) && (g.delegationResponses = a.delegationResponses.map((m) => r.DelegationResponse.fromJSON(m))), (0, i.isSet)(a.pagination) && (g.pagination = n.PageResponse.fromJSON(a.pagination)), g;
    },
    toJSON(a) {
      const g = {};
      return a.delegationResponses ? g.delegationResponses = a.delegationResponses.map((m) => m ? r.DelegationResponse.toJSON(m) : void 0) : g.delegationResponses = [], a.pagination !== void 0 && (g.pagination = a.pagination ? n.PageResponse.toJSON(a.pagination) : void 0), g;
    },
    fromPartial(a) {
      var m;
      const g = w();
      return g.delegationResponses = ((m = a.delegationResponses) == null ? void 0 : m.map((S) => r.DelegationResponse.fromPartial(S))) || [], a.pagination !== void 0 && a.pagination !== null && (g.pagination = n.PageResponse.fromPartial(a.pagination)), g;
    }
  };
  function N() {
    return {
      validatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryValidatorUnbondingDelegationsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsRequest",
    encode(a, g = t.BinaryWriter.create()) {
      return a.validatorAddr !== "" && g.uint32(10).string(a.validatorAddr), a.pagination !== void 0 && n.PageRequest.encode(a.pagination, g.uint32(18).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = N();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.validatorAddr = m.string();
            break;
          case 2:
            O.pagination = n.PageRequest.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = N();
      return (0, i.isSet)(a.validatorAddr) && (g.validatorAddr = String(a.validatorAddr)), (0, i.isSet)(a.pagination) && (g.pagination = n.PageRequest.fromJSON(a.pagination)), g;
    },
    toJSON(a) {
      const g = {};
      return a.validatorAddr !== void 0 && (g.validatorAddr = a.validatorAddr), a.pagination !== void 0 && (g.pagination = a.pagination ? n.PageRequest.toJSON(a.pagination) : void 0), g;
    },
    fromPartial(a) {
      const g = N();
      return g.validatorAddr = a.validatorAddr ?? "", a.pagination !== void 0 && a.pagination !== null && (g.pagination = n.PageRequest.fromPartial(a.pagination)), g;
    }
  };
  function h() {
    return {
      unbondingResponses: [],
      pagination: void 0
    };
  }
  e.QueryValidatorUnbondingDelegationsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsResponse",
    encode(a, g = t.BinaryWriter.create()) {
      for (const m of a.unbondingResponses)
        r.UnbondingDelegation.encode(m, g.uint32(10).fork()).ldelim();
      return a.pagination !== void 0 && n.PageResponse.encode(a.pagination, g.uint32(18).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = h();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.unbondingResponses.push(r.UnbondingDelegation.decode(m, m.uint32()));
            break;
          case 2:
            O.pagination = n.PageResponse.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = h();
      return Array.isArray(a == null ? void 0 : a.unbondingResponses) && (g.unbondingResponses = a.unbondingResponses.map((m) => r.UnbondingDelegation.fromJSON(m))), (0, i.isSet)(a.pagination) && (g.pagination = n.PageResponse.fromJSON(a.pagination)), g;
    },
    toJSON(a) {
      const g = {};
      return a.unbondingResponses ? g.unbondingResponses = a.unbondingResponses.map((m) => m ? r.UnbondingDelegation.toJSON(m) : void 0) : g.unbondingResponses = [], a.pagination !== void 0 && (g.pagination = a.pagination ? n.PageResponse.toJSON(a.pagination) : void 0), g;
    },
    fromPartial(a) {
      var m;
      const g = h();
      return g.unbondingResponses = ((m = a.unbondingResponses) == null ? void 0 : m.map((S) => r.UnbondingDelegation.fromPartial(S))) || [], a.pagination !== void 0 && a.pagination !== null && (g.pagination = n.PageResponse.fromPartial(a.pagination)), g;
    }
  };
  function P() {
    return {
      delegatorAddr: "",
      validatorAddr: ""
    };
  }
  e.QueryDelegationRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegationRequest",
    encode(a, g = t.BinaryWriter.create()) {
      return a.delegatorAddr !== "" && g.uint32(10).string(a.delegatorAddr), a.validatorAddr !== "" && g.uint32(18).string(a.validatorAddr), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = P();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.delegatorAddr = m.string();
            break;
          case 2:
            O.validatorAddr = m.string();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = P();
      return (0, i.isSet)(a.delegatorAddr) && (g.delegatorAddr = String(a.delegatorAddr)), (0, i.isSet)(a.validatorAddr) && (g.validatorAddr = String(a.validatorAddr)), g;
    },
    toJSON(a) {
      const g = {};
      return a.delegatorAddr !== void 0 && (g.delegatorAddr = a.delegatorAddr), a.validatorAddr !== void 0 && (g.validatorAddr = a.validatorAddr), g;
    },
    fromPartial(a) {
      const g = P();
      return g.delegatorAddr = a.delegatorAddr ?? "", g.validatorAddr = a.validatorAddr ?? "", g;
    }
  };
  function b() {
    return {
      delegationResponse: void 0
    };
  }
  e.QueryDelegationResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegationResponse",
    encode(a, g = t.BinaryWriter.create()) {
      return a.delegationResponse !== void 0 && r.DelegationResponse.encode(a.delegationResponse, g.uint32(10).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = b();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.delegationResponse = r.DelegationResponse.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = b();
      return (0, i.isSet)(a.delegationResponse) && (g.delegationResponse = r.DelegationResponse.fromJSON(a.delegationResponse)), g;
    },
    toJSON(a) {
      const g = {};
      return a.delegationResponse !== void 0 && (g.delegationResponse = a.delegationResponse ? r.DelegationResponse.toJSON(a.delegationResponse) : void 0), g;
    },
    fromPartial(a) {
      const g = b();
      return a.delegationResponse !== void 0 && a.delegationResponse !== null && (g.delegationResponse = r.DelegationResponse.fromPartial(a.delegationResponse)), g;
    }
  };
  function c() {
    return {
      delegatorAddr: "",
      validatorAddr: ""
    };
  }
  e.QueryUnbondingDelegationRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryUnbondingDelegationRequest",
    encode(a, g = t.BinaryWriter.create()) {
      return a.delegatorAddr !== "" && g.uint32(10).string(a.delegatorAddr), a.validatorAddr !== "" && g.uint32(18).string(a.validatorAddr), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = c();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.delegatorAddr = m.string();
            break;
          case 2:
            O.validatorAddr = m.string();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = c();
      return (0, i.isSet)(a.delegatorAddr) && (g.delegatorAddr = String(a.delegatorAddr)), (0, i.isSet)(a.validatorAddr) && (g.validatorAddr = String(a.validatorAddr)), g;
    },
    toJSON(a) {
      const g = {};
      return a.delegatorAddr !== void 0 && (g.delegatorAddr = a.delegatorAddr), a.validatorAddr !== void 0 && (g.validatorAddr = a.validatorAddr), g;
    },
    fromPartial(a) {
      const g = c();
      return g.delegatorAddr = a.delegatorAddr ?? "", g.validatorAddr = a.validatorAddr ?? "", g;
    }
  };
  function l() {
    return {
      unbond: r.UnbondingDelegation.fromPartial({})
    };
  }
  e.QueryUnbondingDelegationResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryUnbondingDelegationResponse",
    encode(a, g = t.BinaryWriter.create()) {
      return a.unbond !== void 0 && r.UnbondingDelegation.encode(a.unbond, g.uint32(10).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = l();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.unbond = r.UnbondingDelegation.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = l();
      return (0, i.isSet)(a.unbond) && (g.unbond = r.UnbondingDelegation.fromJSON(a.unbond)), g;
    },
    toJSON(a) {
      const g = {};
      return a.unbond !== void 0 && (g.unbond = a.unbond ? r.UnbondingDelegation.toJSON(a.unbond) : void 0), g;
    },
    fromPartial(a) {
      const g = l();
      return a.unbond !== void 0 && a.unbond !== null && (g.unbond = r.UnbondingDelegation.fromPartial(a.unbond)), g;
    }
  };
  function y() {
    return {
      delegatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryDelegatorDelegationsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorDelegationsRequest",
    encode(a, g = t.BinaryWriter.create()) {
      return a.delegatorAddr !== "" && g.uint32(10).string(a.delegatorAddr), a.pagination !== void 0 && n.PageRequest.encode(a.pagination, g.uint32(18).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = y();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.delegatorAddr = m.string();
            break;
          case 2:
            O.pagination = n.PageRequest.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = y();
      return (0, i.isSet)(a.delegatorAddr) && (g.delegatorAddr = String(a.delegatorAddr)), (0, i.isSet)(a.pagination) && (g.pagination = n.PageRequest.fromJSON(a.pagination)), g;
    },
    toJSON(a) {
      const g = {};
      return a.delegatorAddr !== void 0 && (g.delegatorAddr = a.delegatorAddr), a.pagination !== void 0 && (g.pagination = a.pagination ? n.PageRequest.toJSON(a.pagination) : void 0), g;
    },
    fromPartial(a) {
      const g = y();
      return g.delegatorAddr = a.delegatorAddr ?? "", a.pagination !== void 0 && a.pagination !== null && (g.pagination = n.PageRequest.fromPartial(a.pagination)), g;
    }
  };
  function E() {
    return {
      delegationResponses: [],
      pagination: void 0
    };
  }
  e.QueryDelegatorDelegationsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorDelegationsResponse",
    encode(a, g = t.BinaryWriter.create()) {
      for (const m of a.delegationResponses)
        r.DelegationResponse.encode(m, g.uint32(10).fork()).ldelim();
      return a.pagination !== void 0 && n.PageResponse.encode(a.pagination, g.uint32(18).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = E();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.delegationResponses.push(r.DelegationResponse.decode(m, m.uint32()));
            break;
          case 2:
            O.pagination = n.PageResponse.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = E();
      return Array.isArray(a == null ? void 0 : a.delegationResponses) && (g.delegationResponses = a.delegationResponses.map((m) => r.DelegationResponse.fromJSON(m))), (0, i.isSet)(a.pagination) && (g.pagination = n.PageResponse.fromJSON(a.pagination)), g;
    },
    toJSON(a) {
      const g = {};
      return a.delegationResponses ? g.delegationResponses = a.delegationResponses.map((m) => m ? r.DelegationResponse.toJSON(m) : void 0) : g.delegationResponses = [], a.pagination !== void 0 && (g.pagination = a.pagination ? n.PageResponse.toJSON(a.pagination) : void 0), g;
    },
    fromPartial(a) {
      var m;
      const g = E();
      return g.delegationResponses = ((m = a.delegationResponses) == null ? void 0 : m.map((S) => r.DelegationResponse.fromPartial(S))) || [], a.pagination !== void 0 && a.pagination !== null && (g.pagination = n.PageResponse.fromPartial(a.pagination)), g;
    }
  };
  function J() {
    return {
      delegatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryDelegatorUnbondingDelegationsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsRequest",
    encode(a, g = t.BinaryWriter.create()) {
      return a.delegatorAddr !== "" && g.uint32(10).string(a.delegatorAddr), a.pagination !== void 0 && n.PageRequest.encode(a.pagination, g.uint32(18).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = J();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.delegatorAddr = m.string();
            break;
          case 2:
            O.pagination = n.PageRequest.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = J();
      return (0, i.isSet)(a.delegatorAddr) && (g.delegatorAddr = String(a.delegatorAddr)), (0, i.isSet)(a.pagination) && (g.pagination = n.PageRequest.fromJSON(a.pagination)), g;
    },
    toJSON(a) {
      const g = {};
      return a.delegatorAddr !== void 0 && (g.delegatorAddr = a.delegatorAddr), a.pagination !== void 0 && (g.pagination = a.pagination ? n.PageRequest.toJSON(a.pagination) : void 0), g;
    },
    fromPartial(a) {
      const g = J();
      return g.delegatorAddr = a.delegatorAddr ?? "", a.pagination !== void 0 && a.pagination !== null && (g.pagination = n.PageRequest.fromPartial(a.pagination)), g;
    }
  };
  function _() {
    return {
      unbondingResponses: [],
      pagination: void 0
    };
  }
  e.QueryDelegatorUnbondingDelegationsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsResponse",
    encode(a, g = t.BinaryWriter.create()) {
      for (const m of a.unbondingResponses)
        r.UnbondingDelegation.encode(m, g.uint32(10).fork()).ldelim();
      return a.pagination !== void 0 && n.PageResponse.encode(a.pagination, g.uint32(18).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = _();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.unbondingResponses.push(r.UnbondingDelegation.decode(m, m.uint32()));
            break;
          case 2:
            O.pagination = n.PageResponse.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = _();
      return Array.isArray(a == null ? void 0 : a.unbondingResponses) && (g.unbondingResponses = a.unbondingResponses.map((m) => r.UnbondingDelegation.fromJSON(m))), (0, i.isSet)(a.pagination) && (g.pagination = n.PageResponse.fromJSON(a.pagination)), g;
    },
    toJSON(a) {
      const g = {};
      return a.unbondingResponses ? g.unbondingResponses = a.unbondingResponses.map((m) => m ? r.UnbondingDelegation.toJSON(m) : void 0) : g.unbondingResponses = [], a.pagination !== void 0 && (g.pagination = a.pagination ? n.PageResponse.toJSON(a.pagination) : void 0), g;
    },
    fromPartial(a) {
      var m;
      const g = _();
      return g.unbondingResponses = ((m = a.unbondingResponses) == null ? void 0 : m.map((S) => r.UnbondingDelegation.fromPartial(S))) || [], a.pagination !== void 0 && a.pagination !== null && (g.pagination = n.PageResponse.fromPartial(a.pagination)), g;
    }
  };
  function V() {
    return {
      delegatorAddr: "",
      srcValidatorAddr: "",
      dstValidatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryRedelegationsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryRedelegationsRequest",
    encode(a, g = t.BinaryWriter.create()) {
      return a.delegatorAddr !== "" && g.uint32(10).string(a.delegatorAddr), a.srcValidatorAddr !== "" && g.uint32(18).string(a.srcValidatorAddr), a.dstValidatorAddr !== "" && g.uint32(26).string(a.dstValidatorAddr), a.pagination !== void 0 && n.PageRequest.encode(a.pagination, g.uint32(34).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = V();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.delegatorAddr = m.string();
            break;
          case 2:
            O.srcValidatorAddr = m.string();
            break;
          case 3:
            O.dstValidatorAddr = m.string();
            break;
          case 4:
            O.pagination = n.PageRequest.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = V();
      return (0, i.isSet)(a.delegatorAddr) && (g.delegatorAddr = String(a.delegatorAddr)), (0, i.isSet)(a.srcValidatorAddr) && (g.srcValidatorAddr = String(a.srcValidatorAddr)), (0, i.isSet)(a.dstValidatorAddr) && (g.dstValidatorAddr = String(a.dstValidatorAddr)), (0, i.isSet)(a.pagination) && (g.pagination = n.PageRequest.fromJSON(a.pagination)), g;
    },
    toJSON(a) {
      const g = {};
      return a.delegatorAddr !== void 0 && (g.delegatorAddr = a.delegatorAddr), a.srcValidatorAddr !== void 0 && (g.srcValidatorAddr = a.srcValidatorAddr), a.dstValidatorAddr !== void 0 && (g.dstValidatorAddr = a.dstValidatorAddr), a.pagination !== void 0 && (g.pagination = a.pagination ? n.PageRequest.toJSON(a.pagination) : void 0), g;
    },
    fromPartial(a) {
      const g = V();
      return g.delegatorAddr = a.delegatorAddr ?? "", g.srcValidatorAddr = a.srcValidatorAddr ?? "", g.dstValidatorAddr = a.dstValidatorAddr ?? "", a.pagination !== void 0 && a.pagination !== null && (g.pagination = n.PageRequest.fromPartial(a.pagination)), g;
    }
  };
  function o() {
    return {
      redelegationResponses: [],
      pagination: void 0
    };
  }
  e.QueryRedelegationsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryRedelegationsResponse",
    encode(a, g = t.BinaryWriter.create()) {
      for (const m of a.redelegationResponses)
        r.RedelegationResponse.encode(m, g.uint32(10).fork()).ldelim();
      return a.pagination !== void 0 && n.PageResponse.encode(a.pagination, g.uint32(18).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = o();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.redelegationResponses.push(r.RedelegationResponse.decode(m, m.uint32()));
            break;
          case 2:
            O.pagination = n.PageResponse.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = o();
      return Array.isArray(a == null ? void 0 : a.redelegationResponses) && (g.redelegationResponses = a.redelegationResponses.map((m) => r.RedelegationResponse.fromJSON(m))), (0, i.isSet)(a.pagination) && (g.pagination = n.PageResponse.fromJSON(a.pagination)), g;
    },
    toJSON(a) {
      const g = {};
      return a.redelegationResponses ? g.redelegationResponses = a.redelegationResponses.map((m) => m ? r.RedelegationResponse.toJSON(m) : void 0) : g.redelegationResponses = [], a.pagination !== void 0 && (g.pagination = a.pagination ? n.PageResponse.toJSON(a.pagination) : void 0), g;
    },
    fromPartial(a) {
      var m;
      const g = o();
      return g.redelegationResponses = ((m = a.redelegationResponses) == null ? void 0 : m.map((S) => r.RedelegationResponse.fromPartial(S))) || [], a.pagination !== void 0 && a.pagination !== null && (g.pagination = n.PageResponse.fromPartial(a.pagination)), g;
    }
  };
  function p() {
    return {
      delegatorAddr: "",
      pagination: void 0
    };
  }
  e.QueryDelegatorValidatorsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorsRequest",
    encode(a, g = t.BinaryWriter.create()) {
      return a.delegatorAddr !== "" && g.uint32(10).string(a.delegatorAddr), a.pagination !== void 0 && n.PageRequest.encode(a.pagination, g.uint32(18).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = p();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.delegatorAddr = m.string();
            break;
          case 2:
            O.pagination = n.PageRequest.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = p();
      return (0, i.isSet)(a.delegatorAddr) && (g.delegatorAddr = String(a.delegatorAddr)), (0, i.isSet)(a.pagination) && (g.pagination = n.PageRequest.fromJSON(a.pagination)), g;
    },
    toJSON(a) {
      const g = {};
      return a.delegatorAddr !== void 0 && (g.delegatorAddr = a.delegatorAddr), a.pagination !== void 0 && (g.pagination = a.pagination ? n.PageRequest.toJSON(a.pagination) : void 0), g;
    },
    fromPartial(a) {
      const g = p();
      return g.delegatorAddr = a.delegatorAddr ?? "", a.pagination !== void 0 && a.pagination !== null && (g.pagination = n.PageRequest.fromPartial(a.pagination)), g;
    }
  };
  function I() {
    return {
      validators: [],
      pagination: void 0
    };
  }
  e.QueryDelegatorValidatorsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorsResponse",
    encode(a, g = t.BinaryWriter.create()) {
      for (const m of a.validators)
        r.Validator.encode(m, g.uint32(10).fork()).ldelim();
      return a.pagination !== void 0 && n.PageResponse.encode(a.pagination, g.uint32(18).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = I();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.validators.push(r.Validator.decode(m, m.uint32()));
            break;
          case 2:
            O.pagination = n.PageResponse.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = I();
      return Array.isArray(a == null ? void 0 : a.validators) && (g.validators = a.validators.map((m) => r.Validator.fromJSON(m))), (0, i.isSet)(a.pagination) && (g.pagination = n.PageResponse.fromJSON(a.pagination)), g;
    },
    toJSON(a) {
      const g = {};
      return a.validators ? g.validators = a.validators.map((m) => m ? r.Validator.toJSON(m) : void 0) : g.validators = [], a.pagination !== void 0 && (g.pagination = a.pagination ? n.PageResponse.toJSON(a.pagination) : void 0), g;
    },
    fromPartial(a) {
      var m;
      const g = I();
      return g.validators = ((m = a.validators) == null ? void 0 : m.map((S) => r.Validator.fromPartial(S))) || [], a.pagination !== void 0 && a.pagination !== null && (g.pagination = n.PageResponse.fromPartial(a.pagination)), g;
    }
  };
  function q() {
    return {
      delegatorAddr: "",
      validatorAddr: ""
    };
  }
  e.QueryDelegatorValidatorRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorRequest",
    encode(a, g = t.BinaryWriter.create()) {
      return a.delegatorAddr !== "" && g.uint32(10).string(a.delegatorAddr), a.validatorAddr !== "" && g.uint32(18).string(a.validatorAddr), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = q();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.delegatorAddr = m.string();
            break;
          case 2:
            O.validatorAddr = m.string();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = q();
      return (0, i.isSet)(a.delegatorAddr) && (g.delegatorAddr = String(a.delegatorAddr)), (0, i.isSet)(a.validatorAddr) && (g.validatorAddr = String(a.validatorAddr)), g;
    },
    toJSON(a) {
      const g = {};
      return a.delegatorAddr !== void 0 && (g.delegatorAddr = a.delegatorAddr), a.validatorAddr !== void 0 && (g.validatorAddr = a.validatorAddr), g;
    },
    fromPartial(a) {
      const g = q();
      return g.delegatorAddr = a.delegatorAddr ?? "", g.validatorAddr = a.validatorAddr ?? "", g;
    }
  };
  function s() {
    return {
      validator: r.Validator.fromPartial({})
    };
  }
  e.QueryDelegatorValidatorResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorResponse",
    encode(a, g = t.BinaryWriter.create()) {
      return a.validator !== void 0 && r.Validator.encode(a.validator, g.uint32(10).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = s();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.validator = r.Validator.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = s();
      return (0, i.isSet)(a.validator) && (g.validator = r.Validator.fromJSON(a.validator)), g;
    },
    toJSON(a) {
      const g = {};
      return a.validator !== void 0 && (g.validator = a.validator ? r.Validator.toJSON(a.validator) : void 0), g;
    },
    fromPartial(a) {
      const g = s();
      return a.validator !== void 0 && a.validator !== null && (g.validator = r.Validator.fromPartial(a.validator)), g;
    }
  };
  function u() {
    return {
      height: BigInt(0)
    };
  }
  e.QueryHistoricalInfoRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryHistoricalInfoRequest",
    encode(a, g = t.BinaryWriter.create()) {
      return a.height !== BigInt(0) && g.uint32(8).int64(a.height), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = u();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.height = m.int64();
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = u();
      return (0, i.isSet)(a.height) && (g.height = BigInt(a.height.toString())), g;
    },
    toJSON(a) {
      const g = {};
      return a.height !== void 0 && (g.height = (a.height || BigInt(0)).toString()), g;
    },
    fromPartial(a) {
      const g = u();
      return a.height !== void 0 && a.height !== null && (g.height = BigInt(a.height.toString())), g;
    }
  };
  function A() {
    return {
      hist: void 0
    };
  }
  e.QueryHistoricalInfoResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryHistoricalInfoResponse",
    encode(a, g = t.BinaryWriter.create()) {
      return a.hist !== void 0 && r.HistoricalInfo.encode(a.hist, g.uint32(10).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = A();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.hist = r.HistoricalInfo.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = A();
      return (0, i.isSet)(a.hist) && (g.hist = r.HistoricalInfo.fromJSON(a.hist)), g;
    },
    toJSON(a) {
      const g = {};
      return a.hist !== void 0 && (g.hist = a.hist ? r.HistoricalInfo.toJSON(a.hist) : void 0), g;
    },
    fromPartial(a) {
      const g = A();
      return a.hist !== void 0 && a.hist !== null && (g.hist = r.HistoricalInfo.fromPartial(a.hist)), g;
    }
  };
  function R() {
    return {};
  }
  e.QueryPoolRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryPoolRequest",
    encode(a, g = t.BinaryWriter.create()) {
      return g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = R();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      return R();
    },
    toJSON(a) {
      return {};
    },
    fromPartial(a) {
      return R();
    }
  };
  function v() {
    return {
      pool: r.Pool.fromPartial({})
    };
  }
  e.QueryPoolResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryPoolResponse",
    encode(a, g = t.BinaryWriter.create()) {
      return a.pool !== void 0 && r.Pool.encode(a.pool, g.uint32(10).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = v();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.pool = r.Pool.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = v();
      return (0, i.isSet)(a.pool) && (g.pool = r.Pool.fromJSON(a.pool)), g;
    },
    toJSON(a) {
      const g = {};
      return a.pool !== void 0 && (g.pool = a.pool ? r.Pool.toJSON(a.pool) : void 0), g;
    },
    fromPartial(a) {
      const g = v();
      return a.pool !== void 0 && a.pool !== null && (g.pool = r.Pool.fromPartial(a.pool)), g;
    }
  };
  function D() {
    return {};
  }
  e.QueryParamsRequest = {
    typeUrl: "/cosmos.staking.v1beta1.QueryParamsRequest",
    encode(a, g = t.BinaryWriter.create()) {
      return g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = D();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      return D();
    },
    toJSON(a) {
      return {};
    },
    fromPartial(a) {
      return D();
    }
  };
  function W() {
    return {
      params: r.Params.fromPartial({})
    };
  }
  e.QueryParamsResponse = {
    typeUrl: "/cosmos.staking.v1beta1.QueryParamsResponse",
    encode(a, g = t.BinaryWriter.create()) {
      return a.params !== void 0 && r.Params.encode(a.params, g.uint32(10).fork()).ldelim(), g;
    },
    decode(a, g) {
      const m = a instanceof t.BinaryReader ? a : new t.BinaryReader(a);
      let S = g === void 0 ? m.len : m.pos + g;
      const O = W();
      for (; m.pos < S; ) {
        const Q = m.uint32();
        switch (Q >>> 3) {
          case 1:
            O.params = r.Params.decode(m, m.uint32());
            break;
          default:
            m.skipType(Q & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(a) {
      const g = W();
      return (0, i.isSet)(a.params) && (g.params = r.Params.fromJSON(a.params)), g;
    },
    toJSON(a) {
      const g = {};
      return a.params !== void 0 && (g.params = a.params ? r.Params.toJSON(a.params) : void 0), g;
    },
    fromPartial(a) {
      const g = W();
      return a.params !== void 0 && a.params !== null && (g.params = r.Params.fromPartial(a.params)), g;
    }
  };
  class H {
    constructor(g) {
      this.rpc = g, this.Validators = this.Validators.bind(this), this.Validator = this.Validator.bind(this), this.ValidatorDelegations = this.ValidatorDelegations.bind(this), this.ValidatorUnbondingDelegations = this.ValidatorUnbondingDelegations.bind(this), this.Delegation = this.Delegation.bind(this), this.UnbondingDelegation = this.UnbondingDelegation.bind(this), this.DelegatorDelegations = this.DelegatorDelegations.bind(this), this.DelegatorUnbondingDelegations = this.DelegatorUnbondingDelegations.bind(this), this.Redelegations = this.Redelegations.bind(this), this.DelegatorValidators = this.DelegatorValidators.bind(this), this.DelegatorValidator = this.DelegatorValidator.bind(this), this.HistoricalInfo = this.HistoricalInfo.bind(this), this.Pool = this.Pool.bind(this), this.Params = this.Params.bind(this);
    }
    Validators(g) {
      const m = e.QueryValidatorsRequest.encode(g).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Validators", m).then((O) => e.QueryValidatorsResponse.decode(new t.BinaryReader(O)));
    }
    Validator(g) {
      const m = e.QueryValidatorRequest.encode(g).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Validator", m).then((O) => e.QueryValidatorResponse.decode(new t.BinaryReader(O)));
    }
    ValidatorDelegations(g) {
      const m = e.QueryValidatorDelegationsRequest.encode(g).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorDelegations", m).then((O) => e.QueryValidatorDelegationsResponse.decode(new t.BinaryReader(O)));
    }
    ValidatorUnbondingDelegations(g) {
      const m = e.QueryValidatorUnbondingDelegationsRequest.encode(g).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorUnbondingDelegations", m).then((O) => e.QueryValidatorUnbondingDelegationsResponse.decode(new t.BinaryReader(O)));
    }
    Delegation(g) {
      const m = e.QueryDelegationRequest.encode(g).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Delegation", m).then((O) => e.QueryDelegationResponse.decode(new t.BinaryReader(O)));
    }
    UnbondingDelegation(g) {
      const m = e.QueryUnbondingDelegationRequest.encode(g).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "UnbondingDelegation", m).then((O) => e.QueryUnbondingDelegationResponse.decode(new t.BinaryReader(O)));
    }
    DelegatorDelegations(g) {
      const m = e.QueryDelegatorDelegationsRequest.encode(g).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorDelegations", m).then((O) => e.QueryDelegatorDelegationsResponse.decode(new t.BinaryReader(O)));
    }
    DelegatorUnbondingDelegations(g) {
      const m = e.QueryDelegatorUnbondingDelegationsRequest.encode(g).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorUnbondingDelegations", m).then((O) => e.QueryDelegatorUnbondingDelegationsResponse.decode(new t.BinaryReader(O)));
    }
    Redelegations(g) {
      const m = e.QueryRedelegationsRequest.encode(g).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Redelegations", m).then((O) => e.QueryRedelegationsResponse.decode(new t.BinaryReader(O)));
    }
    DelegatorValidators(g) {
      const m = e.QueryDelegatorValidatorsRequest.encode(g).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidators", m).then((O) => e.QueryDelegatorValidatorsResponse.decode(new t.BinaryReader(O)));
    }
    DelegatorValidator(g) {
      const m = e.QueryDelegatorValidatorRequest.encode(g).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidator", m).then((O) => e.QueryDelegatorValidatorResponse.decode(new t.BinaryReader(O)));
    }
    HistoricalInfo(g) {
      const m = e.QueryHistoricalInfoRequest.encode(g).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "HistoricalInfo", m).then((O) => e.QueryHistoricalInfoResponse.decode(new t.BinaryReader(O)));
    }
    Pool(g = {}) {
      const m = e.QueryPoolRequest.encode(g).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Pool", m).then((O) => e.QueryPoolResponse.decode(new t.BinaryReader(O)));
    }
    Params(g = {}) {
      const m = e.QueryParamsRequest.encode(g).finish();
      return this.rpc.request("cosmos.staking.v1beta1.Query", "Params", m).then((O) => e.QueryParamsResponse.decode(new t.BinaryReader(O)));
    }
  }
  e.QueryClientImpl = H;
})(vl);
Object.defineProperty(wo, "__esModule", { value: !0 });
wo.setupStakingExtension = void 0;
const og = vl, et = Ge;
function ag(e) {
  const n = (0, et.createProtobufRpcClient)(e), r = new og.QueryClientImpl(n);
  return {
    staking: {
      delegation: async (t, i) => await r.Delegation({
        delegatorAddr: t,
        validatorAddr: i
      }),
      delegatorDelegations: async (t, i) => await r.DelegatorDelegations({
        delegatorAddr: t,
        pagination: (0, et.createPagination)(i)
      }),
      delegatorUnbondingDelegations: async (t, i) => await r.DelegatorUnbondingDelegations({
        delegatorAddr: t,
        pagination: (0, et.createPagination)(i)
      }),
      delegatorValidator: async (t, i) => await r.DelegatorValidator({
        delegatorAddr: t,
        validatorAddr: i
      }),
      delegatorValidators: async (t, i) => await r.DelegatorValidators({
        delegatorAddr: t,
        pagination: (0, et.createPagination)(i)
      }),
      historicalInfo: async (t) => await r.HistoricalInfo({
        height: BigInt(t)
      }),
      params: async () => await r.Params({}),
      pool: async () => await r.Pool({}),
      redelegations: async (t, i, f, k) => await r.Redelegations({
        delegatorAddr: t,
        srcValidatorAddr: i,
        dstValidatorAddr: f,
        pagination: (0, et.createPagination)(k)
      }),
      unbondingDelegation: async (t, i) => await r.UnbondingDelegation({
        delegatorAddr: t,
        validatorAddr: i
      }),
      validator: async (t) => await r.Validator({ validatorAddr: t }),
      validatorDelegations: async (t, i) => await r.ValidatorDelegations({
        validatorAddr: t,
        pagination: (0, et.createPagination)(i)
      }),
      validators: async (t, i) => await r.Validators({
        status: t,
        pagination: (0, et.createPagination)(i)
      }),
      validatorUnbondingDelegations: async (t, i) => await r.ValidatorUnbondingDelegations({
        validatorAddr: t,
        pagination: (0, et.createPagination)(i)
      })
    }
  };
}
wo.setupStakingExtension = ag;
var _o = {}, Rl = {}, Od = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.SearchTxsResult = e.TxMsgData = e.MsgData = e.SimulationResponse = e.Result = e.GasInfo = e.Attribute = e.StringEvent = e.ABCIMessageLog = e.TxResponse = e.protobufPackage = void 0;
  const n = Be, r = Bd, t = re, i = ie;
  e.protobufPackage = "cosmos.base.abci.v1beta1";
  function f() {
    return {
      height: BigInt(0),
      txhash: "",
      codespace: "",
      code: 0,
      data: "",
      rawLog: "",
      logs: [],
      info: "",
      gasWanted: BigInt(0),
      gasUsed: BigInt(0),
      tx: void 0,
      timestamp: "",
      events: []
    };
  }
  e.TxResponse = {
    typeUrl: "/cosmos.base.abci.v1beta1.TxResponse",
    encode(c, l = t.BinaryWriter.create()) {
      c.height !== BigInt(0) && l.uint32(8).int64(c.height), c.txhash !== "" && l.uint32(18).string(c.txhash), c.codespace !== "" && l.uint32(26).string(c.codespace), c.code !== 0 && l.uint32(32).uint32(c.code), c.data !== "" && l.uint32(42).string(c.data), c.rawLog !== "" && l.uint32(50).string(c.rawLog);
      for (const y of c.logs)
        e.ABCIMessageLog.encode(y, l.uint32(58).fork()).ldelim();
      c.info !== "" && l.uint32(66).string(c.info), c.gasWanted !== BigInt(0) && l.uint32(72).int64(c.gasWanted), c.gasUsed !== BigInt(0) && l.uint32(80).int64(c.gasUsed), c.tx !== void 0 && n.Any.encode(c.tx, l.uint32(90).fork()).ldelim(), c.timestamp !== "" && l.uint32(98).string(c.timestamp);
      for (const y of c.events)
        r.Event.encode(y, l.uint32(106).fork()).ldelim();
      return l;
    },
    decode(c, l) {
      const y = c instanceof t.BinaryReader ? c : new t.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = f();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.height = y.int64();
            break;
          case 2:
            J.txhash = y.string();
            break;
          case 3:
            J.codespace = y.string();
            break;
          case 4:
            J.code = y.uint32();
            break;
          case 5:
            J.data = y.string();
            break;
          case 6:
            J.rawLog = y.string();
            break;
          case 7:
            J.logs.push(e.ABCIMessageLog.decode(y, y.uint32()));
            break;
          case 8:
            J.info = y.string();
            break;
          case 9:
            J.gasWanted = y.int64();
            break;
          case 10:
            J.gasUsed = y.int64();
            break;
          case 11:
            J.tx = n.Any.decode(y, y.uint32());
            break;
          case 12:
            J.timestamp = y.string();
            break;
          case 13:
            J.events.push(r.Event.decode(y, y.uint32()));
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = f();
      return (0, i.isSet)(c.height) && (l.height = BigInt(c.height.toString())), (0, i.isSet)(c.txhash) && (l.txhash = String(c.txhash)), (0, i.isSet)(c.codespace) && (l.codespace = String(c.codespace)), (0, i.isSet)(c.code) && (l.code = Number(c.code)), (0, i.isSet)(c.data) && (l.data = String(c.data)), (0, i.isSet)(c.rawLog) && (l.rawLog = String(c.rawLog)), Array.isArray(c == null ? void 0 : c.logs) && (l.logs = c.logs.map((y) => e.ABCIMessageLog.fromJSON(y))), (0, i.isSet)(c.info) && (l.info = String(c.info)), (0, i.isSet)(c.gasWanted) && (l.gasWanted = BigInt(c.gasWanted.toString())), (0, i.isSet)(c.gasUsed) && (l.gasUsed = BigInt(c.gasUsed.toString())), (0, i.isSet)(c.tx) && (l.tx = n.Any.fromJSON(c.tx)), (0, i.isSet)(c.timestamp) && (l.timestamp = String(c.timestamp)), Array.isArray(c == null ? void 0 : c.events) && (l.events = c.events.map((y) => r.Event.fromJSON(y))), l;
    },
    toJSON(c) {
      const l = {};
      return c.height !== void 0 && (l.height = (c.height || BigInt(0)).toString()), c.txhash !== void 0 && (l.txhash = c.txhash), c.codespace !== void 0 && (l.codespace = c.codespace), c.code !== void 0 && (l.code = Math.round(c.code)), c.data !== void 0 && (l.data = c.data), c.rawLog !== void 0 && (l.rawLog = c.rawLog), c.logs ? l.logs = c.logs.map((y) => y ? e.ABCIMessageLog.toJSON(y) : void 0) : l.logs = [], c.info !== void 0 && (l.info = c.info), c.gasWanted !== void 0 && (l.gasWanted = (c.gasWanted || BigInt(0)).toString()), c.gasUsed !== void 0 && (l.gasUsed = (c.gasUsed || BigInt(0)).toString()), c.tx !== void 0 && (l.tx = c.tx ? n.Any.toJSON(c.tx) : void 0), c.timestamp !== void 0 && (l.timestamp = c.timestamp), c.events ? l.events = c.events.map((y) => y ? r.Event.toJSON(y) : void 0) : l.events = [], l;
    },
    fromPartial(c) {
      var y, E;
      const l = f();
      return c.height !== void 0 && c.height !== null && (l.height = BigInt(c.height.toString())), l.txhash = c.txhash ?? "", l.codespace = c.codespace ?? "", l.code = c.code ?? 0, l.data = c.data ?? "", l.rawLog = c.rawLog ?? "", l.logs = ((y = c.logs) == null ? void 0 : y.map((J) => e.ABCIMessageLog.fromPartial(J))) || [], l.info = c.info ?? "", c.gasWanted !== void 0 && c.gasWanted !== null && (l.gasWanted = BigInt(c.gasWanted.toString())), c.gasUsed !== void 0 && c.gasUsed !== null && (l.gasUsed = BigInt(c.gasUsed.toString())), c.tx !== void 0 && c.tx !== null && (l.tx = n.Any.fromPartial(c.tx)), l.timestamp = c.timestamp ?? "", l.events = ((E = c.events) == null ? void 0 : E.map((J) => r.Event.fromPartial(J))) || [], l;
    }
  };
  function k() {
    return {
      msgIndex: 0,
      log: "",
      events: []
    };
  }
  e.ABCIMessageLog = {
    typeUrl: "/cosmos.base.abci.v1beta1.ABCIMessageLog",
    encode(c, l = t.BinaryWriter.create()) {
      c.msgIndex !== 0 && l.uint32(8).uint32(c.msgIndex), c.log !== "" && l.uint32(18).string(c.log);
      for (const y of c.events)
        e.StringEvent.encode(y, l.uint32(26).fork()).ldelim();
      return l;
    },
    decode(c, l) {
      const y = c instanceof t.BinaryReader ? c : new t.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = k();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.msgIndex = y.uint32();
            break;
          case 2:
            J.log = y.string();
            break;
          case 3:
            J.events.push(e.StringEvent.decode(y, y.uint32()));
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = k();
      return (0, i.isSet)(c.msgIndex) && (l.msgIndex = Number(c.msgIndex)), (0, i.isSet)(c.log) && (l.log = String(c.log)), Array.isArray(c == null ? void 0 : c.events) && (l.events = c.events.map((y) => e.StringEvent.fromJSON(y))), l;
    },
    toJSON(c) {
      const l = {};
      return c.msgIndex !== void 0 && (l.msgIndex = Math.round(c.msgIndex)), c.log !== void 0 && (l.log = c.log), c.events ? l.events = c.events.map((y) => y ? e.StringEvent.toJSON(y) : void 0) : l.events = [], l;
    },
    fromPartial(c) {
      var y;
      const l = k();
      return l.msgIndex = c.msgIndex ?? 0, l.log = c.log ?? "", l.events = ((y = c.events) == null ? void 0 : y.map((E) => e.StringEvent.fromPartial(E))) || [], l;
    }
  };
  function C() {
    return {
      type: "",
      attributes: []
    };
  }
  e.StringEvent = {
    typeUrl: "/cosmos.base.abci.v1beta1.StringEvent",
    encode(c, l = t.BinaryWriter.create()) {
      c.type !== "" && l.uint32(10).string(c.type);
      for (const y of c.attributes)
        e.Attribute.encode(y, l.uint32(18).fork()).ldelim();
      return l;
    },
    decode(c, l) {
      const y = c instanceof t.BinaryReader ? c : new t.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = C();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.type = y.string();
            break;
          case 2:
            J.attributes.push(e.Attribute.decode(y, y.uint32()));
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = C();
      return (0, i.isSet)(c.type) && (l.type = String(c.type)), Array.isArray(c == null ? void 0 : c.attributes) && (l.attributes = c.attributes.map((y) => e.Attribute.fromJSON(y))), l;
    },
    toJSON(c) {
      const l = {};
      return c.type !== void 0 && (l.type = c.type), c.attributes ? l.attributes = c.attributes.map((y) => y ? e.Attribute.toJSON(y) : void 0) : l.attributes = [], l;
    },
    fromPartial(c) {
      var y;
      const l = C();
      return l.type = c.type ?? "", l.attributes = ((y = c.attributes) == null ? void 0 : y.map((E) => e.Attribute.fromPartial(E))) || [], l;
    }
  };
  function T() {
    return {
      key: "",
      value: ""
    };
  }
  e.Attribute = {
    typeUrl: "/cosmos.base.abci.v1beta1.Attribute",
    encode(c, l = t.BinaryWriter.create()) {
      return c.key !== "" && l.uint32(10).string(c.key), c.value !== "" && l.uint32(18).string(c.value), l;
    },
    decode(c, l) {
      const y = c instanceof t.BinaryReader ? c : new t.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = T();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.key = y.string();
            break;
          case 2:
            J.value = y.string();
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = T();
      return (0, i.isSet)(c.key) && (l.key = String(c.key)), (0, i.isSet)(c.value) && (l.value = String(c.value)), l;
    },
    toJSON(c) {
      const l = {};
      return c.key !== void 0 && (l.key = c.key), c.value !== void 0 && (l.value = c.value), l;
    },
    fromPartial(c) {
      const l = T();
      return l.key = c.key ?? "", l.value = c.value ?? "", l;
    }
  };
  function U() {
    return {
      gasWanted: BigInt(0),
      gasUsed: BigInt(0)
    };
  }
  e.GasInfo = {
    typeUrl: "/cosmos.base.abci.v1beta1.GasInfo",
    encode(c, l = t.BinaryWriter.create()) {
      return c.gasWanted !== BigInt(0) && l.uint32(8).uint64(c.gasWanted), c.gasUsed !== BigInt(0) && l.uint32(16).uint64(c.gasUsed), l;
    },
    decode(c, l) {
      const y = c instanceof t.BinaryReader ? c : new t.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = U();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.gasWanted = y.uint64();
            break;
          case 2:
            J.gasUsed = y.uint64();
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = U();
      return (0, i.isSet)(c.gasWanted) && (l.gasWanted = BigInt(c.gasWanted.toString())), (0, i.isSet)(c.gasUsed) && (l.gasUsed = BigInt(c.gasUsed.toString())), l;
    },
    toJSON(c) {
      const l = {};
      return c.gasWanted !== void 0 && (l.gasWanted = (c.gasWanted || BigInt(0)).toString()), c.gasUsed !== void 0 && (l.gasUsed = (c.gasUsed || BigInt(0)).toString()), l;
    },
    fromPartial(c) {
      const l = U();
      return c.gasWanted !== void 0 && c.gasWanted !== null && (l.gasWanted = BigInt(c.gasWanted.toString())), c.gasUsed !== void 0 && c.gasUsed !== null && (l.gasUsed = BigInt(c.gasUsed.toString())), l;
    }
  };
  function w() {
    return {
      data: new Uint8Array(),
      log: "",
      events: [],
      msgResponses: []
    };
  }
  e.Result = {
    typeUrl: "/cosmos.base.abci.v1beta1.Result",
    encode(c, l = t.BinaryWriter.create()) {
      c.data.length !== 0 && l.uint32(10).bytes(c.data), c.log !== "" && l.uint32(18).string(c.log);
      for (const y of c.events)
        r.Event.encode(y, l.uint32(26).fork()).ldelim();
      for (const y of c.msgResponses)
        n.Any.encode(y, l.uint32(34).fork()).ldelim();
      return l;
    },
    decode(c, l) {
      const y = c instanceof t.BinaryReader ? c : new t.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = w();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.data = y.bytes();
            break;
          case 2:
            J.log = y.string();
            break;
          case 3:
            J.events.push(r.Event.decode(y, y.uint32()));
            break;
          case 4:
            J.msgResponses.push(n.Any.decode(y, y.uint32()));
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = w();
      return (0, i.isSet)(c.data) && (l.data = (0, i.bytesFromBase64)(c.data)), (0, i.isSet)(c.log) && (l.log = String(c.log)), Array.isArray(c == null ? void 0 : c.events) && (l.events = c.events.map((y) => r.Event.fromJSON(y))), Array.isArray(c == null ? void 0 : c.msgResponses) && (l.msgResponses = c.msgResponses.map((y) => n.Any.fromJSON(y))), l;
    },
    toJSON(c) {
      const l = {};
      return c.data !== void 0 && (l.data = (0, i.base64FromBytes)(c.data !== void 0 ? c.data : new Uint8Array())), c.log !== void 0 && (l.log = c.log), c.events ? l.events = c.events.map((y) => y ? r.Event.toJSON(y) : void 0) : l.events = [], c.msgResponses ? l.msgResponses = c.msgResponses.map((y) => y ? n.Any.toJSON(y) : void 0) : l.msgResponses = [], l;
    },
    fromPartial(c) {
      var y, E;
      const l = w();
      return l.data = c.data ?? new Uint8Array(), l.log = c.log ?? "", l.events = ((y = c.events) == null ? void 0 : y.map((J) => r.Event.fromPartial(J))) || [], l.msgResponses = ((E = c.msgResponses) == null ? void 0 : E.map((J) => n.Any.fromPartial(J))) || [], l;
    }
  };
  function N() {
    return {
      gasInfo: e.GasInfo.fromPartial({}),
      result: void 0
    };
  }
  e.SimulationResponse = {
    typeUrl: "/cosmos.base.abci.v1beta1.SimulationResponse",
    encode(c, l = t.BinaryWriter.create()) {
      return c.gasInfo !== void 0 && e.GasInfo.encode(c.gasInfo, l.uint32(10).fork()).ldelim(), c.result !== void 0 && e.Result.encode(c.result, l.uint32(18).fork()).ldelim(), l;
    },
    decode(c, l) {
      const y = c instanceof t.BinaryReader ? c : new t.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = N();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.gasInfo = e.GasInfo.decode(y, y.uint32());
            break;
          case 2:
            J.result = e.Result.decode(y, y.uint32());
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = N();
      return (0, i.isSet)(c.gasInfo) && (l.gasInfo = e.GasInfo.fromJSON(c.gasInfo)), (0, i.isSet)(c.result) && (l.result = e.Result.fromJSON(c.result)), l;
    },
    toJSON(c) {
      const l = {};
      return c.gasInfo !== void 0 && (l.gasInfo = c.gasInfo ? e.GasInfo.toJSON(c.gasInfo) : void 0), c.result !== void 0 && (l.result = c.result ? e.Result.toJSON(c.result) : void 0), l;
    },
    fromPartial(c) {
      const l = N();
      return c.gasInfo !== void 0 && c.gasInfo !== null && (l.gasInfo = e.GasInfo.fromPartial(c.gasInfo)), c.result !== void 0 && c.result !== null && (l.result = e.Result.fromPartial(c.result)), l;
    }
  };
  function h() {
    return {
      msgType: "",
      data: new Uint8Array()
    };
  }
  e.MsgData = {
    typeUrl: "/cosmos.base.abci.v1beta1.MsgData",
    encode(c, l = t.BinaryWriter.create()) {
      return c.msgType !== "" && l.uint32(10).string(c.msgType), c.data.length !== 0 && l.uint32(18).bytes(c.data), l;
    },
    decode(c, l) {
      const y = c instanceof t.BinaryReader ? c : new t.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = h();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.msgType = y.string();
            break;
          case 2:
            J.data = y.bytes();
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = h();
      return (0, i.isSet)(c.msgType) && (l.msgType = String(c.msgType)), (0, i.isSet)(c.data) && (l.data = (0, i.bytesFromBase64)(c.data)), l;
    },
    toJSON(c) {
      const l = {};
      return c.msgType !== void 0 && (l.msgType = c.msgType), c.data !== void 0 && (l.data = (0, i.base64FromBytes)(c.data !== void 0 ? c.data : new Uint8Array())), l;
    },
    fromPartial(c) {
      const l = h();
      return l.msgType = c.msgType ?? "", l.data = c.data ?? new Uint8Array(), l;
    }
  };
  function P() {
    return {
      data: [],
      msgResponses: []
    };
  }
  e.TxMsgData = {
    typeUrl: "/cosmos.base.abci.v1beta1.TxMsgData",
    encode(c, l = t.BinaryWriter.create()) {
      for (const y of c.data)
        e.MsgData.encode(y, l.uint32(10).fork()).ldelim();
      for (const y of c.msgResponses)
        n.Any.encode(y, l.uint32(18).fork()).ldelim();
      return l;
    },
    decode(c, l) {
      const y = c instanceof t.BinaryReader ? c : new t.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = P();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.data.push(e.MsgData.decode(y, y.uint32()));
            break;
          case 2:
            J.msgResponses.push(n.Any.decode(y, y.uint32()));
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = P();
      return Array.isArray(c == null ? void 0 : c.data) && (l.data = c.data.map((y) => e.MsgData.fromJSON(y))), Array.isArray(c == null ? void 0 : c.msgResponses) && (l.msgResponses = c.msgResponses.map((y) => n.Any.fromJSON(y))), l;
    },
    toJSON(c) {
      const l = {};
      return c.data ? l.data = c.data.map((y) => y ? e.MsgData.toJSON(y) : void 0) : l.data = [], c.msgResponses ? l.msgResponses = c.msgResponses.map((y) => y ? n.Any.toJSON(y) : void 0) : l.msgResponses = [], l;
    },
    fromPartial(c) {
      var y, E;
      const l = P();
      return l.data = ((y = c.data) == null ? void 0 : y.map((J) => e.MsgData.fromPartial(J))) || [], l.msgResponses = ((E = c.msgResponses) == null ? void 0 : E.map((J) => n.Any.fromPartial(J))) || [], l;
    }
  };
  function b() {
    return {
      totalCount: BigInt(0),
      count: BigInt(0),
      pageNumber: BigInt(0),
      pageTotal: BigInt(0),
      limit: BigInt(0),
      txs: []
    };
  }
  e.SearchTxsResult = {
    typeUrl: "/cosmos.base.abci.v1beta1.SearchTxsResult",
    encode(c, l = t.BinaryWriter.create()) {
      c.totalCount !== BigInt(0) && l.uint32(8).uint64(c.totalCount), c.count !== BigInt(0) && l.uint32(16).uint64(c.count), c.pageNumber !== BigInt(0) && l.uint32(24).uint64(c.pageNumber), c.pageTotal !== BigInt(0) && l.uint32(32).uint64(c.pageTotal), c.limit !== BigInt(0) && l.uint32(40).uint64(c.limit);
      for (const y of c.txs)
        e.TxResponse.encode(y, l.uint32(50).fork()).ldelim();
      return l;
    },
    decode(c, l) {
      const y = c instanceof t.BinaryReader ? c : new t.BinaryReader(c);
      let E = l === void 0 ? y.len : y.pos + l;
      const J = b();
      for (; y.pos < E; ) {
        const _ = y.uint32();
        switch (_ >>> 3) {
          case 1:
            J.totalCount = y.uint64();
            break;
          case 2:
            J.count = y.uint64();
            break;
          case 3:
            J.pageNumber = y.uint64();
            break;
          case 4:
            J.pageTotal = y.uint64();
            break;
          case 5:
            J.limit = y.uint64();
            break;
          case 6:
            J.txs.push(e.TxResponse.decode(y, y.uint32()));
            break;
          default:
            y.skipType(_ & 7);
            break;
        }
      }
      return J;
    },
    fromJSON(c) {
      const l = b();
      return (0, i.isSet)(c.totalCount) && (l.totalCount = BigInt(c.totalCount.toString())), (0, i.isSet)(c.count) && (l.count = BigInt(c.count.toString())), (0, i.isSet)(c.pageNumber) && (l.pageNumber = BigInt(c.pageNumber.toString())), (0, i.isSet)(c.pageTotal) && (l.pageTotal = BigInt(c.pageTotal.toString())), (0, i.isSet)(c.limit) && (l.limit = BigInt(c.limit.toString())), Array.isArray(c == null ? void 0 : c.txs) && (l.txs = c.txs.map((y) => e.TxResponse.fromJSON(y))), l;
    },
    toJSON(c) {
      const l = {};
      return c.totalCount !== void 0 && (l.totalCount = (c.totalCount || BigInt(0)).toString()), c.count !== void 0 && (l.count = (c.count || BigInt(0)).toString()), c.pageNumber !== void 0 && (l.pageNumber = (c.pageNumber || BigInt(0)).toString()), c.pageTotal !== void 0 && (l.pageTotal = (c.pageTotal || BigInt(0)).toString()), c.limit !== void 0 && (l.limit = (c.limit || BigInt(0)).toString()), c.txs ? l.txs = c.txs.map((y) => y ? e.TxResponse.toJSON(y) : void 0) : l.txs = [], l;
    },
    fromPartial(c) {
      var y;
      const l = b();
      return c.totalCount !== void 0 && c.totalCount !== null && (l.totalCount = BigInt(c.totalCount.toString())), c.count !== void 0 && c.count !== null && (l.count = BigInt(c.count.toString())), c.pageNumber !== void 0 && c.pageNumber !== null && (l.pageNumber = BigInt(c.pageNumber.toString())), c.pageTotal !== void 0 && c.pageTotal !== null && (l.pageTotal = BigInt(c.pageTotal.toString())), c.limit !== void 0 && c.limit !== null && (l.limit = BigInt(c.limit.toString())), l.txs = ((y = c.txs) == null ? void 0 : y.map((E) => e.TxResponse.fromPartial(E))) || [], l;
    }
  };
})(Od);
var sr = {}, Bl = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.EvidenceList = e.LightClientAttackEvidence = e.DuplicateVoteEvidence = e.Evidence = e.protobufPackage = void 0;
  const n = _t, r = _e, t = To, i = re, f = ie;
  e.protobufPackage = "tendermint.types";
  function k() {
    return {
      duplicateVoteEvidence: void 0,
      lightClientAttackEvidence: void 0
    };
  }
  e.Evidence = {
    typeUrl: "/tendermint.types.Evidence",
    encode(w, N = i.BinaryWriter.create()) {
      return w.duplicateVoteEvidence !== void 0 && e.DuplicateVoteEvidence.encode(w.duplicateVoteEvidence, N.uint32(10).fork()).ldelim(), w.lightClientAttackEvidence !== void 0 && e.LightClientAttackEvidence.encode(w.lightClientAttackEvidence, N.uint32(18).fork()).ldelim(), N;
    },
    decode(w, N) {
      const h = w instanceof i.BinaryReader ? w : new i.BinaryReader(w);
      let P = N === void 0 ? h.len : h.pos + N;
      const b = k();
      for (; h.pos < P; ) {
        const c = h.uint32();
        switch (c >>> 3) {
          case 1:
            b.duplicateVoteEvidence = e.DuplicateVoteEvidence.decode(h, h.uint32());
            break;
          case 2:
            b.lightClientAttackEvidence = e.LightClientAttackEvidence.decode(h, h.uint32());
            break;
          default:
            h.skipType(c & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(w) {
      const N = k();
      return (0, f.isSet)(w.duplicateVoteEvidence) && (N.duplicateVoteEvidence = e.DuplicateVoteEvidence.fromJSON(w.duplicateVoteEvidence)), (0, f.isSet)(w.lightClientAttackEvidence) && (N.lightClientAttackEvidence = e.LightClientAttackEvidence.fromJSON(w.lightClientAttackEvidence)), N;
    },
    toJSON(w) {
      const N = {};
      return w.duplicateVoteEvidence !== void 0 && (N.duplicateVoteEvidence = w.duplicateVoteEvidence ? e.DuplicateVoteEvidence.toJSON(w.duplicateVoteEvidence) : void 0), w.lightClientAttackEvidence !== void 0 && (N.lightClientAttackEvidence = w.lightClientAttackEvidence ? e.LightClientAttackEvidence.toJSON(w.lightClientAttackEvidence) : void 0), N;
    },
    fromPartial(w) {
      const N = k();
      return w.duplicateVoteEvidence !== void 0 && w.duplicateVoteEvidence !== null && (N.duplicateVoteEvidence = e.DuplicateVoteEvidence.fromPartial(w.duplicateVoteEvidence)), w.lightClientAttackEvidence !== void 0 && w.lightClientAttackEvidence !== null && (N.lightClientAttackEvidence = e.LightClientAttackEvidence.fromPartial(w.lightClientAttackEvidence)), N;
    }
  };
  function C() {
    return {
      voteA: void 0,
      voteB: void 0,
      totalVotingPower: BigInt(0),
      validatorPower: BigInt(0),
      timestamp: r.Timestamp.fromPartial({})
    };
  }
  e.DuplicateVoteEvidence = {
    typeUrl: "/tendermint.types.DuplicateVoteEvidence",
    encode(w, N = i.BinaryWriter.create()) {
      return w.voteA !== void 0 && n.Vote.encode(w.voteA, N.uint32(10).fork()).ldelim(), w.voteB !== void 0 && n.Vote.encode(w.voteB, N.uint32(18).fork()).ldelim(), w.totalVotingPower !== BigInt(0) && N.uint32(24).int64(w.totalVotingPower), w.validatorPower !== BigInt(0) && N.uint32(32).int64(w.validatorPower), w.timestamp !== void 0 && r.Timestamp.encode(w.timestamp, N.uint32(42).fork()).ldelim(), N;
    },
    decode(w, N) {
      const h = w instanceof i.BinaryReader ? w : new i.BinaryReader(w);
      let P = N === void 0 ? h.len : h.pos + N;
      const b = C();
      for (; h.pos < P; ) {
        const c = h.uint32();
        switch (c >>> 3) {
          case 1:
            b.voteA = n.Vote.decode(h, h.uint32());
            break;
          case 2:
            b.voteB = n.Vote.decode(h, h.uint32());
            break;
          case 3:
            b.totalVotingPower = h.int64();
            break;
          case 4:
            b.validatorPower = h.int64();
            break;
          case 5:
            b.timestamp = r.Timestamp.decode(h, h.uint32());
            break;
          default:
            h.skipType(c & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(w) {
      const N = C();
      return (0, f.isSet)(w.voteA) && (N.voteA = n.Vote.fromJSON(w.voteA)), (0, f.isSet)(w.voteB) && (N.voteB = n.Vote.fromJSON(w.voteB)), (0, f.isSet)(w.totalVotingPower) && (N.totalVotingPower = BigInt(w.totalVotingPower.toString())), (0, f.isSet)(w.validatorPower) && (N.validatorPower = BigInt(w.validatorPower.toString())), (0, f.isSet)(w.timestamp) && (N.timestamp = (0, f.fromJsonTimestamp)(w.timestamp)), N;
    },
    toJSON(w) {
      const N = {};
      return w.voteA !== void 0 && (N.voteA = w.voteA ? n.Vote.toJSON(w.voteA) : void 0), w.voteB !== void 0 && (N.voteB = w.voteB ? n.Vote.toJSON(w.voteB) : void 0), w.totalVotingPower !== void 0 && (N.totalVotingPower = (w.totalVotingPower || BigInt(0)).toString()), w.validatorPower !== void 0 && (N.validatorPower = (w.validatorPower || BigInt(0)).toString()), w.timestamp !== void 0 && (N.timestamp = (0, f.fromTimestamp)(w.timestamp).toISOString()), N;
    },
    fromPartial(w) {
      const N = C();
      return w.voteA !== void 0 && w.voteA !== null && (N.voteA = n.Vote.fromPartial(w.voteA)), w.voteB !== void 0 && w.voteB !== null && (N.voteB = n.Vote.fromPartial(w.voteB)), w.totalVotingPower !== void 0 && w.totalVotingPower !== null && (N.totalVotingPower = BigInt(w.totalVotingPower.toString())), w.validatorPower !== void 0 && w.validatorPower !== null && (N.validatorPower = BigInt(w.validatorPower.toString())), w.timestamp !== void 0 && w.timestamp !== null && (N.timestamp = r.Timestamp.fromPartial(w.timestamp)), N;
    }
  };
  function T() {
    return {
      conflictingBlock: void 0,
      commonHeight: BigInt(0),
      byzantineValidators: [],
      totalVotingPower: BigInt(0),
      timestamp: r.Timestamp.fromPartial({})
    };
  }
  e.LightClientAttackEvidence = {
    typeUrl: "/tendermint.types.LightClientAttackEvidence",
    encode(w, N = i.BinaryWriter.create()) {
      w.conflictingBlock !== void 0 && n.LightBlock.encode(w.conflictingBlock, N.uint32(10).fork()).ldelim(), w.commonHeight !== BigInt(0) && N.uint32(16).int64(w.commonHeight);
      for (const h of w.byzantineValidators)
        t.Validator.encode(h, N.uint32(26).fork()).ldelim();
      return w.totalVotingPower !== BigInt(0) && N.uint32(32).int64(w.totalVotingPower), w.timestamp !== void 0 && r.Timestamp.encode(w.timestamp, N.uint32(42).fork()).ldelim(), N;
    },
    decode(w, N) {
      const h = w instanceof i.BinaryReader ? w : new i.BinaryReader(w);
      let P = N === void 0 ? h.len : h.pos + N;
      const b = T();
      for (; h.pos < P; ) {
        const c = h.uint32();
        switch (c >>> 3) {
          case 1:
            b.conflictingBlock = n.LightBlock.decode(h, h.uint32());
            break;
          case 2:
            b.commonHeight = h.int64();
            break;
          case 3:
            b.byzantineValidators.push(t.Validator.decode(h, h.uint32()));
            break;
          case 4:
            b.totalVotingPower = h.int64();
            break;
          case 5:
            b.timestamp = r.Timestamp.decode(h, h.uint32());
            break;
          default:
            h.skipType(c & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(w) {
      const N = T();
      return (0, f.isSet)(w.conflictingBlock) && (N.conflictingBlock = n.LightBlock.fromJSON(w.conflictingBlock)), (0, f.isSet)(w.commonHeight) && (N.commonHeight = BigInt(w.commonHeight.toString())), Array.isArray(w == null ? void 0 : w.byzantineValidators) && (N.byzantineValidators = w.byzantineValidators.map((h) => t.Validator.fromJSON(h))), (0, f.isSet)(w.totalVotingPower) && (N.totalVotingPower = BigInt(w.totalVotingPower.toString())), (0, f.isSet)(w.timestamp) && (N.timestamp = (0, f.fromJsonTimestamp)(w.timestamp)), N;
    },
    toJSON(w) {
      const N = {};
      return w.conflictingBlock !== void 0 && (N.conflictingBlock = w.conflictingBlock ? n.LightBlock.toJSON(w.conflictingBlock) : void 0), w.commonHeight !== void 0 && (N.commonHeight = (w.commonHeight || BigInt(0)).toString()), w.byzantineValidators ? N.byzantineValidators = w.byzantineValidators.map((h) => h ? t.Validator.toJSON(h) : void 0) : N.byzantineValidators = [], w.totalVotingPower !== void 0 && (N.totalVotingPower = (w.totalVotingPower || BigInt(0)).toString()), w.timestamp !== void 0 && (N.timestamp = (0, f.fromTimestamp)(w.timestamp).toISOString()), N;
    },
    fromPartial(w) {
      var h;
      const N = T();
      return w.conflictingBlock !== void 0 && w.conflictingBlock !== null && (N.conflictingBlock = n.LightBlock.fromPartial(w.conflictingBlock)), w.commonHeight !== void 0 && w.commonHeight !== null && (N.commonHeight = BigInt(w.commonHeight.toString())), N.byzantineValidators = ((h = w.byzantineValidators) == null ? void 0 : h.map((P) => t.Validator.fromPartial(P))) || [], w.totalVotingPower !== void 0 && w.totalVotingPower !== null && (N.totalVotingPower = BigInt(w.totalVotingPower.toString())), w.timestamp !== void 0 && w.timestamp !== null && (N.timestamp = r.Timestamp.fromPartial(w.timestamp)), N;
    }
  };
  function U() {
    return {
      evidence: []
    };
  }
  e.EvidenceList = {
    typeUrl: "/tendermint.types.EvidenceList",
    encode(w, N = i.BinaryWriter.create()) {
      for (const h of w.evidence)
        e.Evidence.encode(h, N.uint32(10).fork()).ldelim();
      return N;
    },
    decode(w, N) {
      const h = w instanceof i.BinaryReader ? w : new i.BinaryReader(w);
      let P = N === void 0 ? h.len : h.pos + N;
      const b = U();
      for (; h.pos < P; ) {
        const c = h.uint32();
        switch (c >>> 3) {
          case 1:
            b.evidence.push(e.Evidence.decode(h, h.uint32()));
            break;
          default:
            h.skipType(c & 7);
            break;
        }
      }
      return b;
    },
    fromJSON(w) {
      const N = U();
      return Array.isArray(w == null ? void 0 : w.evidence) && (N.evidence = w.evidence.map((h) => e.Evidence.fromJSON(h))), N;
    },
    toJSON(w) {
      const N = {};
      return w.evidence ? N.evidence = w.evidence.map((h) => h ? e.Evidence.toJSON(h) : void 0) : N.evidence = [], N;
    },
    fromPartial(w) {
      var h;
      const N = U();
      return N.evidence = ((h = w.evidence) == null ? void 0 : h.map((P) => e.Evidence.fromPartial(P))) || [], N;
    }
  };
})(Bl);
Object.defineProperty(sr, "__esModule", { value: !0 });
sr.Block = sr.protobufPackage = void 0;
const Ee = _t, Wt = Bl, Ps = re, Ri = ie;
sr.protobufPackage = "tendermint.types";
function vs() {
  return {
    header: Ee.Header.fromPartial({}),
    data: Ee.Data.fromPartial({}),
    evidence: Wt.EvidenceList.fromPartial({}),
    lastCommit: void 0
  };
}
sr.Block = {
  typeUrl: "/tendermint.types.Block",
  encode(e, n = Ps.BinaryWriter.create()) {
    return e.header !== void 0 && Ee.Header.encode(e.header, n.uint32(10).fork()).ldelim(), e.data !== void 0 && Ee.Data.encode(e.data, n.uint32(18).fork()).ldelim(), e.evidence !== void 0 && Wt.EvidenceList.encode(e.evidence, n.uint32(26).fork()).ldelim(), e.lastCommit !== void 0 && Ee.Commit.encode(e.lastCommit, n.uint32(34).fork()).ldelim(), n;
  },
  decode(e, n) {
    const r = e instanceof Ps.BinaryReader ? e : new Ps.BinaryReader(e);
    let t = n === void 0 ? r.len : r.pos + n;
    const i = vs();
    for (; r.pos < t; ) {
      const f = r.uint32();
      switch (f >>> 3) {
        case 1:
          i.header = Ee.Header.decode(r, r.uint32());
          break;
        case 2:
          i.data = Ee.Data.decode(r, r.uint32());
          break;
        case 3:
          i.evidence = Wt.EvidenceList.decode(r, r.uint32());
          break;
        case 4:
          i.lastCommit = Ee.Commit.decode(r, r.uint32());
          break;
        default:
          r.skipType(f & 7);
          break;
      }
    }
    return i;
  },
  fromJSON(e) {
    const n = vs();
    return (0, Ri.isSet)(e.header) && (n.header = Ee.Header.fromJSON(e.header)), (0, Ri.isSet)(e.data) && (n.data = Ee.Data.fromJSON(e.data)), (0, Ri.isSet)(e.evidence) && (n.evidence = Wt.EvidenceList.fromJSON(e.evidence)), (0, Ri.isSet)(e.lastCommit) && (n.lastCommit = Ee.Commit.fromJSON(e.lastCommit)), n;
  },
  toJSON(e) {
    const n = {};
    return e.header !== void 0 && (n.header = e.header ? Ee.Header.toJSON(e.header) : void 0), e.data !== void 0 && (n.data = e.data ? Ee.Data.toJSON(e.data) : void 0), e.evidence !== void 0 && (n.evidence = e.evidence ? Wt.EvidenceList.toJSON(e.evidence) : void 0), e.lastCommit !== void 0 && (n.lastCommit = e.lastCommit ? Ee.Commit.toJSON(e.lastCommit) : void 0), n;
  },
  fromPartial(e) {
    const n = vs();
    return e.header !== void 0 && e.header !== null && (n.header = Ee.Header.fromPartial(e.header)), e.data !== void 0 && e.data !== null && (n.data = Ee.Data.fromPartial(e.data)), e.evidence !== void 0 && e.evidence !== null && (n.evidence = Wt.EvidenceList.fromPartial(e.evidence)), e.lastCommit !== void 0 && e.lastCommit !== null && (n.lastCommit = Ee.Commit.fromPartial(e.lastCommit)), n;
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ServiceClientImpl = e.TxDecodeAminoResponse = e.TxDecodeAminoRequest = e.TxEncodeAminoResponse = e.TxEncodeAminoRequest = e.TxEncodeResponse = e.TxEncodeRequest = e.TxDecodeResponse = e.TxDecodeRequest = e.GetBlockWithTxsResponse = e.GetBlockWithTxsRequest = e.GetTxResponse = e.GetTxRequest = e.SimulateResponse = e.SimulateRequest = e.BroadcastTxResponse = e.BroadcastTxRequest = e.GetTxsEventResponse = e.GetTxsEventRequest = e.broadcastModeToJSON = e.broadcastModeFromJSON = e.BroadcastMode = e.orderByToJSON = e.orderByFromJSON = e.OrderBy = e.protobufPackage = void 0;
  const n = xr, r = Ae, t = Od, i = _t, f = sr, k = re, C = ie;
  e.protobufPackage = "cosmos.tx.v1beta1";
  var T;
  (function(H) {
    H[H.ORDER_BY_UNSPECIFIED = 0] = "ORDER_BY_UNSPECIFIED", H[H.ORDER_BY_ASC = 1] = "ORDER_BY_ASC", H[H.ORDER_BY_DESC = 2] = "ORDER_BY_DESC", H[H.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(T || (e.OrderBy = T = {}));
  function U(H) {
    switch (H) {
      case 0:
      case "ORDER_BY_UNSPECIFIED":
        return T.ORDER_BY_UNSPECIFIED;
      case 1:
      case "ORDER_BY_ASC":
        return T.ORDER_BY_ASC;
      case 2:
      case "ORDER_BY_DESC":
        return T.ORDER_BY_DESC;
      case -1:
      case "UNRECOGNIZED":
      default:
        return T.UNRECOGNIZED;
    }
  }
  e.orderByFromJSON = U;
  function w(H) {
    switch (H) {
      case T.ORDER_BY_UNSPECIFIED:
        return "ORDER_BY_UNSPECIFIED";
      case T.ORDER_BY_ASC:
        return "ORDER_BY_ASC";
      case T.ORDER_BY_DESC:
        return "ORDER_BY_DESC";
      case T.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.orderByToJSON = w;
  var N;
  (function(H) {
    H[H.BROADCAST_MODE_UNSPECIFIED = 0] = "BROADCAST_MODE_UNSPECIFIED", H[H.BROADCAST_MODE_BLOCK = 1] = "BROADCAST_MODE_BLOCK", H[H.BROADCAST_MODE_SYNC = 2] = "BROADCAST_MODE_SYNC", H[H.BROADCAST_MODE_ASYNC = 3] = "BROADCAST_MODE_ASYNC", H[H.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(N || (e.BroadcastMode = N = {}));
  function h(H) {
    switch (H) {
      case 0:
      case "BROADCAST_MODE_UNSPECIFIED":
        return N.BROADCAST_MODE_UNSPECIFIED;
      case 1:
      case "BROADCAST_MODE_BLOCK":
        return N.BROADCAST_MODE_BLOCK;
      case 2:
      case "BROADCAST_MODE_SYNC":
        return N.BROADCAST_MODE_SYNC;
      case 3:
      case "BROADCAST_MODE_ASYNC":
        return N.BROADCAST_MODE_ASYNC;
      case -1:
      case "UNRECOGNIZED":
      default:
        return N.UNRECOGNIZED;
    }
  }
  e.broadcastModeFromJSON = h;
  function P(H) {
    switch (H) {
      case N.BROADCAST_MODE_UNSPECIFIED:
        return "BROADCAST_MODE_UNSPECIFIED";
      case N.BROADCAST_MODE_BLOCK:
        return "BROADCAST_MODE_BLOCK";
      case N.BROADCAST_MODE_SYNC:
        return "BROADCAST_MODE_SYNC";
      case N.BROADCAST_MODE_ASYNC:
        return "BROADCAST_MODE_ASYNC";
      case N.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  e.broadcastModeToJSON = P;
  function b() {
    return {
      events: [],
      pagination: void 0,
      orderBy: 0,
      page: BigInt(0),
      limit: BigInt(0)
    };
  }
  e.GetTxsEventRequest = {
    typeUrl: "/cosmos.tx.v1beta1.GetTxsEventRequest",
    encode(H, a = k.BinaryWriter.create()) {
      for (const g of H.events)
        a.uint32(10).string(g);
      return H.pagination !== void 0 && r.PageRequest.encode(H.pagination, a.uint32(18).fork()).ldelim(), H.orderBy !== 0 && a.uint32(24).int32(H.orderBy), H.page !== BigInt(0) && a.uint32(32).uint64(H.page), H.limit !== BigInt(0) && a.uint32(40).uint64(H.limit), a;
    },
    decode(H, a) {
      const g = H instanceof k.BinaryReader ? H : new k.BinaryReader(H);
      let m = a === void 0 ? g.len : g.pos + a;
      const S = b();
      for (; g.pos < m; ) {
        const O = g.uint32();
        switch (O >>> 3) {
          case 1:
            S.events.push(g.string());
            break;
          case 2:
            S.pagination = r.PageRequest.decode(g, g.uint32());
            break;
          case 3:
            S.orderBy = g.int32();
            break;
          case 4:
            S.page = g.uint64();
            break;
          case 5:
            S.limit = g.uint64();
            break;
          default:
            g.skipType(O & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(H) {
      const a = b();
      return Array.isArray(H == null ? void 0 : H.events) && (a.events = H.events.map((g) => String(g))), (0, C.isSet)(H.pagination) && (a.pagination = r.PageRequest.fromJSON(H.pagination)), (0, C.isSet)(H.orderBy) && (a.orderBy = U(H.orderBy)), (0, C.isSet)(H.page) && (a.page = BigInt(H.page.toString())), (0, C.isSet)(H.limit) && (a.limit = BigInt(H.limit.toString())), a;
    },
    toJSON(H) {
      const a = {};
      return H.events ? a.events = H.events.map((g) => g) : a.events = [], H.pagination !== void 0 && (a.pagination = H.pagination ? r.PageRequest.toJSON(H.pagination) : void 0), H.orderBy !== void 0 && (a.orderBy = w(H.orderBy)), H.page !== void 0 && (a.page = (H.page || BigInt(0)).toString()), H.limit !== void 0 && (a.limit = (H.limit || BigInt(0)).toString()), a;
    },
    fromPartial(H) {
      var g;
      const a = b();
      return a.events = ((g = H.events) == null ? void 0 : g.map((m) => m)) || [], H.pagination !== void 0 && H.pagination !== null && (a.pagination = r.PageRequest.fromPartial(H.pagination)), a.orderBy = H.orderBy ?? 0, H.page !== void 0 && H.page !== null && (a.page = BigInt(H.page.toString())), H.limit !== void 0 && H.limit !== null && (a.limit = BigInt(H.limit.toString())), a;
    }
  };
  function c() {
    return {
      txs: [],
      txResponses: [],
      pagination: void 0,
      total: BigInt(0)
    };
  }
  e.GetTxsEventResponse = {
    typeUrl: "/cosmos.tx.v1beta1.GetTxsEventResponse",
    encode(H, a = k.BinaryWriter.create()) {
      for (const g of H.txs)
        n.Tx.encode(g, a.uint32(10).fork()).ldelim();
      for (const g of H.txResponses)
        t.TxResponse.encode(g, a.uint32(18).fork()).ldelim();
      return H.pagination !== void 0 && r.PageResponse.encode(H.pagination, a.uint32(26).fork()).ldelim(), H.total !== BigInt(0) && a.uint32(32).uint64(H.total), a;
    },
    decode(H, a) {
      const g = H instanceof k.BinaryReader ? H : new k.BinaryReader(H);
      let m = a === void 0 ? g.len : g.pos + a;
      const S = c();
      for (; g.pos < m; ) {
        const O = g.uint32();
        switch (O >>> 3) {
          case 1:
            S.txs.push(n.Tx.decode(g, g.uint32()));
            break;
          case 2:
            S.txResponses.push(t.TxResponse.decode(g, g.uint32()));
            break;
          case 3:
            S.pagination = r.PageResponse.decode(g, g.uint32());
            break;
          case 4:
            S.total = g.uint64();
            break;
          default:
            g.skipType(O & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(H) {
      const a = c();
      return Array.isArray(H == null ? void 0 : H.txs) && (a.txs = H.txs.map((g) => n.Tx.fromJSON(g))), Array.isArray(H == null ? void 0 : H.txResponses) && (a.txResponses = H.txResponses.map((g) => t.TxResponse.fromJSON(g))), (0, C.isSet)(H.pagination) && (a.pagination = r.PageResponse.fromJSON(H.pagination)), (0, C.isSet)(H.total) && (a.total = BigInt(H.total.toString())), a;
    },
    toJSON(H) {
      const a = {};
      return H.txs ? a.txs = H.txs.map((g) => g ? n.Tx.toJSON(g) : void 0) : a.txs = [], H.txResponses ? a.txResponses = H.txResponses.map((g) => g ? t.TxResponse.toJSON(g) : void 0) : a.txResponses = [], H.pagination !== void 0 && (a.pagination = H.pagination ? r.PageResponse.toJSON(H.pagination) : void 0), H.total !== void 0 && (a.total = (H.total || BigInt(0)).toString()), a;
    },
    fromPartial(H) {
      var g, m;
      const a = c();
      return a.txs = ((g = H.txs) == null ? void 0 : g.map((S) => n.Tx.fromPartial(S))) || [], a.txResponses = ((m = H.txResponses) == null ? void 0 : m.map((S) => t.TxResponse.fromPartial(S))) || [], H.pagination !== void 0 && H.pagination !== null && (a.pagination = r.PageResponse.fromPartial(H.pagination)), H.total !== void 0 && H.total !== null && (a.total = BigInt(H.total.toString())), a;
    }
  };
  function l() {
    return {
      txBytes: new Uint8Array(),
      mode: 0
    };
  }
  e.BroadcastTxRequest = {
    typeUrl: "/cosmos.tx.v1beta1.BroadcastTxRequest",
    encode(H, a = k.BinaryWriter.create()) {
      return H.txBytes.length !== 0 && a.uint32(10).bytes(H.txBytes), H.mode !== 0 && a.uint32(16).int32(H.mode), a;
    },
    decode(H, a) {
      const g = H instanceof k.BinaryReader ? H : new k.BinaryReader(H);
      let m = a === void 0 ? g.len : g.pos + a;
      const S = l();
      for (; g.pos < m; ) {
        const O = g.uint32();
        switch (O >>> 3) {
          case 1:
            S.txBytes = g.bytes();
            break;
          case 2:
            S.mode = g.int32();
            break;
          default:
            g.skipType(O & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(H) {
      const a = l();
      return (0, C.isSet)(H.txBytes) && (a.txBytes = (0, C.bytesFromBase64)(H.txBytes)), (0, C.isSet)(H.mode) && (a.mode = h(H.mode)), a;
    },
    toJSON(H) {
      const a = {};
      return H.txBytes !== void 0 && (a.txBytes = (0, C.base64FromBytes)(H.txBytes !== void 0 ? H.txBytes : new Uint8Array())), H.mode !== void 0 && (a.mode = P(H.mode)), a;
    },
    fromPartial(H) {
      const a = l();
      return a.txBytes = H.txBytes ?? new Uint8Array(), a.mode = H.mode ?? 0, a;
    }
  };
  function y() {
    return {
      txResponse: void 0
    };
  }
  e.BroadcastTxResponse = {
    typeUrl: "/cosmos.tx.v1beta1.BroadcastTxResponse",
    encode(H, a = k.BinaryWriter.create()) {
      return H.txResponse !== void 0 && t.TxResponse.encode(H.txResponse, a.uint32(10).fork()).ldelim(), a;
    },
    decode(H, a) {
      const g = H instanceof k.BinaryReader ? H : new k.BinaryReader(H);
      let m = a === void 0 ? g.len : g.pos + a;
      const S = y();
      for (; g.pos < m; ) {
        const O = g.uint32();
        switch (O >>> 3) {
          case 1:
            S.txResponse = t.TxResponse.decode(g, g.uint32());
            break;
          default:
            g.skipType(O & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(H) {
      const a = y();
      return (0, C.isSet)(H.txResponse) && (a.txResponse = t.TxResponse.fromJSON(H.txResponse)), a;
    },
    toJSON(H) {
      const a = {};
      return H.txResponse !== void 0 && (a.txResponse = H.txResponse ? t.TxResponse.toJSON(H.txResponse) : void 0), a;
    },
    fromPartial(H) {
      const a = y();
      return H.txResponse !== void 0 && H.txResponse !== null && (a.txResponse = t.TxResponse.fromPartial(H.txResponse)), a;
    }
  };
  function E() {
    return {
      tx: void 0,
      txBytes: new Uint8Array()
    };
  }
  e.SimulateRequest = {
    typeUrl: "/cosmos.tx.v1beta1.SimulateRequest",
    encode(H, a = k.BinaryWriter.create()) {
      return H.tx !== void 0 && n.Tx.encode(H.tx, a.uint32(10).fork()).ldelim(), H.txBytes.length !== 0 && a.uint32(18).bytes(H.txBytes), a;
    },
    decode(H, a) {
      const g = H instanceof k.BinaryReader ? H : new k.BinaryReader(H);
      let m = a === void 0 ? g.len : g.pos + a;
      const S = E();
      for (; g.pos < m; ) {
        const O = g.uint32();
        switch (O >>> 3) {
          case 1:
            S.tx = n.Tx.decode(g, g.uint32());
            break;
          case 2:
            S.txBytes = g.bytes();
            break;
          default:
            g.skipType(O & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(H) {
      const a = E();
      return (0, C.isSet)(H.tx) && (a.tx = n.Tx.fromJSON(H.tx)), (0, C.isSet)(H.txBytes) && (a.txBytes = (0, C.bytesFromBase64)(H.txBytes)), a;
    },
    toJSON(H) {
      const a = {};
      return H.tx !== void 0 && (a.tx = H.tx ? n.Tx.toJSON(H.tx) : void 0), H.txBytes !== void 0 && (a.txBytes = (0, C.base64FromBytes)(H.txBytes !== void 0 ? H.txBytes : new Uint8Array())), a;
    },
    fromPartial(H) {
      const a = E();
      return H.tx !== void 0 && H.tx !== null && (a.tx = n.Tx.fromPartial(H.tx)), a.txBytes = H.txBytes ?? new Uint8Array(), a;
    }
  };
  function J() {
    return {
      gasInfo: void 0,
      result: void 0
    };
  }
  e.SimulateResponse = {
    typeUrl: "/cosmos.tx.v1beta1.SimulateResponse",
    encode(H, a = k.BinaryWriter.create()) {
      return H.gasInfo !== void 0 && t.GasInfo.encode(H.gasInfo, a.uint32(10).fork()).ldelim(), H.result !== void 0 && t.Result.encode(H.result, a.uint32(18).fork()).ldelim(), a;
    },
    decode(H, a) {
      const g = H instanceof k.BinaryReader ? H : new k.BinaryReader(H);
      let m = a === void 0 ? g.len : g.pos + a;
      const S = J();
      for (; g.pos < m; ) {
        const O = g.uint32();
        switch (O >>> 3) {
          case 1:
            S.gasInfo = t.GasInfo.decode(g, g.uint32());
            break;
          case 2:
            S.result = t.Result.decode(g, g.uint32());
            break;
          default:
            g.skipType(O & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(H) {
      const a = J();
      return (0, C.isSet)(H.gasInfo) && (a.gasInfo = t.GasInfo.fromJSON(H.gasInfo)), (0, C.isSet)(H.result) && (a.result = t.Result.fromJSON(H.result)), a;
    },
    toJSON(H) {
      const a = {};
      return H.gasInfo !== void 0 && (a.gasInfo = H.gasInfo ? t.GasInfo.toJSON(H.gasInfo) : void 0), H.result !== void 0 && (a.result = H.result ? t.Result.toJSON(H.result) : void 0), a;
    },
    fromPartial(H) {
      const a = J();
      return H.gasInfo !== void 0 && H.gasInfo !== null && (a.gasInfo = t.GasInfo.fromPartial(H.gasInfo)), H.result !== void 0 && H.result !== null && (a.result = t.Result.fromPartial(H.result)), a;
    }
  };
  function _() {
    return {
      hash: ""
    };
  }
  e.GetTxRequest = {
    typeUrl: "/cosmos.tx.v1beta1.GetTxRequest",
    encode(H, a = k.BinaryWriter.create()) {
      return H.hash !== "" && a.uint32(10).string(H.hash), a;
    },
    decode(H, a) {
      const g = H instanceof k.BinaryReader ? H : new k.BinaryReader(H);
      let m = a === void 0 ? g.len : g.pos + a;
      const S = _();
      for (; g.pos < m; ) {
        const O = g.uint32();
        switch (O >>> 3) {
          case 1:
            S.hash = g.string();
            break;
          default:
            g.skipType(O & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(H) {
      const a = _();
      return (0, C.isSet)(H.hash) && (a.hash = String(H.hash)), a;
    },
    toJSON(H) {
      const a = {};
      return H.hash !== void 0 && (a.hash = H.hash), a;
    },
    fromPartial(H) {
      const a = _();
      return a.hash = H.hash ?? "", a;
    }
  };
  function V() {
    return {
      tx: void 0,
      txResponse: void 0
    };
  }
  e.GetTxResponse = {
    typeUrl: "/cosmos.tx.v1beta1.GetTxResponse",
    encode(H, a = k.BinaryWriter.create()) {
      return H.tx !== void 0 && n.Tx.encode(H.tx, a.uint32(10).fork()).ldelim(), H.txResponse !== void 0 && t.TxResponse.encode(H.txResponse, a.uint32(18).fork()).ldelim(), a;
    },
    decode(H, a) {
      const g = H instanceof k.BinaryReader ? H : new k.BinaryReader(H);
      let m = a === void 0 ? g.len : g.pos + a;
      const S = V();
      for (; g.pos < m; ) {
        const O = g.uint32();
        switch (O >>> 3) {
          case 1:
            S.tx = n.Tx.decode(g, g.uint32());
            break;
          case 2:
            S.txResponse = t.TxResponse.decode(g, g.uint32());
            break;
          default:
            g.skipType(O & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(H) {
      const a = V();
      return (0, C.isSet)(H.tx) && (a.tx = n.Tx.fromJSON(H.tx)), (0, C.isSet)(H.txResponse) && (a.txResponse = t.TxResponse.fromJSON(H.txResponse)), a;
    },
    toJSON(H) {
      const a = {};
      return H.tx !== void 0 && (a.tx = H.tx ? n.Tx.toJSON(H.tx) : void 0), H.txResponse !== void 0 && (a.txResponse = H.txResponse ? t.TxResponse.toJSON(H.txResponse) : void 0), a;
    },
    fromPartial(H) {
      const a = V();
      return H.tx !== void 0 && H.tx !== null && (a.tx = n.Tx.fromPartial(H.tx)), H.txResponse !== void 0 && H.txResponse !== null && (a.txResponse = t.TxResponse.fromPartial(H.txResponse)), a;
    }
  };
  function o() {
    return {
      height: BigInt(0),
      pagination: void 0
    };
  }
  e.GetBlockWithTxsRequest = {
    typeUrl: "/cosmos.tx.v1beta1.GetBlockWithTxsRequest",
    encode(H, a = k.BinaryWriter.create()) {
      return H.height !== BigInt(0) && a.uint32(8).int64(H.height), H.pagination !== void 0 && r.PageRequest.encode(H.pagination, a.uint32(18).fork()).ldelim(), a;
    },
    decode(H, a) {
      const g = H instanceof k.BinaryReader ? H : new k.BinaryReader(H);
      let m = a === void 0 ? g.len : g.pos + a;
      const S = o();
      for (; g.pos < m; ) {
        const O = g.uint32();
        switch (O >>> 3) {
          case 1:
            S.height = g.int64();
            break;
          case 2:
            S.pagination = r.PageRequest.decode(g, g.uint32());
            break;
          default:
            g.skipType(O & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(H) {
      const a = o();
      return (0, C.isSet)(H.height) && (a.height = BigInt(H.height.toString())), (0, C.isSet)(H.pagination) && (a.pagination = r.PageRequest.fromJSON(H.pagination)), a;
    },
    toJSON(H) {
      const a = {};
      return H.height !== void 0 && (a.height = (H.height || BigInt(0)).toString()), H.pagination !== void 0 && (a.pagination = H.pagination ? r.PageRequest.toJSON(H.pagination) : void 0), a;
    },
    fromPartial(H) {
      const a = o();
      return H.height !== void 0 && H.height !== null && (a.height = BigInt(H.height.toString())), H.pagination !== void 0 && H.pagination !== null && (a.pagination = r.PageRequest.fromPartial(H.pagination)), a;
    }
  };
  function p() {
    return {
      txs: [],
      blockId: void 0,
      block: void 0,
      pagination: void 0
    };
  }
  e.GetBlockWithTxsResponse = {
    typeUrl: "/cosmos.tx.v1beta1.GetBlockWithTxsResponse",
    encode(H, a = k.BinaryWriter.create()) {
      for (const g of H.txs)
        n.Tx.encode(g, a.uint32(10).fork()).ldelim();
      return H.blockId !== void 0 && i.BlockID.encode(H.blockId, a.uint32(18).fork()).ldelim(), H.block !== void 0 && f.Block.encode(H.block, a.uint32(26).fork()).ldelim(), H.pagination !== void 0 && r.PageResponse.encode(H.pagination, a.uint32(34).fork()).ldelim(), a;
    },
    decode(H, a) {
      const g = H instanceof k.BinaryReader ? H : new k.BinaryReader(H);
      let m = a === void 0 ? g.len : g.pos + a;
      const S = p();
      for (; g.pos < m; ) {
        const O = g.uint32();
        switch (O >>> 3) {
          case 1:
            S.txs.push(n.Tx.decode(g, g.uint32()));
            break;
          case 2:
            S.blockId = i.BlockID.decode(g, g.uint32());
            break;
          case 3:
            S.block = f.Block.decode(g, g.uint32());
            break;
          case 4:
            S.pagination = r.PageResponse.decode(g, g.uint32());
            break;
          default:
            g.skipType(O & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(H) {
      const a = p();
      return Array.isArray(H == null ? void 0 : H.txs) && (a.txs = H.txs.map((g) => n.Tx.fromJSON(g))), (0, C.isSet)(H.blockId) && (a.blockId = i.BlockID.fromJSON(H.blockId)), (0, C.isSet)(H.block) && (a.block = f.Block.fromJSON(H.block)), (0, C.isSet)(H.pagination) && (a.pagination = r.PageResponse.fromJSON(H.pagination)), a;
    },
    toJSON(H) {
      const a = {};
      return H.txs ? a.txs = H.txs.map((g) => g ? n.Tx.toJSON(g) : void 0) : a.txs = [], H.blockId !== void 0 && (a.blockId = H.blockId ? i.BlockID.toJSON(H.blockId) : void 0), H.block !== void 0 && (a.block = H.block ? f.Block.toJSON(H.block) : void 0), H.pagination !== void 0 && (a.pagination = H.pagination ? r.PageResponse.toJSON(H.pagination) : void 0), a;
    },
    fromPartial(H) {
      var g;
      const a = p();
      return a.txs = ((g = H.txs) == null ? void 0 : g.map((m) => n.Tx.fromPartial(m))) || [], H.blockId !== void 0 && H.blockId !== null && (a.blockId = i.BlockID.fromPartial(H.blockId)), H.block !== void 0 && H.block !== null && (a.block = f.Block.fromPartial(H.block)), H.pagination !== void 0 && H.pagination !== null && (a.pagination = r.PageResponse.fromPartial(H.pagination)), a;
    }
  };
  function I() {
    return {
      txBytes: new Uint8Array()
    };
  }
  e.TxDecodeRequest = {
    typeUrl: "/cosmos.tx.v1beta1.TxDecodeRequest",
    encode(H, a = k.BinaryWriter.create()) {
      return H.txBytes.length !== 0 && a.uint32(10).bytes(H.txBytes), a;
    },
    decode(H, a) {
      const g = H instanceof k.BinaryReader ? H : new k.BinaryReader(H);
      let m = a === void 0 ? g.len : g.pos + a;
      const S = I();
      for (; g.pos < m; ) {
        const O = g.uint32();
        switch (O >>> 3) {
          case 1:
            S.txBytes = g.bytes();
            break;
          default:
            g.skipType(O & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(H) {
      const a = I();
      return (0, C.isSet)(H.txBytes) && (a.txBytes = (0, C.bytesFromBase64)(H.txBytes)), a;
    },
    toJSON(H) {
      const a = {};
      return H.txBytes !== void 0 && (a.txBytes = (0, C.base64FromBytes)(H.txBytes !== void 0 ? H.txBytes : new Uint8Array())), a;
    },
    fromPartial(H) {
      const a = I();
      return a.txBytes = H.txBytes ?? new Uint8Array(), a;
    }
  };
  function q() {
    return {
      tx: void 0
    };
  }
  e.TxDecodeResponse = {
    typeUrl: "/cosmos.tx.v1beta1.TxDecodeResponse",
    encode(H, a = k.BinaryWriter.create()) {
      return H.tx !== void 0 && n.Tx.encode(H.tx, a.uint32(10).fork()).ldelim(), a;
    },
    decode(H, a) {
      const g = H instanceof k.BinaryReader ? H : new k.BinaryReader(H);
      let m = a === void 0 ? g.len : g.pos + a;
      const S = q();
      for (; g.pos < m; ) {
        const O = g.uint32();
        switch (O >>> 3) {
          case 1:
            S.tx = n.Tx.decode(g, g.uint32());
            break;
          default:
            g.skipType(O & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(H) {
      const a = q();
      return (0, C.isSet)(H.tx) && (a.tx = n.Tx.fromJSON(H.tx)), a;
    },
    toJSON(H) {
      const a = {};
      return H.tx !== void 0 && (a.tx = H.tx ? n.Tx.toJSON(H.tx) : void 0), a;
    },
    fromPartial(H) {
      const a = q();
      return H.tx !== void 0 && H.tx !== null && (a.tx = n.Tx.fromPartial(H.tx)), a;
    }
  };
  function s() {
    return {
      tx: void 0
    };
  }
  e.TxEncodeRequest = {
    typeUrl: "/cosmos.tx.v1beta1.TxEncodeRequest",
    encode(H, a = k.BinaryWriter.create()) {
      return H.tx !== void 0 && n.Tx.encode(H.tx, a.uint32(10).fork()).ldelim(), a;
    },
    decode(H, a) {
      const g = H instanceof k.BinaryReader ? H : new k.BinaryReader(H);
      let m = a === void 0 ? g.len : g.pos + a;
      const S = s();
      for (; g.pos < m; ) {
        const O = g.uint32();
        switch (O >>> 3) {
          case 1:
            S.tx = n.Tx.decode(g, g.uint32());
            break;
          default:
            g.skipType(O & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(H) {
      const a = s();
      return (0, C.isSet)(H.tx) && (a.tx = n.Tx.fromJSON(H.tx)), a;
    },
    toJSON(H) {
      const a = {};
      return H.tx !== void 0 && (a.tx = H.tx ? n.Tx.toJSON(H.tx) : void 0), a;
    },
    fromPartial(H) {
      const a = s();
      return H.tx !== void 0 && H.tx !== null && (a.tx = n.Tx.fromPartial(H.tx)), a;
    }
  };
  function u() {
    return {
      txBytes: new Uint8Array()
    };
  }
  e.TxEncodeResponse = {
    typeUrl: "/cosmos.tx.v1beta1.TxEncodeResponse",
    encode(H, a = k.BinaryWriter.create()) {
      return H.txBytes.length !== 0 && a.uint32(10).bytes(H.txBytes), a;
    },
    decode(H, a) {
      const g = H instanceof k.BinaryReader ? H : new k.BinaryReader(H);
      let m = a === void 0 ? g.len : g.pos + a;
      const S = u();
      for (; g.pos < m; ) {
        const O = g.uint32();
        switch (O >>> 3) {
          case 1:
            S.txBytes = g.bytes();
            break;
          default:
            g.skipType(O & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(H) {
      const a = u();
      return (0, C.isSet)(H.txBytes) && (a.txBytes = (0, C.bytesFromBase64)(H.txBytes)), a;
    },
    toJSON(H) {
      const a = {};
      return H.txBytes !== void 0 && (a.txBytes = (0, C.base64FromBytes)(H.txBytes !== void 0 ? H.txBytes : new Uint8Array())), a;
    },
    fromPartial(H) {
      const a = u();
      return a.txBytes = H.txBytes ?? new Uint8Array(), a;
    }
  };
  function A() {
    return {
      aminoJson: ""
    };
  }
  e.TxEncodeAminoRequest = {
    typeUrl: "/cosmos.tx.v1beta1.TxEncodeAminoRequest",
    encode(H, a = k.BinaryWriter.create()) {
      return H.aminoJson !== "" && a.uint32(10).string(H.aminoJson), a;
    },
    decode(H, a) {
      const g = H instanceof k.BinaryReader ? H : new k.BinaryReader(H);
      let m = a === void 0 ? g.len : g.pos + a;
      const S = A();
      for (; g.pos < m; ) {
        const O = g.uint32();
        switch (O >>> 3) {
          case 1:
            S.aminoJson = g.string();
            break;
          default:
            g.skipType(O & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(H) {
      const a = A();
      return (0, C.isSet)(H.aminoJson) && (a.aminoJson = String(H.aminoJson)), a;
    },
    toJSON(H) {
      const a = {};
      return H.aminoJson !== void 0 && (a.aminoJson = H.aminoJson), a;
    },
    fromPartial(H) {
      const a = A();
      return a.aminoJson = H.aminoJson ?? "", a;
    }
  };
  function R() {
    return {
      aminoBinary: new Uint8Array()
    };
  }
  e.TxEncodeAminoResponse = {
    typeUrl: "/cosmos.tx.v1beta1.TxEncodeAminoResponse",
    encode(H, a = k.BinaryWriter.create()) {
      return H.aminoBinary.length !== 0 && a.uint32(10).bytes(H.aminoBinary), a;
    },
    decode(H, a) {
      const g = H instanceof k.BinaryReader ? H : new k.BinaryReader(H);
      let m = a === void 0 ? g.len : g.pos + a;
      const S = R();
      for (; g.pos < m; ) {
        const O = g.uint32();
        switch (O >>> 3) {
          case 1:
            S.aminoBinary = g.bytes();
            break;
          default:
            g.skipType(O & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(H) {
      const a = R();
      return (0, C.isSet)(H.aminoBinary) && (a.aminoBinary = (0, C.bytesFromBase64)(H.aminoBinary)), a;
    },
    toJSON(H) {
      const a = {};
      return H.aminoBinary !== void 0 && (a.aminoBinary = (0, C.base64FromBytes)(H.aminoBinary !== void 0 ? H.aminoBinary : new Uint8Array())), a;
    },
    fromPartial(H) {
      const a = R();
      return a.aminoBinary = H.aminoBinary ?? new Uint8Array(), a;
    }
  };
  function v() {
    return {
      aminoBinary: new Uint8Array()
    };
  }
  e.TxDecodeAminoRequest = {
    typeUrl: "/cosmos.tx.v1beta1.TxDecodeAminoRequest",
    encode(H, a = k.BinaryWriter.create()) {
      return H.aminoBinary.length !== 0 && a.uint32(10).bytes(H.aminoBinary), a;
    },
    decode(H, a) {
      const g = H instanceof k.BinaryReader ? H : new k.BinaryReader(H);
      let m = a === void 0 ? g.len : g.pos + a;
      const S = v();
      for (; g.pos < m; ) {
        const O = g.uint32();
        switch (O >>> 3) {
          case 1:
            S.aminoBinary = g.bytes();
            break;
          default:
            g.skipType(O & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(H) {
      const a = v();
      return (0, C.isSet)(H.aminoBinary) && (a.aminoBinary = (0, C.bytesFromBase64)(H.aminoBinary)), a;
    },
    toJSON(H) {
      const a = {};
      return H.aminoBinary !== void 0 && (a.aminoBinary = (0, C.base64FromBytes)(H.aminoBinary !== void 0 ? H.aminoBinary : new Uint8Array())), a;
    },
    fromPartial(H) {
      const a = v();
      return a.aminoBinary = H.aminoBinary ?? new Uint8Array(), a;
    }
  };
  function D() {
    return {
      aminoJson: ""
    };
  }
  e.TxDecodeAminoResponse = {
    typeUrl: "/cosmos.tx.v1beta1.TxDecodeAminoResponse",
    encode(H, a = k.BinaryWriter.create()) {
      return H.aminoJson !== "" && a.uint32(10).string(H.aminoJson), a;
    },
    decode(H, a) {
      const g = H instanceof k.BinaryReader ? H : new k.BinaryReader(H);
      let m = a === void 0 ? g.len : g.pos + a;
      const S = D();
      for (; g.pos < m; ) {
        const O = g.uint32();
        switch (O >>> 3) {
          case 1:
            S.aminoJson = g.string();
            break;
          default:
            g.skipType(O & 7);
            break;
        }
      }
      return S;
    },
    fromJSON(H) {
      const a = D();
      return (0, C.isSet)(H.aminoJson) && (a.aminoJson = String(H.aminoJson)), a;
    },
    toJSON(H) {
      const a = {};
      return H.aminoJson !== void 0 && (a.aminoJson = H.aminoJson), a;
    },
    fromPartial(H) {
      const a = D();
      return a.aminoJson = H.aminoJson ?? "", a;
    }
  };
  class W {
    constructor(a) {
      this.rpc = a, this.Simulate = this.Simulate.bind(this), this.GetTx = this.GetTx.bind(this), this.BroadcastTx = this.BroadcastTx.bind(this), this.GetTxsEvent = this.GetTxsEvent.bind(this), this.GetBlockWithTxs = this.GetBlockWithTxs.bind(this), this.TxDecode = this.TxDecode.bind(this), this.TxEncode = this.TxEncode.bind(this), this.TxEncodeAmino = this.TxEncodeAmino.bind(this), this.TxDecodeAmino = this.TxDecodeAmino.bind(this);
    }
    Simulate(a) {
      const g = e.SimulateRequest.encode(a).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "Simulate", g).then((S) => e.SimulateResponse.decode(new k.BinaryReader(S)));
    }
    GetTx(a) {
      const g = e.GetTxRequest.encode(a).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "GetTx", g).then((S) => e.GetTxResponse.decode(new k.BinaryReader(S)));
    }
    BroadcastTx(a) {
      const g = e.BroadcastTxRequest.encode(a).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "BroadcastTx", g).then((S) => e.BroadcastTxResponse.decode(new k.BinaryReader(S)));
    }
    GetTxsEvent(a) {
      const g = e.GetTxsEventRequest.encode(a).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "GetTxsEvent", g).then((S) => e.GetTxsEventResponse.decode(new k.BinaryReader(S)));
    }
    GetBlockWithTxs(a) {
      const g = e.GetBlockWithTxsRequest.encode(a).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "GetBlockWithTxs", g).then((S) => e.GetBlockWithTxsResponse.decode(new k.BinaryReader(S)));
    }
    TxDecode(a) {
      const g = e.TxDecodeRequest.encode(a).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "TxDecode", g).then((S) => e.TxDecodeResponse.decode(new k.BinaryReader(S)));
    }
    TxEncode(a) {
      const g = e.TxEncodeRequest.encode(a).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "TxEncode", g).then((S) => e.TxEncodeResponse.decode(new k.BinaryReader(S)));
    }
    TxEncodeAmino(a) {
      const g = e.TxEncodeAminoRequest.encode(a).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "TxEncodeAmino", g).then((S) => e.TxEncodeAminoResponse.decode(new k.BinaryReader(S)));
    }
    TxDecodeAmino(a) {
      const g = e.TxDecodeAminoRequest.encode(a).finish();
      return this.rpc.request("cosmos.tx.v1beta1.Service", "TxDecodeAmino", g).then((S) => e.TxDecodeAminoResponse.decode(new k.BinaryReader(S)));
    }
  }
  e.ServiceClientImpl = W;
})(Rl);
Object.defineProperty(_o, "__esModule", { value: !0 });
_o.setupTxExtension = void 0;
const sg = Nt, dg = ed, Ju = Rl, Ur = xr, ug = Ge;
function cg(e) {
  const n = (0, ug.createProtobufRpcClient)(e), r = new Ju.ServiceClientImpl(n);
  return {
    tx: {
      getTx: async (t) => {
        const i = {
          hash: t
        };
        return await r.GetTx(i);
      },
      simulate: async (t, i, f, k) => {
        const C = Ur.Tx.fromPartial({
          authInfo: Ur.AuthInfo.fromPartial({
            fee: Ur.Fee.fromPartial({}),
            signerInfos: [
              {
                publicKey: (0, sg.encodePubkey)(f),
                sequence: BigInt(k),
                modeInfo: { single: { mode: dg.SignMode.SIGN_MODE_UNSPECIFIED } }
              }
            ]
          }),
          body: Ur.TxBody.fromPartial({
            messages: Array.from(t),
            memo: i
          }),
          signatures: [new Uint8Array()]
        }), T = Ju.SimulateRequest.fromPartial({
          txBytes: Ur.Tx.encode(C).finish()
        });
        return await r.Simulate(T);
      }
    }
  };
}
_o.setupTxExtension = cg;
var dr = {};
Object.defineProperty(dr, "__esModule", { value: !0 });
dr.createVestingAminoConverters = dr.isAminoMsgCreateVestingAccount = void 0;
function lg(e) {
  return e.type === "cosmos-sdk/MsgCreateVestingAccount";
}
dr.isAminoMsgCreateVestingAccount = lg;
function fg() {
  return {
    "/cosmos.vesting.v1beta1.MsgCreateVestingAccount": {
      aminoType: "cosmos-sdk/MsgCreateVestingAccount",
      toAmino: ({ fromAddress: e, toAddress: n, amount: r, endTime: t, delayed: i }) => ({
        from_address: e,
        to_address: n,
        amount: [...r],
        end_time: t.toString(),
        delayed: i
      }),
      fromAmino: ({ from_address: e, to_address: n, amount: r, end_time: t, delayed: i }) => ({
        fromAddress: e,
        toAddress: n,
        amount: [...r],
        endTime: BigInt(t),
        delayed: i
      })
    }
  };
}
dr.createVestingAminoConverters = fg;
var Eo = {}, Ol = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgCreatePeriodicVestingAccountResponse = e.MsgCreatePeriodicVestingAccount = e.MsgCreatePermanentLockedAccountResponse = e.MsgCreatePermanentLockedAccount = e.MsgCreateVestingAccountResponse = e.MsgCreateVestingAccount = e.protobufPackage = void 0;
  const n = Le, r = td, t = re, i = ie;
  e.protobufPackage = "cosmos.vesting.v1beta1";
  function f() {
    return {
      fromAddress: "",
      toAddress: "",
      amount: [],
      endTime: BigInt(0),
      delayed: !1
    };
  }
  e.MsgCreateVestingAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.MsgCreateVestingAccount",
    encode(h, P = t.BinaryWriter.create()) {
      h.fromAddress !== "" && P.uint32(10).string(h.fromAddress), h.toAddress !== "" && P.uint32(18).string(h.toAddress);
      for (const b of h.amount)
        n.Coin.encode(b, P.uint32(26).fork()).ldelim();
      return h.endTime !== BigInt(0) && P.uint32(32).int64(h.endTime), h.delayed === !0 && P.uint32(40).bool(h.delayed), P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = f();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.fromAddress = b.string();
            break;
          case 2:
            l.toAddress = b.string();
            break;
          case 3:
            l.amount.push(n.Coin.decode(b, b.uint32()));
            break;
          case 4:
            l.endTime = b.int64();
            break;
          case 5:
            l.delayed = b.bool();
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = f();
      return (0, i.isSet)(h.fromAddress) && (P.fromAddress = String(h.fromAddress)), (0, i.isSet)(h.toAddress) && (P.toAddress = String(h.toAddress)), Array.isArray(h == null ? void 0 : h.amount) && (P.amount = h.amount.map((b) => n.Coin.fromJSON(b))), (0, i.isSet)(h.endTime) && (P.endTime = BigInt(h.endTime.toString())), (0, i.isSet)(h.delayed) && (P.delayed = !!h.delayed), P;
    },
    toJSON(h) {
      const P = {};
      return h.fromAddress !== void 0 && (P.fromAddress = h.fromAddress), h.toAddress !== void 0 && (P.toAddress = h.toAddress), h.amount ? P.amount = h.amount.map((b) => b ? n.Coin.toJSON(b) : void 0) : P.amount = [], h.endTime !== void 0 && (P.endTime = (h.endTime || BigInt(0)).toString()), h.delayed !== void 0 && (P.delayed = h.delayed), P;
    },
    fromPartial(h) {
      var b;
      const P = f();
      return P.fromAddress = h.fromAddress ?? "", P.toAddress = h.toAddress ?? "", P.amount = ((b = h.amount) == null ? void 0 : b.map((c) => n.Coin.fromPartial(c))) || [], h.endTime !== void 0 && h.endTime !== null && (P.endTime = BigInt(h.endTime.toString())), P.delayed = h.delayed ?? !1, P;
    }
  };
  function k() {
    return {};
  }
  e.MsgCreateVestingAccountResponse = {
    typeUrl: "/cosmos.vesting.v1beta1.MsgCreateVestingAccountResponse",
    encode(h, P = t.BinaryWriter.create()) {
      return P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = k();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      return k();
    },
    toJSON(h) {
      return {};
    },
    fromPartial(h) {
      return k();
    }
  };
  function C() {
    return {
      fromAddress: "",
      toAddress: "",
      amount: []
    };
  }
  e.MsgCreatePermanentLockedAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount",
    encode(h, P = t.BinaryWriter.create()) {
      h.fromAddress !== "" && P.uint32(10).string(h.fromAddress), h.toAddress !== "" && P.uint32(18).string(h.toAddress);
      for (const b of h.amount)
        n.Coin.encode(b, P.uint32(26).fork()).ldelim();
      return P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = C();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.fromAddress = b.string();
            break;
          case 2:
            l.toAddress = b.string();
            break;
          case 3:
            l.amount.push(n.Coin.decode(b, b.uint32()));
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = C();
      return (0, i.isSet)(h.fromAddress) && (P.fromAddress = String(h.fromAddress)), (0, i.isSet)(h.toAddress) && (P.toAddress = String(h.toAddress)), Array.isArray(h == null ? void 0 : h.amount) && (P.amount = h.amount.map((b) => n.Coin.fromJSON(b))), P;
    },
    toJSON(h) {
      const P = {};
      return h.fromAddress !== void 0 && (P.fromAddress = h.fromAddress), h.toAddress !== void 0 && (P.toAddress = h.toAddress), h.amount ? P.amount = h.amount.map((b) => b ? n.Coin.toJSON(b) : void 0) : P.amount = [], P;
    },
    fromPartial(h) {
      var b;
      const P = C();
      return P.fromAddress = h.fromAddress ?? "", P.toAddress = h.toAddress ?? "", P.amount = ((b = h.amount) == null ? void 0 : b.map((c) => n.Coin.fromPartial(c))) || [], P;
    }
  };
  function T() {
    return {};
  }
  e.MsgCreatePermanentLockedAccountResponse = {
    typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccountResponse",
    encode(h, P = t.BinaryWriter.create()) {
      return P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = T();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      return T();
    },
    toJSON(h) {
      return {};
    },
    fromPartial(h) {
      return T();
    }
  };
  function U() {
    return {
      fromAddress: "",
      toAddress: "",
      startTime: BigInt(0),
      vestingPeriods: []
    };
  }
  e.MsgCreatePeriodicVestingAccount = {
    typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount",
    encode(h, P = t.BinaryWriter.create()) {
      h.fromAddress !== "" && P.uint32(10).string(h.fromAddress), h.toAddress !== "" && P.uint32(18).string(h.toAddress), h.startTime !== BigInt(0) && P.uint32(24).int64(h.startTime);
      for (const b of h.vestingPeriods)
        r.Period.encode(b, P.uint32(34).fork()).ldelim();
      return P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = U();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          case 1:
            l.fromAddress = b.string();
            break;
          case 2:
            l.toAddress = b.string();
            break;
          case 3:
            l.startTime = b.int64();
            break;
          case 4:
            l.vestingPeriods.push(r.Period.decode(b, b.uint32()));
            break;
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      const P = U();
      return (0, i.isSet)(h.fromAddress) && (P.fromAddress = String(h.fromAddress)), (0, i.isSet)(h.toAddress) && (P.toAddress = String(h.toAddress)), (0, i.isSet)(h.startTime) && (P.startTime = BigInt(h.startTime.toString())), Array.isArray(h == null ? void 0 : h.vestingPeriods) && (P.vestingPeriods = h.vestingPeriods.map((b) => r.Period.fromJSON(b))), P;
    },
    toJSON(h) {
      const P = {};
      return h.fromAddress !== void 0 && (P.fromAddress = h.fromAddress), h.toAddress !== void 0 && (P.toAddress = h.toAddress), h.startTime !== void 0 && (P.startTime = (h.startTime || BigInt(0)).toString()), h.vestingPeriods ? P.vestingPeriods = h.vestingPeriods.map((b) => b ? r.Period.toJSON(b) : void 0) : P.vestingPeriods = [], P;
    },
    fromPartial(h) {
      var b;
      const P = U();
      return P.fromAddress = h.fromAddress ?? "", P.toAddress = h.toAddress ?? "", h.startTime !== void 0 && h.startTime !== null && (P.startTime = BigInt(h.startTime.toString())), P.vestingPeriods = ((b = h.vestingPeriods) == null ? void 0 : b.map((c) => r.Period.fromPartial(c))) || [], P;
    }
  };
  function w() {
    return {};
  }
  e.MsgCreatePeriodicVestingAccountResponse = {
    typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccountResponse",
    encode(h, P = t.BinaryWriter.create()) {
      return P;
    },
    decode(h, P) {
      const b = h instanceof t.BinaryReader ? h : new t.BinaryReader(h);
      let c = P === void 0 ? b.len : b.pos + P;
      const l = w();
      for (; b.pos < c; ) {
        const y = b.uint32();
        switch (y >>> 3) {
          default:
            b.skipType(y & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(h) {
      return w();
    },
    toJSON(h) {
      return {};
    },
    fromPartial(h) {
      return w();
    }
  };
  class N {
    constructor(P) {
      this.rpc = P, this.CreateVestingAccount = this.CreateVestingAccount.bind(this), this.CreatePermanentLockedAccount = this.CreatePermanentLockedAccount.bind(this), this.CreatePeriodicVestingAccount = this.CreatePeriodicVestingAccount.bind(this);
    }
    CreateVestingAccount(P) {
      const b = e.MsgCreateVestingAccount.encode(P).finish();
      return this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreateVestingAccount", b).then((l) => e.MsgCreateVestingAccountResponse.decode(new t.BinaryReader(l)));
    }
    CreatePermanentLockedAccount(P) {
      const b = e.MsgCreatePermanentLockedAccount.encode(P).finish();
      return this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreatePermanentLockedAccount", b).then((l) => e.MsgCreatePermanentLockedAccountResponse.decode(new t.BinaryReader(l)));
    }
    CreatePeriodicVestingAccount(P) {
      const b = e.MsgCreatePeriodicVestingAccount.encode(P).finish();
      return this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreatePeriodicVestingAccount", b).then((l) => e.MsgCreatePeriodicVestingAccountResponse.decode(new t.BinaryReader(l)));
    }
  }
  e.MsgClientImpl = N;
})(Ol);
Object.defineProperty(Eo, "__esModule", { value: !0 });
Eo.vestingTypes = void 0;
const pg = Ol;
Eo.vestingTypes = [
  ["/cosmos.vesting.v1beta1.MsgCreateVestingAccount", pg.MsgCreateVestingAccount]
];
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isAminoMsgCreateValidator = e.isAminoMsgBeginRedelegate = e.createStakingAminoConverters = e.setupSlashingExtension = e.isAminoMsgUnjail = e.createSlashingAminoConverters = e.setupMintExtension = e.setupIbcExtension = e.isMsgTransferEncodeObject = e.ibcTypes = e.isAminoMsgTransfer = e.createIbcAminoConverters = e.groupTypes = e.createGroupAminoConverters = e.setupGovExtension = e.isMsgVoteWeightedEncodeObject = e.isMsgVoteEncodeObject = e.isMsgSubmitProposalEncodeObject = e.isMsgDepositEncodeObject = e.govTypes = e.isAminoMsgVoteWeighted = e.isAminoMsgVote = e.isAminoMsgSubmitProposal = e.isAminoMsgDeposit = e.createGovAminoConverters = e.setupFeegrantExtension = e.feegrantTypes = e.createFeegrantAminoConverters = e.isAminoMsgSubmitEvidence = e.createEvidenceAminoConverters = e.setupDistributionExtension = e.isMsgWithdrawDelegatorRewardEncodeObject = e.distributionTypes = e.isAminoMsgWithdrawValidatorCommission = e.isAminoMsgWithdrawDelegatorReward = e.isAminoMsgSetWithdrawAddress = e.isAminoMsgFundCommunityPool = e.createDistributionAminoConverters = e.isAminoMsgVerifyInvariant = e.createCrysisAminoConverters = e.setupBankExtension = e.isMsgSendEncodeObject = e.bankTypes = e.isAminoMsgSend = e.isAminoMsgMultiSend = e.createBankAminoConverters = e.setupAuthzExtension = e.authzTypes = e.createAuthzAminoConverters = e.setupAuthExtension = void 0, e.vestingTypes = e.isAminoMsgCreateVestingAccount = e.createVestingAminoConverters = e.setupTxExtension = e.setupStakingExtension = e.stakingTypes = e.isMsgUndelegateEncodeObject = e.isMsgEditValidatorEncodeObject = e.isMsgDelegateEncodeObject = e.isMsgCreateValidatorEncodeObject = e.isMsgBeginRedelegateEncodeObject = e.isAminoMsgUndelegate = e.isAminoMsgEditValidator = e.isAminoMsgDelegate = void 0;
  var n = no;
  Object.defineProperty(e, "setupAuthExtension", { enumerable: !0, get: function() {
    return n.setupAuthExtension;
  } });
  var r = po;
  Object.defineProperty(e, "createAuthzAminoConverters", { enumerable: !0, get: function() {
    return r.createAuthzAminoConverters;
  } });
  var t = ho;
  Object.defineProperty(e, "authzTypes", { enumerable: !0, get: function() {
    return t.authzTypes;
  } });
  var i = yo;
  Object.defineProperty(e, "setupAuthzExtension", { enumerable: !0, get: function() {
    return i.setupAuthzExtension;
  } });
  var f = st;
  Object.defineProperty(e, "createBankAminoConverters", { enumerable: !0, get: function() {
    return f.createBankAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgMultiSend", { enumerable: !0, get: function() {
    return f.isAminoMsgMultiSend;
  } }), Object.defineProperty(e, "isAminoMsgSend", { enumerable: !0, get: function() {
    return f.isAminoMsgSend;
  } });
  var k = er;
  Object.defineProperty(e, "bankTypes", { enumerable: !0, get: function() {
    return k.bankTypes;
  } }), Object.defineProperty(e, "isMsgSendEncodeObject", { enumerable: !0, get: function() {
    return k.isMsgSendEncodeObject;
  } });
  var C = mo;
  Object.defineProperty(e, "setupBankExtension", { enumerable: !0, get: function() {
    return C.setupBankExtension;
  } });
  var T = nr;
  Object.defineProperty(e, "createCrysisAminoConverters", { enumerable: !0, get: function() {
    return T.createCrysisAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgVerifyInvariant", { enumerable: !0, get: function() {
    return T.isAminoMsgVerifyInvariant;
  } });
  var U = yn;
  Object.defineProperty(e, "createDistributionAminoConverters", { enumerable: !0, get: function() {
    return U.createDistributionAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgFundCommunityPool", { enumerable: !0, get: function() {
    return U.isAminoMsgFundCommunityPool;
  } }), Object.defineProperty(e, "isAminoMsgSetWithdrawAddress", { enumerable: !0, get: function() {
    return U.isAminoMsgSetWithdrawAddress;
  } }), Object.defineProperty(e, "isAminoMsgWithdrawDelegatorReward", { enumerable: !0, get: function() {
    return U.isAminoMsgWithdrawDelegatorReward;
  } }), Object.defineProperty(e, "isAminoMsgWithdrawValidatorCommission", { enumerable: !0, get: function() {
    return U.isAminoMsgWithdrawValidatorCommission;
  } });
  var w = tr;
  Object.defineProperty(e, "distributionTypes", { enumerable: !0, get: function() {
    return w.distributionTypes;
  } }), Object.defineProperty(e, "isMsgWithdrawDelegatorRewardEncodeObject", { enumerable: !0, get: function() {
    return w.isMsgWithdrawDelegatorRewardEncodeObject;
  } });
  var N = go;
  Object.defineProperty(e, "setupDistributionExtension", { enumerable: !0, get: function() {
    return N.setupDistributionExtension;
  } });
  var h = rr;
  Object.defineProperty(e, "createEvidenceAminoConverters", { enumerable: !0, get: function() {
    return h.createEvidenceAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgSubmitEvidence", { enumerable: !0, get: function() {
    return h.isAminoMsgSubmitEvidence;
  } });
  var P = So;
  Object.defineProperty(e, "createFeegrantAminoConverters", { enumerable: !0, get: function() {
    return P.createFeegrantAminoConverters;
  } });
  var b = ko;
  Object.defineProperty(e, "feegrantTypes", { enumerable: !0, get: function() {
    return b.feegrantTypes;
  } });
  var c = Po;
  Object.defineProperty(e, "setupFeegrantExtension", { enumerable: !0, get: function() {
    return c.setupFeegrantExtension;
  } });
  var l = mn;
  Object.defineProperty(e, "createGovAminoConverters", { enumerable: !0, get: function() {
    return l.createGovAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgDeposit", { enumerable: !0, get: function() {
    return l.isAminoMsgDeposit;
  } }), Object.defineProperty(e, "isAminoMsgSubmitProposal", { enumerable: !0, get: function() {
    return l.isAminoMsgSubmitProposal;
  } }), Object.defineProperty(e, "isAminoMsgVote", { enumerable: !0, get: function() {
    return l.isAminoMsgVote;
  } }), Object.defineProperty(e, "isAminoMsgVoteWeighted", { enumerable: !0, get: function() {
    return l.isAminoMsgVoteWeighted;
  } });
  var y = gn;
  Object.defineProperty(e, "govTypes", { enumerable: !0, get: function() {
    return y.govTypes;
  } }), Object.defineProperty(e, "isMsgDepositEncodeObject", { enumerable: !0, get: function() {
    return y.isMsgDepositEncodeObject;
  } }), Object.defineProperty(e, "isMsgSubmitProposalEncodeObject", { enumerable: !0, get: function() {
    return y.isMsgSubmitProposalEncodeObject;
  } }), Object.defineProperty(e, "isMsgVoteEncodeObject", { enumerable: !0, get: function() {
    return y.isMsgVoteEncodeObject;
  } }), Object.defineProperty(e, "isMsgVoteWeightedEncodeObject", { enumerable: !0, get: function() {
    return y.isMsgVoteWeightedEncodeObject;
  } });
  var E = Ro;
  Object.defineProperty(e, "setupGovExtension", { enumerable: !0, get: function() {
    return E.setupGovExtension;
  } });
  var J = Bo;
  Object.defineProperty(e, "createGroupAminoConverters", { enumerable: !0, get: function() {
    return J.createGroupAminoConverters;
  } });
  var _ = Oo;
  Object.defineProperty(e, "groupTypes", { enumerable: !0, get: function() {
    return _.groupTypes;
  } });
  var V = ir;
  Object.defineProperty(e, "createIbcAminoConverters", { enumerable: !0, get: function() {
    return V.createIbcAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgTransfer", { enumerable: !0, get: function() {
    return V.isAminoMsgTransfer;
  } });
  var o = or;
  Object.defineProperty(e, "ibcTypes", { enumerable: !0, get: function() {
    return o.ibcTypes;
  } }), Object.defineProperty(e, "isMsgTransferEncodeObject", { enumerable: !0, get: function() {
    return o.isMsgTransferEncodeObject;
  } });
  var p = Io;
  Object.defineProperty(e, "setupIbcExtension", { enumerable: !0, get: function() {
    return p.setupIbcExtension;
  } });
  var I = Co;
  Object.defineProperty(e, "setupMintExtension", { enumerable: !0, get: function() {
    return I.setupMintExtension;
  } });
  var q = ar;
  Object.defineProperty(e, "createSlashingAminoConverters", { enumerable: !0, get: function() {
    return q.createSlashingAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgUnjail", { enumerable: !0, get: function() {
    return q.isAminoMsgUnjail;
  } });
  var s = No;
  Object.defineProperty(e, "setupSlashingExtension", { enumerable: !0, get: function() {
    return s.setupSlashingExtension;
  } });
  var u = Ve;
  Object.defineProperty(e, "createStakingAminoConverters", { enumerable: !0, get: function() {
    return u.createStakingAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgBeginRedelegate", { enumerable: !0, get: function() {
    return u.isAminoMsgBeginRedelegate;
  } }), Object.defineProperty(e, "isAminoMsgCreateValidator", { enumerable: !0, get: function() {
    return u.isAminoMsgCreateValidator;
  } }), Object.defineProperty(e, "isAminoMsgDelegate", { enumerable: !0, get: function() {
    return u.isAminoMsgDelegate;
  } }), Object.defineProperty(e, "isAminoMsgEditValidator", { enumerable: !0, get: function() {
    return u.isAminoMsgEditValidator;
  } }), Object.defineProperty(e, "isAminoMsgUndelegate", { enumerable: !0, get: function() {
    return u.isAminoMsgUndelegate;
  } });
  var A = je;
  Object.defineProperty(e, "isMsgBeginRedelegateEncodeObject", { enumerable: !0, get: function() {
    return A.isMsgBeginRedelegateEncodeObject;
  } }), Object.defineProperty(e, "isMsgCreateValidatorEncodeObject", { enumerable: !0, get: function() {
    return A.isMsgCreateValidatorEncodeObject;
  } }), Object.defineProperty(e, "isMsgDelegateEncodeObject", { enumerable: !0, get: function() {
    return A.isMsgDelegateEncodeObject;
  } }), Object.defineProperty(e, "isMsgEditValidatorEncodeObject", { enumerable: !0, get: function() {
    return A.isMsgEditValidatorEncodeObject;
  } }), Object.defineProperty(e, "isMsgUndelegateEncodeObject", { enumerable: !0, get: function() {
    return A.isMsgUndelegateEncodeObject;
  } }), Object.defineProperty(e, "stakingTypes", { enumerable: !0, get: function() {
    return A.stakingTypes;
  } });
  var R = wo;
  Object.defineProperty(e, "setupStakingExtension", { enumerable: !0, get: function() {
    return R.setupStakingExtension;
  } });
  var v = _o;
  Object.defineProperty(e, "setupTxExtension", { enumerable: !0, get: function() {
    return v.setupTxExtension;
  } });
  var D = dr;
  Object.defineProperty(e, "createVestingAminoConverters", { enumerable: !0, get: function() {
    return D.createVestingAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgCreateVestingAccount", { enumerable: !0, get: function() {
    return D.isAminoMsgCreateVestingAccount;
  } });
  var W = Eo;
  Object.defineProperty(e, "vestingTypes", { enumerable: !0, get: function() {
    return W.vestingTypes;
  } });
})(Qr);
var ft = {};
Object.defineProperty(ft, "__esModule", { value: !0 });
ft.makeMultisignedTxBytes = ft.makeMultisignedTx = ft.makeCompactBitArray = void 0;
const hg = Xi, yg = Ct, mg = Nt, qs = Pp, gg = ed, Uu = xr, bl = xr;
function Al(e) {
  const n = Math.ceil(e.length / 8), r = e.length - Math.floor(e.length / 8) * 8, t = new Uint8Array(n);
  return e.forEach((i, f) => {
    const k = Math.floor(f / 8), C = f % 8;
    i && (t[k] |= 1 << 8 - 1 - C);
  }), qs.CompactBitArray.fromPartial({ elems: t, extraBitsStored: r });
}
ft.makeCompactBitArray = Al;
function Il(e, n, r, t, i) {
  const f = Array.from(i.keys()), k = (0, yg.fromBech32)(f[0]).prefix, C = Array(e.value.pubkeys.length).fill(!1), T = new Array();
  for (let P = 0; P < e.value.pubkeys.length; P++) {
    const b = (0, hg.pubkeyToAddress)(e.value.pubkeys[P], k), c = i.get(b);
    c && (C[P] = !0, T.push(c));
  }
  const U = {
    publicKey: (0, mg.encodePubkey)(e),
    modeInfo: {
      multi: {
        bitarray: Al(C),
        modeInfos: T.map((P) => ({ single: { mode: gg.SignMode.SIGN_MODE_LEGACY_AMINO_JSON } }))
      }
    },
    sequence: BigInt(n)
  }, w = Uu.AuthInfo.fromPartial({
    signerInfos: [U],
    fee: {
      amount: [...r.amount],
      gasLimit: BigInt(r.gas)
    }
  }), N = Uu.AuthInfo.encode(w).finish();
  return bl.TxRaw.fromPartial({
    bodyBytes: t,
    authInfoBytes: N,
    signatures: [qs.MultiSignature.encode(qs.MultiSignature.fromPartial({ signatures: T })).finish()]
  });
}
ft.makeMultisignedTx = Il;
function Sg(e, n, r, t, i) {
  const f = Il(e, n, r, t, i);
  return Uint8Array.from(bl.TxRaw.encode(f).finish());
}
ft.makeMultisignedTxBytes = Sg;
var ni = {};
Object.defineProperty(ni, "__esModule", { value: !0 });
ni.isSearchTxQueryArray = void 0;
function kg(e) {
  return Array.isArray(e);
}
ni.isSearchTxQueryArray = kg;
var Tl = {}, bd = {}, qn = {}, ti = {}, Vn = {}, $e = {}, ur = {};
Object.defineProperty(ur, "__esModule", { value: !0 });
ur.fromAscii = ur.toAscii = void 0;
function Pg(e) {
  const n = (r) => r.split("").map((t) => {
    const i = t.charCodeAt(0);
    if (i < 32 || i > 126)
      throw new Error("Cannot encode character that is out of printable ASCII range: " + i);
    return i;
  });
  return Uint8Array.from(n(e));
}
ur.toAscii = Pg;
function vg(e) {
  return ((r) => r.map((t) => {
    if (t < 32 || t > 126)
      throw new Error("Cannot decode character that is out of printable ASCII range: " + t);
    return String.fromCharCode(t);
  }))(Array.from(e)).join("");
}
ur.fromAscii = vg;
var cr = {}, Rg = j && j.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), Bg = j && j.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), Og = j && j.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var r in e)
      r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && Rg(n, e, r);
  return Bg(n, e), n;
};
Object.defineProperty(cr, "__esModule", { value: !0 });
cr.fromBase64 = cr.toBase64 = void 0;
const Cl = Og(vp);
function bg(e) {
  return Cl.fromByteArray(e);
}
cr.toBase64 = bg;
function Ag(e) {
  if (!e.match(/^[a-zA-Z0-9+/]*={0,2}$/))
    throw new Error("Invalid base64 string format");
  return Cl.toByteArray(e);
}
cr.fromBase64 = Ag;
var pt = {}, Ig = j && j.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), Tg = j && j.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), Cg = j && j.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var r in e)
      r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && Ig(n, e, r);
  return Tg(n, e), n;
};
Object.defineProperty(pt, "__esModule", { value: !0 });
pt.normalizeBech32 = pt.fromBech32 = pt.toBech32 = void 0;
const Wi = Cg(Rp);
function Nl(e, n, r) {
  return Wi.encode(e, Wi.toWords(n), r);
}
pt.toBech32 = Nl;
function wl(e, n = 1 / 0) {
  const r = Wi.decode(e, n);
  return {
    prefix: r.prefix,
    data: new Uint8Array(Wi.fromWords(r.words))
  };
}
pt.fromBech32 = wl;
function Ng(e) {
  const { prefix: n, data: r } = wl(e);
  return Nl(n, r);
}
pt.normalizeBech32 = Ng;
var lr = {};
Object.defineProperty(lr, "__esModule", { value: !0 });
lr.fromHex = lr.toHex = void 0;
function wg(e) {
  let n = "";
  for (const r of e)
    n += ("0" + r.toString(16)).slice(-2);
  return n;
}
lr.toHex = wg;
function _g(e) {
  if (e.length % 2 !== 0)
    throw new Error("hex string length must be a multiple of 2");
  const n = new Uint8Array(e.length / 2);
  for (let r = 0; r < n.length; r++) {
    const t = 2 * r, i = e.slice(t, t + 2);
    if (!i.match(/[0-9a-f]{2}/i))
      throw new Error("hex string contains invalid characters");
    n[r] = parseInt(i, 16);
  }
  return n;
}
lr.fromHex = _g;
var fr = {};
Object.defineProperty(fr, "__esModule", { value: !0 });
fr.toRfc3339 = fr.fromRfc3339 = void 0;
const Eg = /^(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(\.\d{1,9})?((?:[+-]\d{2}:\d{2})|Z)$/;
function qt(e, n = 2) {
  return e.toString().padStart(n, "0");
}
function Jg(e) {
  const n = Eg.exec(e);
  if (!n)
    throw new Error("Date string is not in RFC3339 format");
  const r = +n[1], t = +n[2], i = +n[3], f = +n[4], k = +n[5], C = +n[6], T = n[7] ? Math.floor(+n[7] * 1e3) : 0;
  let U, w, N;
  n[8] === "Z" ? (U = 1, w = 0, N = 0) : (U = n[8].substring(0, 1) === "-" ? -1 : 1, w = +n[8].substring(1, 3), N = +n[8].substring(4, 6));
  const h = U * (w * 60 + N) * 60, P = /* @__PURE__ */ new Date();
  return P.setUTCFullYear(r, t - 1, i), P.setUTCHours(f, k, C, T), new Date(P.getTime() - h * 1e3);
}
fr.fromRfc3339 = Jg;
function Ug(e) {
  const n = e.getUTCFullYear(), r = qt(e.getUTCMonth() + 1), t = qt(e.getUTCDate()), i = qt(e.getUTCHours()), f = qt(e.getUTCMinutes()), k = qt(e.getUTCSeconds()), C = qt(e.getUTCMilliseconds(), 3);
  return `${n}-${r}-${t}T${i}:${f}:${k}.${C}Z`;
}
fr.toRfc3339 = Ug;
var pr = {};
Object.defineProperty(pr, "__esModule", { value: !0 });
pr.fromUtf8 = pr.toUtf8 = void 0;
function Dg(e) {
  return new TextEncoder().encode(e);
}
pr.toUtf8 = Dg;
function Mg(e, n = !1) {
  const r = !n;
  return new TextDecoder("utf-8", { fatal: r }).decode(e);
}
pr.fromUtf8 = Mg;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.toUtf8 = e.fromUtf8 = e.toRfc3339 = e.fromRfc3339 = e.toHex = e.fromHex = e.toBech32 = e.normalizeBech32 = e.fromBech32 = e.toBase64 = e.fromBase64 = e.toAscii = e.fromAscii = void 0;
  var n = ur;
  Object.defineProperty(e, "fromAscii", { enumerable: !0, get: function() {
    return n.fromAscii;
  } }), Object.defineProperty(e, "toAscii", { enumerable: !0, get: function() {
    return n.toAscii;
  } });
  var r = cr;
  Object.defineProperty(e, "fromBase64", { enumerable: !0, get: function() {
    return r.fromBase64;
  } }), Object.defineProperty(e, "toBase64", { enumerable: !0, get: function() {
    return r.toBase64;
  } });
  var t = pt;
  Object.defineProperty(e, "fromBech32", { enumerable: !0, get: function() {
    return t.fromBech32;
  } }), Object.defineProperty(e, "normalizeBech32", { enumerable: !0, get: function() {
    return t.normalizeBech32;
  } }), Object.defineProperty(e, "toBech32", { enumerable: !0, get: function() {
    return t.toBech32;
  } });
  var i = lr;
  Object.defineProperty(e, "fromHex", { enumerable: !0, get: function() {
    return i.fromHex;
  } }), Object.defineProperty(e, "toHex", { enumerable: !0, get: function() {
    return i.toHex;
  } });
  var f = fr;
  Object.defineProperty(e, "fromRfc3339", { enumerable: !0, get: function() {
    return f.fromRfc3339;
  } }), Object.defineProperty(e, "toRfc3339", { enumerable: !0, get: function() {
    return f.toRfc3339;
  } });
  var k = pr;
  Object.defineProperty(e, "fromUtf8", { enumerable: !0, get: function() {
    return k.fromUtf8;
  } }), Object.defineProperty(e, "toUtf8", { enumerable: !0, get: function() {
    return k.toUtf8;
  } });
})($e);
var en = {}, Hg = j && j.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), qg = j && j.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), Vg = j && j.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var r in e)
      r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && Hg(n, e, r);
  return qg(n, e), n;
};
Object.defineProperty(en, "__esModule", { value: !0 });
en.pbkdf2Sha512 = en.pbkdf2Sha512Noble = en.pbkdf2Sha512NodeCrypto = en.pbkdf2Sha512Subtle = en.getSubtle = en.getNodeCrypto = void 0;
const Bt = an, Qg = Bp, Wg = nd;
async function _l() {
  try {
    const e = await Promise.resolve().then(() => Vg(ic()));
    return typeof e == "object" && Object.keys(e).length <= 1 ? void 0 : e;
  } catch {
    return;
  }
}
en.getNodeCrypto = _l;
async function El() {
  var n, r, t;
  let e = (n = globalThis == null ? void 0 : globalThis.crypto) == null ? void 0 : n.subtle;
  return e || (e = (t = (r = globalThis == null ? void 0 : globalThis.crypto) == null ? void 0 : r.webcrypto) == null ? void 0 : t.subtle), e;
}
en.getSubtle = El;
async function Jl(e, n, r, t, i) {
  return (0, Bt.assert)(e, "Argument subtle is falsy"), (0, Bt.assert)(typeof e == "object", "Argument subtle is not of type object"), (0, Bt.assert)(typeof e.importKey == "function", "subtle.importKey is not a function"), (0, Bt.assert)(typeof e.deriveBits == "function", "subtle.deriveBits is not a function"), e.importKey("raw", n, { name: "PBKDF2" }, !1, ["deriveBits"]).then((f) => e.deriveBits({
    name: "PBKDF2",
    salt: r,
    iterations: t,
    hash: { name: "SHA-512" }
  }, f, i * 8).then((k) => new Uint8Array(k)));
}
en.pbkdf2Sha512Subtle = Jl;
async function Ul(e, n, r, t, i) {
  return (0, Bt.assert)(e, "Argument nodeCrypto is falsy"), (0, Bt.assert)(typeof e == "object", "Argument nodeCrypto is not of type object"), (0, Bt.assert)(typeof e.pbkdf2 == "function", "nodeCrypto.pbkdf2 is not a function"), new Promise((f, k) => {
    e.pbkdf2(n, r, t, i, "sha512", (C, T) => {
      C ? k(C) : f(Uint8Array.from(T));
    });
  });
}
en.pbkdf2Sha512NodeCrypto = Ul;
async function Dl(e, n, r, t) {
  return (0, Qg.pbkdf2Async)(Wg.sha512, e, n, { c: r, dkLen: t });
}
en.pbkdf2Sha512Noble = Dl;
async function Fg(e, n, r, t) {
  const i = await El();
  if (i)
    return Jl(i, e, n, r, t);
  {
    const f = await _l();
    return f ? Ul(f, e, n, r, t) : Dl(e, n, r, t);
  }
}
en.pbkdf2Sha512 = Fg;
var Rn = {}, Ar = {};
Object.defineProperty(Ar, "__esModule", { value: !0 });
Ar.toRealUint8Array = void 0;
function Lg(e) {
  return e instanceof Uint8Array ? e : Uint8Array.from(e);
}
Ar.toRealUint8Array = Lg;
Object.defineProperty(Rn, "__esModule", { value: !0 });
Rn.sha512 = Rn.Sha512 = Rn.sha256 = Rn.Sha256 = void 0;
const Gg = sc, $g = nd, Ml = Ar;
class Hl {
  constructor(n) {
    this.blockSize = 512 / 8, this.impl = Gg.sha256.create(), n && this.update(n);
  }
  update(n) {
    return this.impl.update((0, Ml.toRealUint8Array)(n)), this;
  }
  digest() {
    return this.impl.digest();
  }
}
Rn.Sha256 = Hl;
function zg(e) {
  return new Hl(e).digest();
}
Rn.sha256 = zg;
class ql {
  constructor(n) {
    this.blockSize = 1024 / 8, this.impl = $g.sha512.create(), n && this.update(n);
  }
  update(n) {
    return this.impl.update((0, Ml.toRealUint8Array)(n)), this;
  }
  digest() {
    return this.impl.digest();
  }
}
Rn.Sha512 = ql;
function Kg(e) {
  return new ql(e).digest();
}
Rn.sha512 = Kg;
Object.defineProperty(Vn, "__esModule", { value: !0 });
Vn.Bip39 = Vn.EnglishMnemonic = Vn.mnemonicToEntropy = Vn.entropyToMnemonic = void 0;
const Du = $e, xg = en, Zg = Rn, Ad = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];
function Vl(e) {
  return Array.from(e).map((n) => n.toString(2).padStart(8, "0")).join("");
}
function Ql(e) {
  const r = e.length * 8 / 32, t = (0, Zg.sha256)(e);
  return Vl(t).slice(0, r);
}
function Wl(e) {
  return parseInt(e, 2);
}
const Yg = [16, 20, 24, 28, 32], Xg = [12, 15, 18, 21, 24];
function Fl(e) {
  if (Yg.indexOf(e.length) === -1)
    throw new Error("invalid input length");
  const n = Vl(e), r = Ql(e);
  return (n + r).match(/(.{11})/g).map((k) => {
    const C = Wl(k);
    return Ad[C];
  }).join(" ");
}
Vn.entropyToMnemonic = Fl;
const jg = "Invalid number of words", eS = "Found word that is not in the wordlist", nS = "Invalid entropy", tS = "Invalid mnemonic checksum";
function Vs(e) {
  return e.normalize("NFKD");
}
function Id(e) {
  const n = Vs(e).split(" ");
  if (!Xg.includes(n.length))
    throw new Error(jg);
  const r = n.map((U) => {
    const w = Ad.indexOf(U);
    if (w === -1)
      throw new Error(eS);
    return w.toString(2).padStart(11, "0");
  }).join(""), t = Math.floor(r.length / 33) * 32, i = r.slice(0, t), f = r.slice(t), k = i.match(/(.{1,8})/g).map(Wl);
  if (k.length < 16 || k.length > 32 || k.length % 4 !== 0)
    throw new Error(nS);
  const C = Uint8Array.from(k);
  if (Ql(C) !== f)
    throw new Error(tS);
  return C;
}
Vn.mnemonicToEntropy = Id;
class It {
  constructor(n) {
    if (!It.mnemonicMatcher.test(n))
      throw new Error("Invalid mnemonic format");
    const r = n.split(" "), t = [12, 15, 18, 21, 24];
    if (t.indexOf(r.length) === -1)
      throw new Error(`Invalid word count in mnemonic (allowed: ${t} got: ${r.length})`);
    for (const i of r)
      if (It.wordlist.indexOf(i) === -1)
        throw new Error("Mnemonic contains invalid word");
    Id(n), this.data = n;
  }
  toString() {
    return this.data;
  }
}
Vn.EnglishMnemonic = It;
It.wordlist = Ad;
It.mnemonicMatcher = /^[a-z]+( [a-z]+)*$/;
class rS {
  /**
   * Encodes raw entropy of length 16, 20, 24, 28 or 32 bytes as an English mnemonic between 12 and 24 words.
   *
   * | Entropy            | Words |
   * |--------------------|-------|
   * | 128 bit (16 bytes) |    12 |
   * | 160 bit (20 bytes) |    15 |
   * | 192 bit (24 bytes) |    18 |
   * | 224 bit (28 bytes) |    21 |
   * | 256 bit (32 bytes) |    24 |
   *
   *
   * @see https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#generating-the-mnemonic
   * @param entropy The entropy to be encoded. This must be cryptographically secure.
   */
  static encode(n) {
    return new It(Fl(n));
  }
  static decode(n) {
    return Id(n.toString());
  }
  static async mnemonicToSeed(n, r) {
    const t = (0, Du.toUtf8)(Vs(n.toString())), i = "mnemonic" + (r ? Vs(r) : ""), f = (0, Du.toUtf8)(i);
    return (0, xg.pbkdf2Sha512)(t, f, 2048, 64);
  }
}
Vn.Bip39 = rS;
var ri = {};
Object.defineProperty(ri, "__esModule", { value: !0 });
ri.Hmac = void 0;
class iS {
  constructor(n, r) {
    const t = new n().blockSize;
    this.hash = (f) => new n().update(f).digest();
    let i = r;
    if (i.length > t && (i = this.hash(i)), i.length < t) {
      const f = new Uint8Array(t - i.length);
      i = new Uint8Array([...i, ...f]);
    }
    this.oKeyPad = i.map((f) => f ^ 92), this.iKeyPad = i.map((f) => f ^ 54), this.messageHasher = new n(), this.blockSize = t, this.update(this.iKeyPad);
  }
  update(n) {
    return this.messageHasher.update(n), this;
  }
  digest() {
    const n = this.messageHasher.digest();
    return this.hash(new Uint8Array([...this.oKeyPad, ...n]));
  }
}
ri.Hmac = iS;
var hr = {};
Object.defineProperty(hr, "__esModule", { value: !0 });
hr.keccak256 = hr.Keccak256 = void 0;
const oS = Op, aS = Ar;
class Ll {
  constructor(n) {
    this.blockSize = 512 / 8, this.impl = oS.keccak_256.create(), n && this.update(n);
  }
  update(n) {
    return this.impl.update((0, aS.toRealUint8Array)(n)), this;
  }
  digest() {
    return this.impl.digest();
  }
}
hr.Keccak256 = Ll;
function sS(e) {
  return new Ll(e).digest();
}
hr.keccak256 = sS;
var nn = {}, dS = j && j.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(nn, "__esModule", { value: !0 });
nn.Xchacha20poly1305Ietf = nn.xchacha20NonceLength = nn.Ed25519 = nn.Ed25519Keypair = nn.Argon2id = nn.isArgon2idOptions = void 0;
const uS = an, dn = dS(bp);
function cS(e) {
  return !(!(0, uS.isNonNullObject)(e) || typeof e.outputLength != "number" || typeof e.opsLimit != "number" || typeof e.memLimitKib != "number");
}
nn.isArgon2idOptions = cS;
class lS {
  static async execute(n, r, t) {
    return await dn.default.ready, dn.default.crypto_pwhash(
      t.outputLength,
      n,
      r,
      // libsodium only supports 16 byte salts and will throw when you don't respect that
      t.opsLimit,
      t.memLimitKib * 1024,
      dn.default.crypto_pwhash_ALG_ARGON2ID13
    );
  }
}
nn.Argon2id = lS;
class Jo {
  // a libsodium privkey has the format `<ed25519 privkey> + <ed25519 pubkey>`
  static fromLibsodiumPrivkey(n) {
    if (n.length !== 64)
      throw new Error(`Unexpected key length ${n.length}. Must be 64.`);
    return new Jo(n.slice(0, 32), n.slice(32, 64));
  }
  constructor(n, r) {
    this.privkey = n, this.pubkey = r;
  }
  toLibsodiumPrivkey() {
    return new Uint8Array([...this.privkey, ...this.pubkey]);
  }
}
nn.Ed25519Keypair = Jo;
class fS {
  /**
   * Generates a keypair deterministically from a given 32 bytes seed.
   *
   * This seed equals the Ed25519 private key.
   * For implementation details see crypto_sign_seed_keypair in
   * https://download.libsodium.org/doc/public-key_cryptography/public-key_signatures.html
   * and diagram on https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
   */
  static async makeKeypair(n) {
    await dn.default.ready;
    const r = dn.default.crypto_sign_seed_keypair(n);
    return Jo.fromLibsodiumPrivkey(r.privateKey);
  }
  static async createSignature(n, r) {
    return await dn.default.ready, dn.default.crypto_sign_detached(n, r.toLibsodiumPrivkey());
  }
  static async verifySignature(n, r, t) {
    return await dn.default.ready, dn.default.crypto_sign_verify_detached(n, r, t);
  }
}
nn.Ed25519 = fS;
nn.xchacha20NonceLength = 24;
class pS {
  static async encrypt(n, r, t) {
    await dn.default.ready;
    const i = null;
    return dn.default.crypto_aead_xchacha20poly1305_ietf_encrypt(
      n,
      i,
      null,
      // secret nonce: unused and should be null (https://download.libsodium.org/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction)
      t,
      r
    );
  }
  static async decrypt(n, r, t) {
    await dn.default.ready;
    const i = null;
    return dn.default.crypto_aead_xchacha20poly1305_ietf_decrypt(
      null,
      // secret nonce: unused and should be null (https://download.libsodium.org/doc/secret-key_cryptography/aead/chacha20-poly1305/xchacha20-poly1305_construction)
      n,
      i,
      t,
      r
    );
  }
}
nn.Xchacha20poly1305Ietf = pS;
var Uo = {};
Object.defineProperty(Uo, "__esModule", { value: !0 });
Uo.Random = void 0;
class hS {
  /**
   * Returns `count` cryptographically secure random bytes
   */
  static getBytes(n) {
    try {
      const r = typeof window == "object" ? window : self, t = typeof r.crypto < "u" ? r.crypto : r.msCrypto, i = new Uint8Array(n);
      return t.getRandomValues(i), i;
    } catch {
      try {
        const r = ic();
        return new Uint8Array([...r.randomBytes(n)]);
      } catch {
        throw new Error("No secure random number generator found");
      }
    }
  }
}
Uo.Random = hS;
var yr = {};
Object.defineProperty(yr, "__esModule", { value: !0 });
yr.ripemd160 = yr.Ripemd160 = void 0;
const yS = ac, mS = Ar;
class Gl {
  constructor(n) {
    this.blockSize = 512 / 8, this.impl = yS.ripemd160.create(), n && this.update(n);
  }
  update(n) {
    return this.impl.update((0, mS.toRealUint8Array)(n)), this;
  }
  digest() {
    return this.impl.digest();
  }
}
yr.Ripemd160 = Gl;
function gS(e) {
  return new Gl(e).digest();
}
yr.ripemd160 = gS;
var Do = {}, Tt = {};
Object.defineProperty(Tt, "__esModule", { value: !0 });
Tt.ExtendedSecp256k1Signature = Tt.Secp256k1Signature = void 0;
function Lt(e) {
  let n = 0;
  for (const r of e)
    if (r === 0)
      n++;
    else
      break;
  return e.slice(n);
}
const Bi = 2;
class Fr {
  /**
   * Takes the pair of integers (r, s) as 2x32 byte of binary data.
   *
   * Note: This is the format Cosmos SDK uses natively.
   *
   * @param data a 64 byte value containing integers r and s.
   */
  static fromFixedLength(n) {
    if (n.length !== 64)
      throw new Error(`Got invalid data length: ${n.length}. Expected 2x 32 bytes for the pair (r, s)`);
    return new Fr(Lt(n.slice(0, 32)), Lt(n.slice(32, 64)));
  }
  static fromDer(n) {
    let r = 0;
    if (n[r++] !== 48)
      throw new Error("Prefix 0x30 expected");
    const t = n[r++];
    if (n.length - r !== t)
      throw new Error("Data length mismatch detected");
    if (n[r++] !== Bi)
      throw new Error("INTEGER tag expected");
    const f = n[r++];
    if (f >= 128)
      throw new Error("Decoding length values above 127 not supported");
    const k = n.slice(r, r + f);
    if (r += f, n[r++] !== Bi)
      throw new Error("INTEGER tag expected");
    const T = n[r++];
    if (T >= 128)
      throw new Error("Decoding length values above 127 not supported");
    const U = n.slice(r, r + T);
    return r += T, new Fr(
      // r/s data can contain leading 0 bytes to express integers being non-negative in DER
      Lt(k),
      Lt(U)
    );
  }
  constructor(n, r) {
    if (n.length > 32 || n.length === 0 || n[0] === 0)
      throw new Error("Unsigned integer r must be encoded as unpadded big endian.");
    if (r.length > 32 || r.length === 0 || r[0] === 0)
      throw new Error("Unsigned integer s must be encoded as unpadded big endian.");
    this.data = {
      r: n,
      s: r
    };
  }
  r(n) {
    if (n === void 0)
      return this.data.r;
    {
      const r = n - this.data.r.length;
      if (r < 0)
        throw new Error("Length too small to hold parameter r");
      const t = new Uint8Array(r);
      return new Uint8Array([...t, ...this.data.r]);
    }
  }
  s(n) {
    if (n === void 0)
      return this.data.s;
    {
      const r = n - this.data.s.length;
      if (r < 0)
        throw new Error("Length too small to hold parameter s");
      const t = new Uint8Array(r);
      return new Uint8Array([...t, ...this.data.s]);
    }
  }
  toFixedLength() {
    return new Uint8Array([...this.r(32), ...this.s(32)]);
  }
  toDer() {
    const n = this.data.r[0] >= 128 ? new Uint8Array([0, ...this.data.r]) : this.data.r, r = this.data.s[0] >= 128 ? new Uint8Array([0, ...this.data.s]) : this.data.s, t = n.length, i = r.length, f = new Uint8Array([Bi, t, ...n, Bi, i, ...r]);
    return new Uint8Array([48, f.length, ...f]);
  }
}
Tt.Secp256k1Signature = Fr;
class Td extends Fr {
  /**
   * Decode extended signature from the simple fixed length encoding
   * described in toFixedLength().
   */
  static fromFixedLength(n) {
    if (n.length !== 65)
      throw new Error(`Got invalid data length ${n.length}. Expected 32 + 32 + 1`);
    return new Td(Lt(n.slice(0, 32)), Lt(n.slice(32, 64)), n[64]);
  }
  constructor(n, r, t) {
    if (super(n, r), !Number.isInteger(t))
      throw new Error("The recovery parameter must be an integer.");
    if (t < 0 || t > 4)
      throw new Error("The recovery parameter must be one of 0, 1, 2, 3.");
    this.recovery = t;
  }
  /**
   * A simple custom encoding that encodes the extended signature as
   * r (32 bytes) | s (32 bytes) | recovery param (1 byte)
   * where | denotes concatenation of bonary data.
   */
  toFixedLength() {
    return new Uint8Array([...this.r(32), ...this.s(32), this.recovery]);
  }
}
Tt.ExtendedSecp256k1Signature = Td;
var $l = j && j.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Do, "__esModule", { value: !0 });
Do.Secp256k1 = void 0;
const Oi = $e, zl = $l(Yi), SS = $l(oc()), kS = Tt, kt = new SS.default.ec("secp256k1"), PS = new zl.default("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", "hex");
class vS {
  /**
   * Takes a 32 byte private key and returns a privkey/pubkey pair.
   *
   * The resulting pubkey is uncompressed. For the use in Cosmos it should
   * be compressed first using `Secp256k1.compressPubkey`.
   */
  static async makeKeypair(n) {
    if (n.length !== 32)
      throw new Error("input data is not a valid secp256k1 private key");
    const r = kt.keyFromPrivate(n);
    if (r.validate().result !== !0)
      throw new Error("input data is not a valid secp256k1 private key");
    if (new zl.default(n).gte(PS))
      throw new Error("input data is not a valid secp256k1 private key");
    return {
      privkey: (0, Oi.fromHex)(r.getPrivate("hex")),
      // encodes uncompressed as
      // - 1-byte prefix "04"
      // - 32-byte x coordinate
      // - 32-byte y coordinate
      pubkey: Uint8Array.from(r.getPublic("array"))
    };
  }
  /**
   * Creates a signature that is
   * - deterministic (RFC 6979)
   * - lowS signature
   * - DER encoded
   */
  static async createSignature(n, r) {
    if (n.length === 0)
      throw new Error("Message hash must not be empty");
    if (n.length > 32)
      throw new Error("Message hash length must not exceed 32 bytes");
    const t = kt.keyFromPrivate(r), { r: i, s: f, recoveryParam: k } = t.sign(n, { canonical: !0 });
    if (typeof k != "number")
      throw new Error("Recovery param missing");
    return new kS.ExtendedSecp256k1Signature(Uint8Array.from(i.toArray()), Uint8Array.from(f.toArray()), k);
  }
  static async verifySignature(n, r, t) {
    if (r.length === 0)
      throw new Error("Message hash must not be empty");
    if (r.length > 32)
      throw new Error("Message hash length must not exceed 32 bytes");
    const i = kt.keyFromPublic(t);
    try {
      return i.verify(r, n.toDer());
    } catch {
      return !1;
    }
  }
  static recoverPubkey(n, r) {
    const t = { r: (0, Oi.toHex)(n.r()), s: (0, Oi.toHex)(n.s()) }, i = kt.recoverPubKey(r, t, n.recovery), f = kt.keyFromPublic(i);
    return (0, Oi.fromHex)(f.getPublic(!1, "hex"));
  }
  /**
   * Takes a compressed or uncompressed pubkey and return a compressed one.
   *
   * This function is idempotent.
   */
  static compressPubkey(n) {
    switch (n.length) {
      case 33:
        return n;
      case 65:
        return Uint8Array.from(kt.keyFromPublic(n).getPublic(!0, "array"));
      default:
        throw new Error("Invalid pubkey length");
    }
  }
  /**
   * Takes a compressed or uncompressed pubkey and returns an uncompressed one.
   *
   * This function is idempotent.
   */
  static uncompressPubkey(n) {
    switch (n.length) {
      case 33:
        return Uint8Array.from(kt.keyFromPublic(n).getPublic(!1, "array"));
      case 65:
        return n;
      default:
        throw new Error("Invalid pubkey length");
    }
  }
  static trimRecoveryByte(n) {
    switch (n.length) {
      case 64:
        return n;
      case 65:
        return n.slice(0, 64);
      default:
        throw new Error("Invalid signature length");
    }
  }
}
Do.Secp256k1 = vS;
var Kl = {}, Mo = {}, Ho = {}, RS = j && j.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Ho, "__esModule", { value: !0 });
Ho.Decimal = void 0;
const In = RS(Yi), Mu = 100;
class be {
  static fromUserInput(n, r) {
    be.verifyFractionalDigits(r);
    const t = n.match(/[^0-9.]/);
    if (t)
      throw new Error(`Invalid character at position ${t.index + 1}`);
    let i, f;
    if (n === "")
      i = "0", f = "";
    else if (n.search(/\./) === -1)
      i = n, f = "";
    else {
      const C = n.split(".");
      switch (C.length) {
        case 0:
        case 1:
          throw new Error("Fewer than two elements in split result. This must not happen here.");
        case 2:
          if (!C[1])
            throw new Error("Fractional part missing");
          i = C[0], f = C[1].replace(/0+$/, "");
          break;
        default:
          throw new Error("More than one separator found");
      }
    }
    if (f.length > r)
      throw new Error("Got more fractional digits than supported");
    const k = `${i}${f.padEnd(r, "0")}`;
    return new be(k, r);
  }
  static fromAtomics(n, r) {
    return be.verifyFractionalDigits(r), new be(n, r);
  }
  /**
   * Creates a Decimal with value 0.0 and the given number of fractial digits.
   *
   * Fractional digits are not relevant for the value but needed to be able
   * to perform arithmetic operations with other decimals.
   */
  static zero(n) {
    return be.verifyFractionalDigits(n), new be("0", n);
  }
  /**
   * Creates a Decimal with value 1.0 and the given number of fractial digits.
   *
   * Fractional digits are not relevant for the value but needed to be able
   * to perform arithmetic operations with other decimals.
   */
  static one(n) {
    return be.verifyFractionalDigits(n), new be("1" + "0".repeat(n), n);
  }
  static verifyFractionalDigits(n) {
    if (!Number.isInteger(n))
      throw new Error("Fractional digits is not an integer");
    if (n < 0)
      throw new Error("Fractional digits must not be negative");
    if (n > Mu)
      throw new Error(`Fractional digits must not exceed ${Mu}`);
  }
  static compare(n, r) {
    if (n.fractionalDigits !== r.fractionalDigits)
      throw new Error("Fractional digits do not match");
    return n.data.atomics.cmp(new In.default(r.atomics));
  }
  get atomics() {
    return this.data.atomics.toString();
  }
  get fractionalDigits() {
    return this.data.fractionalDigits;
  }
  constructor(n, r) {
    if (!n.match(/^[0-9]+$/))
      throw new Error("Invalid string format. Only non-negative integers in decimal representation supported.");
    this.data = {
      atomics: new In.default(n),
      fractionalDigits: r
    };
  }
  /** Creates a new instance with the same value */
  clone() {
    return new be(this.atomics, this.fractionalDigits);
  }
  /** Returns the greatest decimal <= this which has no fractional part (rounding down) */
  floor() {
    const n = new In.default(10).pow(new In.default(this.data.fractionalDigits)), r = this.data.atomics.div(n);
    return this.data.atomics.mod(n).isZero() ? this.clone() : be.fromAtomics(r.mul(n).toString(), this.fractionalDigits);
  }
  /** Returns the smallest decimal >= this which has no fractional part (rounding up) */
  ceil() {
    const n = new In.default(10).pow(new In.default(this.data.fractionalDigits)), r = this.data.atomics.div(n);
    return this.data.atomics.mod(n).isZero() ? this.clone() : be.fromAtomics(r.addn(1).mul(n).toString(), this.fractionalDigits);
  }
  toString() {
    const n = new In.default(10).pow(new In.default(this.data.fractionalDigits)), r = this.data.atomics.div(n), t = this.data.atomics.mod(n);
    if (t.isZero())
      return r.toString();
    {
      const f = t.toString().padStart(this.data.fractionalDigits, "0").replace(/0+$/, "");
      return `${r.toString()}.${f}`;
    }
  }
  /**
   * Returns an approximation as a float type. Only use this if no
   * exact calculation is required.
   */
  toFloatApproximation() {
    const n = Number(this.toString());
    if (Number.isNaN(n))
      throw new Error("Conversion to number failed");
    return n;
  }
  /**
   * a.plus(b) returns a+b.
   *
   * Both values need to have the same fractional digits.
   */
  plus(n) {
    if (this.fractionalDigits !== n.fractionalDigits)
      throw new Error("Fractional digits do not match");
    const r = this.data.atomics.add(new In.default(n.atomics));
    return new be(r.toString(), this.fractionalDigits);
  }
  /**
   * a.minus(b) returns a-b.
   *
   * Both values need to have the same fractional digits.
   * The resulting difference needs to be non-negative.
   */
  minus(n) {
    if (this.fractionalDigits !== n.fractionalDigits)
      throw new Error("Fractional digits do not match");
    const r = this.data.atomics.sub(new In.default(n.atomics));
    if (r.ltn(0))
      throw new Error("Difference must not be negative");
    return new be(r.toString(), this.fractionalDigits);
  }
  /**
   * a.multiply(b) returns a*b.
   *
   * We only allow multiplication by unsigned integers to avoid rounding errors.
   */
  multiply(n) {
    const r = this.data.atomics.mul(new In.default(n.toString()));
    return new be(r.toString(), this.fractionalDigits);
  }
  equals(n) {
    return be.compare(this, n) === 0;
  }
  isLessThan(n) {
    return be.compare(this, n) < 0;
  }
  isLessThanOrEqual(n) {
    return be.compare(this, n) <= 0;
  }
  isGreaterThan(n) {
    return be.compare(this, n) > 0;
  }
  isGreaterThanOrEqual(n) {
    return be.compare(this, n) >= 0;
  }
}
Ho.Decimal = be;
var Qn = {}, BS = j && j.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Qn, "__esModule", { value: !0 });
Qn.Uint64 = Qn.Uint53 = Qn.Int53 = Qn.Uint32 = void 0;
const Ui = BS(Yi), OS = new Ui.default("18446744073709551615", 10, "be");
class qr {
  /** @deprecated use Uint32.fromBytes */
  static fromBigEndianBytes(n) {
    return qr.fromBytes(n);
  }
  /**
   * Creates a Uint32 from a fixed length byte array.
   *
   * @param bytes a list of exactly 4 bytes
   * @param endianess defaults to big endian
   */
  static fromBytes(n, r = "be") {
    if (n.length !== 4)
      throw new Error("Invalid input length. Expected 4 bytes.");
    for (let i = 0; i < n.length; ++i)
      if (!Number.isInteger(n[i]) || n[i] > 255 || n[i] < 0)
        throw new Error("Invalid value in byte. Found: " + n[i]);
    const t = r === "be" ? n : Array.from(n).reverse();
    return new qr(t[0] * 2 ** 24 + t[1] * 2 ** 16 + t[2] * 2 ** 8 + t[3]);
  }
  static fromString(n) {
    if (!n.match(/^[0-9]+$/))
      throw new Error("Invalid string format");
    return new qr(Number.parseInt(n, 10));
  }
  constructor(n) {
    if (Number.isNaN(n))
      throw new Error("Input is not a number");
    if (!Number.isInteger(n))
      throw new Error("Input is not an integer");
    if (n < 0 || n > 4294967295)
      throw new Error("Input not in uint32 range: " + n.toString());
    this.data = n;
  }
  toBytesBigEndian() {
    return new Uint8Array([
      Math.floor(this.data / 2 ** 24) & 255,
      Math.floor(this.data / 2 ** 16) & 255,
      Math.floor(this.data / 2 ** 8) & 255,
      Math.floor(this.data / 2 ** 0) & 255
    ]);
  }
  toBytesLittleEndian() {
    return new Uint8Array([
      Math.floor(this.data / 2 ** 0) & 255,
      Math.floor(this.data / 2 ** 8) & 255,
      Math.floor(this.data / 2 ** 16) & 255,
      Math.floor(this.data / 2 ** 24) & 255
    ]);
  }
  toNumber() {
    return this.data;
  }
  toBigInt() {
    return BigInt(this.toNumber());
  }
  toString() {
    return this.data.toString();
  }
}
Qn.Uint32 = qr;
class Lr {
  static fromString(n) {
    if (!n.match(/^-?[0-9]+$/))
      throw new Error("Invalid string format");
    return new Lr(Number.parseInt(n, 10));
  }
  constructor(n) {
    if (Number.isNaN(n))
      throw new Error("Input is not a number");
    if (!Number.isInteger(n))
      throw new Error("Input is not an integer");
    if (n < Number.MIN_SAFE_INTEGER || n > Number.MAX_SAFE_INTEGER)
      throw new Error("Input not in int53 range: " + n.toString());
    this.data = n;
  }
  toNumber() {
    return this.data;
  }
  toBigInt() {
    return BigInt(this.toNumber());
  }
  toString() {
    return this.data.toString();
  }
}
Qn.Int53 = Lr;
class Cd {
  static fromString(n) {
    const r = Lr.fromString(n);
    return new Cd(r.toNumber());
  }
  constructor(n) {
    const r = new Lr(n);
    if (r.toNumber() < 0)
      throw new Error("Input is negative");
    this.data = r;
  }
  toNumber() {
    return this.data.toNumber();
  }
  toBigInt() {
    return BigInt(this.toNumber());
  }
  toString() {
    return this.data.toString();
  }
}
Qn.Uint53 = Cd;
class Gt {
  /** @deprecated use Uint64.fromBytes */
  static fromBytesBigEndian(n) {
    return Gt.fromBytes(n);
  }
  /**
   * Creates a Uint64 from a fixed length byte array.
   *
   * @param bytes a list of exactly 8 bytes
   * @param endianess defaults to big endian
   */
  static fromBytes(n, r = "be") {
    if (n.length !== 8)
      throw new Error("Invalid input length. Expected 8 bytes.");
    for (let i = 0; i < n.length; ++i)
      if (!Number.isInteger(n[i]) || n[i] > 255 || n[i] < 0)
        throw new Error("Invalid value in byte. Found: " + n[i]);
    const t = r === "be" ? Array.from(n) : Array.from(n).reverse();
    return new Gt(new Ui.default(t));
  }
  static fromString(n) {
    if (!n.match(/^[0-9]+$/))
      throw new Error("Invalid string format");
    return new Gt(new Ui.default(n, 10, "be"));
  }
  static fromNumber(n) {
    if (Number.isNaN(n))
      throw new Error("Input is not a number");
    if (!Number.isInteger(n))
      throw new Error("Input is not an integer");
    let r;
    try {
      r = new Ui.default(n);
    } catch {
      throw new Error("Input is not a safe integer");
    }
    return new Gt(r);
  }
  constructor(n) {
    if (n.isNeg())
      throw new Error("Input is negative");
    if (n.gt(OS))
      throw new Error("Input exceeds uint64 range");
    this.data = n;
  }
  toBytesBigEndian() {
    return Uint8Array.from(this.data.toArray("be", 8));
  }
  toBytesLittleEndian() {
    return Uint8Array.from(this.data.toArray("le", 8));
  }
  toString() {
    return this.data.toString(10);
  }
  toBigInt() {
    return BigInt(this.toString());
  }
  toNumber() {
    return this.data.toNumber();
  }
}
Qn.Uint64 = Gt;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Uint64 = e.Uint53 = e.Uint32 = e.Int53 = e.Decimal = void 0;
  var n = Ho;
  Object.defineProperty(e, "Decimal", { enumerable: !0, get: function() {
    return n.Decimal;
  } });
  var r = Qn;
  Object.defineProperty(e, "Int53", { enumerable: !0, get: function() {
    return r.Int53;
  } }), Object.defineProperty(e, "Uint32", { enumerable: !0, get: function() {
    return r.Uint32;
  } }), Object.defineProperty(e, "Uint53", { enumerable: !0, get: function() {
    return r.Uint53;
  } }), Object.defineProperty(e, "Uint64", { enumerable: !0, get: function() {
    return r.Uint64;
  } });
})(Mo);
(function(e) {
  var n = j && j.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.stringToPath = e.pathToString = e.Slip10 = e.Slip10RawIndex = e.slip10CurveFromString = e.Slip10Curve = void 0;
  const r = $e, t = Mo, i = n(Yi), f = n(oc()), k = ri, C = Rn;
  var T;
  (function(c) {
    c.Secp256k1 = "Bitcoin seed", c.Ed25519 = "ed25519 seed";
  })(T = e.Slip10Curve || (e.Slip10Curve = {}));
  function U(c) {
    switch (c) {
      case T.Ed25519:
        return T.Ed25519;
      case T.Secp256k1:
        return T.Secp256k1;
      default:
        throw new Error(`Unknown curve string: '${c}'`);
    }
  }
  e.slip10CurveFromString = U;
  class w extends t.Uint32 {
    static hardened(l) {
      return new w(l + 2 ** 31);
    }
    static normal(l) {
      return new w(l);
    }
    isHardened() {
      return this.data >= 2 ** 31;
    }
  }
  e.Slip10RawIndex = w;
  const N = new f.default.ec("secp256k1");
  class h {
    static derivePath(l, y, E) {
      let J = this.master(l, y);
      for (const _ of E)
        J = this.child(l, J.privkey, J.chainCode, _);
      return J;
    }
    static master(l, y) {
      const E = new k.Hmac(C.Sha512, (0, r.toAscii)(l)).update(y).digest(), J = E.slice(0, 32), _ = E.slice(32, 64);
      return l !== T.Ed25519 && (this.isZero(J) || this.isGteN(l, J)) ? this.master(l, E) : {
        chainCode: _,
        privkey: J
      };
    }
    static child(l, y, E, J) {
      let _;
      if (J.isHardened()) {
        const V = new Uint8Array([0, ...y, ...J.toBytesBigEndian()]);
        _ = new k.Hmac(C.Sha512, E).update(V).digest();
      } else {
        if (l === T.Ed25519)
          throw new Error("Normal keys are not allowed with ed25519");
        {
          const V = new Uint8Array([
            ...h.serializedPoint(l, new i.default(y)),
            ...J.toBytesBigEndian()
          ]);
          _ = new k.Hmac(C.Sha512, E).update(V).digest();
        }
      }
      return this.childImpl(l, y, E, J, _);
    }
    /**
     * Implementation of ser_P(point(k_par)) from BIP-0032
     *
     * @see https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
     */
    static serializedPoint(l, y) {
      switch (l) {
        case T.Secp256k1:
          return (0, r.fromHex)(N.g.mul(y).encodeCompressed("hex"));
        default:
          throw new Error("curve not supported");
      }
    }
    static childImpl(l, y, E, J, _) {
      const V = _.slice(0, 32), o = _.slice(32, 64), p = o;
      if (l === T.Ed25519)
        return {
          chainCode: p,
          privkey: V
        };
      const I = this.n(l), q = new i.default(V).add(new i.default(y)).mod(I), s = Uint8Array.from(q.toArray("be", 32));
      if (this.isGteN(l, V) || this.isZero(s)) {
        const u = new k.Hmac(C.Sha512, E).update(new Uint8Array([1, ...o, ...J.toBytesBigEndian()])).digest();
        return this.childImpl(l, y, E, J, u);
      }
      return {
        chainCode: p,
        privkey: s
      };
    }
    static isZero(l) {
      return l.every((y) => y === 0);
    }
    static isGteN(l, y) {
      return new i.default(y).gte(this.n(l));
    }
    static n(l) {
      switch (l) {
        case T.Secp256k1:
          return new i.default("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", 16);
        default:
          throw new Error("curve not supported");
      }
    }
  }
  e.Slip10 = h;
  function P(c) {
    return c.reduce((l, y) => {
      const E = y.isHardened() ? `${y.toNumber() - 2147483648}'` : y.toString();
      return l + "/" + E;
    }, "m");
  }
  e.pathToString = P;
  function b(c) {
    if (!c.startsWith("m"))
      throw new Error("Path string must start with 'm'");
    let l = c.slice(1);
    const y = new Array();
    for (; l; ) {
      const E = l.match(/^\/([0-9]+)('?)/);
      if (!E)
        throw new Error("Syntax error while reading path component");
      const [J, _, V] = E, o = t.Uint53.fromString(_).toNumber();
      if (o >= 2 ** 31)
        throw new Error("Component value too high. Must not exceed 2**31-1.");
      V ? y.push(w.hardened(o)) : y.push(w.normal(o)), l = l.slice(J.length);
    }
    return y;
  }
  e.stringToPath = b;
})(Kl);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.stringToPath = e.Slip10RawIndex = e.slip10CurveFromString = e.Slip10Curve = e.Slip10 = e.pathToString = e.sha512 = e.Sha512 = e.sha256 = e.Sha256 = e.Secp256k1Signature = e.ExtendedSecp256k1Signature = e.Secp256k1 = e.ripemd160 = e.Ripemd160 = e.Random = e.Xchacha20poly1305Ietf = e.xchacha20NonceLength = e.isArgon2idOptions = e.Ed25519Keypair = e.Ed25519 = e.Argon2id = e.keccak256 = e.Keccak256 = e.Hmac = e.EnglishMnemonic = e.Bip39 = void 0;
  var n = Vn;
  Object.defineProperty(e, "Bip39", { enumerable: !0, get: function() {
    return n.Bip39;
  } }), Object.defineProperty(e, "EnglishMnemonic", { enumerable: !0, get: function() {
    return n.EnglishMnemonic;
  } });
  var r = ri;
  Object.defineProperty(e, "Hmac", { enumerable: !0, get: function() {
    return r.Hmac;
  } });
  var t = hr;
  Object.defineProperty(e, "Keccak256", { enumerable: !0, get: function() {
    return t.Keccak256;
  } }), Object.defineProperty(e, "keccak256", { enumerable: !0, get: function() {
    return t.keccak256;
  } });
  var i = nn;
  Object.defineProperty(e, "Argon2id", { enumerable: !0, get: function() {
    return i.Argon2id;
  } }), Object.defineProperty(e, "Ed25519", { enumerable: !0, get: function() {
    return i.Ed25519;
  } }), Object.defineProperty(e, "Ed25519Keypair", { enumerable: !0, get: function() {
    return i.Ed25519Keypair;
  } }), Object.defineProperty(e, "isArgon2idOptions", { enumerable: !0, get: function() {
    return i.isArgon2idOptions;
  } }), Object.defineProperty(e, "xchacha20NonceLength", { enumerable: !0, get: function() {
    return i.xchacha20NonceLength;
  } }), Object.defineProperty(e, "Xchacha20poly1305Ietf", { enumerable: !0, get: function() {
    return i.Xchacha20poly1305Ietf;
  } });
  var f = Uo;
  Object.defineProperty(e, "Random", { enumerable: !0, get: function() {
    return f.Random;
  } });
  var k = yr;
  Object.defineProperty(e, "Ripemd160", { enumerable: !0, get: function() {
    return k.Ripemd160;
  } }), Object.defineProperty(e, "ripemd160", { enumerable: !0, get: function() {
    return k.ripemd160;
  } });
  var C = Do;
  Object.defineProperty(e, "Secp256k1", { enumerable: !0, get: function() {
    return C.Secp256k1;
  } });
  var T = Tt;
  Object.defineProperty(e, "ExtendedSecp256k1Signature", { enumerable: !0, get: function() {
    return T.ExtendedSecp256k1Signature;
  } }), Object.defineProperty(e, "Secp256k1Signature", { enumerable: !0, get: function() {
    return T.Secp256k1Signature;
  } });
  var U = Rn;
  Object.defineProperty(e, "Sha256", { enumerable: !0, get: function() {
    return U.Sha256;
  } }), Object.defineProperty(e, "sha256", { enumerable: !0, get: function() {
    return U.sha256;
  } }), Object.defineProperty(e, "Sha512", { enumerable: !0, get: function() {
    return U.Sha512;
  } }), Object.defineProperty(e, "sha512", { enumerable: !0, get: function() {
    return U.sha512;
  } });
  var w = Kl;
  Object.defineProperty(e, "pathToString", { enumerable: !0, get: function() {
    return w.pathToString;
  } }), Object.defineProperty(e, "Slip10", { enumerable: !0, get: function() {
    return w.Slip10;
  } }), Object.defineProperty(e, "Slip10Curve", { enumerable: !0, get: function() {
    return w.Slip10Curve;
  } }), Object.defineProperty(e, "slip10CurveFromString", { enumerable: !0, get: function() {
    return w.slip10CurveFromString;
  } }), Object.defineProperty(e, "Slip10RawIndex", { enumerable: !0, get: function() {
    return w.Slip10RawIndex;
  } }), Object.defineProperty(e, "stringToPath", { enumerable: !0, get: function() {
    return w.stringToPath;
  } });
})(ti);
Object.defineProperty(qn, "__esModule", { value: !0 });
qn.pubkeyToAddress = qn.pubkeyToRawAddress = qn.rawSecp256k1PubkeyToRawAddress = qn.rawEd25519PubkeyToRawAddress = void 0;
const Qs = ti, bS = $e;
function xl(e) {
  if (e.length !== 32)
    throw new Error(`Invalid Ed25519 pubkey length: ${e.length}`);
  return (0, Qs.sha256)(e).slice(0, 20);
}
qn.rawEd25519PubkeyToRawAddress = xl;
function Zl(e) {
  if (e.length !== 33)
    throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${e.length}`);
  return (0, Qs.ripemd160)((0, Qs.sha256)(e));
}
qn.rawSecp256k1PubkeyToRawAddress = Zl;
function Yl(e, n) {
  switch (e) {
    case "ed25519":
      return xl(n);
    case "secp256k1":
      return Zl(n);
    default:
      throw new Error(`Pubkey type ${e} not supported`);
  }
}
qn.pubkeyToRawAddress = Yl;
function AS(e, n) {
  return (0, bS.toHex)(Yl(e, n)).toUpperCase();
}
qn.pubkeyToAddress = AS;
var Fe = {};
Object.defineProperty(Fe, "__esModule", { value: !0 });
Fe.DateTime = Fe.toSeconds = Fe.fromSeconds = Fe.toRfc3339WithNanoseconds = Fe.fromRfc3339WithNanoseconds = void 0;
const IS = $e, TS = Mo;
function Xl(e) {
  const n = (0, IS.fromRfc3339)(e), r = e.match(/\.(\d+)Z$/), t = r ? r[1].slice(3) : "";
  return n.nanoseconds = parseInt(t.padEnd(6, "0"), 10), n;
}
Fe.fromRfc3339WithNanoseconds = Xl;
function jl(e) {
  var t;
  const n = e.toISOString(), r = ((t = e.nanoseconds) == null ? void 0 : t.toString()) ?? "";
  return `${n.slice(0, -1)}${r.padStart(6, "0")}Z`;
}
Fe.toRfc3339WithNanoseconds = jl;
function CS(e, n = 0) {
  const r = new TS.Uint32(n).toNumber();
  if (r > 999999999)
    throw new Error("Nano seconds must not exceed 999999999");
  const t = new Date(e * 1e3 + Math.floor(r / 1e6));
  return t.nanoseconds = r % 1e6, t;
}
Fe.fromSeconds = CS;
function NS(e) {
  return {
    seconds: Math.floor(e.getTime() / 1e3),
    nanos: e.getTime() % 1e3 * 1e6 + (e.nanoseconds ?? 0)
  };
}
Fe.toSeconds = NS;
class wS {
  /** @deprecated Use fromRfc3339WithNanoseconds instead */
  static decode(n) {
    return Xl(n);
  }
  /** @deprecated Use toRfc3339WithNanoseconds instead */
  static encode(n) {
    return jl(n);
  }
}
Fe.DateTime = wS;
var Fi = {}, qo = {}, Xn = {};
Object.defineProperty(Xn, "__esModule", { value: !0 });
Xn.createJsonRpcRequest = void 0;
const Hu = "123456789";
function _S() {
  return Hu[Math.floor(Math.random() * Hu.length)];
}
function ES() {
  return parseInt(Array.from({ length: 12 }).map(() => _S()).join(""), 10);
}
function JS(e, n) {
  const r = n ? { ...n } : {};
  return {
    jsonrpc: "2.0",
    id: ES(),
    method: e,
    params: r
  };
}
Xn.createJsonRpcRequest = JS;
var ii = {}, Vo = {}, Qo = {}, Wo = {};
Object.defineProperty(Wo, "__esModule", { value: !0 });
Wo.makeJsonRpcId = void 0;
let US = 1e4;
function DS() {
  return US += 1;
}
Wo.makeJsonRpcId = DS;
var Fo = {}, Kn = {};
Object.defineProperty(Kn, "__esModule", { value: !0 });
Kn.jsonRpcCode = Kn.isJsonRpcSuccessResponse = Kn.isJsonRpcErrorResponse = void 0;
function ef(e) {
  return typeof e.error == "object";
}
Kn.isJsonRpcErrorResponse = ef;
function MS(e) {
  return !ef(e);
}
Kn.isJsonRpcSuccessResponse = MS;
Kn.jsonRpcCode = {
  parseError: -32700,
  invalidRequest: -32600,
  methodNotFound: -32601,
  invalidParams: -32602,
  internalError: -32603,
  // server error (Reserved for implementation-defined server-errors.):
  // -32000 to -32099
  serverError: {
    default: -32e3
  }
};
Object.defineProperty(Fo, "__esModule", { value: !0 });
Fo.JsonRpcClient = void 0;
const HS = ei, qS = Kn;
class VS {
  constructor(n) {
    this.connection = n;
  }
  async run(n) {
    const r = this.connection.responseStream.filter((f) => f.id === n.id), t = (0, HS.firstEvent)(r);
    this.connection.sendRequest(n);
    const i = await t;
    if ((0, qS.isJsonRpcErrorResponse)(i)) {
      const f = i.error;
      throw new Error(`JSON RPC error: code=${f.code}; message='${f.message}'`);
    }
    return i;
  }
}
Fo.JsonRpcClient = VS;
var Sn = {}, ht = {};
Object.defineProperty(ht, "__esModule", { value: !0 });
ht.isJsonCompatibleDictionary = ht.isJsonCompatibleArray = ht.isJsonCompatibleValue = void 0;
function Nd(e) {
  return !!(typeof e == "string" || typeof e == "number" || typeof e == "boolean" || e === null || // eslint-disable-next-line @typescript-eslint/no-use-before-define
  nf(e) || // eslint-disable-next-line @typescript-eslint/no-use-before-define
  tf(e));
}
ht.isJsonCompatibleValue = Nd;
function nf(e) {
  if (!Array.isArray(e))
    return !1;
  for (const n of e)
    if (!Nd(n))
      return !1;
  return !0;
}
ht.isJsonCompatibleArray = nf;
function tf(e) {
  return typeof e != "object" || e === null || Object.prototype.toString.call(e) !== "[object Object]" ? !1 : Object.values(e).every(Nd);
}
ht.isJsonCompatibleDictionary = tf;
Object.defineProperty(Sn, "__esModule", { value: !0 });
Sn.parseJsonRpcResponse = Sn.parseJsonRpcSuccessResponse = Sn.parseJsonRpcErrorResponse = Sn.parseJsonRpcRequest = Sn.parseJsonRpcId = void 0;
const yt = ht;
function rf(e) {
  if (!(0, yt.isJsonCompatibleDictionary)(e))
    throw new Error("Data must be JSON compatible dictionary");
  const n = e.id;
  return typeof n != "number" && typeof n != "string" ? null : n;
}
Sn.parseJsonRpcId = rf;
function QS(e) {
  if (!(0, yt.isJsonCompatibleDictionary)(e))
    throw new Error("Data must be JSON compatible dictionary");
  if (e.jsonrpc !== "2.0")
    throw new Error(`Got unexpected jsonrpc version: ${e.jsonrpc}`);
  const n = rf(e);
  if (n === null)
    throw new Error("Invalid id field");
  const r = e.method;
  if (typeof r != "string")
    throw new Error("Invalid method field");
  if (!(0, yt.isJsonCompatibleArray)(e.params) && !(0, yt.isJsonCompatibleDictionary)(e.params))
    throw new Error("Invalid params field");
  return {
    jsonrpc: "2.0",
    id: n,
    method: r,
    params: e.params
  };
}
Sn.parseJsonRpcRequest = QS;
function WS(e) {
  if (typeof e.code != "number")
    throw new Error("Error property 'code' is not a number");
  if (typeof e.message != "string")
    throw new Error("Error property 'message' is not a string");
  let n;
  if (e.data === void 0)
    n = void 0;
  else if ((0, yt.isJsonCompatibleValue)(e.data))
    n = e.data;
  else
    throw new Error("Error property 'data' is defined but not a JSON compatible value.");
  return {
    code: e.code,
    message: e.message,
    ...n !== void 0 ? { data: n } : {}
  };
}
function of(e) {
  if (!(0, yt.isJsonCompatibleDictionary)(e))
    throw new Error("Data must be JSON compatible dictionary");
  if (e.jsonrpc !== "2.0")
    throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(e)}`);
  const n = e.id;
  if (typeof n != "number" && typeof n != "string" && n !== null)
    throw new Error("Invalid id field");
  if (typeof e.error > "u" || !(0, yt.isJsonCompatibleDictionary)(e.error))
    throw new Error("Invalid error field");
  return {
    jsonrpc: "2.0",
    id: n,
    error: WS(e.error)
  };
}
Sn.parseJsonRpcErrorResponse = of;
function af(e) {
  if (!(0, yt.isJsonCompatibleDictionary)(e))
    throw new Error("Data must be JSON compatible dictionary");
  if (e.jsonrpc !== "2.0")
    throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(e)}`);
  const n = e.id;
  if (typeof n != "number" && typeof n != "string")
    throw new Error("Invalid id field");
  if (typeof e.result > "u")
    throw new Error("Invalid result field");
  const r = e.result;
  return {
    jsonrpc: "2.0",
    id: n,
    result: r
  };
}
Sn.parseJsonRpcSuccessResponse = af;
function FS(e) {
  let n;
  try {
    n = of(e);
  } catch {
    n = af(e);
  }
  return n;
}
Sn.parseJsonRpcResponse = FS;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.jsonRpcCode = e.isJsonRpcSuccessResponse = e.isJsonRpcErrorResponse = e.parseJsonRpcSuccessResponse = e.parseJsonRpcResponse = e.parseJsonRpcRequest = e.parseJsonRpcId = e.parseJsonRpcErrorResponse = e.JsonRpcClient = e.makeJsonRpcId = void 0;
  var n = Wo;
  Object.defineProperty(e, "makeJsonRpcId", { enumerable: !0, get: function() {
    return n.makeJsonRpcId;
  } });
  var r = Fo;
  Object.defineProperty(e, "JsonRpcClient", { enumerable: !0, get: function() {
    return r.JsonRpcClient;
  } });
  var t = Sn;
  Object.defineProperty(e, "parseJsonRpcErrorResponse", { enumerable: !0, get: function() {
    return t.parseJsonRpcErrorResponse;
  } }), Object.defineProperty(e, "parseJsonRpcId", { enumerable: !0, get: function() {
    return t.parseJsonRpcId;
  } }), Object.defineProperty(e, "parseJsonRpcRequest", { enumerable: !0, get: function() {
    return t.parseJsonRpcRequest;
  } }), Object.defineProperty(e, "parseJsonRpcResponse", { enumerable: !0, get: function() {
    return t.parseJsonRpcResponse;
  } }), Object.defineProperty(e, "parseJsonRpcSuccessResponse", { enumerable: !0, get: function() {
    return t.parseJsonRpcSuccessResponse;
  } });
  var i = Kn;
  Object.defineProperty(e, "isJsonRpcErrorResponse", { enumerable: !0, get: function() {
    return i.isJsonRpcErrorResponse;
  } }), Object.defineProperty(e, "isJsonRpcSuccessResponse", { enumerable: !0, get: function() {
    return i.isJsonRpcSuccessResponse;
  } }), Object.defineProperty(e, "jsonRpcCode", { enumerable: !0, get: function() {
    return i.jsonRpcCode;
  } });
})(Qo);
var oi = {};
function sf(e, n) {
  return function() {
    return e.apply(n, arguments);
  };
}
const { toString: LS } = Object.prototype, { getPrototypeOf: wd } = Object, Lo = ((e) => (n) => {
  const r = LS.call(n);
  return e[r] || (e[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), $n = (e) => (e = e.toLowerCase(), (n) => Lo(n) === e), Go = (e) => (n) => typeof n === e, { isArray: Ir } = Array, Gr = Go("undefined");
function GS(e) {
  return e !== null && !Gr(e) && e.constructor !== null && !Gr(e.constructor) && An(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const df = $n("ArrayBuffer");
function $S(e) {
  let n;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? n = ArrayBuffer.isView(e) : n = e && e.buffer && df(e.buffer), n;
}
const zS = Go("string"), An = Go("function"), uf = Go("number"), $o = (e) => e !== null && typeof e == "object", KS = (e) => e === !0 || e === !1, Di = (e) => {
  if (Lo(e) !== "object")
    return !1;
  const n = wd(e);
  return (n === null || n === Object.prototype || Object.getPrototypeOf(n) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, xS = $n("Date"), ZS = $n("File"), YS = $n("Blob"), XS = $n("FileList"), jS = (e) => $o(e) && An(e.pipe), ek = (e) => {
  let n;
  return e && (typeof FormData == "function" && e instanceof FormData || An(e.append) && ((n = Lo(e)) === "formdata" || // detect form-data instance
  n === "object" && An(e.toString) && e.toString() === "[object FormData]"));
}, nk = $n("URLSearchParams"), tk = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function ai(e, n, { allOwnKeys: r = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let t, i;
  if (typeof e != "object" && (e = [e]), Ir(e))
    for (t = 0, i = e.length; t < i; t++)
      n.call(null, e[t], t, e);
  else {
    const f = r ? Object.getOwnPropertyNames(e) : Object.keys(e), k = f.length;
    let C;
    for (t = 0; t < k; t++)
      C = f[t], n.call(null, e[C], C, e);
  }
}
function cf(e, n) {
  n = n.toLowerCase();
  const r = Object.keys(e);
  let t = r.length, i;
  for (; t-- > 0; )
    if (i = r[t], n === i.toLowerCase())
      return i;
  return null;
}
const lf = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : j)(), ff = (e) => !Gr(e) && e !== lf;
function Ws() {
  const { caseless: e } = ff(this) && this || {}, n = {}, r = (t, i) => {
    const f = e && cf(n, i) || i;
    Di(n[f]) && Di(t) ? n[f] = Ws(n[f], t) : Di(t) ? n[f] = Ws({}, t) : Ir(t) ? n[f] = t.slice() : n[f] = t;
  };
  for (let t = 0, i = arguments.length; t < i; t++)
    arguments[t] && ai(arguments[t], r);
  return n;
}
const rk = (e, n, r, { allOwnKeys: t } = {}) => (ai(n, (i, f) => {
  r && An(i) ? e[f] = sf(i, r) : e[f] = i;
}, { allOwnKeys: t }), e), ik = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), ok = (e, n, r, t) => {
  e.prototype = Object.create(n.prototype, t), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: n.prototype
  }), r && Object.assign(e.prototype, r);
}, ak = (e, n, r, t) => {
  let i, f, k;
  const C = {};
  if (n = n || {}, e == null)
    return n;
  do {
    for (i = Object.getOwnPropertyNames(e), f = i.length; f-- > 0; )
      k = i[f], (!t || t(k, e, n)) && !C[k] && (n[k] = e[k], C[k] = !0);
    e = r !== !1 && wd(e);
  } while (e && (!r || r(e, n)) && e !== Object.prototype);
  return n;
}, sk = (e, n, r) => {
  e = String(e), (r === void 0 || r > e.length) && (r = e.length), r -= n.length;
  const t = e.indexOf(n, r);
  return t !== -1 && t === r;
}, dk = (e) => {
  if (!e)
    return null;
  if (Ir(e))
    return e;
  let n = e.length;
  if (!uf(n))
    return null;
  const r = new Array(n);
  for (; n-- > 0; )
    r[n] = e[n];
  return r;
}, uk = ((e) => (n) => e && n instanceof e)(typeof Uint8Array < "u" && wd(Uint8Array)), ck = (e, n) => {
  const t = (e && e[Symbol.iterator]).call(e);
  let i;
  for (; (i = t.next()) && !i.done; ) {
    const f = i.value;
    n.call(e, f[0], f[1]);
  }
}, lk = (e, n) => {
  let r;
  const t = [];
  for (; (r = e.exec(n)) !== null; )
    t.push(r);
  return t;
}, fk = $n("HTMLFormElement"), pk = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(r, t, i) {
    return t.toUpperCase() + i;
  }
), qu = (({ hasOwnProperty: e }) => (n, r) => e.call(n, r))(Object.prototype), hk = $n("RegExp"), pf = (e, n) => {
  const r = Object.getOwnPropertyDescriptors(e), t = {};
  ai(r, (i, f) => {
    let k;
    (k = n(i, f, e)) !== !1 && (t[f] = k || i);
  }), Object.defineProperties(e, t);
}, yk = (e) => {
  pf(e, (n, r) => {
    if (An(e) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return !1;
    const t = e[r];
    if (An(t)) {
      if (n.enumerable = !1, "writable" in n) {
        n.writable = !1;
        return;
      }
      n.set || (n.set = () => {
        throw Error("Can not rewrite read-only method '" + r + "'");
      });
    }
  });
}, mk = (e, n) => {
  const r = {}, t = (i) => {
    i.forEach((f) => {
      r[f] = !0;
    });
  };
  return Ir(e) ? t(e) : t(String(e).split(n)), r;
}, gk = () => {
}, Sk = (e, n) => (e = +e, Number.isFinite(e) ? e : n), Rs = "abcdefghijklmnopqrstuvwxyz", Vu = "0123456789", hf = {
  DIGIT: Vu,
  ALPHA: Rs,
  ALPHA_DIGIT: Rs + Rs.toUpperCase() + Vu
}, kk = (e = 16, n = hf.ALPHA_DIGIT) => {
  let r = "";
  const { length: t } = n;
  for (; e--; )
    r += n[Math.random() * t | 0];
  return r;
};
function Pk(e) {
  return !!(e && An(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const vk = (e) => {
  const n = new Array(10), r = (t, i) => {
    if ($o(t)) {
      if (n.indexOf(t) >= 0)
        return;
      if (!("toJSON" in t)) {
        n[i] = t;
        const f = Ir(t) ? [] : {};
        return ai(t, (k, C) => {
          const T = r(k, i + 1);
          !Gr(T) && (f[C] = T);
        }), n[i] = void 0, f;
      }
    }
    return t;
  };
  return r(e, 0);
}, Rk = $n("AsyncFunction"), Bk = (e) => e && ($o(e) || An(e)) && An(e.then) && An(e.catch);
var x = {
  isArray: Ir,
  isArrayBuffer: df,
  isBuffer: GS,
  isFormData: ek,
  isArrayBufferView: $S,
  isString: zS,
  isNumber: uf,
  isBoolean: KS,
  isObject: $o,
  isPlainObject: Di,
  isUndefined: Gr,
  isDate: xS,
  isFile: ZS,
  isBlob: YS,
  isRegExp: hk,
  isFunction: An,
  isStream: jS,
  isURLSearchParams: nk,
  isTypedArray: uk,
  isFileList: XS,
  forEach: ai,
  merge: Ws,
  extend: rk,
  trim: tk,
  stripBOM: ik,
  inherits: ok,
  toFlatObject: ak,
  kindOf: Lo,
  kindOfTest: $n,
  endsWith: sk,
  toArray: dk,
  forEachEntry: ck,
  matchAll: lk,
  isHTMLForm: fk,
  hasOwnProperty: qu,
  hasOwnProp: qu,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: pf,
  freezeMethods: yk,
  toObjectSet: mk,
  toCamelCase: pk,
  noop: gk,
  toFiniteNumber: Sk,
  findKey: cf,
  global: lf,
  isContextDefined: ff,
  ALPHABET: hf,
  generateString: kk,
  isSpecCompliantForm: Pk,
  toJSONObject: vk,
  isAsyncFn: Rk,
  isThenable: Bk
};
function Se(e, n, r, t, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", n && (this.code = n), r && (this.config = r), t && (this.request = t), i && (this.response = i);
}
x.inherits(Se, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: x.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const yf = Se.prototype, mf = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  mf[e] = { value: e };
});
Object.defineProperties(Se, mf);
Object.defineProperty(yf, "isAxiosError", { value: !0 });
Se.from = (e, n, r, t, i, f) => {
  const k = Object.create(yf);
  return x.toFlatObject(e, k, function(T) {
    return T !== Error.prototype;
  }, (C) => C !== "isAxiosError"), Se.call(k, e.message, n, r, t, i), k.cause = e, k.name = e.name, f && Object.assign(k, f), k;
};
var Ok = null;
function Fs(e) {
  return x.isPlainObject(e) || x.isArray(e);
}
function gf(e) {
  return x.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function Qu(e, n, r) {
  return e ? e.concat(n).map(function(i, f) {
    return i = gf(i), !r && f ? "[" + i + "]" : i;
  }).join(r ? "." : "") : n;
}
function bk(e) {
  return x.isArray(e) && !e.some(Fs);
}
const Ak = x.toFlatObject(x, {}, null, function(n) {
  return /^is[A-Z]/.test(n);
});
function zo(e, n, r) {
  if (!x.isObject(e))
    throw new TypeError("target must be an object");
  n = n || new FormData(), r = x.toFlatObject(r, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(c, l) {
    return !x.isUndefined(l[c]);
  });
  const t = r.metaTokens, i = r.visitor || w, f = r.dots, k = r.indexes, T = (r.Blob || typeof Blob < "u" && Blob) && x.isSpecCompliantForm(n);
  if (!x.isFunction(i))
    throw new TypeError("visitor must be a function");
  function U(b) {
    if (b === null)
      return "";
    if (x.isDate(b))
      return b.toISOString();
    if (!T && x.isBlob(b))
      throw new Se("Blob is not supported. Use a Buffer instead.");
    return x.isArrayBuffer(b) || x.isTypedArray(b) ? T && typeof Blob == "function" ? new Blob([b]) : Ci.Buffer.from(b) : b;
  }
  function w(b, c, l) {
    let y = b;
    if (b && !l && typeof b == "object") {
      if (x.endsWith(c, "{}"))
        c = t ? c : c.slice(0, -2), b = JSON.stringify(b);
      else if (x.isArray(b) && bk(b) || (x.isFileList(b) || x.endsWith(c, "[]")) && (y = x.toArray(b)))
        return c = gf(c), y.forEach(function(J, _) {
          !(x.isUndefined(J) || J === null) && n.append(
            // eslint-disable-next-line no-nested-ternary
            k === !0 ? Qu([c], _, f) : k === null ? c : c + "[]",
            U(J)
          );
        }), !1;
    }
    return Fs(b) ? !0 : (n.append(Qu(l, c, f), U(b)), !1);
  }
  const N = [], h = Object.assign(Ak, {
    defaultVisitor: w,
    convertValue: U,
    isVisitable: Fs
  });
  function P(b, c) {
    if (!x.isUndefined(b)) {
      if (N.indexOf(b) !== -1)
        throw Error("Circular reference detected in " + c.join("."));
      N.push(b), x.forEach(b, function(y, E) {
        (!(x.isUndefined(y) || y === null) && i.call(
          n,
          y,
          x.isString(E) ? E.trim() : E,
          c,
          h
        )) === !0 && P(y, c ? c.concat(E) : [E]);
      }), N.pop();
    }
  }
  if (!x.isObject(e))
    throw new TypeError("data must be an object");
  return P(e), n;
}
function Wu(e) {
  const n = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(t) {
    return n[t];
  });
}
function _d(e, n) {
  this._pairs = [], e && zo(e, this, n);
}
const Sf = _d.prototype;
Sf.append = function(n, r) {
  this._pairs.push([n, r]);
};
Sf.toString = function(n) {
  const r = n ? function(t) {
    return n.call(this, t, Wu);
  } : Wu;
  return this._pairs.map(function(i) {
    return r(i[0]) + "=" + r(i[1]);
  }, "").join("&");
};
function Ik(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function kf(e, n, r) {
  if (!n)
    return e;
  const t = r && r.encode || Ik, i = r && r.serialize;
  let f;
  if (i ? f = i(n, r) : f = x.isURLSearchParams(n) ? n.toString() : new _d(n, r).toString(t), f) {
    const k = e.indexOf("#");
    k !== -1 && (e = e.slice(0, k)), e += (e.indexOf("?") === -1 ? "?" : "&") + f;
  }
  return e;
}
class Tk {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(n, r, t) {
    return this.handlers.push({
      fulfilled: n,
      rejected: r,
      synchronous: t ? t.synchronous : !1,
      runWhen: t ? t.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(n) {
    this.handlers[n] && (this.handlers[n] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(n) {
    x.forEach(this.handlers, function(t) {
      t !== null && n(t);
    });
  }
}
var Fu = Tk, Pf = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, Ck = typeof URLSearchParams < "u" ? URLSearchParams : _d, Nk = typeof FormData < "u" ? FormData : null, wk = typeof Blob < "u" ? Blob : null, _k = {
  isBrowser: !0,
  classes: {
    URLSearchParams: Ck,
    FormData: Nk,
    Blob: wk
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const vf = typeof window < "u" && typeof document < "u", Ek = ((e) => vf && ["ReactNative", "NativeScript", "NS"].indexOf(e) < 0)(typeof navigator < "u" && navigator.product), Jk = (() => typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function")();
var Uk = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  hasBrowserEnv: vf,
  hasStandardBrowserWebWorkerEnv: Jk,
  hasStandardBrowserEnv: Ek
}), Wn = {
  ...Uk,
  ..._k
};
function Dk(e, n) {
  return zo(e, new Wn.classes.URLSearchParams(), Object.assign({
    visitor: function(r, t, i, f) {
      return Wn.isNode && x.isBuffer(r) ? (this.append(t, r.toString("base64")), !1) : f.defaultVisitor.apply(this, arguments);
    }
  }, n));
}
function Mk(e) {
  return x.matchAll(/\w+|\[(\w*)]/g, e).map((n) => n[0] === "[]" ? "" : n[1] || n[0]);
}
function Hk(e) {
  const n = {}, r = Object.keys(e);
  let t;
  const i = r.length;
  let f;
  for (t = 0; t < i; t++)
    f = r[t], n[f] = e[f];
  return n;
}
function Rf(e) {
  function n(r, t, i, f) {
    let k = r[f++];
    const C = Number.isFinite(+k), T = f >= r.length;
    return k = !k && x.isArray(i) ? i.length : k, T ? (x.hasOwnProp(i, k) ? i[k] = [i[k], t] : i[k] = t, !C) : ((!i[k] || !x.isObject(i[k])) && (i[k] = []), n(r, t, i[k], f) && x.isArray(i[k]) && (i[k] = Hk(i[k])), !C);
  }
  if (x.isFormData(e) && x.isFunction(e.entries)) {
    const r = {};
    return x.forEachEntry(e, (t, i) => {
      n(Mk(t), i, r, 0);
    }), r;
  }
  return null;
}
function qk(e, n, r) {
  if (x.isString(e))
    try {
      return (n || JSON.parse)(e), x.trim(e);
    } catch (t) {
      if (t.name !== "SyntaxError")
        throw t;
    }
  return (r || JSON.stringify)(e);
}
const Ed = {
  transitional: Pf,
  adapter: ["xhr", "http"],
  transformRequest: [function(n, r) {
    const t = r.getContentType() || "", i = t.indexOf("application/json") > -1, f = x.isObject(n);
    if (f && x.isHTMLForm(n) && (n = new FormData(n)), x.isFormData(n))
      return i && i ? JSON.stringify(Rf(n)) : n;
    if (x.isArrayBuffer(n) || x.isBuffer(n) || x.isStream(n) || x.isFile(n) || x.isBlob(n))
      return n;
    if (x.isArrayBufferView(n))
      return n.buffer;
    if (x.isURLSearchParams(n))
      return r.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), n.toString();
    let C;
    if (f) {
      if (t.indexOf("application/x-www-form-urlencoded") > -1)
        return Dk(n, this.formSerializer).toString();
      if ((C = x.isFileList(n)) || t.indexOf("multipart/form-data") > -1) {
        const T = this.env && this.env.FormData;
        return zo(
          C ? { "files[]": n } : n,
          T && new T(),
          this.formSerializer
        );
      }
    }
    return f || i ? (r.setContentType("application/json", !1), qk(n)) : n;
  }],
  transformResponse: [function(n) {
    const r = this.transitional || Ed.transitional, t = r && r.forcedJSONParsing, i = this.responseType === "json";
    if (n && x.isString(n) && (t && !this.responseType || i)) {
      const k = !(r && r.silentJSONParsing) && i;
      try {
        return JSON.parse(n);
      } catch (C) {
        if (k)
          throw C.name === "SyntaxError" ? Se.from(C, Se.ERR_BAD_RESPONSE, this, null, this.response) : C;
      }
    }
    return n;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Wn.classes.FormData,
    Blob: Wn.classes.Blob
  },
  validateStatus: function(n) {
    return n >= 200 && n < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
x.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  Ed.headers[e] = {};
});
var Jd = Ed;
const Vk = x.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var Qk = (e) => {
  const n = {};
  let r, t, i;
  return e && e.split(`
`).forEach(function(k) {
    i = k.indexOf(":"), r = k.substring(0, i).trim().toLowerCase(), t = k.substring(i + 1).trim(), !(!r || n[r] && Vk[r]) && (r === "set-cookie" ? n[r] ? n[r].push(t) : n[r] = [t] : n[r] = n[r] ? n[r] + ", " + t : t);
  }), n;
};
const Lu = Symbol("internals");
function Dr(e) {
  return e && String(e).trim().toLowerCase();
}
function Mi(e) {
  return e === !1 || e == null ? e : x.isArray(e) ? e.map(Mi) : String(e);
}
function Wk(e) {
  const n = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let t;
  for (; t = r.exec(e); )
    n[t[1]] = t[2];
  return n;
}
const Fk = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function Bs(e, n, r, t, i) {
  if (x.isFunction(t))
    return t.call(this, n, r);
  if (i && (n = r), !!x.isString(n)) {
    if (x.isString(t))
      return n.indexOf(t) !== -1;
    if (x.isRegExp(t))
      return t.test(n);
  }
}
function Lk(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (n, r, t) => r.toUpperCase() + t);
}
function Gk(e, n) {
  const r = x.toCamelCase(" " + n);
  ["get", "set", "has"].forEach((t) => {
    Object.defineProperty(e, t + r, {
      value: function(i, f, k) {
        return this[t].call(this, n, i, f, k);
      },
      configurable: !0
    });
  });
}
class Ko {
  constructor(n) {
    n && this.set(n);
  }
  set(n, r, t) {
    const i = this;
    function f(C, T, U) {
      const w = Dr(T);
      if (!w)
        throw new Error("header name must be a non-empty string");
      const N = x.findKey(i, w);
      (!N || i[N] === void 0 || U === !0 || U === void 0 && i[N] !== !1) && (i[N || T] = Mi(C));
    }
    const k = (C, T) => x.forEach(C, (U, w) => f(U, w, T));
    return x.isPlainObject(n) || n instanceof this.constructor ? k(n, r) : x.isString(n) && (n = n.trim()) && !Fk(n) ? k(Qk(n), r) : n != null && f(r, n, t), this;
  }
  get(n, r) {
    if (n = Dr(n), n) {
      const t = x.findKey(this, n);
      if (t) {
        const i = this[t];
        if (!r)
          return i;
        if (r === !0)
          return Wk(i);
        if (x.isFunction(r))
          return r.call(this, i, t);
        if (x.isRegExp(r))
          return r.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(n, r) {
    if (n = Dr(n), n) {
      const t = x.findKey(this, n);
      return !!(t && this[t] !== void 0 && (!r || Bs(this, this[t], t, r)));
    }
    return !1;
  }
  delete(n, r) {
    const t = this;
    let i = !1;
    function f(k) {
      if (k = Dr(k), k) {
        const C = x.findKey(t, k);
        C && (!r || Bs(t, t[C], C, r)) && (delete t[C], i = !0);
      }
    }
    return x.isArray(n) ? n.forEach(f) : f(n), i;
  }
  clear(n) {
    const r = Object.keys(this);
    let t = r.length, i = !1;
    for (; t--; ) {
      const f = r[t];
      (!n || Bs(this, this[f], f, n, !0)) && (delete this[f], i = !0);
    }
    return i;
  }
  normalize(n) {
    const r = this, t = {};
    return x.forEach(this, (i, f) => {
      const k = x.findKey(t, f);
      if (k) {
        r[k] = Mi(i), delete r[f];
        return;
      }
      const C = n ? Lk(f) : String(f).trim();
      C !== f && delete r[f], r[C] = Mi(i), t[C] = !0;
    }), this;
  }
  concat(...n) {
    return this.constructor.concat(this, ...n);
  }
  toJSON(n) {
    const r = /* @__PURE__ */ Object.create(null);
    return x.forEach(this, (t, i) => {
      t != null && t !== !1 && (r[i] = n && x.isArray(t) ? t.join(", ") : t);
    }), r;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([n, r]) => n + ": " + r).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(n) {
    return n instanceof this ? n : new this(n);
  }
  static concat(n, ...r) {
    const t = new this(n);
    return r.forEach((i) => t.set(i)), t;
  }
  static accessor(n) {
    const t = (this[Lu] = this[Lu] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function f(k) {
      const C = Dr(k);
      t[C] || (Gk(i, k), t[C] = !0);
    }
    return x.isArray(n) ? n.forEach(f) : f(n), this;
  }
}
Ko.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
x.reduceDescriptors(Ko.prototype, ({ value: e }, n) => {
  let r = n[0].toUpperCase() + n.slice(1);
  return {
    get: () => e,
    set(t) {
      this[r] = t;
    }
  };
});
x.freezeMethods(Ko);
var xn = Ko;
function Os(e, n) {
  const r = this || Jd, t = n || r, i = xn.from(t.headers);
  let f = t.data;
  return x.forEach(e, function(C) {
    f = C.call(r, f, i.normalize(), n ? n.status : void 0);
  }), i.normalize(), f;
}
function Bf(e) {
  return !!(e && e.__CANCEL__);
}
function si(e, n, r) {
  Se.call(this, e ?? "canceled", Se.ERR_CANCELED, n, r), this.name = "CanceledError";
}
x.inherits(si, Se, {
  __CANCEL__: !0
});
function $k(e, n, r) {
  const t = r.config.validateStatus;
  !r.status || !t || t(r.status) ? e(r) : n(new Se(
    "Request failed with status code " + r.status,
    [Se.ERR_BAD_REQUEST, Se.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
    r.config,
    r.request,
    r
  ));
}
var zk = Wn.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, n, r, t, i, f) {
      const k = [e + "=" + encodeURIComponent(n)];
      x.isNumber(r) && k.push("expires=" + new Date(r).toGMTString()), x.isString(t) && k.push("path=" + t), x.isString(i) && k.push("domain=" + i), f === !0 && k.push("secure"), document.cookie = k.join("; ");
    },
    read(e) {
      const n = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return n ? decodeURIComponent(n[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function Kk(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function xk(e, n) {
  return n ? e.replace(/\/+$/, "") + "/" + n.replace(/^\/+/, "") : e;
}
function Of(e, n) {
  return e && !Kk(n) ? xk(e, n) : n;
}
var Zk = Wn.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const n = /(msie|trident)/i.test(navigator.userAgent), r = document.createElement("a");
    let t;
    function i(f) {
      let k = f;
      return n && (r.setAttribute("href", k), k = r.href), r.setAttribute("href", k), {
        href: r.href,
        protocol: r.protocol ? r.protocol.replace(/:$/, "") : "",
        host: r.host,
        search: r.search ? r.search.replace(/^\?/, "") : "",
        hash: r.hash ? r.hash.replace(/^#/, "") : "",
        hostname: r.hostname,
        port: r.port,
        pathname: r.pathname.charAt(0) === "/" ? r.pathname : "/" + r.pathname
      };
    }
    return t = i(window.location.href), function(k) {
      const C = x.isString(k) ? i(k) : k;
      return C.protocol === t.protocol && C.host === t.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function() {
    return function() {
      return !0;
    };
  }()
);
function Yk(e) {
  const n = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return n && n[1] || "";
}
function Xk(e, n) {
  e = e || 10;
  const r = new Array(e), t = new Array(e);
  let i = 0, f = 0, k;
  return n = n !== void 0 ? n : 1e3, function(T) {
    const U = Date.now(), w = t[f];
    k || (k = U), r[i] = T, t[i] = U;
    let N = f, h = 0;
    for (; N !== i; )
      h += r[N++], N = N % e;
    if (i = (i + 1) % e, i === f && (f = (f + 1) % e), U - k < n)
      return;
    const P = w && U - w;
    return P ? Math.round(h * 1e3 / P) : void 0;
  };
}
function Gu(e, n) {
  let r = 0;
  const t = Xk(50, 250);
  return (i) => {
    const f = i.loaded, k = i.lengthComputable ? i.total : void 0, C = f - r, T = t(C), U = f <= k;
    r = f;
    const w = {
      loaded: f,
      total: k,
      progress: k ? f / k : void 0,
      bytes: C,
      rate: T || void 0,
      estimated: T && k && U ? (k - f) / T : void 0,
      event: i
    };
    w[n ? "download" : "upload"] = !0, e(w);
  };
}
const jk = typeof XMLHttpRequest < "u";
var eP = jk && function(e) {
  return new Promise(function(r, t) {
    let i = e.data;
    const f = xn.from(e.headers).normalize();
    let { responseType: k, withXSRFToken: C } = e, T;
    function U() {
      e.cancelToken && e.cancelToken.unsubscribe(T), e.signal && e.signal.removeEventListener("abort", T);
    }
    let w;
    if (x.isFormData(i)) {
      if (Wn.hasStandardBrowserEnv || Wn.hasStandardBrowserWebWorkerEnv)
        f.setContentType(!1);
      else if ((w = f.getContentType()) !== !1) {
        const [c, ...l] = w ? w.split(";").map((y) => y.trim()).filter(Boolean) : [];
        f.setContentType([c || "multipart/form-data", ...l].join("; "));
      }
    }
    let N = new XMLHttpRequest();
    if (e.auth) {
      const c = e.auth.username || "", l = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
      f.set("Authorization", "Basic " + btoa(c + ":" + l));
    }
    const h = Of(e.baseURL, e.url);
    N.open(e.method.toUpperCase(), kf(h, e.params, e.paramsSerializer), !0), N.timeout = e.timeout;
    function P() {
      if (!N)
        return;
      const c = xn.from(
        "getAllResponseHeaders" in N && N.getAllResponseHeaders()
      ), y = {
        data: !k || k === "text" || k === "json" ? N.responseText : N.response,
        status: N.status,
        statusText: N.statusText,
        headers: c,
        config: e,
        request: N
      };
      $k(function(J) {
        r(J), U();
      }, function(J) {
        t(J), U();
      }, y), N = null;
    }
    if ("onloadend" in N ? N.onloadend = P : N.onreadystatechange = function() {
      !N || N.readyState !== 4 || N.status === 0 && !(N.responseURL && N.responseURL.indexOf("file:") === 0) || setTimeout(P);
    }, N.onabort = function() {
      N && (t(new Se("Request aborted", Se.ECONNABORTED, e, N)), N = null);
    }, N.onerror = function() {
      t(new Se("Network Error", Se.ERR_NETWORK, e, N)), N = null;
    }, N.ontimeout = function() {
      let l = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded";
      const y = e.transitional || Pf;
      e.timeoutErrorMessage && (l = e.timeoutErrorMessage), t(new Se(
        l,
        y.clarifyTimeoutError ? Se.ETIMEDOUT : Se.ECONNABORTED,
        e,
        N
      )), N = null;
    }, Wn.hasStandardBrowserEnv && (C && x.isFunction(C) && (C = C(e)), C || C !== !1 && Zk(h))) {
      const c = e.xsrfHeaderName && e.xsrfCookieName && zk.read(e.xsrfCookieName);
      c && f.set(e.xsrfHeaderName, c);
    }
    i === void 0 && f.setContentType(null), "setRequestHeader" in N && x.forEach(f.toJSON(), function(l, y) {
      N.setRequestHeader(y, l);
    }), x.isUndefined(e.withCredentials) || (N.withCredentials = !!e.withCredentials), k && k !== "json" && (N.responseType = e.responseType), typeof e.onDownloadProgress == "function" && N.addEventListener("progress", Gu(e.onDownloadProgress, !0)), typeof e.onUploadProgress == "function" && N.upload && N.upload.addEventListener("progress", Gu(e.onUploadProgress)), (e.cancelToken || e.signal) && (T = (c) => {
      N && (t(!c || c.type ? new si(null, e, N) : c), N.abort(), N = null);
    }, e.cancelToken && e.cancelToken.subscribe(T), e.signal && (e.signal.aborted ? T() : e.signal.addEventListener("abort", T)));
    const b = Yk(h);
    if (b && Wn.protocols.indexOf(b) === -1) {
      t(new Se("Unsupported protocol " + b + ":", Se.ERR_BAD_REQUEST, e));
      return;
    }
    N.send(i || null);
  });
};
const Ls = {
  http: Ok,
  xhr: eP
};
x.forEach(Ls, (e, n) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: n });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: n });
  }
});
const $u = (e) => `- ${e}`, nP = (e) => x.isFunction(e) || e === null || e === !1;
var bf = {
  getAdapter: (e) => {
    e = x.isArray(e) ? e : [e];
    const { length: n } = e;
    let r, t;
    const i = {};
    for (let f = 0; f < n; f++) {
      r = e[f];
      let k;
      if (t = r, !nP(r) && (t = Ls[(k = String(r)).toLowerCase()], t === void 0))
        throw new Se(`Unknown adapter '${k}'`);
      if (t)
        break;
      i[k || "#" + f] = t;
    }
    if (!t) {
      const f = Object.entries(i).map(
        ([C, T]) => `adapter ${C} ` + (T === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let k = n ? f.length > 1 ? `since :
` + f.map($u).join(`
`) : " " + $u(f[0]) : "as no adapter specified";
      throw new Se(
        "There is no suitable adapter to dispatch the request " + k,
        "ERR_NOT_SUPPORT"
      );
    }
    return t;
  },
  adapters: Ls
};
function bs(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new si(null, e);
}
function zu(e) {
  return bs(e), e.headers = xn.from(e.headers), e.data = Os.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), bf.getAdapter(e.adapter || Jd.adapter)(e).then(function(t) {
    return bs(e), t.data = Os.call(
      e,
      e.transformResponse,
      t
    ), t.headers = xn.from(t.headers), t;
  }, function(t) {
    return Bf(t) || (bs(e), t && t.response && (t.response.data = Os.call(
      e,
      e.transformResponse,
      t.response
    ), t.response.headers = xn.from(t.response.headers))), Promise.reject(t);
  });
}
const Ku = (e) => e instanceof xn ? e.toJSON() : e;
function mr(e, n) {
  n = n || {};
  const r = {};
  function t(U, w, N) {
    return x.isPlainObject(U) && x.isPlainObject(w) ? x.merge.call({ caseless: N }, U, w) : x.isPlainObject(w) ? x.merge({}, w) : x.isArray(w) ? w.slice() : w;
  }
  function i(U, w, N) {
    if (x.isUndefined(w)) {
      if (!x.isUndefined(U))
        return t(void 0, U, N);
    } else
      return t(U, w, N);
  }
  function f(U, w) {
    if (!x.isUndefined(w))
      return t(void 0, w);
  }
  function k(U, w) {
    if (x.isUndefined(w)) {
      if (!x.isUndefined(U))
        return t(void 0, U);
    } else
      return t(void 0, w);
  }
  function C(U, w, N) {
    if (N in n)
      return t(U, w);
    if (N in e)
      return t(void 0, U);
  }
  const T = {
    url: f,
    method: f,
    data: f,
    baseURL: k,
    transformRequest: k,
    transformResponse: k,
    paramsSerializer: k,
    timeout: k,
    timeoutMessage: k,
    withCredentials: k,
    withXSRFToken: k,
    adapter: k,
    responseType: k,
    xsrfCookieName: k,
    xsrfHeaderName: k,
    onUploadProgress: k,
    onDownloadProgress: k,
    decompress: k,
    maxContentLength: k,
    maxBodyLength: k,
    beforeRedirect: k,
    transport: k,
    httpAgent: k,
    httpsAgent: k,
    cancelToken: k,
    socketPath: k,
    responseEncoding: k,
    validateStatus: C,
    headers: (U, w) => i(Ku(U), Ku(w), !0)
  };
  return x.forEach(Object.keys(Object.assign({}, e, n)), function(w) {
    const N = T[w] || i, h = N(e[w], n[w], w);
    x.isUndefined(h) && N !== C || (r[w] = h);
  }), r;
}
const Af = "1.6.2", Ud = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, n) => {
  Ud[e] = function(t) {
    return typeof t === e || "a" + (n < 1 ? "n " : " ") + e;
  };
});
const xu = {};
Ud.transitional = function(n, r, t) {
  function i(f, k) {
    return "[Axios v" + Af + "] Transitional option '" + f + "'" + k + (t ? ". " + t : "");
  }
  return (f, k, C) => {
    if (n === !1)
      throw new Se(
        i(k, " has been removed" + (r ? " in " + r : "")),
        Se.ERR_DEPRECATED
      );
    return r && !xu[k] && (xu[k] = !0, console.warn(
      i(
        k,
        " has been deprecated since v" + r + " and will be removed in the near future"
      )
    )), n ? n(f, k, C) : !0;
  };
};
function tP(e, n, r) {
  if (typeof e != "object")
    throw new Se("options must be an object", Se.ERR_BAD_OPTION_VALUE);
  const t = Object.keys(e);
  let i = t.length;
  for (; i-- > 0; ) {
    const f = t[i], k = n[f];
    if (k) {
      const C = e[f], T = C === void 0 || k(C, f, e);
      if (T !== !0)
        throw new Se("option " + f + " must be " + T, Se.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== !0)
      throw new Se("Unknown option " + f, Se.ERR_BAD_OPTION);
  }
}
var Gs = {
  assertOptions: tP,
  validators: Ud
};
const nt = Gs.validators;
class Li {
  constructor(n) {
    this.defaults = n, this.interceptors = {
      request: new Fu(),
      response: new Fu()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(n, r) {
    typeof n == "string" ? (r = r || {}, r.url = n) : r = n || {}, r = mr(this.defaults, r);
    const { transitional: t, paramsSerializer: i, headers: f } = r;
    t !== void 0 && Gs.assertOptions(t, {
      silentJSONParsing: nt.transitional(nt.boolean),
      forcedJSONParsing: nt.transitional(nt.boolean),
      clarifyTimeoutError: nt.transitional(nt.boolean)
    }, !1), i != null && (x.isFunction(i) ? r.paramsSerializer = {
      serialize: i
    } : Gs.assertOptions(i, {
      encode: nt.function,
      serialize: nt.function
    }, !0)), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let k = f && x.merge(
      f.common,
      f[r.method]
    );
    f && x.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (b) => {
        delete f[b];
      }
    ), r.headers = xn.concat(k, f);
    const C = [];
    let T = !0;
    this.interceptors.request.forEach(function(c) {
      typeof c.runWhen == "function" && c.runWhen(r) === !1 || (T = T && c.synchronous, C.unshift(c.fulfilled, c.rejected));
    });
    const U = [];
    this.interceptors.response.forEach(function(c) {
      U.push(c.fulfilled, c.rejected);
    });
    let w, N = 0, h;
    if (!T) {
      const b = [zu.bind(this), void 0];
      for (b.unshift.apply(b, C), b.push.apply(b, U), h = b.length, w = Promise.resolve(r); N < h; )
        w = w.then(b[N++], b[N++]);
      return w;
    }
    h = C.length;
    let P = r;
    for (N = 0; N < h; ) {
      const b = C[N++], c = C[N++];
      try {
        P = b(P);
      } catch (l) {
        c.call(this, l);
        break;
      }
    }
    try {
      w = zu.call(this, P);
    } catch (b) {
      return Promise.reject(b);
    }
    for (N = 0, h = U.length; N < h; )
      w = w.then(U[N++], U[N++]);
    return w;
  }
  getUri(n) {
    n = mr(this.defaults, n);
    const r = Of(n.baseURL, n.url);
    return kf(r, n.params, n.paramsSerializer);
  }
}
x.forEach(["delete", "get", "head", "options"], function(n) {
  Li.prototype[n] = function(r, t) {
    return this.request(mr(t || {}, {
      method: n,
      url: r,
      data: (t || {}).data
    }));
  };
});
x.forEach(["post", "put", "patch"], function(n) {
  function r(t) {
    return function(f, k, C) {
      return this.request(mr(C || {}, {
        method: n,
        headers: t ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: f,
        data: k
      }));
    };
  }
  Li.prototype[n] = r(), Li.prototype[n + "Form"] = r(!0);
});
var Hi = Li;
class Dd {
  constructor(n) {
    if (typeof n != "function")
      throw new TypeError("executor must be a function.");
    let r;
    this.promise = new Promise(function(f) {
      r = f;
    });
    const t = this;
    this.promise.then((i) => {
      if (!t._listeners)
        return;
      let f = t._listeners.length;
      for (; f-- > 0; )
        t._listeners[f](i);
      t._listeners = null;
    }), this.promise.then = (i) => {
      let f;
      const k = new Promise((C) => {
        t.subscribe(C), f = C;
      }).then(i);
      return k.cancel = function() {
        t.unsubscribe(f);
      }, k;
    }, n(function(f, k, C) {
      t.reason || (t.reason = new si(f, k, C), r(t.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(n) {
    if (this.reason) {
      n(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(n) : this._listeners = [n];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(n) {
    if (!this._listeners)
      return;
    const r = this._listeners.indexOf(n);
    r !== -1 && this._listeners.splice(r, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let n;
    return {
      token: new Dd(function(i) {
        n = i;
      }),
      cancel: n
    };
  }
}
var rP = Dd;
function iP(e) {
  return function(r) {
    return e.apply(null, r);
  };
}
function oP(e) {
  return x.isObject(e) && e.isAxiosError === !0;
}
const $s = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries($s).forEach(([e, n]) => {
  $s[n] = e;
});
var aP = $s;
function If(e) {
  const n = new Hi(e), r = sf(Hi.prototype.request, n);
  return x.extend(r, Hi.prototype, n, { allOwnKeys: !0 }), x.extend(r, n, null, { allOwnKeys: !0 }), r.create = function(i) {
    return If(mr(e, i));
  }, r;
}
const Te = If(Jd);
Te.Axios = Hi;
Te.CanceledError = si;
Te.CancelToken = rP;
Te.isCancel = Bf;
Te.VERSION = Af;
Te.toFormData = zo;
Te.AxiosError = Se;
Te.Cancel = Te.CanceledError;
Te.all = function(n) {
  return Promise.all(n);
};
Te.spread = iP;
Te.isAxiosError = oP;
Te.mergeConfig = mr;
Te.AxiosHeaders = xn;
Te.formToJSON = (e) => Rf(x.isHTMLForm(e) ? new FormData(e) : e);
Te.getAdapter = bf.getAdapter;
Te.HttpStatusCode = aP;
Te.default = Te;
var sP = Te, dP = j && j.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(oi, "__esModule", { value: !0 });
oi.http = void 0;
const uP = dP(sP);
function cP(e) {
  if (e.status >= 400)
    throw new Error(`Bad status on response: ${e.status}`);
  return e;
}
function lP(e) {
  return e.toString().includes("emitExperimentalWarning");
}
async function fP(e, n, r, t) {
  if (typeof fetch == "function" && !lP(fetch)) {
    const i = {
      method: e,
      body: t ? JSON.stringify(t) : void 0,
      headers: {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        "Content-Type": "application/json",
        ...r
      }
    };
    return fetch(n, i).then(cP).then((f) => f.json());
  } else
    return uP.default.request({ url: n, method: e, data: t, headers: r }).then((i) => i.data);
}
oi.http = fP;
var Zn = {};
Object.defineProperty(Zn, "__esModule", { value: !0 });
Zn.hasProtocol = Zn.instanceOfRpcStreamingClient = void 0;
function pP(e) {
  return typeof e.listen == "function";
}
Zn.instanceOfRpcStreamingClient = pP;
function hP(e) {
  return e.search("://") !== -1;
}
Zn.hasProtocol = hP;
Object.defineProperty(Vo, "__esModule", { value: !0 });
Vo.HttpBatchClient = void 0;
const Zu = Qo, yP = oi, mP = Zn, Yu = {
  dispatchInterval: 20,
  batchSizeLimit: 20
};
class gP {
  constructor(n, r = {}) {
    this.queue = [], this.options = {
      batchSizeLimit: r.batchSizeLimit ?? Yu.batchSizeLimit,
      dispatchInterval: r.dispatchInterval ?? Yu.dispatchInterval
    }, typeof n == "string" ? this.url = (0, mP.hasProtocol)(n) ? n : "http://" + n : (this.url = n.url, this.headers = n.headers), this.timer = setInterval(() => this.tick(), r.dispatchInterval), this.validate();
  }
  disconnect() {
    this.timer && clearInterval(this.timer), this.timer = void 0;
  }
  async execute(n) {
    return new Promise((r, t) => {
      this.queue.push({ request: n, resolve: r, reject: t }), this.queue.length >= this.options.batchSizeLimit && this.tick();
    });
  }
  validate() {
    if (!this.options.batchSizeLimit || !Number.isSafeInteger(this.options.batchSizeLimit) || this.options.batchSizeLimit < 1)
      throw new Error("batchSizeLimit must be a safe integer >= 1");
  }
  /**
   * This is called in an interval where promise rejections cannot be handled.
   * So this is not async and HTTP errors need to be handled by the queued promises.
   */
  tick() {
    const n = this.queue.splice(0, this.options.batchSizeLimit);
    if (!n.length)
      return;
    const r = n.map((i) => i.request), t = r.map((i) => i.id);
    (0, yP.http)("POST", this.url, this.headers, r).then((i) => {
      (Array.isArray(i) ? i : [i]).forEach((k) => {
        const C = n.find((N) => N.request.id === k.id);
        if (!C)
          return;
        const { reject: T, resolve: U } = C, w = (0, Zu.parseJsonRpcResponse)(k);
        (0, Zu.isJsonRpcErrorResponse)(w) ? T(new Error(JSON.stringify(w.error))) : U(w);
      });
    }, (i) => {
      for (const f of t) {
        const k = n.find((C) => C.request.id === f);
        if (!k)
          return;
        k.reject(i);
      }
    });
  }
}
Vo.HttpBatchClient = gP;
var xo = {};
Object.defineProperty(xo, "__esModule", { value: !0 });
xo.HttpClient = void 0;
const Xu = Qo, SP = oi, kP = Zn;
class PP {
  constructor(n) {
    typeof n == "string" ? this.url = (0, kP.hasProtocol)(n) ? n : "http://" + n : (this.url = n.url, this.headers = n.headers);
  }
  disconnect() {
  }
  async execute(n) {
    const r = (0, Xu.parseJsonRpcResponse)(await (0, SP.http)("POST", this.url, this.headers, n));
    if ((0, Xu.isJsonRpcErrorResponse)(r))
      throw new Error(JSON.stringify(r.error));
    return r;
  }
}
xo.HttpClient = PP;
var Zo = {}, Tf = {}, Md = {}, di = {}, ui = {}, Ft = null;
typeof WebSocket < "u" ? Ft = WebSocket : typeof MozWebSocket < "u" ? Ft = MozWebSocket : typeof j < "u" ? Ft = j.WebSocket || j.MozWebSocket : typeof window < "u" ? Ft = window.WebSocket || window.MozWebSocket : typeof self < "u" && (Ft = self.WebSocket || self.MozWebSocket);
var vP = Ft, RP = j && j.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ui, "__esModule", { value: !0 });
ui.SocketWrapper = void 0;
const Vt = RP(vP);
function BP() {
  return typeof Ci.process < "u" && typeof Ci.process.versions < "u" && typeof Ci.process.versions.node < "u";
}
class OP {
  constructor(n, r, t, i, f, k = 1e4) {
    this.closed = !1, this.connected = new Promise((C, T) => {
      this.connectedResolver = C, this.connectedRejecter = T;
    }), this.url = n, this.messageHandler = r, this.errorHandler = t, this.openHandler = i, this.closeHandler = f, this.timeout = k;
  }
  /**
   * returns a promise that resolves when connection is open
   */
  connect() {
    const n = new Vt.default(this.url);
    n.onerror = (t) => {
      this.clearTimeout(), this.errorHandler && this.errorHandler(t);
    }, n.onmessage = (t) => {
      this.messageHandler({
        type: t.type,
        data: t.data
      });
    }, n.onopen = (t) => {
      this.clearTimeout(), this.connectedResolver(), this.openHandler && this.openHandler();
    }, n.onclose = (t) => {
      this.closed = !0, this.closeHandler && this.closeHandler(t);
    };
    const r = Date.now();
    this.timeoutId = setTimeout(() => {
      n.onmessage = () => 0, n.onerror = () => 0, n.onopen = () => 0, n.onclose = () => 0, n.close(), this.socket = void 0;
      const t = Math.floor(Date.now() - r);
      this.connectedRejecter(`Connection attempt timed out after ${t} ms`);
    }, this.timeout), this.socket = n;
  }
  /**
   * Closes an established connection and aborts other connection states
   */
  disconnect() {
    if (!this.socket)
      throw new Error("Socket undefined. This must be called after connecting.");
    switch (this.clearTimeout(), this.socket.readyState) {
      case Vt.default.OPEN:
        this.socket.close(
          1e3
          /* Normal Closure */
        );
        break;
      case Vt.default.CLOSED:
        break;
      case Vt.default.CONNECTING:
        this.socket.onopen = () => 0, this.socket.onclose = () => 0, this.socket.onerror = () => 0, this.socket.onmessage = () => 0, this.socket = void 0, this.closeHandler && this.closeHandler({ wasClean: !1, code: 4001 });
        break;
      case Vt.default.CLOSING:
        break;
      default:
        throw new Error(`Unknown readyState: ${this.socket.readyState}`);
    }
  }
  async send(n) {
    return new Promise((r, t) => {
      if (!this.socket)
        throw new Error("Socket undefined. This must be called after connecting.");
      if (this.closed)
        throw new Error("Socket was closed, so no data can be sent anymore.");
      if (this.socket.readyState !== Vt.default.OPEN)
        throw new Error("Websocket is not open");
      BP() ? this.socket.send(n, (i) => i ? t(i) : r()) : (this.socket.send(n), r());
    });
  }
  /**
   * Clears the timeout function, such that no timeout error will be raised anymore. This should be
   * called when the connection is established, a connection error occurred or the socket is disconnected.
   *
   * This method must not be called before `connect()`.
   * This method is idempotent.
   */
  clearTimeout() {
    if (!this.timeoutId)
      throw new Error("Timeout ID not set. This should not happen and usually means connect() was not called.");
    clearTimeout(this.timeoutId);
  }
}
ui.SocketWrapper = OP;
Object.defineProperty(di, "__esModule", { value: !0 });
di.StreamingSocket = void 0;
const bP = Ue, AP = ui;
class IP {
  constructor(n, r = 1e4) {
    this.socket = new AP.SocketWrapper(n, (i) => {
      this.eventProducerListener && this.eventProducerListener.next(i);
    }, (i) => {
      this.eventProducerListener && this.eventProducerListener.error(i);
    }, () => {
    }, (i) => {
      this.eventProducerListener && (i.wasClean ? this.eventProducerListener.complete() : this.eventProducerListener.error("Socket was closed unclean"));
    }, r), this.connected = this.socket.connected;
    const t = {
      start: (i) => this.eventProducerListener = i,
      stop: () => this.eventProducerListener = void 0
    };
    this.events = bP.Stream.create(t);
  }
  connect() {
    this.socket.connect();
  }
  disconnect() {
    this.socket.disconnect();
  }
  async send(n) {
    return this.socket.send(n);
  }
}
di.StreamingSocket = IP;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.QueueingStreamingSocket = e.ConnectionStatus = void 0;
  const n = ei, r = Ue, t = di;
  var i;
  (function(k) {
    k[k.Unconnected = 0] = "Unconnected", k[k.Connecting = 1] = "Connecting", k[k.Connected = 2] = "Connected", k[k.Disconnected = 3] = "Disconnected";
  })(i = e.ConnectionStatus || (e.ConnectionStatus = {}));
  class f {
    constructor(C, T = 1e4, U) {
      this.queue = [], this.isProcessingQueue = !1, this.url = C, this.timeout = T, this.reconnectedHandler = U;
      const w = {
        start: (N) => this.eventProducerListener = N,
        stop: () => this.eventProducerListener = void 0
      };
      this.events = r.Stream.create(w), this.connectionStatusProducer = new n.DefaultValueProducer(i.Unconnected), this.connectionStatus = new n.ValueAndUpdates(this.connectionStatusProducer), this.socket = new t.StreamingSocket(this.url, this.timeout), this.socket.events.subscribe({
        next: (N) => {
          if (!this.eventProducerListener)
            throw new Error("No event producer listener set");
          this.eventProducerListener.next(N);
        },
        error: () => this.connectionStatusProducer.update(i.Disconnected)
      });
    }
    connect() {
      this.connectionStatusProducer.update(i.Connecting), this.socket.connected.then(async () => (this.connectionStatusProducer.update(i.Connected), this.processQueue()), () => this.connectionStatusProducer.update(i.Disconnected)), this.socket.connect();
    }
    disconnect() {
      this.connectionStatusProducer.update(i.Disconnected), this.socket.disconnect();
    }
    reconnect() {
      this.socket = new t.StreamingSocket(this.url, this.timeout), this.socket.events.subscribe({
        next: (C) => {
          if (!this.eventProducerListener)
            throw new Error("No event producer listener set");
          this.eventProducerListener.next(C);
        },
        error: () => this.connectionStatusProducer.update(i.Disconnected)
      }), this.socket.connected.then(() => {
        this.reconnectedHandler && this.reconnectedHandler();
      }), this.connect();
    }
    getQueueLength() {
      return this.queue.length;
    }
    queueRequest(C) {
      this.queue.push(C), this.processQueue();
    }
    async processQueue() {
      if (this.isProcessingQueue || this.connectionStatus.value !== i.Connected)
        return;
      this.isProcessingQueue = !0;
      let C;
      for (; C = this.queue.shift(); )
        try {
          await this.socket.send(C), this.isProcessingQueue = !1;
        } catch {
          this.queue.unshift(C), this.isProcessingQueue = !1;
          return;
        }
    }
  }
  e.QueueingStreamingSocket = f;
})(Md);
var Yo = {};
Object.defineProperty(Yo, "__esModule", { value: !0 });
Yo.ReconnectingSocket = void 0;
const TP = Ue, As = Md;
class Hd {
  /** Starts with a 0.1 second timeout, then doubles every attempt with a maximum timeout of 5 seconds. */
  static calculateTimeout(n) {
    return Math.min(2 ** n * 100, 5e3);
  }
  constructor(n, r = 1e4, t) {
    this.unconnected = !0, this.disconnected = !1, this.timeoutIndex = 0, this.reconnectTimeout = null;
    const i = {
      start: (f) => this.eventProducerListener = f,
      stop: () => this.eventProducerListener = void 0
    };
    this.events = TP.Stream.create(i), this.socket = new As.QueueingStreamingSocket(n, r, t), this.socket.events.subscribe({
      next: (f) => {
        this.eventProducerListener && this.eventProducerListener.next(f);
      },
      error: (f) => {
        this.eventProducerListener && this.eventProducerListener.error(f);
      }
    }), this.connectionStatus = this.socket.connectionStatus, this.connectionStatus.updates.subscribe({
      next: (f) => {
        f === As.ConnectionStatus.Connected && (this.timeoutIndex = 0), f === As.ConnectionStatus.Disconnected && (this.reconnectTimeout && (clearTimeout(this.reconnectTimeout), this.reconnectTimeout = null), this.reconnectTimeout = setTimeout(() => this.socket.reconnect(), Hd.calculateTimeout(this.timeoutIndex++)));
      }
    });
  }
  connect() {
    if (!this.unconnected)
      throw new Error("Cannot connect: socket has already connected");
    this.socket.connect(), this.unconnected = !1;
  }
  disconnect() {
    if (this.unconnected)
      throw new Error("Cannot disconnect: socket has not yet connected");
    this.socket.disconnect(), this.eventProducerListener && this.eventProducerListener.complete(), this.disconnected = !0;
  }
  queueRequest(n) {
    if (this.disconnected)
      throw new Error("Cannot queue request: socket has disconnected");
    this.socket.queueRequest(n);
  }
}
Yo.ReconnectingSocket = Hd;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.StreamingSocket = e.SocketWrapper = e.ReconnectingSocket = e.QueueingStreamingSocket = e.ConnectionStatus = void 0;
  var n = Md;
  Object.defineProperty(e, "ConnectionStatus", { enumerable: !0, get: function() {
    return n.ConnectionStatus;
  } }), Object.defineProperty(e, "QueueingStreamingSocket", { enumerable: !0, get: function() {
    return n.QueueingStreamingSocket;
  } });
  var r = Yo;
  Object.defineProperty(e, "ReconnectingSocket", { enumerable: !0, get: function() {
    return r.ReconnectingSocket;
  } });
  var t = ui;
  Object.defineProperty(e, "SocketWrapper", { enumerable: !0, get: function() {
    return t.SocketWrapper;
  } });
  var i = di;
  Object.defineProperty(e, "StreamingSocket", { enumerable: !0, get: function() {
    return i.StreamingSocket;
  } });
})(Tf);
Object.defineProperty(Zo, "__esModule", { value: !0 });
Zo.WebsocketClient = void 0;
const Gi = Qo, ju = Tf, CP = ei, NP = Ue, wP = Zn;
function _P(e) {
  throw e;
}
function Cf(e) {
  if (e.type !== "message")
    throw new Error(`Unexcepted message type on websocket: ${e.type}`);
  return (0, Gi.parseJsonRpcResponse)(JSON.parse(e.data));
}
class EP {
  constructor(n, r) {
    this.running = !1, this.subscriptions = [], this.request = n, this.socket = r;
  }
  /**
   * Implementation of Producer.start
   */
  start(n) {
    if (this.running)
      throw Error("Already started. Please stop first before restarting.");
    this.running = !0, this.connectToClient(n), this.socket.queueRequest(JSON.stringify(this.request));
  }
  /**
   * Implementation of Producer.stop
   *
   * Called by the stream when the stream's last listener stopped listening
   * or when the producer completed.
   */
  stop() {
    this.running = !1;
    const n = { ...this.request, method: "unsubscribe" };
    try {
      this.socket.queueRequest(JSON.stringify(n));
    } catch (r) {
      if (!(r instanceof Error && r.message.match(/socket has disconnected/i)))
        throw r;
    }
  }
  connectToClient(n) {
    const r = this.socket.events.map(Cf), t = r.filter((k) => k.id === this.request.id).subscribe({
      next: (k) => {
        (0, Gi.isJsonRpcErrorResponse)(k) && (this.closeSubscriptions(), n.error(JSON.stringify(k.error))), t.unsubscribe();
      }
    }), i = r.filter((k) => k.id === this.request.id).subscribe({
      next: (k) => {
        (0, Gi.isJsonRpcErrorResponse)(k) ? (this.closeSubscriptions(), n.error(JSON.stringify(k.error))) : n.next(k.result);
      }
    }), f = r.subscribe({
      error: (k) => {
        this.closeSubscriptions(), n.error(k);
      },
      complete: () => {
        this.closeSubscriptions(), n.complete();
      }
    });
    this.subscriptions.push(t, i, f);
  }
  closeSubscriptions() {
    for (const n of this.subscriptions)
      n.unsubscribe();
    this.subscriptions = [];
  }
}
class JP {
  constructor(n, r = _P) {
    this.subscriptionStreams = /* @__PURE__ */ new Map();
    const t = n.endsWith("/") ? "websocket" : "/websocket", i = (0, wP.hasProtocol)(n) ? n : "ws://" + n;
    this.url = i + t, this.socket = new ju.ReconnectingSocket(this.url);
    const f = this.socket.events.subscribe({
      error: (k) => {
        r(k), f.unsubscribe();
      }
    });
    this.jsonRpcResponseStream = this.socket.events.map(Cf), this.socket.connect();
  }
  async execute(n) {
    const r = this.responseForRequestId(n.id);
    this.socket.queueRequest(JSON.stringify(n));
    const t = await r;
    if ((0, Gi.isJsonRpcErrorResponse)(t))
      throw new Error(JSON.stringify(t.error));
    return t;
  }
  listen(n) {
    if (n.method !== "subscribe")
      throw new Error('Request method must be "subscribe" to start event listening');
    const r = n.params.query;
    if (typeof r != "string")
      throw new Error("request.params.query must be a string");
    if (!this.subscriptionStreams.has(r)) {
      const t = new EP(n, this.socket), i = NP.Stream.create(t);
      this.subscriptionStreams.set(r, i);
    }
    return this.subscriptionStreams.get(r).filter((t) => t.query !== void 0);
  }
  /**
   * Resolves as soon as websocket is connected. execute() queues requests automatically,
   * so this should be required for testing purposes only.
   */
  async connected() {
    await this.socket.connectionStatus.waitFor(ju.ConnectionStatus.Connected);
  }
  disconnect() {
    this.socket.disconnect();
  }
  async responseForRequestId(n) {
    return (0, CP.firstEvent)(this.jsonRpcResponseStream.filter((r) => r.id === n));
  }
}
Zo.WebsocketClient = JP;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.WebsocketClient = e.instanceOfRpcStreamingClient = e.HttpClient = e.HttpBatchClient = void 0;
  var n = Vo;
  Object.defineProperty(e, "HttpBatchClient", { enumerable: !0, get: function() {
    return n.HttpBatchClient;
  } });
  var r = xo;
  Object.defineProperty(e, "HttpClient", { enumerable: !0, get: function() {
    return r.HttpClient;
  } });
  var t = Zn;
  Object.defineProperty(e, "instanceOfRpcStreamingClient", { enumerable: !0, get: function() {
    return t.instanceOfRpcStreamingClient;
  } });
  var i = Zo;
  Object.defineProperty(e, "WebsocketClient", { enumerable: !0, get: function() {
    return i.WebsocketClient;
  } });
})(ii);
var Nf = {}, Xo = {}, fn = {}, ye = {};
Object.defineProperty(ye, "__esModule", { value: !0 });
ye.encodeBlockId = ye.encodeVersion = ye.encodeBytes = ye.encodeTime = ye.encodeUvarint = ye.encodeString = ye.dictionaryToStringMap = ye.may = ye.assertNotEmpty = ye.assertObject = ye.assertArray = ye.assertNumber = ye.assertString = ye.assertBoolean = ye.assertSet = void 0;
const UP = $e;
function Et(e) {
  if (e === void 0)
    throw new Error("Value must not be undefined");
  if (e === null)
    throw new Error("Value must not be null");
  return e;
}
ye.assertSet = Et;
function DP(e) {
  if (Et(e), typeof e != "boolean")
    throw new Error("Value must be a boolean");
  return e;
}
ye.assertBoolean = DP;
function MP(e) {
  if (Et(e), typeof e != "string")
    throw new Error("Value must be a string");
  return e;
}
ye.assertString = MP;
function HP(e) {
  if (Et(e), typeof e != "number")
    throw new Error("Value must be a number");
  return e;
}
ye.assertNumber = HP;
function qP(e) {
  if (Et(e), !Array.isArray(e))
    throw new Error("Value must be a an array");
  return e;
}
ye.assertArray = qP;
function VP(e) {
  if (Et(e), typeof e != "object")
    throw new Error("Value must be an object");
  if (Object.prototype.toString.call(e) !== "[object Object]")
    throw new Error("Value must be a simple object");
  return e;
}
ye.assertObject = VP;
function QP(e) {
  if (Et(e), typeof e == "number" && e === 0)
    throw new Error("must provide a non-zero value");
  if (e.length === 0)
    throw new Error("must provide a non-empty value");
  return e;
}
ye.assertNotEmpty = QP;
function WP(e, n) {
  return n == null ? void 0 : e(n);
}
ye.may = WP;
function FP(e) {
  const n = /* @__PURE__ */ new Map();
  for (const r of Object.keys(e)) {
    const t = e[r];
    if (typeof t != "string")
      throw new Error("Found dictionary value of type other than string");
    n.set(r, t);
  }
  return n;
}
ye.dictionaryToStringMap = FP;
function LP(e) {
  const n = (0, UP.toUtf8)(e);
  return Uint8Array.from([n.length, ...n]);
}
ye.encodeString = LP;
function gr(e) {
  return e >= 128 ? (
    // eslint-disable-next-line no-bitwise
    Uint8Array.from([e & 255 | 128, ...gr(e >> 7)])
  ) : (
    // eslint-disable-next-line no-bitwise
    Uint8Array.from([e & 255])
  );
}
ye.encodeUvarint = gr;
function GP(e) {
  const n = e.getTime(), r = Math.floor(n / 1e3), t = r ? [8, ...gr(r)] : new Uint8Array(), i = (e.nanoseconds || 0) + n % 1e3 * 1e6, f = i ? [16, ...gr(i)] : new Uint8Array();
  return Uint8Array.from([...t, ...f]);
}
ye.encodeTime = GP;
function $P(e) {
  if (e.length >= 128)
    throw new Error("Not implemented for byte arrays of length 128 or more");
  return e.length ? Uint8Array.from([e.length, ...e]) : new Uint8Array();
}
ye.encodeBytes = $P;
function zP(e) {
  const n = e.block ? Uint8Array.from([8, ...gr(e.block)]) : new Uint8Array(), r = e.app ? Uint8Array.from([16, ...gr(e.app)]) : new Uint8Array();
  return Uint8Array.from([...n, ...r]);
}
ye.encodeVersion = zP;
function KP(e) {
  return Uint8Array.from([
    10,
    e.hash.length,
    ...e.hash,
    18,
    e.parts.hash.length + 4,
    8,
    e.parts.total,
    18,
    e.parts.hash.length,
    ...e.parts.hash
  ]);
}
ye.encodeBlockId = KP;
Object.defineProperty(fn, "__esModule", { value: !0 });
fn.smallIntToApi = fn.apiToBigInt = fn.apiToSmallInt = void 0;
const zs = Mo, xP = ye;
function ZP(e) {
  return (typeof e == "number" ? new zs.Int53(e) : zs.Int53.fromString(e)).toNumber();
}
fn.apiToSmallInt = ZP;
function YP(e) {
  if ((0, xP.assertString)(e), !e.match(/^-?[0-9]+$/))
    throw new Error("Invalid string format");
  return BigInt(e);
}
fn.apiToBigInt = YP;
function XP(e) {
  return new zs.Int53(e).toString();
}
fn.smallIntToApi = XP;
var me = {};
Object.defineProperty(me, "__esModule", { value: !0 });
me.encodeBlockId = me.encodeVersion = me.encodeBytes = me.encodeTime = me.encodeUvarint = me.encodeString = me.dictionaryToStringMap = me.may = me.assertNotEmpty = me.assertObject = me.assertArray = me.assertNumber = me.assertString = me.assertBoolean = me.assertSet = void 0;
const jP = $e;
function Jt(e) {
  if (e === void 0)
    throw new Error("Value must not be undefined");
  if (e === null)
    throw new Error("Value must not be null");
  return e;
}
me.assertSet = Jt;
function ev(e) {
  if (Jt(e), typeof e != "boolean")
    throw new Error("Value must be a boolean");
  return e;
}
me.assertBoolean = ev;
function nv(e) {
  if (Jt(e), typeof e != "string")
    throw new Error("Value must be a string");
  return e;
}
me.assertString = nv;
function tv(e) {
  if (Jt(e), typeof e != "number")
    throw new Error("Value must be a number");
  return e;
}
me.assertNumber = tv;
function rv(e) {
  if (Jt(e), !Array.isArray(e))
    throw new Error("Value must be a an array");
  return e;
}
me.assertArray = rv;
function iv(e) {
  if (Jt(e), typeof e != "object")
    throw new Error("Value must be an object");
  if (Object.prototype.toString.call(e) !== "[object Object]")
    throw new Error("Value must be a simple object");
  return e;
}
me.assertObject = iv;
function ov(e) {
  if (Jt(e), typeof e == "number" && e === 0)
    throw new Error("must provide a non-zero value");
  if (e.length === 0)
    throw new Error("must provide a non-empty value");
  return e;
}
me.assertNotEmpty = ov;
function av(e, n) {
  return n == null ? void 0 : e(n);
}
me.may = av;
function sv(e) {
  const n = /* @__PURE__ */ new Map();
  for (const r of Object.keys(e)) {
    const t = e[r];
    if (typeof t != "string")
      throw new Error("Found dictionary value of type other than string");
    n.set(r, t);
  }
  return n;
}
me.dictionaryToStringMap = sv;
function dv(e) {
  const n = (0, jP.toUtf8)(e);
  return Uint8Array.from([n.length, ...n]);
}
me.encodeString = dv;
function Sr(e) {
  return e >= 128 ? (
    // eslint-disable-next-line no-bitwise
    Uint8Array.from([e & 255 | 128, ...Sr(e >> 7)])
  ) : (
    // eslint-disable-next-line no-bitwise
    Uint8Array.from([e & 255])
  );
}
me.encodeUvarint = Sr;
function uv(e) {
  const n = e.getTime(), r = Math.floor(n / 1e3), t = r ? [8, ...Sr(r)] : new Uint8Array(), i = (e.nanoseconds || 0) + n % 1e3 * 1e6, f = i ? [16, ...Sr(i)] : new Uint8Array();
  return Uint8Array.from([...t, ...f]);
}
me.encodeTime = uv;
function cv(e) {
  if (e.length >= 128)
    throw new Error("Not implemented for byte arrays of length 128 or more");
  return e.length ? Uint8Array.from([e.length, ...e]) : new Uint8Array();
}
me.encodeBytes = cv;
function lv(e) {
  const n = e.block ? Uint8Array.from([8, ...Sr(e.block)]) : new Uint8Array(), r = e.app ? Uint8Array.from([16, ...Sr(e.app)]) : new Uint8Array();
  return Uint8Array.from([...n, ...r]);
}
me.encodeVersion = lv;
function fv(e) {
  return Uint8Array.from([
    10,
    e.hash.length,
    ...e.hash,
    18,
    e.parts.hash.length + 4,
    8,
    e.parts.total,
    18,
    e.parts.hash.length,
    ...e.parts.hash
  ]);
}
me.encodeBlockId = fv;
var jo = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.buildQuery = e.SubscriptionEventType = e.Method = void 0, function(r) {
    r.AbciInfo = "abci_info", r.AbciQuery = "abci_query", r.Block = "block", r.Blockchain = "blockchain", r.BlockResults = "block_results", r.BlockSearch = "block_search", r.BroadcastTxAsync = "broadcast_tx_async", r.BroadcastTxSync = "broadcast_tx_sync", r.BroadcastTxCommit = "broadcast_tx_commit", r.Commit = "commit", r.Genesis = "genesis", r.Health = "health", r.NumUnconfirmedTxs = "num_unconfirmed_txs", r.Status = "status", r.Subscribe = "subscribe", r.Tx = "tx", r.TxSearch = "tx_search", r.Validators = "validators", r.Unsubscribe = "unsubscribe";
  }(e.Method || (e.Method = {})), function(r) {
    r.NewBlock = "NewBlock", r.NewBlockHeader = "NewBlockHeader", r.Tx = "Tx";
  }(e.SubscriptionEventType || (e.SubscriptionEventType = {}));
  function n(r) {
    const i = (r.tags ? r.tags : []).map((k) => `${k.key}='${k.value}'`), f = r.raw ? [r.raw] : [];
    return [...i, ...f].join(" AND ");
  }
  e.buildQuery = n;
})(jo);
var pv = j && j.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), hv = j && j.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), yv = j && j.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var r in e)
      r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && pv(n, e, r);
  return hv(n, e), n;
};
Object.defineProperty(Xo, "__esModule", { value: !0 });
Xo.Params = void 0;
const qd = $e, Nn = fn, De = Xn, tn = me, mv = yv(jo);
function Is(e) {
  return {
    height: (0, tn.may)(Nn.smallIntToApi, e.height)
  };
}
function gv(e) {
  return {
    minHeight: (0, tn.may)(Nn.smallIntToApi, e.minHeight),
    maxHeight: (0, tn.may)(Nn.smallIntToApi, e.maxHeight)
  };
}
function Sv(e) {
  return {
    query: e.query,
    page: (0, tn.may)(Nn.smallIntToApi, e.page),
    per_page: (0, tn.may)(Nn.smallIntToApi, e.per_page),
    order_by: e.order_by
  };
}
function kv(e) {
  return {
    path: (0, tn.assertNotEmpty)(e.path),
    data: (0, qd.toHex)(e.data),
    height: (0, tn.may)(Nn.smallIntToApi, e.height),
    prove: e.prove
  };
}
function Pv(e) {
  return {
    tx: (0, qd.toBase64)((0, tn.assertNotEmpty)(e.tx))
  };
}
function vv(e) {
  return {
    hash: (0, qd.toBase64)((0, tn.assertNotEmpty)(e.hash)),
    prove: e.prove
  };
}
function Rv(e) {
  return {
    query: e.query,
    prove: e.prove,
    page: (0, tn.may)(Nn.smallIntToApi, e.page),
    per_page: (0, tn.may)(Nn.smallIntToApi, e.per_page),
    order_by: e.order_by
  };
}
function Bv(e) {
  return {
    height: (0, tn.may)(Nn.smallIntToApi, e.height),
    page: (0, tn.may)(Nn.smallIntToApi, e.page),
    per_page: (0, tn.may)(Nn.smallIntToApi, e.per_page)
  };
}
let Ov = class {
  static encodeAbciInfo(n) {
    return (0, De.createJsonRpcRequest)(n.method);
  }
  static encodeAbciQuery(n) {
    return (0, De.createJsonRpcRequest)(n.method, kv(n.params));
  }
  static encodeBlock(n) {
    return (0, De.createJsonRpcRequest)(n.method, Is(n.params));
  }
  static encodeBlockchain(n) {
    return (0, De.createJsonRpcRequest)(n.method, gv(n.params));
  }
  static encodeBlockResults(n) {
    return (0, De.createJsonRpcRequest)(n.method, Is(n.params));
  }
  static encodeBlockSearch(n) {
    return (0, De.createJsonRpcRequest)(n.method, Sv(n.params));
  }
  static encodeBroadcastTx(n) {
    return (0, De.createJsonRpcRequest)(n.method, Pv(n.params));
  }
  static encodeCommit(n) {
    return (0, De.createJsonRpcRequest)(n.method, Is(n.params));
  }
  static encodeGenesis(n) {
    return (0, De.createJsonRpcRequest)(n.method);
  }
  static encodeHealth(n) {
    return (0, De.createJsonRpcRequest)(n.method);
  }
  static encodeNumUnconfirmedTxs(n) {
    return (0, De.createJsonRpcRequest)(n.method);
  }
  static encodeStatus(n) {
    return (0, De.createJsonRpcRequest)(n.method);
  }
  static encodeSubscribe(n) {
    const r = { key: "tm.event", value: n.query.type }, t = mv.buildQuery({ tags: [r], raw: n.query.raw });
    return (0, De.createJsonRpcRequest)("subscribe", { query: t });
  }
  static encodeTx(n) {
    return (0, De.createJsonRpcRequest)(n.method, vv(n.params));
  }
  // TODO: encode params for query string???
  static encodeTxSearch(n) {
    return (0, De.createJsonRpcRequest)(n.method, Rv(n.params));
  }
  static encodeValidators(n) {
    return (0, De.createJsonRpcRequest)(n.method, Bv(n.params));
  }
};
Xo.Params = Ov;
var kn = {}, ci = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.BlockIdFlag = void 0, function(n) {
    n[n.Unknown = 0] = "Unknown", n[n.Absent = 1] = "Absent", n[n.Commit = 2] = "Commit", n[n.Nil = 3] = "Nil", n[n.Unrecognized = -1] = "Unrecognized";
  }(e.BlockIdFlag || (e.BlockIdFlag = {}));
})(ci);
var kr = {};
Object.defineProperty(kr, "__esModule", { value: !0 });
kr.hashBlock = kr.hashTx = void 0;
const Vd = ti, Ke = me;
function bv(e) {
  return (0, Vd.sha256)(e);
}
kr.hashTx = bv;
function Av(e) {
  if (e < 1)
    throw new Error("Cannot split an empty tree");
  const n = 2 ** Math.floor(Math.log2(e));
  return n < e ? n : n / 2;
}
function Iv(e) {
  const n = new Vd.Sha256(Uint8Array.from([0]));
  return n.update(e), n.digest();
}
function Tv(e, n) {
  const r = new Vd.Sha256(Uint8Array.from([1]));
  return r.update(e), r.update(n), r.digest();
}
function Ks(e) {
  switch (e.length) {
    case 0:
      throw new Error("Cannot hash empty tree");
    case 1:
      return Iv(e[0]);
    default: {
      const n = Av(e.length), r = Ks(e.slice(0, n)), t = Ks(e.slice(n));
      return Tv(r, t);
    }
  }
}
function Cv(e) {
  if (!e.lastBlockId)
    throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
  const n = [
    (0, Ke.encodeVersion)(e.version),
    (0, Ke.encodeString)(e.chainId),
    (0, Ke.encodeUvarint)(e.height),
    (0, Ke.encodeTime)(e.time),
    (0, Ke.encodeBlockId)(e.lastBlockId),
    (0, Ke.encodeBytes)(e.lastCommitHash),
    (0, Ke.encodeBytes)(e.dataHash),
    (0, Ke.encodeBytes)(e.validatorsHash),
    (0, Ke.encodeBytes)(e.nextValidatorsHash),
    (0, Ke.encodeBytes)(e.consensusHash),
    (0, Ke.encodeBytes)(e.appHash),
    (0, Ke.encodeBytes)(e.lastResultsHash),
    (0, Ke.encodeBytes)(e.evidenceHash),
    (0, Ke.encodeBytes)(e.proposerAddress)
  ];
  return Ks(n);
}
kr.hashBlock = Cv;
Object.defineProperty(kn, "__esModule", { value: !0 });
kn.Responses = kn.decodeValidatorInfo = kn.decodeValidatorGenesis = kn.decodeValidatorUpdate = kn.decodeEvent = void 0;
const ce = $e, wf = an, $r = Fe, se = fn, Nv = ci, X = me, wv = kr;
function _v(e) {
  return {
    data: e.data,
    lastBlockHeight: (0, X.may)(se.apiToSmallInt, e.last_block_height),
    lastBlockAppHash: (0, X.may)(ce.fromBase64, e.last_block_app_hash)
  };
}
function Ev(e) {
  return {
    ops: e.ops.map((n) => ({
      type: n.type,
      key: (0, ce.fromBase64)(n.key),
      data: (0, ce.fromBase64)(n.data)
    }))
  };
}
function Jv(e) {
  return {
    key: (0, ce.fromBase64)((0, X.assertString)(e.key ?? "")),
    value: (0, ce.fromBase64)((0, X.assertString)(e.value ?? "")),
    proof: (0, X.may)(Ev, e.proofOps),
    height: (0, X.may)(se.apiToSmallInt, e.height),
    code: (0, X.may)(se.apiToSmallInt, e.code),
    codespace: (0, X.assertString)(e.codespace ?? ""),
    index: (0, X.may)(se.apiToSmallInt, e.index),
    log: e.log,
    info: (0, X.assertString)(e.info ?? "")
  };
}
function Uv(e) {
  return {
    key: (0, X.assertNotEmpty)(e.key),
    value: e.value ?? ""
  };
}
function Dv(e) {
  return (0, X.assertArray)(e).map(Uv);
}
function _f(e) {
  return {
    type: e.type,
    attributes: e.attributes ? Dv(e.attributes) : []
  };
}
kn.decodeEvent = _f;
function xs(e) {
  return (0, X.assertArray)(e).map(_f);
}
function Pr(e) {
  return {
    code: (0, se.apiToSmallInt)((0, X.assertNumber)(e.code ?? 0)),
    codespace: e.codespace,
    log: e.log,
    data: (0, X.may)(ce.fromBase64, e.data),
    events: e.events ? xs(e.events) : [],
    gasWanted: (0, se.apiToBigInt)(e.gas_wanted ?? "0"),
    gasUsed: (0, se.apiToBigInt)(e.gas_used ?? "0")
  };
}
function Qd(e) {
  if ("Sum" in e) {
    const [[n, r]] = Object.entries(e.Sum.value);
    return (0, wf.assert)(n === "ed25519" || n === "secp256k1", `unknown pubkey type: ${n}`), {
      algorithm: n,
      data: (0, ce.fromBase64)((0, X.assertNotEmpty)(r))
    };
  } else
    switch (e.type) {
      case "tendermint/PubKeyEd25519":
        return {
          algorithm: "ed25519",
          data: (0, ce.fromBase64)((0, X.assertNotEmpty)(e.value))
        };
      case "tendermint/PubKeySecp256k1":
        return {
          algorithm: "secp256k1",
          data: (0, ce.fromBase64)((0, X.assertNotEmpty)(e.value))
        };
      default:
        throw new Error(`unknown pubkey type: ${e.type}`);
    }
}
function Mv(e) {
  return {
    maxBytes: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.max_bytes)),
    maxGas: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.max_gas))
  };
}
function Hv(e) {
  return {
    maxAgeNumBlocks: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.max_age_num_blocks)),
    maxAgeDuration: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.max_age_duration))
  };
}
function Ef(e) {
  return {
    block: Mv((0, X.assertObject)(e.block)),
    evidence: Hv((0, X.assertObject)(e.evidence))
  };
}
function Jf(e) {
  return {
    pubkey: Qd((0, X.assertObject)(e.pub_key)),
    votingPower: (0, se.apiToBigInt)(e.power ?? "0")
  };
}
kn.decodeValidatorUpdate = Jf;
function qv(e) {
  return {
    height: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.height)),
    results: (e.txs_results || []).map(Pr),
    validatorUpdates: (e.validator_updates || []).map(Jf),
    consensusUpdates: (0, X.may)(Ef, e.consensus_param_updates),
    beginBlockEvents: xs(e.begin_block_events || []),
    endBlockEvents: xs(e.end_block_events || [])
  };
}
function ea(e) {
  return {
    hash: (0, ce.fromHex)((0, X.assertNotEmpty)(e.hash)),
    parts: {
      total: (0, X.assertNotEmpty)(e.parts.total),
      hash: (0, ce.fromHex)((0, X.assertNotEmpty)(e.parts.hash))
    }
  };
}
function Vv(e) {
  return {
    block: (0, se.apiToSmallInt)(e.block),
    app: (0, se.apiToSmallInt)(e.app ?? 0)
  };
}
function na(e) {
  return {
    version: Vv(e.version),
    chainId: (0, X.assertNotEmpty)(e.chain_id),
    height: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.height)),
    time: (0, $r.fromRfc3339WithNanoseconds)((0, X.assertNotEmpty)(e.time)),
    // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
    // { hash: '', parts: { total: 0, hash: '' } }
    lastBlockId: e.last_block_id.hash ? ea(e.last_block_id) : null,
    lastCommitHash: (0, ce.fromHex)((0, X.assertSet)(e.last_commit_hash)),
    dataHash: (0, ce.fromHex)((0, X.assertSet)(e.data_hash)),
    validatorsHash: (0, ce.fromHex)((0, X.assertSet)(e.validators_hash)),
    nextValidatorsHash: (0, ce.fromHex)((0, X.assertSet)(e.next_validators_hash)),
    consensusHash: (0, ce.fromHex)((0, X.assertSet)(e.consensus_hash)),
    appHash: (0, ce.fromHex)((0, X.assertSet)(e.app_hash)),
    lastResultsHash: (0, ce.fromHex)((0, X.assertSet)(e.last_results_hash)),
    evidenceHash: (0, ce.fromHex)((0, X.assertSet)(e.evidence_hash)),
    proposerAddress: (0, ce.fromHex)((0, X.assertNotEmpty)(e.proposer_address))
  };
}
function Qv(e) {
  return {
    blockId: ea(e.block_id),
    blockSize: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.block_size)),
    header: na(e.header),
    numTxs: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.num_txs))
  };
}
function Wv(e) {
  return {
    lastHeight: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.last_height)),
    blockMetas: (0, X.assertArray)(e.block_metas).map(Qv)
  };
}
function Fv(e) {
  return {
    ...Pr(e),
    hash: (0, ce.fromHex)((0, X.assertNotEmpty)(e.hash))
  };
}
function Lv(e) {
  const n = e.tx_result ? Pr(e.tx_result) : void 0;
  return {
    height: (0, se.apiToSmallInt)(e.height),
    hash: (0, ce.fromHex)((0, X.assertNotEmpty)(e.hash)),
    checkTx: Pr((0, X.assertObject)(e.check_tx)),
    deliverTx: n,
    txResult: n
  };
}
function Gv(e) {
  return (0, wf.assert)(e in Nv.BlockIdFlag), e;
}
function $v(e) {
  return {
    blockIdFlag: Gv(e.block_id_flag),
    validatorAddress: e.validator_address ? (0, ce.fromHex)(e.validator_address) : void 0,
    timestamp: e.timestamp ? (0, $r.fromRfc3339WithNanoseconds)(e.timestamp) : void 0,
    signature: e.signature ? (0, ce.fromBase64)(e.signature) : void 0
  };
}
function Uf(e) {
  return {
    blockId: ea((0, X.assertObject)(e.block_id)),
    height: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.height)),
    round: (0, se.apiToSmallInt)(e.round),
    signatures: (0, X.assertArray)(e.signatures).map($v)
  };
}
function zv(e) {
  return {
    canonical: (0, X.assertBoolean)(e.canonical),
    header: na(e.signed_header.header),
    commit: Uf(e.signed_header.commit)
  };
}
function Df(e) {
  return {
    address: (0, ce.fromHex)((0, X.assertNotEmpty)(e.address)),
    pubkey: Qd((0, X.assertObject)(e.pub_key)),
    votingPower: (0, se.apiToBigInt)((0, X.assertNotEmpty)(e.power))
  };
}
kn.decodeValidatorGenesis = Df;
function Kv(e) {
  return {
    genesisTime: (0, $r.fromRfc3339WithNanoseconds)((0, X.assertNotEmpty)(e.genesis_time)),
    chainId: (0, X.assertNotEmpty)(e.chain_id),
    consensusParams: Ef(e.consensus_params),
    validators: e.validators ? (0, X.assertArray)(e.validators).map(Df) : [],
    appHash: (0, ce.fromHex)((0, X.assertSet)(e.app_hash)),
    appState: e.app_state
  };
}
function Wd(e) {
  return {
    pubkey: Qd((0, X.assertObject)(e.pub_key)),
    votingPower: (0, se.apiToBigInt)((0, X.assertNotEmpty)(e.voting_power)),
    address: (0, ce.fromHex)((0, X.assertNotEmpty)(e.address)),
    proposerPriority: e.proposer_priority ? (0, se.apiToSmallInt)(e.proposer_priority) : void 0
  };
}
kn.decodeValidatorInfo = Wd;
function xv(e) {
  return {
    id: (0, ce.fromHex)((0, X.assertNotEmpty)(e.id)),
    listenAddr: (0, X.assertNotEmpty)(e.listen_addr),
    network: (0, X.assertNotEmpty)(e.network),
    version: (0, X.assertString)(e.version),
    channels: (0, X.assertNotEmpty)(e.channels),
    moniker: (0, X.assertNotEmpty)(e.moniker),
    other: (0, X.dictionaryToStringMap)(e.other),
    protocolVersion: {
      app: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.protocol_version.app)),
      block: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.protocol_version.block)),
      p2p: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.protocol_version.p2p))
    }
  };
}
function Zv(e) {
  const n = e.earliest_block_height ? (0, se.apiToSmallInt)(e.earliest_block_height) : void 0, r = e.earliest_block_time ? (0, $r.fromRfc3339WithNanoseconds)(e.earliest_block_time) : void 0;
  return {
    earliestAppHash: e.earliest_app_hash ? (0, ce.fromHex)(e.earliest_app_hash) : void 0,
    earliestBlockHash: e.earliest_block_hash ? (0, ce.fromHex)(e.earliest_block_hash) : void 0,
    earliestBlockHeight: n || void 0,
    earliestBlockTime: r != null && r.getTime() ? r : void 0,
    latestBlockHash: (0, ce.fromHex)((0, X.assertNotEmpty)(e.latest_block_hash)),
    latestAppHash: (0, ce.fromHex)((0, X.assertNotEmpty)(e.latest_app_hash)),
    latestBlockTime: (0, $r.fromRfc3339WithNanoseconds)((0, X.assertNotEmpty)(e.latest_block_time)),
    latestBlockHeight: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.latest_block_height)),
    catchingUp: (0, X.assertBoolean)(e.catching_up)
  };
}
function Yv(e) {
  return {
    nodeInfo: xv(e.node_info),
    syncInfo: Zv(e.sync_info),
    validatorInfo: Wd(e.validator_info)
  };
}
function Xv(e) {
  return {
    data: (0, ce.fromBase64)((0, X.assertNotEmpty)(e.data)),
    rootHash: (0, ce.fromHex)((0, X.assertNotEmpty)(e.root_hash)),
    proof: {
      total: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.proof.total)),
      index: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.proof.index)),
      leafHash: (0, ce.fromBase64)((0, X.assertNotEmpty)(e.proof.leaf_hash)),
      aunts: (0, X.assertArray)(e.proof.aunts).map(ce.fromBase64)
    }
  };
}
function Mf(e) {
  return {
    tx: (0, ce.fromBase64)((0, X.assertNotEmpty)(e.tx)),
    result: Pr((0, X.assertObject)(e.tx_result)),
    height: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.height)),
    index: (0, se.apiToSmallInt)((0, X.assertNumber)(e.index)),
    hash: (0, ce.fromHex)((0, X.assertNotEmpty)(e.hash)),
    proof: (0, X.may)(Xv, e.proof)
  };
}
function jv(e) {
  return {
    totalCount: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.total_count)),
    txs: (0, X.assertArray)(e.txs).map(Mf)
  };
}
function eR(e) {
  const n = (0, ce.fromBase64)((0, X.assertNotEmpty)(e.tx));
  return {
    tx: n,
    hash: (0, wv.hashTx)(n),
    result: Pr(e.result),
    height: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.height))
  };
}
function nR(e) {
  return {
    blockHeight: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.block_height)),
    validators: (0, X.assertArray)(e.validators).map(Wd),
    count: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.count)),
    total: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.total))
  };
}
function Hf(e) {
  var n;
  return {
    header: na((0, X.assertObject)(e.header)),
    // For the block at height 1, last commit is not set. This is represented in an empty object like this:
    // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
    lastCommit: e.last_commit.block_id.hash ? Uf((0, X.assertObject)(e.last_commit)) : null,
    txs: e.data.txs ? (0, X.assertArray)(e.data.txs).map(ce.fromBase64) : [],
    // Lift up .evidence.evidence to just .evidence
    // See https://github.com/tendermint/tendermint/issues/7697
    evidence: ((n = e.evidence) == null ? void 0 : n.evidence) ?? []
  };
}
function qf(e) {
  return {
    blockId: ea(e.block_id),
    block: Hf(e.block)
  };
}
function tR(e) {
  return {
    totalCount: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.total_count)),
    blocks: (0, X.assertArray)(e.blocks).map(qf)
  };
}
function rR(e) {
  return {
    total: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.total)),
    totalBytes: (0, se.apiToSmallInt)((0, X.assertNotEmpty)(e.total_bytes))
  };
}
let iR = class Vf {
  static decodeAbciInfo(n) {
    return _v((0, X.assertObject)(n.result.response));
  }
  static decodeAbciQuery(n) {
    return Jv((0, X.assertObject)(n.result.response));
  }
  static decodeBlock(n) {
    return qf(n.result);
  }
  static decodeBlockResults(n) {
    return qv(n.result);
  }
  static decodeBlockSearch(n) {
    return tR(n.result);
  }
  static decodeBlockchain(n) {
    return Wv(n.result);
  }
  static decodeBroadcastTxSync(n) {
    return Fv(n.result);
  }
  static decodeBroadcastTxAsync(n) {
    return Vf.decodeBroadcastTxSync(n);
  }
  static decodeBroadcastTxCommit(n) {
    return Lv(n.result);
  }
  static decodeCommit(n) {
    return zv(n.result);
  }
  static decodeGenesis(n) {
    return Kv((0, X.assertObject)(n.result.genesis));
  }
  static decodeHealth() {
    return null;
  }
  static decodeNumUnconfirmedTxs(n) {
    return rR(n.result);
  }
  static decodeStatus(n) {
    return Yv(n.result);
  }
  static decodeNewBlockEvent(n) {
    return Hf(n.data.value.block);
  }
  static decodeNewBlockHeaderEvent(n) {
    return na(n.data.value.header);
  }
  static decodeTxEvent(n) {
    return eR(n.data.value.TxResult);
  }
  static decodeTx(n) {
    return Mf(n.result);
  }
  static decodeTxSearch(n) {
    return jv(n.result);
  }
  static decodeValidators(n) {
    return nR(n.result);
  }
};
kn.Responses = iR;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Responses = e.Params = void 0;
  var n = Xo;
  Object.defineProperty(e, "Params", { enumerable: !0, get: function() {
    return n.Params;
  } });
  var r = kn;
  Object.defineProperty(e, "Responses", { enumerable: !0, get: function() {
    return r.Responses;
  } });
})(Nf);
var oR = j && j.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), aR = j && j.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), sR = j && j.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var r in e)
      r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && oR(n, e, r);
  return aR(n, e), n;
};
Object.defineProperty(qo, "__esModule", { value: !0 });
qo.Comet38Client = void 0;
const dR = Xn, bi = ii, fe = Nf, Pe = sR(jo);
class $i {
  /**
   * Creates a new Tendermint client for the given endpoint.
   *
   * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
   */
  static async connect(n) {
    let r;
    return typeof n == "object" ? r = new bi.HttpClient(n) : r = n.startsWith("http://") || n.startsWith("https://") ? new bi.HttpClient(n) : new bi.WebsocketClient(n), await this.detectVersion(r), $i.create(r);
  }
  /**
   * Creates a new Tendermint client given an RPC client.
   */
  static async create(n) {
    return new $i(n);
  }
  static async detectVersion(n) {
    const r = (0, dR.createJsonRpcRequest)(Pe.Method.Status), i = (await n.execute(r)).result;
    if (!i || !i.node_info)
      throw new Error("Unrecognized format for status response");
    const f = i.node_info.version;
    if (typeof f != "string")
      throw new Error("Unrecognized version format: must be string");
    return f;
  }
  /**
   * Use `Tendermint37Client.connect` or `Tendermint37Client.create` to create an instance.
   */
  constructor(n) {
    this.client = n;
  }
  disconnect() {
    this.client.disconnect();
  }
  async abciInfo() {
    const n = { method: Pe.Method.AbciInfo };
    return this.doCall(n, fe.Params.encodeAbciInfo, fe.Responses.decodeAbciInfo);
  }
  async abciQuery(n) {
    const r = { params: n, method: Pe.Method.AbciQuery };
    return this.doCall(r, fe.Params.encodeAbciQuery, fe.Responses.decodeAbciQuery);
  }
  async block(n) {
    const r = { method: Pe.Method.Block, params: { height: n } };
    return this.doCall(r, fe.Params.encodeBlock, fe.Responses.decodeBlock);
  }
  async blockResults(n) {
    const r = {
      method: Pe.Method.BlockResults,
      params: { height: n }
    };
    return this.doCall(r, fe.Params.encodeBlockResults, fe.Responses.decodeBlockResults);
  }
  /**
   * Search for events that are in a block.
   *
   * NOTE
   * This method will error on any node that is running a Tendermint version lower than 0.34.9.
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
   */
  async blockSearch(n) {
    const r = { params: n, method: Pe.Method.BlockSearch }, t = await this.doCall(r, fe.Params.encodeBlockSearch, fe.Responses.decodeBlockSearch);
    return {
      ...t,
      // make sure we sort by height, as tendermint may be sorting by string value of the height
      blocks: [...t.blocks].sort((i, f) => i.block.header.height - f.block.header.height)
    };
  }
  // this should paginate through all blockSearch options to ensure it returns all results.
  // starts with page 1 or whatever was provided (eg. to start on page 7)
  //
  // NOTE
  // This method will error on any node that is running a Tendermint version lower than 0.34.9.
  async blockSearchAll(n) {
    let r = n.page || 1;
    const t = [];
    let i = !1;
    for (; !i; ) {
      const f = await this.blockSearch({ ...n, page: r });
      t.push(...f.blocks), t.length < f.totalCount ? r++ : i = !0;
    }
    return t.sort((f, k) => f.block.header.height - k.block.header.height), {
      totalCount: t.length,
      blocks: t
    };
  }
  /**
   * Queries block headers filtered by minHeight <= height <= maxHeight.
   *
   * @param minHeight The minimum height to be included in the result. Defaults to 0.
   * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
   */
  async blockchain(n, r) {
    const t = {
      method: Pe.Method.Blockchain,
      params: {
        minHeight: n,
        maxHeight: r
      }
    };
    return this.doCall(t, fe.Params.encodeBlockchain, fe.Responses.decodeBlockchain);
  }
  /**
   * Broadcast transaction to mempool and wait for response
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
   */
  async broadcastTxSync(n) {
    const r = { params: n, method: Pe.Method.BroadcastTxSync };
    return this.doCall(r, fe.Params.encodeBroadcastTx, fe.Responses.decodeBroadcastTxSync);
  }
  /**
   * Broadcast transaction to mempool and do not wait for result
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
   */
  async broadcastTxAsync(n) {
    const r = { params: n, method: Pe.Method.BroadcastTxAsync };
    return this.doCall(r, fe.Params.encodeBroadcastTx, fe.Responses.decodeBroadcastTxAsync);
  }
  /**
   * Broadcast transaction to mempool and wait for block
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
   */
  async broadcastTxCommit(n) {
    const r = { params: n, method: Pe.Method.BroadcastTxCommit };
    return this.doCall(r, fe.Params.encodeBroadcastTx, fe.Responses.decodeBroadcastTxCommit);
  }
  async commit(n) {
    const r = { method: Pe.Method.Commit, params: { height: n } };
    return this.doCall(r, fe.Params.encodeCommit, fe.Responses.decodeCommit);
  }
  async genesis() {
    const n = { method: Pe.Method.Genesis };
    return this.doCall(n, fe.Params.encodeGenesis, fe.Responses.decodeGenesis);
  }
  async health() {
    const n = { method: Pe.Method.Health };
    return this.doCall(n, fe.Params.encodeHealth, fe.Responses.decodeHealth);
  }
  async numUnconfirmedTxs() {
    const n = { method: Pe.Method.NumUnconfirmedTxs };
    return this.doCall(n, fe.Params.encodeNumUnconfirmedTxs, fe.Responses.decodeNumUnconfirmedTxs);
  }
  async status() {
    const n = { method: Pe.Method.Status };
    return this.doCall(n, fe.Params.encodeStatus, fe.Responses.decodeStatus);
  }
  subscribeNewBlock() {
    const n = {
      method: Pe.Method.Subscribe,
      query: { type: Pe.SubscriptionEventType.NewBlock }
    };
    return this.subscribe(n, fe.Responses.decodeNewBlockEvent);
  }
  subscribeNewBlockHeader() {
    const n = {
      method: Pe.Method.Subscribe,
      query: { type: Pe.SubscriptionEventType.NewBlockHeader }
    };
    return this.subscribe(n, fe.Responses.decodeNewBlockHeaderEvent);
  }
  subscribeTx(n) {
    const r = {
      method: Pe.Method.Subscribe,
      query: {
        type: Pe.SubscriptionEventType.Tx,
        raw: n
      }
    };
    return this.subscribe(r, fe.Responses.decodeTxEvent);
  }
  /**
   * Get a single transaction by hash
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/tx
   */
  async tx(n) {
    const r = { params: n, method: Pe.Method.Tx };
    return this.doCall(r, fe.Params.encodeTx, fe.Responses.decodeTx);
  }
  /**
   * Search for transactions that are in a block
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
   */
  async txSearch(n) {
    const r = { params: n, method: Pe.Method.TxSearch };
    return this.doCall(r, fe.Params.encodeTxSearch, fe.Responses.decodeTxSearch);
  }
  // this should paginate through all txSearch options to ensure it returns all results.
  // starts with page 1 or whatever was provided (eg. to start on page 7)
  async txSearchAll(n) {
    let r = n.page || 1;
    const t = [];
    let i = !1;
    for (; !i; ) {
      const f = await this.txSearch({ ...n, page: r });
      t.push(...f.txs), t.length < f.totalCount ? r++ : i = !0;
    }
    return {
      totalCount: t.length,
      txs: t
    };
  }
  async validators(n) {
    const r = {
      method: Pe.Method.Validators,
      params: n
    };
    return this.doCall(r, fe.Params.encodeValidators, fe.Responses.decodeValidators);
  }
  async validatorsAll(n) {
    const r = [];
    let t = 1, i = !1, f = n;
    for (; !i; ) {
      const k = await this.validators({
        per_page: 50,
        height: f,
        page: t
      });
      r.push(...k.validators), f = f || k.blockHeight, r.length < k.total ? t++ : i = !0;
    }
    return {
      // NOTE: Default value is for type safety but this should always be set
      blockHeight: f ?? 0,
      count: r.length,
      total: r.length,
      validators: r
    };
  }
  // doCall is a helper to handle the encode/call/decode logic
  async doCall(n, r, t) {
    const i = r(n), f = await this.client.execute(i);
    return t(f);
  }
  subscribe(n, r) {
    if (!(0, bi.instanceOfRpcStreamingClient)(this.client))
      throw new Error("This RPC client type cannot subscribe to events");
    const t = fe.Params.encodeSubscribe(n);
    return this.client.listen(t).map((f) => r(f));
  }
}
qo.Comet38Client = $i;
var Qf = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.VoteType = e.broadcastTxCommitSuccess = e.broadcastTxSyncSuccess = void 0;
  function n(t) {
    return t.code === 0;
  }
  e.broadcastTxSyncSuccess = n;
  function r(t) {
    return t.checkTx.code === 0 && !!t.deliverTx && t.deliverTx.code === 0;
  }
  e.broadcastTxCommitSuccess = r, function(t) {
    t[t.PreVote = 1] = "PreVote", t[t.PreCommit = 2] = "PreCommit";
  }(e.VoteType || (e.VoteType = {}));
})(Qf);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.VoteType = e.broadcastTxSyncSuccess = e.broadcastTxCommitSuccess = e.SubscriptionEventType = e.Method = e.Comet38Client = void 0;
  var n = qo;
  Object.defineProperty(e, "Comet38Client", { enumerable: !0, get: function() {
    return n.Comet38Client;
  } });
  var r = jo;
  Object.defineProperty(e, "Method", { enumerable: !0, get: function() {
    return r.Method;
  } }), Object.defineProperty(e, "SubscriptionEventType", { enumerable: !0, get: function() {
    return r.SubscriptionEventType;
  } });
  var t = Qf;
  Object.defineProperty(e, "broadcastTxCommitSuccess", { enumerable: !0, get: function() {
    return t.broadcastTxCommitSuccess;
  } }), Object.defineProperty(e, "broadcastTxSyncSuccess", { enumerable: !0, get: function() {
    return t.broadcastTxSyncSuccess;
  } }), Object.defineProperty(e, "VoteType", { enumerable: !0, get: function() {
    return t.VoteType;
  } });
})(Fi);
var Vr = {}, ta = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.buildQuery = e.SubscriptionEventType = e.Method = void 0, function(r) {
    r.AbciInfo = "abci_info", r.AbciQuery = "abci_query", r.Block = "block", r.Blockchain = "blockchain", r.BlockResults = "block_results", r.BlockSearch = "block_search", r.BroadcastTxAsync = "broadcast_tx_async", r.BroadcastTxSync = "broadcast_tx_sync", r.BroadcastTxCommit = "broadcast_tx_commit", r.Commit = "commit", r.Genesis = "genesis", r.Health = "health", r.NumUnconfirmedTxs = "num_unconfirmed_txs", r.Status = "status", r.Subscribe = "subscribe", r.Tx = "tx", r.TxSearch = "tx_search", r.Validators = "validators", r.Unsubscribe = "unsubscribe";
  }(e.Method || (e.Method = {})), function(r) {
    r.NewBlock = "NewBlock", r.NewBlockHeader = "NewBlockHeader", r.Tx = "Tx";
  }(e.SubscriptionEventType || (e.SubscriptionEventType = {}));
  function n(r) {
    const i = (r.tags ? r.tags : []).map((k) => `${k.key}='${k.value}'`), f = r.raw ? [r.raw] : [];
    return [...i, ...f].join(" AND ");
  }
  e.buildQuery = n;
})(ta);
var Wf = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.VoteType = e.broadcastTxCommitSuccess = e.broadcastTxSyncSuccess = void 0;
  function n(t) {
    return t.code === 0;
  }
  e.broadcastTxSyncSuccess = n;
  function r(t) {
    return t.checkTx.code === 0 && !!t.deliverTx && t.deliverTx.code === 0;
  }
  e.broadcastTxCommitSuccess = r, function(t) {
    t[t.PreVote = 1] = "PreVote", t[t.PreCommit = 2] = "PreCommit";
  }(e.VoteType || (e.VoteType = {}));
})(Wf);
var ra = {}, Ff = {}, ia = {}, uR = j && j.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), cR = j && j.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), lR = j && j.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var r in e)
      r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && uR(n, e, r);
  return cR(n, e), n;
};
Object.defineProperty(ia, "__esModule", { value: !0 });
ia.Params = void 0;
const Fd = $e, wn = fn, Me = Xn, rn = ye, fR = lR(ta);
function Ts(e) {
  return {
    height: (0, rn.may)(wn.smallIntToApi, e.height)
  };
}
function pR(e) {
  return {
    minHeight: (0, rn.may)(wn.smallIntToApi, e.minHeight),
    maxHeight: (0, rn.may)(wn.smallIntToApi, e.maxHeight)
  };
}
function hR(e) {
  return {
    query: e.query,
    page: (0, rn.may)(wn.smallIntToApi, e.page),
    per_page: (0, rn.may)(wn.smallIntToApi, e.per_page),
    order_by: e.order_by
  };
}
function yR(e) {
  return {
    path: (0, rn.assertNotEmpty)(e.path),
    data: (0, Fd.toHex)(e.data),
    height: (0, rn.may)(wn.smallIntToApi, e.height),
    prove: e.prove
  };
}
function mR(e) {
  return {
    tx: (0, Fd.toBase64)((0, rn.assertNotEmpty)(e.tx))
  };
}
function gR(e) {
  return {
    hash: (0, Fd.toBase64)((0, rn.assertNotEmpty)(e.hash)),
    prove: e.prove
  };
}
function SR(e) {
  return {
    query: e.query,
    prove: e.prove,
    page: (0, rn.may)(wn.smallIntToApi, e.page),
    per_page: (0, rn.may)(wn.smallIntToApi, e.per_page),
    order_by: e.order_by
  };
}
function kR(e) {
  return {
    height: (0, rn.may)(wn.smallIntToApi, e.height),
    page: (0, rn.may)(wn.smallIntToApi, e.page),
    per_page: (0, rn.may)(wn.smallIntToApi, e.per_page)
  };
}
let PR = class {
  static encodeAbciInfo(n) {
    return (0, Me.createJsonRpcRequest)(n.method);
  }
  static encodeAbciQuery(n) {
    return (0, Me.createJsonRpcRequest)(n.method, yR(n.params));
  }
  static encodeBlock(n) {
    return (0, Me.createJsonRpcRequest)(n.method, Ts(n.params));
  }
  static encodeBlockchain(n) {
    return (0, Me.createJsonRpcRequest)(n.method, pR(n.params));
  }
  static encodeBlockResults(n) {
    return (0, Me.createJsonRpcRequest)(n.method, Ts(n.params));
  }
  static encodeBlockSearch(n) {
    return (0, Me.createJsonRpcRequest)(n.method, hR(n.params));
  }
  static encodeBroadcastTx(n) {
    return (0, Me.createJsonRpcRequest)(n.method, mR(n.params));
  }
  static encodeCommit(n) {
    return (0, Me.createJsonRpcRequest)(n.method, Ts(n.params));
  }
  static encodeGenesis(n) {
    return (0, Me.createJsonRpcRequest)(n.method);
  }
  static encodeHealth(n) {
    return (0, Me.createJsonRpcRequest)(n.method);
  }
  static encodeNumUnconfirmedTxs(n) {
    return (0, Me.createJsonRpcRequest)(n.method);
  }
  static encodeStatus(n) {
    return (0, Me.createJsonRpcRequest)(n.method);
  }
  static encodeSubscribe(n) {
    const r = { key: "tm.event", value: n.query.type }, t = fR.buildQuery({ tags: [r], raw: n.query.raw });
    return (0, Me.createJsonRpcRequest)("subscribe", { query: t });
  }
  static encodeTx(n) {
    return (0, Me.createJsonRpcRequest)(n.method, gR(n.params));
  }
  // TODO: encode params for query string???
  static encodeTxSearch(n) {
    return (0, Me.createJsonRpcRequest)(n.method, SR(n.params));
  }
  static encodeValidators(n) {
    return (0, Me.createJsonRpcRequest)(n.method, kR(n.params));
  }
};
ia.Params = PR;
var Pn = {}, vr = {};
Object.defineProperty(vr, "__esModule", { value: !0 });
vr.hashBlock = vr.hashTx = void 0;
const Ld = ti, xe = ye;
function vR(e) {
  return (0, Ld.sha256)(e);
}
vr.hashTx = vR;
function RR(e) {
  if (e < 1)
    throw new Error("Cannot split an empty tree");
  const n = 2 ** Math.floor(Math.log2(e));
  return n < e ? n : n / 2;
}
function BR(e) {
  const n = new Ld.Sha256(Uint8Array.from([0]));
  return n.update(e), n.digest();
}
function OR(e, n) {
  const r = new Ld.Sha256(Uint8Array.from([1]));
  return r.update(e), r.update(n), r.digest();
}
function Zs(e) {
  switch (e.length) {
    case 0:
      throw new Error("Cannot hash empty tree");
    case 1:
      return BR(e[0]);
    default: {
      const n = RR(e.length), r = Zs(e.slice(0, n)), t = Zs(e.slice(n));
      return OR(r, t);
    }
  }
}
function bR(e) {
  if (!e.lastBlockId)
    throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
  const n = [
    (0, xe.encodeVersion)(e.version),
    (0, xe.encodeString)(e.chainId),
    (0, xe.encodeUvarint)(e.height),
    (0, xe.encodeTime)(e.time),
    (0, xe.encodeBlockId)(e.lastBlockId),
    (0, xe.encodeBytes)(e.lastCommitHash),
    (0, xe.encodeBytes)(e.dataHash),
    (0, xe.encodeBytes)(e.validatorsHash),
    (0, xe.encodeBytes)(e.nextValidatorsHash),
    (0, xe.encodeBytes)(e.consensusHash),
    (0, xe.encodeBytes)(e.appHash),
    (0, xe.encodeBytes)(e.lastResultsHash),
    (0, xe.encodeBytes)(e.evidenceHash),
    (0, xe.encodeBytes)(e.proposerAddress)
  ];
  return Zs(n);
}
vr.hashBlock = bR;
Object.defineProperty(Pn, "__esModule", { value: !0 });
Pn.Responses = Pn.decodeValidatorInfo = Pn.decodeValidatorGenesis = Pn.decodeValidatorUpdate = Pn.decodeEvent = void 0;
const ae = $e, Lf = an, zr = Fe, de = fn, AR = ci, Z = ye, IR = vr;
function TR(e) {
  return {
    data: e.data,
    lastBlockHeight: (0, Z.may)(de.apiToSmallInt, e.last_block_height),
    lastBlockAppHash: (0, Z.may)(ae.fromBase64, e.last_block_app_hash)
  };
}
function CR(e) {
  return {
    ops: e.ops.map((n) => ({
      type: n.type,
      key: (0, ae.fromBase64)(n.key),
      data: (0, ae.fromBase64)(n.data)
    }))
  };
}
function NR(e) {
  return {
    key: (0, ae.fromBase64)((0, Z.assertString)(e.key ?? "")),
    value: (0, ae.fromBase64)((0, Z.assertString)(e.value ?? "")),
    proof: (0, Z.may)(CR, e.proofOps),
    height: (0, Z.may)(de.apiToSmallInt, e.height),
    code: (0, Z.may)(de.apiToSmallInt, e.code),
    codespace: (0, Z.assertString)(e.codespace ?? ""),
    index: (0, Z.may)(de.apiToSmallInt, e.index),
    log: e.log,
    info: (0, Z.assertString)(e.info ?? "")
  };
}
function wR(e) {
  return {
    key: (0, ae.fromBase64)((0, Z.assertNotEmpty)(e.key)),
    value: (0, ae.fromBase64)((0, Z.assertString)(e.value ?? ""))
  };
}
function _R(e) {
  return (0, Z.assertArray)(e).map(wR);
}
function Gf(e) {
  return {
    type: e.type,
    attributes: e.attributes ? _R(e.attributes) : []
  };
}
Pn.decodeEvent = Gf;
function Ys(e) {
  return (0, Z.assertArray)(e).map(Gf);
}
function Rr(e) {
  return {
    code: (0, de.apiToSmallInt)((0, Z.assertNumber)(e.code ?? 0)),
    codespace: e.codespace,
    log: e.log,
    data: (0, Z.may)(ae.fromBase64, e.data),
    events: e.events ? Ys(e.events) : [],
    gasWanted: (0, de.apiToBigInt)(e.gas_wanted ?? "0"),
    gasUsed: (0, de.apiToBigInt)(e.gas_used ?? "0")
  };
}
function Gd(e) {
  if ("Sum" in e) {
    const [[n, r]] = Object.entries(e.Sum.value);
    return (0, Lf.assert)(n === "ed25519" || n === "secp256k1", `unknown pubkey type: ${n}`), {
      algorithm: n,
      data: (0, ae.fromBase64)((0, Z.assertNotEmpty)(r))
    };
  } else
    switch (e.type) {
      case "tendermint/PubKeyEd25519":
        return {
          algorithm: "ed25519",
          data: (0, ae.fromBase64)((0, Z.assertNotEmpty)(e.value))
        };
      case "tendermint/PubKeySecp256k1":
        return {
          algorithm: "secp256k1",
          data: (0, ae.fromBase64)((0, Z.assertNotEmpty)(e.value))
        };
      default:
        throw new Error(`unknown pubkey type: ${e.type}`);
    }
}
function ER(e) {
  return {
    maxBytes: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.max_bytes)),
    maxGas: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.max_gas))
  };
}
function JR(e) {
  return {
    maxAgeNumBlocks: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.max_age_num_blocks)),
    maxAgeDuration: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.max_age_duration))
  };
}
function $f(e) {
  return {
    block: ER((0, Z.assertObject)(e.block)),
    evidence: JR((0, Z.assertObject)(e.evidence))
  };
}
function zf(e) {
  return {
    pubkey: Gd((0, Z.assertObject)(e.pub_key)),
    votingPower: (0, de.apiToBigInt)(e.power ?? "0")
  };
}
Pn.decodeValidatorUpdate = zf;
function UR(e) {
  return {
    height: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.height)),
    results: (e.txs_results || []).map(Rr),
    validatorUpdates: (e.validator_updates || []).map(zf),
    consensusUpdates: (0, Z.may)($f, e.consensus_param_updates),
    beginBlockEvents: Ys(e.begin_block_events || []),
    endBlockEvents: Ys(e.end_block_events || [])
  };
}
function oa(e) {
  return {
    hash: (0, ae.fromHex)((0, Z.assertNotEmpty)(e.hash)),
    parts: {
      total: (0, Z.assertNotEmpty)(e.parts.total),
      hash: (0, ae.fromHex)((0, Z.assertNotEmpty)(e.parts.hash))
    }
  };
}
function DR(e) {
  return {
    block: (0, de.apiToSmallInt)(e.block),
    app: (0, de.apiToSmallInt)(e.app ?? 0)
  };
}
function aa(e) {
  return {
    version: DR(e.version),
    chainId: (0, Z.assertNotEmpty)(e.chain_id),
    height: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.height)),
    time: (0, zr.fromRfc3339WithNanoseconds)((0, Z.assertNotEmpty)(e.time)),
    // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
    // { hash: '', parts: { total: 0, hash: '' } }
    lastBlockId: e.last_block_id.hash ? oa(e.last_block_id) : null,
    lastCommitHash: (0, ae.fromHex)((0, Z.assertSet)(e.last_commit_hash)),
    dataHash: (0, ae.fromHex)((0, Z.assertSet)(e.data_hash)),
    validatorsHash: (0, ae.fromHex)((0, Z.assertSet)(e.validators_hash)),
    nextValidatorsHash: (0, ae.fromHex)((0, Z.assertSet)(e.next_validators_hash)),
    consensusHash: (0, ae.fromHex)((0, Z.assertSet)(e.consensus_hash)),
    appHash: (0, ae.fromHex)((0, Z.assertSet)(e.app_hash)),
    lastResultsHash: (0, ae.fromHex)((0, Z.assertSet)(e.last_results_hash)),
    evidenceHash: (0, ae.fromHex)((0, Z.assertSet)(e.evidence_hash)),
    proposerAddress: (0, ae.fromHex)((0, Z.assertNotEmpty)(e.proposer_address))
  };
}
function MR(e) {
  return {
    blockId: oa(e.block_id),
    blockSize: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.block_size)),
    header: aa(e.header),
    numTxs: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.num_txs))
  };
}
function HR(e) {
  return {
    lastHeight: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.last_height)),
    blockMetas: (0, Z.assertArray)(e.block_metas).map(MR)
  };
}
function qR(e) {
  return {
    ...Rr(e),
    hash: (0, ae.fromHex)((0, Z.assertNotEmpty)(e.hash))
  };
}
function VR(e) {
  return {
    height: (0, de.apiToSmallInt)(e.height),
    hash: (0, ae.fromHex)((0, Z.assertNotEmpty)(e.hash)),
    checkTx: Rr((0, Z.assertObject)(e.check_tx)),
    deliverTx: (0, Z.may)(Rr, e.deliver_tx)
  };
}
function QR(e) {
  return (0, Lf.assert)(e in AR.BlockIdFlag), e;
}
function WR(e) {
  return {
    blockIdFlag: QR(e.block_id_flag),
    validatorAddress: e.validator_address ? (0, ae.fromHex)(e.validator_address) : void 0,
    timestamp: e.timestamp ? (0, zr.fromRfc3339WithNanoseconds)(e.timestamp) : void 0,
    signature: e.signature ? (0, ae.fromBase64)(e.signature) : void 0
  };
}
function Kf(e) {
  return {
    blockId: oa((0, Z.assertObject)(e.block_id)),
    height: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.height)),
    round: (0, de.apiToSmallInt)(e.round),
    signatures: (0, Z.assertArray)(e.signatures).map(WR)
  };
}
function FR(e) {
  return {
    canonical: (0, Z.assertBoolean)(e.canonical),
    header: aa(e.signed_header.header),
    commit: Kf(e.signed_header.commit)
  };
}
function xf(e) {
  return {
    address: (0, ae.fromHex)((0, Z.assertNotEmpty)(e.address)),
    pubkey: Gd((0, Z.assertObject)(e.pub_key)),
    votingPower: (0, de.apiToBigInt)((0, Z.assertNotEmpty)(e.power))
  };
}
Pn.decodeValidatorGenesis = xf;
function LR(e) {
  return {
    genesisTime: (0, zr.fromRfc3339WithNanoseconds)((0, Z.assertNotEmpty)(e.genesis_time)),
    chainId: (0, Z.assertNotEmpty)(e.chain_id),
    consensusParams: $f(e.consensus_params),
    validators: e.validators ? (0, Z.assertArray)(e.validators).map(xf) : [],
    appHash: (0, ae.fromHex)((0, Z.assertSet)(e.app_hash)),
    appState: e.app_state
  };
}
function $d(e) {
  return {
    pubkey: Gd((0, Z.assertObject)(e.pub_key)),
    votingPower: (0, de.apiToBigInt)((0, Z.assertNotEmpty)(e.voting_power)),
    address: (0, ae.fromHex)((0, Z.assertNotEmpty)(e.address)),
    proposerPriority: e.proposer_priority ? (0, de.apiToSmallInt)(e.proposer_priority) : void 0
  };
}
Pn.decodeValidatorInfo = $d;
function GR(e) {
  return {
    id: (0, ae.fromHex)((0, Z.assertNotEmpty)(e.id)),
    listenAddr: (0, Z.assertNotEmpty)(e.listen_addr),
    network: (0, Z.assertNotEmpty)(e.network),
    version: (0, Z.assertString)(e.version),
    channels: (0, Z.assertNotEmpty)(e.channels),
    moniker: (0, Z.assertNotEmpty)(e.moniker),
    other: (0, Z.dictionaryToStringMap)(e.other),
    protocolVersion: {
      app: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.protocol_version.app)),
      block: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.protocol_version.block)),
      p2p: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.protocol_version.p2p))
    }
  };
}
function $R(e) {
  const n = e.earliest_block_height ? (0, de.apiToSmallInt)(e.earliest_block_height) : void 0, r = e.earliest_block_time ? (0, zr.fromRfc3339WithNanoseconds)(e.earliest_block_time) : void 0;
  return {
    earliestAppHash: e.earliest_app_hash ? (0, ae.fromHex)(e.earliest_app_hash) : void 0,
    earliestBlockHash: e.earliest_block_hash ? (0, ae.fromHex)(e.earliest_block_hash) : void 0,
    earliestBlockHeight: n || void 0,
    earliestBlockTime: r != null && r.getTime() ? r : void 0,
    latestBlockHash: (0, ae.fromHex)((0, Z.assertNotEmpty)(e.latest_block_hash)),
    latestAppHash: (0, ae.fromHex)((0, Z.assertNotEmpty)(e.latest_app_hash)),
    latestBlockTime: (0, zr.fromRfc3339WithNanoseconds)((0, Z.assertNotEmpty)(e.latest_block_time)),
    latestBlockHeight: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.latest_block_height)),
    catchingUp: (0, Z.assertBoolean)(e.catching_up)
  };
}
function zR(e) {
  return {
    nodeInfo: GR(e.node_info),
    syncInfo: $R(e.sync_info),
    validatorInfo: $d(e.validator_info)
  };
}
function KR(e) {
  return {
    data: (0, ae.fromBase64)((0, Z.assertNotEmpty)(e.data)),
    rootHash: (0, ae.fromHex)((0, Z.assertNotEmpty)(e.root_hash)),
    proof: {
      total: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.proof.total)),
      index: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.proof.index)),
      leafHash: (0, ae.fromBase64)((0, Z.assertNotEmpty)(e.proof.leaf_hash)),
      aunts: (0, Z.assertArray)(e.proof.aunts).map(ae.fromBase64)
    }
  };
}
function Zf(e) {
  return {
    tx: (0, ae.fromBase64)((0, Z.assertNotEmpty)(e.tx)),
    result: Rr((0, Z.assertObject)(e.tx_result)),
    height: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.height)),
    index: (0, de.apiToSmallInt)((0, Z.assertNumber)(e.index)),
    hash: (0, ae.fromHex)((0, Z.assertNotEmpty)(e.hash)),
    proof: (0, Z.may)(KR, e.proof)
  };
}
function xR(e) {
  return {
    totalCount: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.total_count)),
    txs: (0, Z.assertArray)(e.txs).map(Zf)
  };
}
function ZR(e) {
  const n = (0, ae.fromBase64)((0, Z.assertNotEmpty)(e.tx));
  return {
    tx: n,
    hash: (0, IR.hashTx)(n),
    result: Rr(e.result),
    height: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.height))
  };
}
function YR(e) {
  return {
    blockHeight: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.block_height)),
    validators: (0, Z.assertArray)(e.validators).map($d),
    count: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.count)),
    total: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.total))
  };
}
function Yf(e) {
  var n;
  return {
    header: aa((0, Z.assertObject)(e.header)),
    // For the block at height 1, last commit is not set. This is represented in an empty object like this:
    // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
    lastCommit: e.last_commit.block_id.hash ? Kf((0, Z.assertObject)(e.last_commit)) : null,
    txs: e.data.txs ? (0, Z.assertArray)(e.data.txs).map(ae.fromBase64) : [],
    // Lift up .evidence.evidence to just .evidence
    // See https://github.com/tendermint/tendermint/issues/7697
    evidence: ((n = e.evidence) == null ? void 0 : n.evidence) ?? []
  };
}
function Xf(e) {
  return {
    blockId: oa(e.block_id),
    block: Yf(e.block)
  };
}
function XR(e) {
  return {
    totalCount: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.total_count)),
    blocks: (0, Z.assertArray)(e.blocks).map(Xf)
  };
}
function jR(e) {
  return {
    total: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.total)),
    totalBytes: (0, de.apiToSmallInt)((0, Z.assertNotEmpty)(e.total_bytes))
  };
}
let eB = class jf {
  static decodeAbciInfo(n) {
    return TR((0, Z.assertObject)(n.result.response));
  }
  static decodeAbciQuery(n) {
    return NR((0, Z.assertObject)(n.result.response));
  }
  static decodeBlock(n) {
    return Xf(n.result);
  }
  static decodeBlockResults(n) {
    return UR(n.result);
  }
  static decodeBlockSearch(n) {
    return XR(n.result);
  }
  static decodeBlockchain(n) {
    return HR(n.result);
  }
  static decodeBroadcastTxSync(n) {
    return qR(n.result);
  }
  static decodeBroadcastTxAsync(n) {
    return jf.decodeBroadcastTxSync(n);
  }
  static decodeBroadcastTxCommit(n) {
    return VR(n.result);
  }
  static decodeCommit(n) {
    return FR(n.result);
  }
  static decodeGenesis(n) {
    return LR((0, Z.assertObject)(n.result.genesis));
  }
  static decodeHealth() {
    return null;
  }
  static decodeNumUnconfirmedTxs(n) {
    return jR(n.result);
  }
  static decodeStatus(n) {
    return zR(n.result);
  }
  static decodeNewBlockEvent(n) {
    return Yf(n.data.value.block);
  }
  static decodeNewBlockHeaderEvent(n) {
    return aa(n.data.value.header);
  }
  static decodeTxEvent(n) {
    return ZR(n.data.value.TxResult);
  }
  static decodeTx(n) {
    return Zf(n.result);
  }
  static decodeTxSearch(n) {
    return xR(n.result);
  }
  static decodeValidators(n) {
    return YR(n.result);
  }
};
Pn.Responses = eB;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Responses = e.Params = void 0;
  var n = ia;
  Object.defineProperty(e, "Params", { enumerable: !0, get: function() {
    return n.Params;
  } });
  var r = Pn;
  Object.defineProperty(e, "Responses", { enumerable: !0, get: function() {
    return r.Responses;
  } });
})(Ff);
var nB = j && j.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), tB = j && j.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), rB = j && j.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var r in e)
      r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && nB(n, e, r);
  return tB(n, e), n;
};
Object.defineProperty(ra, "__esModule", { value: !0 });
ra.Tendermint34Client = void 0;
const iB = Xn, Ai = ii, pe = Ff, ve = rB(ta);
class zi {
  /**
   * Creates a new Tendermint client for the given endpoint.
   *
   * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
   */
  static async connect(n) {
    let r;
    return typeof n == "object" ? r = new Ai.HttpClient(n) : r = n.startsWith("http://") || n.startsWith("https://") ? new Ai.HttpClient(n) : new Ai.WebsocketClient(n), await this.detectVersion(r), zi.create(r);
  }
  /**
   * Creates a new Tendermint client given an RPC client.
   */
  static async create(n) {
    return new zi(n);
  }
  static async detectVersion(n) {
    const r = (0, iB.createJsonRpcRequest)(ve.Method.Status), i = (await n.execute(r)).result;
    if (!i || !i.node_info)
      throw new Error("Unrecognized format for status response");
    const f = i.node_info.version;
    if (typeof f != "string")
      throw new Error("Unrecognized version format: must be string");
    return f;
  }
  /**
   * Use `Tendermint34Client.connect` or `Tendermint34Client.create` to create an instance.
   */
  constructor(n) {
    this.client = n;
  }
  disconnect() {
    this.client.disconnect();
  }
  async abciInfo() {
    const n = { method: ve.Method.AbciInfo };
    return this.doCall(n, pe.Params.encodeAbciInfo, pe.Responses.decodeAbciInfo);
  }
  async abciQuery(n) {
    const r = { params: n, method: ve.Method.AbciQuery };
    return this.doCall(r, pe.Params.encodeAbciQuery, pe.Responses.decodeAbciQuery);
  }
  async block(n) {
    const r = { method: ve.Method.Block, params: { height: n } };
    return this.doCall(r, pe.Params.encodeBlock, pe.Responses.decodeBlock);
  }
  async blockResults(n) {
    const r = {
      method: ve.Method.BlockResults,
      params: { height: n }
    };
    return this.doCall(r, pe.Params.encodeBlockResults, pe.Responses.decodeBlockResults);
  }
  /**
   * Search for events that are in a block.
   *
   * NOTE
   * This method will error on any node that is running a Tendermint version lower than 0.34.9.
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
   */
  async blockSearch(n) {
    const r = { params: n, method: ve.Method.BlockSearch }, t = await this.doCall(r, pe.Params.encodeBlockSearch, pe.Responses.decodeBlockSearch);
    return {
      ...t,
      // make sure we sort by height, as tendermint may be sorting by string value of the height
      blocks: [...t.blocks].sort((i, f) => i.block.header.height - f.block.header.height)
    };
  }
  // this should paginate through all blockSearch options to ensure it returns all results.
  // starts with page 1 or whatever was provided (eg. to start on page 7)
  //
  // NOTE
  // This method will error on any node that is running a Tendermint version lower than 0.34.9.
  async blockSearchAll(n) {
    let r = n.page || 1;
    const t = [];
    let i = !1;
    for (; !i; ) {
      const f = await this.blockSearch({ ...n, page: r });
      t.push(...f.blocks), t.length < f.totalCount ? r++ : i = !0;
    }
    return t.sort((f, k) => f.block.header.height - k.block.header.height), {
      totalCount: t.length,
      blocks: t
    };
  }
  /**
   * Queries block headers filtered by minHeight <= height <= maxHeight.
   *
   * @param minHeight The minimum height to be included in the result. Defaults to 0.
   * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
   */
  async blockchain(n, r) {
    const t = {
      method: ve.Method.Blockchain,
      params: {
        minHeight: n,
        maxHeight: r
      }
    };
    return this.doCall(t, pe.Params.encodeBlockchain, pe.Responses.decodeBlockchain);
  }
  /**
   * Broadcast transaction to mempool and wait for response
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
   */
  async broadcastTxSync(n) {
    const r = { params: n, method: ve.Method.BroadcastTxSync };
    return this.doCall(r, pe.Params.encodeBroadcastTx, pe.Responses.decodeBroadcastTxSync);
  }
  /**
   * Broadcast transaction to mempool and do not wait for result
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
   */
  async broadcastTxAsync(n) {
    const r = { params: n, method: ve.Method.BroadcastTxAsync };
    return this.doCall(r, pe.Params.encodeBroadcastTx, pe.Responses.decodeBroadcastTxAsync);
  }
  /**
   * Broadcast transaction to mempool and wait for block
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
   */
  async broadcastTxCommit(n) {
    const r = { params: n, method: ve.Method.BroadcastTxCommit };
    return this.doCall(r, pe.Params.encodeBroadcastTx, pe.Responses.decodeBroadcastTxCommit);
  }
  async commit(n) {
    const r = { method: ve.Method.Commit, params: { height: n } };
    return this.doCall(r, pe.Params.encodeCommit, pe.Responses.decodeCommit);
  }
  async genesis() {
    const n = { method: ve.Method.Genesis };
    return this.doCall(n, pe.Params.encodeGenesis, pe.Responses.decodeGenesis);
  }
  async health() {
    const n = { method: ve.Method.Health };
    return this.doCall(n, pe.Params.encodeHealth, pe.Responses.decodeHealth);
  }
  async numUnconfirmedTxs() {
    const n = { method: ve.Method.NumUnconfirmedTxs };
    return this.doCall(n, pe.Params.encodeNumUnconfirmedTxs, pe.Responses.decodeNumUnconfirmedTxs);
  }
  async status() {
    const n = { method: ve.Method.Status };
    return this.doCall(n, pe.Params.encodeStatus, pe.Responses.decodeStatus);
  }
  subscribeNewBlock() {
    const n = {
      method: ve.Method.Subscribe,
      query: { type: ve.SubscriptionEventType.NewBlock }
    };
    return this.subscribe(n, pe.Responses.decodeNewBlockEvent);
  }
  subscribeNewBlockHeader() {
    const n = {
      method: ve.Method.Subscribe,
      query: { type: ve.SubscriptionEventType.NewBlockHeader }
    };
    return this.subscribe(n, pe.Responses.decodeNewBlockHeaderEvent);
  }
  subscribeTx(n) {
    const r = {
      method: ve.Method.Subscribe,
      query: {
        type: ve.SubscriptionEventType.Tx,
        raw: n
      }
    };
    return this.subscribe(r, pe.Responses.decodeTxEvent);
  }
  /**
   * Get a single transaction by hash
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/tx
   */
  async tx(n) {
    const r = { params: n, method: ve.Method.Tx };
    return this.doCall(r, pe.Params.encodeTx, pe.Responses.decodeTx);
  }
  /**
   * Search for transactions that are in a block
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
   */
  async txSearch(n) {
    const r = { params: n, method: ve.Method.TxSearch };
    return this.doCall(r, pe.Params.encodeTxSearch, pe.Responses.decodeTxSearch);
  }
  // this should paginate through all txSearch options to ensure it returns all results.
  // starts with page 1 or whatever was provided (eg. to start on page 7)
  async txSearchAll(n) {
    let r = n.page || 1;
    const t = [];
    let i = !1;
    for (; !i; ) {
      const f = await this.txSearch({ ...n, page: r });
      t.push(...f.txs), t.length < f.totalCount ? r++ : i = !0;
    }
    return {
      totalCount: t.length,
      txs: t
    };
  }
  async validators(n) {
    const r = {
      method: ve.Method.Validators,
      params: n
    };
    return this.doCall(r, pe.Params.encodeValidators, pe.Responses.decodeValidators);
  }
  async validatorsAll(n) {
    const r = [];
    let t = 1, i = !1, f = n;
    for (; !i; ) {
      const k = await this.validators({
        per_page: 50,
        height: f,
        page: t
      });
      r.push(...k.validators), f = f || k.blockHeight, r.length < k.total ? t++ : i = !0;
    }
    return {
      // NOTE: Default value is for type safety but this should always be set
      blockHeight: f ?? 0,
      count: r.length,
      total: r.length,
      validators: r
    };
  }
  // doCall is a helper to handle the encode/call/decode logic
  async doCall(n, r, t) {
    const i = r(n), f = await this.client.execute(i);
    return t(f);
  }
  subscribe(n, r) {
    if (!(0, Ai.instanceOfRpcStreamingClient)(this.client))
      throw new Error("This RPC client type cannot subscribe to events");
    const t = pe.Params.encodeSubscribe(n);
    return this.client.listen(t).map((f) => r(f));
  }
}
ra.Tendermint34Client = zi;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Tendermint34Client = e.VoteType = e.broadcastTxSyncSuccess = e.broadcastTxCommitSuccess = e.SubscriptionEventType = e.Method = void 0;
  var n = ta;
  Object.defineProperty(e, "Method", { enumerable: !0, get: function() {
    return n.Method;
  } }), Object.defineProperty(e, "SubscriptionEventType", { enumerable: !0, get: function() {
    return n.SubscriptionEventType;
  } });
  var r = Wf;
  Object.defineProperty(e, "broadcastTxCommitSuccess", { enumerable: !0, get: function() {
    return r.broadcastTxCommitSuccess;
  } }), Object.defineProperty(e, "broadcastTxSyncSuccess", { enumerable: !0, get: function() {
    return r.broadcastTxSyncSuccess;
  } }), Object.defineProperty(e, "VoteType", { enumerable: !0, get: function() {
    return r.VoteType;
  } });
  var t = ra;
  Object.defineProperty(e, "Tendermint34Client", { enumerable: !0, get: function() {
    return t.Tendermint34Client;
  } });
})(Vr);
var Ki = {}, sa = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.buildQuery = e.SubscriptionEventType = e.Method = void 0, function(r) {
    r.AbciInfo = "abci_info", r.AbciQuery = "abci_query", r.Block = "block", r.Blockchain = "blockchain", r.BlockResults = "block_results", r.BlockSearch = "block_search", r.BroadcastTxAsync = "broadcast_tx_async", r.BroadcastTxSync = "broadcast_tx_sync", r.BroadcastTxCommit = "broadcast_tx_commit", r.Commit = "commit", r.Genesis = "genesis", r.Health = "health", r.NumUnconfirmedTxs = "num_unconfirmed_txs", r.Status = "status", r.Subscribe = "subscribe", r.Tx = "tx", r.TxSearch = "tx_search", r.Validators = "validators", r.Unsubscribe = "unsubscribe";
  }(e.Method || (e.Method = {})), function(r) {
    r.NewBlock = "NewBlock", r.NewBlockHeader = "NewBlockHeader", r.Tx = "Tx";
  }(e.SubscriptionEventType || (e.SubscriptionEventType = {}));
  function n(r) {
    const i = (r.tags ? r.tags : []).map((k) => `${k.key}='${k.value}'`), f = r.raw ? [r.raw] : [];
    return [...i, ...f].join(" AND ");
  }
  e.buildQuery = n;
})(sa);
var ep = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.VoteType = e.broadcastTxCommitSuccess = e.broadcastTxSyncSuccess = void 0;
  function n(t) {
    return t.code === 0;
  }
  e.broadcastTxSyncSuccess = n;
  function r(t) {
    return t.checkTx.code === 0 && !!t.deliverTx && t.deliverTx.code === 0;
  }
  e.broadcastTxCommitSuccess = r, function(t) {
    t[t.PreVote = 1] = "PreVote", t[t.PreCommit = 2] = "PreCommit";
  }(e.VoteType || (e.VoteType = {}));
})(ep);
var da = {}, np = {}, ua = {}, ge = {};
Object.defineProperty(ge, "__esModule", { value: !0 });
ge.encodeBlockId = ge.encodeVersion = ge.encodeBytes = ge.encodeTime = ge.encodeUvarint = ge.encodeString = ge.dictionaryToStringMap = ge.may = ge.assertNotEmpty = ge.assertObject = ge.assertArray = ge.assertNumber = ge.assertString = ge.assertBoolean = ge.assertSet = void 0;
const oB = $e;
function Ut(e) {
  if (e === void 0)
    throw new Error("Value must not be undefined");
  if (e === null)
    throw new Error("Value must not be null");
  return e;
}
ge.assertSet = Ut;
function aB(e) {
  if (Ut(e), typeof e != "boolean")
    throw new Error("Value must be a boolean");
  return e;
}
ge.assertBoolean = aB;
function sB(e) {
  if (Ut(e), typeof e != "string")
    throw new Error("Value must be a string");
  return e;
}
ge.assertString = sB;
function dB(e) {
  if (Ut(e), typeof e != "number")
    throw new Error("Value must be a number");
  return e;
}
ge.assertNumber = dB;
function uB(e) {
  if (Ut(e), !Array.isArray(e))
    throw new Error("Value must be a an array");
  return e;
}
ge.assertArray = uB;
function cB(e) {
  if (Ut(e), typeof e != "object")
    throw new Error("Value must be an object");
  if (Object.prototype.toString.call(e) !== "[object Object]")
    throw new Error("Value must be a simple object");
  return e;
}
ge.assertObject = cB;
function lB(e) {
  if (Ut(e), typeof e == "number" && e === 0)
    throw new Error("must provide a non-zero value");
  if (e.length === 0)
    throw new Error("must provide a non-empty value");
  return e;
}
ge.assertNotEmpty = lB;
function fB(e, n) {
  return n == null ? void 0 : e(n);
}
ge.may = fB;
function pB(e) {
  const n = /* @__PURE__ */ new Map();
  for (const r of Object.keys(e)) {
    const t = e[r];
    if (typeof t != "string")
      throw new Error("Found dictionary value of type other than string");
    n.set(r, t);
  }
  return n;
}
ge.dictionaryToStringMap = pB;
function hB(e) {
  const n = (0, oB.toUtf8)(e);
  return Uint8Array.from([n.length, ...n]);
}
ge.encodeString = hB;
function Br(e) {
  return e >= 128 ? (
    // eslint-disable-next-line no-bitwise
    Uint8Array.from([e & 255 | 128, ...Br(e >> 7)])
  ) : (
    // eslint-disable-next-line no-bitwise
    Uint8Array.from([e & 255])
  );
}
ge.encodeUvarint = Br;
function yB(e) {
  const n = e.getTime(), r = Math.floor(n / 1e3), t = r ? [8, ...Br(r)] : new Uint8Array(), i = (e.nanoseconds || 0) + n % 1e3 * 1e6, f = i ? [16, ...Br(i)] : new Uint8Array();
  return Uint8Array.from([...t, ...f]);
}
ge.encodeTime = yB;
function mB(e) {
  if (e.length >= 128)
    throw new Error("Not implemented for byte arrays of length 128 or more");
  return e.length ? Uint8Array.from([e.length, ...e]) : new Uint8Array();
}
ge.encodeBytes = mB;
function gB(e) {
  const n = e.block ? Uint8Array.from([8, ...Br(e.block)]) : new Uint8Array(), r = e.app ? Uint8Array.from([16, ...Br(e.app)]) : new Uint8Array();
  return Uint8Array.from([...n, ...r]);
}
ge.encodeVersion = gB;
function SB(e) {
  return Uint8Array.from([
    10,
    e.hash.length,
    ...e.hash,
    18,
    e.parts.hash.length + 4,
    8,
    e.parts.total,
    18,
    e.parts.hash.length,
    ...e.parts.hash
  ]);
}
ge.encodeBlockId = SB;
var kB = j && j.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), PB = j && j.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), vB = j && j.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var r in e)
      r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && kB(n, e, r);
  return PB(n, e), n;
};
Object.defineProperty(ua, "__esModule", { value: !0 });
ua.Params = void 0;
const zd = $e, _n = fn, He = Xn, on = ge, RB = vB(sa);
function Cs(e) {
  return {
    height: (0, on.may)(_n.smallIntToApi, e.height)
  };
}
function BB(e) {
  return {
    minHeight: (0, on.may)(_n.smallIntToApi, e.minHeight),
    maxHeight: (0, on.may)(_n.smallIntToApi, e.maxHeight)
  };
}
function OB(e) {
  return {
    query: e.query,
    page: (0, on.may)(_n.smallIntToApi, e.page),
    per_page: (0, on.may)(_n.smallIntToApi, e.per_page),
    order_by: e.order_by
  };
}
function bB(e) {
  return {
    path: (0, on.assertNotEmpty)(e.path),
    data: (0, zd.toHex)(e.data),
    height: (0, on.may)(_n.smallIntToApi, e.height),
    prove: e.prove
  };
}
function AB(e) {
  return {
    tx: (0, zd.toBase64)((0, on.assertNotEmpty)(e.tx))
  };
}
function IB(e) {
  return {
    hash: (0, zd.toBase64)((0, on.assertNotEmpty)(e.hash)),
    prove: e.prove
  };
}
function TB(e) {
  return {
    query: e.query,
    prove: e.prove,
    page: (0, on.may)(_n.smallIntToApi, e.page),
    per_page: (0, on.may)(_n.smallIntToApi, e.per_page),
    order_by: e.order_by
  };
}
function CB(e) {
  return {
    height: (0, on.may)(_n.smallIntToApi, e.height),
    page: (0, on.may)(_n.smallIntToApi, e.page),
    per_page: (0, on.may)(_n.smallIntToApi, e.per_page)
  };
}
class NB {
  static encodeAbciInfo(n) {
    return (0, He.createJsonRpcRequest)(n.method);
  }
  static encodeAbciQuery(n) {
    return (0, He.createJsonRpcRequest)(n.method, bB(n.params));
  }
  static encodeBlock(n) {
    return (0, He.createJsonRpcRequest)(n.method, Cs(n.params));
  }
  static encodeBlockchain(n) {
    return (0, He.createJsonRpcRequest)(n.method, BB(n.params));
  }
  static encodeBlockResults(n) {
    return (0, He.createJsonRpcRequest)(n.method, Cs(n.params));
  }
  static encodeBlockSearch(n) {
    return (0, He.createJsonRpcRequest)(n.method, OB(n.params));
  }
  static encodeBroadcastTx(n) {
    return (0, He.createJsonRpcRequest)(n.method, AB(n.params));
  }
  static encodeCommit(n) {
    return (0, He.createJsonRpcRequest)(n.method, Cs(n.params));
  }
  static encodeGenesis(n) {
    return (0, He.createJsonRpcRequest)(n.method);
  }
  static encodeHealth(n) {
    return (0, He.createJsonRpcRequest)(n.method);
  }
  static encodeNumUnconfirmedTxs(n) {
    return (0, He.createJsonRpcRequest)(n.method);
  }
  static encodeStatus(n) {
    return (0, He.createJsonRpcRequest)(n.method);
  }
  static encodeSubscribe(n) {
    const r = { key: "tm.event", value: n.query.type }, t = RB.buildQuery({ tags: [r], raw: n.query.raw });
    return (0, He.createJsonRpcRequest)("subscribe", { query: t });
  }
  static encodeTx(n) {
    return (0, He.createJsonRpcRequest)(n.method, IB(n.params));
  }
  // TODO: encode params for query string???
  static encodeTxSearch(n) {
    return (0, He.createJsonRpcRequest)(n.method, TB(n.params));
  }
  static encodeValidators(n) {
    return (0, He.createJsonRpcRequest)(n.method, CB(n.params));
  }
}
ua.Params = NB;
var vn = {}, Or = {};
Object.defineProperty(Or, "__esModule", { value: !0 });
Or.hashBlock = Or.hashTx = void 0;
const Kd = ti, Ze = ge;
function wB(e) {
  return (0, Kd.sha256)(e);
}
Or.hashTx = wB;
function _B(e) {
  if (e < 1)
    throw new Error("Cannot split an empty tree");
  const n = 2 ** Math.floor(Math.log2(e));
  return n < e ? n : n / 2;
}
function EB(e) {
  const n = new Kd.Sha256(Uint8Array.from([0]));
  return n.update(e), n.digest();
}
function JB(e, n) {
  const r = new Kd.Sha256(Uint8Array.from([1]));
  return r.update(e), r.update(n), r.digest();
}
function Xs(e) {
  switch (e.length) {
    case 0:
      throw new Error("Cannot hash empty tree");
    case 1:
      return EB(e[0]);
    default: {
      const n = _B(e.length), r = Xs(e.slice(0, n)), t = Xs(e.slice(n));
      return JB(r, t);
    }
  }
}
function UB(e) {
  if (!e.lastBlockId)
    throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
  const n = [
    (0, Ze.encodeVersion)(e.version),
    (0, Ze.encodeString)(e.chainId),
    (0, Ze.encodeUvarint)(e.height),
    (0, Ze.encodeTime)(e.time),
    (0, Ze.encodeBlockId)(e.lastBlockId),
    (0, Ze.encodeBytes)(e.lastCommitHash),
    (0, Ze.encodeBytes)(e.dataHash),
    (0, Ze.encodeBytes)(e.validatorsHash),
    (0, Ze.encodeBytes)(e.nextValidatorsHash),
    (0, Ze.encodeBytes)(e.consensusHash),
    (0, Ze.encodeBytes)(e.appHash),
    (0, Ze.encodeBytes)(e.lastResultsHash),
    (0, Ze.encodeBytes)(e.evidenceHash),
    (0, Ze.encodeBytes)(e.proposerAddress)
  ];
  return Xs(n);
}
Or.hashBlock = UB;
Object.defineProperty(vn, "__esModule", { value: !0 });
vn.Responses = vn.decodeValidatorInfo = vn.decodeValidatorGenesis = vn.decodeValidatorUpdate = vn.decodeEvent = void 0;
const le = $e, tp = an, Kr = Fe, ue = fn, DB = ci, Y = ge, MB = Or;
function HB(e) {
  return {
    data: e.data,
    lastBlockHeight: (0, Y.may)(ue.apiToSmallInt, e.last_block_height),
    lastBlockAppHash: (0, Y.may)(le.fromBase64, e.last_block_app_hash)
  };
}
function qB(e) {
  return {
    ops: e.ops.map((n) => ({
      type: n.type,
      key: (0, le.fromBase64)(n.key),
      data: (0, le.fromBase64)(n.data)
    }))
  };
}
function VB(e) {
  return {
    key: (0, le.fromBase64)((0, Y.assertString)(e.key ?? "")),
    value: (0, le.fromBase64)((0, Y.assertString)(e.value ?? "")),
    proof: (0, Y.may)(qB, e.proofOps),
    height: (0, Y.may)(ue.apiToSmallInt, e.height),
    code: (0, Y.may)(ue.apiToSmallInt, e.code),
    codespace: (0, Y.assertString)(e.codespace ?? ""),
    index: (0, Y.may)(ue.apiToSmallInt, e.index),
    log: e.log,
    info: (0, Y.assertString)(e.info ?? "")
  };
}
function QB(e) {
  return {
    key: (0, Y.assertNotEmpty)(e.key),
    value: e.value ?? ""
  };
}
function WB(e) {
  return (0, Y.assertArray)(e).map(QB);
}
function rp(e) {
  return {
    type: e.type,
    attributes: e.attributes ? WB(e.attributes) : []
  };
}
vn.decodeEvent = rp;
function js(e) {
  return (0, Y.assertArray)(e).map(rp);
}
function br(e) {
  return {
    code: (0, ue.apiToSmallInt)((0, Y.assertNumber)(e.code ?? 0)),
    codespace: e.codespace,
    log: e.log,
    data: (0, Y.may)(le.fromBase64, e.data),
    events: e.events ? js(e.events) : [],
    gasWanted: (0, ue.apiToBigInt)(e.gas_wanted ?? "0"),
    gasUsed: (0, ue.apiToBigInt)(e.gas_used ?? "0")
  };
}
function xd(e) {
  if ("Sum" in e) {
    const [[n, r]] = Object.entries(e.Sum.value);
    return (0, tp.assert)(n === "ed25519" || n === "secp256k1", `unknown pubkey type: ${n}`), {
      algorithm: n,
      data: (0, le.fromBase64)((0, Y.assertNotEmpty)(r))
    };
  } else
    switch (e.type) {
      case "tendermint/PubKeyEd25519":
        return {
          algorithm: "ed25519",
          data: (0, le.fromBase64)((0, Y.assertNotEmpty)(e.value))
        };
      case "tendermint/PubKeySecp256k1":
        return {
          algorithm: "secp256k1",
          data: (0, le.fromBase64)((0, Y.assertNotEmpty)(e.value))
        };
      default:
        throw new Error(`unknown pubkey type: ${e.type}`);
    }
}
function FB(e) {
  return {
    maxBytes: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.max_bytes)),
    maxGas: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.max_gas))
  };
}
function LB(e) {
  return {
    maxAgeNumBlocks: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.max_age_num_blocks)),
    maxAgeDuration: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.max_age_duration))
  };
}
function ip(e) {
  return {
    block: FB((0, Y.assertObject)(e.block)),
    evidence: LB((0, Y.assertObject)(e.evidence))
  };
}
function op(e) {
  return {
    pubkey: xd((0, Y.assertObject)(e.pub_key)),
    votingPower: (0, ue.apiToBigInt)(e.power ?? "0")
  };
}
vn.decodeValidatorUpdate = op;
function GB(e) {
  return {
    height: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.height)),
    results: (e.txs_results || []).map(br),
    validatorUpdates: (e.validator_updates || []).map(op),
    consensusUpdates: (0, Y.may)(ip, e.consensus_param_updates),
    beginBlockEvents: js(e.begin_block_events || []),
    endBlockEvents: js(e.end_block_events || [])
  };
}
function ca(e) {
  return {
    hash: (0, le.fromHex)((0, Y.assertNotEmpty)(e.hash)),
    parts: {
      total: (0, Y.assertNotEmpty)(e.parts.total),
      hash: (0, le.fromHex)((0, Y.assertNotEmpty)(e.parts.hash))
    }
  };
}
function $B(e) {
  return {
    block: (0, ue.apiToSmallInt)(e.block),
    app: (0, ue.apiToSmallInt)(e.app ?? 0)
  };
}
function la(e) {
  return {
    version: $B(e.version),
    chainId: (0, Y.assertNotEmpty)(e.chain_id),
    height: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.height)),
    time: (0, Kr.fromRfc3339WithNanoseconds)((0, Y.assertNotEmpty)(e.time)),
    // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
    // { hash: '', parts: { total: 0, hash: '' } }
    lastBlockId: e.last_block_id.hash ? ca(e.last_block_id) : null,
    lastCommitHash: (0, le.fromHex)((0, Y.assertSet)(e.last_commit_hash)),
    dataHash: (0, le.fromHex)((0, Y.assertSet)(e.data_hash)),
    validatorsHash: (0, le.fromHex)((0, Y.assertSet)(e.validators_hash)),
    nextValidatorsHash: (0, le.fromHex)((0, Y.assertSet)(e.next_validators_hash)),
    consensusHash: (0, le.fromHex)((0, Y.assertSet)(e.consensus_hash)),
    appHash: (0, le.fromHex)((0, Y.assertSet)(e.app_hash)),
    lastResultsHash: (0, le.fromHex)((0, Y.assertSet)(e.last_results_hash)),
    evidenceHash: (0, le.fromHex)((0, Y.assertSet)(e.evidence_hash)),
    proposerAddress: (0, le.fromHex)((0, Y.assertNotEmpty)(e.proposer_address))
  };
}
function zB(e) {
  return {
    blockId: ca(e.block_id),
    blockSize: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.block_size)),
    header: la(e.header),
    numTxs: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.num_txs))
  };
}
function KB(e) {
  return {
    lastHeight: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.last_height)),
    blockMetas: (0, Y.assertArray)(e.block_metas).map(zB)
  };
}
function xB(e) {
  return {
    ...br(e),
    hash: (0, le.fromHex)((0, Y.assertNotEmpty)(e.hash))
  };
}
function ZB(e) {
  return {
    height: (0, ue.apiToSmallInt)(e.height),
    hash: (0, le.fromHex)((0, Y.assertNotEmpty)(e.hash)),
    checkTx: br((0, Y.assertObject)(e.check_tx)),
    deliverTx: (0, Y.may)(br, e.deliver_tx)
  };
}
function YB(e) {
  return (0, tp.assert)(e in DB.BlockIdFlag), e;
}
function XB(e) {
  return {
    blockIdFlag: YB(e.block_id_flag),
    validatorAddress: e.validator_address ? (0, le.fromHex)(e.validator_address) : void 0,
    timestamp: e.timestamp ? (0, Kr.fromRfc3339WithNanoseconds)(e.timestamp) : void 0,
    signature: e.signature ? (0, le.fromBase64)(e.signature) : void 0
  };
}
function ap(e) {
  return {
    blockId: ca((0, Y.assertObject)(e.block_id)),
    height: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.height)),
    round: (0, ue.apiToSmallInt)(e.round),
    signatures: (0, Y.assertArray)(e.signatures).map(XB)
  };
}
function jB(e) {
  return {
    canonical: (0, Y.assertBoolean)(e.canonical),
    header: la(e.signed_header.header),
    commit: ap(e.signed_header.commit)
  };
}
function sp(e) {
  return {
    address: (0, le.fromHex)((0, Y.assertNotEmpty)(e.address)),
    pubkey: xd((0, Y.assertObject)(e.pub_key)),
    votingPower: (0, ue.apiToBigInt)((0, Y.assertNotEmpty)(e.power))
  };
}
vn.decodeValidatorGenesis = sp;
function eO(e) {
  return {
    genesisTime: (0, Kr.fromRfc3339WithNanoseconds)((0, Y.assertNotEmpty)(e.genesis_time)),
    chainId: (0, Y.assertNotEmpty)(e.chain_id),
    consensusParams: ip(e.consensus_params),
    validators: e.validators ? (0, Y.assertArray)(e.validators).map(sp) : [],
    appHash: (0, le.fromHex)((0, Y.assertSet)(e.app_hash)),
    appState: e.app_state
  };
}
function Zd(e) {
  return {
    pubkey: xd((0, Y.assertObject)(e.pub_key)),
    votingPower: (0, ue.apiToBigInt)((0, Y.assertNotEmpty)(e.voting_power)),
    address: (0, le.fromHex)((0, Y.assertNotEmpty)(e.address)),
    proposerPriority: e.proposer_priority ? (0, ue.apiToSmallInt)(e.proposer_priority) : void 0
  };
}
vn.decodeValidatorInfo = Zd;
function nO(e) {
  return {
    id: (0, le.fromHex)((0, Y.assertNotEmpty)(e.id)),
    listenAddr: (0, Y.assertNotEmpty)(e.listen_addr),
    network: (0, Y.assertNotEmpty)(e.network),
    version: (0, Y.assertString)(e.version),
    channels: (0, Y.assertNotEmpty)(e.channels),
    moniker: (0, Y.assertNotEmpty)(e.moniker),
    other: (0, Y.dictionaryToStringMap)(e.other),
    protocolVersion: {
      app: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.protocol_version.app)),
      block: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.protocol_version.block)),
      p2p: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.protocol_version.p2p))
    }
  };
}
function tO(e) {
  const n = e.earliest_block_height ? (0, ue.apiToSmallInt)(e.earliest_block_height) : void 0, r = e.earliest_block_time ? (0, Kr.fromRfc3339WithNanoseconds)(e.earliest_block_time) : void 0;
  return {
    earliestAppHash: e.earliest_app_hash ? (0, le.fromHex)(e.earliest_app_hash) : void 0,
    earliestBlockHash: e.earliest_block_hash ? (0, le.fromHex)(e.earliest_block_hash) : void 0,
    earliestBlockHeight: n || void 0,
    earliestBlockTime: r != null && r.getTime() ? r : void 0,
    latestBlockHash: (0, le.fromHex)((0, Y.assertNotEmpty)(e.latest_block_hash)),
    latestAppHash: (0, le.fromHex)((0, Y.assertNotEmpty)(e.latest_app_hash)),
    latestBlockTime: (0, Kr.fromRfc3339WithNanoseconds)((0, Y.assertNotEmpty)(e.latest_block_time)),
    latestBlockHeight: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.latest_block_height)),
    catchingUp: (0, Y.assertBoolean)(e.catching_up)
  };
}
function rO(e) {
  return {
    nodeInfo: nO(e.node_info),
    syncInfo: tO(e.sync_info),
    validatorInfo: Zd(e.validator_info)
  };
}
function iO(e) {
  return {
    data: (0, le.fromBase64)((0, Y.assertNotEmpty)(e.data)),
    rootHash: (0, le.fromHex)((0, Y.assertNotEmpty)(e.root_hash)),
    proof: {
      total: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.proof.total)),
      index: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.proof.index)),
      leafHash: (0, le.fromBase64)((0, Y.assertNotEmpty)(e.proof.leaf_hash)),
      aunts: (0, Y.assertArray)(e.proof.aunts).map(le.fromBase64)
    }
  };
}
function dp(e) {
  return {
    tx: (0, le.fromBase64)((0, Y.assertNotEmpty)(e.tx)),
    result: br((0, Y.assertObject)(e.tx_result)),
    height: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.height)),
    index: (0, ue.apiToSmallInt)((0, Y.assertNumber)(e.index)),
    hash: (0, le.fromHex)((0, Y.assertNotEmpty)(e.hash)),
    proof: (0, Y.may)(iO, e.proof)
  };
}
function oO(e) {
  return {
    totalCount: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.total_count)),
    txs: (0, Y.assertArray)(e.txs).map(dp)
  };
}
function aO(e) {
  const n = (0, le.fromBase64)((0, Y.assertNotEmpty)(e.tx));
  return {
    tx: n,
    hash: (0, MB.hashTx)(n),
    result: br(e.result),
    height: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.height))
  };
}
function sO(e) {
  return {
    blockHeight: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.block_height)),
    validators: (0, Y.assertArray)(e.validators).map(Zd),
    count: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.count)),
    total: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.total))
  };
}
function up(e) {
  var n;
  return {
    header: la((0, Y.assertObject)(e.header)),
    // For the block at height 1, last commit is not set. This is represented in an empty object like this:
    // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
    lastCommit: e.last_commit.block_id.hash ? ap((0, Y.assertObject)(e.last_commit)) : null,
    txs: e.data.txs ? (0, Y.assertArray)(e.data.txs).map(le.fromBase64) : [],
    // Lift up .evidence.evidence to just .evidence
    // See https://github.com/tendermint/tendermint/issues/7697
    evidence: ((n = e.evidence) == null ? void 0 : n.evidence) ?? []
  };
}
function cp(e) {
  return {
    blockId: ca(e.block_id),
    block: up(e.block)
  };
}
function dO(e) {
  return {
    totalCount: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.total_count)),
    blocks: (0, Y.assertArray)(e.blocks).map(cp)
  };
}
function uO(e) {
  return {
    total: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.total)),
    totalBytes: (0, ue.apiToSmallInt)((0, Y.assertNotEmpty)(e.total_bytes))
  };
}
class Yd {
  static decodeAbciInfo(n) {
    return HB((0, Y.assertObject)(n.result.response));
  }
  static decodeAbciQuery(n) {
    return VB((0, Y.assertObject)(n.result.response));
  }
  static decodeBlock(n) {
    return cp(n.result);
  }
  static decodeBlockResults(n) {
    return GB(n.result);
  }
  static decodeBlockSearch(n) {
    return dO(n.result);
  }
  static decodeBlockchain(n) {
    return KB(n.result);
  }
  static decodeBroadcastTxSync(n) {
    return xB(n.result);
  }
  static decodeBroadcastTxAsync(n) {
    return Yd.decodeBroadcastTxSync(n);
  }
  static decodeBroadcastTxCommit(n) {
    return ZB(n.result);
  }
  static decodeCommit(n) {
    return jB(n.result);
  }
  static decodeGenesis(n) {
    return eO((0, Y.assertObject)(n.result.genesis));
  }
  static decodeHealth() {
    return null;
  }
  static decodeNumUnconfirmedTxs(n) {
    return uO(n.result);
  }
  static decodeStatus(n) {
    return rO(n.result);
  }
  static decodeNewBlockEvent(n) {
    return up(n.data.value.block);
  }
  static decodeNewBlockHeaderEvent(n) {
    return la(n.data.value.header);
  }
  static decodeTxEvent(n) {
    return aO(n.data.value.TxResult);
  }
  static decodeTx(n) {
    return dp(n.result);
  }
  static decodeTxSearch(n) {
    return oO(n.result);
  }
  static decodeValidators(n) {
    return sO(n.result);
  }
}
vn.Responses = Yd;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Responses = e.Params = void 0;
  var n = ua;
  Object.defineProperty(e, "Params", { enumerable: !0, get: function() {
    return n.Params;
  } });
  var r = vn;
  Object.defineProperty(e, "Responses", { enumerable: !0, get: function() {
    return r.Responses;
  } });
})(np);
var cO = j && j.__createBinding || (Object.create ? function(e, n, r, t) {
  t === void 0 && (t = r);
  var i = Object.getOwnPropertyDescriptor(n, r);
  (!i || ("get" in i ? !n.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return n[r];
  } }), Object.defineProperty(e, t, i);
} : function(e, n, r, t) {
  t === void 0 && (t = r), e[t] = n[r];
}), lO = j && j.__setModuleDefault || (Object.create ? function(e, n) {
  Object.defineProperty(e, "default", { enumerable: !0, value: n });
} : function(e, n) {
  e.default = n;
}), fO = j && j.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var n = {};
  if (e != null)
    for (var r in e)
      r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && cO(n, e, r);
  return lO(n, e), n;
};
Object.defineProperty(da, "__esModule", { value: !0 });
da.Tendermint37Client = void 0;
const pO = Xn, Ii = ii, he = np, Re = fO(sa);
class xi {
  /**
   * Creates a new Tendermint client for the given endpoint.
   *
   * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
   */
  static async connect(n) {
    let r;
    return typeof n == "object" ? r = new Ii.HttpClient(n) : r = n.startsWith("http://") || n.startsWith("https://") ? new Ii.HttpClient(n) : new Ii.WebsocketClient(n), await this.detectVersion(r), xi.create(r);
  }
  /**
   * Creates a new Tendermint client given an RPC client.
   */
  static async create(n) {
    return new xi(n);
  }
  static async detectVersion(n) {
    const r = (0, pO.createJsonRpcRequest)(Re.Method.Status), i = (await n.execute(r)).result;
    if (!i || !i.node_info)
      throw new Error("Unrecognized format for status response");
    const f = i.node_info.version;
    if (typeof f != "string")
      throw new Error("Unrecognized version format: must be string");
    return f;
  }
  /**
   * Use `Tendermint37Client.connect` or `Tendermint37Client.create` to create an instance.
   */
  constructor(n) {
    this.client = n;
  }
  disconnect() {
    this.client.disconnect();
  }
  async abciInfo() {
    const n = { method: Re.Method.AbciInfo };
    return this.doCall(n, he.Params.encodeAbciInfo, he.Responses.decodeAbciInfo);
  }
  async abciQuery(n) {
    const r = { params: n, method: Re.Method.AbciQuery };
    return this.doCall(r, he.Params.encodeAbciQuery, he.Responses.decodeAbciQuery);
  }
  async block(n) {
    const r = { method: Re.Method.Block, params: { height: n } };
    return this.doCall(r, he.Params.encodeBlock, he.Responses.decodeBlock);
  }
  async blockResults(n) {
    const r = {
      method: Re.Method.BlockResults,
      params: { height: n }
    };
    return this.doCall(r, he.Params.encodeBlockResults, he.Responses.decodeBlockResults);
  }
  /**
   * Search for events that are in a block.
   *
   * NOTE
   * This method will error on any node that is running a Tendermint version lower than 0.34.9.
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
   */
  async blockSearch(n) {
    const r = { params: n, method: Re.Method.BlockSearch }, t = await this.doCall(r, he.Params.encodeBlockSearch, he.Responses.decodeBlockSearch);
    return {
      ...t,
      // make sure we sort by height, as tendermint may be sorting by string value of the height
      blocks: [...t.blocks].sort((i, f) => i.block.header.height - f.block.header.height)
    };
  }
  // this should paginate through all blockSearch options to ensure it returns all results.
  // starts with page 1 or whatever was provided (eg. to start on page 7)
  //
  // NOTE
  // This method will error on any node that is running a Tendermint version lower than 0.34.9.
  async blockSearchAll(n) {
    let r = n.page || 1;
    const t = [];
    let i = !1;
    for (; !i; ) {
      const f = await this.blockSearch({ ...n, page: r });
      t.push(...f.blocks), t.length < f.totalCount ? r++ : i = !0;
    }
    return t.sort((f, k) => f.block.header.height - k.block.header.height), {
      totalCount: t.length,
      blocks: t
    };
  }
  /**
   * Queries block headers filtered by minHeight <= height <= maxHeight.
   *
   * @param minHeight The minimum height to be included in the result. Defaults to 0.
   * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
   */
  async blockchain(n, r) {
    const t = {
      method: Re.Method.Blockchain,
      params: {
        minHeight: n,
        maxHeight: r
      }
    };
    return this.doCall(t, he.Params.encodeBlockchain, he.Responses.decodeBlockchain);
  }
  /**
   * Broadcast transaction to mempool and wait for response
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
   */
  async broadcastTxSync(n) {
    const r = { params: n, method: Re.Method.BroadcastTxSync };
    return this.doCall(r, he.Params.encodeBroadcastTx, he.Responses.decodeBroadcastTxSync);
  }
  /**
   * Broadcast transaction to mempool and do not wait for result
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
   */
  async broadcastTxAsync(n) {
    const r = { params: n, method: Re.Method.BroadcastTxAsync };
    return this.doCall(r, he.Params.encodeBroadcastTx, he.Responses.decodeBroadcastTxAsync);
  }
  /**
   * Broadcast transaction to mempool and wait for block
   *
   * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
   */
  async broadcastTxCommit(n) {
    const r = { params: n, method: Re.Method.BroadcastTxCommit };
    return this.doCall(r, he.Params.encodeBroadcastTx, he.Responses.decodeBroadcastTxCommit);
  }
  async commit(n) {
    const r = { method: Re.Method.Commit, params: { height: n } };
    return this.doCall(r, he.Params.encodeCommit, he.Responses.decodeCommit);
  }
  async genesis() {
    const n = { method: Re.Method.Genesis };
    return this.doCall(n, he.Params.encodeGenesis, he.Responses.decodeGenesis);
  }
  async health() {
    const n = { method: Re.Method.Health };
    return this.doCall(n, he.Params.encodeHealth, he.Responses.decodeHealth);
  }
  async numUnconfirmedTxs() {
    const n = { method: Re.Method.NumUnconfirmedTxs };
    return this.doCall(n, he.Params.encodeNumUnconfirmedTxs, he.Responses.decodeNumUnconfirmedTxs);
  }
  async status() {
    const n = { method: Re.Method.Status };
    return this.doCall(n, he.Params.encodeStatus, he.Responses.decodeStatus);
  }
  subscribeNewBlock() {
    const n = {
      method: Re.Method.Subscribe,
      query: { type: Re.SubscriptionEventType.NewBlock }
    };
    return this.subscribe(n, he.Responses.decodeNewBlockEvent);
  }
  subscribeNewBlockHeader() {
    const n = {
      method: Re.Method.Subscribe,
      query: { type: Re.SubscriptionEventType.NewBlockHeader }
    };
    return this.subscribe(n, he.Responses.decodeNewBlockHeaderEvent);
  }
  subscribeTx(n) {
    const r = {
      method: Re.Method.Subscribe,
      query: {
        type: Re.SubscriptionEventType.Tx,
        raw: n
      }
    };
    return this.subscribe(r, he.Responses.decodeTxEvent);
  }
  /**
   * Get a single transaction by hash
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/tx
   */
  async tx(n) {
    const r = { params: n, method: Re.Method.Tx };
    return this.doCall(r, he.Params.encodeTx, he.Responses.decodeTx);
  }
  /**
   * Search for transactions that are in a block
   *
   * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
   */
  async txSearch(n) {
    const r = { params: n, method: Re.Method.TxSearch };
    return this.doCall(r, he.Params.encodeTxSearch, he.Responses.decodeTxSearch);
  }
  // this should paginate through all txSearch options to ensure it returns all results.
  // starts with page 1 or whatever was provided (eg. to start on page 7)
  async txSearchAll(n) {
    let r = n.page || 1;
    const t = [];
    let i = !1;
    for (; !i; ) {
      const f = await this.txSearch({ ...n, page: r });
      t.push(...f.txs), t.length < f.totalCount ? r++ : i = !0;
    }
    return {
      totalCount: t.length,
      txs: t
    };
  }
  async validators(n) {
    const r = {
      method: Re.Method.Validators,
      params: n
    };
    return this.doCall(r, he.Params.encodeValidators, he.Responses.decodeValidators);
  }
  async validatorsAll(n) {
    const r = [];
    let t = 1, i = !1, f = n;
    for (; !i; ) {
      const k = await this.validators({
        per_page: 50,
        height: f,
        page: t
      });
      r.push(...k.validators), f = f || k.blockHeight, r.length < k.total ? t++ : i = !0;
    }
    return {
      // NOTE: Default value is for type safety but this should always be set
      blockHeight: f ?? 0,
      count: r.length,
      total: r.length,
      validators: r
    };
  }
  // doCall is a helper to handle the encode/call/decode logic
  async doCall(n, r, t) {
    const i = r(n), f = await this.client.execute(i);
    return t(f);
  }
  subscribe(n, r) {
    if (!(0, Ii.instanceOfRpcStreamingClient)(this.client))
      throw new Error("This RPC client type cannot subscribe to events");
    const t = he.Params.encodeSubscribe(n);
    return this.client.listen(t).map((f) => r(f));
  }
}
da.Tendermint37Client = xi;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Tendermint37Client = e.VoteType = e.broadcastTxSyncSuccess = e.broadcastTxCommitSuccess = e.SubscriptionEventType = e.Method = void 0;
  var n = sa;
  Object.defineProperty(e, "Method", { enumerable: !0, get: function() {
    return n.Method;
  } }), Object.defineProperty(e, "SubscriptionEventType", { enumerable: !0, get: function() {
    return n.SubscriptionEventType;
  } });
  var r = ep;
  Object.defineProperty(e, "broadcastTxCommitSuccess", { enumerable: !0, get: function() {
    return r.broadcastTxCommitSuccess;
  } }), Object.defineProperty(e, "broadcastTxSyncSuccess", { enumerable: !0, get: function() {
    return r.broadcastTxSyncSuccess;
  } }), Object.defineProperty(e, "VoteType", { enumerable: !0, get: function() {
    return r.VoteType;
  } });
  var t = da;
  Object.defineProperty(e, "Tendermint37Client", { enumerable: !0, get: function() {
    return t.Tendermint37Client;
  } });
})(Ki);
var Fn = {};
Object.defineProperty(Fn, "__esModule", { value: !0 });
Fn.connectComet = Fn.isComet38Client = Fn.isTendermint37Client = Fn.isTendermint34Client = void 0;
const lp = Fi, fp = Vr, pp = Ki;
function hO(e) {
  return e instanceof fp.Tendermint34Client;
}
Fn.isTendermint34Client = hO;
function yO(e) {
  return e instanceof pp.Tendermint37Client;
}
Fn.isTendermint37Client = yO;
function mO(e) {
  return e instanceof lp.Comet38Client;
}
Fn.isComet38Client = mO;
async function gO(e) {
  let n;
  const r = await pp.Tendermint37Client.connect(e), t = (await r.status()).nodeInfo.version;
  return t.startsWith("0.37.") ? n = r : t.startsWith("0.38.") ? (r.disconnect(), n = await lp.Comet38Client.connect(e)) : (r.disconnect(), n = await fp.Tendermint34Client.connect(e)), n;
}
Fn.connectComet = gO;
(function(e) {
  var n = j && j.__createBinding || (Object.create ? function(P, b, c, l) {
    l === void 0 && (l = c);
    var y = Object.getOwnPropertyDescriptor(b, c);
    (!y || ("get" in y ? !b.__esModule : y.writable || y.configurable)) && (y = { enumerable: !0, get: function() {
      return b[c];
    } }), Object.defineProperty(P, l, y);
  } : function(P, b, c, l) {
    l === void 0 && (l = c), P[l] = b[c];
  }), r = j && j.__setModuleDefault || (Object.create ? function(P, b) {
    Object.defineProperty(P, "default", { enumerable: !0, value: b });
  } : function(P, b) {
    P.default = b;
  }), t = j && j.__importStar || function(P) {
    if (P && P.__esModule)
      return P;
    var b = {};
    if (P != null)
      for (var c in P)
        c !== "default" && Object.prototype.hasOwnProperty.call(P, c) && n(b, P, c);
    return r(b, P), b;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.BlockIdFlag = e.isTendermint37Client = e.isTendermint34Client = e.isComet38Client = e.connectComet = e.Tendermint37Client = e.tendermint37 = e.Tendermint34Client = e.tendermint34 = e.VoteType = e.SubscriptionEventType = e.Method = e.broadcastTxSyncSuccess = e.broadcastTxCommitSuccess = e.WebsocketClient = e.HttpClient = e.HttpBatchClient = e.Comet38Client = e.comet38 = e.toSeconds = e.toRfc3339WithNanoseconds = e.fromSeconds = e.fromRfc3339WithNanoseconds = e.DateTime = e.rawSecp256k1PubkeyToRawAddress = e.rawEd25519PubkeyToRawAddress = e.pubkeyToRawAddress = e.pubkeyToAddress = void 0;
  var i = qn;
  Object.defineProperty(e, "pubkeyToAddress", { enumerable: !0, get: function() {
    return i.pubkeyToAddress;
  } }), Object.defineProperty(e, "pubkeyToRawAddress", { enumerable: !0, get: function() {
    return i.pubkeyToRawAddress;
  } }), Object.defineProperty(e, "rawEd25519PubkeyToRawAddress", { enumerable: !0, get: function() {
    return i.rawEd25519PubkeyToRawAddress;
  } }), Object.defineProperty(e, "rawSecp256k1PubkeyToRawAddress", { enumerable: !0, get: function() {
    return i.rawSecp256k1PubkeyToRawAddress;
  } });
  var f = Fe;
  Object.defineProperty(e, "DateTime", { enumerable: !0, get: function() {
    return f.DateTime;
  } }), Object.defineProperty(e, "fromRfc3339WithNanoseconds", { enumerable: !0, get: function() {
    return f.fromRfc3339WithNanoseconds;
  } }), Object.defineProperty(e, "fromSeconds", { enumerable: !0, get: function() {
    return f.fromSeconds;
  } }), Object.defineProperty(e, "toRfc3339WithNanoseconds", { enumerable: !0, get: function() {
    return f.toRfc3339WithNanoseconds;
  } }), Object.defineProperty(e, "toSeconds", { enumerable: !0, get: function() {
    return f.toSeconds;
  } }), e.comet38 = t(Fi);
  var k = Fi;
  Object.defineProperty(e, "Comet38Client", { enumerable: !0, get: function() {
    return k.Comet38Client;
  } });
  var C = ii;
  Object.defineProperty(e, "HttpBatchClient", { enumerable: !0, get: function() {
    return C.HttpBatchClient;
  } }), Object.defineProperty(e, "HttpClient", { enumerable: !0, get: function() {
    return C.HttpClient;
  } }), Object.defineProperty(e, "WebsocketClient", { enumerable: !0, get: function() {
    return C.WebsocketClient;
  } });
  var T = Vr;
  Object.defineProperty(e, "broadcastTxCommitSuccess", { enumerable: !0, get: function() {
    return T.broadcastTxCommitSuccess;
  } }), Object.defineProperty(e, "broadcastTxSyncSuccess", { enumerable: !0, get: function() {
    return T.broadcastTxSyncSuccess;
  } }), Object.defineProperty(e, "Method", { enumerable: !0, get: function() {
    return T.Method;
  } }), Object.defineProperty(e, "SubscriptionEventType", { enumerable: !0, get: function() {
    return T.SubscriptionEventType;
  } }), Object.defineProperty(e, "VoteType", { enumerable: !0, get: function() {
    return T.VoteType;
  } }), e.tendermint34 = t(Vr);
  var U = Vr;
  Object.defineProperty(e, "Tendermint34Client", { enumerable: !0, get: function() {
    return U.Tendermint34Client;
  } }), e.tendermint37 = t(Ki);
  var w = Ki;
  Object.defineProperty(e, "Tendermint37Client", { enumerable: !0, get: function() {
    return w.Tendermint37Client;
  } });
  var N = Fn;
  Object.defineProperty(e, "connectComet", { enumerable: !0, get: function() {
    return N.connectComet;
  } }), Object.defineProperty(e, "isComet38Client", { enumerable: !0, get: function() {
    return N.isComet38Client;
  } }), Object.defineProperty(e, "isTendermint34Client", { enumerable: !0, get: function() {
    return N.isTendermint34Client;
  } }), Object.defineProperty(e, "isTendermint37Client", { enumerable: !0, get: function() {
    return N.isTendermint37Client;
  } });
  var h = ci;
  Object.defineProperty(e, "BlockIdFlag", { enumerable: !0, get: function() {
    return h.BlockIdFlag;
  } });
})(bd);
var Je = {};
Object.defineProperty(Je, "__esModule", { value: !0 });
Je.StargateClient = Je.BroadcastTxError = Je.assertIsDeliverTxFailure = Je.assertIsDeliverTxSuccess = Je.isDeliverTxSuccess = Je.isDeliverTxFailure = Je.TimeoutError = void 0;
const SO = Xi, Ns = Ct, ec = mt, nc = bd, tc = an, kO = Od, PO = Zr, vO = Xr, Ti = Qr, RO = Ge, BO = ni;
class hp extends Error {
  constructor(n, r) {
    super(n), this.txId = r;
  }
}
Je.TimeoutError = hp;
function Xd(e) {
  return !!e.code;
}
Je.isDeliverTxFailure = Xd;
function yp(e) {
  return !Xd(e);
}
Je.isDeliverTxSuccess = yp;
function OO(e) {
  if (Xd(e))
    throw new Error(`Error when broadcasting tx ${e.transactionHash} at height ${e.height}. Code: ${e.code}; Raw log: ${e.rawLog}`);
}
Je.assertIsDeliverTxSuccess = OO;
function bO(e) {
  if (yp(e))
    throw new Error(`Transaction ${e.transactionHash} did not fail at height ${e.height}. Code: ${e.code}; Raw log: ${e.rawLog}`);
}
Je.assertIsDeliverTxFailure = bO;
class mp extends Error {
  constructor(n, r, t) {
    super(`Broadcasting transaction failed with code ${n} (codespace: ${r}). Log: ${t}`), this.code = n, this.codespace = r, this.log = t;
  }
}
Je.BroadcastTxError = mp;
class Zi {
  /**
   * Creates an instance by connecting to the given CometBFT RPC endpoint.
   *
   * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
   * To set the Comet client explicitly, use `create`.
   */
  static async connect(n, r = {}) {
    const t = await (0, nc.connectComet)(n);
    return Zi.create(t, r);
  }
  /**
   * Creates an instance from a manually created Comet client.
   * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
   */
  static async create(n, r = {}) {
    return new Zi(n, r);
  }
  constructor(n, r) {
    n && (this.cometClient = n, this.queryClient = RO.QueryClient.withExtensions(n, Ti.setupAuthExtension, Ti.setupBankExtension, Ti.setupStakingExtension, Ti.setupTxExtension));
    const { accountParser: t = PO.accountFromAny } = r;
    this.accountParser = t;
  }
  getCometClient() {
    return this.cometClient;
  }
  forceGetCometClient() {
    if (!this.cometClient)
      throw new Error("Comet client not available. You cannot use online functionality in offline mode.");
    return this.cometClient;
  }
  getQueryClient() {
    return this.queryClient;
  }
  forceGetQueryClient() {
    if (!this.queryClient)
      throw new Error("Query client not available. You cannot use online functionality in offline mode.");
    return this.queryClient;
  }
  async getChainId() {
    if (!this.chainId) {
      const r = (await this.forceGetCometClient().status()).nodeInfo.network;
      if (!r)
        throw new Error("Chain ID must not be empty");
      this.chainId = r;
    }
    return this.chainId;
  }
  async getHeight() {
    return (await this.forceGetCometClient().status()).syncInfo.latestBlockHeight;
  }
  async getAccount(n) {
    try {
      const r = await this.forceGetQueryClient().auth.account(n);
      return r ? this.accountParser(r) : null;
    } catch (r) {
      if (/rpc error: code = NotFound/i.test(r.toString()))
        return null;
      throw r;
    }
  }
  async getSequence(n) {
    const r = await this.getAccount(n);
    if (!r)
      throw new Error(`Account '${n}' does not exist on chain. Send some tokens there before trying to query sequence.`);
    return {
      accountNumber: r.accountNumber,
      sequence: r.sequence
    };
  }
  async getBlock(n) {
    const r = await this.forceGetCometClient().block(n);
    return {
      id: (0, Ns.toHex)(r.blockId.hash).toUpperCase(),
      header: {
        version: {
          block: new ec.Uint53(r.block.header.version.block).toString(),
          app: new ec.Uint53(r.block.header.version.app).toString()
        },
        height: r.block.header.height,
        chainId: r.block.header.chainId,
        time: (0, nc.toRfc3339WithNanoseconds)(r.block.header.time)
      },
      txs: r.block.txs
    };
  }
  async getBalance(n, r) {
    return this.forceGetQueryClient().bank.balance(n, r);
  }
  /**
   * Queries all balances for all denoms that belong to this address.
   *
   * Uses the grpc queries (which iterates over the store internally), and we cannot get
   * proofs from such a method.
   */
  async getAllBalances(n) {
    return this.forceGetQueryClient().bank.allBalances(n);
  }
  async getBalanceStaked(n) {
    const r = [];
    let t;
    do {
      const { delegationResponses: f, pagination: k } = await this.forceGetQueryClient().staking.delegatorDelegations(n, t), C = f || [];
      r.push(...C), t = k == null ? void 0 : k.nextKey;
    } while (t !== void 0 && t.length !== 0);
    return r.reduce((f, k) => ((0, tc.assert)(k.balance), f !== null ? (0, SO.addCoins)(f, k.balance) : k.balance), null);
  }
  async getDelegation(n, r) {
    var i;
    let t;
    try {
      t = (i = (await this.forceGetQueryClient().staking.delegation(n, r)).delegationResponse) == null ? void 0 : i.balance;
    } catch (f) {
      if (!f.toString().includes("key not found"))
        throw f;
    }
    return t || null;
  }
  async getTx(n) {
    return (await this.txsQuery(`tx.hash='${n}'`))[0] ?? null;
  }
  async searchTx(n) {
    let r;
    if (typeof n == "string")
      r = n;
    else if ((0, BO.isSearchTxQueryArray)(n))
      r = n.map((t) => typeof t.value == "string" ? `${t.key}='${t.value}'` : `${t.key}=${t.value}`).join(" AND ");
    else
      throw new Error("Got unsupported query type. See CosmJS 0.31 CHANGELOG for API breaking changes here.");
    return this.txsQuery(r);
  }
  disconnect() {
    this.cometClient && this.cometClient.disconnect();
  }
  /**
   * Broadcasts a signed transaction to the network and monitors its inclusion in a block.
   *
   * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
   * an error is thrown.
   *
   * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.
   *
   * If the transaction is included in a block, a `DeliverTxResponse` is returned. The caller then
   * usually needs to check for execution success or failure.
   */
  async broadcastTx(n, r = 6e4, t = 3e3) {
    let i = !1;
    const f = setTimeout(() => {
      i = !0;
    }, r), k = async (T) => {
      if (i)
        throw new hp(`Transaction with ID ${T} was submitted but was not yet found on the chain. You might want to check later. There was a wait of ${r / 1e3} seconds.`, T);
      await (0, tc.sleep)(t);
      const U = await this.getTx(T);
      return U ? {
        code: U.code,
        height: U.height,
        txIndex: U.txIndex,
        events: U.events,
        rawLog: U.rawLog,
        transactionHash: T,
        msgResponses: U.msgResponses,
        gasUsed: U.gasUsed,
        gasWanted: U.gasWanted
      } : k(T);
    }, C = await this.broadcastTxSync(n);
    return new Promise((T, U) => k(C).then((w) => {
      clearTimeout(f), T(w);
    }, (w) => {
      clearTimeout(f), U(w);
    }));
  }
  /**
   * Broadcasts a signed transaction to the network without monitoring it.
   *
   * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
   * an error is thrown.
   *
   * If the transaction is broadcasted, a `string` containing the hash of the transaction is returned. The caller then
   * usually needs to check if the transaction was included in a block and was successful.
   *
   * @returns Returns the hash of the transaction
   */
  async broadcastTxSync(n) {
    const r = await this.forceGetCometClient().broadcastTxSync({ tx: n });
    return r.code ? Promise.reject(new mp(r.code, r.codespace ?? "", r.log)) : (0, Ns.toHex)(r.hash).toUpperCase();
  }
  async txsQuery(n) {
    return (await this.forceGetCometClient().txSearchAll({ query: n })).txs.map((t) => {
      const i = kO.TxMsgData.decode(t.result.data ?? new Uint8Array());
      return {
        height: t.height,
        txIndex: t.index,
        hash: (0, Ns.toHex)(t.hash).toUpperCase(),
        code: t.result.code,
        events: t.result.events.map(vO.fromTendermintEvent),
        rawLog: t.result.log || "",
        tx: t.tx,
        msgResponses: i.msgResponses,
        gasUsed: t.result.gasUsed,
        gasWanted: t.result.gasWanted
      };
    });
  }
}
Je.StargateClient = Zi;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.SigningStargateClient = e.createDefaultAminoConverters = e.defaultRegistryTypes = void 0;
  const n = Xi, r = Ct, t = mt, i = Nt, f = bd, k = an, C = Le, T = md, U = vd, w = ed, N = xr, h = bo, P = Yr, b = Ot, c = Qr, l = Qr, y = Je;
  e.defaultRegistryTypes = [
    ["/cosmos.base.v1beta1.Coin", C.Coin],
    ...c.authzTypes,
    ...c.bankTypes,
    ...c.distributionTypes,
    ...c.feegrantTypes,
    ...c.govTypes,
    ...c.groupTypes,
    ...c.stakingTypes,
    ...c.ibcTypes,
    ...c.vestingTypes
  ];
  function E() {
    return {
      ...(0, l.createAuthzAminoConverters)(),
      ...(0, l.createBankAminoConverters)(),
      ...(0, l.createDistributionAminoConverters)(),
      ...(0, l.createGovAminoConverters)(),
      ...(0, l.createStakingAminoConverters)(),
      ...(0, l.createIbcAminoConverters)(),
      ...(0, l.createFeegrantAminoConverters)(),
      ...(0, l.createVestingAminoConverters)()
    };
  }
  e.createDefaultAminoConverters = E;
  class J extends y.StargateClient {
    /**
     * Creates an instance by connecting to the given CometBFT RPC endpoint.
     *
     * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
     * To set the Comet client explicitly, use `createWithSigner`.
     */
    static async connectWithSigner(V, o, p = {}) {
      const I = await (0, f.connectComet)(V);
      return J.createWithSigner(I, o, p);
    }
    /**
     * Creates an instance from a manually created Comet client.
     * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
     */
    static async createWithSigner(V, o, p = {}) {
      return new J(V, o, p);
    }
    /**
     * Creates a client in offline mode.
     *
     * This should only be used in niche cases where you know exactly what you're doing,
     * e.g. when building an offline signing application.
     *
     * When you try to use online functionality with such a signer, an
     * exception will be raised.
     */
    static async offline(V, o = {}) {
      return new J(void 0, V, o);
    }
    constructor(V, o, p) {
      super(V, p);
      const { registry: I = new i.Registry(e.defaultRegistryTypes), aminoTypes: q = new P.AminoTypes(E()) } = p;
      this.registry = I, this.aminoTypes = q, this.signer = o, this.broadcastTimeoutMs = p.broadcastTimeoutMs, this.broadcastPollIntervalMs = p.broadcastPollIntervalMs, this.gasPrice = p.gasPrice;
    }
    async simulate(V, o, p) {
      const I = o.map((R) => this.registry.encodeAsAny(R)), q = (await this.signer.getAccounts()).find((R) => R.address === V);
      if (!q)
        throw new Error("Failed to retrieve account from signer");
      const s = (0, n.encodeSecp256k1Pubkey)(q.pubkey), { sequence: u } = await this.getSequence(V), { gasInfo: A } = await this.forceGetQueryClient().tx.simulate(I, p, s, u);
      return (0, k.assertDefined)(A), t.Uint53.fromString(A.gasUsed.toString()).toNumber();
    }
    async sendTokens(V, o, p, I, q = "") {
      const s = {
        typeUrl: "/cosmos.bank.v1beta1.MsgSend",
        value: {
          fromAddress: V,
          toAddress: o,
          amount: [...p]
        }
      };
      return this.signAndBroadcast(V, [s], I, q);
    }
    async delegateTokens(V, o, p, I, q = "") {
      const s = {
        typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
        value: U.MsgDelegate.fromPartial({
          delegatorAddress: V,
          validatorAddress: o,
          amount: p
        })
      };
      return this.signAndBroadcast(V, [s], I, q);
    }
    async undelegateTokens(V, o, p, I, q = "") {
      const s = {
        typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
        value: U.MsgUndelegate.fromPartial({
          delegatorAddress: V,
          validatorAddress: o,
          amount: p
        })
      };
      return this.signAndBroadcast(V, [s], I, q);
    }
    async withdrawRewards(V, o, p, I = "") {
      const q = {
        typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
        value: T.MsgWithdrawDelegatorReward.fromPartial({
          delegatorAddress: V,
          validatorAddress: o
        })
      };
      return this.signAndBroadcast(V, [q], p, I);
    }
    /**
     * @deprecated This API does not support setting the memo field of `MsgTransfer` (only the transaction memo).
     * We'll remove this method at some point because trying to wrap the various message types is a losing strategy.
     * Please migrate to `signAndBroadcast` with an `MsgTransferEncodeObject` created in the caller code instead.
     * @see https://github.com/cosmos/cosmjs/issues/1493
     */
    async sendIbcTokens(V, o, p, I, q, s, u, A, R = "") {
      const v = u ? BigInt(u) * BigInt(1e9) : void 0, D = {
        typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
        value: h.MsgTransfer.fromPartial({
          sourcePort: I,
          sourceChannel: q,
          sender: V,
          receiver: o,
          token: p,
          timeoutHeight: s,
          timeoutTimestamp: v
        })
      };
      return this.signAndBroadcast(V, [D], A, R);
    }
    async signAndBroadcast(V, o, p, I = "", q) {
      let s;
      if (p == "auto" || typeof p == "number") {
        (0, k.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
        const R = await this.simulate(V, o, I), v = typeof p == "number" ? p : 1.4;
        s = (0, b.calculateFee)(Math.round(R * v), this.gasPrice);
      } else
        s = p;
      const u = await this.sign(V, o, s, I, void 0, q), A = N.TxRaw.encode(u).finish();
      return this.broadcastTx(A, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);
    }
    /**
     * This method is useful if you want to send a transaction in broadcast,
     * without waiting for it to be placed inside a block, because for example
     * I would like to receive the hash to later track the transaction with another tool.
     * @returns Returns the hash of the transaction
     */
    async signAndBroadcastSync(V, o, p, I = "", q) {
      let s;
      if (p == "auto" || typeof p == "number") {
        (0, k.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
        const R = await this.simulate(V, o, I), v = typeof p == "number" ? p : 1.3;
        s = (0, b.calculateFee)(Math.round(R * v), this.gasPrice);
      } else
        s = p;
      const u = await this.sign(V, o, s, I, void 0, q), A = N.TxRaw.encode(u).finish();
      return this.broadcastTxSync(A);
    }
    /**
     * Gets account number and sequence from the API, creates a sign doc,
     * creates a single signature and assembles the signed transaction.
     *
     * The sign mode (SIGN_MODE_DIRECT or SIGN_MODE_LEGACY_AMINO_JSON) is determined by this client's signer.
     *
     * You can pass signer data (account number, sequence and chain ID) explicitly instead of querying them
     * from the chain. This is needed when signing for a multisig account, but it also allows for offline signing
     * (See the SigningStargateClient.offline constructor).
     */
    async sign(V, o, p, I, q, s) {
      let u;
      if (q)
        u = q;
      else {
        const { accountNumber: A, sequence: R } = await this.getSequence(V), v = await this.getChainId();
        u = {
          accountNumber: A,
          sequence: R,
          chainId: v
        };
      }
      return (0, i.isOfflineDirectSigner)(this.signer) ? this.signDirect(V, o, p, I, u, s) : this.signAmino(V, o, p, I, u, s);
    }
    async signAmino(V, o, p, I, { accountNumber: q, sequence: s, chainId: u }, A) {
      (0, k.assert)(!(0, i.isOfflineDirectSigner)(this.signer));
      const R = (await this.signer.getAccounts()).find((ne) => ne.address === V);
      if (!R)
        throw new Error("Failed to retrieve account from signer");
      const v = (0, i.encodePubkey)((0, n.encodeSecp256k1Pubkey)(R.pubkey)), D = w.SignMode.SIGN_MODE_LEGACY_AMINO_JSON, W = o.map((ne) => this.aminoTypes.toAmino(ne)), H = (0, n.makeSignDoc)(W, p, u, I, q, s, A), { signature: a, signed: g } = await this.signer.signAmino(V, H), S = {
        typeUrl: "/cosmos.tx.v1beta1.TxBody",
        value: {
          messages: g.msgs.map((ne) => this.aminoTypes.fromAmino(ne)),
          memo: g.memo,
          timeoutHeight: A
        }
      }, O = this.registry.encode(S), Q = t.Int53.fromString(g.fee.gas).toNumber(), G = t.Int53.fromString(g.sequence).toNumber(), L = (0, i.makeAuthInfoBytes)([{ pubkey: v, sequence: G }], g.fee.amount, Q, g.fee.granter, g.fee.payer, D);
      return N.TxRaw.fromPartial({
        bodyBytes: O,
        authInfoBytes: L,
        signatures: [(0, r.fromBase64)(a.signature)]
      });
    }
    async signDirect(V, o, p, I, { accountNumber: q, sequence: s, chainId: u }, A) {
      (0, k.assert)((0, i.isOfflineDirectSigner)(this.signer));
      const R = (await this.signer.getAccounts()).find((O) => O.address === V);
      if (!R)
        throw new Error("Failed to retrieve account from signer");
      const v = (0, i.encodePubkey)((0, n.encodeSecp256k1Pubkey)(R.pubkey)), D = {
        typeUrl: "/cosmos.tx.v1beta1.TxBody",
        value: {
          messages: o,
          memo: I,
          timeoutHeight: A
        }
      }, W = this.registry.encode(D), H = t.Int53.fromString(p.gas).toNumber(), a = (0, i.makeAuthInfoBytes)([{ pubkey: v, sequence: s }], p.amount, H, p.granter, p.payer), g = (0, i.makeSignDoc)(W, a, u, q), { signature: m, signed: S } = await this.signer.signDirect(V, g);
      return N.TxRaw.fromPartial({
        bodyBytes: S.bodyBytes,
        authInfoBytes: S.authInfoBytes,
        signatures: [(0, r.fromBase64)(m.signature)]
      });
    }
  }
  e.SigningStargateClient = J;
})(Tl);
(function(e) {
  var n = j && j.__createBinding || (Object.create ? function(c, l, y, E) {
    E === void 0 && (E = y);
    var J = Object.getOwnPropertyDescriptor(l, y);
    (!J || ("get" in J ? !l.__esModule : J.writable || J.configurable)) && (J = { enumerable: !0, get: function() {
      return l[y];
    } }), Object.defineProperty(c, E, J);
  } : function(c, l, y, E) {
    E === void 0 && (E = y), c[E] = l[y];
  }), r = j && j.__setModuleDefault || (Object.create ? function(c, l) {
    Object.defineProperty(c, "default", { enumerable: !0, value: l });
  } : function(c, l) {
    c.default = l;
  }), t = j && j.__importStar || function(c) {
    if (c && c.__esModule)
      return c;
    var l = {};
    if (c != null)
      for (var y in c)
        y !== "default" && Object.prototype.hasOwnProperty.call(c, y) && n(l, c, y);
    return r(l, c), l;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isMsgWithdrawDelegatorRewardEncodeObject = e.isMsgVoteWeightedEncodeObject = e.isMsgVoteEncodeObject = e.isMsgUndelegateEncodeObject = e.isMsgTransferEncodeObject = e.isMsgSubmitProposalEncodeObject = e.isMsgSendEncodeObject = e.isMsgEditValidatorEncodeObject = e.isMsgDepositEncodeObject = e.isMsgDelegateEncodeObject = e.isMsgCreateValidatorEncodeObject = e.isMsgBeginRedelegateEncodeObject = e.isAminoMsgWithdrawValidatorCommission = e.isAminoMsgWithdrawDelegatorReward = e.isAminoMsgVoteWeighted = e.isAminoMsgVote = e.isAminoMsgVerifyInvariant = e.isAminoMsgUnjail = e.isAminoMsgUndelegate = e.isAminoMsgTransfer = e.isAminoMsgSubmitProposal = e.isAminoMsgSubmitEvidence = e.isAminoMsgSetWithdrawAddress = e.isAminoMsgSend = e.isAminoMsgMultiSend = e.isAminoMsgFundCommunityPool = e.isAminoMsgEditValidator = e.isAminoMsgDeposit = e.isAminoMsgDelegate = e.isAminoMsgCreateVestingAccount = e.isAminoMsgCreateValidator = e.isAminoMsgBeginRedelegate = e.createVestingAminoConverters = e.createStakingAminoConverters = e.createSlashingAminoConverters = e.createIbcAminoConverters = e.createGroupAminoConverters = e.createGovAminoConverters = e.createFeegrantAminoConverters = e.createEvidenceAminoConverters = e.createDistributionAminoConverters = e.createCrysisAminoConverters = e.createBankAminoConverters = e.createAuthzAminoConverters = e.logs = e.GasPrice = e.calculateFee = e.fromTendermintEvent = e.AminoTypes = e.accountFromAny = void 0, e.parseCoins = e.makeCosmoshubPath = e.coins = e.coin = e.TimeoutError = e.StargateClient = e.isDeliverTxSuccess = e.isDeliverTxFailure = e.BroadcastTxError = e.assertIsDeliverTxSuccess = e.assertIsDeliverTxFailure = e.SigningStargateClient = e.defaultRegistryTypes = e.createDefaultAminoConverters = e.isSearchTxQueryArray = e.QueryClient = e.decodeCosmosSdkDecFromProto = e.createProtobufRpcClient = e.createPagination = e.makeMultisignedTxBytes = e.makeMultisignedTx = e.setupTxExtension = e.setupStakingExtension = e.setupSlashingExtension = e.setupMintExtension = e.setupIbcExtension = e.setupGovExtension = e.setupFeegrantExtension = e.setupDistributionExtension = e.setupBankExtension = e.setupAuthzExtension = e.setupAuthExtension = void 0;
  var i = Zr;
  Object.defineProperty(e, "accountFromAny", { enumerable: !0, get: function() {
    return i.accountFromAny;
  } });
  var f = Yr;
  Object.defineProperty(e, "AminoTypes", { enumerable: !0, get: function() {
    return f.AminoTypes;
  } });
  var k = Xr;
  Object.defineProperty(e, "fromTendermintEvent", { enumerable: !0, get: function() {
    return k.fromTendermintEvent;
  } });
  var C = Ot;
  Object.defineProperty(e, "calculateFee", { enumerable: !0, get: function() {
    return C.calculateFee;
  } }), Object.defineProperty(e, "GasPrice", { enumerable: !0, get: function() {
    return C.GasPrice;
  } }), e.logs = t(Xe);
  var T = Qr;
  Object.defineProperty(e, "createAuthzAminoConverters", { enumerable: !0, get: function() {
    return T.createAuthzAminoConverters;
  } }), Object.defineProperty(e, "createBankAminoConverters", { enumerable: !0, get: function() {
    return T.createBankAminoConverters;
  } }), Object.defineProperty(e, "createCrysisAminoConverters", { enumerable: !0, get: function() {
    return T.createCrysisAminoConverters;
  } }), Object.defineProperty(e, "createDistributionAminoConverters", { enumerable: !0, get: function() {
    return T.createDistributionAminoConverters;
  } }), Object.defineProperty(e, "createEvidenceAminoConverters", { enumerable: !0, get: function() {
    return T.createEvidenceAminoConverters;
  } }), Object.defineProperty(e, "createFeegrantAminoConverters", { enumerable: !0, get: function() {
    return T.createFeegrantAminoConverters;
  } }), Object.defineProperty(e, "createGovAminoConverters", { enumerable: !0, get: function() {
    return T.createGovAminoConverters;
  } }), Object.defineProperty(e, "createGroupAminoConverters", { enumerable: !0, get: function() {
    return T.createGroupAminoConverters;
  } }), Object.defineProperty(e, "createIbcAminoConverters", { enumerable: !0, get: function() {
    return T.createIbcAminoConverters;
  } }), Object.defineProperty(e, "createSlashingAminoConverters", { enumerable: !0, get: function() {
    return T.createSlashingAminoConverters;
  } }), Object.defineProperty(e, "createStakingAminoConverters", { enumerable: !0, get: function() {
    return T.createStakingAminoConverters;
  } }), Object.defineProperty(e, "createVestingAminoConverters", { enumerable: !0, get: function() {
    return T.createVestingAminoConverters;
  } }), Object.defineProperty(e, "isAminoMsgBeginRedelegate", { enumerable: !0, get: function() {
    return T.isAminoMsgBeginRedelegate;
  } }), Object.defineProperty(e, "isAminoMsgCreateValidator", { enumerable: !0, get: function() {
    return T.isAminoMsgCreateValidator;
  } }), Object.defineProperty(e, "isAminoMsgCreateVestingAccount", { enumerable: !0, get: function() {
    return T.isAminoMsgCreateVestingAccount;
  } }), Object.defineProperty(e, "isAminoMsgDelegate", { enumerable: !0, get: function() {
    return T.isAminoMsgDelegate;
  } }), Object.defineProperty(e, "isAminoMsgDeposit", { enumerable: !0, get: function() {
    return T.isAminoMsgDeposit;
  } }), Object.defineProperty(e, "isAminoMsgEditValidator", { enumerable: !0, get: function() {
    return T.isAminoMsgEditValidator;
  } }), Object.defineProperty(e, "isAminoMsgFundCommunityPool", { enumerable: !0, get: function() {
    return T.isAminoMsgFundCommunityPool;
  } }), Object.defineProperty(e, "isAminoMsgMultiSend", { enumerable: !0, get: function() {
    return T.isAminoMsgMultiSend;
  } }), Object.defineProperty(e, "isAminoMsgSend", { enumerable: !0, get: function() {
    return T.isAminoMsgSend;
  } }), Object.defineProperty(e, "isAminoMsgSetWithdrawAddress", { enumerable: !0, get: function() {
    return T.isAminoMsgSetWithdrawAddress;
  } }), Object.defineProperty(e, "isAminoMsgSubmitEvidence", { enumerable: !0, get: function() {
    return T.isAminoMsgSubmitEvidence;
  } }), Object.defineProperty(e, "isAminoMsgSubmitProposal", { enumerable: !0, get: function() {
    return T.isAminoMsgSubmitProposal;
  } }), Object.defineProperty(e, "isAminoMsgTransfer", { enumerable: !0, get: function() {
    return T.isAminoMsgTransfer;
  } }), Object.defineProperty(e, "isAminoMsgUndelegate", { enumerable: !0, get: function() {
    return T.isAminoMsgUndelegate;
  } }), Object.defineProperty(e, "isAminoMsgUnjail", { enumerable: !0, get: function() {
    return T.isAminoMsgUnjail;
  } }), Object.defineProperty(e, "isAminoMsgVerifyInvariant", { enumerable: !0, get: function() {
    return T.isAminoMsgVerifyInvariant;
  } }), Object.defineProperty(e, "isAminoMsgVote", { enumerable: !0, get: function() {
    return T.isAminoMsgVote;
  } }), Object.defineProperty(e, "isAminoMsgVoteWeighted", { enumerable: !0, get: function() {
    return T.isAminoMsgVoteWeighted;
  } }), Object.defineProperty(e, "isAminoMsgWithdrawDelegatorReward", { enumerable: !0, get: function() {
    return T.isAminoMsgWithdrawDelegatorReward;
  } }), Object.defineProperty(e, "isAminoMsgWithdrawValidatorCommission", { enumerable: !0, get: function() {
    return T.isAminoMsgWithdrawValidatorCommission;
  } }), Object.defineProperty(e, "isMsgBeginRedelegateEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgBeginRedelegateEncodeObject;
  } }), Object.defineProperty(e, "isMsgCreateValidatorEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgCreateValidatorEncodeObject;
  } }), Object.defineProperty(e, "isMsgDelegateEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgDelegateEncodeObject;
  } }), Object.defineProperty(e, "isMsgDepositEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgDepositEncodeObject;
  } }), Object.defineProperty(e, "isMsgEditValidatorEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgEditValidatorEncodeObject;
  } }), Object.defineProperty(e, "isMsgSendEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgSendEncodeObject;
  } }), Object.defineProperty(e, "isMsgSubmitProposalEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgSubmitProposalEncodeObject;
  } }), Object.defineProperty(e, "isMsgTransferEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgTransferEncodeObject;
  } }), Object.defineProperty(e, "isMsgUndelegateEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgUndelegateEncodeObject;
  } }), Object.defineProperty(e, "isMsgVoteEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgVoteEncodeObject;
  } }), Object.defineProperty(e, "isMsgVoteWeightedEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgVoteWeightedEncodeObject;
  } }), Object.defineProperty(e, "isMsgWithdrawDelegatorRewardEncodeObject", { enumerable: !0, get: function() {
    return T.isMsgWithdrawDelegatorRewardEncodeObject;
  } }), Object.defineProperty(e, "setupAuthExtension", { enumerable: !0, get: function() {
    return T.setupAuthExtension;
  } }), Object.defineProperty(e, "setupAuthzExtension", { enumerable: !0, get: function() {
    return T.setupAuthzExtension;
  } }), Object.defineProperty(e, "setupBankExtension", { enumerable: !0, get: function() {
    return T.setupBankExtension;
  } }), Object.defineProperty(e, "setupDistributionExtension", { enumerable: !0, get: function() {
    return T.setupDistributionExtension;
  } }), Object.defineProperty(e, "setupFeegrantExtension", { enumerable: !0, get: function() {
    return T.setupFeegrantExtension;
  } }), Object.defineProperty(e, "setupGovExtension", { enumerable: !0, get: function() {
    return T.setupGovExtension;
  } }), Object.defineProperty(e, "setupIbcExtension", { enumerable: !0, get: function() {
    return T.setupIbcExtension;
  } }), Object.defineProperty(e, "setupMintExtension", { enumerable: !0, get: function() {
    return T.setupMintExtension;
  } }), Object.defineProperty(e, "setupSlashingExtension", { enumerable: !0, get: function() {
    return T.setupSlashingExtension;
  } }), Object.defineProperty(e, "setupStakingExtension", { enumerable: !0, get: function() {
    return T.setupStakingExtension;
  } }), Object.defineProperty(e, "setupTxExtension", { enumerable: !0, get: function() {
    return T.setupTxExtension;
  } });
  var U = ft;
  Object.defineProperty(e, "makeMultisignedTx", { enumerable: !0, get: function() {
    return U.makeMultisignedTx;
  } }), Object.defineProperty(e, "makeMultisignedTxBytes", { enumerable: !0, get: function() {
    return U.makeMultisignedTxBytes;
  } });
  var w = Ge;
  Object.defineProperty(e, "createPagination", { enumerable: !0, get: function() {
    return w.createPagination;
  } }), Object.defineProperty(e, "createProtobufRpcClient", { enumerable: !0, get: function() {
    return w.createProtobufRpcClient;
  } }), Object.defineProperty(e, "decodeCosmosSdkDecFromProto", { enumerable: !0, get: function() {
    return w.decodeCosmosSdkDecFromProto;
  } }), Object.defineProperty(e, "QueryClient", { enumerable: !0, get: function() {
    return w.QueryClient;
  } });
  var N = ni;
  Object.defineProperty(e, "isSearchTxQueryArray", { enumerable: !0, get: function() {
    return N.isSearchTxQueryArray;
  } });
  var h = Tl;
  Object.defineProperty(e, "createDefaultAminoConverters", { enumerable: !0, get: function() {
    return h.createDefaultAminoConverters;
  } }), Object.defineProperty(e, "defaultRegistryTypes", { enumerable: !0, get: function() {
    return h.defaultRegistryTypes;
  } }), Object.defineProperty(e, "SigningStargateClient", { enumerable: !0, get: function() {
    return h.SigningStargateClient;
  } });
  var P = Je;
  Object.defineProperty(e, "assertIsDeliverTxFailure", { enumerable: !0, get: function() {
    return P.assertIsDeliverTxFailure;
  } }), Object.defineProperty(e, "assertIsDeliverTxSuccess", { enumerable: !0, get: function() {
    return P.assertIsDeliverTxSuccess;
  } }), Object.defineProperty(e, "BroadcastTxError", { enumerable: !0, get: function() {
    return P.BroadcastTxError;
  } }), Object.defineProperty(e, "isDeliverTxFailure", { enumerable: !0, get: function() {
    return P.isDeliverTxFailure;
  } }), Object.defineProperty(e, "isDeliverTxSuccess", { enumerable: !0, get: function() {
    return P.isDeliverTxSuccess;
  } }), Object.defineProperty(e, "StargateClient", { enumerable: !0, get: function() {
    return P.StargateClient;
  } }), Object.defineProperty(e, "TimeoutError", { enumerable: !0, get: function() {
    return P.TimeoutError;
  } });
  var b = Nt;
  Object.defineProperty(e, "coin", { enumerable: !0, get: function() {
    return b.coin;
  } }), Object.defineProperty(e, "coins", { enumerable: !0, get: function() {
    return b.coins;
  } }), Object.defineProperty(e, "makeCosmoshubPath", { enumerable: !0, get: function() {
    return b.makeCosmoshubPath;
  } }), Object.defineProperty(e, "parseCoins", { enumerable: !0, get: function() {
    return b.parseCoins;
  } });
})(dc);
const EO = /* @__PURE__ */ Up({
  __proto__: null
}, [dc]);
export {
  EO as i
};
