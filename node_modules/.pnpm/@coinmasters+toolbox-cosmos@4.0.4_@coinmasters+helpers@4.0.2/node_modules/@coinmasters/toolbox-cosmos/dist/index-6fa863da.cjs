"use strict";const b=require("./index-44c7a055.cjs"),P=require("./index-dbb7e3c1.cjs");function fe(e,t){for(var n=0;n<t.length;n++){const r=t[n];if(typeof r!="string"&&!Array.isArray(r)){for(const o in r)if(o!=="default"&&!(o in e)){const i=Object.getOwnPropertyDescriptor(r,o);i&&Object.defineProperty(e,o,i.get?i:{enumerable:!0,get:()=>r[o]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}var V={},l={},a={},B={};(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.isMultisigThresholdPubkey=e.isSinglePubkey=e.pubkeyType=e.isSecp256k1Pubkey=e.isEd25519Pubkey=void 0;function t(i){return i.type==="tendermint/PubKeyEd25519"}e.isEd25519Pubkey=t;function n(i){return i.type==="tendermint/PubKeySecp256k1"}e.isSecp256k1Pubkey=n,e.pubkeyType={secp256k1:"tendermint/PubKeySecp256k1",ed25519:"tendermint/PubKeyEd25519",sr25519:"tendermint/PubKeySr25519",multisigThreshold:"tendermint/PubKeyMultisigThreshold"};function r(i){return[e.pubkeyType.ed25519,e.pubkeyType.secp256k1,e.pubkeyType.sr25519].includes(i.type)}e.isSinglePubkey=r;function o(i){return i.type==="tendermint/PubKeyMultisigThreshold"}e.isMultisigThresholdPubkey=o})(B);Object.defineProperty(a,"__esModule",{value:!0});a.encodeBech32Pubkey=a.encodeAminoPubkey=a.decodeBech32Pubkey=a.decodeAminoPubkey=a.encodeEd25519Pubkey=a.encodeSecp256k1Pubkey=void 0;const y=P.build,he=b.build$1,C=b.build,m=B;function be(e){if(e.length!==33||e[0]!==2&&e[0]!==3)throw new Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");return{type:m.pubkeyType.secp256k1,value:(0,y.toBase64)(e)}}a.encodeSecp256k1Pubkey=be;function pe(e){if(e.length!==32)throw new Error("Ed25519 public key must be 32 bytes long");return{type:m.pubkeyType.ed25519,value:(0,y.toBase64)(e)}}a.encodeEd25519Pubkey=pe;const I=(0,y.fromHex)("eb5ae98721"),W=(0,y.fromHex)("1624de6420"),Q=(0,y.fromHex)("0dfb100520"),R=(0,y.fromHex)("22c1f7e2");function q(e){if((0,C.arrayContentStartsWith)(e,I)){const t=e.slice(I.length);if(t.length!==33)throw new Error("Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).");return{type:m.pubkeyType.secp256k1,value:(0,y.toBase64)(t)}}else if((0,C.arrayContentStartsWith)(e,W)){const t=e.slice(W.length);if(t.length!==32)throw new Error("Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).");return{type:m.pubkeyType.ed25519,value:(0,y.toBase64)(t)}}else if((0,C.arrayContentStartsWith)(e,Q)){const t=e.slice(Q.length);if(t.length!==32)throw new Error("Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).");return{type:m.pubkeyType.sr25519,value:(0,y.toBase64)(t)}}else{if((0,C.arrayContentStartsWith)(e,R))return ge(e);throw new Error("Unsupported public key type. Amino data starts with: "+(0,y.toHex)(e.slice(0,5)))}}a.decodeAminoPubkey=q;function me(e){const{data:t}=(0,y.fromBech32)(e);return q(t)}a.decodeBech32Pubkey=me;function Y(e){if(e.length<1)throw new Error("Can't decode varint. EOF");if(e[0]>127)throw new Error("Decoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.Varint implementation from the Go standard library and write some tests.");return[e[0],1]}function ge(e){const t=Array.from(e),n=t.splice(0,R.length);if(!(0,C.arrayContentStartsWith)(n,R))throw new Error("Invalid multisig prefix.");if(t.shift()!=8)throw new Error("Invalid multisig data. Expecting 0x08 prefix before threshold.");const[r,o]=Y(t);t.splice(0,o);const i=[];for(;t.length>0;){if(t.shift()!=18)throw new Error("Invalid multisig data. Expecting 0x12 prefix before participant pubkey length.");const[c,u]=Y(t);if(t.splice(0,u),t.length<c)throw new Error("Invalid multisig data length.");const s=t.splice(0,c),d=q(Uint8Array.from(s));i.push(d)}return{type:m.pubkeyType.multisigThreshold,value:{threshold:r.toString(),pubkeys:i}}}function ee(e){const t=he.Uint53.fromString(e.toString()).toNumber();if(t>127)throw new Error("Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.");return[t]}function x(e){if((0,m.isMultisigThresholdPubkey)(e)){const t=Array.from(R);t.push(8),t.push(...ee(e.value.threshold));for(const n of e.value.pubkeys.map(r=>x(r)))t.push(18),t.push(...ee(n.length)),t.push(...n);return new Uint8Array(t)}else{if((0,m.isEd25519Pubkey)(e))return new Uint8Array([...W,...(0,y.fromBase64)(e.value)]);if((0,m.isSecp256k1Pubkey)(e))return new Uint8Array([...I,...(0,y.fromBase64)(e.value)]);throw new Error("Unsupported pubkey type")}}a.encodeAminoPubkey=x;function ke(e,t){return(0,y.toBech32)(t,x(e))}a.encodeBech32Pubkey=ke;Object.defineProperty(l,"__esModule",{value:!0});l.pubkeyToAddress=l.pubkeyToRawAddress=l.rawSecp256k1PubkeyToRawAddress=l.rawEd25519PubkeyToRawAddress=void 0;const U=b.build$2,J=P.build,Pe=a,z=B;function ie(e){if(e.length!==32)throw new Error(`Invalid Ed25519 pubkey length: ${e.length}`);return(0,U.sha256)(e).slice(0,20)}l.rawEd25519PubkeyToRawAddress=ie;function se(e){if(e.length!==33)throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${e.length}`);return(0,U.ripemd160)((0,U.sha256)(e))}l.rawSecp256k1PubkeyToRawAddress=se;function ce(e){if((0,z.isSecp256k1Pubkey)(e)){const t=(0,J.fromBase64)(e.value);return se(t)}else if((0,z.isEd25519Pubkey)(e)){const t=(0,J.fromBase64)(e.value);return ie(t)}else if((0,z.isMultisigThresholdPubkey)(e)){const t=(0,Pe.encodeAminoPubkey)(e);return(0,U.sha256)(t).slice(0,20)}else throw new Error("Unsupported public key type")}l.pubkeyToRawAddress=ce;function we(e,t){return(0,J.toBech32)(t,ce(e))}l.pubkeyToAddress=we;var p={};Object.defineProperty(p,"__esModule",{value:!0});p.addCoins=p.parseCoins=p.coins=p.coin=void 0;const H=b.build$1;function ue(e,t){let n;if(typeof e=="number")try{n=new H.Uint53(e).toString()}catch{throw new Error("Given amount is not a safe integer. Consider using a string instead to overcome the limitations of JS numbers.")}else{if(!e.match(/^[0-9]+$/))throw new Error("Invalid unsigned integer string format");n=e.replace(/^0*/,"")||"0"}return{amount:n,denom:t}}p.coin=ue;function Se(e,t){return[ue(e,t)]}p.coins=Se;function ve(e){return e.replace(/\s/g,"").split(",").filter(Boolean).map(t=>{const n=t.match(/^([0-9]+)([a-zA-Z]+)/);if(!n)throw new Error("Got an invalid coin string");return{amount:n[1].replace(/^0+/,"")||"0",denom:n[2]}})}p.parseCoins=ve;function Ae(e,t){if(e.denom!==t.denom)throw new Error("Trying to add two coins with different denoms");return{amount:H.Decimal.fromAtomics(e.amount,0).plus(H.Decimal.fromAtomics(t.amount,0)).atomics,denom:e.denom}}p.addCoins=Ae;var A={};Object.defineProperty(A,"__esModule",{value:!0});A.createMultisigThresholdPubkey=A.compareArrays=void 0;const te=P.build,Te=b.build$1,ne=l;function ae(e,t){const n=(0,te.toHex)(e),r=(0,te.toHex)(t);return n===r?0:n<r?-1:1}A.compareArrays=ae;function Ee(e,t,n=!1){const r=new Te.Uint53(t);if(r.toNumber()>e.length)throw new Error(`Threshold k = ${r.toNumber()} exceeds number of keys n = ${e.length}`);const o=n?e:Array.from(e).sort((i,c)=>{const u=(0,ne.pubkeyToRawAddress)(i),s=(0,ne.pubkeyToRawAddress)(c);return ae(u,s)});return{type:"tendermint/PubKeyMultisigThreshold",value:{threshold:r.toString(),pubkeys:o}}}A.createMultisigThresholdPubkey=Ee;var D={};Object.defineProperty(D,"__esModule",{value:!0});D.omitDefault=void 0;function _e(e){switch(typeof e){case"string":return e===""?void 0:e;case"number":return e===0?void 0:e;case"bigint":return e===BigInt(0)?void 0:e;case"boolean":return e||void 0;default:throw new Error(`Got unsupported type '${typeof e}'`)}}D.omitDefault=_e;var $={};Object.defineProperty($,"__esModule",{value:!0});$.makeCosmoshubPath=void 0;const _=b.build$2;function Oe(e){return[_.Slip10RawIndex.hardened(44),_.Slip10RawIndex.hardened(118),_.Slip10RawIndex.hardened(0),_.Slip10RawIndex.normal(0),_.Slip10RawIndex.normal(e)]}$.makeCosmoshubPath=Oe;var T={},k={};Object.defineProperty(k,"__esModule",{value:!0});k.decodeSignature=k.encodeSecp256k1Signature=void 0;const L=P.build,je=a,Ce=B;function Be(e,t){if(t.length!==64)throw new Error("Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.");return{pub_key:(0,je.encodeSecp256k1Pubkey)(e),signature:(0,L.toBase64)(t)}}k.encodeSecp256k1Signature=Be;function $e(e){switch(e.pub_key.type){case Ce.pubkeyType.secp256k1:return{pubkey:(0,L.fromBase64)(e.pub_key.value),signature:(0,L.fromBase64)(e.signature)};default:throw new Error("Unsupported pubkey type")}}k.decodeSignature=$e;var h={};Object.defineProperty(h,"__esModule",{value:!0});h.serializeSignDoc=h.escapeCharacters=h.makeSignDoc=h.sortedJsonStringify=void 0;const Me=P.build,re=b.build$1;function G(e){if(typeof e!="object"||e===null)return e;if(Array.isArray(e))return e.map(G);const t=Object.keys(e).sort(),n={};return t.forEach(r=>{n[r]=G(e[r])}),n}function de(e){return JSON.stringify(G(e))}h.sortedJsonStringify=de;function Ke(e,t,n,r,o,i,c){return{chain_id:n,account_number:re.Uint53.fromString(o.toString()).toString(),sequence:re.Uint53.fromString(i.toString()).toString(),fee:t,msgs:e,memo:r||"",...c&&{timeout_height:c.toString()}}}h.makeSignDoc=Ke;function ye(e){const t=/&/g,n=/</g,r=/>/g;return e.replace(t,"\\u0026").replace(n,"\\u003c").replace(r,"\\u003e")}h.escapeCharacters=ye;function Re(e){const t=ye(de(e));return(0,Me.toUtf8)(t)}h.serializeSignDoc=Re;var F={};(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.decrypt=e.encrypt=e.supportedAlgorithms=e.executeKdf=e.cosmjsSalt=void 0;const t=b.build$2,n=P.build;e.cosmjsSalt=(0,n.toAscii)("The CosmJS salt.");async function r(c,u){switch(u.algorithm){case"argon2id":{const s=u.params;if(!(0,t.isArgon2idOptions)(s))throw new Error("Invalid format of argon2id params");return t.Argon2id.execute(c,e.cosmjsSalt,s)}default:throw new Error("Unsupported KDF algorithm")}}e.executeKdf=r,e.supportedAlgorithms={xchacha20poly1305Ietf:"xchacha20poly1305-ietf"};async function o(c,u,s){switch(s.algorithm){case e.supportedAlgorithms.xchacha20poly1305Ietf:{const d=t.Random.getBytes(t.xchacha20NonceLength);return new Uint8Array([...d,...await t.Xchacha20poly1305Ietf.encrypt(c,u,d)])}default:throw new Error(`Unsupported encryption algorithm: '${s.algorithm}'`)}}e.encrypt=o;async function i(c,u,s){switch(s.algorithm){case e.supportedAlgorithms.xchacha20poly1305Ietf:{const d=c.slice(0,t.xchacha20NonceLength);return t.Xchacha20poly1305Ietf.decrypt(c.slice(t.xchacha20NonceLength),u,d)}default:throw new Error(`Unsupported encryption algorithm: '${s.algorithm}'`)}}e.decrypt=i})(F);Object.defineProperty(T,"__esModule",{value:!0});T.Secp256k1HdWallet=T.extractKdfConfiguration=void 0;const f=b.build$2,O=P.build,v=b.build,Ue=l,De=$,Ne=k,ze=h,j=F,K="secp256k1wallet-v1",Ie={algorithm:"argon2id",params:{outputLength:32,opsLimit:24,memLimitKib:12*1024}};function We(e){return!(!(0,v.isNonNullObject)(e)||typeof e.hdPath!="string"||typeof e.prefix!="string")}function Je(e){return e.kdf}function He(e){const t=JSON.parse(e);if(!(0,v.isNonNullObject)(t))throw new Error("Root document is not an object.");switch(t.type){case K:return Je(t);default:throw new Error("Unsupported serialization type")}}T.extractKdfConfiguration=He;const oe={bip39Password:"",hdPaths:[(0,De.makeCosmoshubPath)(0)],prefix:"cosmos"};class w{static async fromMnemonic(t,n={}){const r=new f.EnglishMnemonic(t),o=await f.Bip39.mnemonicToSeed(r,n.bip39Password);return new w(r,{...n,seed:o})}static async generate(t=12,n={}){const r=4*Math.floor(11*t/33),o=f.Random.getBytes(r),i=f.Bip39.encode(o);return w.fromMnemonic(i.toString(),n)}static async deserialize(t,n){const r=JSON.parse(t);if(!(0,v.isNonNullObject)(r))throw new Error("Root document is not an object.");switch(r.type){case K:return w.deserializeTypeV1(t,n);default:throw new Error("Unsupported serialization type")}}static async deserializeWithEncryptionKey(t,n){const r=JSON.parse(t);if(!(0,v.isNonNullObject)(r))throw new Error("Root document is not an object.");const o=r;switch(o.type){case K:{const i=await(0,j.decrypt)((0,O.fromBase64)(o.data),n,o.encryption),c=JSON.parse((0,O.fromUtf8)(i)),{mnemonic:u,accounts:s}=c;if((0,v.assert)(typeof u=="string"),!Array.isArray(s))throw new Error("Property 'accounts' is not an array");if(!s.every(g=>We(g)))throw new Error("Account is not in the correct format.");const d=s[0].prefix;if(!s.every(({prefix:g})=>g===d))throw new Error("Accounts do not all have the same prefix");const S=s.map(({hdPath:g})=>(0,f.stringToPath)(g));return w.fromMnemonic(u,{hdPaths:S,prefix:d})}default:throw new Error("Unsupported serialization type")}}static async deserializeTypeV1(t,n){const r=JSON.parse(t);if(!(0,v.isNonNullObject)(r))throw new Error("Root document is not an object.");const o=await(0,j.executeKdf)(n,r.kdf);return w.deserializeWithEncryptionKey(t,o)}constructor(t,n){const r=n.hdPaths??oe.hdPaths,o=n.prefix??oe.prefix;this.secret=t,this.seed=n.seed,this.accounts=r.map(i=>({hdPath:i,prefix:o}))}get mnemonic(){return this.secret.toString()}async getAccounts(){return(await this.getAccountsWithPrivkeys()).map(({algo:n,pubkey:r,address:o})=>({algo:n,pubkey:r,address:o}))}async signAmino(t,n){const o=(await this.getAccountsWithPrivkeys()).find(({address:S})=>S===t);if(o===void 0)throw new Error(`Address ${t} not found in wallet`);const{privkey:i,pubkey:c}=o,u=(0,f.sha256)((0,ze.serializeSignDoc)(n)),s=await f.Secp256k1.createSignature(u,i),d=new Uint8Array([...s.r(32),...s.s(32)]);return{signed:n,signature:(0,Ne.encodeSecp256k1Signature)(c,d)}}async serialize(t){const n=Ie,r=await(0,j.executeKdf)(t,n);return this.serializeWithEncryptionKey(r,n)}async serializeWithEncryptionKey(t,n){const r={mnemonic:this.mnemonic,accounts:this.accounts.map(({hdPath:s,prefix:d})=>({hdPath:(0,f.pathToString)(s),prefix:d}))},o=(0,O.toUtf8)(JSON.stringify(r)),i={algorithm:j.supportedAlgorithms.xchacha20poly1305Ietf},c=await(0,j.encrypt)(o,t,i),u={type:K,kdf:n,encryption:i,data:(0,O.toBase64)(c)};return JSON.stringify(u)}async getKeyPair(t){const{privkey:n}=f.Slip10.derivePath(f.Slip10Curve.Secp256k1,this.seed,t),{pubkey:r}=await f.Secp256k1.makeKeypair(n);return{privkey:n,pubkey:f.Secp256k1.compressPubkey(r)}}async getAccountsWithPrivkeys(){return Promise.all(this.accounts.map(async({hdPath:t,prefix:n})=>{const{privkey:r,pubkey:o}=await this.getKeyPair(t),i=(0,O.toBech32)(n,(0,Ue.rawSecp256k1PubkeyToRawAddress)(o));return{algo:"secp256k1",privkey:r,pubkey:o,address:i}}))}}T.Secp256k1HdWallet=w;var N={};Object.defineProperty(N,"__esModule",{value:!0});N.Secp256k1Wallet=void 0;const M=b.build$2,Le=P.build,Ge=l,Ve=k,qe=h;class X{static async fromKey(t,n="cosmos"){const r=(await M.Secp256k1.makeKeypair(t)).pubkey;return new X(t,M.Secp256k1.compressPubkey(r),n)}constructor(t,n,r){this.privkey=t,this.pubkey=n,this.prefix=r}get address(){return(0,Le.toBech32)(this.prefix,(0,Ge.rawSecp256k1PubkeyToRawAddress)(this.pubkey))}async getAccounts(){return[{algo:"secp256k1",address:this.address,pubkey:this.pubkey}]}async signAmino(t,n){if(t!==this.address)throw new Error(`Address ${t} not found in wallet`);const r=new M.Sha256((0,qe.serializeSignDoc)(n)).digest(),o=await M.Secp256k1.createSignature(r,this.privkey),i=new Uint8Array([...o.r(32),...o.s(32)]);return{signed:n,signature:(0,Ve.encodeSecp256k1Signature)(this.pubkey,i)}}}N.Secp256k1Wallet=X;var E={};Object.defineProperty(E,"__esModule",{value:!0});E.makeStdTx=E.isStdTx=void 0;function xe(e){const{memo:t,msg:n,fee:r,signatures:o}=e;return typeof t=="string"&&Array.isArray(n)&&typeof r=="object"&&Array.isArray(o)}E.isStdTx=xe;function Fe(e,t){return{msg:e.msgs,fee:e.fee,memo:e.memo,signatures:Array.isArray(t)?t:[t]}}E.makeStdTx=Fe;(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.executeKdf=e.makeStdTx=e.isStdTx=e.serializeSignDoc=e.makeSignDoc=e.encodeSecp256k1Signature=e.decodeSignature=e.Secp256k1Wallet=e.Secp256k1HdWallet=e.extractKdfConfiguration=e.pubkeyType=e.isSinglePubkey=e.isSecp256k1Pubkey=e.isMultisigThresholdPubkey=e.isEd25519Pubkey=e.makeCosmoshubPath=e.omitDefault=e.createMultisigThresholdPubkey=e.encodeSecp256k1Pubkey=e.encodeEd25519Pubkey=e.encodeBech32Pubkey=e.encodeAminoPubkey=e.decodeBech32Pubkey=e.decodeAminoPubkey=e.parseCoins=e.coins=e.coin=e.addCoins=e.rawSecp256k1PubkeyToRawAddress=e.rawEd25519PubkeyToRawAddress=e.pubkeyToRawAddress=e.pubkeyToAddress=void 0;var t=l;Object.defineProperty(e,"pubkeyToAddress",{enumerable:!0,get:function(){return t.pubkeyToAddress}}),Object.defineProperty(e,"pubkeyToRawAddress",{enumerable:!0,get:function(){return t.pubkeyToRawAddress}}),Object.defineProperty(e,"rawEd25519PubkeyToRawAddress",{enumerable:!0,get:function(){return t.rawEd25519PubkeyToRawAddress}}),Object.defineProperty(e,"rawSecp256k1PubkeyToRawAddress",{enumerable:!0,get:function(){return t.rawSecp256k1PubkeyToRawAddress}});var n=p;Object.defineProperty(e,"addCoins",{enumerable:!0,get:function(){return n.addCoins}}),Object.defineProperty(e,"coin",{enumerable:!0,get:function(){return n.coin}}),Object.defineProperty(e,"coins",{enumerable:!0,get:function(){return n.coins}}),Object.defineProperty(e,"parseCoins",{enumerable:!0,get:function(){return n.parseCoins}});var r=a;Object.defineProperty(e,"decodeAminoPubkey",{enumerable:!0,get:function(){return r.decodeAminoPubkey}}),Object.defineProperty(e,"decodeBech32Pubkey",{enumerable:!0,get:function(){return r.decodeBech32Pubkey}}),Object.defineProperty(e,"encodeAminoPubkey",{enumerable:!0,get:function(){return r.encodeAminoPubkey}}),Object.defineProperty(e,"encodeBech32Pubkey",{enumerable:!0,get:function(){return r.encodeBech32Pubkey}}),Object.defineProperty(e,"encodeEd25519Pubkey",{enumerable:!0,get:function(){return r.encodeEd25519Pubkey}}),Object.defineProperty(e,"encodeSecp256k1Pubkey",{enumerable:!0,get:function(){return r.encodeSecp256k1Pubkey}});var o=A;Object.defineProperty(e,"createMultisigThresholdPubkey",{enumerable:!0,get:function(){return o.createMultisigThresholdPubkey}});var i=D;Object.defineProperty(e,"omitDefault",{enumerable:!0,get:function(){return i.omitDefault}});var c=$;Object.defineProperty(e,"makeCosmoshubPath",{enumerable:!0,get:function(){return c.makeCosmoshubPath}});var u=B;Object.defineProperty(e,"isEd25519Pubkey",{enumerable:!0,get:function(){return u.isEd25519Pubkey}}),Object.defineProperty(e,"isMultisigThresholdPubkey",{enumerable:!0,get:function(){return u.isMultisigThresholdPubkey}}),Object.defineProperty(e,"isSecp256k1Pubkey",{enumerable:!0,get:function(){return u.isSecp256k1Pubkey}}),Object.defineProperty(e,"isSinglePubkey",{enumerable:!0,get:function(){return u.isSinglePubkey}}),Object.defineProperty(e,"pubkeyType",{enumerable:!0,get:function(){return u.pubkeyType}});var s=T;Object.defineProperty(e,"extractKdfConfiguration",{enumerable:!0,get:function(){return s.extractKdfConfiguration}}),Object.defineProperty(e,"Secp256k1HdWallet",{enumerable:!0,get:function(){return s.Secp256k1HdWallet}});var d=N;Object.defineProperty(e,"Secp256k1Wallet",{enumerable:!0,get:function(){return d.Secp256k1Wallet}});var S=k;Object.defineProperty(e,"decodeSignature",{enumerable:!0,get:function(){return S.decodeSignature}}),Object.defineProperty(e,"encodeSecp256k1Signature",{enumerable:!0,get:function(){return S.encodeSecp256k1Signature}});var g=h;Object.defineProperty(e,"makeSignDoc",{enumerable:!0,get:function(){return g.makeSignDoc}}),Object.defineProperty(e,"serializeSignDoc",{enumerable:!0,get:function(){return g.serializeSignDoc}});var Z=E;Object.defineProperty(e,"isStdTx",{enumerable:!0,get:function(){return Z.isStdTx}}),Object.defineProperty(e,"makeStdTx",{enumerable:!0,get:function(){return Z.makeStdTx}});var le=F;Object.defineProperty(e,"executeKdf",{enumerable:!0,get:function(){return le.executeKdf}})})(V);const Xe=fe({__proto__:null},[V]);exports.build=V;exports.index=Xe;
