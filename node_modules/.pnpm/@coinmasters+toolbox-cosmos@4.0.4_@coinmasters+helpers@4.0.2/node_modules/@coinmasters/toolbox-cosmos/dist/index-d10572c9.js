import { t as fe, s as Te, e as G, b as W, h as $, a as pe, d as me, o as j } from "./index-dd5ccbe6.js";
import { b as H } from "./index-c4fe3c8a.js";
import { b as Oe, e as q, a as Ne } from "./index-376c10b7.js";
function Ke(e, t) {
  for (var r = 0; r < t.length; r++) {
    const u = t[r];
    if (typeof u != "string" && !Array.isArray(u)) {
      for (const c in u)
        if (c !== "default" && !(c in e)) {
          const y = Object.getOwnPropertyDescriptor(u, c);
          y && Object.defineProperty(e, c, y.get ? y : {
            enumerable: !0,
            get: () => u[c]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var ve = {}, V = {};
Object.defineProperty(V, "__esModule", { value: !0 });
V.parseCoins = void 0;
function Je(e) {
  return e.replace(/\s/g, "").split(",").filter(Boolean).map((t) => {
    const r = t.match(/^([0-9]+)([a-zA-Z][a-zA-Z0-9/]{2,127})$/);
    if (!r)
      throw new Error("Got an invalid coin string");
    return {
      amount: r[1].replace(/^0+/, "") || "0",
      denom: r[2]
    };
  });
}
V.parseCoins = Je;
var X = {};
Object.defineProperty(X, "__esModule", { value: !0 });
X.decodeTxRaw = void 0;
const x = fe;
function Ce(e) {
  const t = x.TxRaw.decode(e);
  return {
    authInfo: x.AuthInfo.decode(t.authInfoBytes),
    body: x.TxBody.decode(t.bodyBytes),
    signatures: t.signatures
  };
}
X.decodeTxRaw = Ce;
var T = {}, w = {};
Object.defineProperty(w, "__esModule", { value: !0 });
w.makeSignBytes = w.makeSignDoc = w.makeAuthInfoBytes = void 0;
const Se = Oe, De = Te, z = fe;
function Ie(e, t) {
  return e.map(({ pubkey: r, sequence: u }) => ({
    publicKey: r,
    modeInfo: {
      single: { mode: t }
    },
    sequence: BigInt(u)
  }));
}
function We(e, t, r, u, c, y = De.SignMode.SIGN_MODE_DIRECT) {
  (0, Se.assert)(u === void 0 || typeof u == "string", "feeGranter must be undefined or string"), (0, Se.assert)(c === void 0 || typeof c == "string", "feePayer must be undefined or string");
  const f = z.AuthInfo.fromPartial({
    signerInfos: Ie(e, y),
    fee: {
      amount: [...t],
      gasLimit: BigInt(r),
      granter: u,
      payer: c
    }
  });
  return z.AuthInfo.encode(f).finish();
}
w.makeAuthInfoBytes = We;
function $e(e, t, r, u) {
  return {
    bodyBytes: e,
    authInfoBytes: t,
    chainId: r,
    accountNumber: BigInt(u)
  };
}
w.makeSignDoc = $e;
function Le({ accountNumber: e, authInfoBytes: t, bodyBytes: r, chainId: u }) {
  const c = z.SignDoc.fromPartial({
    accountNumber: e,
    authInfoBytes: t,
    bodyBytes: r,
    chainId: u
  });
  return z.SignDoc.encode(c).finish();
}
w.makeSignBytes = Le;
var be = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.decrypt = e.encrypt = e.supportedAlgorithms = e.executeKdf = e.cosmjsSalt = void 0;
  const t = q, r = G;
  e.cosmjsSalt = (0, r.toAscii)("The CosmJS salt.");
  async function u(f, p) {
    switch (p.algorithm) {
      case "argon2id": {
        const m = p.params;
        if (!(0, t.isArgon2idOptions)(m))
          throw new Error("Invalid format of argon2id params");
        return t.Argon2id.execute(f, e.cosmjsSalt, m);
      }
      default:
        throw new Error("Unsupported KDF algorithm");
    }
  }
  e.executeKdf = u, e.supportedAlgorithms = {
    xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
  };
  async function c(f, p, m) {
    switch (m.algorithm) {
      case e.supportedAlgorithms.xchacha20poly1305Ietf: {
        const h = t.Random.getBytes(t.xchacha20NonceLength);
        return new Uint8Array([
          ...h,
          ...await t.Xchacha20poly1305Ietf.encrypt(f, p, h)
        ]);
      }
      default:
        throw new Error(`Unsupported encryption algorithm: '${m.algorithm}'`);
    }
  }
  e.encrypt = c;
  async function y(f, p, m) {
    switch (m.algorithm) {
      case e.supportedAlgorithms.xchacha20poly1305Ietf: {
        const h = f.slice(0, t.xchacha20NonceLength);
        return t.Xchacha20poly1305Ietf.decrypt(f.slice(t.xchacha20NonceLength), p, h);
      }
      default:
        throw new Error(`Unsupported encryption algorithm: '${m.algorithm}'`);
    }
  }
  e.decrypt = y;
})(be);
Object.defineProperty(T, "__esModule", { value: !0 });
T.DirectSecp256k1HdWallet = T.extractKdfConfiguration = void 0;
const de = H, g = q, K = G, E = Oe, Fe = w, J = be, F = "directsecp256k1hdwallet-v1", ze = {
  algorithm: "argon2id",
  params: {
    outputLength: 32,
    opsLimit: 24,
    memLimitKib: 12 * 1024
  }
};
function Ge(e) {
  return !(!(0, E.isNonNullObject)(e) || typeof e.hdPath != "string" || typeof e.prefix != "string");
}
function He(e) {
  return e.kdf;
}
function qe(e) {
  const t = JSON.parse(e);
  if (!(0, E.isNonNullObject)(t))
    throw new Error("Root document is not an object.");
  switch (t.type) {
    case F:
      return He(t);
    default:
      throw new Error("Unsupported serialization type");
  }
}
T.extractKdfConfiguration = qe;
const ge = {
  bip39Password: "",
  hdPaths: [(0, de.makeCosmoshubPath)(0)],
  prefix: "cosmos"
};
class A {
  /**
   * Restores a wallet from the given BIP39 mnemonic.
   *
   * @param mnemonic Any valid English mnemonic.
   * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
   */
  static async fromMnemonic(t, r = {}) {
    const u = new g.EnglishMnemonic(t), c = await g.Bip39.mnemonicToSeed(u, r.bip39Password);
    return new A(u, {
      ...r,
      seed: c
    });
  }
  /**
   * Generates a new wallet with a BIP39 mnemonic of the given length.
   *
   * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
   * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
   */
  static async generate(t = 12, r = {}) {
    const u = 4 * Math.floor(11 * t / 33), c = g.Random.getBytes(u), y = g.Bip39.encode(c);
    return A.fromMnemonic(y.toString(), r);
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * @param password The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  static async deserialize(t, r) {
    const u = JSON.parse(t);
    if (!(0, E.isNonNullObject)(u))
      throw new Error("Root document is not an object.");
    switch (u.type) {
      case F:
        return A.deserializeTypeV1(t, r);
      default:
        throw new Error("Unsupported serialization type");
    }
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
   * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
   * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
   */
  static async deserializeWithEncryptionKey(t, r) {
    const u = JSON.parse(t);
    if (!(0, E.isNonNullObject)(u))
      throw new Error("Root document is not an object.");
    const c = u;
    switch (c.type) {
      case F: {
        const y = await (0, J.decrypt)((0, K.fromBase64)(c.data), r, c.encryption), f = JSON.parse((0, K.fromUtf8)(y)), { mnemonic: p, accounts: m } = f;
        if ((0, E.assert)(typeof p == "string"), !Array.isArray(m))
          throw new Error("Property 'accounts' is not an array");
        if (!m.every((n) => Ge(n)))
          throw new Error("Account is not in the correct format.");
        const h = m[0].prefix;
        if (!m.every(({ prefix: n }) => n === h))
          throw new Error("Accounts do not all have the same prefix");
        const S = m.map(({ hdPath: n }) => (0, g.stringToPath)(n));
        return A.fromMnemonic(p, {
          hdPaths: S,
          prefix: h
        });
      }
      default:
        throw new Error("Unsupported serialization type");
    }
  }
  static async deserializeTypeV1(t, r) {
    const u = JSON.parse(t);
    if (!(0, E.isNonNullObject)(u))
      throw new Error("Root document is not an object.");
    const c = await (0, J.executeKdf)(r, u.kdf);
    return A.deserializeWithEncryptionKey(t, c);
  }
  constructor(t, r) {
    const u = r.prefix ?? ge.prefix, c = r.hdPaths ?? ge.hdPaths;
    this.secret = t, this.seed = r.seed, this.accounts = c.map((y) => ({
      hdPath: y,
      prefix: u
    }));
  }
  get mnemonic() {
    return this.secret.toString();
  }
  async getAccounts() {
    return (await this.getAccountsWithPrivkeys()).map(({ algo: r, pubkey: u, address: c }) => ({
      algo: r,
      pubkey: u,
      address: c
    }));
  }
  async signDirect(t, r) {
    const c = (await this.getAccountsWithPrivkeys()).find(({ address: o }) => o === t);
    if (c === void 0)
      throw new Error(`Address ${t} not found in wallet`);
    const { privkey: y, pubkey: f } = c, p = (0, Fe.makeSignBytes)(r), m = (0, g.sha256)(p), h = await g.Secp256k1.createSignature(m, y), S = new Uint8Array([...h.r(32), ...h.s(32)]), n = (0, de.encodeSecp256k1Signature)(f, S);
    return {
      signed: r,
      signature: n
    };
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * @param password The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  async serialize(t) {
    const r = ze, u = await (0, J.executeKdf)(t, r);
    return this.serializeWithEncryptionKey(u, r);
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
   * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF options. If this
   * is not the case, the wallet cannot be restored with the original password.
   */
  async serializeWithEncryptionKey(t, r) {
    const u = {
      mnemonic: this.mnemonic,
      accounts: this.accounts.map(({ hdPath: m, prefix: h }) => ({
        hdPath: (0, g.pathToString)(m),
        prefix: h
      }))
    }, c = (0, K.toUtf8)(JSON.stringify(u)), y = {
      algorithm: J.supportedAlgorithms.xchacha20poly1305Ietf
    }, f = await (0, J.encrypt)(c, t, y), p = {
      type: F,
      kdf: r,
      encryption: y,
      data: (0, K.toBase64)(f)
    };
    return JSON.stringify(p);
  }
  async getKeyPair(t) {
    const { privkey: r } = g.Slip10.derivePath(g.Slip10Curve.Secp256k1, this.seed, t), { pubkey: u } = await g.Secp256k1.makeKeypair(r);
    return {
      privkey: r,
      pubkey: g.Secp256k1.compressPubkey(u)
    };
  }
  async getAccountsWithPrivkeys() {
    return Promise.all(this.accounts.map(async ({ hdPath: t, prefix: r }) => {
      const { privkey: u, pubkey: c } = await this.getKeyPair(t), y = (0, K.toBech32)(r, (0, de.rawSecp256k1PubkeyToRawAddress)(c));
      return {
        algo: "secp256k1",
        privkey: u,
        pubkey: c,
        address: y
      };
    }));
  }
}
T.DirectSecp256k1HdWallet = A;
var Z = {};
Object.defineProperty(Z, "__esModule", { value: !0 });
Z.DirectSecp256k1Wallet = void 0;
const Pe = H, L = q, Ve = G, Xe = w;
class he {
  /**
   * Creates a DirectSecp256k1Wallet from the given private key
   *
   * @param privkey The private key.
   * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
   */
  static async fromKey(t, r = "cosmos") {
    const u = (await L.Secp256k1.makeKeypair(t)).pubkey;
    return new he(t, L.Secp256k1.compressPubkey(u), r);
  }
  constructor(t, r, u) {
    this.privkey = t, this.pubkey = r, this.prefix = u;
  }
  get address() {
    return (0, Ve.toBech32)(this.prefix, (0, Pe.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
  }
  async getAccounts() {
    return [
      {
        algo: "secp256k1",
        address: this.address,
        pubkey: this.pubkey
      }
    ];
  }
  async signDirect(t, r) {
    const u = (0, Xe.makeSignBytes)(r);
    if (t !== this.address)
      throw new Error(`Address ${t} not found in wallet`);
    const c = (0, L.sha256)(u), y = await L.Secp256k1.createSignature(c, this.privkey), f = new Uint8Array([...y.r(32), ...y.s(32)]), p = (0, Pe.encodeSecp256k1Signature)(this.pubkey, f);
    return {
      signed: r,
      signature: p
    };
  }
}
Z.DirectSecp256k1Wallet = he;
var Q = {};
Object.defineProperty(Q, "__esModule", { value: !0 });
Q.makeCosmoshubPath = void 0;
const C = q;
function Ze(e) {
  return [
    C.Slip10RawIndex.hardened(44),
    C.Slip10RawIndex.hardened(118),
    C.Slip10RawIndex.hardened(0),
    C.Slip10RawIndex.normal(0),
    C.Slip10RawIndex.normal(e)
  ];
}
Q.makeCosmoshubPath = Ze;
var B = {}, O = {};
Object.defineProperty(O, "__esModule", { value: !0 });
O.PrivKey = O.PubKey = O.protobufPackage = void 0;
const M = W, _ = $;
O.protobufPackage = "cosmos.crypto.ed25519";
function ee() {
  return {
    key: new Uint8Array()
  };
}
O.PubKey = {
  typeUrl: "/cosmos.crypto.ed25519.PubKey",
  encode(e, t = M.BinaryWriter.create()) {
    return e.key.length !== 0 && t.uint32(10).bytes(e.key), t;
  },
  decode(e, t) {
    const r = e instanceof M.BinaryReader ? e : new M.BinaryReader(e);
    let u = t === void 0 ? r.len : r.pos + t;
    const c = ee();
    for (; r.pos < u; ) {
      const y = r.uint32();
      switch (y >>> 3) {
        case 1:
          c.key = r.bytes();
          break;
        default:
          r.skipType(y & 7);
          break;
      }
    }
    return c;
  },
  fromJSON(e) {
    const t = ee();
    return (0, _.isSet)(e.key) && (t.key = (0, _.bytesFromBase64)(e.key)), t;
  },
  toJSON(e) {
    const t = {};
    return e.key !== void 0 && (t.key = (0, _.base64FromBytes)(e.key !== void 0 ? e.key : new Uint8Array())), t;
  },
  fromPartial(e) {
    const t = ee();
    return t.key = e.key ?? new Uint8Array(), t;
  }
};
function ne() {
  return {
    key: new Uint8Array()
  };
}
O.PrivKey = {
  typeUrl: "/cosmos.crypto.ed25519.PrivKey",
  encode(e, t = M.BinaryWriter.create()) {
    return e.key.length !== 0 && t.uint32(10).bytes(e.key), t;
  },
  decode(e, t) {
    const r = e instanceof M.BinaryReader ? e : new M.BinaryReader(e);
    let u = t === void 0 ? r.len : r.pos + t;
    const c = ne();
    for (; r.pos < u; ) {
      const y = r.uint32();
      switch (y >>> 3) {
        case 1:
          c.key = r.bytes();
          break;
        default:
          r.skipType(y & 7);
          break;
      }
    }
    return c;
  },
  fromJSON(e) {
    const t = ne();
    return (0, _.isSet)(e.key) && (t.key = (0, _.bytesFromBase64)(e.key)), t;
  },
  toJSON(e) {
    const t = {};
    return e.key !== void 0 && (t.key = (0, _.base64FromBytes)(e.key !== void 0 ? e.key : new Uint8Array())), t;
  },
  fromPartial(e) {
    const t = ne();
    return t.key = e.key ?? new Uint8Array(), t;
  }
};
var N = {};
Object.defineProperty(N, "__esModule", { value: !0 });
N.LegacyAminoPubKey = N.protobufPackage = void 0;
const D = pe, te = W, Qe = $;
N.protobufPackage = "cosmos.crypto.multisig";
function re() {
  return {
    threshold: 0,
    publicKeys: []
  };
}
N.LegacyAminoPubKey = {
  typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
  encode(e, t = te.BinaryWriter.create()) {
    e.threshold !== 0 && t.uint32(8).uint32(e.threshold);
    for (const r of e.publicKeys)
      D.Any.encode(r, t.uint32(18).fork()).ldelim();
    return t;
  },
  decode(e, t) {
    const r = e instanceof te.BinaryReader ? e : new te.BinaryReader(e);
    let u = t === void 0 ? r.len : r.pos + t;
    const c = re();
    for (; r.pos < u; ) {
      const y = r.uint32();
      switch (y >>> 3) {
        case 1:
          c.threshold = r.uint32();
          break;
        case 2:
          c.publicKeys.push(D.Any.decode(r, r.uint32()));
          break;
        default:
          r.skipType(y & 7);
          break;
      }
    }
    return c;
  },
  fromJSON(e) {
    const t = re();
    return (0, Qe.isSet)(e.threshold) && (t.threshold = Number(e.threshold)), Array.isArray(e == null ? void 0 : e.publicKeys) && (t.publicKeys = e.publicKeys.map((r) => D.Any.fromJSON(r))), t;
  },
  toJSON(e) {
    const t = {};
    return e.threshold !== void 0 && (t.threshold = Math.round(e.threshold)), e.publicKeys ? t.publicKeys = e.publicKeys.map((r) => r ? D.Any.toJSON(r) : void 0) : t.publicKeys = [], t;
  },
  fromPartial(e) {
    var r;
    const t = re();
    return t.threshold = e.threshold ?? 0, t.publicKeys = ((r = e.publicKeys) == null ? void 0 : r.map((u) => D.Any.fromPartial(u))) || [], t;
  }
};
var v = {};
Object.defineProperty(v, "__esModule", { value: !0 });
v.PrivKey = v.PubKey = v.protobufPackage = void 0;
const U = W, R = $;
v.protobufPackage = "cosmos.crypto.secp256k1";
function oe() {
  return {
    key: new Uint8Array()
  };
}
v.PubKey = {
  typeUrl: "/cosmos.crypto.secp256k1.PubKey",
  encode(e, t = U.BinaryWriter.create()) {
    return e.key.length !== 0 && t.uint32(10).bytes(e.key), t;
  },
  decode(e, t) {
    const r = e instanceof U.BinaryReader ? e : new U.BinaryReader(e);
    let u = t === void 0 ? r.len : r.pos + t;
    const c = oe();
    for (; r.pos < u; ) {
      const y = r.uint32();
      switch (y >>> 3) {
        case 1:
          c.key = r.bytes();
          break;
        default:
          r.skipType(y & 7);
          break;
      }
    }
    return c;
  },
  fromJSON(e) {
    const t = oe();
    return (0, R.isSet)(e.key) && (t.key = (0, R.bytesFromBase64)(e.key)), t;
  },
  toJSON(e) {
    const t = {};
    return e.key !== void 0 && (t.key = (0, R.base64FromBytes)(e.key !== void 0 ? e.key : new Uint8Array())), t;
  },
  fromPartial(e) {
    const t = oe();
    return t.key = e.key ?? new Uint8Array(), t;
  }
};
function ae() {
  return {
    key: new Uint8Array()
  };
}
v.PrivKey = {
  typeUrl: "/cosmos.crypto.secp256k1.PrivKey",
  encode(e, t = U.BinaryWriter.create()) {
    return e.key.length !== 0 && t.uint32(10).bytes(e.key), t;
  },
  decode(e, t) {
    const r = e instanceof U.BinaryReader ? e : new U.BinaryReader(e);
    let u = t === void 0 ? r.len : r.pos + t;
    const c = ae();
    for (; r.pos < u; ) {
      const y = r.uint32();
      switch (y >>> 3) {
        case 1:
          c.key = r.bytes();
          break;
        default:
          r.skipType(y & 7);
          break;
      }
    }
    return c;
  },
  fromJSON(e) {
    const t = ae();
    return (0, R.isSet)(e.key) && (t.key = (0, R.bytesFromBase64)(e.key)), t;
  },
  toJSON(e) {
    const t = {};
    return e.key !== void 0 && (t.key = (0, R.base64FromBytes)(e.key !== void 0 ? e.key : new Uint8Array())), t;
  },
  fromPartial(e) {
    const t = ae();
    return t.key = e.key ?? new Uint8Array(), t;
  }
};
Object.defineProperty(B, "__esModule", { value: !0 });
B.decodeOptionalPubkey = B.decodePubkey = B.anyToSinglePubkey = B.encodePubkey = void 0;
const I = H, Be = G, Ye = Ne, ue = O, ce = N, ye = v, se = pe;
function Ae(e) {
  if ((0, I.isSecp256k1Pubkey)(e)) {
    const t = ye.PubKey.fromPartial({
      key: (0, Be.fromBase64)(e.value)
    });
    return se.Any.fromPartial({
      typeUrl: "/cosmos.crypto.secp256k1.PubKey",
      value: Uint8Array.from(ye.PubKey.encode(t).finish())
    });
  } else if ((0, I.isEd25519Pubkey)(e)) {
    const t = ue.PubKey.fromPartial({
      key: (0, Be.fromBase64)(e.value)
    });
    return se.Any.fromPartial({
      typeUrl: "/cosmos.crypto.ed25519.PubKey",
      value: Uint8Array.from(ue.PubKey.encode(t).finish())
    });
  } else if ((0, I.isMultisigThresholdPubkey)(e)) {
    const t = ce.LegacyAminoPubKey.fromPartial({
      threshold: Ye.Uint53.fromString(e.value.threshold).toNumber(),
      publicKeys: e.value.pubkeys.map(Ae)
    });
    return se.Any.fromPartial({
      typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
      value: Uint8Array.from(ce.LegacyAminoPubKey.encode(t).finish())
    });
  } else
    throw new Error(`Pubkey type ${e.type} not recognized`);
}
B.encodePubkey = Ae;
function le(e) {
  switch (e.typeUrl) {
    case "/cosmos.crypto.secp256k1.PubKey": {
      const { key: t } = ye.PubKey.decode(e.value);
      return (0, I.encodeSecp256k1Pubkey)(t);
    }
    case "/cosmos.crypto.ed25519.PubKey": {
      const { key: t } = ue.PubKey.decode(e.value);
      return (0, I.encodeEd25519Pubkey)(t);
    }
    default:
      throw new Error(`Pubkey type_url ${e.typeUrl} not recognized as single public key type`);
  }
}
B.anyToSinglePubkey = le;
function Ee(e) {
  switch (e.typeUrl) {
    case "/cosmos.crypto.secp256k1.PubKey":
    case "/cosmos.crypto.ed25519.PubKey":
      return le(e);
    case "/cosmos.crypto.multisig.LegacyAminoPubKey": {
      const { threshold: t, publicKeys: r } = ce.LegacyAminoPubKey.decode(e.value);
      return {
        type: "tendermint/PubKeyMultisigThreshold",
        value: {
          threshold: t.toString(),
          pubkeys: r.map(le)
        }
      };
    }
    default:
      throw new Error(`Pubkey type URL '${e.typeUrl}' not recognized`);
  }
}
B.decodePubkey = Ee;
function je(e) {
  if (!e)
    return null;
  if (e.typeUrl) {
    if (e.value.length)
      return Ee(e);
    throw new Error(`Pubkey is an Any with type URL '${e.typeUrl}' but an empty value`);
  } else {
    if (e.value.length)
      throw new Error("Pubkey is an Any with an empty type URL but a value set");
    return null;
  }
}
B.decodeOptionalPubkey = je;
var P = {}, Me = {}, _e = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Metadata = e.DenomUnit = e.Supply = e.Output = e.Input = e.SendEnabled = e.Params = e.protobufPackage = void 0;
  const t = me, r = W, u = $;
  e.protobufPackage = "cosmos.bank.v1beta1";
  function c() {
    return {
      sendEnabled: [],
      defaultSendEnabled: !1
    };
  }
  e.Params = {
    typeUrl: "/cosmos.bank.v1beta1.Params",
    encode(n, o = r.BinaryWriter.create()) {
      for (const d of n.sendEnabled)
        e.SendEnabled.encode(d, o.uint32(10).fork()).ldelim();
      return n.defaultSendEnabled === !0 && o.uint32(16).bool(n.defaultSendEnabled), o;
    },
    decode(n, o) {
      const d = n instanceof r.BinaryReader ? n : new r.BinaryReader(n);
      let a = o === void 0 ? d.len : d.pos + o;
      const s = c();
      for (; d.pos < a; ) {
        const i = d.uint32();
        switch (i >>> 3) {
          case 1:
            s.sendEnabled.push(e.SendEnabled.decode(d, d.uint32()));
            break;
          case 2:
            s.defaultSendEnabled = d.bool();
            break;
          default:
            d.skipType(i & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      const o = c();
      return Array.isArray(n == null ? void 0 : n.sendEnabled) && (o.sendEnabled = n.sendEnabled.map((d) => e.SendEnabled.fromJSON(d))), (0, u.isSet)(n.defaultSendEnabled) && (o.defaultSendEnabled = !!n.defaultSendEnabled), o;
    },
    toJSON(n) {
      const o = {};
      return n.sendEnabled ? o.sendEnabled = n.sendEnabled.map((d) => d ? e.SendEnabled.toJSON(d) : void 0) : o.sendEnabled = [], n.defaultSendEnabled !== void 0 && (o.defaultSendEnabled = n.defaultSendEnabled), o;
    },
    fromPartial(n) {
      var d;
      const o = c();
      return o.sendEnabled = ((d = n.sendEnabled) == null ? void 0 : d.map((a) => e.SendEnabled.fromPartial(a))) || [], o.defaultSendEnabled = n.defaultSendEnabled ?? !1, o;
    }
  };
  function y() {
    return {
      denom: "",
      enabled: !1
    };
  }
  e.SendEnabled = {
    typeUrl: "/cosmos.bank.v1beta1.SendEnabled",
    encode(n, o = r.BinaryWriter.create()) {
      return n.denom !== "" && o.uint32(10).string(n.denom), n.enabled === !0 && o.uint32(16).bool(n.enabled), o;
    },
    decode(n, o) {
      const d = n instanceof r.BinaryReader ? n : new r.BinaryReader(n);
      let a = o === void 0 ? d.len : d.pos + o;
      const s = y();
      for (; d.pos < a; ) {
        const i = d.uint32();
        switch (i >>> 3) {
          case 1:
            s.denom = d.string();
            break;
          case 2:
            s.enabled = d.bool();
            break;
          default:
            d.skipType(i & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      const o = y();
      return (0, u.isSet)(n.denom) && (o.denom = String(n.denom)), (0, u.isSet)(n.enabled) && (o.enabled = !!n.enabled), o;
    },
    toJSON(n) {
      const o = {};
      return n.denom !== void 0 && (o.denom = n.denom), n.enabled !== void 0 && (o.enabled = n.enabled), o;
    },
    fromPartial(n) {
      const o = y();
      return o.denom = n.denom ?? "", o.enabled = n.enabled ?? !1, o;
    }
  };
  function f() {
    return {
      address: "",
      coins: []
    };
  }
  e.Input = {
    typeUrl: "/cosmos.bank.v1beta1.Input",
    encode(n, o = r.BinaryWriter.create()) {
      n.address !== "" && o.uint32(10).string(n.address);
      for (const d of n.coins)
        t.Coin.encode(d, o.uint32(18).fork()).ldelim();
      return o;
    },
    decode(n, o) {
      const d = n instanceof r.BinaryReader ? n : new r.BinaryReader(n);
      let a = o === void 0 ? d.len : d.pos + o;
      const s = f();
      for (; d.pos < a; ) {
        const i = d.uint32();
        switch (i >>> 3) {
          case 1:
            s.address = d.string();
            break;
          case 2:
            s.coins.push(t.Coin.decode(d, d.uint32()));
            break;
          default:
            d.skipType(i & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      const o = f();
      return (0, u.isSet)(n.address) && (o.address = String(n.address)), Array.isArray(n == null ? void 0 : n.coins) && (o.coins = n.coins.map((d) => t.Coin.fromJSON(d))), o;
    },
    toJSON(n) {
      const o = {};
      return n.address !== void 0 && (o.address = n.address), n.coins ? o.coins = n.coins.map((d) => d ? t.Coin.toJSON(d) : void 0) : o.coins = [], o;
    },
    fromPartial(n) {
      var d;
      const o = f();
      return o.address = n.address ?? "", o.coins = ((d = n.coins) == null ? void 0 : d.map((a) => t.Coin.fromPartial(a))) || [], o;
    }
  };
  function p() {
    return {
      address: "",
      coins: []
    };
  }
  e.Output = {
    typeUrl: "/cosmos.bank.v1beta1.Output",
    encode(n, o = r.BinaryWriter.create()) {
      n.address !== "" && o.uint32(10).string(n.address);
      for (const d of n.coins)
        t.Coin.encode(d, o.uint32(18).fork()).ldelim();
      return o;
    },
    decode(n, o) {
      const d = n instanceof r.BinaryReader ? n : new r.BinaryReader(n);
      let a = o === void 0 ? d.len : d.pos + o;
      const s = p();
      for (; d.pos < a; ) {
        const i = d.uint32();
        switch (i >>> 3) {
          case 1:
            s.address = d.string();
            break;
          case 2:
            s.coins.push(t.Coin.decode(d, d.uint32()));
            break;
          default:
            d.skipType(i & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      const o = p();
      return (0, u.isSet)(n.address) && (o.address = String(n.address)), Array.isArray(n == null ? void 0 : n.coins) && (o.coins = n.coins.map((d) => t.Coin.fromJSON(d))), o;
    },
    toJSON(n) {
      const o = {};
      return n.address !== void 0 && (o.address = n.address), n.coins ? o.coins = n.coins.map((d) => d ? t.Coin.toJSON(d) : void 0) : o.coins = [], o;
    },
    fromPartial(n) {
      var d;
      const o = p();
      return o.address = n.address ?? "", o.coins = ((d = n.coins) == null ? void 0 : d.map((a) => t.Coin.fromPartial(a))) || [], o;
    }
  };
  function m() {
    return {
      total: []
    };
  }
  e.Supply = {
    typeUrl: "/cosmos.bank.v1beta1.Supply",
    encode(n, o = r.BinaryWriter.create()) {
      for (const d of n.total)
        t.Coin.encode(d, o.uint32(10).fork()).ldelim();
      return o;
    },
    decode(n, o) {
      const d = n instanceof r.BinaryReader ? n : new r.BinaryReader(n);
      let a = o === void 0 ? d.len : d.pos + o;
      const s = m();
      for (; d.pos < a; ) {
        const i = d.uint32();
        switch (i >>> 3) {
          case 1:
            s.total.push(t.Coin.decode(d, d.uint32()));
            break;
          default:
            d.skipType(i & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      const o = m();
      return Array.isArray(n == null ? void 0 : n.total) && (o.total = n.total.map((d) => t.Coin.fromJSON(d))), o;
    },
    toJSON(n) {
      const o = {};
      return n.total ? o.total = n.total.map((d) => d ? t.Coin.toJSON(d) : void 0) : o.total = [], o;
    },
    fromPartial(n) {
      var d;
      const o = m();
      return o.total = ((d = n.total) == null ? void 0 : d.map((a) => t.Coin.fromPartial(a))) || [], o;
    }
  };
  function h() {
    return {
      denom: "",
      exponent: 0,
      aliases: []
    };
  }
  e.DenomUnit = {
    typeUrl: "/cosmos.bank.v1beta1.DenomUnit",
    encode(n, o = r.BinaryWriter.create()) {
      n.denom !== "" && o.uint32(10).string(n.denom), n.exponent !== 0 && o.uint32(16).uint32(n.exponent);
      for (const d of n.aliases)
        o.uint32(26).string(d);
      return o;
    },
    decode(n, o) {
      const d = n instanceof r.BinaryReader ? n : new r.BinaryReader(n);
      let a = o === void 0 ? d.len : d.pos + o;
      const s = h();
      for (; d.pos < a; ) {
        const i = d.uint32();
        switch (i >>> 3) {
          case 1:
            s.denom = d.string();
            break;
          case 2:
            s.exponent = d.uint32();
            break;
          case 3:
            s.aliases.push(d.string());
            break;
          default:
            d.skipType(i & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      const o = h();
      return (0, u.isSet)(n.denom) && (o.denom = String(n.denom)), (0, u.isSet)(n.exponent) && (o.exponent = Number(n.exponent)), Array.isArray(n == null ? void 0 : n.aliases) && (o.aliases = n.aliases.map((d) => String(d))), o;
    },
    toJSON(n) {
      const o = {};
      return n.denom !== void 0 && (o.denom = n.denom), n.exponent !== void 0 && (o.exponent = Math.round(n.exponent)), n.aliases ? o.aliases = n.aliases.map((d) => d) : o.aliases = [], o;
    },
    fromPartial(n) {
      var d;
      const o = h();
      return o.denom = n.denom ?? "", o.exponent = n.exponent ?? 0, o.aliases = ((d = n.aliases) == null ? void 0 : d.map((a) => a)) || [], o;
    }
  };
  function S() {
    return {
      description: "",
      denomUnits: [],
      base: "",
      display: "",
      name: "",
      symbol: "",
      uri: "",
      uriHash: ""
    };
  }
  e.Metadata = {
    typeUrl: "/cosmos.bank.v1beta1.Metadata",
    encode(n, o = r.BinaryWriter.create()) {
      n.description !== "" && o.uint32(10).string(n.description);
      for (const d of n.denomUnits)
        e.DenomUnit.encode(d, o.uint32(18).fork()).ldelim();
      return n.base !== "" && o.uint32(26).string(n.base), n.display !== "" && o.uint32(34).string(n.display), n.name !== "" && o.uint32(42).string(n.name), n.symbol !== "" && o.uint32(50).string(n.symbol), n.uri !== "" && o.uint32(58).string(n.uri), n.uriHash !== "" && o.uint32(66).string(n.uriHash), o;
    },
    decode(n, o) {
      const d = n instanceof r.BinaryReader ? n : new r.BinaryReader(n);
      let a = o === void 0 ? d.len : d.pos + o;
      const s = S();
      for (; d.pos < a; ) {
        const i = d.uint32();
        switch (i >>> 3) {
          case 1:
            s.description = d.string();
            break;
          case 2:
            s.denomUnits.push(e.DenomUnit.decode(d, d.uint32()));
            break;
          case 3:
            s.base = d.string();
            break;
          case 4:
            s.display = d.string();
            break;
          case 5:
            s.name = d.string();
            break;
          case 6:
            s.symbol = d.string();
            break;
          case 7:
            s.uri = d.string();
            break;
          case 8:
            s.uriHash = d.string();
            break;
          default:
            d.skipType(i & 7);
            break;
        }
      }
      return s;
    },
    fromJSON(n) {
      const o = S();
      return (0, u.isSet)(n.description) && (o.description = String(n.description)), Array.isArray(n == null ? void 0 : n.denomUnits) && (o.denomUnits = n.denomUnits.map((d) => e.DenomUnit.fromJSON(d))), (0, u.isSet)(n.base) && (o.base = String(n.base)), (0, u.isSet)(n.display) && (o.display = String(n.display)), (0, u.isSet)(n.name) && (o.name = String(n.name)), (0, u.isSet)(n.symbol) && (o.symbol = String(n.symbol)), (0, u.isSet)(n.uri) && (o.uri = String(n.uri)), (0, u.isSet)(n.uriHash) && (o.uriHash = String(n.uriHash)), o;
    },
    toJSON(n) {
      const o = {};
      return n.description !== void 0 && (o.description = n.description), n.denomUnits ? o.denomUnits = n.denomUnits.map((d) => d ? e.DenomUnit.toJSON(d) : void 0) : o.denomUnits = [], n.base !== void 0 && (o.base = n.base), n.display !== void 0 && (o.display = n.display), n.name !== void 0 && (o.name = n.name), n.symbol !== void 0 && (o.symbol = n.symbol), n.uri !== void 0 && (o.uri = n.uri), n.uriHash !== void 0 && (o.uriHash = n.uriHash), o;
    },
    fromPartial(n) {
      var d;
      const o = S();
      return o.description = n.description ?? "", o.denomUnits = ((d = n.denomUnits) == null ? void 0 : d.map((a) => e.DenomUnit.fromPartial(a))) || [], o.base = n.base ?? "", o.display = n.display ?? "", o.name = n.name ?? "", o.symbol = n.symbol ?? "", o.uri = n.uri ?? "", o.uriHash = n.uriHash ?? "", o;
    }
  };
})(_e);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgSetSendEnabledResponse = e.MsgSetSendEnabled = e.MsgUpdateParamsResponse = e.MsgUpdateParams = e.MsgMultiSendResponse = e.MsgMultiSend = e.MsgSendResponse = e.MsgSend = e.protobufPackage = void 0;
  const t = me, r = _e, u = W, c = $;
  e.protobufPackage = "cosmos.bank.v1beta1";
  function y() {
    return {
      fromAddress: "",
      toAddress: "",
      amount: []
    };
  }
  e.MsgSend = {
    typeUrl: "/cosmos.bank.v1beta1.MsgSend",
    encode(a, s = u.BinaryWriter.create()) {
      a.fromAddress !== "" && s.uint32(10).string(a.fromAddress), a.toAddress !== "" && s.uint32(18).string(a.toAddress);
      for (const i of a.amount)
        t.Coin.encode(i, s.uint32(26).fork()).ldelim();
      return s;
    },
    decode(a, s) {
      const i = a instanceof u.BinaryReader ? a : new u.BinaryReader(a);
      let b = s === void 0 ? i.len : i.pos + s;
      const l = y();
      for (; i.pos < b; ) {
        const k = i.uint32();
        switch (k >>> 3) {
          case 1:
            l.fromAddress = i.string();
            break;
          case 2:
            l.toAddress = i.string();
            break;
          case 3:
            l.amount.push(t.Coin.decode(i, i.uint32()));
            break;
          default:
            i.skipType(k & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(a) {
      const s = y();
      return (0, c.isSet)(a.fromAddress) && (s.fromAddress = String(a.fromAddress)), (0, c.isSet)(a.toAddress) && (s.toAddress = String(a.toAddress)), Array.isArray(a == null ? void 0 : a.amount) && (s.amount = a.amount.map((i) => t.Coin.fromJSON(i))), s;
    },
    toJSON(a) {
      const s = {};
      return a.fromAddress !== void 0 && (s.fromAddress = a.fromAddress), a.toAddress !== void 0 && (s.toAddress = a.toAddress), a.amount ? s.amount = a.amount.map((i) => i ? t.Coin.toJSON(i) : void 0) : s.amount = [], s;
    },
    fromPartial(a) {
      var i;
      const s = y();
      return s.fromAddress = a.fromAddress ?? "", s.toAddress = a.toAddress ?? "", s.amount = ((i = a.amount) == null ? void 0 : i.map((b) => t.Coin.fromPartial(b))) || [], s;
    }
  };
  function f() {
    return {};
  }
  e.MsgSendResponse = {
    typeUrl: "/cosmos.bank.v1beta1.MsgSendResponse",
    encode(a, s = u.BinaryWriter.create()) {
      return s;
    },
    decode(a, s) {
      const i = a instanceof u.BinaryReader ? a : new u.BinaryReader(a);
      let b = s === void 0 ? i.len : i.pos + s;
      const l = f();
      for (; i.pos < b; ) {
        const k = i.uint32();
        switch (k >>> 3) {
          default:
            i.skipType(k & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(a) {
      return f();
    },
    toJSON(a) {
      return {};
    },
    fromPartial(a) {
      return f();
    }
  };
  function p() {
    return {
      inputs: [],
      outputs: []
    };
  }
  e.MsgMultiSend = {
    typeUrl: "/cosmos.bank.v1beta1.MsgMultiSend",
    encode(a, s = u.BinaryWriter.create()) {
      for (const i of a.inputs)
        r.Input.encode(i, s.uint32(10).fork()).ldelim();
      for (const i of a.outputs)
        r.Output.encode(i, s.uint32(18).fork()).ldelim();
      return s;
    },
    decode(a, s) {
      const i = a instanceof u.BinaryReader ? a : new u.BinaryReader(a);
      let b = s === void 0 ? i.len : i.pos + s;
      const l = p();
      for (; i.pos < b; ) {
        const k = i.uint32();
        switch (k >>> 3) {
          case 1:
            l.inputs.push(r.Input.decode(i, i.uint32()));
            break;
          case 2:
            l.outputs.push(r.Output.decode(i, i.uint32()));
            break;
          default:
            i.skipType(k & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(a) {
      const s = p();
      return Array.isArray(a == null ? void 0 : a.inputs) && (s.inputs = a.inputs.map((i) => r.Input.fromJSON(i))), Array.isArray(a == null ? void 0 : a.outputs) && (s.outputs = a.outputs.map((i) => r.Output.fromJSON(i))), s;
    },
    toJSON(a) {
      const s = {};
      return a.inputs ? s.inputs = a.inputs.map((i) => i ? r.Input.toJSON(i) : void 0) : s.inputs = [], a.outputs ? s.outputs = a.outputs.map((i) => i ? r.Output.toJSON(i) : void 0) : s.outputs = [], s;
    },
    fromPartial(a) {
      var i, b;
      const s = p();
      return s.inputs = ((i = a.inputs) == null ? void 0 : i.map((l) => r.Input.fromPartial(l))) || [], s.outputs = ((b = a.outputs) == null ? void 0 : b.map((l) => r.Output.fromPartial(l))) || [], s;
    }
  };
  function m() {
    return {};
  }
  e.MsgMultiSendResponse = {
    typeUrl: "/cosmos.bank.v1beta1.MsgMultiSendResponse",
    encode(a, s = u.BinaryWriter.create()) {
      return s;
    },
    decode(a, s) {
      const i = a instanceof u.BinaryReader ? a : new u.BinaryReader(a);
      let b = s === void 0 ? i.len : i.pos + s;
      const l = m();
      for (; i.pos < b; ) {
        const k = i.uint32();
        switch (k >>> 3) {
          default:
            i.skipType(k & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(a) {
      return m();
    },
    toJSON(a) {
      return {};
    },
    fromPartial(a) {
      return m();
    }
  };
  function h() {
    return {
      authority: "",
      params: r.Params.fromPartial({})
    };
  }
  e.MsgUpdateParams = {
    typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParams",
    encode(a, s = u.BinaryWriter.create()) {
      return a.authority !== "" && s.uint32(10).string(a.authority), a.params !== void 0 && r.Params.encode(a.params, s.uint32(18).fork()).ldelim(), s;
    },
    decode(a, s) {
      const i = a instanceof u.BinaryReader ? a : new u.BinaryReader(a);
      let b = s === void 0 ? i.len : i.pos + s;
      const l = h();
      for (; i.pos < b; ) {
        const k = i.uint32();
        switch (k >>> 3) {
          case 1:
            l.authority = i.string();
            break;
          case 2:
            l.params = r.Params.decode(i, i.uint32());
            break;
          default:
            i.skipType(k & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(a) {
      const s = h();
      return (0, c.isSet)(a.authority) && (s.authority = String(a.authority)), (0, c.isSet)(a.params) && (s.params = r.Params.fromJSON(a.params)), s;
    },
    toJSON(a) {
      const s = {};
      return a.authority !== void 0 && (s.authority = a.authority), a.params !== void 0 && (s.params = a.params ? r.Params.toJSON(a.params) : void 0), s;
    },
    fromPartial(a) {
      const s = h();
      return s.authority = a.authority ?? "", a.params !== void 0 && a.params !== null && (s.params = r.Params.fromPartial(a.params)), s;
    }
  };
  function S() {
    return {};
  }
  e.MsgUpdateParamsResponse = {
    typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParamsResponse",
    encode(a, s = u.BinaryWriter.create()) {
      return s;
    },
    decode(a, s) {
      const i = a instanceof u.BinaryReader ? a : new u.BinaryReader(a);
      let b = s === void 0 ? i.len : i.pos + s;
      const l = S();
      for (; i.pos < b; ) {
        const k = i.uint32();
        switch (k >>> 3) {
          default:
            i.skipType(k & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(a) {
      return S();
    },
    toJSON(a) {
      return {};
    },
    fromPartial(a) {
      return S();
    }
  };
  function n() {
    return {
      authority: "",
      sendEnabled: [],
      useDefaultFor: []
    };
  }
  e.MsgSetSendEnabled = {
    typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabled",
    encode(a, s = u.BinaryWriter.create()) {
      a.authority !== "" && s.uint32(10).string(a.authority);
      for (const i of a.sendEnabled)
        r.SendEnabled.encode(i, s.uint32(18).fork()).ldelim();
      for (const i of a.useDefaultFor)
        s.uint32(26).string(i);
      return s;
    },
    decode(a, s) {
      const i = a instanceof u.BinaryReader ? a : new u.BinaryReader(a);
      let b = s === void 0 ? i.len : i.pos + s;
      const l = n();
      for (; i.pos < b; ) {
        const k = i.uint32();
        switch (k >>> 3) {
          case 1:
            l.authority = i.string();
            break;
          case 2:
            l.sendEnabled.push(r.SendEnabled.decode(i, i.uint32()));
            break;
          case 3:
            l.useDefaultFor.push(i.string());
            break;
          default:
            i.skipType(k & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(a) {
      const s = n();
      return (0, c.isSet)(a.authority) && (s.authority = String(a.authority)), Array.isArray(a == null ? void 0 : a.sendEnabled) && (s.sendEnabled = a.sendEnabled.map((i) => r.SendEnabled.fromJSON(i))), Array.isArray(a == null ? void 0 : a.useDefaultFor) && (s.useDefaultFor = a.useDefaultFor.map((i) => String(i))), s;
    },
    toJSON(a) {
      const s = {};
      return a.authority !== void 0 && (s.authority = a.authority), a.sendEnabled ? s.sendEnabled = a.sendEnabled.map((i) => i ? r.SendEnabled.toJSON(i) : void 0) : s.sendEnabled = [], a.useDefaultFor ? s.useDefaultFor = a.useDefaultFor.map((i) => i) : s.useDefaultFor = [], s;
    },
    fromPartial(a) {
      var i, b;
      const s = n();
      return s.authority = a.authority ?? "", s.sendEnabled = ((i = a.sendEnabled) == null ? void 0 : i.map((l) => r.SendEnabled.fromPartial(l))) || [], s.useDefaultFor = ((b = a.useDefaultFor) == null ? void 0 : b.map((l) => l)) || [], s;
    }
  };
  function o() {
    return {};
  }
  e.MsgSetSendEnabledResponse = {
    typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabledResponse",
    encode(a, s = u.BinaryWriter.create()) {
      return s;
    },
    decode(a, s) {
      const i = a instanceof u.BinaryReader ? a : new u.BinaryReader(a);
      let b = s === void 0 ? i.len : i.pos + s;
      const l = o();
      for (; i.pos < b; ) {
        const k = i.uint32();
        switch (k >>> 3) {
          default:
            i.skipType(k & 7);
            break;
        }
      }
      return l;
    },
    fromJSON(a) {
      return o();
    },
    toJSON(a) {
      return {};
    },
    fromPartial(a) {
      return o();
    }
  };
  class d {
    constructor(s) {
      this.rpc = s, this.Send = this.Send.bind(this), this.MultiSend = this.MultiSend.bind(this), this.UpdateParams = this.UpdateParams.bind(this), this.SetSendEnabled = this.SetSendEnabled.bind(this);
    }
    Send(s) {
      const i = e.MsgSend.encode(s).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Msg", "Send", i).then((l) => e.MsgSendResponse.decode(new u.BinaryReader(l)));
    }
    MultiSend(s) {
      const i = e.MsgMultiSend.encode(s).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Msg", "MultiSend", i).then((l) => e.MsgMultiSendResponse.decode(new u.BinaryReader(l)));
    }
    UpdateParams(s) {
      const i = e.MsgUpdateParams.encode(s).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Msg", "UpdateParams", i).then((l) => e.MsgUpdateParamsResponse.decode(new u.BinaryReader(l)));
    }
    SetSendEnabled(s) {
      const i = e.MsgSetSendEnabled.encode(s).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Msg", "SetSendEnabled", i).then((l) => e.MsgSetSendEnabledResponse.decode(new u.BinaryReader(l)));
    }
  }
  e.MsgClientImpl = d;
})(Me);
Object.defineProperty(P, "__esModule", { value: !0 });
P.Registry = P.isTxBodyEncodeObject = P.isPbjsGeneratedType = P.isTsProtoGeneratedType = P.isTelescopeGeneratedType = void 0;
const xe = Me, en = me, ie = fe, nn = pe;
function Ue(e) {
  const t = e;
  return typeof t.fromPartial == "function" && typeof t.typeUrl == "string";
}
P.isTelescopeGeneratedType = Ue;
function ke(e) {
  return typeof e.fromPartial == "function";
}
P.isTsProtoGeneratedType = ke;
function tn(e) {
  return !ke(e);
}
P.isPbjsGeneratedType = tn;
const we = {
  cosmosCoin: "/cosmos.base.v1beta1.Coin",
  cosmosMsgSend: "/cosmos.bank.v1beta1.MsgSend",
  cosmosTxBody: "/cosmos.tx.v1beta1.TxBody",
  googleAny: "/google.protobuf.Any"
};
function Re(e) {
  return e.typeUrl === "/cosmos.tx.v1beta1.TxBody";
}
P.isTxBodyEncodeObject = Re;
class rn {
  /**
   * Creates a new Registry for mapping protobuf type identifiers/type URLs to
   * actual implementations. Those implementations are typically generated with ts-proto
   * but we also support protobuf.js as a type generator.
   *
   * If there is no parameter given, a `new Registry()` adds the types `Coin` and `MsgSend`
   * for historic reasons. Those can be overriden by customTypes.
   *
   * There are currently two methods for adding new types:
   * 1. Passing types to the constructor.
   * 2. Using the `register()` method
   */
  constructor(t) {
    const { cosmosCoin: r, cosmosMsgSend: u } = we;
    this.types = t ? new Map([...t]) : /* @__PURE__ */ new Map([
      [r, en.Coin],
      [u, xe.MsgSend]
    ]);
  }
  register(t, r) {
    this.types.set(t, r);
  }
  /**
   * Looks up a type that was previously added to the registry.
   *
   * The generator information (ts-proto or pbjs) gets lost along the way.
   * If you need to work with the result type in TypeScript, you can use:
   *
   * ```
   * import { assert } from "@cosmjs/utils";
   *
   * const Coin = registry.lookupType("/cosmos.base.v1beta1.Coin");
   * assert(Coin); // Ensures not unset
   * assert(isTsProtoGeneratedType(Coin)); // Ensures this is the type we expect
   *
   * // Coin is typed TsProtoGeneratedType now.
   * ```
   */
  lookupType(t) {
    return this.types.get(t);
  }
  lookupTypeWithError(t) {
    const r = this.lookupType(t);
    if (!r)
      throw new Error(`Unregistered type url: ${t}`);
    return r;
  }
  /**
   * Takes a typeUrl/value pair and encodes the value to protobuf if
   * the given type was previously registered.
   *
   * If the value has to be wrapped in an Any, this needs to be done
   * manually after this call. Or use `encodeAsAny` instead.
   */
  encode(t) {
    const { value: r, typeUrl: u } = t;
    if (Re(t))
      return this.encodeTxBody(r);
    const c = this.lookupTypeWithError(u), y = Ue(c) || ke(c) ? c.fromPartial(r) : c.create(r);
    return c.encode(y).finish();
  }
  /**
   * Takes a typeUrl/value pair and encodes the value to an Any if
   * the given type was previously registered.
   */
  encodeAsAny(t) {
    const r = this.encode(t);
    return nn.Any.fromPartial({
      typeUrl: t.typeUrl,
      value: r
    });
  }
  encodeTxBody(t) {
    var c;
    const r = t.messages.map((y) => this.encodeAsAny(y)), u = ie.TxBody.fromPartial({
      ...t,
      timeoutHeight: BigInt(((c = t.timeoutHeight) == null ? void 0 : c.toString()) ?? "0"),
      messages: r
    });
    return ie.TxBody.encode(u).finish();
  }
  decode({ typeUrl: t, value: r }) {
    if (t === we.cosmosTxBody)
      return this.decodeTxBody(r);
    const c = this.lookupTypeWithError(t).decode(r);
    return Object.entries(c).forEach(([y, f]) => {
      typeof j.Buffer < "u" && typeof j.Buffer.isBuffer < "u" && j.Buffer.isBuffer(f) && (c[y] = Uint8Array.from(f));
    }), c;
  }
  decodeTxBody(t) {
    const r = ie.TxBody.decode(t);
    return {
      ...r,
      messages: r.messages.map(({ typeUrl: u, value: c }) => {
        if (!u)
          throw new Error("Missing type_url in Any");
        if (!c)
          throw new Error("Missing value in Any");
        return this.decode({ typeUrl: u, value: c });
      })
    };
  }
}
P.Registry = rn;
var Y = {};
Object.defineProperty(Y, "__esModule", { value: !0 });
Y.isOfflineDirectSigner = void 0;
function on(e) {
  return e.signDirect !== void 0;
}
Y.isOfflineDirectSigner = on;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.coins = e.coin = e.executeKdf = e.makeSignDoc = e.makeSignBytes = e.makeAuthInfoBytes = e.isOfflineDirectSigner = e.Registry = e.isTxBodyEncodeObject = e.isTsProtoGeneratedType = e.isPbjsGeneratedType = e.encodePubkey = e.decodePubkey = e.decodeOptionalPubkey = e.anyToSinglePubkey = e.makeCosmoshubPath = e.DirectSecp256k1Wallet = e.extractKdfConfiguration = e.DirectSecp256k1HdWallet = e.decodeTxRaw = e.parseCoins = void 0;
  var t = V;
  Object.defineProperty(e, "parseCoins", { enumerable: !0, get: function() {
    return t.parseCoins;
  } });
  var r = X;
  Object.defineProperty(e, "decodeTxRaw", { enumerable: !0, get: function() {
    return r.decodeTxRaw;
  } });
  var u = T;
  Object.defineProperty(e, "DirectSecp256k1HdWallet", { enumerable: !0, get: function() {
    return u.DirectSecp256k1HdWallet;
  } }), Object.defineProperty(e, "extractKdfConfiguration", { enumerable: !0, get: function() {
    return u.extractKdfConfiguration;
  } });
  var c = Z;
  Object.defineProperty(e, "DirectSecp256k1Wallet", { enumerable: !0, get: function() {
    return c.DirectSecp256k1Wallet;
  } });
  var y = Q;
  Object.defineProperty(e, "makeCosmoshubPath", { enumerable: !0, get: function() {
    return y.makeCosmoshubPath;
  } });
  var f = B;
  Object.defineProperty(e, "anyToSinglePubkey", { enumerable: !0, get: function() {
    return f.anyToSinglePubkey;
  } }), Object.defineProperty(e, "decodeOptionalPubkey", { enumerable: !0, get: function() {
    return f.decodeOptionalPubkey;
  } }), Object.defineProperty(e, "decodePubkey", { enumerable: !0, get: function() {
    return f.decodePubkey;
  } }), Object.defineProperty(e, "encodePubkey", { enumerable: !0, get: function() {
    return f.encodePubkey;
  } });
  var p = P;
  Object.defineProperty(e, "isPbjsGeneratedType", { enumerable: !0, get: function() {
    return p.isPbjsGeneratedType;
  } }), Object.defineProperty(e, "isTsProtoGeneratedType", { enumerable: !0, get: function() {
    return p.isTsProtoGeneratedType;
  } }), Object.defineProperty(e, "isTxBodyEncodeObject", { enumerable: !0, get: function() {
    return p.isTxBodyEncodeObject;
  } }), Object.defineProperty(e, "Registry", { enumerable: !0, get: function() {
    return p.Registry;
  } });
  var m = Y;
  Object.defineProperty(e, "isOfflineDirectSigner", { enumerable: !0, get: function() {
    return m.isOfflineDirectSigner;
  } });
  var h = w;
  Object.defineProperty(e, "makeAuthInfoBytes", { enumerable: !0, get: function() {
    return h.makeAuthInfoBytes;
  } }), Object.defineProperty(e, "makeSignBytes", { enumerable: !0, get: function() {
    return h.makeSignBytes;
  } }), Object.defineProperty(e, "makeSignDoc", { enumerable: !0, get: function() {
    return h.makeSignDoc;
  } });
  var S = be;
  Object.defineProperty(e, "executeKdf", { enumerable: !0, get: function() {
    return S.executeKdf;
  } });
  var n = H;
  Object.defineProperty(e, "coin", { enumerable: !0, get: function() {
    return n.coin;
  } }), Object.defineProperty(e, "coins", { enumerable: !0, get: function() {
    return n.coins;
  } });
})(ve);
const un = /* @__PURE__ */ Ke({
  __proto__: null
}, [ve]);
export {
  _e as a,
  ve as b,
  un as i,
  Me as t
};
