/// <reference types="node" />

import type { Account as Account_2 } from '@cosmjs/stargate';
import type { AminoTypes } from '@cosmjs/stargate';
import type { Asset } from '@coinmasters/types';
import { AssetValue } from '@coinmasters/helpers';
import { ChainId } from '@coinmasters/types';
import type { CosmosChain } from '@coinmasters/types';
import type { curve } from 'elliptic';
import type { FeeOption } from '@coinmasters/types';
import { MultisigThresholdPubkey } from '@cosmjs/amino';
import type { OfflineDirectSigner } from '@cosmjs/proto-signing';
import type { OfflineSigner } from '@cosmjs/proto-signing';
import type { Pubkey } from '@cosmjs/amino';
import type { Registry } from '@cosmjs/proto-signing';
import { RPCUrl } from '@coinmasters/types';
import type { Secp256k1HdWallet } from '@cosmjs/amino';
import { SigningStargateClient } from '@cosmjs/stargate';
import { SigningStargateClientOptions } from '@cosmjs/stargate';
import { StargateClient } from '@cosmjs/stargate';
import type { StdFee } from '@cosmjs/amino';
import type { SwapKitNumber } from '@coinmasters/helpers';

/**
 * Account
 * @see https://docs.binance.org/api-reference/dex-api/paths.html#account
 */
export declare type Account = {
    /**
     * Account number
     */
    account_number: number;
    /**
     * Address of the account
     */
    address: string;
    /**
     * List of balances
     */
    balances: Balance[];
    /**
     * Public key bytes
     */
    public_key: number[];
    /**
     * indicate additional check for this account
     */
    flags: number;
    /**
     * sequence is for preventing replay attack
     */
    sequence: number;
};

export declare enum AminoPrefix {
    MsgSend = "2A2C87FA",
    StdTx = "F0625DEE"
}

/**
 * Balance
 * @see https://docs.binance.org/api-reference/dex-api/paths.html#balance
 */
export declare type Balance = {
    /**
     * asset symbol, e.g. BNB
     */
    symbol: string;
    /**
     * In decimal form, e.g. 0.00000000
     */
    free: string;
    /**
     * In decimal form, e.g. 0.00000000
     */
    locked: string;
    /**
     * In decimal form, e.g. 0.00000000
     */
    frozen: string;
};

export declare const base64ToBech32: (address: string, prefix?: string) => string;

export declare type BaseCosmosToolboxType = {
    getAccount: (address: string) => Promise<Account_2 | null>;
    getSigner: (phrase: string) => Promise<OfflineDirectSigner>;
    getSignerFromPrivateKey: (privateKey: Uint8Array) => Promise<OfflineDirectSigner>;
    validateAddress: (address: string) => Promise<boolean>;
    getAddressFromMnemonic: (phrase: string) => Promise<string>;
    getPubKeyFromMnemonic: (phrase: string) => Promise<string>;
    getBalance: (pubkeys: any[], potentialScamFilter?: boolean) => Promise<AssetValue[]>;
    transfer: (params: TransferParams) => Promise<string>;
    getFeeRateFromThorswap?: (chainId: ChainId) => Promise<number | undefined>;
};

export declare abstract class BaseMsg {
    abstract getSignMsg(): {};
    abstract getMsg(): {};
    static defaultMsg(): object;
}

export declare const bech32ToBase64: (address: string) => string;

export declare const BinanceToolbox: ({ stagenet }?: ToolboxParams) => BinanceToolboxType;

export declare type BinanceToolboxType = Omit<BaseCosmosToolboxType, 'getAccount'> & {
    getFees: () => Promise<Fees>;
    createKeyPair: (phrase: string) => Promise<Uint8Array>;
    transfer: (params: TransferParams) => Promise<string>;
    getAccount: (address: string) => Promise<Account>;
    sendRawTransaction: (signedBz: string, sync: boolean) => Promise<any>;
    createTransactionAndSignMsg: (params: TransferParams) => Promise<{
        transaction: BNBTransaction;
        signMsg: {
            inputs: {
                address: string;
                coins: {
                    amount: number;
                    denom: string;
                }[];
            }[];
            outputs: {
                address: string;
                coins: {
                    amount: number;
                    denom: string;
                }[];
            }[];
        };
    }>;
    getPublicKey: (publicKey: string) => curve.base.BasePoint;
};

export declare type BNBFees = (Fee | TransferFee | DexFees)[];

/**
 * Creates a new transaction object.
 * @example
 * var rawTx = {
 *   accountNumber: 1,
 *   chainId: 'bnbchain-1000',
 *   memo: '',
 *   msg: {},
 *   type: 'NewOrderMsg',
 *   sequence: 29,
 *   source: 0
 * };
 * var tx = new Transaction(rawTx);
 * @property {Buffer} raw The raw vstruct encoded transaction
 * @param {Number} data.account_number account number
 * @param {String} data.chain_id bnbChain Id
 * @param {String} data.memo transaction memo
 * @param {String} type transaction type
 * @param {Msg} data.msg object data of tx type
 * @param {Number} data.sequence transaction counts
 * @param {Number} data.source where does this transaction come from
 */
declare class BNBTransaction {
    sequence: NonNullable<StdSignMsg['sequence']>;
    accountNumber: NonNullable<StdSignMsg['accountNumber']>;
    chainId: StdSignMsg['chainId'];
    msg?: any;
    baseMsg?: NonNullable<BaseMsg>;
    memo: StdSignMsg['memo'];
    source: NonNullable<StdSignMsg['source']>;
    signatures: StdSignature[];
    constructor(data: StdSignMsg);
    /**
     * generate the sign bytes for a transaction, given a msg
     * @param {SignMsg} concrete msg object
     * @return {Buffer}
     **/
    getSignBytes(msg?: {}): Buffer;
    /**
     * attaches a signature to the transaction
     * @param {Elliptic.PublicKey} pubKey
     * @param {Buffer} signature
     * @return {Transaction}
     **/
    addSignature(pubKey: curve.base.BasePoint, signature: Buffer): this;
    /**
     * sign transaction with a given private key and msg
     * @param {string} privateKey private key hex string
     * @param {SignMsg} concrete msg object
     * @return {Transaction}
     **/
    sign: (privateKey: string, msg?: {}) => Promise<this>;
    /**
     * encode signed transaction to hex which is compatible with amino
     */
    serialize(): string;
    /**
     * serializes a public key in a 33-byte compressed format.
     * @param {Elliptic.PublicKey} unencodedPubKey
     * @return {Buffer}
     */
    _serializePubKey(unencodedPubKey: curve.base.BasePoint): Buffer;
}

export declare const buildDepositTx: ({ signer, memo, assetValue, isStagenet, }: {
    isStagenet?: boolean | undefined;
    signer: string;
    memo?: string | undefined;
    assetValue: AssetValue;
}) => Promise<{
    memo: string;
    accountNumber: number;
    chainId: ChainId;
    fee: {
        amount: never[];
        gas: string;
    };
    sequence: number;
    msgs: {
        typeUrl: string;
        value: {
            coins: {
                amount: string;
                asset: string;
            }[];
            signer: string;
            memo: string;
        };
    }[];
}>;

export declare const buildTransferTx: ({ fromAddress, toAddress, assetValue, memo, isStagenet, }: {
    isStagenet?: boolean | undefined;
    fromAddress: string;
    toAddress: string;
    assetValue: AssetValue;
    memo?: string | undefined;
}) => Promise<{
    memo: string;
    accountNumber: number;
    sequence: number;
    chainId: ChainId;
    msgs: {
        typeUrl: string;
        value: {
            fromAddress: string;
            toAddress: string;
            amount: {
                amount: string;
                denom: string;
            }[];
        };
    }[];
    fee: {
        amount: never[];
        gas: string;
    };
}>;

export declare const checkBalances: (balances: AssetValue[], fees: Record<FeeOption, AssetValue>, assetValue: AssetValue) => Promise<void>;

export declare type CosmosLikeToolbox = GaiaToolboxType | BinanceToolboxType | ThorchainToolboxType | MayaToolboxType | KujiraToolboxType;

export declare type CosmosMaxSendableAmountParams = {
    toolbox: CosmosLikeToolbox;
    from: string;
    asset?: AssetValue | string;
    feeOptionKey?: FeeOption;
};

export declare type CosmosSDKClientParams = {
    server: string;
    chainId: ChainId;
    prefix?: string;
    stagenet?: boolean;
};

export declare const createOfflineStargateClient: (wallet: OfflineSigner, registry?: SigningStargateClientOptions) => Promise<SigningStargateClient>;

export declare const createSigningStargateClient: (url: string, signer: any, options?: SigningStargateClientOptions) => Promise<SigningStargateClient>;

export declare const createStargateClient: (url: string) => Promise<StargateClient>;

export declare const DEFAULT_COSMOS_FEE_MAINNET: {
    amount: {
        denom: string;
        amount: string;
    }[];
    gas: string;
};

export declare const DEFAULT_GAS_VALUE = "5000000000";

export declare type DepositParam = {
    signer?: OfflineDirectSigner;
    walletIndex?: number;
    assetValue: AssetValue;
    memo: string;
};

export declare type DexFee = {
    fee_name: DexFeeName;
    fee_value: number;
};

export declare type DexFeeName = 'ExpireFee' | 'ExpireFeeNative' | 'CancelFee' | 'CancelFeeNative' | 'FeeRate' | 'FeeRateNative' | 'IOCExpireFee' | 'IOCExpireFeeNative';

export declare type DexFees = {
    dex_fee_fields: DexFee[];
};

export declare const estimateMaxSendableAmount: ({ from, toolbox, asset, feeOptionKey, }: CosmosMaxSendableAmountParams) => Promise<AssetValue>;

export declare type Fee = {
    msg_type: FeeType;
    fee: number;
    fee_for: number;
};

declare type Fees = {
    average: SwapKitNumber;
    fast: SwapKitNumber;
    fastest: SwapKitNumber;
};

export declare type FeeType = 'submit_proposal' | 'deposit' | 'vote' | 'create_validator' | 'remove_validator' | 'dexList' | 'orderNew' | 'orderCancel' | 'issueMsg' | 'mintMsg' | 'tokensBurn' | 'tokensFreeze' | 'send' | 'timeLock' | 'timeUnlock' | 'timeRelock' | 'setAccountFlags' | 'HTLT' | 'depositHTLT' | 'claimHTLT' | 'refundHTLT';

export declare const GaiaToolbox: ({ server }?: {
    server?: string | undefined;
}) => GaiaToolboxType;

export declare type GaiaToolboxType = BaseCosmosToolboxType & {
    getFees: () => Promise<Fees>;
};

export declare const getDenom: (symbol: string, isThorchain?: boolean) => string;

export declare const getDenomWithChain: ({ symbol }: AssetValue) => string;

export declare const getRPC: (chainId: ChainId, stagenet?: boolean) => RPCUrl.Binance | RPCUrl.Cosmos | RPCUrl.Kujira | RPCUrl.Maya | RPCUrl.MayaStagenet | RPCUrl.Osmosis | RPCUrl.THORChain | RPCUrl.THORChainStagenet;

export declare const getToolboxByChain: (chain: CosmosChain) => Promise<(({ stagenet }?: {
    stagenet?: boolean | undefined;
}) => BinanceToolboxType) | (({ server }?: {
    server?: string | undefined;
}) => GaiaToolboxType) | (({ stagenet, }?: {
    stagenet?: boolean | undefined;
}) => ThorchainToolboxType) | undefined>;

/**
 * Type guard for runtime checks of `Fee`
 *
 * @param {Fee|TransferFee|DexFees} v
 * @returns {boolean} `true` or `false`.
 */
export declare const isFee: (v: Fee | TransferFee | DexFees) => v is Fee;

/**
 * Type guard for `TransferFee`
 *
 * @param {Fee|TransferFee|DexFees} v
 * @returns {boolean} `true` or `false`.
 */
export declare const isTransferFee: (v: Fee | TransferFee | DexFees) => v is TransferFee;

export declare const KujiraToolbox: ({ server }?: {
    server?: string | undefined;
}) => KujiraToolboxType;

export declare type KujiraToolboxType = BaseCosmosToolboxType & {
    getFees: () => Promise<Fees>;
};

export declare const MayaToolbox: ({ stagenet }?: {
    stagenet?: boolean | undefined;
}) => MayaToolboxType;

export declare type MayaToolboxType = ThorchainToolboxType;

export { MultisigThresholdPubkey }

/**
 * Response of `/cosmos/base/tendermint/v1beta1/node_info`
 * Note: We are interested in `network` (aka chain id) only
 */
export declare type NodeInfoResponse = {
    default_node_info: {
        network: string;
    };
};

export declare type NodeUrl = {
    node: string;
    rpc: string;
};

export declare const OsmosisToolbox: () => any;

export declare type Signer = {
    pubKey: string;
    signature: string;
};

export declare const sortObject: (obj: any) => any;

export declare interface StdSignature {
    pub_key?: Buffer;
    signature: Buffer;
    account_number: number;
    sequence: number;
}

export declare interface StdSignMsg {
    chainId: string;
    accountNumber: number;
    sequence: number;
    baseMsg?: BaseMsg;
    msg?: {};
    memo: string;
    source: number;
    data?: Buffer | null | string;
}

export declare interface StdTx {
    msg: {}[];
    signatures: StdSignature[];
    memo: string;
    source: number;
    data?: Buffer | null | string;
    aminoPrefix: AminoPrefix;
}

/**
 * Response from `thorchain/constants` endpoint
 */
export declare type ThorchainConstantsResponse = {
    int_64_values: {
        NativeTransactionFee: number;
    };
};

export declare const ThorchainToolbox: ({ stagenet, }?: {
    stagenet?: boolean | undefined;
}) => ThorchainToolboxType;

export declare type ThorchainToolboxType = BaseCosmosToolboxType & {
    getFees: () => Promise<Fees>;
    deposit: (params: DepositParam & {
        from: string;
    }) => Promise<string>;
    createDefaultRegistry: () => Promise<Registry>;
    createDefaultAminoTypes: () => Promise<AminoTypes>;
    createDepositMessage: (assetValue: AssetValue, address: string, memo?: string, forBroadcasting?: boolean) => any;
    createMultisig: (pubKeys: string[], threshold: number) => Promise<MultisigThresholdPubkey>;
    importSignature: (signature: string) => Uint8Array;
    secp256k1HdWalletFromMnemonic: (mnemonic: string, index?: number) => Promise<Secp256k1HdWallet>;
    signMultisigTx: (wallet: Secp256k1HdWallet, tx: string) => Promise<{
        signature: string;
        bodyBytes: Uint8Array;
    }>;
    broadcastMultisigTx: (tx: string, signers: Signer[], threshold: number, bodyBytes: Uint8Array, isStagenet?: boolean) => Promise<string>;
    pubkeyToAddress: (pubkey: Pubkey, prefix: string) => Promise<string>;
    loadAddressBalances: (address: string) => Promise<AssetValue[]>;
};

declare type ToolboxParams = {
    stagenet?: boolean;
};

export declare type TransferFee = {
    fixed_fee_params: Fee;
    multi_transfer_fee: number;
    lower_limit_as_multi: number;
};

export declare type TransferParams = {
    privkey?: Uint8Array;
    signer?: OfflineDirectSigner;
    from: string;
    recipient: string;
    assetValue: AssetValue;
    memo?: string;
    fee?: StdFee;
    feeOptionKey?: FeeOption;
};

/**
 * Tx
 * @see https://docs.binance.org/api-reference/dex-api/paths.html#tx
 */
export declare type Tx = {
    /**
     * block height
     */
    blockHeight: number;
    /**
     * transaction result code
     */
    code: number;
    /**
     * _no offical description_
     */
    confirmBlocks: number;
    /**
     * _no offical description_
     */
    data: string | null;
    /**
     * From address
     */
    fromAddr: string;
    /**
     * Order ID
     */
    orderId: string | null;
    /**
     * Time of transaction
     */
    timeStamp: string;
    /**
     * To address
     */
    toAddr: string;
    /**
     * _no offical description_
     */
    txAge: number;
    /**
     * _no offical description_
     */
    txAsset: string;
    /**
     * _no offical description_
     */
    txFee: string;
    /**
     * hash of transaction
     */
    txHash: string;
    /**
     * Type of transaction
     */
    txType: TxType;
    /**
     * memo
     */
    memo: string;
    /**
     * Value of transaction
     */
    value: string;
    /**
     * _no offical description_
     */
    source: number;
    /**
     * _no offical description_
     */
    sequence: number;
    /**
     * Optional. Available when the transaction type is one of HTL_TRANSFER, CLAIM_HTL, REFUND_HTL, DEPOSIT_HTL
     */
    swapId?: string;
    /**
     * _no offical description_
     */
    proposalId: string | null;
};

declare type Tx_2 = {
    asset: Asset;
    from: {
        from: string;
    }[];
    to: {
        to: string;
    }[];
    date: Date;
    type: TxType_2;
    hash: string;
};

export declare type TxData = Pick<Tx_2, 'from' | 'to' | 'type'>;

/**
 * Type of transactions
 * @see https://docs.binance.org/api-reference/dex-api/paths.html#apiv1transactions
 */
export declare type TxType = 'NEW_ORDER' | 'ISSUE_TOKEN' | 'BURN_TOKEN' | 'LIST_TOKEN' | 'CANCEL_ORDER' | 'FREEZE_TOKEN' | 'UN_FREEZE_TOKEN' | 'TRANSFER' | 'PROPOSAL' | 'VOTE' | 'MINT' | 'DEPOSIT' | 'CREATE_VALIDATOR' | 'REMOVE_VALIDATOR' | 'TIME_LOCK' | 'TIME_UNLOCK' | 'TIME_RELOCK' | 'SET_ACCOUNT_FLAG' | 'HTL_TRANSFER' | 'CLAIM_HTL' | 'DEPOSIT_HTL' | 'REFUND_HTL';

declare enum TxType_2 {
    Transfer = "transfer",
    Unknown = "unknown"
}

export { }
