import { q as G, o as c, g as N, n as Z, u as k } from "./index-dd5ccbe6.js";
function F(e, r) {
  for (var t = 0; t < r.length; t++) {
    const o = r[t];
    if (typeof o != "string" && !Array.isArray(o)) {
      for (const s in o)
        if (s !== "default" && !(s in e)) {
          const f = Object.getOwnPropertyDescriptor(o, s);
          f && Object.defineProperty(e, s, f.get ? f : {
            enumerable: !0,
            get: () => o[s]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
const d = G(), K = c.Buffer.alloc(1, 1), I = c.Buffer.alloc(1, 0);
function U(e, r, t, o, s) {
  let f = c.Buffer.alloc(32, 0), n = c.Buffer.alloc(32, 1);
  f = d("sha256", f).update(n).update(I).update(r).update(e).update(s || "").digest(), n = d("sha256", f).update(n).digest(), f = d("sha256", f).update(n).update(K).update(r).update(e).update(s || "").digest(), n = d("sha256", f).update(n).digest(), n = d("sha256", f).update(n).digest();
  let a = n;
  for (; !o(a) || !t(a); )
    f = d("sha256", f).update(n).update(I).digest(), n = d("sha256", f).update(n).digest(), n = d("sha256", f).update(n).digest(), a = n;
  return a;
}
var $ = U;
const M = k, Q = Z().ec, S = new Q("secp256k1"), z = $, B = c.Buffer.alloc(32, 0), A = c.Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", "hex"), D = c.Buffer.from("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f", "hex"), u = S.curve.n, H = u.shrn(1), R = S.curve.g, b = "Expected Private", m = "Expected Point", v = "Expected Tweak", j = "Expected Hash", L = "Expected Signature", V = "Expected Extra Data (32 bytes)";
function T(e) {
  return c.Buffer.isBuffer(e) && e.length === 32;
}
function P(e) {
  return T(e) ? e.compare(A) < 0 : !1;
}
function l(e) {
  if (!c.Buffer.isBuffer(e) || e.length < 33)
    return !1;
  const r = e[0], t = e.slice(1, 33);
  if (t.compare(B) === 0 || t.compare(D) >= 0)
    return !1;
  if ((r === 2 || r === 3) && e.length === 33) {
    try {
      E(e);
    } catch {
      return !1;
    }
    return !0;
  }
  const o = e.slice(33);
  return o.compare(B) === 0 || o.compare(D) >= 0 ? !1 : r === 4 && e.length === 65;
}
function C(e) {
  return e[0] !== 4;
}
function X(e) {
  return l(e) ? C(e) : !1;
}
function p(e) {
  return T(e) ? e.compare(B) > 0 && // > 0
  e.compare(A) < 0 : !1;
}
function J(e) {
  const r = e.slice(0, 32), t = e.slice(32, 64);
  return c.Buffer.isBuffer(e) && e.length === 64 && r.compare(A) < 0 && t.compare(A) < 0;
}
function g(e, r) {
  return e === void 0 && r !== void 0 ? C(r) : e === void 0 ? !0 : e;
}
function i(e) {
  return new M(e);
}
function O(e) {
  return e.toArrayLike(c.Buffer, "be", 32);
}
function E(e) {
  return S.curve.decodePoint(e);
}
function w(e, r) {
  return c.Buffer.from(e._encode(r));
}
function Y(e, r, t) {
  if (!l(e))
    throw new TypeError(m);
  if (!l(r))
    throw new TypeError(m);
  const o = E(e), s = E(r), f = o.add(s);
  if (f.isInfinity())
    return null;
  const n = g(t, e);
  return w(f, n);
}
function ee(e, r, t) {
  if (!l(e))
    throw new TypeError(m);
  if (!P(r))
    throw new TypeError(v);
  const o = g(t, e), s = E(e);
  if (r.compare(B) === 0)
    return w(s, o);
  const f = i(r), n = R.mul(f), a = s.add(n);
  return a.isInfinity() ? null : w(a, o);
}
function re(e, r) {
  if (!l(e))
    throw new TypeError(m);
  const t = E(e);
  if (t.isInfinity())
    throw new TypeError(m);
  const o = g(r, e);
  return w(t, o);
}
function te(e, r) {
  if (!p(e))
    throw new TypeError(b);
  const t = i(e), o = R.mul(t);
  if (o.isInfinity())
    return null;
  const s = g(r);
  return w(o, s);
}
function ne(e, r, t) {
  if (!l(e))
    throw new TypeError(m);
  if (!P(r))
    throw new TypeError(v);
  const o = g(t, e), s = E(e), f = i(r), n = s.mul(f);
  return n.isInfinity() ? null : w(n, o);
}
function fe(e, r) {
  if (!p(e))
    throw new TypeError(b);
  if (!P(r))
    throw new TypeError(v);
  const t = i(e), o = i(r), s = O(t.add(o).umod(u));
  return p(s) ? s : null;
}
function oe(e, r) {
  if (!p(e))
    throw new TypeError(b);
  if (!P(r))
    throw new TypeError(v);
  const t = i(e), o = i(r), s = O(t.sub(o).umod(u));
  return p(s) ? s : null;
}
function se(e, r) {
  return W(e, r);
}
function ie(e, r, t) {
  return W(e, r, t);
}
function W(e, r, t) {
  if (!T(e))
    throw new TypeError(j);
  if (!p(r))
    throw new TypeError(b);
  if (t !== void 0 && !T(t))
    throw new TypeError(V);
  const o = i(r), s = i(e);
  let f, n;
  z(e, r, function(x) {
    const _ = i(x), h = R.mul(_);
    return !(h.isInfinity() || (f = h.x.umod(u), f.isZero() === 0) || (n = _.invm(u).mul(s.add(o.mul(f))).umod(u), n.isZero() === 0));
  }, p, t), n.cmp(H) > 0 && (n = u.sub(n));
  const y = c.Buffer.allocUnsafe(64);
  return O(f).copy(y, 0), O(n).copy(y, 32), y;
}
function ce(e, r, t, o) {
  if (!T(e))
    throw new TypeError(j);
  if (!l(r))
    throw new TypeError(m);
  if (!J(t))
    throw new TypeError(L);
  const s = E(r), f = i(t.slice(0, 32)), n = i(t.slice(32, 64));
  if (o && n.cmp(H) > 0 || f.gtn(0) <= 0 || n.gtn(0) <= 0)
    return !1;
  const a = i(e), y = n.invm(u), x = a.mul(y).umod(u), _ = f.mul(y).umod(u), h = R.mulAdd(x, s, _);
  return h.isInfinity() ? !1 : h.x.umod(u).eq(f);
}
var q = {
  isPoint: l,
  isPointCompressed: X,
  isPrivate: p,
  pointAdd: Y,
  pointAddScalar: ee,
  pointCompress: re,
  pointFromScalar: te,
  pointMultiply: ne,
  privateAdd: fe,
  privateSub: oe,
  sign: se,
  signWithEntropy: ie,
  verify: ce
};
const ue = /* @__PURE__ */ N(q), pe = /* @__PURE__ */ F({
  __proto__: null,
  default: ue
}, [q]);
export {
  pe as j
};
