"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseTransactionParser = void 0;
const caip_1 = require("@shapeshiftoss/caip");
const bignumber_js_1 = require("bignumber.js");
const ethers_1 = require("ethers");
const types_1 = require("../../types");
const utils_1 = require("../../utils");
const erc20 = __importStar(require("./erc20"));
__exportStar(require("./types"), exports);
__exportStar(require("./utils"), exports);
class BaseTransactionParser {
    constructor(args) {
        this.parsers = [];
        this.chainId = args.chainId;
        this.provider = new ethers_1.ethers.providers.JsonRpcProvider(args.rpcUrl);
        this.registerParser(new erc20.Parser({ chainId: this.chainId, provider: this.provider }));
    }
    /**
     * Register custom transaction sub parser to extract contract specific data
     *
     * _parsers should be registered from most generic first to most specific last_
     */
    registerParser(parser) {
        this.parsers.unshift(parser);
    }
    registerParsers(parsers) {
        parsers.forEach((parser) => this.registerParser(parser));
    }
    async parse(tx, address) {
        var _a;
        address = ethers_1.ethers.utils.getAddress(address);
        // We expect only one Parser to return a result. If multiple do, we take the first and early exit.
        const contractParserResult = await (0, utils_1.findAsyncSequential)(this.parsers, async (parser) => await parser.parse(tx));
        const parsedTx = {
            address,
            blockHash: tx.blockHash,
            blockHeight: tx.blockHeight,
            blockTime: tx.timestamp,
            chainId: this.chainId,
            confirmations: tx.confirmations,
            status: this.getStatus(tx),
            trade: contractParserResult === null || contractParserResult === void 0 ? void 0 : contractParserResult.trade,
            transfers: (_a = contractParserResult === null || contractParserResult === void 0 ? void 0 : contractParserResult.transfers) !== null && _a !== void 0 ? _a : [],
            txid: tx.txid,
            data: contractParserResult === null || contractParserResult === void 0 ? void 0 : contractParserResult.data,
        };
        return this.getParsedTxWithTransfers(tx, parsedTx, address);
    }
    getStatus(tx) {
        const status = tx.status;
        if (status === -1 && tx.confirmations <= 0)
            return types_1.TxStatus.Pending;
        if (status === 1 && tx.confirmations > 0)
            return types_1.TxStatus.Confirmed;
        if (status === 0)
            return types_1.TxStatus.Failed;
        return types_1.TxStatus.Unknown;
    }
    getParsedTxWithTransfers(tx, parsedTx, address) {
        var _a, _b;
        if (address === tx.from) {
            // send amount
            const sendValue = new bignumber_js_1.BigNumber(tx.value);
            if (sendValue.gt(0)) {
                parsedTx.transfers = (0, utils_1.aggregateTransfer)(parsedTx.transfers, types_1.TransferType.Send, this.assetId, tx.from, tx.to, sendValue.toString(10));
            }
            // network fee
            const fees = new bignumber_js_1.BigNumber(tx.fee);
            if (fees.gt(0)) {
                parsedTx.fee = { assetId: this.assetId, value: fees.toString(10) };
            }
        }
        if (address === tx.to) {
            // receive amount
            const receiveValue = new bignumber_js_1.BigNumber(tx.value);
            if (receiveValue.gt(0)) {
                parsedTx.transfers = (0, utils_1.aggregateTransfer)(parsedTx.transfers, types_1.TransferType.Receive, this.assetId, tx.from, tx.to, receiveValue.toString(10));
            }
        }
        (_a = tx.tokenTransfers) === null || _a === void 0 ? void 0 : _a.forEach((transfer) => {
            // FTX Token (FTT) name and symbol was set backwards on the ERC20 contract (Ethereum Mainnet)
            if (this.chainId === caip_1.ethChainId &&
                transfer.contract === '0x50D1c9771902476076eCFc8B2A83Ad6b9355a4c9') {
                transfer.name = transfer.symbol;
                transfer.symbol = transfer.name;
            }
            const token = {
                contract: transfer.contract,
                decimals: transfer.decimals,
                name: transfer.name,
                symbol: transfer.symbol,
            };
            const transferArgs = [
                (0, caip_1.toAssetId)({
                    chainId: this.chainId,
                    assetNamespace: 'erc20',
                    assetReference: transfer.contract,
                }),
                transfer.from,
                transfer.to,
                transfer.value,
                token,
            ];
            // token send amount
            if (address === transfer.from) {
                parsedTx.transfers = (0, utils_1.aggregateTransfer)(parsedTx.transfers, types_1.TransferType.Send, ...transferArgs);
            }
            // token receive amount
            if (address === transfer.to) {
                parsedTx.transfers = (0, utils_1.aggregateTransfer)(parsedTx.transfers, types_1.TransferType.Receive, ...transferArgs);
            }
        });
        (_b = tx.internalTxs) === null || _b === void 0 ? void 0 : _b.forEach((internalTx) => {
            const transferArgs = [this.assetId, internalTx.from, internalTx.to, internalTx.value];
            // internal eth send
            if (address === internalTx.from) {
                parsedTx.transfers = (0, utils_1.aggregateTransfer)(parsedTx.transfers, types_1.TransferType.Send, ...transferArgs);
            }
            // internal eth receive
            if (address === internalTx.to) {
                parsedTx.transfers = (0, utils_1.aggregateTransfer)(parsedTx.transfers, types_1.TransferType.Receive, ...transferArgs);
            }
        });
        return parsedTx;
    }
}
exports.BaseTransactionParser = BaseTransactionParser;
