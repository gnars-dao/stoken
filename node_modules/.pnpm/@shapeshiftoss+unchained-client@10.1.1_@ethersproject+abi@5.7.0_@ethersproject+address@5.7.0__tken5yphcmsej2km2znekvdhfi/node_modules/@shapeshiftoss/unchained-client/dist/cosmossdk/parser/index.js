"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseTransactionParser = void 0;
const caip_1 = require("@shapeshiftoss/caip");
const logger_1 = require("@shapeshiftoss/logger");
const bignumber_js_1 = require("bignumber.js");
const types_1 = require("../../types");
const utils_1 = require("../../utils");
const utils_2 = require("./utils");
__exportStar(require("./types"), exports);
const logger = new logger_1.Logger({
    namespace: ['unchained-client', 'cosmossdk', 'parser'],
    level: process.env.LOG_LEVEL,
});
const assetIdByDenom = new Map([
    ['uatom', caip_1.cosmosAssetId],
    ['uosmo', caip_1.osmosisAssetId],
    ['rune', caip_1.thorchainAssetId],
]);
class BaseTransactionParser {
    constructor(args) {
        this.chainId = args.chainId;
    }
    async parse(tx, address) {
        var _a, _b;
        const parsedTx = {
            address,
            blockHash: tx.blockHash,
            blockHeight: (_a = tx.blockHeight) !== null && _a !== void 0 ? _a : -1,
            blockTime: (_b = tx.timestamp) !== null && _b !== void 0 ? _b : Math.floor(Date.now() / 1000),
            chainId: this.chainId,
            confirmations: tx.confirmations,
            status: tx.confirmations > 0 ? types_1.TxStatus.Confirmed : types_1.TxStatus.Pending,
            transfers: [],
            txid: tx.txid,
        };
        parsedTx.data = (0, utils_2.metaData)(tx.messages[0], this.assetId);
        tx.messages.forEach(({ from = '', to = '', value, origin }) => {
            var _a;
            const amount = new bignumber_js_1.BigNumber((_a = value === null || value === void 0 ? void 0 : value.amount) !== null && _a !== void 0 ? _a : 0);
            const assetId = (() => {
                if (!(value === null || value === void 0 ? void 0 : value.denom))
                    return this.assetId;
                if (assetIdByDenom.has(value.denom))
                    return assetIdByDenom.get(value.denom);
                const [assetNamespace, assetReference] = value.denom.split('/');
                if (assetNamespace === 'ibc' && assetReference) {
                    return (0, caip_1.toAssetId)({ chainId: this.chainId, assetNamespace, assetReference });
                }
                logger.warn(`unknown denom: ${value.denom}, defaulting to: ${this.assetId}`);
                return this.assetId;
            })();
            if (from === address && amount.gt(0)) {
                parsedTx.transfers = (0, utils_1.aggregateTransfer)(parsedTx.transfers, types_1.TransferType.Send, assetId, from, to, amount.toString(10));
            }
            if (to === address && amount.gt(0)) {
                parsedTx.transfers = (0, utils_1.aggregateTransfer)(parsedTx.transfers, types_1.TransferType.Receive, assetId, from, to, amount.toString(10));
            }
            // We use origin for fees because some txs have a different from and origin addresses
            if (origin === address) {
                // network fee
                const fees = new bignumber_js_1.BigNumber(tx.fee.amount);
                if (fees.gt(0)) {
                    parsedTx.fee = { assetId: this.assetId, value: fees.toString(10) };
                }
            }
        });
        return parsedTx;
    }
}
exports.BaseTransactionParser = BaseTransactionParser;
