"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserContractSet = exports.ContractExpirationSet = exports.ContractSet = exports.Contract = exports.Provider = exports.contractAuthorizationToJSON = exports.contractAuthorizationFromJSON = exports.ContractAuthorization = exports.contractTypeToJSON = exports.contractTypeFromJSON = exports.ContractType = exports.providerStatusToJSON = exports.providerStatusFromJSON = exports.ProviderStatus = exports.protobufPackage = void 0;
/* eslint-disable */
var long_1 = __importDefault(require("long"));
var minimal_1 = __importDefault(require("protobufjs/minimal"));
var coin_1 = require("../../cosmos/base/v1beta1/coin");
exports.protobufPackage = "arkeo.arkeo";
var ProviderStatus;
(function (ProviderStatus) {
    ProviderStatus[ProviderStatus["OFFLINE"] = 0] = "OFFLINE";
    ProviderStatus[ProviderStatus["ONLINE"] = 1] = "ONLINE";
    ProviderStatus[ProviderStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ProviderStatus = exports.ProviderStatus || (exports.ProviderStatus = {}));
function providerStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "OFFLINE":
            return ProviderStatus.OFFLINE;
        case 1:
        case "ONLINE":
            return ProviderStatus.ONLINE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ProviderStatus.UNRECOGNIZED;
    }
}
exports.providerStatusFromJSON = providerStatusFromJSON;
function providerStatusToJSON(object) {
    switch (object) {
        case ProviderStatus.OFFLINE:
            return "OFFLINE";
        case ProviderStatus.ONLINE:
            return "ONLINE";
        case ProviderStatus.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.providerStatusToJSON = providerStatusToJSON;
var ContractType;
(function (ContractType) {
    ContractType[ContractType["SUBSCRIPTION"] = 0] = "SUBSCRIPTION";
    ContractType[ContractType["PAY_AS_YOU_GO"] = 1] = "PAY_AS_YOU_GO";
    ContractType[ContractType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ContractType = exports.ContractType || (exports.ContractType = {}));
function contractTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "SUBSCRIPTION":
            return ContractType.SUBSCRIPTION;
        case 1:
        case "PAY_AS_YOU_GO":
            return ContractType.PAY_AS_YOU_GO;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ContractType.UNRECOGNIZED;
    }
}
exports.contractTypeFromJSON = contractTypeFromJSON;
function contractTypeToJSON(object) {
    switch (object) {
        case ContractType.SUBSCRIPTION:
            return "SUBSCRIPTION";
        case ContractType.PAY_AS_YOU_GO:
            return "PAY_AS_YOU_GO";
        case ContractType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.contractTypeToJSON = contractTypeToJSON;
var ContractAuthorization;
(function (ContractAuthorization) {
    ContractAuthorization[ContractAuthorization["STRICT"] = 0] = "STRICT";
    ContractAuthorization[ContractAuthorization["OPEN"] = 1] = "OPEN";
    ContractAuthorization[ContractAuthorization["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ContractAuthorization = exports.ContractAuthorization || (exports.ContractAuthorization = {}));
function contractAuthorizationFromJSON(object) {
    switch (object) {
        case 0:
        case "STRICT":
            return ContractAuthorization.STRICT;
        case 1:
        case "OPEN":
            return ContractAuthorization.OPEN;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ContractAuthorization.UNRECOGNIZED;
    }
}
exports.contractAuthorizationFromJSON = contractAuthorizationFromJSON;
function contractAuthorizationToJSON(object) {
    switch (object) {
        case ContractAuthorization.STRICT:
            return "STRICT";
        case ContractAuthorization.OPEN:
            return "OPEN";
        case ContractAuthorization.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.contractAuthorizationToJSON = contractAuthorizationToJSON;
function createBaseProvider() {
    return {
        pubKey: new Uint8Array(),
        service: 0,
        metadataUri: "",
        metadataNonce: 0,
        status: 0,
        minContractDuration: 0,
        maxContractDuration: 0,
        subscriptionRate: [],
        payAsYouGoRate: [],
        bond: "",
        lastUpdate: 0,
        settlementDuration: 0,
    };
}
exports.Provider = {
    encode: function (message, writer) {
        var e_1, _a, e_2, _b;
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.pubKey.length !== 0) {
            writer.uint32(10).bytes(message.pubKey);
        }
        if (message.service !== 0) {
            writer.uint32(16).int32(message.service);
        }
        if (message.metadataUri !== "") {
            writer.uint32(26).string(message.metadataUri);
        }
        if (message.metadataNonce !== 0) {
            writer.uint32(32).uint64(message.metadataNonce);
        }
        if (message.status !== 0) {
            writer.uint32(40).int32(message.status);
        }
        if (message.minContractDuration !== 0) {
            writer.uint32(48).int64(message.minContractDuration);
        }
        if (message.maxContractDuration !== 0) {
            writer.uint32(56).int64(message.maxContractDuration);
        }
        try {
            for (var _c = __values(message.subscriptionRate), _d = _c.next(); !_d.done; _d = _c.next()) {
                var v = _d.value;
                coin_1.Coin.encode(v, writer.uint32(66).fork()).ldelim();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            for (var _e = __values(message.payAsYouGoRate), _f = _e.next(); !_f.done; _f = _e.next()) {
                var v = _f.value;
                coin_1.Coin.encode(v, writer.uint32(74).fork()).ldelim();
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_2) throw e_2.error; }
        }
        if (message.bond !== "") {
            writer.uint32(82).string(message.bond);
        }
        if (message.lastUpdate !== 0) {
            writer.uint32(88).int64(message.lastUpdate);
        }
        if (message.settlementDuration !== 0) {
            writer.uint32(96).int64(message.settlementDuration);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseProvider();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pubKey = reader.bytes();
                    break;
                case 2:
                    message.service = reader.int32();
                    break;
                case 3:
                    message.metadataUri = reader.string();
                    break;
                case 4:
                    message.metadataNonce = longToNumber(reader.uint64());
                    break;
                case 5:
                    message.status = reader.int32();
                    break;
                case 6:
                    message.minContractDuration = longToNumber(reader.int64());
                    break;
                case 7:
                    message.maxContractDuration = longToNumber(reader.int64());
                    break;
                case 8:
                    message.subscriptionRate.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.payAsYouGoRate.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 10:
                    message.bond = reader.string();
                    break;
                case 11:
                    message.lastUpdate = longToNumber(reader.int64());
                    break;
                case 12:
                    message.settlementDuration = longToNumber(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            pubKey: isSet(object.pubKey) ? bytesFromBase64(object.pubKey) : new Uint8Array(),
            service: isSet(object.service) ? Number(object.service) : 0,
            metadataUri: isSet(object.metadataUri) ? String(object.metadataUri) : "",
            metadataNonce: isSet(object.metadataNonce) ? Number(object.metadataNonce) : 0,
            status: isSet(object.status) ? providerStatusFromJSON(object.status) : 0,
            minContractDuration: isSet(object.minContractDuration) ? Number(object.minContractDuration) : 0,
            maxContractDuration: isSet(object.maxContractDuration) ? Number(object.maxContractDuration) : 0,
            subscriptionRate: Array.isArray(object === null || object === void 0 ? void 0 : object.subscriptionRate)
                ? object.subscriptionRate.map(function (e) { return coin_1.Coin.fromJSON(e); })
                : [],
            payAsYouGoRate: Array.isArray(object === null || object === void 0 ? void 0 : object.payAsYouGoRate)
                ? object.payAsYouGoRate.map(function (e) { return coin_1.Coin.fromJSON(e); })
                : [],
            bond: isSet(object.bond) ? String(object.bond) : "",
            lastUpdate: isSet(object.lastUpdate) ? Number(object.lastUpdate) : 0,
            settlementDuration: isSet(object.settlementDuration) ? Number(object.settlementDuration) : 0,
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.pubKey !== undefined
            && (obj.pubKey = base64FromBytes(message.pubKey !== undefined ? message.pubKey : new Uint8Array()));
        message.service !== undefined && (obj.service = Math.round(message.service));
        message.metadataUri !== undefined && (obj.metadataUri = message.metadataUri);
        message.metadataNonce !== undefined && (obj.metadataNonce = Math.round(message.metadataNonce));
        message.status !== undefined && (obj.status = providerStatusToJSON(message.status));
        message.minContractDuration !== undefined && (obj.minContractDuration = Math.round(message.minContractDuration));
        message.maxContractDuration !== undefined && (obj.maxContractDuration = Math.round(message.maxContractDuration));
        if (message.subscriptionRate) {
            obj.subscriptionRate = message.subscriptionRate.map(function (e) { return e ? coin_1.Coin.toJSON(e) : undefined; });
        }
        else {
            obj.subscriptionRate = [];
        }
        if (message.payAsYouGoRate) {
            obj.payAsYouGoRate = message.payAsYouGoRate.map(function (e) { return e ? coin_1.Coin.toJSON(e) : undefined; });
        }
        else {
            obj.payAsYouGoRate = [];
        }
        message.bond !== undefined && (obj.bond = message.bond);
        message.lastUpdate !== undefined && (obj.lastUpdate = Math.round(message.lastUpdate));
        message.settlementDuration !== undefined && (obj.settlementDuration = Math.round(message.settlementDuration));
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        var message = createBaseProvider();
        message.pubKey = (_a = object.pubKey) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.service = (_b = object.service) !== null && _b !== void 0 ? _b : 0;
        message.metadataUri = (_c = object.metadataUri) !== null && _c !== void 0 ? _c : "";
        message.metadataNonce = (_d = object.metadataNonce) !== null && _d !== void 0 ? _d : 0;
        message.status = (_e = object.status) !== null && _e !== void 0 ? _e : 0;
        message.minContractDuration = (_f = object.minContractDuration) !== null && _f !== void 0 ? _f : 0;
        message.maxContractDuration = (_g = object.maxContractDuration) !== null && _g !== void 0 ? _g : 0;
        message.subscriptionRate = ((_h = object.subscriptionRate) === null || _h === void 0 ? void 0 : _h.map(function (e) { return coin_1.Coin.fromPartial(e); })) || [];
        message.payAsYouGoRate = ((_j = object.payAsYouGoRate) === null || _j === void 0 ? void 0 : _j.map(function (e) { return coin_1.Coin.fromPartial(e); })) || [];
        message.bond = (_k = object.bond) !== null && _k !== void 0 ? _k : "";
        message.lastUpdate = (_l = object.lastUpdate) !== null && _l !== void 0 ? _l : 0;
        message.settlementDuration = (_m = object.settlementDuration) !== null && _m !== void 0 ? _m : 0;
        return message;
    },
};
function createBaseContract() {
    return {
        provider: new Uint8Array(),
        service: 0,
        client: new Uint8Array(),
        delegate: new Uint8Array(),
        type: 0,
        height: 0,
        duration: 0,
        rate: undefined,
        deposit: "",
        paid: "",
        nonce: 0,
        settlementHeight: 0,
        id: 0,
        settlementDuration: 0,
        authorization: 0,
    };
}
exports.Contract = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.provider.length !== 0) {
            writer.uint32(10).bytes(message.provider);
        }
        if (message.service !== 0) {
            writer.uint32(16).int32(message.service);
        }
        if (message.client.length !== 0) {
            writer.uint32(26).bytes(message.client);
        }
        if (message.delegate.length !== 0) {
            writer.uint32(34).bytes(message.delegate);
        }
        if (message.type !== 0) {
            writer.uint32(40).int32(message.type);
        }
        if (message.height !== 0) {
            writer.uint32(48).int64(message.height);
        }
        if (message.duration !== 0) {
            writer.uint32(56).int64(message.duration);
        }
        if (message.rate !== undefined) {
            coin_1.Coin.encode(message.rate, writer.uint32(66).fork()).ldelim();
        }
        if (message.deposit !== "") {
            writer.uint32(74).string(message.deposit);
        }
        if (message.paid !== "") {
            writer.uint32(82).string(message.paid);
        }
        if (message.nonce !== 0) {
            writer.uint32(88).int64(message.nonce);
        }
        if (message.settlementHeight !== 0) {
            writer.uint32(96).int64(message.settlementHeight);
        }
        if (message.id !== 0) {
            writer.uint32(104).uint64(message.id);
        }
        if (message.settlementDuration !== 0) {
            writer.uint32(112).int64(message.settlementDuration);
        }
        if (message.authorization !== 0) {
            writer.uint32(120).int32(message.authorization);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseContract();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.provider = reader.bytes();
                    break;
                case 2:
                    message.service = reader.int32();
                    break;
                case 3:
                    message.client = reader.bytes();
                    break;
                case 4:
                    message.delegate = reader.bytes();
                    break;
                case 5:
                    message.type = reader.int32();
                    break;
                case 6:
                    message.height = longToNumber(reader.int64());
                    break;
                case 7:
                    message.duration = longToNumber(reader.int64());
                    break;
                case 8:
                    message.rate = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.deposit = reader.string();
                    break;
                case 10:
                    message.paid = reader.string();
                    break;
                case 11:
                    message.nonce = longToNumber(reader.int64());
                    break;
                case 12:
                    message.settlementHeight = longToNumber(reader.int64());
                    break;
                case 13:
                    message.id = longToNumber(reader.uint64());
                    break;
                case 14:
                    message.settlementDuration = longToNumber(reader.int64());
                    break;
                case 15:
                    message.authorization = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            provider: isSet(object.provider) ? bytesFromBase64(object.provider) : new Uint8Array(),
            service: isSet(object.service) ? Number(object.service) : 0,
            client: isSet(object.client) ? bytesFromBase64(object.client) : new Uint8Array(),
            delegate: isSet(object.delegate) ? bytesFromBase64(object.delegate) : new Uint8Array(),
            type: isSet(object.type) ? contractTypeFromJSON(object.type) : 0,
            height: isSet(object.height) ? Number(object.height) : 0,
            duration: isSet(object.duration) ? Number(object.duration) : 0,
            rate: isSet(object.rate) ? coin_1.Coin.fromJSON(object.rate) : undefined,
            deposit: isSet(object.deposit) ? String(object.deposit) : "",
            paid: isSet(object.paid) ? String(object.paid) : "",
            nonce: isSet(object.nonce) ? Number(object.nonce) : 0,
            settlementHeight: isSet(object.settlementHeight) ? Number(object.settlementHeight) : 0,
            id: isSet(object.id) ? Number(object.id) : 0,
            settlementDuration: isSet(object.settlementDuration) ? Number(object.settlementDuration) : 0,
            authorization: isSet(object.authorization) ? contractAuthorizationFromJSON(object.authorization) : 0,
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.provider !== undefined
            && (obj.provider = base64FromBytes(message.provider !== undefined ? message.provider : new Uint8Array()));
        message.service !== undefined && (obj.service = Math.round(message.service));
        message.client !== undefined
            && (obj.client = base64FromBytes(message.client !== undefined ? message.client : new Uint8Array()));
        message.delegate !== undefined
            && (obj.delegate = base64FromBytes(message.delegate !== undefined ? message.delegate : new Uint8Array()));
        message.type !== undefined && (obj.type = contractTypeToJSON(message.type));
        message.height !== undefined && (obj.height = Math.round(message.height));
        message.duration !== undefined && (obj.duration = Math.round(message.duration));
        message.rate !== undefined && (obj.rate = message.rate ? coin_1.Coin.toJSON(message.rate) : undefined);
        message.deposit !== undefined && (obj.deposit = message.deposit);
        message.paid !== undefined && (obj.paid = message.paid);
        message.nonce !== undefined && (obj.nonce = Math.round(message.nonce));
        message.settlementHeight !== undefined && (obj.settlementHeight = Math.round(message.settlementHeight));
        message.id !== undefined && (obj.id = Math.round(message.id));
        message.settlementDuration !== undefined && (obj.settlementDuration = Math.round(message.settlementDuration));
        message.authorization !== undefined && (obj.authorization = contractAuthorizationToJSON(message.authorization));
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        var message = createBaseContract();
        message.provider = (_a = object.provider) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.service = (_b = object.service) !== null && _b !== void 0 ? _b : 0;
        message.client = (_c = object.client) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.delegate = (_d = object.delegate) !== null && _d !== void 0 ? _d : new Uint8Array();
        message.type = (_e = object.type) !== null && _e !== void 0 ? _e : 0;
        message.height = (_f = object.height) !== null && _f !== void 0 ? _f : 0;
        message.duration = (_g = object.duration) !== null && _g !== void 0 ? _g : 0;
        message.rate = (object.rate !== undefined && object.rate !== null) ? coin_1.Coin.fromPartial(object.rate) : undefined;
        message.deposit = (_h = object.deposit) !== null && _h !== void 0 ? _h : "";
        message.paid = (_j = object.paid) !== null && _j !== void 0 ? _j : "";
        message.nonce = (_k = object.nonce) !== null && _k !== void 0 ? _k : 0;
        message.settlementHeight = (_l = object.settlementHeight) !== null && _l !== void 0 ? _l : 0;
        message.id = (_m = object.id) !== null && _m !== void 0 ? _m : 0;
        message.settlementDuration = (_o = object.settlementDuration) !== null && _o !== void 0 ? _o : 0;
        message.authorization = (_p = object.authorization) !== null && _p !== void 0 ? _p : 0;
        return message;
    },
};
function createBaseContractSet() {
    return { contractIds: [] };
}
exports.ContractSet = {
    encode: function (message, writer) {
        var e_3, _a;
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        writer.uint32(10).fork();
        try {
            for (var _b = __values(message.contractIds), _c = _b.next(); !_c.done; _c = _b.next()) {
                var v = _c.value;
                writer.uint64(v);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        writer.ldelim();
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseContractSet();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.contractIds.push(longToNumber(reader.uint64()));
                        }
                    }
                    else {
                        message.contractIds.push(longToNumber(reader.uint64()));
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return { contractIds: Array.isArray(object === null || object === void 0 ? void 0 : object.contractIds) ? object.contractIds.map(function (e) { return Number(e); }) : [] };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.contractIds) {
            obj.contractIds = message.contractIds.map(function (e) { return Math.round(e); });
        }
        else {
            obj.contractIds = [];
        }
        return obj;
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseContractSet();
        message.contractIds = ((_a = object.contractIds) === null || _a === void 0 ? void 0 : _a.map(function (e) { return e; })) || [];
        return message;
    },
};
function createBaseContractExpirationSet() {
    return { height: 0, contractSet: undefined };
}
exports.ContractExpirationSet = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.height !== 0) {
            writer.uint32(8).int64(message.height);
        }
        if (message.contractSet !== undefined) {
            exports.ContractSet.encode(message.contractSet, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseContractExpirationSet();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.height = longToNumber(reader.int64());
                    break;
                case 2:
                    message.contractSet = exports.ContractSet.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            height: isSet(object.height) ? Number(object.height) : 0,
            contractSet: isSet(object.contractSet) ? exports.ContractSet.fromJSON(object.contractSet) : undefined,
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.height !== undefined && (obj.height = Math.round(message.height));
        message.contractSet !== undefined
            && (obj.contractSet = message.contractSet ? exports.ContractSet.toJSON(message.contractSet) : undefined);
        return obj;
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseContractExpirationSet();
        message.height = (_a = object.height) !== null && _a !== void 0 ? _a : 0;
        message.contractSet = (object.contractSet !== undefined && object.contractSet !== null)
            ? exports.ContractSet.fromPartial(object.contractSet)
            : undefined;
        return message;
    },
};
function createBaseUserContractSet() {
    return { user: new Uint8Array(), contractSet: undefined };
}
exports.UserContractSet = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.user.length !== 0) {
            writer.uint32(10).bytes(message.user);
        }
        if (message.contractSet !== undefined) {
            exports.ContractSet.encode(message.contractSet, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseUserContractSet();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.user = reader.bytes();
                    break;
                case 2:
                    message.contractSet = exports.ContractSet.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            user: isSet(object.user) ? bytesFromBase64(object.user) : new Uint8Array(),
            contractSet: isSet(object.contractSet) ? exports.ContractSet.fromJSON(object.contractSet) : undefined,
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.user !== undefined
            && (obj.user = base64FromBytes(message.user !== undefined ? message.user : new Uint8Array()));
        message.contractSet !== undefined
            && (obj.contractSet = message.contractSet ? exports.ContractSet.toJSON(message.contractSet) : undefined);
        return obj;
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseUserContractSet();
        message.user = (_a = object.user) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.contractSet = (object.contractSet !== undefined && object.contractSet !== null)
            ? exports.ContractSet.fromPartial(object.contractSet)
            : undefined;
        return message;
    },
};
var globalThis = (function () {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        var bin = globalThis.atob(b64);
        var arr = new Uint8Array(bin.length);
        for (var i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        var bin_1 = [];
        arr.forEach(function (byte) {
            bin_1.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin_1.join(""));
    }
}
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
