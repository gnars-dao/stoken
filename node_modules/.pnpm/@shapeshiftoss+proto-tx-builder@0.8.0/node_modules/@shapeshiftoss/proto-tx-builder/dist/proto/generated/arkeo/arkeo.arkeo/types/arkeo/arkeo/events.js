"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidatorPayoutEvent = exports.EventCloseContract = exports.EventSettleContract = exports.EventOpenContract = exports.EventModProvider = exports.EventBondProvider = exports.protobufPackage = void 0;
/* eslint-disable */
var long_1 = __importDefault(require("long"));
var minimal_1 = __importDefault(require("protobufjs/minimal"));
var coin_1 = require("../../cosmos/base/v1beta1/coin");
var keeper_1 = require("./keeper");
exports.protobufPackage = "arkeo.arkeo";
function createBaseEventBondProvider() {
    return { provider: new Uint8Array(), service: "", bondRel: "", bondAbs: "" };
}
exports.EventBondProvider = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.provider.length !== 0) {
            writer.uint32(10).bytes(message.provider);
        }
        if (message.service !== "") {
            writer.uint32(18).string(message.service);
        }
        if (message.bondRel !== "") {
            writer.uint32(26).string(message.bondRel);
        }
        if (message.bondAbs !== "") {
            writer.uint32(34).string(message.bondAbs);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventBondProvider();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.provider = reader.bytes();
                    break;
                case 2:
                    message.service = reader.string();
                    break;
                case 3:
                    message.bondRel = reader.string();
                    break;
                case 4:
                    message.bondAbs = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            provider: isSet(object.provider) ? bytesFromBase64(object.provider) : new Uint8Array(),
            service: isSet(object.service) ? String(object.service) : "",
            bondRel: isSet(object.bondRel) ? String(object.bondRel) : "",
            bondAbs: isSet(object.bondAbs) ? String(object.bondAbs) : "",
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.provider !== undefined
            && (obj.provider = base64FromBytes(message.provider !== undefined ? message.provider : new Uint8Array()));
        message.service !== undefined && (obj.service = message.service);
        message.bondRel !== undefined && (obj.bondRel = message.bondRel);
        message.bondAbs !== undefined && (obj.bondAbs = message.bondAbs);
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d;
        var message = createBaseEventBondProvider();
        message.provider = (_a = object.provider) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.service = (_b = object.service) !== null && _b !== void 0 ? _b : "";
        message.bondRel = (_c = object.bondRel) !== null && _c !== void 0 ? _c : "";
        message.bondAbs = (_d = object.bondAbs) !== null && _d !== void 0 ? _d : "";
        return message;
    },
};
function createBaseEventModProvider() {
    return {
        creator: new Uint8Array(),
        provider: new Uint8Array(),
        service: "",
        metadataURI: "",
        metadataNonce: 0,
        status: 0,
        minContractDuration: 0,
        maxContractDuration: 0,
        subscriptionRate: [],
        payAsYouGoRate: [],
        bond: "",
        settlementDuration: 0,
    };
}
exports.EventModProvider = {
    encode: function (message, writer) {
        var e_1, _a, e_2, _b;
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.creator.length !== 0) {
            writer.uint32(10).bytes(message.creator);
        }
        if (message.provider.length !== 0) {
            writer.uint32(18).bytes(message.provider);
        }
        if (message.service !== "") {
            writer.uint32(26).string(message.service);
        }
        if (message.metadataURI !== "") {
            writer.uint32(34).string(message.metadataURI);
        }
        if (message.metadataNonce !== 0) {
            writer.uint32(40).uint64(message.metadataNonce);
        }
        if (message.status !== 0) {
            writer.uint32(48).int32(message.status);
        }
        if (message.minContractDuration !== 0) {
            writer.uint32(56).int64(message.minContractDuration);
        }
        if (message.maxContractDuration !== 0) {
            writer.uint32(64).int64(message.maxContractDuration);
        }
        try {
            for (var _c = __values(message.subscriptionRate), _d = _c.next(); !_d.done; _d = _c.next()) {
                var v = _d.value;
                coin_1.Coin.encode(v, writer.uint32(74).fork()).ldelim();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            for (var _e = __values(message.payAsYouGoRate), _f = _e.next(); !_f.done; _f = _e.next()) {
                var v = _f.value;
                coin_1.Coin.encode(v, writer.uint32(82).fork()).ldelim();
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_2) throw e_2.error; }
        }
        if (message.bond !== "") {
            writer.uint32(90).string(message.bond);
        }
        if (message.settlementDuration !== 0) {
            writer.uint32(96).int64(message.settlementDuration);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventModProvider();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.creator = reader.bytes();
                    break;
                case 2:
                    message.provider = reader.bytes();
                    break;
                case 3:
                    message.service = reader.string();
                    break;
                case 4:
                    message.metadataURI = reader.string();
                    break;
                case 5:
                    message.metadataNonce = longToNumber(reader.uint64());
                    break;
                case 6:
                    message.status = reader.int32();
                    break;
                case 7:
                    message.minContractDuration = longToNumber(reader.int64());
                    break;
                case 8:
                    message.maxContractDuration = longToNumber(reader.int64());
                    break;
                case 9:
                    message.subscriptionRate.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 10:
                    message.payAsYouGoRate.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                case 11:
                    message.bond = reader.string();
                    break;
                case 12:
                    message.settlementDuration = longToNumber(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            creator: isSet(object.creator) ? bytesFromBase64(object.creator) : new Uint8Array(),
            provider: isSet(object.provider) ? bytesFromBase64(object.provider) : new Uint8Array(),
            service: isSet(object.service) ? String(object.service) : "",
            metadataURI: isSet(object.metadataURI) ? String(object.metadataURI) : "",
            metadataNonce: isSet(object.metadataNonce) ? Number(object.metadataNonce) : 0,
            status: isSet(object.status) ? (0, keeper_1.providerStatusFromJSON)(object.status) : 0,
            minContractDuration: isSet(object.minContractDuration) ? Number(object.minContractDuration) : 0,
            maxContractDuration: isSet(object.maxContractDuration) ? Number(object.maxContractDuration) : 0,
            subscriptionRate: Array.isArray(object === null || object === void 0 ? void 0 : object.subscriptionRate)
                ? object.subscriptionRate.map(function (e) { return coin_1.Coin.fromJSON(e); })
                : [],
            payAsYouGoRate: Array.isArray(object === null || object === void 0 ? void 0 : object.payAsYouGoRate)
                ? object.payAsYouGoRate.map(function (e) { return coin_1.Coin.fromJSON(e); })
                : [],
            bond: isSet(object.bond) ? String(object.bond) : "",
            settlementDuration: isSet(object.settlementDuration) ? Number(object.settlementDuration) : 0,
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.creator !== undefined
            && (obj.creator = base64FromBytes(message.creator !== undefined ? message.creator : new Uint8Array()));
        message.provider !== undefined
            && (obj.provider = base64FromBytes(message.provider !== undefined ? message.provider : new Uint8Array()));
        message.service !== undefined && (obj.service = message.service);
        message.metadataURI !== undefined && (obj.metadataURI = message.metadataURI);
        message.metadataNonce !== undefined && (obj.metadataNonce = Math.round(message.metadataNonce));
        message.status !== undefined && (obj.status = (0, keeper_1.providerStatusToJSON)(message.status));
        message.minContractDuration !== undefined && (obj.minContractDuration = Math.round(message.minContractDuration));
        message.maxContractDuration !== undefined && (obj.maxContractDuration = Math.round(message.maxContractDuration));
        if (message.subscriptionRate) {
            obj.subscriptionRate = message.subscriptionRate.map(function (e) { return e ? coin_1.Coin.toJSON(e) : undefined; });
        }
        else {
            obj.subscriptionRate = [];
        }
        if (message.payAsYouGoRate) {
            obj.payAsYouGoRate = message.payAsYouGoRate.map(function (e) { return e ? coin_1.Coin.toJSON(e) : undefined; });
        }
        else {
            obj.payAsYouGoRate = [];
        }
        message.bond !== undefined && (obj.bond = message.bond);
        message.settlementDuration !== undefined && (obj.settlementDuration = Math.round(message.settlementDuration));
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        var message = createBaseEventModProvider();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.provider = (_b = object.provider) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.service = (_c = object.service) !== null && _c !== void 0 ? _c : "";
        message.metadataURI = (_d = object.metadataURI) !== null && _d !== void 0 ? _d : "";
        message.metadataNonce = (_e = object.metadataNonce) !== null && _e !== void 0 ? _e : 0;
        message.status = (_f = object.status) !== null && _f !== void 0 ? _f : 0;
        message.minContractDuration = (_g = object.minContractDuration) !== null && _g !== void 0 ? _g : 0;
        message.maxContractDuration = (_h = object.maxContractDuration) !== null && _h !== void 0 ? _h : 0;
        message.subscriptionRate = ((_j = object.subscriptionRate) === null || _j === void 0 ? void 0 : _j.map(function (e) { return coin_1.Coin.fromPartial(e); })) || [];
        message.payAsYouGoRate = ((_k = object.payAsYouGoRate) === null || _k === void 0 ? void 0 : _k.map(function (e) { return coin_1.Coin.fromPartial(e); })) || [];
        message.bond = (_l = object.bond) !== null && _l !== void 0 ? _l : "";
        message.settlementDuration = (_m = object.settlementDuration) !== null && _m !== void 0 ? _m : 0;
        return message;
    },
};
function createBaseEventOpenContract() {
    return {
        provider: new Uint8Array(),
        contractId: 0,
        service: "",
        client: new Uint8Array(),
        delegate: new Uint8Array(),
        type: 0,
        height: 0,
        duration: 0,
        rate: undefined,
        openCost: 0,
        deposit: "",
        settlementDuration: 0,
        authorization: 0,
    };
}
exports.EventOpenContract = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.provider.length !== 0) {
            writer.uint32(10).bytes(message.provider);
        }
        if (message.contractId !== 0) {
            writer.uint32(16).uint64(message.contractId);
        }
        if (message.service !== "") {
            writer.uint32(26).string(message.service);
        }
        if (message.client.length !== 0) {
            writer.uint32(34).bytes(message.client);
        }
        if (message.delegate.length !== 0) {
            writer.uint32(42).bytes(message.delegate);
        }
        if (message.type !== 0) {
            writer.uint32(48).int32(message.type);
        }
        if (message.height !== 0) {
            writer.uint32(56).int64(message.height);
        }
        if (message.duration !== 0) {
            writer.uint32(64).int64(message.duration);
        }
        if (message.rate !== undefined) {
            coin_1.Coin.encode(message.rate, writer.uint32(74).fork()).ldelim();
        }
        if (message.openCost !== 0) {
            writer.uint32(80).int64(message.openCost);
        }
        if (message.deposit !== "") {
            writer.uint32(90).string(message.deposit);
        }
        if (message.settlementDuration !== 0) {
            writer.uint32(96).int64(message.settlementDuration);
        }
        if (message.authorization !== 0) {
            writer.uint32(104).int32(message.authorization);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventOpenContract();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.provider = reader.bytes();
                    break;
                case 2:
                    message.contractId = longToNumber(reader.uint64());
                    break;
                case 3:
                    message.service = reader.string();
                    break;
                case 4:
                    message.client = reader.bytes();
                    break;
                case 5:
                    message.delegate = reader.bytes();
                    break;
                case 6:
                    message.type = reader.int32();
                    break;
                case 7:
                    message.height = longToNumber(reader.int64());
                    break;
                case 8:
                    message.duration = longToNumber(reader.int64());
                    break;
                case 9:
                    message.rate = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.openCost = longToNumber(reader.int64());
                    break;
                case 11:
                    message.deposit = reader.string();
                    break;
                case 12:
                    message.settlementDuration = longToNumber(reader.int64());
                    break;
                case 13:
                    message.authorization = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            provider: isSet(object.provider) ? bytesFromBase64(object.provider) : new Uint8Array(),
            contractId: isSet(object.contractId) ? Number(object.contractId) : 0,
            service: isSet(object.service) ? String(object.service) : "",
            client: isSet(object.client) ? bytesFromBase64(object.client) : new Uint8Array(),
            delegate: isSet(object.delegate) ? bytesFromBase64(object.delegate) : new Uint8Array(),
            type: isSet(object.type) ? (0, keeper_1.contractTypeFromJSON)(object.type) : 0,
            height: isSet(object.height) ? Number(object.height) : 0,
            duration: isSet(object.duration) ? Number(object.duration) : 0,
            rate: isSet(object.rate) ? coin_1.Coin.fromJSON(object.rate) : undefined,
            openCost: isSet(object.openCost) ? Number(object.openCost) : 0,
            deposit: isSet(object.deposit) ? String(object.deposit) : "",
            settlementDuration: isSet(object.settlementDuration) ? Number(object.settlementDuration) : 0,
            authorization: isSet(object.authorization) ? (0, keeper_1.contractAuthorizationFromJSON)(object.authorization) : 0,
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.provider !== undefined
            && (obj.provider = base64FromBytes(message.provider !== undefined ? message.provider : new Uint8Array()));
        message.contractId !== undefined && (obj.contractId = Math.round(message.contractId));
        message.service !== undefined && (obj.service = message.service);
        message.client !== undefined
            && (obj.client = base64FromBytes(message.client !== undefined ? message.client : new Uint8Array()));
        message.delegate !== undefined
            && (obj.delegate = base64FromBytes(message.delegate !== undefined ? message.delegate : new Uint8Array()));
        message.type !== undefined && (obj.type = (0, keeper_1.contractTypeToJSON)(message.type));
        message.height !== undefined && (obj.height = Math.round(message.height));
        message.duration !== undefined && (obj.duration = Math.round(message.duration));
        message.rate !== undefined && (obj.rate = message.rate ? coin_1.Coin.toJSON(message.rate) : undefined);
        message.openCost !== undefined && (obj.openCost = Math.round(message.openCost));
        message.deposit !== undefined && (obj.deposit = message.deposit);
        message.settlementDuration !== undefined && (obj.settlementDuration = Math.round(message.settlementDuration));
        message.authorization !== undefined && (obj.authorization = (0, keeper_1.contractAuthorizationToJSON)(message.authorization));
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        var message = createBaseEventOpenContract();
        message.provider = (_a = object.provider) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.contractId = (_b = object.contractId) !== null && _b !== void 0 ? _b : 0;
        message.service = (_c = object.service) !== null && _c !== void 0 ? _c : "";
        message.client = (_d = object.client) !== null && _d !== void 0 ? _d : new Uint8Array();
        message.delegate = (_e = object.delegate) !== null && _e !== void 0 ? _e : new Uint8Array();
        message.type = (_f = object.type) !== null && _f !== void 0 ? _f : 0;
        message.height = (_g = object.height) !== null && _g !== void 0 ? _g : 0;
        message.duration = (_h = object.duration) !== null && _h !== void 0 ? _h : 0;
        message.rate = (object.rate !== undefined && object.rate !== null) ? coin_1.Coin.fromPartial(object.rate) : undefined;
        message.openCost = (_j = object.openCost) !== null && _j !== void 0 ? _j : 0;
        message.deposit = (_k = object.deposit) !== null && _k !== void 0 ? _k : "";
        message.settlementDuration = (_l = object.settlementDuration) !== null && _l !== void 0 ? _l : 0;
        message.authorization = (_m = object.authorization) !== null && _m !== void 0 ? _m : 0;
        return message;
    },
};
function createBaseEventSettleContract() {
    return {
        provider: new Uint8Array(),
        contractId: 0,
        service: "",
        client: new Uint8Array(),
        delegate: new Uint8Array(),
        type: 0,
        nonce: 0,
        height: 0,
        paid: "",
        reserve: "",
    };
}
exports.EventSettleContract = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.provider.length !== 0) {
            writer.uint32(10).bytes(message.provider);
        }
        if (message.contractId !== 0) {
            writer.uint32(16).uint64(message.contractId);
        }
        if (message.service !== "") {
            writer.uint32(26).string(message.service);
        }
        if (message.client.length !== 0) {
            writer.uint32(34).bytes(message.client);
        }
        if (message.delegate.length !== 0) {
            writer.uint32(42).bytes(message.delegate);
        }
        if (message.type !== 0) {
            writer.uint32(48).int32(message.type);
        }
        if (message.nonce !== 0) {
            writer.uint32(56).int64(message.nonce);
        }
        if (message.height !== 0) {
            writer.uint32(64).int64(message.height);
        }
        if (message.paid !== "") {
            writer.uint32(74).string(message.paid);
        }
        if (message.reserve !== "") {
            writer.uint32(82).string(message.reserve);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventSettleContract();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.provider = reader.bytes();
                    break;
                case 2:
                    message.contractId = longToNumber(reader.uint64());
                    break;
                case 3:
                    message.service = reader.string();
                    break;
                case 4:
                    message.client = reader.bytes();
                    break;
                case 5:
                    message.delegate = reader.bytes();
                    break;
                case 6:
                    message.type = reader.int32();
                    break;
                case 7:
                    message.nonce = longToNumber(reader.int64());
                    break;
                case 8:
                    message.height = longToNumber(reader.int64());
                    break;
                case 9:
                    message.paid = reader.string();
                    break;
                case 10:
                    message.reserve = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            provider: isSet(object.provider) ? bytesFromBase64(object.provider) : new Uint8Array(),
            contractId: isSet(object.contractId) ? Number(object.contractId) : 0,
            service: isSet(object.service) ? String(object.service) : "",
            client: isSet(object.client) ? bytesFromBase64(object.client) : new Uint8Array(),
            delegate: isSet(object.delegate) ? bytesFromBase64(object.delegate) : new Uint8Array(),
            type: isSet(object.type) ? (0, keeper_1.contractTypeFromJSON)(object.type) : 0,
            nonce: isSet(object.nonce) ? Number(object.nonce) : 0,
            height: isSet(object.height) ? Number(object.height) : 0,
            paid: isSet(object.paid) ? String(object.paid) : "",
            reserve: isSet(object.reserve) ? String(object.reserve) : "",
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.provider !== undefined
            && (obj.provider = base64FromBytes(message.provider !== undefined ? message.provider : new Uint8Array()));
        message.contractId !== undefined && (obj.contractId = Math.round(message.contractId));
        message.service !== undefined && (obj.service = message.service);
        message.client !== undefined
            && (obj.client = base64FromBytes(message.client !== undefined ? message.client : new Uint8Array()));
        message.delegate !== undefined
            && (obj.delegate = base64FromBytes(message.delegate !== undefined ? message.delegate : new Uint8Array()));
        message.type !== undefined && (obj.type = (0, keeper_1.contractTypeToJSON)(message.type));
        message.nonce !== undefined && (obj.nonce = Math.round(message.nonce));
        message.height !== undefined && (obj.height = Math.round(message.height));
        message.paid !== undefined && (obj.paid = message.paid);
        message.reserve !== undefined && (obj.reserve = message.reserve);
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        var message = createBaseEventSettleContract();
        message.provider = (_a = object.provider) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.contractId = (_b = object.contractId) !== null && _b !== void 0 ? _b : 0;
        message.service = (_c = object.service) !== null && _c !== void 0 ? _c : "";
        message.client = (_d = object.client) !== null && _d !== void 0 ? _d : new Uint8Array();
        message.delegate = (_e = object.delegate) !== null && _e !== void 0 ? _e : new Uint8Array();
        message.type = (_f = object.type) !== null && _f !== void 0 ? _f : 0;
        message.nonce = (_g = object.nonce) !== null && _g !== void 0 ? _g : 0;
        message.height = (_h = object.height) !== null && _h !== void 0 ? _h : 0;
        message.paid = (_j = object.paid) !== null && _j !== void 0 ? _j : "";
        message.reserve = (_k = object.reserve) !== null && _k !== void 0 ? _k : "";
        return message;
    },
};
function createBaseEventCloseContract() {
    return {
        contractId: 0,
        provider: new Uint8Array(),
        service: "",
        client: new Uint8Array(),
        delegate: new Uint8Array(),
    };
}
exports.EventCloseContract = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.contractId !== 0) {
            writer.uint32(8).uint64(message.contractId);
        }
        if (message.provider.length !== 0) {
            writer.uint32(18).bytes(message.provider);
        }
        if (message.service !== "") {
            writer.uint32(26).string(message.service);
        }
        if (message.client.length !== 0) {
            writer.uint32(34).bytes(message.client);
        }
        if (message.delegate.length !== 0) {
            writer.uint32(42).bytes(message.delegate);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventCloseContract();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.contractId = longToNumber(reader.uint64());
                    break;
                case 2:
                    message.provider = reader.bytes();
                    break;
                case 3:
                    message.service = reader.string();
                    break;
                case 4:
                    message.client = reader.bytes();
                    break;
                case 5:
                    message.delegate = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            contractId: isSet(object.contractId) ? Number(object.contractId) : 0,
            provider: isSet(object.provider) ? bytesFromBase64(object.provider) : new Uint8Array(),
            service: isSet(object.service) ? String(object.service) : "",
            client: isSet(object.client) ? bytesFromBase64(object.client) : new Uint8Array(),
            delegate: isSet(object.delegate) ? bytesFromBase64(object.delegate) : new Uint8Array(),
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.contractId !== undefined && (obj.contractId = Math.round(message.contractId));
        message.provider !== undefined
            && (obj.provider = base64FromBytes(message.provider !== undefined ? message.provider : new Uint8Array()));
        message.service !== undefined && (obj.service = message.service);
        message.client !== undefined
            && (obj.client = base64FromBytes(message.client !== undefined ? message.client : new Uint8Array()));
        message.delegate !== undefined
            && (obj.delegate = base64FromBytes(message.delegate !== undefined ? message.delegate : new Uint8Array()));
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e;
        var message = createBaseEventCloseContract();
        message.contractId = (_a = object.contractId) !== null && _a !== void 0 ? _a : 0;
        message.provider = (_b = object.provider) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.service = (_c = object.service) !== null && _c !== void 0 ? _c : "";
        message.client = (_d = object.client) !== null && _d !== void 0 ? _d : new Uint8Array();
        message.delegate = (_e = object.delegate) !== null && _e !== void 0 ? _e : new Uint8Array();
        return message;
    },
};
function createBaseValidatorPayoutEvent() {
    return { validator: new Uint8Array(), reward: "" };
}
exports.ValidatorPayoutEvent = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.validator.length !== 0) {
            writer.uint32(10).bytes(message.validator);
        }
        if (message.reward !== "") {
            writer.uint32(18).string(message.reward);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseValidatorPayoutEvent();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.validator = reader.bytes();
                    break;
                case 2:
                    message.reward = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            validator: isSet(object.validator) ? bytesFromBase64(object.validator) : new Uint8Array(),
            reward: isSet(object.reward) ? String(object.reward) : "",
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.validator !== undefined
            && (obj.validator = base64FromBytes(message.validator !== undefined ? message.validator : new Uint8Array()));
        message.reward !== undefined && (obj.reward = message.reward);
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseValidatorPayoutEvent();
        message.validator = (_a = object.validator) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.reward = (_b = object.reward) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
var globalThis = (function () {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        var bin = globalThis.atob(b64);
        var arr = new Uint8Array(bin.length);
        for (var i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        var bin_1 = [];
        arr.forEach(function (byte) {
            bin_1.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin_1.join(""));
    }
}
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
