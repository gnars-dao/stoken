import _m0 from "protobufjs/minimal";
import { Chain } from "./claim_record";
export declare const protobufPackage = "arkeo.claim";
export interface MsgClaimEth {
    creator: Uint8Array;
    /** the adress the claim is for */
    ethAddress: string;
    /** EIP712 signature that has to be signed by ethAddress */
    signature: string;
}
export interface MsgClaimEthResponse {
}
export interface MsgClaimArkeo {
    creator: Uint8Array;
}
export interface MsgClaimArkeoResponse {
}
export interface MsgTransferClaim {
    creator: Uint8Array;
    toAddress: Uint8Array;
}
export interface MsgTransferClaimResponse {
}
export interface MsgAddClaim {
    creator: Uint8Array;
    chain: Chain;
    address: string;
    amount: number;
}
export interface MsgAddClaimResponse {
}
export declare const MsgClaimEth: {
    encode(message: MsgClaimEth, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgClaimEth;
    fromJSON(object: any): MsgClaimEth;
    toJSON(message: MsgClaimEth): unknown;
    fromPartial<I extends {
        creator?: Uint8Array | undefined;
        ethAddress?: string | undefined;
        signature?: string | undefined;
    } & {
        creator?: Uint8Array | undefined;
        ethAddress?: string | undefined;
        signature?: string | undefined;
    } & { [K in Exclude<keyof I, keyof MsgClaimEth>]: never; }>(object: I): MsgClaimEth;
};
export declare const MsgClaimEthResponse: {
    encode(_: MsgClaimEthResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgClaimEthResponse;
    fromJSON(_: any): MsgClaimEthResponse;
    toJSON(_: MsgClaimEthResponse): unknown;
    fromPartial<I extends {} & {} & { [K in Exclude<keyof I, never>]: never; }>(_: I): MsgClaimEthResponse;
};
export declare const MsgClaimArkeo: {
    encode(message: MsgClaimArkeo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgClaimArkeo;
    fromJSON(object: any): MsgClaimArkeo;
    toJSON(message: MsgClaimArkeo): unknown;
    fromPartial<I extends {
        creator?: Uint8Array | undefined;
    } & {
        creator?: Uint8Array | undefined;
    } & { [K in Exclude<keyof I, "creator">]: never; }>(object: I): MsgClaimArkeo;
};
export declare const MsgClaimArkeoResponse: {
    encode(_: MsgClaimArkeoResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgClaimArkeoResponse;
    fromJSON(_: any): MsgClaimArkeoResponse;
    toJSON(_: MsgClaimArkeoResponse): unknown;
    fromPartial<I extends {} & {} & { [K in Exclude<keyof I, never>]: never; }>(_: I): MsgClaimArkeoResponse;
};
export declare const MsgTransferClaim: {
    encode(message: MsgTransferClaim, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgTransferClaim;
    fromJSON(object: any): MsgTransferClaim;
    toJSON(message: MsgTransferClaim): unknown;
    fromPartial<I extends {
        creator?: Uint8Array | undefined;
        toAddress?: Uint8Array | undefined;
    } & {
        creator?: Uint8Array | undefined;
        toAddress?: Uint8Array | undefined;
    } & { [K in Exclude<keyof I, keyof MsgTransferClaim>]: never; }>(object: I): MsgTransferClaim;
};
export declare const MsgTransferClaimResponse: {
    encode(_: MsgTransferClaimResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgTransferClaimResponse;
    fromJSON(_: any): MsgTransferClaimResponse;
    toJSON(_: MsgTransferClaimResponse): unknown;
    fromPartial<I extends {} & {} & { [K in Exclude<keyof I, never>]: never; }>(_: I): MsgTransferClaimResponse;
};
export declare const MsgAddClaim: {
    encode(message: MsgAddClaim, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgAddClaim;
    fromJSON(object: any): MsgAddClaim;
    toJSON(message: MsgAddClaim): unknown;
    fromPartial<I extends {
        creator?: Uint8Array | undefined;
        chain?: Chain | undefined;
        address?: string | undefined;
        amount?: number | undefined;
    } & {
        creator?: Uint8Array | undefined;
        chain?: Chain | undefined;
        address?: string | undefined;
        amount?: number | undefined;
    } & { [K in Exclude<keyof I, keyof MsgAddClaim>]: never; }>(object: I): MsgAddClaim;
};
export declare const MsgAddClaimResponse: {
    encode(_: MsgAddClaimResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgAddClaimResponse;
    fromJSON(_: any): MsgAddClaimResponse;
    toJSON(_: MsgAddClaimResponse): unknown;
    fromPartial<I extends {} & {} & { [K in Exclude<keyof I, never>]: never; }>(_: I): MsgAddClaimResponse;
};
/** Msg defines the Msg service. */
export interface Msg {
    ClaimEth(request: MsgClaimEth): Promise<MsgClaimEthResponse>;
    ClaimArkeo(request: MsgClaimArkeo): Promise<MsgClaimArkeoResponse>;
    TransferClaim(request: MsgTransferClaim): Promise<MsgTransferClaimResponse>;
    /** this line is used by starport scaffolding # proto/tx/rpc */
    AddClaim(request: MsgAddClaim): Promise<MsgAddClaimResponse>;
}
export declare class MsgClientImpl implements Msg {
    private readonly rpc;
    constructor(rpc: Rpc);
    ClaimEth(request: MsgClaimEth): Promise<MsgClaimEthResponse>;
    ClaimArkeo(request: MsgClaimArkeo): Promise<MsgClaimArkeoResponse>;
    TransferClaim(request: MsgTransferClaim): Promise<MsgTransferClaimResponse>;
    AddClaim(request: MsgAddClaim): Promise<MsgAddClaimResponse>;
}
interface Rpc {
    request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export {};
