"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BondProviders = exports.BondProvider = exports.NodeAccount = exports.nodeTypeToJSON = exports.nodeTypeFromJSON = exports.NodeType = exports.nodeStatusToJSON = exports.nodeStatusFromJSON = exports.NodeStatus = void 0;
/* eslint-disable */
var long_1 = __importDefault(require("long"));
var minimal_1 = __importDefault(require("protobufjs/minimal"));
var common_1 = require("../../../../../thorchain/v1/common/common");
var NodeStatus;
(function (NodeStatus) {
    NodeStatus[NodeStatus["Unknown"] = 0] = "Unknown";
    NodeStatus[NodeStatus["Whitelisted"] = 1] = "Whitelisted";
    NodeStatus[NodeStatus["Standby"] = 2] = "Standby";
    NodeStatus[NodeStatus["Ready"] = 3] = "Ready";
    NodeStatus[NodeStatus["Active"] = 4] = "Active";
    NodeStatus[NodeStatus["Disabled"] = 5] = "Disabled";
    NodeStatus[NodeStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(NodeStatus = exports.NodeStatus || (exports.NodeStatus = {}));
function nodeStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "Unknown":
            return NodeStatus.Unknown;
        case 1:
        case "Whitelisted":
            return NodeStatus.Whitelisted;
        case 2:
        case "Standby":
            return NodeStatus.Standby;
        case 3:
        case "Ready":
            return NodeStatus.Ready;
        case 4:
        case "Active":
            return NodeStatus.Active;
        case 5:
        case "Disabled":
            return NodeStatus.Disabled;
        case -1:
        case "UNRECOGNIZED":
        default:
            return NodeStatus.UNRECOGNIZED;
    }
}
exports.nodeStatusFromJSON = nodeStatusFromJSON;
function nodeStatusToJSON(object) {
    switch (object) {
        case NodeStatus.Unknown:
            return "Unknown";
        case NodeStatus.Whitelisted:
            return "Whitelisted";
        case NodeStatus.Standby:
            return "Standby";
        case NodeStatus.Ready:
            return "Ready";
        case NodeStatus.Active:
            return "Active";
        case NodeStatus.Disabled:
            return "Disabled";
        default:
            return "UNKNOWN";
    }
}
exports.nodeStatusToJSON = nodeStatusToJSON;
var NodeType;
(function (NodeType) {
    NodeType[NodeType["TypeValidator"] = 0] = "TypeValidator";
    NodeType[NodeType["TypeVault"] = 1] = "TypeVault";
    NodeType[NodeType["TypeUnknown"] = 2] = "TypeUnknown";
    NodeType[NodeType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(NodeType = exports.NodeType || (exports.NodeType = {}));
function nodeTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "TypeValidator":
            return NodeType.TypeValidator;
        case 1:
        case "TypeVault":
            return NodeType.TypeVault;
        case 2:
        case "TypeUnknown":
            return NodeType.TypeUnknown;
        case -1:
        case "UNRECOGNIZED":
        default:
            return NodeType.UNRECOGNIZED;
    }
}
exports.nodeTypeFromJSON = nodeTypeFromJSON;
function nodeTypeToJSON(object) {
    switch (object) {
        case NodeType.TypeValidator:
            return "TypeValidator";
        case NodeType.TypeVault:
            return "TypeVault";
        case NodeType.TypeUnknown:
            return "TypeUnknown";
        default:
            return "UNKNOWN";
    }
}
exports.nodeTypeToJSON = nodeTypeToJSON;
function createBaseNodeAccount() {
    return {
        nodeAddress: new Uint8Array(),
        status: 0,
        pubKeySet: undefined,
        validatorConsPubKey: "",
        bond: "",
        activeBlockHeight: long_1.default.ZERO,
        bondAddress: "",
        statusSince: long_1.default.ZERO,
        signerMembership: [],
        requestedToLeave: false,
        forcedToLeave: false,
        leaveScore: long_1.default.UZERO,
        ipAddress: "",
        version: "",
        type: 0,
    };
}
exports.NodeAccount = {
    encode: function (message, writer) {
        var e_1, _a;
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.nodeAddress.length !== 0) {
            writer.uint32(10).bytes(message.nodeAddress);
        }
        if (message.status !== 0) {
            writer.uint32(16).int32(message.status);
        }
        if (message.pubKeySet !== undefined) {
            common_1.PubKeySet.encode(message.pubKeySet, writer.uint32(26).fork()).ldelim();
        }
        if (message.validatorConsPubKey !== "") {
            writer.uint32(34).string(message.validatorConsPubKey);
        }
        if (message.bond !== "") {
            writer.uint32(42).string(message.bond);
        }
        if (!message.activeBlockHeight.isZero()) {
            writer.uint32(48).int64(message.activeBlockHeight);
        }
        if (message.bondAddress !== "") {
            writer.uint32(58).string(message.bondAddress);
        }
        if (!message.statusSince.isZero()) {
            writer.uint32(64).int64(message.statusSince);
        }
        try {
            for (var _b = __values(message.signerMembership), _c = _b.next(); !_c.done; _c = _b.next()) {
                var v = _c.value;
                writer.uint32(74).string(v);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (message.requestedToLeave === true) {
            writer.uint32(80).bool(message.requestedToLeave);
        }
        if (message.forcedToLeave === true) {
            writer.uint32(88).bool(message.forcedToLeave);
        }
        if (!message.leaveScore.isZero()) {
            writer.uint32(96).uint64(message.leaveScore);
        }
        if (message.ipAddress !== "") {
            writer.uint32(106).string(message.ipAddress);
        }
        if (message.version !== "") {
            writer.uint32(114).string(message.version);
        }
        if (message.type !== 0) {
            writer.uint32(120).int32(message.type);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseNodeAccount();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.nodeAddress = reader.bytes();
                    break;
                case 2:
                    message.status = reader.int32();
                    break;
                case 3:
                    message.pubKeySet = common_1.PubKeySet.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.validatorConsPubKey = reader.string();
                    break;
                case 5:
                    message.bond = reader.string();
                    break;
                case 6:
                    message.activeBlockHeight = reader.int64();
                    break;
                case 7:
                    message.bondAddress = reader.string();
                    break;
                case 8:
                    message.statusSince = reader.int64();
                    break;
                case 9:
                    message.signerMembership.push(reader.string());
                    break;
                case 10:
                    message.requestedToLeave = reader.bool();
                    break;
                case 11:
                    message.forcedToLeave = reader.bool();
                    break;
                case 12:
                    message.leaveScore = reader.uint64();
                    break;
                case 13:
                    message.ipAddress = reader.string();
                    break;
                case 14:
                    message.version = reader.string();
                    break;
                case 15:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            nodeAddress: isSet(object.nodeAddress)
                ? bytesFromBase64(object.nodeAddress)
                : new Uint8Array(),
            status: isSet(object.status) ? nodeStatusFromJSON(object.status) : 0,
            pubKeySet: isSet(object.pubKeySet)
                ? common_1.PubKeySet.fromJSON(object.pubKeySet)
                : undefined,
            validatorConsPubKey: isSet(object.validatorConsPubKey)
                ? String(object.validatorConsPubKey)
                : "",
            bond: isSet(object.bond) ? String(object.bond) : "",
            activeBlockHeight: isSet(object.activeBlockHeight)
                ? long_1.default.fromString(object.activeBlockHeight)
                : long_1.default.ZERO,
            bondAddress: isSet(object.bondAddress) ? String(object.bondAddress) : "",
            statusSince: isSet(object.statusSince)
                ? long_1.default.fromString(object.statusSince)
                : long_1.default.ZERO,
            signerMembership: Array.isArray(object === null || object === void 0 ? void 0 : object.signerMembership)
                ? object.signerMembership.map(function (e) { return String(e); })
                : [],
            requestedToLeave: isSet(object.requestedToLeave)
                ? Boolean(object.requestedToLeave)
                : false,
            forcedToLeave: isSet(object.forcedToLeave)
                ? Boolean(object.forcedToLeave)
                : false,
            leaveScore: isSet(object.leaveScore)
                ? long_1.default.fromString(object.leaveScore)
                : long_1.default.UZERO,
            ipAddress: isSet(object.ipAddress) ? String(object.ipAddress) : "",
            version: isSet(object.version) ? String(object.version) : "",
            type: isSet(object.type) ? nodeTypeFromJSON(object.type) : 0,
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.nodeAddress !== undefined &&
            (obj.nodeAddress = base64FromBytes(message.nodeAddress !== undefined
                ? message.nodeAddress
                : new Uint8Array()));
        message.status !== undefined &&
            (obj.status = nodeStatusToJSON(message.status));
        message.pubKeySet !== undefined &&
            (obj.pubKeySet = message.pubKeySet
                ? common_1.PubKeySet.toJSON(message.pubKeySet)
                : undefined);
        message.validatorConsPubKey !== undefined &&
            (obj.validatorConsPubKey = message.validatorConsPubKey);
        message.bond !== undefined && (obj.bond = message.bond);
        message.activeBlockHeight !== undefined &&
            (obj.activeBlockHeight = (message.activeBlockHeight || long_1.default.ZERO).toString());
        message.bondAddress !== undefined &&
            (obj.bondAddress = message.bondAddress);
        message.statusSince !== undefined &&
            (obj.statusSince = (message.statusSince || long_1.default.ZERO).toString());
        if (message.signerMembership) {
            obj.signerMembership = message.signerMembership.map(function (e) { return e; });
        }
        else {
            obj.signerMembership = [];
        }
        message.requestedToLeave !== undefined &&
            (obj.requestedToLeave = message.requestedToLeave);
        message.forcedToLeave !== undefined &&
            (obj.forcedToLeave = message.forcedToLeave);
        message.leaveScore !== undefined &&
            (obj.leaveScore = (message.leaveScore || long_1.default.UZERO).toString());
        message.ipAddress !== undefined && (obj.ipAddress = message.ipAddress);
        message.version !== undefined && (obj.version = message.version);
        message.type !== undefined && (obj.type = nodeTypeToJSON(message.type));
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        var message = createBaseNodeAccount();
        message.nodeAddress = (_a = object.nodeAddress) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.status = (_b = object.status) !== null && _b !== void 0 ? _b : 0;
        message.pubKeySet =
            object.pubKeySet !== undefined && object.pubKeySet !== null
                ? common_1.PubKeySet.fromPartial(object.pubKeySet)
                : undefined;
        message.validatorConsPubKey = (_c = object.validatorConsPubKey) !== null && _c !== void 0 ? _c : "";
        message.bond = (_d = object.bond) !== null && _d !== void 0 ? _d : "";
        message.activeBlockHeight =
            object.activeBlockHeight !== undefined &&
                object.activeBlockHeight !== null
                ? long_1.default.fromValue(object.activeBlockHeight)
                : long_1.default.ZERO;
        message.bondAddress = (_e = object.bondAddress) !== null && _e !== void 0 ? _e : "";
        message.statusSince =
            object.statusSince !== undefined && object.statusSince !== null
                ? long_1.default.fromValue(object.statusSince)
                : long_1.default.ZERO;
        message.signerMembership = ((_f = object.signerMembership) === null || _f === void 0 ? void 0 : _f.map(function (e) { return e; })) || [];
        message.requestedToLeave = (_g = object.requestedToLeave) !== null && _g !== void 0 ? _g : false;
        message.forcedToLeave = (_h = object.forcedToLeave) !== null && _h !== void 0 ? _h : false;
        message.leaveScore =
            object.leaveScore !== undefined && object.leaveScore !== null
                ? long_1.default.fromValue(object.leaveScore)
                : long_1.default.UZERO;
        message.ipAddress = (_j = object.ipAddress) !== null && _j !== void 0 ? _j : "";
        message.version = (_k = object.version) !== null && _k !== void 0 ? _k : "";
        message.type = (_l = object.type) !== null && _l !== void 0 ? _l : 0;
        return message;
    },
};
function createBaseBondProvider() {
    return { bondAddress: new Uint8Array(), bond: "" };
}
exports.BondProvider = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.bondAddress.length !== 0) {
            writer.uint32(10).bytes(message.bondAddress);
        }
        if (message.bond !== "") {
            writer.uint32(18).string(message.bond);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseBondProvider();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.bondAddress = reader.bytes();
                    break;
                case 2:
                    message.bond = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            bondAddress: isSet(object.bondAddress)
                ? bytesFromBase64(object.bondAddress)
                : new Uint8Array(),
            bond: isSet(object.bond) ? String(object.bond) : "",
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.bondAddress !== undefined &&
            (obj.bondAddress = base64FromBytes(message.bondAddress !== undefined
                ? message.bondAddress
                : new Uint8Array()));
        message.bond !== undefined && (obj.bond = message.bond);
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseBondProvider();
        message.bondAddress = (_a = object.bondAddress) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.bond = (_b = object.bond) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseBondProviders() {
    return { nodeAddress: new Uint8Array(), nodeOperatorFee: "", providers: [] };
}
exports.BondProviders = {
    encode: function (message, writer) {
        var e_2, _a;
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.nodeAddress.length !== 0) {
            writer.uint32(10).bytes(message.nodeAddress);
        }
        if (message.nodeOperatorFee !== "") {
            writer.uint32(18).string(message.nodeOperatorFee);
        }
        try {
            for (var _b = __values(message.providers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var v = _c.value;
                exports.BondProvider.encode(v, writer.uint32(26).fork()).ldelim();
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseBondProviders();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.nodeAddress = reader.bytes();
                    break;
                case 2:
                    message.nodeOperatorFee = reader.string();
                    break;
                case 3:
                    message.providers.push(exports.BondProvider.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            nodeAddress: isSet(object.nodeAddress)
                ? bytesFromBase64(object.nodeAddress)
                : new Uint8Array(),
            nodeOperatorFee: isSet(object.nodeOperatorFee)
                ? String(object.nodeOperatorFee)
                : "",
            providers: Array.isArray(object === null || object === void 0 ? void 0 : object.providers)
                ? object.providers.map(function (e) { return exports.BondProvider.fromJSON(e); })
                : [],
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.nodeAddress !== undefined &&
            (obj.nodeAddress = base64FromBytes(message.nodeAddress !== undefined
                ? message.nodeAddress
                : new Uint8Array()));
        message.nodeOperatorFee !== undefined &&
            (obj.nodeOperatorFee = message.nodeOperatorFee);
        if (message.providers) {
            obj.providers = message.providers.map(function (e) {
                return e ? exports.BondProvider.toJSON(e) : undefined;
            });
        }
        else {
            obj.providers = [];
        }
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b, _c;
        var message = createBaseBondProviders();
        message.nodeAddress = (_a = object.nodeAddress) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.nodeOperatorFee = (_b = object.nodeOperatorFee) !== null && _b !== void 0 ? _b : "";
        message.providers =
            ((_c = object.providers) === null || _c === void 0 ? void 0 : _c.map(function (e) { return exports.BondProvider.fromPartial(e); })) || [];
        return message;
    },
};
var globalThis = (function () {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
var atob = globalThis.atob ||
    (function (b64) { return globalThis.Buffer.from(b64, "base64").toString("binary"); });
function bytesFromBase64(b64) {
    var bin = atob(b64);
    var arr = new Uint8Array(bin.length);
    for (var i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
var btoa = globalThis.btoa ||
    (function (bin) { return globalThis.Buffer.from(bin, "binary").toString("base64"); });
function base64FromBytes(arr) {
    var e_3, _a;
    var bin = [];
    try {
        for (var arr_1 = __values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
            var byte = arr_1_1.value;
            bin.push(String.fromCharCode(byte));
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return btoa(bin.join(""));
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
