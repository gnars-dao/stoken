"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClaimRecord = exports.chainToJSON = exports.chainFromJSON = exports.Chain = exports.actionToJSON = exports.actionFromJSON = exports.Action = exports.protobufPackage = void 0;
/* eslint-disable */
var minimal_1 = __importDefault(require("protobufjs/minimal"));
var coin_1 = require("../../cosmos/base/v1beta1/coin");
exports.protobufPackage = "arkeo.claim";
/** actions for arkeo chain */
var Action;
(function (Action) {
    Action[Action["ACTION_CLAIM"] = 0] = "ACTION_CLAIM";
    Action[Action["ACTION_VOTE"] = 1] = "ACTION_VOTE";
    Action[Action["ACTION_DELEGATE"] = 2] = "ACTION_DELEGATE";
    Action[Action["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Action = exports.Action || (exports.Action = {}));
function actionFromJSON(object) {
    switch (object) {
        case 0:
        case "ACTION_CLAIM":
            return Action.ACTION_CLAIM;
        case 1:
        case "ACTION_VOTE":
            return Action.ACTION_VOTE;
        case 2:
        case "ACTION_DELEGATE":
            return Action.ACTION_DELEGATE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Action.UNRECOGNIZED;
    }
}
exports.actionFromJSON = actionFromJSON;
function actionToJSON(object) {
    switch (object) {
        case Action.ACTION_CLAIM:
            return "ACTION_CLAIM";
        case Action.ACTION_VOTE:
            return "ACTION_VOTE";
        case Action.ACTION_DELEGATE:
            return "ACTION_DELEGATE";
        case Action.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.actionToJSON = actionToJSON;
var Chain;
(function (Chain) {
    Chain[Chain["ARKEO"] = 0] = "ARKEO";
    Chain[Chain["ETHEREUM"] = 1] = "ETHEREUM";
    Chain[Chain["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Chain = exports.Chain || (exports.Chain = {}));
function chainFromJSON(object) {
    switch (object) {
        case 0:
        case "ARKEO":
            return Chain.ARKEO;
        case 1:
        case "ETHEREUM":
            return Chain.ETHEREUM;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Chain.UNRECOGNIZED;
    }
}
exports.chainFromJSON = chainFromJSON;
function chainToJSON(object) {
    switch (object) {
        case Chain.ARKEO:
            return "ARKEO";
        case Chain.ETHEREUM:
            return "ETHEREUM";
        case Chain.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.chainToJSON = chainToJSON;
function createBaseClaimRecord() {
    return {
        chain: 0,
        address: "",
        amountClaim: undefined,
        amountVote: undefined,
        amountDelegate: undefined,
        isTransferable: false,
    };
}
exports.ClaimRecord = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.chain !== 0) {
            writer.uint32(8).int32(message.chain);
        }
        if (message.address !== "") {
            writer.uint32(18).string(message.address);
        }
        if (message.amountClaim !== undefined) {
            coin_1.Coin.encode(message.amountClaim, writer.uint32(26).fork()).ldelim();
        }
        if (message.amountVote !== undefined) {
            coin_1.Coin.encode(message.amountVote, writer.uint32(34).fork()).ldelim();
        }
        if (message.amountDelegate !== undefined) {
            coin_1.Coin.encode(message.amountDelegate, writer.uint32(42).fork()).ldelim();
        }
        if (message.isTransferable === true) {
            writer.uint32(48).bool(message.isTransferable);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseClaimRecord();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.chain = reader.int32();
                    break;
                case 2:
                    message.address = reader.string();
                    break;
                case 3:
                    message.amountClaim = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.amountVote = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.amountDelegate = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.isTransferable = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            chain: isSet(object.chain) ? chainFromJSON(object.chain) : 0,
            address: isSet(object.address) ? String(object.address) : "",
            amountClaim: isSet(object.amountClaim) ? coin_1.Coin.fromJSON(object.amountClaim) : undefined,
            amountVote: isSet(object.amountVote) ? coin_1.Coin.fromJSON(object.amountVote) : undefined,
            amountDelegate: isSet(object.amountDelegate) ? coin_1.Coin.fromJSON(object.amountDelegate) : undefined,
            isTransferable: isSet(object.isTransferable) ? Boolean(object.isTransferable) : false,
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.chain !== undefined && (obj.chain = chainToJSON(message.chain));
        message.address !== undefined && (obj.address = message.address);
        message.amountClaim !== undefined
            && (obj.amountClaim = message.amountClaim ? coin_1.Coin.toJSON(message.amountClaim) : undefined);
        message.amountVote !== undefined
            && (obj.amountVote = message.amountVote ? coin_1.Coin.toJSON(message.amountVote) : undefined);
        message.amountDelegate !== undefined
            && (obj.amountDelegate = message.amountDelegate ? coin_1.Coin.toJSON(message.amountDelegate) : undefined);
        message.isTransferable !== undefined && (obj.isTransferable = message.isTransferable);
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b, _c;
        var message = createBaseClaimRecord();
        message.chain = (_a = object.chain) !== null && _a !== void 0 ? _a : 0;
        message.address = (_b = object.address) !== null && _b !== void 0 ? _b : "";
        message.amountClaim = (object.amountClaim !== undefined && object.amountClaim !== null)
            ? coin_1.Coin.fromPartial(object.amountClaim)
            : undefined;
        message.amountVote = (object.amountVote !== undefined && object.amountVote !== null)
            ? coin_1.Coin.fromPartial(object.amountVote)
            : undefined;
        message.amountDelegate = (object.amountDelegate !== undefined && object.amountDelegate !== null)
            ? coin_1.Coin.fromPartial(object.amountDelegate)
            : undefined;
        message.isTransferable = (_c = object.isTransferable) !== null && _c !== void 0 ? _c : false;
        return message;
    },
};
function isSet(value) {
    return value !== null && value !== undefined;
}
