import Long from "long";
import _m0 from "protobufjs/minimal";
import { Asset, Tx, Coin, Fee } from "../../../../../thorchain/v1/common/common";
import { PoolStatus } from "../../../../../thorchain/v1/x/thorchain/types/type_pool";
import { ReserveContributor } from "../../../../../thorchain/v1/x/thorchain/types/type_reserve_contributor";
export declare enum PendingLiquidityType {
    add = 0,
    withdraw = 1,
    UNRECOGNIZED = -1
}
export declare function pendingLiquidityTypeFromJSON(object: any): PendingLiquidityType;
export declare function pendingLiquidityTypeToJSON(object: PendingLiquidityType): string;
export declare enum BondType {
    bond_paid = 0,
    bond_returned = 1,
    bond_reward = 2,
    bond_cost = 3,
    UNRECOGNIZED = -1
}
export declare function bondTypeFromJSON(object: any): BondType;
export declare function bondTypeToJSON(object: BondType): string;
export interface PoolMod {
    asset?: Asset;
    runeAmt: string;
    runeAdd: boolean;
    assetAmt: string;
    assetAdd: boolean;
}
export interface EventSwap {
    pool?: Asset;
    swapTarget: string;
    swapSlip: string;
    liquidityFee: string;
    liquidityFeeInRune: string;
    inTx?: Tx;
    outTxs?: Tx;
    emitAsset?: Coin;
    synthUnits: string;
}
export interface EventAddLiquidity {
    pool?: Asset;
    providerUnits: string;
    runeAddress: string;
    runeAmount: string;
    assetAmount: string;
    runeTxId: string;
    assetTxId: string;
    assetAddress: string;
}
export interface EventWithdraw {
    pool?: Asset;
    providerUnits: string;
    basisPoints: Long;
    asymmetry: Uint8Array;
    inTx?: Tx;
    emitAsset: string;
    emitRune: string;
    impLossProtection: string;
}
export interface EventPendingLiquidity {
    pool?: Asset;
    pendingType: PendingLiquidityType;
    runeAddress: string;
    runeAmount: string;
    assetAddress: string;
    assetAmount: string;
    runeTxId: string;
    assetTxId: string;
}
export interface EventDonate {
    pool?: Asset;
    inTx?: Tx;
}
export interface EventPool {
    pool?: Asset;
    Status: PoolStatus;
}
export interface PoolAmt {
    asset?: Asset;
    amount: Long;
}
export interface EventRewards {
    bondReward: string;
    poolRewards: PoolAmt[];
}
export interface EventRefund {
    code: number;
    reason: string;
    inTx?: Tx;
    fee?: Fee;
}
export interface EventBond {
    amount: string;
    bondType: BondType;
    txIn?: Tx;
}
export interface GasPool {
    asset?: Asset;
    runeAmt: string;
    assetAmt: string;
    count: Long;
}
export interface EventGas {
    pools: GasPool[];
}
export interface EventReserve {
    reserveContributor?: ReserveContributor;
    inTx?: Tx;
}
export interface EventSlash {
    pool?: Asset;
    slashAmount: PoolAmt[];
}
export interface EventErrata {
    txId: string;
    pools: PoolMod[];
}
export interface EventFee {
    txId: string;
    fee?: Fee;
    synthUnits: string;
}
export interface EventOutbound {
    inTxId: string;
    tx?: Tx;
}
export interface EventTssKeygenMetric {
    pubKey: string;
    medianDurationMs: Long;
}
export interface EventTssKeysignMetric {
    txId: string;
    medianDurationMs: Long;
}
export interface EventSlashPoint {
    nodeAddress: Uint8Array;
    slashPoints: Long;
    reason: string;
}
export interface EventPoolBalanceChanged {
    poolChange?: PoolMod;
    reason: string;
}
export interface EventSwitch {
    toAddress: Uint8Array;
    fromAddress: string;
    burn?: Coin;
}
export interface EventSwitchV56 {
    toAddress: Uint8Array;
    fromAddress: string;
    burn?: Coin;
    txId: string;
}
export interface EventTHORName {
    name: string;
    chain: string;
    address: string;
    registrationFee: string;
    fundAmt: string;
    expire: Long;
    owner: Uint8Array;
}
export declare const PoolMod: {
    encode(message: PoolMod, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PoolMod;
    fromJSON(object: any): PoolMod;
    toJSON(message: PoolMod): unknown;
    fromPartial<I extends {
        asset?: {
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } | undefined;
        runeAmt?: string | undefined;
        runeAdd?: boolean | undefined;
        assetAmt?: string | undefined;
        assetAdd?: boolean | undefined;
    } & {
        asset?: ({
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } & {
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } & Record<Exclude<keyof I["asset"], keyof Asset>, never>) | undefined;
        runeAmt?: string | undefined;
        runeAdd?: boolean | undefined;
        assetAmt?: string | undefined;
        assetAdd?: boolean | undefined;
    } & Record<Exclude<keyof I, keyof PoolMod>, never>>(object: I): PoolMod;
};
export declare const EventSwap: {
    encode(message: EventSwap, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventSwap;
    fromJSON(object: any): EventSwap;
    toJSON(message: EventSwap): unknown;
    fromPartial<I extends {
        pool?: {
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } | undefined;
        swapTarget?: string | undefined;
        swapSlip?: string | undefined;
        liquidityFee?: string | undefined;
        liquidityFeeInRune?: string | undefined;
        inTx?: {
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            gas?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            memo?: string | undefined;
        } | undefined;
        outTxs?: {
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            gas?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            memo?: string | undefined;
        } | undefined;
        emitAsset?: {
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            amount?: string | undefined;
            decimals?: string | number | Long.Long | undefined;
        } | undefined;
        synthUnits?: string | undefined;
    } & {
        pool?: ({
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } & {
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } & Record<Exclude<keyof I["pool"], keyof Asset>, never>) | undefined;
        swapTarget?: string | undefined;
        swapSlip?: string | undefined;
        liquidityFee?: string | undefined;
        liquidityFeeInRune?: string | undefined;
        inTx?: ({
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            gas?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            memo?: string | undefined;
        } & {
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] & ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            } & {
                asset?: ({
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & Record<Exclude<keyof I["inTx"]["coins"][number]["asset"], keyof Asset>, never>) | undefined;
                amount?: string | undefined;
                decimals?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["inTx"]["coins"][number]["decimals"], keyof Long.Long>, never>) | undefined;
            } & Record<Exclude<keyof I["inTx"]["coins"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["inTx"]["coins"], keyof {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[]>, never>) | undefined;
            gas?: ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] & ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            } & {
                asset?: ({
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & Record<Exclude<keyof I["inTx"]["gas"][number]["asset"], keyof Asset>, never>) | undefined;
                amount?: string | undefined;
                decimals?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["inTx"]["gas"][number]["decimals"], keyof Long.Long>, never>) | undefined;
            } & Record<Exclude<keyof I["inTx"]["gas"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["inTx"]["gas"], keyof {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[]>, never>) | undefined;
            memo?: string | undefined;
        } & Record<Exclude<keyof I["inTx"], keyof Tx>, never>) | undefined;
        outTxs?: ({
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            gas?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            memo?: string | undefined;
        } & {
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] & ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            } & {
                asset?: ({
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & Record<Exclude<keyof I["outTxs"]["coins"][number]["asset"], keyof Asset>, never>) | undefined;
                amount?: string | undefined;
                decimals?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["outTxs"]["coins"][number]["decimals"], keyof Long.Long>, never>) | undefined;
            } & Record<Exclude<keyof I["outTxs"]["coins"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["outTxs"]["coins"], keyof {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[]>, never>) | undefined;
            gas?: ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] & ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            } & {
                asset?: ({
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & Record<Exclude<keyof I["outTxs"]["gas"][number]["asset"], keyof Asset>, never>) | undefined;
                amount?: string | undefined;
                decimals?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["outTxs"]["gas"][number]["decimals"], keyof Long.Long>, never>) | undefined;
            } & Record<Exclude<keyof I["outTxs"]["gas"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["outTxs"]["gas"], keyof {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[]>, never>) | undefined;
            memo?: string | undefined;
        } & Record<Exclude<keyof I["outTxs"], keyof Tx>, never>) | undefined;
        emitAsset?: ({
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            amount?: string | undefined;
            decimals?: string | number | Long.Long | undefined;
        } & {
            asset?: ({
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } & {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } & Record<Exclude<keyof I["emitAsset"]["asset"], keyof Asset>, never>) | undefined;
            amount?: string | undefined;
            decimals?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["emitAsset"]["decimals"], keyof Long.Long>, never>) | undefined;
        } & Record<Exclude<keyof I["emitAsset"], keyof Coin>, never>) | undefined;
        synthUnits?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventSwap>, never>>(object: I): EventSwap;
};
export declare const EventAddLiquidity: {
    encode(message: EventAddLiquidity, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventAddLiquidity;
    fromJSON(object: any): EventAddLiquidity;
    toJSON(message: EventAddLiquidity): unknown;
    fromPartial<I extends {
        pool?: {
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } | undefined;
        providerUnits?: string | undefined;
        runeAddress?: string | undefined;
        runeAmount?: string | undefined;
        assetAmount?: string | undefined;
        runeTxId?: string | undefined;
        assetTxId?: string | undefined;
        assetAddress?: string | undefined;
    } & {
        pool?: ({
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } & {
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } & Record<Exclude<keyof I["pool"], keyof Asset>, never>) | undefined;
        providerUnits?: string | undefined;
        runeAddress?: string | undefined;
        runeAmount?: string | undefined;
        assetAmount?: string | undefined;
        runeTxId?: string | undefined;
        assetTxId?: string | undefined;
        assetAddress?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventAddLiquidity>, never>>(object: I): EventAddLiquidity;
};
export declare const EventWithdraw: {
    encode(message: EventWithdraw, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventWithdraw;
    fromJSON(object: any): EventWithdraw;
    toJSON(message: EventWithdraw): unknown;
    fromPartial<I extends {
        pool?: {
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } | undefined;
        providerUnits?: string | undefined;
        basisPoints?: string | number | Long.Long | undefined;
        asymmetry?: Uint8Array | undefined;
        inTx?: {
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            gas?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            memo?: string | undefined;
        } | undefined;
        emitAsset?: string | undefined;
        emitRune?: string | undefined;
        impLossProtection?: string | undefined;
    } & {
        pool?: ({
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } & {
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } & Record<Exclude<keyof I["pool"], keyof Asset>, never>) | undefined;
        providerUnits?: string | undefined;
        basisPoints?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["basisPoints"], keyof Long.Long>, never>) | undefined;
        asymmetry?: Uint8Array | undefined;
        inTx?: ({
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            gas?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            memo?: string | undefined;
        } & {
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] & ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            } & {
                asset?: ({
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & Record<Exclude<keyof I["inTx"]["coins"][number]["asset"], keyof Asset>, never>) | undefined;
                amount?: string | undefined;
                decimals?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["inTx"]["coins"][number]["decimals"], keyof Long.Long>, never>) | undefined;
            } & Record<Exclude<keyof I["inTx"]["coins"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["inTx"]["coins"], keyof {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[]>, never>) | undefined;
            gas?: ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] & ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            } & {
                asset?: ({
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & Record<Exclude<keyof I["inTx"]["gas"][number]["asset"], keyof Asset>, never>) | undefined;
                amount?: string | undefined;
                decimals?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["inTx"]["gas"][number]["decimals"], keyof Long.Long>, never>) | undefined;
            } & Record<Exclude<keyof I["inTx"]["gas"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["inTx"]["gas"], keyof {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[]>, never>) | undefined;
            memo?: string | undefined;
        } & Record<Exclude<keyof I["inTx"], keyof Tx>, never>) | undefined;
        emitAsset?: string | undefined;
        emitRune?: string | undefined;
        impLossProtection?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventWithdraw>, never>>(object: I): EventWithdraw;
};
export declare const EventPendingLiquidity: {
    encode(message: EventPendingLiquidity, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventPendingLiquidity;
    fromJSON(object: any): EventPendingLiquidity;
    toJSON(message: EventPendingLiquidity): unknown;
    fromPartial<I extends {
        pool?: {
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } | undefined;
        pendingType?: PendingLiquidityType | undefined;
        runeAddress?: string | undefined;
        runeAmount?: string | undefined;
        assetAddress?: string | undefined;
        assetAmount?: string | undefined;
        runeTxId?: string | undefined;
        assetTxId?: string | undefined;
    } & {
        pool?: ({
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } & {
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } & Record<Exclude<keyof I["pool"], keyof Asset>, never>) | undefined;
        pendingType?: PendingLiquidityType | undefined;
        runeAddress?: string | undefined;
        runeAmount?: string | undefined;
        assetAddress?: string | undefined;
        assetAmount?: string | undefined;
        runeTxId?: string | undefined;
        assetTxId?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventPendingLiquidity>, never>>(object: I): EventPendingLiquidity;
};
export declare const EventDonate: {
    encode(message: EventDonate, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventDonate;
    fromJSON(object: any): EventDonate;
    toJSON(message: EventDonate): unknown;
    fromPartial<I extends {
        pool?: {
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } | undefined;
        inTx?: {
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            gas?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            memo?: string | undefined;
        } | undefined;
    } & {
        pool?: ({
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } & {
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } & Record<Exclude<keyof I["pool"], keyof Asset>, never>) | undefined;
        inTx?: ({
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            gas?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            memo?: string | undefined;
        } & {
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] & ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            } & {
                asset?: ({
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & Record<Exclude<keyof I["inTx"]["coins"][number]["asset"], keyof Asset>, never>) | undefined;
                amount?: string | undefined;
                decimals?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["inTx"]["coins"][number]["decimals"], keyof Long.Long>, never>) | undefined;
            } & Record<Exclude<keyof I["inTx"]["coins"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["inTx"]["coins"], keyof {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[]>, never>) | undefined;
            gas?: ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] & ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            } & {
                asset?: ({
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & Record<Exclude<keyof I["inTx"]["gas"][number]["asset"], keyof Asset>, never>) | undefined;
                amount?: string | undefined;
                decimals?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["inTx"]["gas"][number]["decimals"], keyof Long.Long>, never>) | undefined;
            } & Record<Exclude<keyof I["inTx"]["gas"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["inTx"]["gas"], keyof {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[]>, never>) | undefined;
            memo?: string | undefined;
        } & Record<Exclude<keyof I["inTx"], keyof Tx>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof EventDonate>, never>>(object: I): EventDonate;
};
export declare const EventPool: {
    encode(message: EventPool, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventPool;
    fromJSON(object: any): EventPool;
    toJSON(message: EventPool): unknown;
    fromPartial<I extends {
        pool?: {
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } | undefined;
        Status?: PoolStatus | undefined;
    } & {
        pool?: ({
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } & {
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } & Record<Exclude<keyof I["pool"], keyof Asset>, never>) | undefined;
        Status?: PoolStatus | undefined;
    } & Record<Exclude<keyof I, keyof EventPool>, never>>(object: I): EventPool;
};
export declare const PoolAmt: {
    encode(message: PoolAmt, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PoolAmt;
    fromJSON(object: any): PoolAmt;
    toJSON(message: PoolAmt): unknown;
    fromPartial<I extends {
        asset?: {
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } | undefined;
        amount?: string | number | Long.Long | undefined;
    } & {
        asset?: ({
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } & {
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } & Record<Exclude<keyof I["asset"], keyof Asset>, never>) | undefined;
        amount?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["amount"], keyof Long.Long>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof PoolAmt>, never>>(object: I): PoolAmt;
};
export declare const EventRewards: {
    encode(message: EventRewards, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventRewards;
    fromJSON(object: any): EventRewards;
    toJSON(message: EventRewards): unknown;
    fromPartial<I extends {
        bondReward?: string | undefined;
        poolRewards?: {
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            amount?: string | number | Long.Long | undefined;
        }[] | undefined;
    } & {
        bondReward?: string | undefined;
        poolRewards?: ({
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            amount?: string | number | Long.Long | undefined;
        }[] & ({
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            amount?: string | number | Long.Long | undefined;
        } & {
            asset?: ({
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } & {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } & Record<Exclude<keyof I["poolRewards"][number]["asset"], keyof Asset>, never>) | undefined;
            amount?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["poolRewards"][number]["amount"], keyof Long.Long>, never>) | undefined;
        } & Record<Exclude<keyof I["poolRewards"][number], keyof PoolAmt>, never>)[] & Record<Exclude<keyof I["poolRewards"], keyof {
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            amount?: string | number | Long.Long | undefined;
        }[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof EventRewards>, never>>(object: I): EventRewards;
};
export declare const EventRefund: {
    encode(message: EventRefund, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventRefund;
    fromJSON(object: any): EventRefund;
    toJSON(message: EventRefund): unknown;
    fromPartial<I extends {
        code?: number | undefined;
        reason?: string | undefined;
        inTx?: {
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            gas?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            memo?: string | undefined;
        } | undefined;
        fee?: {
            coins?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            poolDeduct?: string | undefined;
        } | undefined;
    } & {
        code?: number | undefined;
        reason?: string | undefined;
        inTx?: ({
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            gas?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            memo?: string | undefined;
        } & {
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] & ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            } & {
                asset?: ({
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & Record<Exclude<keyof I["inTx"]["coins"][number]["asset"], keyof Asset>, never>) | undefined;
                amount?: string | undefined;
                decimals?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["inTx"]["coins"][number]["decimals"], keyof Long.Long>, never>) | undefined;
            } & Record<Exclude<keyof I["inTx"]["coins"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["inTx"]["coins"], keyof {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[]>, never>) | undefined;
            gas?: ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] & ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            } & {
                asset?: ({
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & Record<Exclude<keyof I["inTx"]["gas"][number]["asset"], keyof Asset>, never>) | undefined;
                amount?: string | undefined;
                decimals?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["inTx"]["gas"][number]["decimals"], keyof Long.Long>, never>) | undefined;
            } & Record<Exclude<keyof I["inTx"]["gas"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["inTx"]["gas"], keyof {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[]>, never>) | undefined;
            memo?: string | undefined;
        } & Record<Exclude<keyof I["inTx"], keyof Tx>, never>) | undefined;
        fee?: ({
            coins?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            poolDeduct?: string | undefined;
        } & {
            coins?: ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] & ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            } & {
                asset?: ({
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & Record<Exclude<keyof I["fee"]["coins"][number]["asset"], keyof Asset>, never>) | undefined;
                amount?: string | undefined;
                decimals?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["fee"]["coins"][number]["decimals"], keyof Long.Long>, never>) | undefined;
            } & Record<Exclude<keyof I["fee"]["coins"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["fee"]["coins"], keyof {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[]>, never>) | undefined;
            poolDeduct?: string | undefined;
        } & Record<Exclude<keyof I["fee"], keyof Fee>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof EventRefund>, never>>(object: I): EventRefund;
};
export declare const EventBond: {
    encode(message: EventBond, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventBond;
    fromJSON(object: any): EventBond;
    toJSON(message: EventBond): unknown;
    fromPartial<I extends {
        amount?: string | undefined;
        bondType?: BondType | undefined;
        txIn?: {
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            gas?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            memo?: string | undefined;
        } | undefined;
    } & {
        amount?: string | undefined;
        bondType?: BondType | undefined;
        txIn?: ({
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            gas?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            memo?: string | undefined;
        } & {
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] & ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            } & {
                asset?: ({
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & Record<Exclude<keyof I["txIn"]["coins"][number]["asset"], keyof Asset>, never>) | undefined;
                amount?: string | undefined;
                decimals?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["txIn"]["coins"][number]["decimals"], keyof Long.Long>, never>) | undefined;
            } & Record<Exclude<keyof I["txIn"]["coins"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["txIn"]["coins"], keyof {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[]>, never>) | undefined;
            gas?: ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] & ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            } & {
                asset?: ({
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & Record<Exclude<keyof I["txIn"]["gas"][number]["asset"], keyof Asset>, never>) | undefined;
                amount?: string | undefined;
                decimals?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["txIn"]["gas"][number]["decimals"], keyof Long.Long>, never>) | undefined;
            } & Record<Exclude<keyof I["txIn"]["gas"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["txIn"]["gas"], keyof {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[]>, never>) | undefined;
            memo?: string | undefined;
        } & Record<Exclude<keyof I["txIn"], keyof Tx>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof EventBond>, never>>(object: I): EventBond;
};
export declare const GasPool: {
    encode(message: GasPool, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GasPool;
    fromJSON(object: any): GasPool;
    toJSON(message: GasPool): unknown;
    fromPartial<I extends {
        asset?: {
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } | undefined;
        runeAmt?: string | undefined;
        assetAmt?: string | undefined;
        count?: string | number | Long.Long | undefined;
    } & {
        asset?: ({
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } & {
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } & Record<Exclude<keyof I["asset"], keyof Asset>, never>) | undefined;
        runeAmt?: string | undefined;
        assetAmt?: string | undefined;
        count?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["count"], keyof Long.Long>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof GasPool>, never>>(object: I): GasPool;
};
export declare const EventGas: {
    encode(message: EventGas, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventGas;
    fromJSON(object: any): EventGas;
    toJSON(message: EventGas): unknown;
    fromPartial<I extends {
        pools?: {
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            runeAmt?: string | undefined;
            assetAmt?: string | undefined;
            count?: string | number | Long.Long | undefined;
        }[] | undefined;
    } & {
        pools?: ({
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            runeAmt?: string | undefined;
            assetAmt?: string | undefined;
            count?: string | number | Long.Long | undefined;
        }[] & ({
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            runeAmt?: string | undefined;
            assetAmt?: string | undefined;
            count?: string | number | Long.Long | undefined;
        } & {
            asset?: ({
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } & {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } & Record<Exclude<keyof I["pools"][number]["asset"], keyof Asset>, never>) | undefined;
            runeAmt?: string | undefined;
            assetAmt?: string | undefined;
            count?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pools"][number]["count"], keyof Long.Long>, never>) | undefined;
        } & Record<Exclude<keyof I["pools"][number], keyof GasPool>, never>)[] & Record<Exclude<keyof I["pools"], keyof {
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            runeAmt?: string | undefined;
            assetAmt?: string | undefined;
            count?: string | number | Long.Long | undefined;
        }[]>, never>) | undefined;
    } & Record<Exclude<keyof I, "pools">, never>>(object: I): EventGas;
};
export declare const EventReserve: {
    encode(message: EventReserve, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventReserve;
    fromJSON(object: any): EventReserve;
    toJSON(message: EventReserve): unknown;
    fromPartial<I extends {
        reserveContributor?: {
            address?: string | undefined;
            amount?: string | undefined;
        } | undefined;
        inTx?: {
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            gas?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            memo?: string | undefined;
        } | undefined;
    } & {
        reserveContributor?: ({
            address?: string | undefined;
            amount?: string | undefined;
        } & {
            address?: string | undefined;
            amount?: string | undefined;
        } & Record<Exclude<keyof I["reserveContributor"], keyof ReserveContributor>, never>) | undefined;
        inTx?: ({
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            gas?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            memo?: string | undefined;
        } & {
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] & ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            } & {
                asset?: ({
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & Record<Exclude<keyof I["inTx"]["coins"][number]["asset"], keyof Asset>, never>) | undefined;
                amount?: string | undefined;
                decimals?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["inTx"]["coins"][number]["decimals"], keyof Long.Long>, never>) | undefined;
            } & Record<Exclude<keyof I["inTx"]["coins"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["inTx"]["coins"], keyof {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[]>, never>) | undefined;
            gas?: ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] & ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            } & {
                asset?: ({
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & Record<Exclude<keyof I["inTx"]["gas"][number]["asset"], keyof Asset>, never>) | undefined;
                amount?: string | undefined;
                decimals?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["inTx"]["gas"][number]["decimals"], keyof Long.Long>, never>) | undefined;
            } & Record<Exclude<keyof I["inTx"]["gas"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["inTx"]["gas"], keyof {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[]>, never>) | undefined;
            memo?: string | undefined;
        } & Record<Exclude<keyof I["inTx"], keyof Tx>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof EventReserve>, never>>(object: I): EventReserve;
};
export declare const EventSlash: {
    encode(message: EventSlash, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventSlash;
    fromJSON(object: any): EventSlash;
    toJSON(message: EventSlash): unknown;
    fromPartial<I extends {
        pool?: {
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } | undefined;
        slashAmount?: {
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            amount?: string | number | Long.Long | undefined;
        }[] | undefined;
    } & {
        pool?: ({
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } & {
            chain?: string | undefined;
            symbol?: string | undefined;
            ticker?: string | undefined;
            synth?: boolean | undefined;
        } & Record<Exclude<keyof I["pool"], keyof Asset>, never>) | undefined;
        slashAmount?: ({
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            amount?: string | number | Long.Long | undefined;
        }[] & ({
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            amount?: string | number | Long.Long | undefined;
        } & {
            asset?: ({
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } & {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } & Record<Exclude<keyof I["slashAmount"][number]["asset"], keyof Asset>, never>) | undefined;
            amount?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["slashAmount"][number]["amount"], keyof Long.Long>, never>) | undefined;
        } & Record<Exclude<keyof I["slashAmount"][number], keyof PoolAmt>, never>)[] & Record<Exclude<keyof I["slashAmount"], keyof {
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            amount?: string | number | Long.Long | undefined;
        }[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof EventSlash>, never>>(object: I): EventSlash;
};
export declare const EventErrata: {
    encode(message: EventErrata, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventErrata;
    fromJSON(object: any): EventErrata;
    toJSON(message: EventErrata): unknown;
    fromPartial<I extends {
        txId?: string | undefined;
        pools?: {
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            runeAmt?: string | undefined;
            runeAdd?: boolean | undefined;
            assetAmt?: string | undefined;
            assetAdd?: boolean | undefined;
        }[] | undefined;
    } & {
        txId?: string | undefined;
        pools?: ({
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            runeAmt?: string | undefined;
            runeAdd?: boolean | undefined;
            assetAmt?: string | undefined;
            assetAdd?: boolean | undefined;
        }[] & ({
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            runeAmt?: string | undefined;
            runeAdd?: boolean | undefined;
            assetAmt?: string | undefined;
            assetAdd?: boolean | undefined;
        } & {
            asset?: ({
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } & {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } & Record<Exclude<keyof I["pools"][number]["asset"], keyof Asset>, never>) | undefined;
            runeAmt?: string | undefined;
            runeAdd?: boolean | undefined;
            assetAmt?: string | undefined;
            assetAdd?: boolean | undefined;
        } & Record<Exclude<keyof I["pools"][number], keyof PoolMod>, never>)[] & Record<Exclude<keyof I["pools"], keyof {
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            runeAmt?: string | undefined;
            runeAdd?: boolean | undefined;
            assetAmt?: string | undefined;
            assetAdd?: boolean | undefined;
        }[]>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof EventErrata>, never>>(object: I): EventErrata;
};
export declare const EventFee: {
    encode(message: EventFee, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventFee;
    fromJSON(object: any): EventFee;
    toJSON(message: EventFee): unknown;
    fromPartial<I extends {
        txId?: string | undefined;
        fee?: {
            coins?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            poolDeduct?: string | undefined;
        } | undefined;
        synthUnits?: string | undefined;
    } & {
        txId?: string | undefined;
        fee?: ({
            coins?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            poolDeduct?: string | undefined;
        } & {
            coins?: ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] & ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            } & {
                asset?: ({
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & Record<Exclude<keyof I["fee"]["coins"][number]["asset"], keyof Asset>, never>) | undefined;
                amount?: string | undefined;
                decimals?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["fee"]["coins"][number]["decimals"], keyof Long.Long>, never>) | undefined;
            } & Record<Exclude<keyof I["fee"]["coins"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["fee"]["coins"], keyof {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[]>, never>) | undefined;
            poolDeduct?: string | undefined;
        } & Record<Exclude<keyof I["fee"], keyof Fee>, never>) | undefined;
        synthUnits?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventFee>, never>>(object: I): EventFee;
};
export declare const EventOutbound: {
    encode(message: EventOutbound, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventOutbound;
    fromJSON(object: any): EventOutbound;
    toJSON(message: EventOutbound): unknown;
    fromPartial<I extends {
        inTxId?: string | undefined;
        tx?: {
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            gas?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            memo?: string | undefined;
        } | undefined;
    } & {
        inTxId?: string | undefined;
        tx?: ({
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            gas?: {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] | undefined;
            memo?: string | undefined;
        } & {
            id?: string | undefined;
            chain?: string | undefined;
            fromAddress?: string | undefined;
            toAddress?: string | undefined;
            coins?: ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] & ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            } & {
                asset?: ({
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & Record<Exclude<keyof I["tx"]["coins"][number]["asset"], keyof Asset>, never>) | undefined;
                amount?: string | undefined;
                decimals?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["tx"]["coins"][number]["decimals"], keyof Long.Long>, never>) | undefined;
            } & Record<Exclude<keyof I["tx"]["coins"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["tx"]["coins"], keyof {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[]>, never>) | undefined;
            gas?: ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[] & ({
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            } & {
                asset?: ({
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } & Record<Exclude<keyof I["tx"]["gas"][number]["asset"], keyof Asset>, never>) | undefined;
                amount?: string | undefined;
                decimals?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean | undefined) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number | undefined) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["tx"]["gas"][number]["decimals"], keyof Long.Long>, never>) | undefined;
            } & Record<Exclude<keyof I["tx"]["gas"][number], keyof Coin>, never>)[] & Record<Exclude<keyof I["tx"]["gas"], keyof {
                asset?: {
                    chain?: string | undefined;
                    symbol?: string | undefined;
                    ticker?: string | undefined;
                    synth?: boolean | undefined;
                } | undefined;
                amount?: string | undefined;
                decimals?: string | number | Long.Long | undefined;
            }[]>, never>) | undefined;
            memo?: string | undefined;
        } & Record<Exclude<keyof I["tx"], keyof Tx>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof EventOutbound>, never>>(object: I): EventOutbound;
};
export declare const EventTssKeygenMetric: {
    encode(message: EventTssKeygenMetric, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventTssKeygenMetric;
    fromJSON(object: any): EventTssKeygenMetric;
    toJSON(message: EventTssKeygenMetric): unknown;
    fromPartial<I extends {
        pubKey?: string | undefined;
        medianDurationMs?: string | number | Long.Long | undefined;
    } & {
        pubKey?: string | undefined;
        medianDurationMs?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["medianDurationMs"], keyof Long.Long>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof EventTssKeygenMetric>, never>>(object: I): EventTssKeygenMetric;
};
export declare const EventTssKeysignMetric: {
    encode(message: EventTssKeysignMetric, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventTssKeysignMetric;
    fromJSON(object: any): EventTssKeysignMetric;
    toJSON(message: EventTssKeysignMetric): unknown;
    fromPartial<I extends {
        txId?: string | undefined;
        medianDurationMs?: string | number | Long.Long | undefined;
    } & {
        txId?: string | undefined;
        medianDurationMs?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["medianDurationMs"], keyof Long.Long>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof EventTssKeysignMetric>, never>>(object: I): EventTssKeysignMetric;
};
export declare const EventSlashPoint: {
    encode(message: EventSlashPoint, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventSlashPoint;
    fromJSON(object: any): EventSlashPoint;
    toJSON(message: EventSlashPoint): unknown;
    fromPartial<I extends {
        nodeAddress?: Uint8Array | undefined;
        slashPoints?: string | number | Long.Long | undefined;
        reason?: string | undefined;
    } & {
        nodeAddress?: Uint8Array | undefined;
        slashPoints?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["slashPoints"], keyof Long.Long>, never>) | undefined;
        reason?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventSlashPoint>, never>>(object: I): EventSlashPoint;
};
export declare const EventPoolBalanceChanged: {
    encode(message: EventPoolBalanceChanged, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventPoolBalanceChanged;
    fromJSON(object: any): EventPoolBalanceChanged;
    toJSON(message: EventPoolBalanceChanged): unknown;
    fromPartial<I extends {
        poolChange?: {
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            runeAmt?: string | undefined;
            runeAdd?: boolean | undefined;
            assetAmt?: string | undefined;
            assetAdd?: boolean | undefined;
        } | undefined;
        reason?: string | undefined;
    } & {
        poolChange?: ({
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            runeAmt?: string | undefined;
            runeAdd?: boolean | undefined;
            assetAmt?: string | undefined;
            assetAdd?: boolean | undefined;
        } & {
            asset?: ({
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } & {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } & Record<Exclude<keyof I["poolChange"]["asset"], keyof Asset>, never>) | undefined;
            runeAmt?: string | undefined;
            runeAdd?: boolean | undefined;
            assetAmt?: string | undefined;
            assetAdd?: boolean | undefined;
        } & Record<Exclude<keyof I["poolChange"], keyof PoolMod>, never>) | undefined;
        reason?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventPoolBalanceChanged>, never>>(object: I): EventPoolBalanceChanged;
};
export declare const EventSwitch: {
    encode(message: EventSwitch, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventSwitch;
    fromJSON(object: any): EventSwitch;
    toJSON(message: EventSwitch): unknown;
    fromPartial<I extends {
        toAddress?: Uint8Array | undefined;
        fromAddress?: string | undefined;
        burn?: {
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            amount?: string | undefined;
            decimals?: string | number | Long.Long | undefined;
        } | undefined;
    } & {
        toAddress?: Uint8Array | undefined;
        fromAddress?: string | undefined;
        burn?: ({
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            amount?: string | undefined;
            decimals?: string | number | Long.Long | undefined;
        } & {
            asset?: ({
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } & {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } & Record<Exclude<keyof I["burn"]["asset"], keyof Asset>, never>) | undefined;
            amount?: string | undefined;
            decimals?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["burn"]["decimals"], keyof Long.Long>, never>) | undefined;
        } & Record<Exclude<keyof I["burn"], keyof Coin>, never>) | undefined;
    } & Record<Exclude<keyof I, keyof EventSwitch>, never>>(object: I): EventSwitch;
};
export declare const EventSwitchV56: {
    encode(message: EventSwitchV56, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventSwitchV56;
    fromJSON(object: any): EventSwitchV56;
    toJSON(message: EventSwitchV56): unknown;
    fromPartial<I extends {
        toAddress?: Uint8Array | undefined;
        fromAddress?: string | undefined;
        burn?: {
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            amount?: string | undefined;
            decimals?: string | number | Long.Long | undefined;
        } | undefined;
        txId?: string | undefined;
    } & {
        toAddress?: Uint8Array | undefined;
        fromAddress?: string | undefined;
        burn?: ({
            asset?: {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } | undefined;
            amount?: string | undefined;
            decimals?: string | number | Long.Long | undefined;
        } & {
            asset?: ({
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } & {
                chain?: string | undefined;
                symbol?: string | undefined;
                ticker?: string | undefined;
                synth?: boolean | undefined;
            } & Record<Exclude<keyof I["burn"]["asset"], keyof Asset>, never>) | undefined;
            amount?: string | undefined;
            decimals?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean | undefined) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number | undefined) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["burn"]["decimals"], keyof Long.Long>, never>) | undefined;
        } & Record<Exclude<keyof I["burn"], keyof Coin>, never>) | undefined;
        txId?: string | undefined;
    } & Record<Exclude<keyof I, keyof EventSwitchV56>, never>>(object: I): EventSwitchV56;
};
export declare const EventTHORName: {
    encode(message: EventTHORName, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventTHORName;
    fromJSON(object: any): EventTHORName;
    toJSON(message: EventTHORName): unknown;
    fromPartial<I extends {
        name?: string | undefined;
        chain?: string | undefined;
        address?: string | undefined;
        registrationFee?: string | undefined;
        fundAmt?: string | undefined;
        expire?: string | number | Long.Long | undefined;
        owner?: Uint8Array | undefined;
    } & {
        name?: string | undefined;
        chain?: string | undefined;
        address?: string | undefined;
        registrationFee?: string | undefined;
        fundAmt?: string | undefined;
        expire?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean | undefined) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number | undefined) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["expire"], keyof Long.Long>, never>) | undefined;
        owner?: Uint8Array | undefined;
    } & Record<Exclude<keyof I, keyof EventTHORName>, never>>(object: I): EventTHORName;
};
