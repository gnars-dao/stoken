"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventTHORName = exports.EventSwitchV56 = exports.EventSwitch = exports.EventPoolBalanceChanged = exports.EventSlashPoint = exports.EventTssKeysignMetric = exports.EventTssKeygenMetric = exports.EventOutbound = exports.EventFee = exports.EventErrata = exports.EventSlash = exports.EventReserve = exports.EventGas = exports.GasPool = exports.EventBond = exports.EventRefund = exports.EventRewards = exports.PoolAmt = exports.EventPool = exports.EventDonate = exports.EventPendingLiquidity = exports.EventWithdraw = exports.EventAddLiquidity = exports.EventSwap = exports.PoolMod = exports.bondTypeToJSON = exports.bondTypeFromJSON = exports.BondType = exports.pendingLiquidityTypeToJSON = exports.pendingLiquidityTypeFromJSON = exports.PendingLiquidityType = void 0;
/* eslint-disable */
var long_1 = __importDefault(require("long"));
var minimal_1 = __importDefault(require("protobufjs/minimal"));
var common_1 = require("../../../../../thorchain/v1/common/common");
var type_pool_1 = require("../../../../../thorchain/v1/x/thorchain/types/type_pool");
var type_reserve_contributor_1 = require("../../../../../thorchain/v1/x/thorchain/types/type_reserve_contributor");
var PendingLiquidityType;
(function (PendingLiquidityType) {
    PendingLiquidityType[PendingLiquidityType["add"] = 0] = "add";
    PendingLiquidityType[PendingLiquidityType["withdraw"] = 1] = "withdraw";
    PendingLiquidityType[PendingLiquidityType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(PendingLiquidityType = exports.PendingLiquidityType || (exports.PendingLiquidityType = {}));
function pendingLiquidityTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "add":
            return PendingLiquidityType.add;
        case 1:
        case "withdraw":
            return PendingLiquidityType.withdraw;
        case -1:
        case "UNRECOGNIZED":
        default:
            return PendingLiquidityType.UNRECOGNIZED;
    }
}
exports.pendingLiquidityTypeFromJSON = pendingLiquidityTypeFromJSON;
function pendingLiquidityTypeToJSON(object) {
    switch (object) {
        case PendingLiquidityType.add:
            return "add";
        case PendingLiquidityType.withdraw:
            return "withdraw";
        default:
            return "UNKNOWN";
    }
}
exports.pendingLiquidityTypeToJSON = pendingLiquidityTypeToJSON;
var BondType;
(function (BondType) {
    BondType[BondType["bond_paid"] = 0] = "bond_paid";
    BondType[BondType["bond_returned"] = 1] = "bond_returned";
    BondType[BondType["bond_reward"] = 2] = "bond_reward";
    BondType[BondType["bond_cost"] = 3] = "bond_cost";
    BondType[BondType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BondType = exports.BondType || (exports.BondType = {}));
function bondTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "bond_paid":
            return BondType.bond_paid;
        case 1:
        case "bond_returned":
            return BondType.bond_returned;
        case 2:
        case "bond_reward":
            return BondType.bond_reward;
        case 3:
        case "bond_cost":
            return BondType.bond_cost;
        case -1:
        case "UNRECOGNIZED":
        default:
            return BondType.UNRECOGNIZED;
    }
}
exports.bondTypeFromJSON = bondTypeFromJSON;
function bondTypeToJSON(object) {
    switch (object) {
        case BondType.bond_paid:
            return "bond_paid";
        case BondType.bond_returned:
            return "bond_returned";
        case BondType.bond_reward:
            return "bond_reward";
        case BondType.bond_cost:
            return "bond_cost";
        default:
            return "UNKNOWN";
    }
}
exports.bondTypeToJSON = bondTypeToJSON;
function createBasePoolMod() {
    return {
        asset: undefined,
        runeAmt: "",
        runeAdd: false,
        assetAmt: "",
        assetAdd: false,
    };
}
exports.PoolMod = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.asset !== undefined) {
            common_1.Asset.encode(message.asset, writer.uint32(10).fork()).ldelim();
        }
        if (message.runeAmt !== "") {
            writer.uint32(18).string(message.runeAmt);
        }
        if (message.runeAdd === true) {
            writer.uint32(24).bool(message.runeAdd);
        }
        if (message.assetAmt !== "") {
            writer.uint32(34).string(message.assetAmt);
        }
        if (message.assetAdd === true) {
            writer.uint32(40).bool(message.assetAdd);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBasePoolMod();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.asset = common_1.Asset.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.runeAmt = reader.string();
                    break;
                case 3:
                    message.runeAdd = reader.bool();
                    break;
                case 4:
                    message.assetAmt = reader.string();
                    break;
                case 5:
                    message.assetAdd = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            asset: isSet(object.asset) ? common_1.Asset.fromJSON(object.asset) : undefined,
            runeAmt: isSet(object.runeAmt) ? String(object.runeAmt) : "",
            runeAdd: isSet(object.runeAdd) ? Boolean(object.runeAdd) : false,
            assetAmt: isSet(object.assetAmt) ? String(object.assetAmt) : "",
            assetAdd: isSet(object.assetAdd) ? Boolean(object.assetAdd) : false,
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.asset !== undefined &&
            (obj.asset = message.asset ? common_1.Asset.toJSON(message.asset) : undefined);
        message.runeAmt !== undefined && (obj.runeAmt = message.runeAmt);
        message.runeAdd !== undefined && (obj.runeAdd = message.runeAdd);
        message.assetAmt !== undefined && (obj.assetAmt = message.assetAmt);
        message.assetAdd !== undefined && (obj.assetAdd = message.assetAdd);
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d;
        var message = createBasePoolMod();
        message.asset =
            object.asset !== undefined && object.asset !== null
                ? common_1.Asset.fromPartial(object.asset)
                : undefined;
        message.runeAmt = (_a = object.runeAmt) !== null && _a !== void 0 ? _a : "";
        message.runeAdd = (_b = object.runeAdd) !== null && _b !== void 0 ? _b : false;
        message.assetAmt = (_c = object.assetAmt) !== null && _c !== void 0 ? _c : "";
        message.assetAdd = (_d = object.assetAdd) !== null && _d !== void 0 ? _d : false;
        return message;
    },
};
function createBaseEventSwap() {
    return {
        pool: undefined,
        swapTarget: "",
        swapSlip: "",
        liquidityFee: "",
        liquidityFeeInRune: "",
        inTx: undefined,
        outTxs: undefined,
        emitAsset: undefined,
        synthUnits: "",
    };
}
exports.EventSwap = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.pool !== undefined) {
            common_1.Asset.encode(message.pool, writer.uint32(10).fork()).ldelim();
        }
        if (message.swapTarget !== "") {
            writer.uint32(18).string(message.swapTarget);
        }
        if (message.swapSlip !== "") {
            writer.uint32(26).string(message.swapSlip);
        }
        if (message.liquidityFee !== "") {
            writer.uint32(34).string(message.liquidityFee);
        }
        if (message.liquidityFeeInRune !== "") {
            writer.uint32(42).string(message.liquidityFeeInRune);
        }
        if (message.inTx !== undefined) {
            common_1.Tx.encode(message.inTx, writer.uint32(50).fork()).ldelim();
        }
        if (message.outTxs !== undefined) {
            common_1.Tx.encode(message.outTxs, writer.uint32(58).fork()).ldelim();
        }
        if (message.emitAsset !== undefined) {
            common_1.Coin.encode(message.emitAsset, writer.uint32(66).fork()).ldelim();
        }
        if (message.synthUnits !== "") {
            writer.uint32(74).string(message.synthUnits);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventSwap();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pool = common_1.Asset.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.swapTarget = reader.string();
                    break;
                case 3:
                    message.swapSlip = reader.string();
                    break;
                case 4:
                    message.liquidityFee = reader.string();
                    break;
                case 5:
                    message.liquidityFeeInRune = reader.string();
                    break;
                case 6:
                    message.inTx = common_1.Tx.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.outTxs = common_1.Tx.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.emitAsset = common_1.Coin.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.synthUnits = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            pool: isSet(object.pool) ? common_1.Asset.fromJSON(object.pool) : undefined,
            swapTarget: isSet(object.swapTarget) ? String(object.swapTarget) : "",
            swapSlip: isSet(object.swapSlip) ? String(object.swapSlip) : "",
            liquidityFee: isSet(object.liquidityFee)
                ? String(object.liquidityFee)
                : "",
            liquidityFeeInRune: isSet(object.liquidityFeeInRune)
                ? String(object.liquidityFeeInRune)
                : "",
            inTx: isSet(object.inTx) ? common_1.Tx.fromJSON(object.inTx) : undefined,
            outTxs: isSet(object.outTxs) ? common_1.Tx.fromJSON(object.outTxs) : undefined,
            emitAsset: isSet(object.emitAsset)
                ? common_1.Coin.fromJSON(object.emitAsset)
                : undefined,
            synthUnits: isSet(object.synthUnits) ? String(object.synthUnits) : "",
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.pool !== undefined &&
            (obj.pool = message.pool ? common_1.Asset.toJSON(message.pool) : undefined);
        message.swapTarget !== undefined && (obj.swapTarget = message.swapTarget);
        message.swapSlip !== undefined && (obj.swapSlip = message.swapSlip);
        message.liquidityFee !== undefined &&
            (obj.liquidityFee = message.liquidityFee);
        message.liquidityFeeInRune !== undefined &&
            (obj.liquidityFeeInRune = message.liquidityFeeInRune);
        message.inTx !== undefined &&
            (obj.inTx = message.inTx ? common_1.Tx.toJSON(message.inTx) : undefined);
        message.outTxs !== undefined &&
            (obj.outTxs = message.outTxs ? common_1.Tx.toJSON(message.outTxs) : undefined);
        message.emitAsset !== undefined &&
            (obj.emitAsset = message.emitAsset
                ? common_1.Coin.toJSON(message.emitAsset)
                : undefined);
        message.synthUnits !== undefined && (obj.synthUnits = message.synthUnits);
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e;
        var message = createBaseEventSwap();
        message.pool =
            object.pool !== undefined && object.pool !== null
                ? common_1.Asset.fromPartial(object.pool)
                : undefined;
        message.swapTarget = (_a = object.swapTarget) !== null && _a !== void 0 ? _a : "";
        message.swapSlip = (_b = object.swapSlip) !== null && _b !== void 0 ? _b : "";
        message.liquidityFee = (_c = object.liquidityFee) !== null && _c !== void 0 ? _c : "";
        message.liquidityFeeInRune = (_d = object.liquidityFeeInRune) !== null && _d !== void 0 ? _d : "";
        message.inTx =
            object.inTx !== undefined && object.inTx !== null
                ? common_1.Tx.fromPartial(object.inTx)
                : undefined;
        message.outTxs =
            object.outTxs !== undefined && object.outTxs !== null
                ? common_1.Tx.fromPartial(object.outTxs)
                : undefined;
        message.emitAsset =
            object.emitAsset !== undefined && object.emitAsset !== null
                ? common_1.Coin.fromPartial(object.emitAsset)
                : undefined;
        message.synthUnits = (_e = object.synthUnits) !== null && _e !== void 0 ? _e : "";
        return message;
    },
};
function createBaseEventAddLiquidity() {
    return {
        pool: undefined,
        providerUnits: "",
        runeAddress: "",
        runeAmount: "",
        assetAmount: "",
        runeTxId: "",
        assetTxId: "",
        assetAddress: "",
    };
}
exports.EventAddLiquidity = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.pool !== undefined) {
            common_1.Asset.encode(message.pool, writer.uint32(10).fork()).ldelim();
        }
        if (message.providerUnits !== "") {
            writer.uint32(18).string(message.providerUnits);
        }
        if (message.runeAddress !== "") {
            writer.uint32(26).string(message.runeAddress);
        }
        if (message.runeAmount !== "") {
            writer.uint32(34).string(message.runeAmount);
        }
        if (message.assetAmount !== "") {
            writer.uint32(42).string(message.assetAmount);
        }
        if (message.runeTxId !== "") {
            writer.uint32(50).string(message.runeTxId);
        }
        if (message.assetTxId !== "") {
            writer.uint32(58).string(message.assetTxId);
        }
        if (message.assetAddress !== "") {
            writer.uint32(66).string(message.assetAddress);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventAddLiquidity();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pool = common_1.Asset.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.providerUnits = reader.string();
                    break;
                case 3:
                    message.runeAddress = reader.string();
                    break;
                case 4:
                    message.runeAmount = reader.string();
                    break;
                case 5:
                    message.assetAmount = reader.string();
                    break;
                case 6:
                    message.runeTxId = reader.string();
                    break;
                case 7:
                    message.assetTxId = reader.string();
                    break;
                case 8:
                    message.assetAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            pool: isSet(object.pool) ? common_1.Asset.fromJSON(object.pool) : undefined,
            providerUnits: isSet(object.providerUnits)
                ? String(object.providerUnits)
                : "",
            runeAddress: isSet(object.runeAddress) ? String(object.runeAddress) : "",
            runeAmount: isSet(object.runeAmount) ? String(object.runeAmount) : "",
            assetAmount: isSet(object.assetAmount) ? String(object.assetAmount) : "",
            runeTxId: isSet(object.runeTxId) ? String(object.runeTxId) : "",
            assetTxId: isSet(object.assetTxId) ? String(object.assetTxId) : "",
            assetAddress: isSet(object.assetAddress)
                ? String(object.assetAddress)
                : "",
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.pool !== undefined &&
            (obj.pool = message.pool ? common_1.Asset.toJSON(message.pool) : undefined);
        message.providerUnits !== undefined &&
            (obj.providerUnits = message.providerUnits);
        message.runeAddress !== undefined &&
            (obj.runeAddress = message.runeAddress);
        message.runeAmount !== undefined && (obj.runeAmount = message.runeAmount);
        message.assetAmount !== undefined &&
            (obj.assetAmount = message.assetAmount);
        message.runeTxId !== undefined && (obj.runeTxId = message.runeTxId);
        message.assetTxId !== undefined && (obj.assetTxId = message.assetTxId);
        message.assetAddress !== undefined &&
            (obj.assetAddress = message.assetAddress);
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e, _f, _g;
        var message = createBaseEventAddLiquidity();
        message.pool =
            object.pool !== undefined && object.pool !== null
                ? common_1.Asset.fromPartial(object.pool)
                : undefined;
        message.providerUnits = (_a = object.providerUnits) !== null && _a !== void 0 ? _a : "";
        message.runeAddress = (_b = object.runeAddress) !== null && _b !== void 0 ? _b : "";
        message.runeAmount = (_c = object.runeAmount) !== null && _c !== void 0 ? _c : "";
        message.assetAmount = (_d = object.assetAmount) !== null && _d !== void 0 ? _d : "";
        message.runeTxId = (_e = object.runeTxId) !== null && _e !== void 0 ? _e : "";
        message.assetTxId = (_f = object.assetTxId) !== null && _f !== void 0 ? _f : "";
        message.assetAddress = (_g = object.assetAddress) !== null && _g !== void 0 ? _g : "";
        return message;
    },
};
function createBaseEventWithdraw() {
    return {
        pool: undefined,
        providerUnits: "",
        basisPoints: long_1.default.ZERO,
        asymmetry: new Uint8Array(),
        inTx: undefined,
        emitAsset: "",
        emitRune: "",
        impLossProtection: "",
    };
}
exports.EventWithdraw = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.pool !== undefined) {
            common_1.Asset.encode(message.pool, writer.uint32(10).fork()).ldelim();
        }
        if (message.providerUnits !== "") {
            writer.uint32(18).string(message.providerUnits);
        }
        if (!message.basisPoints.isZero()) {
            writer.uint32(24).int64(message.basisPoints);
        }
        if (message.asymmetry.length !== 0) {
            writer.uint32(34).bytes(message.asymmetry);
        }
        if (message.inTx !== undefined) {
            common_1.Tx.encode(message.inTx, writer.uint32(42).fork()).ldelim();
        }
        if (message.emitAsset !== "") {
            writer.uint32(50).string(message.emitAsset);
        }
        if (message.emitRune !== "") {
            writer.uint32(58).string(message.emitRune);
        }
        if (message.impLossProtection !== "") {
            writer.uint32(66).string(message.impLossProtection);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventWithdraw();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pool = common_1.Asset.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.providerUnits = reader.string();
                    break;
                case 3:
                    message.basisPoints = reader.int64();
                    break;
                case 4:
                    message.asymmetry = reader.bytes();
                    break;
                case 5:
                    message.inTx = common_1.Tx.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.emitAsset = reader.string();
                    break;
                case 7:
                    message.emitRune = reader.string();
                    break;
                case 8:
                    message.impLossProtection = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            pool: isSet(object.pool) ? common_1.Asset.fromJSON(object.pool) : undefined,
            providerUnits: isSet(object.providerUnits)
                ? String(object.providerUnits)
                : "",
            basisPoints: isSet(object.basisPoints)
                ? long_1.default.fromString(object.basisPoints)
                : long_1.default.ZERO,
            asymmetry: isSet(object.asymmetry)
                ? bytesFromBase64(object.asymmetry)
                : new Uint8Array(),
            inTx: isSet(object.inTx) ? common_1.Tx.fromJSON(object.inTx) : undefined,
            emitAsset: isSet(object.emitAsset) ? String(object.emitAsset) : "",
            emitRune: isSet(object.emitRune) ? String(object.emitRune) : "",
            impLossProtection: isSet(object.impLossProtection)
                ? String(object.impLossProtection)
                : "",
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.pool !== undefined &&
            (obj.pool = message.pool ? common_1.Asset.toJSON(message.pool) : undefined);
        message.providerUnits !== undefined &&
            (obj.providerUnits = message.providerUnits);
        message.basisPoints !== undefined &&
            (obj.basisPoints = (message.basisPoints || long_1.default.ZERO).toString());
        message.asymmetry !== undefined &&
            (obj.asymmetry = base64FromBytes(message.asymmetry !== undefined ? message.asymmetry : new Uint8Array()));
        message.inTx !== undefined &&
            (obj.inTx = message.inTx ? common_1.Tx.toJSON(message.inTx) : undefined);
        message.emitAsset !== undefined && (obj.emitAsset = message.emitAsset);
        message.emitRune !== undefined && (obj.emitRune = message.emitRune);
        message.impLossProtection !== undefined &&
            (obj.impLossProtection = message.impLossProtection);
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e;
        var message = createBaseEventWithdraw();
        message.pool =
            object.pool !== undefined && object.pool !== null
                ? common_1.Asset.fromPartial(object.pool)
                : undefined;
        message.providerUnits = (_a = object.providerUnits) !== null && _a !== void 0 ? _a : "";
        message.basisPoints =
            object.basisPoints !== undefined && object.basisPoints !== null
                ? long_1.default.fromValue(object.basisPoints)
                : long_1.default.ZERO;
        message.asymmetry = (_b = object.asymmetry) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.inTx =
            object.inTx !== undefined && object.inTx !== null
                ? common_1.Tx.fromPartial(object.inTx)
                : undefined;
        message.emitAsset = (_c = object.emitAsset) !== null && _c !== void 0 ? _c : "";
        message.emitRune = (_d = object.emitRune) !== null && _d !== void 0 ? _d : "";
        message.impLossProtection = (_e = object.impLossProtection) !== null && _e !== void 0 ? _e : "";
        return message;
    },
};
function createBaseEventPendingLiquidity() {
    return {
        pool: undefined,
        pendingType: 0,
        runeAddress: "",
        runeAmount: "",
        assetAddress: "",
        assetAmount: "",
        runeTxId: "",
        assetTxId: "",
    };
}
exports.EventPendingLiquidity = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.pool !== undefined) {
            common_1.Asset.encode(message.pool, writer.uint32(10).fork()).ldelim();
        }
        if (message.pendingType !== 0) {
            writer.uint32(16).int32(message.pendingType);
        }
        if (message.runeAddress !== "") {
            writer.uint32(26).string(message.runeAddress);
        }
        if (message.runeAmount !== "") {
            writer.uint32(34).string(message.runeAmount);
        }
        if (message.assetAddress !== "") {
            writer.uint32(42).string(message.assetAddress);
        }
        if (message.assetAmount !== "") {
            writer.uint32(50).string(message.assetAmount);
        }
        if (message.runeTxId !== "") {
            writer.uint32(58).string(message.runeTxId);
        }
        if (message.assetTxId !== "") {
            writer.uint32(66).string(message.assetTxId);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventPendingLiquidity();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pool = common_1.Asset.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.pendingType = reader.int32();
                    break;
                case 3:
                    message.runeAddress = reader.string();
                    break;
                case 4:
                    message.runeAmount = reader.string();
                    break;
                case 5:
                    message.assetAddress = reader.string();
                    break;
                case 6:
                    message.assetAmount = reader.string();
                    break;
                case 7:
                    message.runeTxId = reader.string();
                    break;
                case 8:
                    message.assetTxId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            pool: isSet(object.pool) ? common_1.Asset.fromJSON(object.pool) : undefined,
            pendingType: isSet(object.pendingType)
                ? pendingLiquidityTypeFromJSON(object.pendingType)
                : 0,
            runeAddress: isSet(object.runeAddress) ? String(object.runeAddress) : "",
            runeAmount: isSet(object.runeAmount) ? String(object.runeAmount) : "",
            assetAddress: isSet(object.assetAddress)
                ? String(object.assetAddress)
                : "",
            assetAmount: isSet(object.assetAmount) ? String(object.assetAmount) : "",
            runeTxId: isSet(object.runeTxId) ? String(object.runeTxId) : "",
            assetTxId: isSet(object.assetTxId) ? String(object.assetTxId) : "",
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.pool !== undefined &&
            (obj.pool = message.pool ? common_1.Asset.toJSON(message.pool) : undefined);
        message.pendingType !== undefined &&
            (obj.pendingType = pendingLiquidityTypeToJSON(message.pendingType));
        message.runeAddress !== undefined &&
            (obj.runeAddress = message.runeAddress);
        message.runeAmount !== undefined && (obj.runeAmount = message.runeAmount);
        message.assetAddress !== undefined &&
            (obj.assetAddress = message.assetAddress);
        message.assetAmount !== undefined &&
            (obj.assetAmount = message.assetAmount);
        message.runeTxId !== undefined && (obj.runeTxId = message.runeTxId);
        message.assetTxId !== undefined && (obj.assetTxId = message.assetTxId);
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e, _f, _g;
        var message = createBaseEventPendingLiquidity();
        message.pool =
            object.pool !== undefined && object.pool !== null
                ? common_1.Asset.fromPartial(object.pool)
                : undefined;
        message.pendingType = (_a = object.pendingType) !== null && _a !== void 0 ? _a : 0;
        message.runeAddress = (_b = object.runeAddress) !== null && _b !== void 0 ? _b : "";
        message.runeAmount = (_c = object.runeAmount) !== null && _c !== void 0 ? _c : "";
        message.assetAddress = (_d = object.assetAddress) !== null && _d !== void 0 ? _d : "";
        message.assetAmount = (_e = object.assetAmount) !== null && _e !== void 0 ? _e : "";
        message.runeTxId = (_f = object.runeTxId) !== null && _f !== void 0 ? _f : "";
        message.assetTxId = (_g = object.assetTxId) !== null && _g !== void 0 ? _g : "";
        return message;
    },
};
function createBaseEventDonate() {
    return { pool: undefined, inTx: undefined };
}
exports.EventDonate = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.pool !== undefined) {
            common_1.Asset.encode(message.pool, writer.uint32(10).fork()).ldelim();
        }
        if (message.inTx !== undefined) {
            common_1.Tx.encode(message.inTx, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventDonate();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pool = common_1.Asset.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.inTx = common_1.Tx.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            pool: isSet(object.pool) ? common_1.Asset.fromJSON(object.pool) : undefined,
            inTx: isSet(object.inTx) ? common_1.Tx.fromJSON(object.inTx) : undefined,
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.pool !== undefined &&
            (obj.pool = message.pool ? common_1.Asset.toJSON(message.pool) : undefined);
        message.inTx !== undefined &&
            (obj.inTx = message.inTx ? common_1.Tx.toJSON(message.inTx) : undefined);
        return obj;
    },
    fromPartial: function (object) {
        var message = createBaseEventDonate();
        message.pool =
            object.pool !== undefined && object.pool !== null
                ? common_1.Asset.fromPartial(object.pool)
                : undefined;
        message.inTx =
            object.inTx !== undefined && object.inTx !== null
                ? common_1.Tx.fromPartial(object.inTx)
                : undefined;
        return message;
    },
};
function createBaseEventPool() {
    return { pool: undefined, Status: 0 };
}
exports.EventPool = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.pool !== undefined) {
            common_1.Asset.encode(message.pool, writer.uint32(10).fork()).ldelim();
        }
        if (message.Status !== 0) {
            writer.uint32(16).int32(message.Status);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventPool();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pool = common_1.Asset.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.Status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            pool: isSet(object.pool) ? common_1.Asset.fromJSON(object.pool) : undefined,
            Status: isSet(object.Status) ? (0, type_pool_1.poolStatusFromJSON)(object.Status) : 0,
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.pool !== undefined &&
            (obj.pool = message.pool ? common_1.Asset.toJSON(message.pool) : undefined);
        message.Status !== undefined &&
            (obj.Status = (0, type_pool_1.poolStatusToJSON)(message.Status));
        return obj;
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseEventPool();
        message.pool =
            object.pool !== undefined && object.pool !== null
                ? common_1.Asset.fromPartial(object.pool)
                : undefined;
        message.Status = (_a = object.Status) !== null && _a !== void 0 ? _a : 0;
        return message;
    },
};
function createBasePoolAmt() {
    return { asset: undefined, amount: long_1.default.ZERO };
}
exports.PoolAmt = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.asset !== undefined) {
            common_1.Asset.encode(message.asset, writer.uint32(10).fork()).ldelim();
        }
        if (!message.amount.isZero()) {
            writer.uint32(16).int64(message.amount);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBasePoolAmt();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.asset = common_1.Asset.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.amount = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            asset: isSet(object.asset) ? common_1.Asset.fromJSON(object.asset) : undefined,
            amount: isSet(object.amount) ? long_1.default.fromString(object.amount) : long_1.default.ZERO,
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.asset !== undefined &&
            (obj.asset = message.asset ? common_1.Asset.toJSON(message.asset) : undefined);
        message.amount !== undefined &&
            (obj.amount = (message.amount || long_1.default.ZERO).toString());
        return obj;
    },
    fromPartial: function (object) {
        var message = createBasePoolAmt();
        message.asset =
            object.asset !== undefined && object.asset !== null
                ? common_1.Asset.fromPartial(object.asset)
                : undefined;
        message.amount =
            object.amount !== undefined && object.amount !== null
                ? long_1.default.fromValue(object.amount)
                : long_1.default.ZERO;
        return message;
    },
};
function createBaseEventRewards() {
    return { bondReward: "", poolRewards: [] };
}
exports.EventRewards = {
    encode: function (message, writer) {
        var e_1, _a;
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.bondReward !== "") {
            writer.uint32(10).string(message.bondReward);
        }
        try {
            for (var _b = __values(message.poolRewards), _c = _b.next(); !_c.done; _c = _b.next()) {
                var v = _c.value;
                exports.PoolAmt.encode(v, writer.uint32(18).fork()).ldelim();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventRewards();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.bondReward = reader.string();
                    break;
                case 2:
                    message.poolRewards.push(exports.PoolAmt.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            bondReward: isSet(object.bondReward) ? String(object.bondReward) : "",
            poolRewards: Array.isArray(object === null || object === void 0 ? void 0 : object.poolRewards)
                ? object.poolRewards.map(function (e) { return exports.PoolAmt.fromJSON(e); })
                : [],
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.bondReward !== undefined && (obj.bondReward = message.bondReward);
        if (message.poolRewards) {
            obj.poolRewards = message.poolRewards.map(function (e) {
                return e ? exports.PoolAmt.toJSON(e) : undefined;
            });
        }
        else {
            obj.poolRewards = [];
        }
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseEventRewards();
        message.bondReward = (_a = object.bondReward) !== null && _a !== void 0 ? _a : "";
        message.poolRewards =
            ((_b = object.poolRewards) === null || _b === void 0 ? void 0 : _b.map(function (e) { return exports.PoolAmt.fromPartial(e); })) || [];
        return message;
    },
};
function createBaseEventRefund() {
    return { code: 0, reason: "", inTx: undefined, fee: undefined };
}
exports.EventRefund = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.code !== 0) {
            writer.uint32(8).uint32(message.code);
        }
        if (message.reason !== "") {
            writer.uint32(18).string(message.reason);
        }
        if (message.inTx !== undefined) {
            common_1.Tx.encode(message.inTx, writer.uint32(26).fork()).ldelim();
        }
        if (message.fee !== undefined) {
            common_1.Fee.encode(message.fee, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventRefund();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.code = reader.uint32();
                    break;
                case 2:
                    message.reason = reader.string();
                    break;
                case 3:
                    message.inTx = common_1.Tx.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.fee = common_1.Fee.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            code: isSet(object.code) ? Number(object.code) : 0,
            reason: isSet(object.reason) ? String(object.reason) : "",
            inTx: isSet(object.inTx) ? common_1.Tx.fromJSON(object.inTx) : undefined,
            fee: isSet(object.fee) ? common_1.Fee.fromJSON(object.fee) : undefined,
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.code !== undefined && (obj.code = Math.round(message.code));
        message.reason !== undefined && (obj.reason = message.reason);
        message.inTx !== undefined &&
            (obj.inTx = message.inTx ? common_1.Tx.toJSON(message.inTx) : undefined);
        message.fee !== undefined &&
            (obj.fee = message.fee ? common_1.Fee.toJSON(message.fee) : undefined);
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseEventRefund();
        message.code = (_a = object.code) !== null && _a !== void 0 ? _a : 0;
        message.reason = (_b = object.reason) !== null && _b !== void 0 ? _b : "";
        message.inTx =
            object.inTx !== undefined && object.inTx !== null
                ? common_1.Tx.fromPartial(object.inTx)
                : undefined;
        message.fee =
            object.fee !== undefined && object.fee !== null
                ? common_1.Fee.fromPartial(object.fee)
                : undefined;
        return message;
    },
};
function createBaseEventBond() {
    return { amount: "", bondType: 0, txIn: undefined };
}
exports.EventBond = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.amount !== "") {
            writer.uint32(10).string(message.amount);
        }
        if (message.bondType !== 0) {
            writer.uint32(16).int32(message.bondType);
        }
        if (message.txIn !== undefined) {
            common_1.Tx.encode(message.txIn, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventBond();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.amount = reader.string();
                    break;
                case 2:
                    message.bondType = reader.int32();
                    break;
                case 3:
                    message.txIn = common_1.Tx.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            amount: isSet(object.amount) ? String(object.amount) : "",
            bondType: isSet(object.bondType) ? bondTypeFromJSON(object.bondType) : 0,
            txIn: isSet(object.txIn) ? common_1.Tx.fromJSON(object.txIn) : undefined,
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.amount !== undefined && (obj.amount = message.amount);
        message.bondType !== undefined &&
            (obj.bondType = bondTypeToJSON(message.bondType));
        message.txIn !== undefined &&
            (obj.txIn = message.txIn ? common_1.Tx.toJSON(message.txIn) : undefined);
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseEventBond();
        message.amount = (_a = object.amount) !== null && _a !== void 0 ? _a : "";
        message.bondType = (_b = object.bondType) !== null && _b !== void 0 ? _b : 0;
        message.txIn =
            object.txIn !== undefined && object.txIn !== null
                ? common_1.Tx.fromPartial(object.txIn)
                : undefined;
        return message;
    },
};
function createBaseGasPool() {
    return { asset: undefined, runeAmt: "", assetAmt: "", count: long_1.default.ZERO };
}
exports.GasPool = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.asset !== undefined) {
            common_1.Asset.encode(message.asset, writer.uint32(10).fork()).ldelim();
        }
        if (message.runeAmt !== "") {
            writer.uint32(18).string(message.runeAmt);
        }
        if (message.assetAmt !== "") {
            writer.uint32(26).string(message.assetAmt);
        }
        if (!message.count.isZero()) {
            writer.uint32(32).int64(message.count);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseGasPool();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.asset = common_1.Asset.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.runeAmt = reader.string();
                    break;
                case 3:
                    message.assetAmt = reader.string();
                    break;
                case 4:
                    message.count = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            asset: isSet(object.asset) ? common_1.Asset.fromJSON(object.asset) : undefined,
            runeAmt: isSet(object.runeAmt) ? String(object.runeAmt) : "",
            assetAmt: isSet(object.assetAmt) ? String(object.assetAmt) : "",
            count: isSet(object.count) ? long_1.default.fromString(object.count) : long_1.default.ZERO,
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.asset !== undefined &&
            (obj.asset = message.asset ? common_1.Asset.toJSON(message.asset) : undefined);
        message.runeAmt !== undefined && (obj.runeAmt = message.runeAmt);
        message.assetAmt !== undefined && (obj.assetAmt = message.assetAmt);
        message.count !== undefined &&
            (obj.count = (message.count || long_1.default.ZERO).toString());
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseGasPool();
        message.asset =
            object.asset !== undefined && object.asset !== null
                ? common_1.Asset.fromPartial(object.asset)
                : undefined;
        message.runeAmt = (_a = object.runeAmt) !== null && _a !== void 0 ? _a : "";
        message.assetAmt = (_b = object.assetAmt) !== null && _b !== void 0 ? _b : "";
        message.count =
            object.count !== undefined && object.count !== null
                ? long_1.default.fromValue(object.count)
                : long_1.default.ZERO;
        return message;
    },
};
function createBaseEventGas() {
    return { pools: [] };
}
exports.EventGas = {
    encode: function (message, writer) {
        var e_2, _a;
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        try {
            for (var _b = __values(message.pools), _c = _b.next(); !_c.done; _c = _b.next()) {
                var v = _c.value;
                exports.GasPool.encode(v, writer.uint32(10).fork()).ldelim();
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventGas();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pools.push(exports.GasPool.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            pools: Array.isArray(object === null || object === void 0 ? void 0 : object.pools)
                ? object.pools.map(function (e) { return exports.GasPool.fromJSON(e); })
                : [],
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.pools) {
            obj.pools = message.pools.map(function (e) { return (e ? exports.GasPool.toJSON(e) : undefined); });
        }
        else {
            obj.pools = [];
        }
        return obj;
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseEventGas();
        message.pools = ((_a = object.pools) === null || _a === void 0 ? void 0 : _a.map(function (e) { return exports.GasPool.fromPartial(e); })) || [];
        return message;
    },
};
function createBaseEventReserve() {
    return { reserveContributor: undefined, inTx: undefined };
}
exports.EventReserve = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.reserveContributor !== undefined) {
            type_reserve_contributor_1.ReserveContributor.encode(message.reserveContributor, writer.uint32(10).fork()).ldelim();
        }
        if (message.inTx !== undefined) {
            common_1.Tx.encode(message.inTx, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventReserve();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.reserveContributor = type_reserve_contributor_1.ReserveContributor.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.inTx = common_1.Tx.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            reserveContributor: isSet(object.reserveContributor)
                ? type_reserve_contributor_1.ReserveContributor.fromJSON(object.reserveContributor)
                : undefined,
            inTx: isSet(object.inTx) ? common_1.Tx.fromJSON(object.inTx) : undefined,
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.reserveContributor !== undefined &&
            (obj.reserveContributor = message.reserveContributor
                ? type_reserve_contributor_1.ReserveContributor.toJSON(message.reserveContributor)
                : undefined);
        message.inTx !== undefined &&
            (obj.inTx = message.inTx ? common_1.Tx.toJSON(message.inTx) : undefined);
        return obj;
    },
    fromPartial: function (object) {
        var message = createBaseEventReserve();
        message.reserveContributor =
            object.reserveContributor !== undefined &&
                object.reserveContributor !== null
                ? type_reserve_contributor_1.ReserveContributor.fromPartial(object.reserveContributor)
                : undefined;
        message.inTx =
            object.inTx !== undefined && object.inTx !== null
                ? common_1.Tx.fromPartial(object.inTx)
                : undefined;
        return message;
    },
};
function createBaseEventSlash() {
    return { pool: undefined, slashAmount: [] };
}
exports.EventSlash = {
    encode: function (message, writer) {
        var e_3, _a;
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.pool !== undefined) {
            common_1.Asset.encode(message.pool, writer.uint32(10).fork()).ldelim();
        }
        try {
            for (var _b = __values(message.slashAmount), _c = _b.next(); !_c.done; _c = _b.next()) {
                var v = _c.value;
                exports.PoolAmt.encode(v, writer.uint32(18).fork()).ldelim();
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventSlash();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pool = common_1.Asset.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.slashAmount.push(exports.PoolAmt.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            pool: isSet(object.pool) ? common_1.Asset.fromJSON(object.pool) : undefined,
            slashAmount: Array.isArray(object === null || object === void 0 ? void 0 : object.slashAmount)
                ? object.slashAmount.map(function (e) { return exports.PoolAmt.fromJSON(e); })
                : [],
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.pool !== undefined &&
            (obj.pool = message.pool ? common_1.Asset.toJSON(message.pool) : undefined);
        if (message.slashAmount) {
            obj.slashAmount = message.slashAmount.map(function (e) {
                return e ? exports.PoolAmt.toJSON(e) : undefined;
            });
        }
        else {
            obj.slashAmount = [];
        }
        return obj;
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseEventSlash();
        message.pool =
            object.pool !== undefined && object.pool !== null
                ? common_1.Asset.fromPartial(object.pool)
                : undefined;
        message.slashAmount =
            ((_a = object.slashAmount) === null || _a === void 0 ? void 0 : _a.map(function (e) { return exports.PoolAmt.fromPartial(e); })) || [];
        return message;
    },
};
function createBaseEventErrata() {
    return { txId: "", pools: [] };
}
exports.EventErrata = {
    encode: function (message, writer) {
        var e_4, _a;
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.txId !== "") {
            writer.uint32(10).string(message.txId);
        }
        try {
            for (var _b = __values(message.pools), _c = _b.next(); !_c.done; _c = _b.next()) {
                var v = _c.value;
                exports.PoolMod.encode(v, writer.uint32(18).fork()).ldelim();
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventErrata();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.txId = reader.string();
                    break;
                case 2:
                    message.pools.push(exports.PoolMod.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            txId: isSet(object.txId) ? String(object.txId) : "",
            pools: Array.isArray(object === null || object === void 0 ? void 0 : object.pools)
                ? object.pools.map(function (e) { return exports.PoolMod.fromJSON(e); })
                : [],
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.txId !== undefined && (obj.txId = message.txId);
        if (message.pools) {
            obj.pools = message.pools.map(function (e) { return (e ? exports.PoolMod.toJSON(e) : undefined); });
        }
        else {
            obj.pools = [];
        }
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseEventErrata();
        message.txId = (_a = object.txId) !== null && _a !== void 0 ? _a : "";
        message.pools = ((_b = object.pools) === null || _b === void 0 ? void 0 : _b.map(function (e) { return exports.PoolMod.fromPartial(e); })) || [];
        return message;
    },
};
function createBaseEventFee() {
    return { txId: "", fee: undefined, synthUnits: "" };
}
exports.EventFee = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.txId !== "") {
            writer.uint32(10).string(message.txId);
        }
        if (message.fee !== undefined) {
            common_1.Fee.encode(message.fee, writer.uint32(18).fork()).ldelim();
        }
        if (message.synthUnits !== "") {
            writer.uint32(26).string(message.synthUnits);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventFee();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.txId = reader.string();
                    break;
                case 2:
                    message.fee = common_1.Fee.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.synthUnits = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            txId: isSet(object.txId) ? String(object.txId) : "",
            fee: isSet(object.fee) ? common_1.Fee.fromJSON(object.fee) : undefined,
            synthUnits: isSet(object.synthUnits) ? String(object.synthUnits) : "",
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.txId !== undefined && (obj.txId = message.txId);
        message.fee !== undefined &&
            (obj.fee = message.fee ? common_1.Fee.toJSON(message.fee) : undefined);
        message.synthUnits !== undefined && (obj.synthUnits = message.synthUnits);
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseEventFee();
        message.txId = (_a = object.txId) !== null && _a !== void 0 ? _a : "";
        message.fee =
            object.fee !== undefined && object.fee !== null
                ? common_1.Fee.fromPartial(object.fee)
                : undefined;
        message.synthUnits = (_b = object.synthUnits) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseEventOutbound() {
    return { inTxId: "", tx: undefined };
}
exports.EventOutbound = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.inTxId !== "") {
            writer.uint32(10).string(message.inTxId);
        }
        if (message.tx !== undefined) {
            common_1.Tx.encode(message.tx, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventOutbound();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.inTxId = reader.string();
                    break;
                case 2:
                    message.tx = common_1.Tx.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            inTxId: isSet(object.inTxId) ? String(object.inTxId) : "",
            tx: isSet(object.tx) ? common_1.Tx.fromJSON(object.tx) : undefined,
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.inTxId !== undefined && (obj.inTxId = message.inTxId);
        message.tx !== undefined &&
            (obj.tx = message.tx ? common_1.Tx.toJSON(message.tx) : undefined);
        return obj;
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseEventOutbound();
        message.inTxId = (_a = object.inTxId) !== null && _a !== void 0 ? _a : "";
        message.tx =
            object.tx !== undefined && object.tx !== null
                ? common_1.Tx.fromPartial(object.tx)
                : undefined;
        return message;
    },
};
function createBaseEventTssKeygenMetric() {
    return { pubKey: "", medianDurationMs: long_1.default.ZERO };
}
exports.EventTssKeygenMetric = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.pubKey !== "") {
            writer.uint32(10).string(message.pubKey);
        }
        if (!message.medianDurationMs.isZero()) {
            writer.uint32(16).int64(message.medianDurationMs);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventTssKeygenMetric();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pubKey = reader.string();
                    break;
                case 2:
                    message.medianDurationMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            pubKey: isSet(object.pubKey) ? String(object.pubKey) : "",
            medianDurationMs: isSet(object.medianDurationMs)
                ? long_1.default.fromString(object.medianDurationMs)
                : long_1.default.ZERO,
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.pubKey !== undefined && (obj.pubKey = message.pubKey);
        message.medianDurationMs !== undefined &&
            (obj.medianDurationMs = (message.medianDurationMs || long_1.default.ZERO).toString());
        return obj;
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseEventTssKeygenMetric();
        message.pubKey = (_a = object.pubKey) !== null && _a !== void 0 ? _a : "";
        message.medianDurationMs =
            object.medianDurationMs !== undefined && object.medianDurationMs !== null
                ? long_1.default.fromValue(object.medianDurationMs)
                : long_1.default.ZERO;
        return message;
    },
};
function createBaseEventTssKeysignMetric() {
    return { txId: "", medianDurationMs: long_1.default.ZERO };
}
exports.EventTssKeysignMetric = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.txId !== "") {
            writer.uint32(10).string(message.txId);
        }
        if (!message.medianDurationMs.isZero()) {
            writer.uint32(16).int64(message.medianDurationMs);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventTssKeysignMetric();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.txId = reader.string();
                    break;
                case 2:
                    message.medianDurationMs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            txId: isSet(object.txId) ? String(object.txId) : "",
            medianDurationMs: isSet(object.medianDurationMs)
                ? long_1.default.fromString(object.medianDurationMs)
                : long_1.default.ZERO,
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.txId !== undefined && (obj.txId = message.txId);
        message.medianDurationMs !== undefined &&
            (obj.medianDurationMs = (message.medianDurationMs || long_1.default.ZERO).toString());
        return obj;
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseEventTssKeysignMetric();
        message.txId = (_a = object.txId) !== null && _a !== void 0 ? _a : "";
        message.medianDurationMs =
            object.medianDurationMs !== undefined && object.medianDurationMs !== null
                ? long_1.default.fromValue(object.medianDurationMs)
                : long_1.default.ZERO;
        return message;
    },
};
function createBaseEventSlashPoint() {
    return { nodeAddress: new Uint8Array(), slashPoints: long_1.default.ZERO, reason: "" };
}
exports.EventSlashPoint = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.nodeAddress.length !== 0) {
            writer.uint32(10).bytes(message.nodeAddress);
        }
        if (!message.slashPoints.isZero()) {
            writer.uint32(16).int64(message.slashPoints);
        }
        if (message.reason !== "") {
            writer.uint32(26).string(message.reason);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventSlashPoint();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.nodeAddress = reader.bytes();
                    break;
                case 2:
                    message.slashPoints = reader.int64();
                    break;
                case 3:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            nodeAddress: isSet(object.nodeAddress)
                ? bytesFromBase64(object.nodeAddress)
                : new Uint8Array(),
            slashPoints: isSet(object.slashPoints)
                ? long_1.default.fromString(object.slashPoints)
                : long_1.default.ZERO,
            reason: isSet(object.reason) ? String(object.reason) : "",
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.nodeAddress !== undefined &&
            (obj.nodeAddress = base64FromBytes(message.nodeAddress !== undefined
                ? message.nodeAddress
                : new Uint8Array()));
        message.slashPoints !== undefined &&
            (obj.slashPoints = (message.slashPoints || long_1.default.ZERO).toString());
        message.reason !== undefined && (obj.reason = message.reason);
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseEventSlashPoint();
        message.nodeAddress = (_a = object.nodeAddress) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.slashPoints =
            object.slashPoints !== undefined && object.slashPoints !== null
                ? long_1.default.fromValue(object.slashPoints)
                : long_1.default.ZERO;
        message.reason = (_b = object.reason) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseEventPoolBalanceChanged() {
    return { poolChange: undefined, reason: "" };
}
exports.EventPoolBalanceChanged = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.poolChange !== undefined) {
            exports.PoolMod.encode(message.poolChange, writer.uint32(10).fork()).ldelim();
        }
        if (message.reason !== "") {
            writer.uint32(18).string(message.reason);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventPoolBalanceChanged();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.poolChange = exports.PoolMod.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            poolChange: isSet(object.poolChange)
                ? exports.PoolMod.fromJSON(object.poolChange)
                : undefined,
            reason: isSet(object.reason) ? String(object.reason) : "",
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.poolChange !== undefined &&
            (obj.poolChange = message.poolChange
                ? exports.PoolMod.toJSON(message.poolChange)
                : undefined);
        message.reason !== undefined && (obj.reason = message.reason);
        return obj;
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseEventPoolBalanceChanged();
        message.poolChange =
            object.poolChange !== undefined && object.poolChange !== null
                ? exports.PoolMod.fromPartial(object.poolChange)
                : undefined;
        message.reason = (_a = object.reason) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseEventSwitch() {
    return { toAddress: new Uint8Array(), fromAddress: "", burn: undefined };
}
exports.EventSwitch = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.toAddress.length !== 0) {
            writer.uint32(10).bytes(message.toAddress);
        }
        if (message.fromAddress !== "") {
            writer.uint32(18).string(message.fromAddress);
        }
        if (message.burn !== undefined) {
            common_1.Coin.encode(message.burn, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventSwitch();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.toAddress = reader.bytes();
                    break;
                case 2:
                    message.fromAddress = reader.string();
                    break;
                case 3:
                    message.burn = common_1.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            toAddress: isSet(object.toAddress)
                ? bytesFromBase64(object.toAddress)
                : new Uint8Array(),
            fromAddress: isSet(object.fromAddress) ? String(object.fromAddress) : "",
            burn: isSet(object.burn) ? common_1.Coin.fromJSON(object.burn) : undefined,
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.toAddress !== undefined &&
            (obj.toAddress = base64FromBytes(message.toAddress !== undefined ? message.toAddress : new Uint8Array()));
        message.fromAddress !== undefined &&
            (obj.fromAddress = message.fromAddress);
        message.burn !== undefined &&
            (obj.burn = message.burn ? common_1.Coin.toJSON(message.burn) : undefined);
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseEventSwitch();
        message.toAddress = (_a = object.toAddress) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.fromAddress = (_b = object.fromAddress) !== null && _b !== void 0 ? _b : "";
        message.burn =
            object.burn !== undefined && object.burn !== null
                ? common_1.Coin.fromPartial(object.burn)
                : undefined;
        return message;
    },
};
function createBaseEventSwitchV56() {
    return {
        toAddress: new Uint8Array(),
        fromAddress: "",
        burn: undefined,
        txId: "",
    };
}
exports.EventSwitchV56 = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.toAddress.length !== 0) {
            writer.uint32(10).bytes(message.toAddress);
        }
        if (message.fromAddress !== "") {
            writer.uint32(18).string(message.fromAddress);
        }
        if (message.burn !== undefined) {
            common_1.Coin.encode(message.burn, writer.uint32(26).fork()).ldelim();
        }
        if (message.txId !== "") {
            writer.uint32(34).string(message.txId);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventSwitchV56();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.toAddress = reader.bytes();
                    break;
                case 2:
                    message.fromAddress = reader.string();
                    break;
                case 3:
                    message.burn = common_1.Coin.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.txId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            toAddress: isSet(object.toAddress)
                ? bytesFromBase64(object.toAddress)
                : new Uint8Array(),
            fromAddress: isSet(object.fromAddress) ? String(object.fromAddress) : "",
            burn: isSet(object.burn) ? common_1.Coin.fromJSON(object.burn) : undefined,
            txId: isSet(object.txId) ? String(object.txId) : "",
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.toAddress !== undefined &&
            (obj.toAddress = base64FromBytes(message.toAddress !== undefined ? message.toAddress : new Uint8Array()));
        message.fromAddress !== undefined &&
            (obj.fromAddress = message.fromAddress);
        message.burn !== undefined &&
            (obj.burn = message.burn ? common_1.Coin.toJSON(message.burn) : undefined);
        message.txId !== undefined && (obj.txId = message.txId);
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b, _c;
        var message = createBaseEventSwitchV56();
        message.toAddress = (_a = object.toAddress) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.fromAddress = (_b = object.fromAddress) !== null && _b !== void 0 ? _b : "";
        message.burn =
            object.burn !== undefined && object.burn !== null
                ? common_1.Coin.fromPartial(object.burn)
                : undefined;
        message.txId = (_c = object.txId) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseEventTHORName() {
    return {
        name: "",
        chain: "",
        address: "",
        registrationFee: "",
        fundAmt: "",
        expire: long_1.default.ZERO,
        owner: new Uint8Array(),
    };
}
exports.EventTHORName = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = minimal_1.default.Writer.create(); }
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.chain !== "") {
            writer.uint32(18).string(message.chain);
        }
        if (message.address !== "") {
            writer.uint32(26).string(message.address);
        }
        if (message.registrationFee !== "") {
            writer.uint32(34).string(message.registrationFee);
        }
        if (message.fundAmt !== "") {
            writer.uint32(42).string(message.fundAmt);
        }
        if (!message.expire.isZero()) {
            writer.uint32(48).int64(message.expire);
        }
        if (message.owner.length !== 0) {
            writer.uint32(58).bytes(message.owner);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseEventTHORName();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.chain = reader.string();
                    break;
                case 3:
                    message.address = reader.string();
                    break;
                case 4:
                    message.registrationFee = reader.string();
                    break;
                case 5:
                    message.fundAmt = reader.string();
                    break;
                case 6:
                    message.expire = reader.int64();
                    break;
                case 7:
                    message.owner = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            name: isSet(object.name) ? String(object.name) : "",
            chain: isSet(object.chain) ? String(object.chain) : "",
            address: isSet(object.address) ? String(object.address) : "",
            registrationFee: isSet(object.registrationFee)
                ? String(object.registrationFee)
                : "",
            fundAmt: isSet(object.fundAmt) ? String(object.fundAmt) : "",
            expire: isSet(object.expire) ? long_1.default.fromString(object.expire) : long_1.default.ZERO,
            owner: isSet(object.owner)
                ? bytesFromBase64(object.owner)
                : new Uint8Array(),
        };
    },
    toJSON: function (message) {
        var obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.chain !== undefined && (obj.chain = message.chain);
        message.address !== undefined && (obj.address = message.address);
        message.registrationFee !== undefined &&
            (obj.registrationFee = message.registrationFee);
        message.fundAmt !== undefined && (obj.fundAmt = message.fundAmt);
        message.expire !== undefined &&
            (obj.expire = (message.expire || long_1.default.ZERO).toString());
        message.owner !== undefined &&
            (obj.owner = base64FromBytes(message.owner !== undefined ? message.owner : new Uint8Array()));
        return obj;
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e, _f;
        var message = createBaseEventTHORName();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.chain = (_b = object.chain) !== null && _b !== void 0 ? _b : "";
        message.address = (_c = object.address) !== null && _c !== void 0 ? _c : "";
        message.registrationFee = (_d = object.registrationFee) !== null && _d !== void 0 ? _d : "";
        message.fundAmt = (_e = object.fundAmt) !== null && _e !== void 0 ? _e : "";
        message.expire =
            object.expire !== undefined && object.expire !== null
                ? long_1.default.fromValue(object.expire)
                : long_1.default.ZERO;
        message.owner = (_f = object.owner) !== null && _f !== void 0 ? _f : new Uint8Array();
        return message;
    },
};
var globalThis = (function () {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
var atob = globalThis.atob ||
    (function (b64) { return globalThis.Buffer.from(b64, "base64").toString("binary"); });
function bytesFromBase64(b64) {
    var bin = atob(b64);
    var arr = new Uint8Array(bin.length);
    for (var i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
var btoa = globalThis.btoa ||
    (function (bin) { return globalThis.Buffer.from(bin, "binary").toString("base64"); });
function base64FromBytes(arr) {
    var e_5, _a;
    var bin = [];
    try {
        for (var arr_1 = __values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
            var byte = arr_1_1.value;
            bin.push(String.fromCharCode(byte));
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);
        }
        finally { if (e_5) throw e_5.error; }
    }
    return btoa(bin.join(""));
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
