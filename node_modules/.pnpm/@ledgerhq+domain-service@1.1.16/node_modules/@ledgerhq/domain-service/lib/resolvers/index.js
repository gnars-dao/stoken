"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveAddress = exports.resolveDomain = void 0;
const axios_1 = __importDefault(require("axios"));
const eip55_1 = __importDefault(require("eip55"));
const logs_1 = require("@ledgerhq/logs");
const utils_1 = require("../utils");
const registries_1 = require("../registries");
/**
 * Get an array of addresses for a domain
 *
 * @param {string} domain
 * @returns {Promise<DomainServiceResolution[]>}
 */
const resolveDomain = (domain, registryName) => __awaiter(void 0, void 0, void 0, function* () {
    const registries = yield (() => __awaiter(void 0, void 0, void 0, function* () {
        if (registryName) {
            const registries = yield (0, registries_1.getRegistries)();
            const registry = registries.find(r => r.name === registryName && r.patterns.forward.test(domain));
            return registry
                ? [registry]
                : /* istanbul ignore next: don't test emptiness of resolutions */ [];
        }
        return (0, registries_1.getRegistriesForDomain)(domain);
    }))();
    const responses = (0, utils_1.allSettled)(registries.map(registry => axios_1.default.request({
        method: "GET",
        url: registry.resolvers.forward.replace("{name}", domain),
    })));
    return responses.then(promises => promises.reduce((result, promise, index) => {
        var _a;
        if (promise.status !== "fulfilled") {
            // ignore 404 error
            /* istanbul ignore next: don't test logs */
            if (axios_1.default.isAxiosError(promise.reason) && ((_a = promise.reason.response) === null || _a === void 0 ? void 0 : _a.status) !== 404) {
                (0, logs_1.log)("domain-service", "failed to resolve a domain", {
                    domain,
                    error: promise.reason,
                });
            }
            return result;
        }
        if (!promise.value.data)
            return result;
        const checksummedAddress = (() => {
            try {
                return eip55_1.default.encode(promise.value.data);
            }
            catch (e) {
                return promise.value.data;
            }
        })();
        result.push({
            registry: registries[index].name,
            address: checksummedAddress,
            domain,
            type: "forward",
        });
        return result;
    }, []));
});
exports.resolveDomain = resolveDomain;
/**
 * Get an array of domains for an address
 *
 * @param {string} address
 * @returns {Promise<DomainServiceResolution[]>}
 */
const resolveAddress = (address, registryName) => __awaiter(void 0, void 0, void 0, function* () {
    const registries = yield (() => __awaiter(void 0, void 0, void 0, function* () {
        if (registryName) {
            const registries = yield (0, registries_1.getRegistries)();
            const registry = registries.find(r => r.name === registryName && r.patterns.reverse.test(address));
            return registry
                ? [registry]
                : /* istanbul ignore next: don't test emptiness of resolutions */ [];
        }
        return (0, registries_1.getRegistriesForAddress)(address);
    }))();
    const checksummedAddress = (() => {
        try {
            return eip55_1.default.encode(address);
        }
        catch (e) {
            return address;
        }
    })();
    const responses = (0, utils_1.allSettled)(registries.map(registry => axios_1.default.request({
        method: "GET",
        url: registry.resolvers.reverse.replace("{address}", address),
    })));
    return responses.then(promises => promises.reduce((result, promise, index) => {
        var _a;
        if (promise.status !== "fulfilled") {
            // ignore 404 error
            /* istanbul ignore next: don't test logs */
            if (axios_1.default.isAxiosError(promise.reason) && ((_a = promise.reason.response) === null || _a === void 0 ? void 0 : _a.status) !== 404) {
                (0, logs_1.log)("domain-service", "failed to resolve a address", {
                    address,
                    error: promise.reason,
                });
            }
            return result;
        }
        if (!promise.value.data)
            return result;
        result.push({
            registry: registries[index].name,
            domain: promise.value.data,
            address: checksummedAddress,
            type: "reverse",
        });
        return result;
    }, []));
});
exports.resolveAddress = resolveAddress;
//# sourceMappingURL=index.js.map