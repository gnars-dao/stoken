var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import axios from "axios";
import eip55 from "eip55";
import { log } from "@ledgerhq/logs";
import { allSettled } from "../utils";
import { getRegistries, getRegistriesForAddress, getRegistriesForDomain } from "../registries";
/**
 * Get an array of addresses for a domain
 *
 * @param {string} domain
 * @returns {Promise<DomainServiceResolution[]>}
 */
export const resolveDomain = (domain, registryName) => __awaiter(void 0, void 0, void 0, function* () {
    const registries = yield (() => __awaiter(void 0, void 0, void 0, function* () {
        if (registryName) {
            const registries = yield getRegistries();
            const registry = registries.find(r => r.name === registryName && r.patterns.forward.test(domain));
            return registry
                ? [registry]
                : /* istanbul ignore next: don't test emptiness of resolutions */ [];
        }
        return getRegistriesForDomain(domain);
    }))();
    const responses = allSettled(registries.map(registry => axios.request({
        method: "GET",
        url: registry.resolvers.forward.replace("{name}", domain),
    })));
    return responses.then(promises => promises.reduce((result, promise, index) => {
        var _a;
        if (promise.status !== "fulfilled") {
            // ignore 404 error
            /* istanbul ignore next: don't test logs */
            if (axios.isAxiosError(promise.reason) && ((_a = promise.reason.response) === null || _a === void 0 ? void 0 : _a.status) !== 404) {
                log("domain-service", "failed to resolve a domain", {
                    domain,
                    error: promise.reason,
                });
            }
            return result;
        }
        if (!promise.value.data)
            return result;
        const checksummedAddress = (() => {
            try {
                return eip55.encode(promise.value.data);
            }
            catch (e) {
                return promise.value.data;
            }
        })();
        result.push({
            registry: registries[index].name,
            address: checksummedAddress,
            domain,
            type: "forward",
        });
        return result;
    }, []));
});
/**
 * Get an array of domains for an address
 *
 * @param {string} address
 * @returns {Promise<DomainServiceResolution[]>}
 */
export const resolveAddress = (address, registryName) => __awaiter(void 0, void 0, void 0, function* () {
    const registries = yield (() => __awaiter(void 0, void 0, void 0, function* () {
        if (registryName) {
            const registries = yield getRegistries();
            const registry = registries.find(r => r.name === registryName && r.patterns.reverse.test(address));
            return registry
                ? [registry]
                : /* istanbul ignore next: don't test emptiness of resolutions */ [];
        }
        return getRegistriesForAddress(address);
    }))();
    const checksummedAddress = (() => {
        try {
            return eip55.encode(address);
        }
        catch (e) {
            return address;
        }
    })();
    const responses = allSettled(registries.map(registry => axios.request({
        method: "GET",
        url: registry.resolvers.reverse.replace("{address}", address),
    })));
    return responses.then(promises => promises.reduce((result, promise, index) => {
        var _a;
        if (promise.status !== "fulfilled") {
            // ignore 404 error
            /* istanbul ignore next: don't test logs */
            if (axios.isAxiosError(promise.reason) && ((_a = promise.reason.response) === null || _a === void 0 ? void 0 : _a.status) !== 404) {
                log("domain-service", "failed to resolve a address", {
                    address,
                    error: promise.reason,
                });
            }
            return result;
        }
        if (!promise.value.data)
            return result;
        result.push({
            registry: registries[index].name,
            domain: promise.value.data,
            address: checksummedAddress,
            type: "reverse",
        });
        return result;
    }, []));
});
//# sourceMappingURL=index.js.map