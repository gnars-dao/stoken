"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeychainSDK = void 0;
const dhive_1 = require("@hiveio/dhive");
const uuid_1 = require("uuid");
const login_1 = require("./utils/login");
const Dhive = require('@hiveio/dhive');
const client = new dhive_1.Client([
    'https://api.hive.blog',
    'https://api.openhive.network',
    'https://api.deathwing.me',
]);
/**
 * @description
 * KeychainSDK Class.
 * Contains utils methods & easy Keychain requests to perform operations/requests on HIVE network.
 * @example
 * //To create and use in a file.
 * import { KeychainSDK } from "keychain-sdk";
 *
 * const keychain = new KeychainSDK(window);
 * //After instantiated, is ready to use, for example in a login request
 *   try {
 *     const login = await keychain.login(
 *       {
 *         username: 'keychain.tests',
 *         message: '{"login":"123"}',
 *         method: 'posting',
 *         title: 'LOGIN',
 *       },
 *       {},
 *     );
 *     console.log({ login });
 *   } catch (error) {
 *     console.log({ error });
 *   }
 * @see KeychainSDK.login function documentation for details of this member method.
 * @export KeychainSDK class
 * @class KeychainSDK
 */
class KeychainSDK {
    constructor(window, options) {
        /**
         * @description
         * Keychain SDK utils functions.
         * Will check if window object set & keychain extension installed/detected
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         * try {
         *     const installed = await keychain.isKeychainInstalled();
         *     console.log({ installed });
         *   } catch (error) {
         *     console.log({ installed });
         *   }
         * @memberof KeychainSDK
         * @returns Promise, true if installed/detected
         */
        this.isKeychainInstalled = () => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                if (this.window.hive_keychain) {
                    try {
                        this.window.hive_keychain.requestHandshake(function () {
                            resolve(true);
                        });
                    }
                    catch (error) {
                        throw error;
                    }
                }
                else {
                    resolve(false);
                }
            });
        });
        /**
         * @description
         * Keychain SDK utils functions.
         * Call this function to perform an easy login function doing a full signing/verification process.
         * @example
         * // Under the hood, this login request is:
         * // 1. Signing the message/buffer.
         * // 2. Checking if publicKey belongs to that user.
         * // 3. Verifying the signature.
         * // Note: Check the login method bellow to see the whole code process.
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         * try {
         *     const login = await keychain.login(
         *       {
         *         username: 'keychain.tests',
         *         message: '{"login":"123"}',
         *         method: 'posting',
         *         title: 'LOGIN',
         *       },
         *     );
         *     console.log({ login });
         *   } catch (error) {
         *     console.log({ error });
         *   }
         *
         * @param {Login} data
         * @memberof KeychainSDK
         * @returns Promise<any>
         */
        this.login = (data) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestSignBuffer(data.username, (_a = data.message) !== null && _a !== void 0 ? _a : (0, uuid_1.v4)(), data.method, (response) => __awaiter(this, void 0, void 0, function* () {
                        var _b, _c;
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            const accounts = (_b = (yield client.keys.getKeyReferences([response.publicKey]))) === null || _b === void 0 ? void 0 : _b.accounts;
                            if ((_c = accounts === null || accounts === void 0 ? void 0 : accounts[0]) === null || _c === void 0 ? void 0 : _c.includes(data.username)) {
                                const signature = Dhive.Signature.fromString(response.result);
                                const key = Dhive.PublicKey.fromString(response.publicKey);
                                const result = key.verify(Dhive.cryptoUtils.sha256(response.data.message), signature);
                                if (result) {
                                    resolve(response);
                                }
                                else
                                    reject((0, login_1.getLoginError)(response, 'The signature could not be verified'));
                            }
                            else
                                reject((0, login_1.getLoginError)(response, 'The signature could not be verified'));
                        }
                    }), undefined, data.title);
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        //////END utils///////
        /**
         * @description
         * This function is called to encode a message, using certain key
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         * try {
         *     const encodeMessage = await keychain.encode({
         *       username: 'keychain.tests',
         *       receiver: 'keychain.tests',
         *       message: '#Message to encode, # is required to encrypt',
         *       method: 'Memo',
         *     });
         *     console.log({ encodeMessage });
         *   } catch (error) {
         *     console.log({ error });
         *   }
         * @param {Encode} data
         * @memberof KeychainSDK
         */
        this.encode = (data) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestEncodeMessage(data.username, data.receiver, data.message, data.method, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    });
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * This function is called to verify that the user has a certain authority over an account, by requesting to decode a message
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         * try {
         *     const verifyKey = await keychain.decode({
         *       username: 'keychain.tests',
         *       message:
         *         '#JnyQbbpLdRBT8ev7SALsNru6c4bftPCf4c6AkTN42YTc52aDvcRqKVqK6yMhRAGhW8fbasR8xz14ofs63WXLP6nxDndKsBMkmg7UsAS9ucTDrKFoZkuJFCyvLmksyCYgD',
         *       method: 'memo',
         *     });
         *     console.log({ verifyKey });
         *   } catch (error) {
         *     console.log({ error });
         *   }
         * @param {Decode} data
         * @memberof KeychainSDK
         */
        this.decode = (data) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestVerifyKey(data.username, data.message, data.method, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    });
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * Requests a message to be signed with proper authority
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         * try {
         *     const signBuffer = await keychain.signBuffer(
         *       {
         *         username: 'keychain.tests',
         *         message: 'message!!',
         *         method: 'Active',
         *         title: 'Login in Into Saturnoman.com\nProceed?',
         *       },
         *     );
         *     console.log({ signBuffer });
         *   } catch (error) {
         *     console.log({ error });
         *   }
         * @param {SignBuffer} data
         * @memberof KeychainSDK
         */
        this.signBuffer = (data) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestSignBuffer(data.username, data.message, data.method, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    }, undefined, data.title);
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * Requests to add account authority over another account. For more information about multisig
         * @see Website read https://peakd.com/utopian-io/@stoodkev/how-to-set-up-and-use-multisignature-accounts-on-steem-blockchain
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         * try {
         *     const addAccountAuthority = await keychain.addAccountAuthority(
         *       {
         *         username: 'keychain.tests',
         *         authorizedUsername: 'keychain.tests',
         *         role: 'posting',
         *         weight: 1,
         *       },
         *     );
         *     console.log({ addAccountAuthority });
         *   } catch (error) {
         *     console.log({ error });
         *
         *   }
         * @param {AddAccountAuthority} data
         * @param {KeychainOptions=} options
         * @memberof KeychainSDK
         */
        this.addAccountAuthority = (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _d, _e;
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestAddAccountAuthority(data.username, data.authorizedUsername, data.role, data.weight, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    }, (_d = options.rpc) !== null && _d !== void 0 ? _d : (_e = this.options) === null || _e === void 0 ? void 0 : _e.rpc);
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * Requests to remove an account authority over another account.
         * @see Website For more information about multisig, please read https://peakd.com/utopian-io/@stoodkev/how-to-set-up-and-use-multisignature-accounts-on-steem-blockchain
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         * try {
         *     const removeAccountAuthority =
         *       await keychain.removeAccountAuthority(
         *         {
         *           username: 'keychain.tests',
         *           authorizedUsername: 'keychain.tests',
         *           role: 'posting',
         *         },
         *       );
         *     console.log({ removeAccountAuthority });
         *   } catch (error) {
         *     console.log({ error });
         *   }
         * @param {RemoveAccountAuthority} data
         * @param {KeychainOptions=} options
         * @memberof KeychainSDK
         */
        this.removeAccountAuthority = (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _f, _g;
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestRemoveAccountAuthority(data.username, data.authorizedUsername, data.role, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    }, (_f = options.rpc) !== null && _f !== void 0 ? _f : (_g = this.options) === null || _g === void 0 ? void 0 : _g.rpc);
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * Requests to add a new key authority to an account.
         * @see Website For more information about multisig, please read https://peakd.com/utopian-io/@stoodkev/how-to-set-up-and-use-multisignature-accounts-on-steem-blockchain
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         * try {
         *     const addKeyAuthority = await keychain.addKeyAuthority(
         *       {
         *         username: 'keychain.tests',
         *         authorizedKey:
         *           'STM8eALyQwyb2C4XhXJ7eZfjfjfSeNeeZREaxPcJRApie1uwzzcuF',
         *         role: 'posting',
         *         weight: 1,
         *       },
         *     );
         *     console.log({ addKeyAuthority });
         *   } catch (error) {
         *     console.log({ error });
         *   }
         * @param {AddKeyAuthority} data
         * @param {KeychainOptions=} options
         * @memberof KeychainSDK
         */
        this.addKeyAuthority = (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _h, _j;
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestAddKeyAuthority(data.username, data.authorizedKey, data.role, data.weight, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    }, (_h = options.rpc) !== null && _h !== void 0 ? _h : (_j = this.options) === null || _j === void 0 ? void 0 : _j.rpc);
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * Requests to remove a key to an account.
         * @see Website For more information about multisig, please read https://peakd.com/utopian-io/@stoodkev/how-to-set-up-and-use-multisignature-accounts-on-steem-blockchain
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         *   try {
         *     const removeKeyAuthority = await keychain.removeKeyAuthority(
         *       {
         *         username: 'keychain.tests',
         *         authorizedKey:
         *           'STM8eALyQwyb2C4XhXJ7eZfjfjfSeNeeZREaxPcJRApie1uwzzcuF',
         *         role: 'posting',
         *       },
         *     );
         *     console.log({ removeKeyAuthority });
         *   } catch (error) {
         *     console.log({ error });
         *   }
         * @param {RemoveKeyAuthority} data
         * @param {KeychainOptions=} options
         * @memberof KeychainSDK
         */
        this.removeKeyAuthority = (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _k, _l;
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestRemoveKeyAuthority(data.username, data.authorizedKey, data.role, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    }, (_k = options.rpc) !== null && _k !== void 0 ? _k : (_l = this.options) === null || _l === void 0 ? void 0 : _l.rpc);
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * Generic broadcast request
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         * try {
         *     const broadcast = await keychain.broadcast(
         *       {
         *         username: 'keychain.tests',
         *         operations: [
         *           [
         *             'transfer',
         *             {
         *               from: 'keychain.tests',
         *               to: 'keychain.tests',
         *               amount: '0.001 HIVE',
         *               memo: 'testing keychain SDK - requestBroadcast',
         *             },
         *           ],
         *         ],
         *         method: 'active',
         *       },
         *     );
         *     console.log({ broadcast });
         *   } catch (error) {
         *     console.log({ error });
         *   }
         * @param {Broadcast} data
         * @param {KeychainOptions=} options
         * @memberof KeychainSDK
         */
        this.broadcast = (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _m, _o;
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestBroadcast(data.username, typeof data.operations === 'string'
                        ? JSON.parse(data.operations)
                        : data.operations, data.method, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    }, (_m = options.rpc) !== null && _m !== void 0 ? _m : (_o = this.options) === null || _o === void 0 ? void 0 : _o.rpc);
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * Requests to sign a transaction with a given authority
         * @example
         * import dhive from '@hiveio/dhive';
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         * const client = new dhive.Client(['https://api.hive.blog', 'https://api.openhive.network']);
         * const props = await client.database.getDynamicGlobalProperties();
         * const headBlockNumber = props.head_block_number;
         * const headBlockId = props.head_block_id;
         * const expireTime = 600000;
         * const op = {
         *  ref_block_num: headBlockNumber & 0xffff,
         *  ref_block_prefix: Buffer.from(headBlockId, 'hex').readUInt32LE(4),
         *  expiration: new Date(Date.now() + 600000).toISOString().slice(0, -5),
         *  operations: [
              [
                "transfer",
                {
                  "from": "keychain.tests",
                  "to": "keychain.tests",
                  "amount": "0.001 HIVE",
                  "memo": "Keychain SDK - requestSignTx & broadcast"
                }
              ]
            ]
         * };
         *  try {
         *     const signTx = await keychain.signTx(
         *       {
         *         username: 'keychain.tests',
         *         tx: op,
         *         method: 'Posting',
         *       }
         *     );
         *     console.log({ signTx });
         *   } catch (error) {
         *     console.log({ error });
         *   }
         * @param {SignTx} data
         * @memberof KeychainSDK
         */
        this.signTx = (data) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestSignTx(data.username, data.tx, data.method, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    });
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * Requests a signed call
         * @deprecated
         * @param {ExcludeCommonParams<RequestSignedCall>} data
         * @param {KeychainOptions} options
         * @memberof KeychainSDK
         */
        this.signedCall = (data, options) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    yield this.isKeychainInstalled();
                    resolve('requestSignedCall has been deprecated.');
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * Requests to broadcast a blog post/comment
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         * try {
         *     const post = await keychain.post(
         *       {
         *         username: 'keychain.tests',
         *         title: 'Keychain SDK 2!',
         *         body: '## This is a blog post n And this is some text. Testing the brand new Keychain SDK v1.0',
         *         parent_perm: 'blog',
         *         parent_username: '',
         *         json_metadata: JSON.stringify({
         *           format: 'markdown',
         *           description: 'A blog post',
         *           tags: ['Blog'],
         *         }),
         *         permlink: 'a-post-by-keychaintests-fourth-part-post',
         *         comment_options: JSON.stringify({
         *           author: 'keychain.tests',
         *           permlink: 'a-post-by-keychaintests-fourth-part-post',
         *           max_accepted_payout: '10000.000 SBD',
         *           allow_votes: true,
         *           allow_curation_rewards: true,
         *           extensions: [],
         *           percent_hbd: 63,
         *         }),
         *       },
         *     );
         *     console.log({ post });
         *   } catch (error) {
         *     console.log({ error });
         *   }
         * @see Website Consult Hive documentation at <https://developers.hive.io/apidefinitions/#broadcast_ops_comment_options> to learn more about comment_options
         * @param {Post} data
         * @param {KeychainOptions=} options
         * @memberof KeychainSDK
         */
        this.post = (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _p, _q;
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestPost(data.username, data.title, data.body, data.parent_perm, data.parent_username, data.json_metadata, data.permlink, data.comment_options, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    }, (_p = options.rpc) !== null && _p !== void 0 ? _p : (_q = this.options) === null || _q === void 0 ? void 0 : _q.rpc);
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * Requests a vote
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         *   try {
         *     const vote = await keychain.vote(
         *       {
         *         username: 'keychain.tests',
         *         author: 'keychain.tests',
         *         permlink: 'a-post-by-keychaintests-fifth-part-post',
         *         weight: 10000,
         *       },
         *     );
         *     console.log({ vote });
         *   } catch (error) {
         *     console.log({ error });
         *   }
         * @param {Vote} data
         * @param {KeychainOptions=} options
         * @memberof KeychainSDK
         */
        this.vote = (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _r, _s;
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestVote(data.username, data.permlink, data.author, data.weight, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    }, (_r = options.rpc) !== null && _r !== void 0 ? _r : (_s = this.options) === null || _s === void 0 ? void 0 : _s.rpc);
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * Requests a custom JSON broadcast
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         *    try {
         *     const custom_json = await keychain.custom(
         *       {
         *         username: 'keychain.tests',
         *         id: '1',
         *         method: 'Posting',
         *         json: JSON.stringify({
         *           items: ['9292cd44ccaef8b73a607949cc787f1679ede10b-93'],
         *           currency: 'DEC',
         *           days: 1,
         *         }),
         *         display_msg: 'rent a card man!',
         *       },
         *     );
         *     console.log({ custom_json });
         *   } catch (error) {
         *     console.log('error custom_json: ', error);
         *   }
         * @param {Custom} data
         * @param {KeychainOptions=} options
         * @memberof KeychainSDK
         */
        this.custom = (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _t, _u;
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestCustomJson(data.username, data.id, data.method, data.json, data.display_msg, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    }, (_t = options.rpc) !== null && _t !== void 0 ? _t : (_u = this.options) === null || _u === void 0 ? void 0 : _u.rpc);
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * Requests a transfer
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         * try {
         *   const transfer = await keychain.transfer(
         *       {
         *          username: 'keychain.tests',
         *          to: 'keychain.tests',
         *          amount: '1.000',
         *          memo: 'Test Keychain SDK transfer',
         *          enforce: false,
         *          currency: 'HIVE',
         *       }
         *   );
         *  console.log({ transfer });
         * } catch (error) {
         *  console.log('error transfer: ', error);
         * }
         * @param {Transfer} data
         * @param {KeychainOptions=} options
         * @memberof KeychainSDK
         */
        this.transfer = (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _v;
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestTransfer(data.username, data.to, data.amount, data.memo, data.currency, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    }, data.enforce, options.rpc ? options.rpc : (_v = this.options) === null || _v === void 0 ? void 0 : _v.rpc);
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * Requests a token transfer
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         *   try {
         *     const sendToken = await keychain.sendToken(
         *       {
         *         username: 'keychain.tests',
         *         to: 'keychain.tests',
         *         amount: '0.001',
         *         memo: 'frescos',
         *         currency: 'LEO',
         *       },
         *     );
         *     console.log({ sendToken });
         *   } catch (error) {
         *     console.log({ error });
         *   }
         * @param {SendToken} data
         * @param {KeychainOptions=} options
         * @memberof KeychainSDK
         */
        this.sendToken = (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _w, _x;
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestSendToken(data.username, data.to, data.amount, data.memo, data.currency, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    }, (_w = options.rpc) !== null && _w !== void 0 ? _w : (_x = this.options) === null || _x === void 0 ? void 0 : _x.rpc);
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * Requests a delegation broadcast
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         *   try {
         *     const delegation = await keychain.delegation(
         *       {
         *         username: 'keychain.tests',
         *         delegatee: 'keychain.tests',
         *         amount: '1.000',
         *         unit: 'HP',
         *       },
         *     );
         *     console.log({ delegation });
         *   } catch (error) {
         *     console.log({ error });
         *   }
         * @param {Delegation} data
         * @param {KeychainOptions=} options
         * @memberof KeychainSDK
         */
        this.delegation = (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _y, _z;
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestDelegation(data.username, data.delegatee, data.amount, data.unit, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    }, (_y = options.rpc) !== null && _y !== void 0 ? _y : (_z = this.options) === null || _z === void 0 ? void 0 : _z.rpc);
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * Requests a witness vote
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         *  try {
         *     const witnessVote = await keychain.witnessVote(
         *       {
         *         username: 'keychain.tests',
         *         witness: 'keychain',
         *         vote: true,
         *       },
         *     );
         *     console.log({ witnessVote });
         *   } catch (error) {
         *     console.log({ error });
         *   }
         * @param {WitnessVote} data
         * @param {KeychainOptions=} options
         * @memberof KeychainSDK
         */
        this.witnessVote = (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _0, _1;
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestWitnessVote(data.username, data.witness, data.vote, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    }, (_0 = options.rpc) !== null && _0 !== void 0 ? _0 : (_1 = this.options) === null || _1 === void 0 ? void 0 : _1.rpc);
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * Select an account as proxy
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         *  try {
         *     const proxy = await keychain.proxy(
         *       {
         *         username: 'keychain.tests',
         *         proxy: 'keychain',
         *       },
         *     );
         *     console.log({ proxy });
         *   } catch (error) {
         *     console.log({ error });
         *   }
         * @param {Proxy} data
         * @param {KeychainOptions=} options
         * @memberof KeychainSDK
         */
        this.proxy = (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _2, _3;
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestProxy(data.username, data.proxy, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    }, (_2 = options.rpc) !== null && _2 !== void 0 ? _2 : (_3 = this.options) === null || _3 === void 0 ? void 0 : _3.rpc);
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * Request a power up
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         *  try {
         *     const powerUp = await keychain.powerUp(
         *       {
         *         username: 'keychain.tests',
         *         recipient: 'keychain.tests',
         *         hive: '0.001',
         *       },
         *     );
         *     console.log({ powerUp });
         *   } catch (error) {
         *     console.log({ error });
         *   }
         * @param {PowerUp} data
         * @param {KeychainOptions=} options
         * @memberof KeychainSDK
         */
        this.powerUp = (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _4, _5;
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestPowerUp(data.username, data.recipient, data.hive, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    }, (_4 = options.rpc) !== null && _4 !== void 0 ? _4 : (_5 = this.options) === null || _5 === void 0 ? void 0 : _5.rpc);
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * Request a power down
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         *  try {
         *     const powerDown = await keychain.powerDown(
         *       {
         *         username: 'keychain.tests',
         *         hive_power: '0.001',
         *       },
         *     );
         *     console.log({ powerDown });
         *   } catch (error) {
         *     console.log({ error });
         *   }
         * @param {PowerDown} data
         * @param {KeychainOptions=} options
         * @memberof KeychainSDK
         */
        this.powerDown = (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _6, _7;
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestPowerDown(data.username, data.hive_power, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    }, (_6 = options.rpc) !== null && _6 !== void 0 ? _6 : (_7 = this.options) === null || _7 === void 0 ? void 0 : _7.rpc);
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * Request the creation of an account using claimed tokens
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         * try {
         * // Note: as an example the same Authority object is being used, to real test, use real data that apply.
         * const DEFAULT_AUTHORITY = {
         *   weight_threshold: 1,
         *   account_auths: [],
         *   key_auths: [["STM8eALyQwyb2C4XhXJ7eZfjfjfSeNeeZREaxPcJRApie1uwzzcuF", 1]],
         * } as Authority;
         *  const createclaimedaccount = await keychain.createClaimedAccount(
         *    {
         *     "username": "keychain.tests",
         *     "new_account": "keychain.tests",
         *     "owner": JSON.stringify(DEFAULT_AUTHORITY),
         *     "active": JSON.stringify(DEFAULT_AUTHORITY),
         *     "posting": JSON.stringify(DEFAULT_AUTHORITY),
         *     "memo": "STM8eALyQwyb2C4XhXJ7eZfjfjfSeNeeZREaxPcJRApie1uwzzcuF"
         *     },
         * );
         *  console.log({ createclaimedaccount });
         * } catch (error) {
         *  console.log({ error });
         * }
         * @param {CreateClaimedAccount} data
         * @param {KeychainOptions=} options
         * @memberof KeychainSDK
         */
        this.createClaimedAccount = (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _8, _9;
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestCreateClaimedAccount(data.username, data.new_account, data.owner, data.active, data.posting, data.memo, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    }, (_8 = options.rpc) !== null && _8 !== void 0 ? _8 : (_9 = this.options) === null || _9 === void 0 ? void 0 : _9.rpc);
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        //HF21
        /**
         * @description
         * Request the creation of a DHF proposal
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         * try {
         *   const createProposal = await keychain.createProposal(
         *     {
         *       username: "keychain.tests",
         *       receiver: "keychain.tests",
         *       subject: "The New proposal title",
         *       permlink: "proposal-keychain-dev-permlink",
         *       start: "2023-02-25T00:00:00",
         *       end: "2024-02-25T00:00:00",
         *       daily_pay: "390.000 HBD",
         *       extensions: "[]",
         *     },
         *   );
         *   console.log({ createProposal });
         * } catch (error) {
         *   console.log({ error });
         * }
         * @param {CreateProposal} data
         * @param {KeychainOptions=} options
         * @memberof KeychainSDK
         */
        this.createProposal = (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _10, _11;
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestCreateProposal(data.username, data.receiver, data.subject, data.permlink, data.daily_pay, data.start, data.end, data.extensions, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    }, (_10 = options.rpc) !== null && _10 !== void 0 ? _10 : (_11 = this.options) === null || _11 === void 0 ? void 0 : _11.rpc);
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * Request the removal of a DHF proposal
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         * try {
         *   const removeproposal = await keychain.removeProposal(
         *     {
         *       username: "keychain.tests",
         *       proposal_ids: "[1,2,3]",
         *       extensions: "[]",
         *     },
         *   );
         *   console.log({ removeproposal });
         * } catch (error) {
         *   console.log({ error });
         * }
         * @param {RemoveProposal} data
         * @param {KeychainOptions=} options
         */
        this.removeProposal = (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _12, _13;
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestRemoveProposal(data.username, data.proposal_ids, data.extensions, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    }, (_12 = options.rpc) !== null && _12 !== void 0 ? _12 : (_13 = this.options) === null || _13 === void 0 ? void 0 : _13.rpc);
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * Vote/Unvote a DHF proposal
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         * try {
         *   const updateproposalvote = await keychain.updateProposalVote(
         *     {
         *       username: "keychain.tests",
         *       proposal_ids: "[1,2,3]",
         *       approve: false,
         *       extensions: "[]",
         *     },
         *   );
         *   console.log({ updateproposalvote });
         * } catch (error) {
         *   console.log({ error });
         * }
         * @param {UpdateProposalVote} data
         * @param {KeychainOptions=} options
         * @memberof KeychainSDK
         */
        this.updateProposalVote = (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _14, _15;
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestUpdateProposalVote(data.username, data.proposal_ids, data.approve, data.extensions, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    }, (_14 = options.rpc) !== null && _14 !== void 0 ? _14 : (_15 = this.options) === null || _15 === void 0 ? void 0 : _15.rpc);
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * Add a new account to Keychain
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         *  try {
         *     const addAccount = await keychain.addAccount(
         *       {
         *         username: 'keychain.tests',
         *         keys: {
         *           active: '5d...',
         *           posting: '5fg...',
         *           memo: '5rfD...',
         *         },
         *       },
         *     );
         *     console.log({ addAccount });
         *   } catch (error) {
         *     console.log({ error });
         *   }
         * @param {AddAccount} data
         * @memberof KeychainSDK
         */
        this.addAccount = (data) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestAddAccount(data.username, data.keys, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    });
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * Request currency conversion
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         *  try {
         *     const conversionCollateralized = await keychain.convert(
         *       {
         *         username: 'keychain.tests',
         *         amount: '1.000',
         *         collaterized: true,
         *       },
         *     );
         *     console.log({ conversionCollateralized });
         *   } catch (error) {
         *     console.log({ error });
         *   }
         * @param {Convert} data
         * @param {KeychainOptions=} options
         * @memberof KeychainSDK
         */
        this.convert = (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _16, _17;
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestConversion(data.username, data.amount, data.collaterized, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    }, (_16 = options.rpc) !== null && _16 !== void 0 ? _16 : (_17 = this.options) === null || _17 === void 0 ? void 0 : _17.rpc);
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        /**
         * @description
         * Request recurrent transfer
         * @example
         * import { KeychainSDK } from "keychain-sdk";
         * const keychain = new KeychainSDK(window);
         *  try {
         *     const recurrentTransfer = await keychain.recurrentTransfer(
         *       {
         *         username: 'keychain.tests',
         *         to: 'keychain.tests',
         *         amount: '1.000',
         *         currency: 'HIVE',
         *         memo: 'Keychain SDK tests rt',
         *         recurrence: 24,
         *         executions: 2,
         *         extensions: [],
         *       },
         *     );
         *     console.log({ recurrentTransfer });
         *   } catch (error) {
         *     console.log({ error});
         *   }
         * @param {RecurrentTransfer} data
         * @param {KeychainOptions=} options
         * @memberof KeychainSDK
         */
        this.recurrentTransfer = (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var _18, _19;
                try {
                    yield this.isKeychainInstalled();
                    this.window.hive_keychain.requestRecurrentTransfer(data.username, data.to, data.amount, data.currency, data.memo, data.recurrence, data.executions, (response) => {
                        if (response.error) {
                            reject(response);
                        }
                        else {
                            resolve(response);
                        }
                    }, (_18 = options.rpc) !== null && _18 !== void 0 ? _18 : (_19 = this.options) === null || _19 === void 0 ? void 0 : _19.rpc);
                }
                catch (error) {
                    throw error;
                }
            }));
        });
        this.window = window;
        this.options = options;
    }
    //////utils////////
    /**
     * @description
     * Keychain SDK utils functions.
     * Will return actual configuration of windows object + rpc options.
     * @example
     * import { KeychainSDK } from "keychain-sdk";
     * const keychain = new KeychainSDK(window);
     * try {
     *     const configObject = await keychain.getConfig();
     *     console.log({ configObject });
     *   } catch (error) {
     *     console.log({ configObject });
     *   }
     * @returns Object as {window,options}
     * @memberof KeychainSDK
     */
    getConfig() {
        return {
            window: this.window,
            options: this.options,
        };
    }
}
exports.KeychainSDK = KeychainSDK;
__exportStar(require("./interfaces/keychain-sdk.interface"), exports);
__exportStar(require("./interfaces/keychain.interface"), exports);
