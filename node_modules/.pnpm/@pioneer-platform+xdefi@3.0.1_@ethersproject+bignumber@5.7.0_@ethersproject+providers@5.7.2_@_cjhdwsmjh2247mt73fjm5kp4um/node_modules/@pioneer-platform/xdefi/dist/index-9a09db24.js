var n = /* @__PURE__ */ ((t) => (t.INVALID_INPUT_PARAMETERS = "1000", t.UNKNOWN_PROVIDERS = "1001", t.CANNOT_FIND_INBOUND_ADDRESS = "1002", t.NO_INBOUND_ADDRESSES = "1003", t.CHAIN_HALTED_OR_UNSUPPORTED = "1004", t.MISSING_INPUT_PARAMETER = "1005", t.INVALID_TYPE_GENERIC = "1100", t.INVALID_NUMBER_STRING = "1101", t.INVALID_NUMBER = "1102", t.INVALID_BOOLEAN = "1103", t.INVALID_OBJECT = "1104", t.INVALID_ARRAY = "1105", t.SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2000", t.SELL_BUY_ASSETS_ARE_THE_SAME = "2001", t.MISSING_SOURCE_ADDRESS_FOR_SYNTH = "2002", t.AFF_ADDRESS_AND_BPS_OR_NEITHER = "2003", t.AFF_ADDRESS_TOO_LONG = "2004", t.AFF_BPS_INTEGER_0_100 = "2005", t.SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN = "2006", t.DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN = "2007", t.PREFERRED_PROFVIDER_NOT_SUPPORTED = "2008", t.DESTINATION_ADDRESS_SMART_CONTRACT = "2009", t.BUY_AMOUNT_MUST_BE_POSITIVE_INTEGER = "2010", t.SOURCE_ADDRESS_SMART_CONTRACT = "2011", t.INVALID_PROVIDER = "2100", t.MISSING_CROSS_CHAIN_PROVIDER = "2101", t.MISSING_AVAX_PROVIDER = "2102", t.MISSING_BSC_PROVIDER = "2103", t.MISSING_ETH_PROVIDER = "2104", t.INVALID_PROVIDER_FOR_SWAP_OUT = "2105", t.MISSING_ARB_PROVIDER = "2106", t.INVALID_CHAIN = "2200", t.INVALID_ASSET = "2201", t.INVALID_ASSET_IDENTIFIER = "2202", t.UNSUPPORTED_CHAIN = "2204", t.UNSUPPORTED_ASSET = "2203", t.UNSUPPORTED_ASSET_FOR_SWAPOUT = "2205", t.THORNODE_QUOTE_GENERIC_ERROR = "3000", t.NOT_ENOUGH_SYNTH_BALANCE = "3001", t.SYNTH_MINTING_CAP_REACHED = "3002", t.INVALID_QUOTE_MODE = "4000", t.NO_QUOTES = "4001", t.SERVICE_UNAVAILABLE_GENERIC = "5000", t.MISSING_GAS_DATA_GENERIC = "5100", t.MISSING_TOKEN_INFO_GENERIC = "5200", t.CANT_FIND_TOKEN_LIST = "5201", t.NO_PRICE = "5202", t.PRICE_IS_STALE = "5203", t.ADDRESS_NOT_WHITELISTED = "6000", t.ADDRESS_ALREADY_CLAIMED = "6001", t.TEMPORARY_ERROR = "9999", t))(n || {});
n.INVALID_INPUT_PARAMETERS + "", n.UNKNOWN_PROVIDERS + "", n.CANNOT_FIND_INBOUND_ADDRESS + "", n.NO_INBOUND_ADDRESSES + "", n.CHAIN_HALTED_OR_UNSUPPORTED + "", n.MISSING_INPUT_PARAMETER + "", n.INVALID_TYPE_GENERIC + "", n.INVALID_NUMBER_STRING + "", n.INVALID_NUMBER + "", n.INVALID_BOOLEAN + "", n.INVALID_OBJECT + "", n.INVALID_ARRAY + "", n.SELL_AMOUNT_MUST_BE_POSITIVE_INTEGER + "", n.SELL_BUY_ASSETS_ARE_THE_SAME + "", n.MISSING_SOURCE_ADDRESS_FOR_SYNTH + "", n.AFF_ADDRESS_AND_BPS_OR_NEITHER + "", n.AFF_ADDRESS_TOO_LONG + "", n.AFF_BPS_INTEGER_0_100 + "", n.SOURCE_ADDRESS_INVALID_FOR_SELL_CHAIN + "", n.DESTINATION_ADDRESS_INVALID_FOR_BUY_CHAIN + "", n.PREFERRED_PROFVIDER_NOT_SUPPORTED + "", n.DESTINATION_ADDRESS_SMART_CONTRACT + "", n.BUY_AMOUNT_MUST_BE_POSITIVE_INTEGER + "", n.INVALID_PROVIDER + "", n.MISSING_CROSS_CHAIN_PROVIDER + "", n.MISSING_AVAX_PROVIDER + "", n.MISSING_BSC_PROVIDER + "", n.MISSING_ETH_PROVIDER + "", n.MISSING_ARB_PROVIDER + "", n.INVALID_PROVIDER_FOR_SWAP_OUT + "", n.INVALID_CHAIN + "", n.INVALID_ASSET + "", n.UNSUPPORTED_CHAIN + "", n.UNSUPPORTED_ASSET + "", n.UNSUPPORTED_ASSET_FOR_SWAPOUT + "", n.THORNODE_QUOTE_GENERIC_ERROR + "", n.NOT_ENOUGH_SYNTH_BALANCE + "", n.SYNTH_MINTING_CAP_REACHED + "", n.INVALID_QUOTE_MODE + "", n.NO_QUOTES + "", n.SERVICE_UNAVAILABLE_GENERIC + "", n.MISSING_GAS_DATA_GENERIC + "", n.MISSING_TOKEN_INFO_GENERIC + "", n.CANT_FIND_TOKEN_LIST + "", n.NO_PRICE + "", n.PRICE_IS_STALE + "", n.ADDRESS_NOT_WHITELISTED + "", n.ADDRESS_ALREADY_CLAIMED + "";
var o = /* @__PURE__ */ ((t) => (t.Arbitrum = "ARB", t.Avalanche = "AVAX", t.Binance = "BNB", t.BinanceSmartChain = "BSC", t.Bitcoin = "BTC", t.BitcoinCash = "BCH", t.Cosmos = "GAIA", t.Dogecoin = "DOGE", t.Ethereum = "ETH", t.Litecoin = "LTC", t.Optimism = "OP", t.Polygon = "MATIC", t.THORChain = "THOR", t))(o || {}), B = /* @__PURE__ */ ((t) => (t[t.ARB = 18] = "ARB", t[t.AVAX = 18] = "AVAX", t[t.BCH = 8] = "BCH", t[t.BNB = 8] = "BNB", t[t.BSC = 18] = "BSC", t[t.BTC = 8] = "BTC", t[t.DOGE = 8] = "DOGE", t[t.ETH = 18] = "ETH", t[t.GAIA = 6] = "GAIA", t[t.LTC = 8] = "LTC", t[t.MATIC = 18] = "MATIC", t[t.OP = 18] = "OP", t[t.THOR = 8] = "THOR", t))(B || {}), R = /* @__PURE__ */ ((t) => (t.Arbitrum = "42161", t.ArbitrumHex = "0xa4b1", t.Avalanche = "43114", t.AvalancheHex = "0xa86a", t.Binance = "Binance-Chain-Tigris", t.BinanceHex = "", t.BinanceSmartChain = "56", t.BinanceSmartChainHex = "0x38", t.Bitcoin = "bitcoin", t.BitcoinHex = "", t.BitcoinCash = "bitcoincash", t.BitcoinCashHex = "", t.Cosmos = "cosmoshub-4", t.CosmosHex = "", t.Dogecoin = "dogecoin", t.DogecoinHex = "", t.Ethereum = "1", t.EthereumHex = "0x1", t.Litecoin = "litecoin", t.LitecoinHex = "", t.Optimism = "10", t.OptimismHex = "0xa", t.Polygon = "137", t.PolygonHex = "0x89", t.THORChain = "thorchain-mainnet-v1", t.THORChainHex = "", t.THORChainStagenet = "thorchain-stagenet-v2", t))(R || {}), p = /* @__PURE__ */ ((t) => (t.Arbitrum = "https://arb1.arbitrum.io/rpc", t.Avalanche = "https://node-router.thorswap.net/avalanche-c", t.Binance = "", t.BinanceSmartChain = "https://bsc-dataseed.binance.org", t.Bitcoin = "https://node-router.thorswap.net/bitcoin", t.BitcoinCash = "https://node-router.thorswap.net/bitcoin-cash", t.Cosmos = "https://node-router.thorswap.net/cosmos/rpc", t.Dogecoin = "https://node-router.thorswap.net/dogecoin", t.Ethereum = "https://node-router.thorswap.net/ethereum", t.Litecoin = "https://node-router.thorswap.net/litecoin", t.Optimism = "https://mainnet.optimism.io", t.Polygon = "https://polygon-rpc.com", t.THORChain = "https://rpc.thorswap.net", t.THORChainStagenet = "https://stagenet-rpc.ninerealms.com", t))(p || {});
const O = Object.values(o), G = Object.keys(o), u = O.reduce(
  (t, i) => {
    const a = G.find((e) => o[e] === i);
    return a && (t[i] = a), t;
  },
  {}
), b = O.reduce(
  (t, i) => (t[i] = R[u[i]], t),
  {}
);
O.reduce(
  (t, i) => (t[i] = p[u[i]], t),
  {}
);
const x = O.reduce(
  (t, i) => (t[i] = R[`${u[i]}Hex`], t),
  {}
);
var F = /* @__PURE__ */ ((t) => (t.Average = "average", t.Fast = "fast", t.Fastest = "fastest", t))(F || {}), P = /* @__PURE__ */ ((t) => (t.KEYSTORE = "KEYSTORE", t.XDEFI = "XDEFI", t.METAMASK = "METAMASK", t.COINBASE_WEB = "COINBASE_WEB", t.TREZOR = "TREZOR", t.KEEPKEY = "KEEPKEY", t.TRUSTWALLET_WEB = "TRUSTWALLET_WEB", t.LEDGER = "LEDGER", t.KEPLR = "KEPLR", t.OKX = "OKX", t.BRAVE = "BRAVE", t.WALLETCONNECT = "WALLETCONNECT", t))(P || {});
const L = (t) => {
  var i, a, e, s, E, _, I, r;
  switch (t) {
    case o.Ethereum:
    case o.Avalanche:
    case o.BinanceSmartChain:
      return (i = window.xfi) == null ? void 0 : i.ethereum;
    case o.Binance:
      return (a = window.xfi) == null ? void 0 : a.binance;
    case o.Bitcoin:
      return (e = window.xfi) == null ? void 0 : e.bitcoin;
    case o.BitcoinCash:
      return (s = window.xfi) == null ? void 0 : s.bitcoincash;
    case o.Dogecoin:
      return (E = window.xfi) == null ? void 0 : E.dogecoin;
    case o.Litecoin:
      return (_ = window.xfi) == null ? void 0 : _.litecoin;
    case o.THORChain:
      return (I = window.xfi) == null ? void 0 : I.thorchain;
    case o.Cosmos:
      return (r = window.xfi) == null ? void 0 : r.keplr;
  }
}, y = async ({
  method: t,
  params: i,
  chain: a
}) => {
  var s;
  const e = t === "deposit" ? (s = window.xfi) == null ? void 0 : s.thorchain : L(a);
  return new Promise((E, _) => {
    e.request({ method: t, params: i }, (I, r) => I ? _(I) : E(r));
  });
}, w = async (t) => {
  const i = L(t);
  if (!i)
    throw new Error("XDEFI provider is not defined");
  if (t === o.Cosmos) {
    await i.enable(R.Cosmos);
    const a = i.getOfflineSigner(R.Cosmos), [{ address: e }] = await a.getAccounts();
    return e;
  } else
    return [o.Ethereum, o.Avalanche, o.BinanceSmartChain].includes(t) ? (await i.request({
      method: "eth_requestAccounts",
      params: []
    }))[0] : new Promise(
      (a, e) => i.request(
        { method: "request_accounts", params: [] },
        (s, E) => s ? e(s) : a(E[0])
      )
    );
}, T = async ({ amount: t, asset: i, recipient: a, memo: e, gasLimit: s }, E = "transfer") => {
  if (!i)
    throw new Error("Asset is not defined");
  const _ = E === "eth_sendTransaction" ? t.amount().toHexString() : t.amount().toNumber(), I = await w(i.chain), r = [
    {
      amount: { amount: _, decimals: t.decimal },
      asset: i,
      from: I,
      memo: e,
      recipient: a,
      gasLimit: s
    }
  ];
  return y({ method: E, params: r, chain: i.chain });
}, Y = (t) => async ({ from: i, recipient: a, amount: e, asset: s, memo: E }) => {
  var N, S;
  const { createCosmJS: _ } = await import("@pioneer-platform/toolbox-cosmos"), I = (S = (N = window.xfi) == null ? void 0 : N.keplr) == null ? void 0 : S.getOfflineSignerOnlyAmino(R.Cosmos), r = await _({ offlineSigner: I, rpcUrl: t }), c = [
    { denom: (s == null ? void 0 : s.symbol) === "MUON" ? "umuon" : "uatom", amount: e.amount().toString() }
  ], { transactionHash: A } = await r.sendTokens(i, a, c, 1.6, E);
  return A;
}, W = async ({
  chain: t,
  ethplorerApiKey: i,
  covalentApiKey: a,
  utxoApiKey: e,
  rpcUrl: s,
  api: E
}) => {
  var _, I;
  switch (t) {
    case o.THORChain: {
      const { DEFAULT_GAS_VALUE: r, ThorchainToolbox: c } = await import("@pioneer-platform/toolbox-cosmos");
      return {
        ...c({ stagenet: !1 }),
        deposit: (A) => T({ ...A, recipient: "" }, "deposit"),
        transfer: (A) => T({ ...A, gasLimit: r }, "transfer")
      };
    }
    case o.Cosmos: {
      const { GaiaToolbox: r } = await import("@pioneer-platform/toolbox-cosmos");
      return { ...r({ server: E }), transfer: Y(s) };
    }
    case o.Binance: {
      const { BinanceToolbox: r } = await import("@pioneer-platform/toolbox-cosmos");
      return { ...r(), transfer: T };
    }
    case o.Ethereum:
    case o.BinanceSmartChain:
    case o.Avalanche: {
      const {
        getProvider: r,
        prepareNetworkSwitch: c,
        ETHToolbox: A,
        AVAXToolbox: N,
        BSCToolbox: S,
        addEVMWalletNetwork: l,
        covalentApi: U,
        ethplorerApi: H
      } = await import("@pioneer-platform/toolbox-evm"), { Web3Provider: M } = await import("@ethersproject/providers"), D = (_ = window.xfi) == null ? void 0 : _.ethereum;
      if (!D)
        throw new Error("Requested web3 wallet is not installed");
      if (t !== o.Ethereum && !a || t === o.Ethereum && !i)
        throw new Error(`Missing API key for ${t} chain`);
      const m = new M(D, "any"), d = {
        provider: m,
        signer: m.getSigner(),
        ethplorerApiKey: i,
        covalentApiKey: a
      }, h = t === o.Ethereum ? A(d) : t === o.Avalanche ? N(d) : S(d);
      try {
        t !== o.Ethereum && await l(
          D,
          h.getNetworkParams()
        );
      } catch {
        throw new Error(`Failed to add/switch ${t} network: ${t}`);
      }
      return c({
        toolbox: {
          ...h,
          getBalance: async (C) => {
            const { getSignatureAssetFor: g } = await import("./index.es-24d5c8d6.js"), { baseAmount: f } = await import("./index-08993fd9.js"), V = await (t === o.Ethereum ? H(i) : U({
              apiKey: a,
              chainId: b[t]
            })).getBalance(C), v = await r(t).getBalance(C);
            return [
              {
                asset: g(t),
                amount: f(v, B[t])
              },
              ...V
            ];
          }
        },
        chainId: x[t],
        provider: (I = window.xfi) == null ? void 0 : I.ethereum
      });
    }
    case o.Bitcoin:
    case o.BitcoinCash:
    case o.Dogecoin:
    case o.Litecoin: {
      const { BCHToolbox: r, BTCToolbox: c, DOGEToolbox: A, LTCToolbox: N } = await import("@pioneer-platform/toolbox-utxo"), S = { rpcUrl: s, utxoApiKey: e, apiClient: E };
      return { ...t === o.Bitcoin ? c(S) : t === o.BitcoinCash ? r(S) : t === o.Dogecoin ? A(S) : N(S), transfer: T };
    }
    default:
      return null;
  }
};
o.Avalanche, o.Binance, o.BinanceSmartChain, o.Bitcoin, o.BitcoinCash, o.Dogecoin, o.Ethereum, o.Litecoin, o.THORChain;
const X = ({
  addChain: t,
  config: { covalentApiKey: i, ethplorerApiKey: a, utxoApiKey: e }
}) => async (s) => {
  const E = s.map(async (_) => {
    const I = await w(_), r = await W({
      chain: _,
      utxoApiKey: e,
      covalentApiKey: i,
      ethplorerApiKey: a
    });
    t({
      chain: _,
      walletMethods: { ...r, getAddress: () => I },
      wallet: { address: I, balance: [], walletType: P.XDEFI }
    });
  });
  return await Promise.all(E), !0;
}, q = {
  connectMethodName: "connectXDEFI",
  connect: X
};
export {
  F as G,
  q as x
};
