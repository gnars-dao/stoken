"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tsd_1 = require("tsd");
const misc_1 = require("./misc");
//=============================================================================
// isObject
//=============================================================================
// eslint-disable-next-line @typescript-eslint/ban-types
const unknownValue = {};
(0, tsd_1.expectNotAssignable)(unknownValue);
if ((0, misc_1.isObject)(unknownValue)) {
    (0, tsd_1.expectAssignable)(unknownValue);
}
// Does not interfere with satisfaction of static type
const constObjectType = { foo: 'foo' };
if ((0, misc_1.hasProperty)(constObjectType, 'foo')) {
    (0, tsd_1.expectAssignable)(constObjectType);
}
//=============================================================================
// hasProperty
//=============================================================================
// eslint-disable-next-line @typescript-eslint/ban-types
const unknownObject = {};
// Establish that `Object` is not accepted when a specific property is needed.
(0, tsd_1.expectNotAssignable)(unknownObject);
// Establish that `RuntimeObject` is not accepted when a specific property is needed.
if ((0, misc_1.isObject)(unknownObject)) {
    (0, tsd_1.expectNotAssignable)(unknownObject);
}
// An object is accepted after `hasProperty` is used to prove that it has the required property.
if ((0, misc_1.isObject)(unknownObject) && (0, misc_1.hasProperty)(unknownObject, 'foo')) {
    (0, tsd_1.expectAssignable)(unknownObject);
}
// An object is accepted after `hasProperty` is used to prove that it has all required properties.
if ((0, misc_1.isObject)(unknownObject) &&
    (0, misc_1.hasProperty)(unknownObject, 'foo') &&
    (0, misc_1.hasProperty)(unknownObject, 'bar')) {
    (0, tsd_1.expectAssignable)(unknownObject);
}
// An object is not accepted after `hasProperty` has only been used to establish that some required properties exist.
if ((0, misc_1.isObject)(unknownObject) && (0, misc_1.hasProperty)(unknownObject, 'foo')) {
    (0, tsd_1.expectNotAssignable)(unknownObject);
}
// Does not interfere with satisfaction of non-overlapping types
const overlappingTypesExample = { foo: 'foo', baz: 'baz' };
if ((0, misc_1.hasProperty)(overlappingTypesExample, 'foo')) {
    (0, tsd_1.expectAssignable)(overlappingTypesExample);
}
const exampleErrorWithCode = new Error('test');
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
exampleErrorWithCode.code = 999;
// Establish that trying to check for a custom property on an error results in failure
(0, tsd_1.expectNotAssignable)(exampleErrorWithCode);
// Using custom Error property is allowed after checking with `hasProperty`
if ((0, misc_1.hasProperty)(exampleErrorWithCode, 'code')) {
    (0, tsd_1.expectType)(exampleErrorWithCode.code);
}
const hasPropertyInterfaceExample = { a: 0 };
(0, misc_1.hasProperty)(hasPropertyInterfaceExample, 'a');
// `hasProperty` is compatible with classes
class HasPropertyClassExample {
}
const hasPropertyClassExample = new HasPropertyClassExample();
(0, misc_1.hasProperty)(hasPropertyClassExample, 'a');
// It keeps the original type when defined.
const hasPropertyTypeExample = {};
if ((0, misc_1.hasProperty)(hasPropertyTypeExample, 'a')) {
    (0, tsd_1.expectType)(hasPropertyTypeExample.a);
}
//=============================================================================
// RuntimeObject
//=============================================================================
// Valid runtime objects:
(0, tsd_1.expectAssignable)({});
(0, tsd_1.expectAssignable)({ foo: 'foo' });
// eslint-disable-next-line @typescript-eslint/naming-convention
(0, tsd_1.expectAssignable)({ 0: 'foo' });
(0, tsd_1.expectAssignable)({ [Symbol('foo')]: 'foo' });
// Invalid runtime objects:
(0, tsd_1.expectNotAssignable)(null);
(0, tsd_1.expectNotAssignable)(undefined);
(0, tsd_1.expectNotAssignable)('foo');
(0, tsd_1.expectNotAssignable)(0);
(0, tsd_1.expectNotAssignable)([]);
(0, tsd_1.expectNotAssignable)(new Date());
(0, tsd_1.expectNotAssignable)(() => 0);
(0, tsd_1.expectNotAssignable)(new Set());
(0, tsd_1.expectNotAssignable)(new Map());
(0, tsd_1.expectNotAssignable)(Symbol('test'));
const runtimeObjectInterfaceExample = { a: 0 };
(0, tsd_1.expectNotAssignable)(runtimeObjectInterfaceExample);
class RuntimeObjectClassExample {
}
const runtimeObjectClassExample = new RuntimeObjectClassExample();
(0, tsd_1.expectNotAssignable)(runtimeObjectClassExample);
//# sourceMappingURL=misc.test-d.js.map