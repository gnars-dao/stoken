import { Infer } from 'superstruct';
export declare const TYPE_REGEX: RegExp;
export declare const ARRAY_REGEX: RegExp;
export declare const BYTES_REGEX: RegExp;
export declare const NUMBER_REGEX: RegExp;
export declare const STATIC_TYPES: string[];
export declare const EIP_712_TYPE: import("superstruct").Struct<{
    name: string;
    type: string;
}, {
    name: import("superstruct").Struct<string, null>;
    type: import("superstruct").Struct<string, null>;
}>;
/**
 * A single type, as part of a struct. The `type` field can be any of the EIP-712 supported types. Currently those are:
 * - Atomic types: bytes1..32, uint8..256, int8..256, bool, address
 * - Dynamic types: bytes, string
 * - Reference types: array type (e.g. uint8[], SomeStruct[]), struct type (e.g. SomeStruct)
 *
 * Note that the `uint` and `int` aliases like in Solidity, and fixed point numbers are not supported by the EIP-712
 * standard.
 */
export declare type EIP712Type = Infer<typeof EIP_712_TYPE>;
export declare const EIP_712_DOMAIN_TYPE: import("superstruct").Struct<{
    name?: string | undefined;
    version?: string | undefined;
    chainId?: any;
    verifyingContract?: string | undefined;
    salt?: any;
}, {
    name: import("superstruct").Struct<string | undefined, null>;
    version: import("superstruct").Struct<string | undefined, null>;
    chainId: import("superstruct").Struct<any, null>;
    verifyingContract: import("superstruct").Struct<string | undefined, null>;
    salt: import("superstruct").Struct<any, null>;
}>;
/**
 * The EIP712 domain struct. Any of these fields are optional, but it must contain at least one field.
 */
export declare type EIP712Domain = Infer<typeof EIP_712_DOMAIN_TYPE>;
export declare const EIP_712_TYPED_DATA_TYPE: import("superstruct").Struct<{
    domain: Record<string, unknown>;
    types: Record<string, {
        name: string;
        type: string;
    }[]>;
    primaryType: string;
    message: Record<string, unknown>;
}, {
    types: import("superstruct").Struct<Record<string, {
        name: string;
        type: string;
    }[]>, null>;
    primaryType: import("superstruct").Struct<string, null>;
    domain: import("superstruct").Struct<Record<string, unknown>, null>;
    message: import("superstruct").Struct<Record<string, unknown>, null>;
}>;
export declare const EIP_712_STRICT_TYPED_DATA_TYPE: import("superstruct").Struct<{
    domain: {
        name?: string | undefined;
        version?: string | undefined;
        chainId?: any;
        verifyingContract?: string | undefined;
        salt?: any;
    };
    types: Record<string, {
        name: string;
        type: string;
    }[]>;
    primaryType: string;
    message: Record<string, unknown>;
}, {
    domain: import("superstruct").Struct<{
        name?: string | undefined;
        version?: string | undefined;
        chainId?: any;
        verifyingContract?: string | undefined;
        salt?: any;
    }, {
        name: import("superstruct").Struct<string | undefined, null>;
        version: import("superstruct").Struct<string | undefined, null>;
        chainId: import("superstruct").Struct<any, null>;
        verifyingContract: import("superstruct").Struct<string | undefined, null>;
        salt: import("superstruct").Struct<any, null>;
    }>;
    types: import("superstruct").Struct<Record<string, {
        name: string;
        type: string;
    }[]>, null>;
    primaryType: import("superstruct").Struct<string, null>;
    message: import("superstruct").Struct<Record<string, unknown>, null>;
}>;
/**
 * The complete typed data, with all the structs, domain data, primary type of the message, and the message itself.
 */
export declare type TypedData = Infer<typeof EIP_712_TYPED_DATA_TYPE>;
export declare type StrictTypedData = Infer<typeof EIP_712_STRICT_TYPED_DATA_TYPE>;
/**
 * Checks if a type is valid with the given `typedData`. The following types are valid:
 * - Atomic types: bytes1..32, uint8..256, int8..256, bool, address
 * - Dynamic types: bytes, string
 * - Reference types: array type (e.g. uint8[], SomeStruct[]), struct type (e.g. SomeStruct)
 *
 * The `uint` and `int` aliases like in Solidity are not supported. Fixed point numbers are not supported.
 */
export declare const isValidType: (types: Record<string, unknown>, type: string) => boolean;
