{"version":3,"sources":["../../src/types.ts"],"names":["array","assign","number","object","optional","pattern","record","refine","string","union","TYPE_REGEX","ARRAY_REGEX","BYTES_REGEX","NUMBER_REGEX","STATIC_TYPES","TYPE","type","context","isValidType","branch","types","EIP_712_TYPE","name","EIP_712_DOMAIN_TYPE","version","chainId","verifyingContract","salt","EIP_712_TYPED_DATA_TYPE","primaryType","domain","message","EIP_712_STRICT_TYPED_DATA_TYPE","includes","match","innerType","bytesMatch","length","Number","numberMatch"],"mappings":"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","sourcesContent":["import { array, assign, Infer, number, object, optional, pattern, record, refine, string, union } from 'superstruct';\n\nexport const TYPE_REGEX = /^\\w+/;\nexport const ARRAY_REGEX = /^(.*)\\[([0-9]*?)]$/;\nexport const BYTES_REGEX = /^bytes([0-9]{1,2})$/;\nexport const NUMBER_REGEX = /^u?int([0-9]{0,3})$/;\n\nexport const STATIC_TYPES = ['address', 'bool', 'bytes', 'string'];\n\nconst TYPE = refine(string(), 'Type', (type, context) => {\n  return isValidType(context.branch[0].types, type);\n});\n\nexport const EIP_712_TYPE = object({\n  name: string(),\n  type: TYPE\n});\n\n/**\n * A single type, as part of a struct. The `type` field can be any of the EIP-712 supported types. Currently those are:\n * - Atomic types: bytes1..32, uint8..256, int8..256, bool, address\n * - Dynamic types: bytes, string\n * - Reference types: array type (e.g. uint8[], SomeStruct[]), struct type (e.g. SomeStruct)\n *\n * Note that the `uint` and `int` aliases like in Solidity, and fixed point numbers are not supported by the EIP-712\n * standard.\n */\nexport type EIP712Type = Infer<typeof EIP_712_TYPE>;\n\nexport const EIP_712_DOMAIN_TYPE = object({\n  name: optional(string()),\n  version: optional(string()),\n  chainId: optional(union([string(), number()])),\n  verifyingContract: optional(pattern(string(), /^0x[0-9a-z]{40}$/i)),\n  salt: optional(union([array(number()), pattern(string(), /^0x[0-9a-z]{64}$/i)]))\n});\n\n/**\n * The EIP712 domain struct. Any of these fields are optional, but it must contain at least one field.\n */\nexport type EIP712Domain = Infer<typeof EIP_712_DOMAIN_TYPE>;\n\nexport const EIP_712_TYPED_DATA_TYPE = object({\n  types: record(string(), array(EIP_712_TYPE)),\n  primaryType: string(),\n  domain: object(),\n  message: object()\n});\n\nexport const EIP_712_STRICT_TYPED_DATA_TYPE = assign(\n  EIP_712_TYPED_DATA_TYPE,\n  object({\n    domain: EIP_712_DOMAIN_TYPE\n  })\n);\n\n/**\n * The complete typed data, with all the structs, domain data, primary type of the message, and the message itself.\n */\nexport type TypedData = Infer<typeof EIP_712_TYPED_DATA_TYPE>;\nexport type StrictTypedData = Infer<typeof EIP_712_STRICT_TYPED_DATA_TYPE>;\n\n/**\n * Checks if a type is valid with the given `typedData`. The following types are valid:\n * - Atomic types: bytes1..32, uint8..256, int8..256, bool, address\n * - Dynamic types: bytes, string\n * - Reference types: array type (e.g. uint8[], SomeStruct[]), struct type (e.g. SomeStruct)\n *\n * The `uint` and `int` aliases like in Solidity are not supported. Fixed point numbers are not supported.\n */\nexport const isValidType = (types: Record<string, unknown>, type: string): boolean => {\n  if (STATIC_TYPES.includes(type as string)) {\n    return true;\n  }\n\n  if (types[type]) {\n    return true;\n  }\n\n  if (type.match(ARRAY_REGEX)) {\n    const match = type.match(TYPE_REGEX);\n    if (match) {\n      const innerType = match[0];\n      return isValidType(types, innerType);\n    }\n  }\n\n  const bytesMatch = type.match(BYTES_REGEX);\n  if (bytesMatch) {\n    const length = Number(bytesMatch[1]);\n    if (length >= 1 && length <= 32) {\n      return true;\n    }\n  }\n\n  const numberMatch = type.match(NUMBER_REGEX);\n  if (numberMatch) {\n    const length = Number(numberMatch[1]);\n    if (length >= 8 && length <= 256 && length % 8 === 0) {\n      return true;\n    }\n  }\n\n  return false;\n};\n"],"file":"types.js"}