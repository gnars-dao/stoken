{"version":3,"sources":["../../src/eip-712.ts"],"names":["getOptions","ARRAY_REGEX","TYPE_REGEX","keccak256","toBuffer","validateTypedData","encode","EIP_191_PREFIX","Buffer","from","getDependencies","typedData","type","options","dependencies","Error","match","actualType","includes","types","reduce","previous","filter","dependency","encodeType","primary","sort","map","name","join","getTypeHash","encodeValue","data","arrayType","length","Number","undefined","Array","isArray","encodedData","item","values","getStructHash","isBuffer","encodeData","field","value","encodedValue","getMessage","hash","domain","message","concat","primaryType","asArray","array"],"mappings":"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","sourcesContent":["import { getOptions, Options } from './options';\nimport { ARRAY_REGEX, TYPE_REGEX, TypedData } from './types';\nimport { keccak256, toBuffer, validateTypedData, encode } from './utils';\n\nconst EIP_191_PREFIX = Buffer.from('1901', 'hex');\n\n/**\n * Get the dependencies of a struct type. If a struct has the same dependency multiple times, it's only included once\n * in the resulting array.\n */\nexport const getDependencies = (\n  typedData: TypedData,\n  type: string,\n  options?: Options,\n  dependencies: string[] = []\n): string[] => {\n  // `getDependencies` is called by most other functions, so we validate the JSON schema here\n  if (!validateTypedData(typedData, options)) {\n    throw new Error('Typed data does not match JSON schema');\n  }\n\n  const match = type.match(TYPE_REGEX)!;\n  const actualType = match[0];\n  if (dependencies.includes(actualType)) {\n    return dependencies;\n  }\n\n  if (!typedData.types[actualType]) {\n    return dependencies;\n  }\n\n  return [\n    actualType,\n    ...typedData.types[actualType].reduce<string[]>(\n      (previous, type) => [\n        ...previous,\n        ...getDependencies(typedData, type.type, options, previous).filter(\n          (dependency) => !previous.includes(dependency)\n        )\n      ],\n      []\n    )\n  ];\n};\n\n/**\n * Encode a type to a string. All dependant types are alphabetically sorted.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {Options} [options]\n * @return {string}\n */\nexport const encodeType = (typedData: TypedData, type: string, options?: Options): string => {\n  const [primary, ...dependencies] = getDependencies(typedData, type, options);\n  const types = [primary, ...dependencies.sort()];\n\n  return types\n    .map((dependency) => {\n      return `${dependency}(${typedData.types[dependency].map((type) => `${type.type} ${type.name}`)})`;\n    })\n    .join('');\n};\n\n/**\n * Get a type string as hash.\n */\nexport const getTypeHash = (typedData: TypedData, type: string, options?: Options): Uint8Array => {\n  return keccak256(encodeType(typedData, type, options), 'utf8');\n};\n\n/**\n * Encodes a single value to an ABI serialisable string, number or Buffer. Returns the data as tuple, which consists of\n * an array of ABI compatible types, and an array of corresponding values.\n */\nconst encodeValue = (\n  typedData: TypedData,\n  type: string,\n  data: unknown,\n  options?: Options\n): [string, string | Uint8Array | number] => {\n  const match = type.match(ARRAY_REGEX);\n\n  // Checks for array types\n  if (match) {\n    const arrayType = match[1];\n    const length = Number(match[2]) || undefined;\n\n    if (!Array.isArray(data)) {\n      throw new Error('Cannot encode data: value is not of array type');\n    }\n\n    if (length && data.length !== length) {\n      throw new Error(`Cannot encode data: expected length of ${length}, but got ${data.length}`);\n    }\n\n    const encodedData = data.map((item) => encodeValue(typedData, arrayType, item, options));\n    const types = encodedData.map((item) => item[0]);\n    const values = encodedData.map((item) => item[1]);\n\n    return ['bytes32', keccak256(encode(types, values))];\n  }\n\n  if (typedData.types[type]) {\n    return ['bytes32', getStructHash(typedData, type, data as Record<string, unknown>, options)];\n  }\n\n  // Strings and arbitrary byte arrays are hashed to bytes32\n  if (type === 'string') {\n    return ['bytes32', keccak256(data as string, 'utf8')];\n  }\n\n  if (type === 'bytes') {\n    return ['bytes32', keccak256(Buffer.isBuffer(data) ? data : toBuffer(data as string), 'hex')];\n  }\n\n  return [type, data as string];\n};\n\n/**\n * Encode the data to an ABI encoded Buffer. The data should be a key -> value object with all the required values. All\n * dependant types are automatically encoded.\n */\nexport const encodeData = (\n  typedData: TypedData,\n  type: string,\n  data: Record<string, unknown>,\n  options?: Options\n): Uint8Array => {\n  const [types, values] = typedData.types[type].reduce<[string[], unknown[]]>(\n    ([types, values], field) => {\n      if (data[field.name] === undefined || data[field.name] === null) {\n        throw new Error(`Cannot encode data: missing data for '${field.name}'`);\n      }\n\n      const value = data[field.name];\n      const [type, encodedValue] = encodeValue(typedData, field.type, value, options);\n\n      return [\n        [...types, type],\n        [...values, encodedValue]\n      ];\n    },\n    [['bytes32'], [getTypeHash(typedData, type, options)]]\n  );\n\n  return encode(types, values);\n};\n\n/**\n * Get encoded data as a hash. The data should be a key -> value object with all the required values. All dependant\n * types are automatically encoded.\n */\nexport const getStructHash = (\n  typedData: TypedData,\n  type: string,\n  data: Record<string, unknown>,\n  options?: Options\n): Uint8Array => {\n  return keccak256(encodeData(typedData, type, data, options));\n};\n\n/**\n * Get the EIP-191 encoded message to sign, from the typedData object. If `hash` is enabled, the message will be hashed\n * with Keccak256.\n */\nexport const getMessage = (typedData: TypedData, hash?: boolean, options?: Options): Uint8Array => {\n  const { domain } = getOptions(options);\n  const message = Buffer.concat([\n    EIP_191_PREFIX,\n    getStructHash(typedData, domain, typedData.domain as Record<string, unknown>, options),\n    getStructHash(typedData, typedData.primaryType, typedData.message, options)\n  ]);\n\n  if (hash) {\n    return keccak256(message);\n  }\n\n  return message;\n};\n\n/**\n * Get the typed data as array. This can be useful for encoding the typed data with the contract ABI.\n */\nexport const asArray = (\n  typedData: TypedData,\n  type: string = typedData.primaryType,\n  data: Record<string, unknown> = typedData.message,\n  options?: Options\n): unknown[] => {\n  if (!validateTypedData(typedData, options)) {\n    throw new Error('Typed data does not match JSON schema');\n  }\n\n  if (!typedData.types[type]) {\n    throw new Error('Cannot get data as array: type does not exist');\n  }\n\n  return typedData.types[type].reduce<unknown[]>((array, { name, type }) => {\n    if (typedData.types[type]) {\n      if (!data[name]) {\n        throw new Error(`Cannot get data as array: missing data for '${name}'`);\n      }\n\n      return [...array, asArray(typedData, type, data[name] as Record<string, unknown>, options)];\n    }\n\n    const value = data[name];\n    return [...array, value];\n  }, []);\n};\n"],"file":"eip-712.js"}