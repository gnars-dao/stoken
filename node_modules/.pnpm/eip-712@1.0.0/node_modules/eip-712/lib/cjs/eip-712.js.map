{"version":3,"sources":["../../src/eip-712.ts"],"names":["EIP_191_PREFIX","Buffer","from","getDependencies","typedData","type","options","dependencies","Error","match","TYPE_REGEX","actualType","includes","types","reduce","previous","filter","dependency","encodeType","primary","sort","map","name","join","getTypeHash","encodeValue","data","ARRAY_REGEX","arrayType","length","Number","undefined","Array","isArray","encodedData","item","values","getStructHash","isBuffer","encodeData","field","value","encodedValue","getMessage","hash","domain","message","concat","primaryType","asArray","array"],"mappings":"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","sourcesContent":["import { getOptions, Options } from './options';\nimport { ARRAY_REGEX, TYPE_REGEX, TypedData } from './types';\nimport { keccak256, toBuffer, validateTypedData, encode } from './utils';\n\nconst EIP_191_PREFIX = Buffer.from('1901', 'hex');\n\n/**\n * Get the dependencies of a struct type. If a struct has the same dependency multiple times, it's only included once\n * in the resulting array.\n */\nexport const getDependencies = (\n  typedData: TypedData,\n  type: string,\n  options?: Options,\n  dependencies: string[] = []\n): string[] => {\n  // `getDependencies` is called by most other functions, so we validate the JSON schema here\n  if (!validateTypedData(typedData, options)) {\n    throw new Error('Typed data does not match JSON schema');\n  }\n\n  const match = type.match(TYPE_REGEX)!;\n  const actualType = match[0];\n  if (dependencies.includes(actualType)) {\n    return dependencies;\n  }\n\n  if (!typedData.types[actualType]) {\n    return dependencies;\n  }\n\n  return [\n    actualType,\n    ...typedData.types[actualType].reduce<string[]>(\n      (previous, type) => [\n        ...previous,\n        ...getDependencies(typedData, type.type, options, previous).filter(\n          (dependency) => !previous.includes(dependency)\n        )\n      ],\n      []\n    )\n  ];\n};\n\n/**\n * Encode a type to a string. All dependant types are alphabetically sorted.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {Options} [options]\n * @return {string}\n */\nexport const encodeType = (typedData: TypedData, type: string, options?: Options): string => {\n  const [primary, ...dependencies] = getDependencies(typedData, type, options);\n  const types = [primary, ...dependencies.sort()];\n\n  return types\n    .map((dependency) => {\n      return `${dependency}(${typedData.types[dependency].map((type) => `${type.type} ${type.name}`)})`;\n    })\n    .join('');\n};\n\n/**\n * Get a type string as hash.\n */\nexport const getTypeHash = (typedData: TypedData, type: string, options?: Options): Uint8Array => {\n  return keccak256(encodeType(typedData, type, options), 'utf8');\n};\n\n/**\n * Encodes a single value to an ABI serialisable string, number or Buffer. Returns the data as tuple, which consists of\n * an array of ABI compatible types, and an array of corresponding values.\n */\nconst encodeValue = (\n  typedData: TypedData,\n  type: string,\n  data: unknown,\n  options?: Options\n): [string, string | Uint8Array | number] => {\n  const match = type.match(ARRAY_REGEX);\n\n  // Checks for array types\n  if (match) {\n    const arrayType = match[1];\n    const length = Number(match[2]) || undefined;\n\n    if (!Array.isArray(data)) {\n      throw new Error('Cannot encode data: value is not of array type');\n    }\n\n    if (length && data.length !== length) {\n      throw new Error(`Cannot encode data: expected length of ${length}, but got ${data.length}`);\n    }\n\n    const encodedData = data.map((item) => encodeValue(typedData, arrayType, item, options));\n    const types = encodedData.map((item) => item[0]);\n    const values = encodedData.map((item) => item[1]);\n\n    return ['bytes32', keccak256(encode(types, values))];\n  }\n\n  if (typedData.types[type]) {\n    return ['bytes32', getStructHash(typedData, type, data as Record<string, unknown>, options)];\n  }\n\n  // Strings and arbitrary byte arrays are hashed to bytes32\n  if (type === 'string') {\n    return ['bytes32', keccak256(data as string, 'utf8')];\n  }\n\n  if (type === 'bytes') {\n    return ['bytes32', keccak256(Buffer.isBuffer(data) ? data : toBuffer(data as string), 'hex')];\n  }\n\n  return [type, data as string];\n};\n\n/**\n * Encode the data to an ABI encoded Buffer. The data should be a key -> value object with all the required values. All\n * dependant types are automatically encoded.\n */\nexport const encodeData = (\n  typedData: TypedData,\n  type: string,\n  data: Record<string, unknown>,\n  options?: Options\n): Uint8Array => {\n  const [types, values] = typedData.types[type].reduce<[string[], unknown[]]>(\n    ([types, values], field) => {\n      if (data[field.name] === undefined || data[field.name] === null) {\n        throw new Error(`Cannot encode data: missing data for '${field.name}'`);\n      }\n\n      const value = data[field.name];\n      const [type, encodedValue] = encodeValue(typedData, field.type, value, options);\n\n      return [\n        [...types, type],\n        [...values, encodedValue]\n      ];\n    },\n    [['bytes32'], [getTypeHash(typedData, type, options)]]\n  );\n\n  return encode(types, values);\n};\n\n/**\n * Get encoded data as a hash. The data should be a key -> value object with all the required values. All dependant\n * types are automatically encoded.\n */\nexport const getStructHash = (\n  typedData: TypedData,\n  type: string,\n  data: Record<string, unknown>,\n  options?: Options\n): Uint8Array => {\n  return keccak256(encodeData(typedData, type, data, options));\n};\n\n/**\n * Get the EIP-191 encoded message to sign, from the typedData object. If `hash` is enabled, the message will be hashed\n * with Keccak256.\n */\nexport const getMessage = (typedData: TypedData, hash?: boolean, options?: Options): Uint8Array => {\n  const { domain } = getOptions(options);\n  const message = Buffer.concat([\n    EIP_191_PREFIX,\n    getStructHash(typedData, domain, typedData.domain as Record<string, unknown>, options),\n    getStructHash(typedData, typedData.primaryType, typedData.message, options)\n  ]);\n\n  if (hash) {\n    return keccak256(message);\n  }\n\n  return message;\n};\n\n/**\n * Get the typed data as array. This can be useful for encoding the typed data with the contract ABI.\n */\nexport const asArray = (\n  typedData: TypedData,\n  type: string = typedData.primaryType,\n  data: Record<string, unknown> = typedData.message,\n  options?: Options\n): unknown[] => {\n  if (!validateTypedData(typedData, options)) {\n    throw new Error('Typed data does not match JSON schema');\n  }\n\n  if (!typedData.types[type]) {\n    throw new Error('Cannot get data as array: type does not exist');\n  }\n\n  return typedData.types[type].reduce<unknown[]>((array, { name, type }) => {\n    if (typedData.types[type]) {\n      if (!data[name]) {\n        throw new Error(`Cannot get data as array: missing data for '${name}'`);\n      }\n\n      return [...array, asArray(typedData, type, data[name] as Record<string, unknown>, options)];\n    }\n\n    const value = data[name];\n    return [...array, value];\n  }, []);\n};\n"],"file":"eip-712.js"}