/// <reference types="node" />

import { AssetValue } from '@coinmasters/helpers';
import { Chain } from '@coinmasters/types';
import type { ECPairInterface } from 'ecpair';
import type { FeeOption } from '@coinmasters/types';
import { Psbt } from 'bitcoinjs-lib';
import { SwapKitNumber } from '@coinmasters/helpers';
import { UTXOChain } from '@coinmasters/types';

export declare const accumulative: ({ inputs, outputs, feeRate, chain, }: UTXOCalculateTxSizeParams & {
    outputs: TargetOutput[];
    chain: UTXOChain;
}) => {
    inputs: (UTXOType | UTXOInputWithScriptType)[];
    outputs: TargetOutput[];
    fee: number;
} | {
    fee: number;
    inputs?: undefined;
    outputs?: undefined;
};

export declare const BaseUTXOToolbox: (baseToolboxParams: UTXOBaseToolboxParams & {
    broadcastTx: (txHex: string) => Promise<string>;
}) => {
    accumulative: ({ inputs, outputs, feeRate, chain, }: UTXOCalculateTxSizeParams & {
        outputs: TargetOutput[];
        chain: UTXOChain;
    }) => {
        inputs: (UTXOType | UTXOInputWithScriptType)[];
        outputs: TargetOutput[];
        fee: number;
    } | {
        fee: number;
        inputs?: undefined;
        outputs?: undefined;
    };
    apiClient: {
        getConfirmedBalance: (address: string) => Promise<number>;
        getRawTx: (txHash: string) => Promise<string>;
        getSuggestedTxFee: () => Promise<number>;
        getBalance: (address: string) => Promise<number>;
        getBalanceXpub: (pubkey: string) => Promise<any>;
        getAddressData: (address: string) => Promise<{
            address: BlockchairAddressCoreData;
            transactions: BlockchairTransaction[];
            utxo: BlockchairUtxo[];
        } | {
            utxo: never[];
            address: {
                balance: number;
                transaction_count: number;
            };
        }>;
        scanUTXOs: (params: {
            address: string;
            fetchTxHex?: boolean | undefined;
        }) => Promise<{
            address: string;
            hash: string;
            index: number;
            txHex: string | undefined;
            value: number;
            witnessUtxo: {
                value: number;
                script: Buffer;
            };
        }[]>;
        listUnspent: (pubkey: string, chain: string, apiKey?: string | undefined) => Promise<any>;
    };
    broadcastTx: (txHex: string) => Promise<string>;
    calculateTxSize: ({ inputs, outputs, feeRate }: UTXOCalculateTxSizeParams) => number;
    buildTx: (params: any) => Promise<{
        psbt: Psbt;
        utxos: UTXOType[];
        inputs: UTXOType[];
    }>;
    getAddressFromKeys: (keys: ECPairInterface) => string;
    validateAddress: (address: string) => boolean;
    createKeysForPath: (params: any) => Promise<ECPairInterface>;
    getPrivateKeyFromMnemonic: ({ phrase, derivationPath, }: {
        phrase: string;
        derivationPath: string;
    }) => Promise<string>;
    getBalance: (pubkeys: any[]) => Promise<AssetValue[]>;
    getFeeRates: () => Promise<{
        average: number;
        fast: number;
        fastest: number;
    }>;
    transfer: (params: any) => Promise<string>;
    getInputsOutputsFee: (params: any) => Promise<{
        inputs: (UTXOType | UTXOInputWithScriptType)[];
        outputs: TargetOutput[];
        fee: number;
    } | {
        fee: number;
        inputs?: undefined;
        outputs?: undefined;
    }>;
    getFeeForTransaction: (params: any) => Promise<SwapKitNumber>;
    estimateMaxSendableAmount: (params: any) => Promise<AssetValue>;
};

declare type BCHMethods = {
    stripPrefix: (address: string) => string;
    validateAddress: (address: string, chain?: UTXOChain) => boolean;
    createKeysForPath: (params: {
        wif?: string;
        phrase?: string;
        derivationPath?: string;
    }) => Promise<{
        getAddress: (index?: number) => string;
    }>;
    getAddressFromKeys: (keys: {
        getAddress: (index?: number) => string;
    }) => string;
    buildBCHTx: (params: UTXOBuildTxParams & {
        apiClient: BlockchairApiType;
    }) => Promise<{
        builder: TransactionBuilderType;
        utxos: UTXOType[];
    }>;
    buildTx: (params: UTXOBuildTxParams) => Promise<{
        psbt: Psbt;
    }>;
    transfer: (params: UTXOWalletTransferParams<{
        builder: TransactionBuilderType;
        utxos: UTXOType[];
    }, TransactionType>) => Promise<string>;
};

export declare const BCHToolbox: ({ apiKey, rpcUrl, apiClient: client, }: {
    apiKey?: string | undefined;
    rpcUrl?: string | undefined;
    apiClient?: {
        getConfirmedBalance: (address: string) => Promise<number>;
        getRawTx: (txHash: string) => Promise<string>;
        getSuggestedTxFee: () => Promise<number>;
        getBalance: (address: string) => Promise<number>;
        getBalanceXpub: (pubkey: string) => Promise<any>;
        getAddressData: (address: string) => Promise<{
            address: BlockchairAddressCoreData;
            transactions: BlockchairTransaction[];
            utxo: BlockchairUtxo[];
        } | {
            utxo: never[];
            address: {
                balance: number;
                transaction_count: number;
            };
        }>;
        scanUTXOs: (params: {
            address: string;
            fetchTxHex?: boolean | undefined;
        }) => Promise<{
            address: string;
            hash: string;
            index: number;
            txHex: string | undefined;
            value: number;
            witnessUtxo: {
                value: number;
                script: Buffer;
            };
        }[]>;
        listUnspent: (pubkey: string, chain: string, apiKey?: string | undefined) => Promise<any>;
    } | undefined;
}) => any & BCHMethods;

export declare interface BlockchairAddressCoreData {
    type: string;
    script_hex: string;
    balance: number;
    balance_usd: number;
    received: number;
    received_usd: number;
    spent: number;
    spent_usd: number;
    output_count: number;
    unspent_output_count: number;
    first_seen_receiving: string;
    last_seen_receiving: string;
    first_seen_spending: null | string;
    last_seen_spending: null | string;
    transaction_count: number;
    scripthash_type: null | string;
}

export declare interface BlockchairAddressResponse {
    [key: string]: {
        address: BlockchairAddressCoreData;
        transactions: BlockchairTransaction[];
        utxo: BlockchairUtxo[];
    };
}

declare const blockchairApi: ({ apiKey, chain }: {
    apiKey?: string | undefined;
    chain: UTXOChain;
}) => {
    getConfirmedBalance: (address: string) => Promise<number>;
    getRawTx: (txHash: string) => Promise<string>;
    getSuggestedTxFee: () => Promise<number>;
    getBalance: (address: string) => Promise<number>;
    getBalanceXpub: (pubkey: string) => Promise<any>;
    getAddressData: (address: string) => Promise<{
        address: BlockchairAddressCoreData;
        transactions: BlockchairTransaction[];
        utxo: BlockchairUtxo[];
    } | {
        utxo: never[];
        address: {
            balance: number;
            transaction_count: number;
        };
    }>;
    scanUTXOs: (params: {
        address: string;
        fetchTxHex?: boolean;
    }) => Promise<{
        address: string;
        hash: string;
        index: number;
        txHex: string | undefined;
        value: number;
        witnessUtxo: {
            value: number;
            script: Buffer;
        };
    }[]>;
    listUnspent: (pubkey: string, chain: string, apiKey?: string) => Promise<any>;
};

export declare type BlockchairApiParams<T> = T & {
    chain: Chain;
    apiKey: string;
};

declare type BlockchairApiType = ReturnType<typeof blockchairApi>;

export declare interface BlockchairDashboardTransactionResponse {
    [key: string]: {
        transaction: {
            block_id: number;
            id: number;
            hash: string;
            date: string;
            time: string;
            size: number;
            weight: number;
            version: number;
            lock_time: number;
            is_coinbase: boolean;
            has_witness: boolean;
            input_count: number;
            output_count: number;
            input_total: number;
            input_total_usd: number;
            output_total: number;
            output_total_usd: number;
            fee: number;
            fee_usd: number;
            fee_per_kb: number;
            fee_per_kb_usd: number;
            fee_per_kwu: number;
            fee_per_kwu_usd: number;
            cdd_total: number;
            is_rbf: boolean;
        };
        inputs: BlockchairTransactionInputOutput[];
        outputs: BlockchairTransactionInputOutput[];
    };
}

export declare interface BlockchairInputOutputCommonData {
    block_id: number;
    transaction_id: number;
    index: number;
    transaction_hash: string;
    date: string;
    time: string;
    value: number;
    value_usd: number;
    recipient: string;
    type: string;
    script_hex: string;
    is_from_coinbase: boolean;
    is_spendable: boolean | null;
    is_spent: boolean;
    lifespan: number | null;
    cdd: number | null;
}

export declare interface BlockchairMultipleAddressesResponse {
    addresses: {
        [key: string]: BlockchairAddressCoreData;
    };
    transactions: BlockchairTransaction[];
    utxo: BlockchairUtxo[];
    set: {
        address_count: number;
        balance: number;
        balance_usd: number;
        received: number;
        spent: number;
        output_count: number;
        unspent_output_count: number;
        first_seen_receiving: string;
        last_seen_receiving: string;
        first_seen_spending: null | string;
        last_seen_spending: null | string;
        transaction_count: number;
    };
}

export declare interface BlockchairMultipleBalancesResponse {
    [key: string]: number;
}

export declare interface BlockchairOutputsResponse extends BlockchairSpendingBlockData, BlockchairInputOutputCommonData {
}

export declare interface BlockchairRawTransactionResponse {
    [key: string]: {
        raw_transaction: string;
        decoded_raw_transaction: {
            txid: string;
            hash: string;
            version: number;
            size: number;
            vsize: number;
            weight: number;
            locktime: number;
            vin: BlockchairVin[];
            vout: BlockchairVout[];
        };
    };
}

export declare interface BlockchairResponse<T> {
    data: T;
    context: {
        code: number;
        source: string;
        results: number;
        state: number;
        market_price_usd: number;
        cache: {
            live: boolean;
            duration: number;
            since: string;
            until: string;
            time: any;
        };
        api: {
            version: string;
            last_major_update: string;
            next_major_update: null | string;
            documentation: string;
            notice: string;
        };
        servers: string;
        time: number;
        render_time: number;
        full_time: number;
        request_cost: number;
    };
}

export declare interface BlockchairSpendingBlockData {
    spending_block_id: number | null;
    spending_transaction_id: number | null;
    spending_index: number | null;
    spending_transaction_hash: string | null;
    spending_date: string | null;
    spending_time: string | null;
    spending_value_usd: number | null;
    spending_sequence: number | null;
    spending_signature_hex: string | null;
    spending_witness: string | null;
}

export declare interface BlockchairTransaction {
    block_id: number;
    hash: string;
    time: string;
    balance_change: number;
}

export declare interface BlockchairTransactionInputOutput extends BlockchairSpendingBlockData, BlockchairInputOutputCommonData {
    scripthash_type: null | string;
}

export declare interface BlockchairUtxo {
    block_id: number;
    transaction_hash: string;
    index: number;
    value: number;
}

export declare interface BlockchairVin {
    txid: string;
    vout: number;
    scriptSig: {
        asm: string;
        hex: string;
    };
    sequence: number;
}

export declare interface BlockchairVout {
    value: number;
    n: number;
    scriptPubKey: {
        asm: string;
        hex: string;
        address: string;
        type: string;
        addresses: string[];
        reqSigs: number;
    };
}

export declare const BTCToolbox: ({ apiKey, rpcUrl, apiClient, }: {
    apiKey?: string | undefined;
    rpcUrl?: string | undefined;
    apiClient?: {
        getConfirmedBalance: (address: string) => Promise<number>;
        getRawTx: (txHash: string) => Promise<string>;
        getSuggestedTxFee: () => Promise<number>;
        getBalance: (address: string) => Promise<number>;
        getBalanceXpub: (pubkey: string) => Promise<any>;
        getAddressData: (address: string) => Promise<{
            address: BlockchairAddressCoreData;
            transactions: BlockchairTransaction[];
            utxo: BlockchairUtxo[];
        } | {
            utxo: never[];
            address: {
                balance: number;
                transaction_count: number;
            };
        }>;
        scanUTXOs: (params: {
            address: string;
            fetchTxHex?: boolean | undefined;
        }) => Promise<{
            address: string;
            hash: string;
            index: number;
            txHex: string | undefined;
            value: number;
            witnessUtxo: {
                value: number;
                script: Buffer;
            };
        }[]>;
        listUnspent: (pubkey: string, chain: string, apiKey?: string | undefined) => Promise<any>;
    } | undefined;
}) => ReturnType<typeof BaseUTXOToolbox>;

export declare const calculateTxSize: ({ inputs, outputs, feeRate }: UTXOCalculateTxSizeParams) => number;

export declare const compileMemo: (memo: string) => Buffer;

export declare const DASHToolbox: ({ apiKey, rpcUrl, apiClient, }: {
    apiKey?: string | undefined;
    rpcUrl?: string | undefined;
    apiClient?: {
        getConfirmedBalance: (address: string) => Promise<number>;
        getRawTx: (txHash: string) => Promise<string>;
        getSuggestedTxFee: () => Promise<number>;
        getBalance: (address: string) => Promise<number>;
        getBalanceXpub: (pubkey: string) => Promise<any>;
        getAddressData: (address: string) => Promise<{
            address: BlockchairAddressCoreData;
            transactions: BlockchairTransaction[];
            utxo: BlockchairUtxo[];
        } | {
            utxo: never[];
            address: {
                balance: number;
                transaction_count: number;
            };
        }>;
        scanUTXOs: (params: {
            address: string;
            fetchTxHex?: boolean | undefined;
        }) => Promise<{
            address: string;
            hash: string;
            index: number;
            txHex: string | undefined;
            value: number;
            witnessUtxo: {
                value: number;
                script: Buffer;
            };
        }[]>;
        listUnspent: (pubkey: string, chain: string, apiKey?: string | undefined) => Promise<any>;
    } | undefined;
}) => ReturnType<typeof BaseUTXOToolbox>;

export declare const DOGEToolbox: ({ apiKey, rpcUrl, apiClient, }: {
    apiKey?: string | undefined;
    rpcUrl?: string | undefined;
    apiClient?: {
        getConfirmedBalance: (address: string) => Promise<number>;
        getRawTx: (txHash: string) => Promise<string>;
        getSuggestedTxFee: () => Promise<number>;
        getBalance: (address: string) => Promise<number>;
        getBalanceXpub: (pubkey: string) => Promise<any>;
        getAddressData: (address: string) => Promise<{
            address: BlockchairAddressCoreData;
            transactions: BlockchairTransaction[];
            utxo: BlockchairUtxo[];
        } | {
            utxo: never[];
            address: {
                balance: number;
                transaction_count: number;
            };
        }>;
        scanUTXOs: (params: {
            address: string;
            fetchTxHex?: boolean | undefined;
        }) => Promise<{
            address: string;
            hash: string;
            index: number;
            txHex: string | undefined;
            value: number;
            witnessUtxo: {
                value: number;
                script: Buffer;
            };
        }[]>;
        listUnspent: (pubkey: string, chain: string, apiKey?: string | undefined) => Promise<any>;
    } | undefined;
}) => ReturnType<typeof BaseUTXOToolbox>;

export declare const getDustThreshold: (chain: UTXOChain) => 550 | 1 | 5500 | 100000;

export declare const getInputSize: (input: UTXOInputWithScriptType | UTXOType) => number;

export declare const getNetwork: (chain: Chain) => any;

export declare const getOutputSize: (output: TargetOutput, scriptType?: UTXOScriptType) => number;

export declare const getScriptTypeForAddress: (address: string) => UTXOScriptType;

export declare const getSeed: (phrase: string) => Uint8Array;

export declare const getToolboxByChain: <T extends UTXOChain>(chain: T) => Promise<({ apiKey, rpcUrl, apiClient: client, }: {
    apiKey?: string | undefined;
    rpcUrl?: string | undefined;
    apiClient?: {
        getConfirmedBalance: (address: string) => Promise<number>;
        getRawTx: (txHash: string) => Promise<string>;
        getSuggestedTxFee: () => Promise<number>;
        getBalance: (address: string) => Promise<number>;
        getBalanceXpub: (pubkey: string) => Promise<any>;
        getAddressData: (address: string) => Promise<{
            address: BlockchairAddressCoreData;
            transactions: BlockchairTransaction[];
            utxo: BlockchairUtxo[];
        } | {
            utxo: never[];
            address: {
                balance: number;
                transaction_count: number;
            };
        }>;
        scanUTXOs: (params: {
            address: string;
            fetchTxHex?: boolean | undefined;
        }) => Promise<{
            address: string;
            hash: string;
            index: number;
            txHex: string | undefined;
            value: number;
            witnessUtxo: {
                value: number;
                script: Buffer;
            };
        }[]>;
        listUnspent: (pubkey: string, chain: string, apiKey?: string | undefined) => Promise<any>;
    } | undefined;
}) => any>;

export declare const InputSizes: Record<UTXOScriptType, number>;

export declare const LTCToolbox: ({ apiKey, rpcUrl, apiClient, }: {
    apiKey?: string | undefined;
    rpcUrl?: string | undefined;
    apiClient?: {
        getConfirmedBalance: (address: string) => Promise<number>;
        getRawTx: (txHash: string) => Promise<string>;
        getSuggestedTxFee: () => Promise<number>;
        getBalance: (address: string) => Promise<number>;
        getBalanceXpub: (pubkey: string) => Promise<any>;
        getAddressData: (address: string) => Promise<{
            address: BlockchairAddressCoreData;
            transactions: BlockchairTransaction[];
            utxo: BlockchairUtxo[];
        } | {
            utxo: never[];
            address: {
                balance: number;
                transaction_count: number;
            };
        }>;
        scanUTXOs: (params: {
            address: string;
            fetchTxHex?: boolean | undefined;
        }) => Promise<{
            address: string;
            hash: string;
            index: number;
            txHex: string | undefined;
            value: number;
            witnessUtxo: {
                value: number;
                script: Buffer;
            };
        }[]>;
        listUnspent: (pubkey: string, chain: string, apiKey?: string | undefined) => Promise<any>;
    } | undefined;
}) => ReturnType<typeof BaseUTXOToolbox>;

/**
 * Minimum transaction fee
 * 1000 satoshi/kB (similar to current `minrelaytxfee`)
 * @see https://github.com/bitcoin/bitcoin/blob/db88db47278d2e7208c50d16ab10cb355067d071/src/validation.h#L56
 */
export declare const MIN_TX_FEE = 1000;

export declare const OP_RETURN_OVERHEAD: number;

export declare const OutputSizes: Record<UTXOScriptType, number>;

export declare const standardFeeRates: (rate: number) => {
    average: number;
    fast: number;
    fastest: number;
};

export declare type TargetOutput = {
    address: string;
    value: number;
    script?: Buffer;
} | {
    script: Buffer;
    value: number;
};

export declare type TransactionBuilderType = {
    inputs: any[];
    sign(vin: number, keyPair: {
        getAddress: (index?: number) => string;
    }, redeemScript?: Buffer, hashType?: number, witnessValue?: number, witnessScript?: Buffer, signatureAlgorithm?: string): void;
    build(): TransactionType;
};

export declare type TransactionType = {
    toHex(): string;
};

export declare const TX_OVERHEAD: number;

export declare const uniqid: () => string;

export declare type UTXOBaseToolboxParams = {
    apiClient: BlockchairApiType;
    chain: UTXOChain;
};

export declare type UTXOBuildTxParams = {
    assetValue: AssetValue;
    recipient: string;
    memo?: string;
    feeRate: number;
    sender: string;
    fetchTxHex?: boolean;
    apiClient: BlockchairApiType;
    chain: UTXOChain;
};

export declare type UTXOCalculateTxSizeParams = {
    inputs: (UTXOInputWithScriptType | UTXOType)[];
    outputs?: TargetOutput[];
    feeRate: number;
};

export declare type UTXOInputWithScriptType = UTXOType & {
    type: UTXOScriptType;
    address: string;
};

export declare enum UTXOScriptType {
    P2PKH = "P2PKH",
    P2WPKH = "P2WPKH"
}

export declare type UTXOToolbox = ReturnType<typeof BTCToolbox | typeof BCHToolbox | typeof DOGEToolbox | typeof LTCToolbox>;

export declare type UTXOTransferParams = {
    apiClient: BlockchairApiType;
    broadcastTx: (txHex: string) => Promise<string>;
    chain: UTXOChain;
    feeOptionKey?: FeeOption;
    feeRate?: number;
    from: string;
    recipient: string;
    assetValue: AssetValue;
    memo?: string;
};

export declare type UTXOType = {
    hash: string;
    index: number;
    value: number;
    txHex?: string;
    witnessUtxo?: Witness;
};

export declare type UTXOWalletTransferParams<T, U> = UTXOTransferParams & {
    signTransaction: (params: T) => Promise<U>;
};

export declare const validatePhrase: (phrase: string) => boolean;

export declare type Witness = {
    value: number;
    script: Buffer;
};

export { }
