"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionHandler = void 0;
const uuid_1 = require("uuid");
const logger_1 = require("@shapeshiftoss/logger");
class ConnectionHandler {
    constructor(websocket, registry) {
        this.pingInterval = 10000;
        this.subscriptionIds = new Map();
        this.logger = new logger_1.Logger({ namespace: ['unchained', 'coinstacks', 'common', 'api'], level: process.env.LOG_LEVEL });
        this.clientId = (0, uuid_1.v4)();
        this.registry = registry;
        this.routes = {
            txs: {
                subscribe: (subscriptionId, data) => this.handleSubscribeTxs(subscriptionId, data),
                unsubscribe: (subscriptionId, data) => this.handleUnsubscribeTxs(subscriptionId, data),
            },
        };
        const interval = setInterval(() => {
            this.websocket.ping();
        }, this.pingInterval);
        this.heartbeat();
        this.websocket = websocket;
        this.websocket.onerror = (error) => {
            this.logger.error({ clientId: this.clientId, error, fn: 'ws.onerror' }, 'websocket error');
            this.close(interval);
        };
        this.websocket.onclose = ({ code, reason }) => {
            this.logger.debug({ clientId: this.clientId, code, reason, fn: 'ws.close' }, 'websocket closed');
            this.close(interval);
        };
        this.websocket.on('pong', () => this.heartbeat());
        this.websocket.on('ping', () => this.websocket.pong());
        this.websocket.onmessage = (event) => this.onMessage(event);
    }
    static start(websocket, registry) {
        new ConnectionHandler(websocket, registry);
    }
    heartbeat() {
        if (this.pingTimeout) {
            clearTimeout(this.pingTimeout);
        }
        this.pingTimeout = setTimeout(() => {
            this.logger.warn({ fn: 'pingTimeout' }, 'heartbeat failed');
            this.websocket.terminate();
        }, this.pingInterval + 1000);
    }
    sendError(message, subscriptionId) {
        this.websocket.send(JSON.stringify({ subscriptionId, type: 'error', message }));
    }
    onMessage(event) {
        try {
            const payload = JSON.parse(event.data.toString());
            switch (payload.method) {
                // browsers do not support ping/pong frame, handle message instead
                case 'ping': {
                    this.websocket.send('pong');
                    break;
                }
                case 'subscribe':
                case 'unsubscribe': {
                    const topic = payload.data?.topic;
                    if (!topic) {
                        this.sendError(`no topic specified for method: ${payload.method}`, payload.subscriptionId);
                        break;
                    }
                    const callback = this.routes[topic][payload.method];
                    if (callback) {
                        callback(payload.subscriptionId, payload.data);
                    }
                    else {
                        this.sendError(`${payload.method} method not implemented for topic: ${topic}`, payload.subscriptionId);
                    }
                }
            }
        }
        catch (err) {
            this.logger.error(err, { fn: 'onMessage', event }, 'Error processing message');
        }
    }
    close(interval) {
        this.pingTimeout && clearTimeout(this.pingTimeout);
        clearInterval(interval);
        for (const subscriptionId of this.subscriptionIds.keys()) {
            this.registry.unsubscribe(this.clientId, subscriptionId, []);
        }
        this.subscriptionIds.clear();
    }
    handleSubscribeTxs(subscriptionId, data) {
        if (!data?.addresses?.length) {
            this.sendError('addresses required', subscriptionId);
            return;
        }
        this.subscriptionIds.set(subscriptionId);
        this.registry.subscribe(this.clientId, subscriptionId, this, data.addresses);
    }
    handleUnsubscribeTxs(subscriptionId, data) {
        this.subscriptionIds.delete(subscriptionId);
        this.registry.unsubscribe(this.clientId, subscriptionId, data?.addresses ?? []);
    }
    publish(subscriptionId, address, data) {
        const message = { address, data, subscriptionId };
        this.websocket.send(JSON.stringify(message));
    }
}
exports.ConnectionHandler = ConnectionHandler;
//# sourceMappingURL=websocket.js.map