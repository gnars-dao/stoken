"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Registry = void 0;
const logger_1 = require("@shapeshiftoss/logger");
/**
 * The registry keeps track of all client websocket connections and their associated addresses that have been registered.
 * Upon receiving new block or transaction messages from the server side websocket connection to the node,
 * unchained transaction payloads will be sent to any clients that have an address registered that was found in the transaction.
 */
class Registry {
    constructor(args) {
        this.formatAddress = (address) => address.toLowerCase();
        this.logger = new logger_1.Logger({ namespace: ['unchained', 'common', 'api', 'registry'], level: process.env.LOG_LEVEL });
        this.clients = {};
        this.addresses = {};
        this.handleBlock = args.blockHandler;
        this.handleTransaction = args.transactionHandler;
        if (args.addressFormatter)
            this.formatAddress = args.addressFormatter;
    }
    static toId(clientId, subscriptionId) {
        return `${clientId}:${subscriptionId}`;
    }
    static fromId(id) {
        const [clientId, subscriptionId] = id.split(':');
        return { clientId, subscriptionId };
    }
    /**
     * Subscribe to new pending/confirmed transactions for addresses by clientId
     *
     * @param clientId unique client uuid
     * @param subscriptionId unique identifier for a set of addresses
     * @param connection websocket client connection
     * @param addresses list of addresses to subscribe to
     */
    subscribe(clientId, subscriptionId, connection, addresses) {
        const id = Registry.toId(clientId, subscriptionId);
        if (!this.clients[id])
            this.clients[id] = new Map();
        addresses.forEach((address) => {
            address = this.formatAddress(address);
            if (!this.addresses[address])
                this.addresses[address] = new Map();
            this.clients[id].set(address);
            this.addresses[address].set(id, connection);
        });
    }
    /**
     * Unsubscribe from new pending/confirmed transactions for addresses by clientId
     *
     * @param clientId unique client uuid
     * @param subscriptionId unique identifier for a set of addresses
     * @param addresses list of addresses to unsubscribe (empty array will unsubscribe from all currently registered addresses)
     */
    unsubscribe(clientId, subscriptionId, addresses) {
        const id = Registry.toId(clientId, subscriptionId);
        if (!this.clients[id])
            return;
        const unregister = (id, address) => {
            address = this.formatAddress(address);
            // unregister address from client
            this.clients[id].delete(address);
            // delete client from registery if no addresses are registered anymore
            if (!this.clients[id].size)
                delete this.clients[id];
            if (this.addresses[address]) {
                // unregister client from address
                this.addresses[address].delete(id);
                // delete address from registery if no clients are registered anymore
                if (!this.addresses[address].size)
                    delete this.addresses[address];
            }
        };
        if (!addresses.length) {
            for (const address of this.clients[id].keys()) {
                unregister(id, address);
            }
        }
        else {
            for (const address of addresses) {
                unregister(id, address);
            }
        }
    }
    async onBlock(msg) {
        if (!Object.keys(this.clients).length)
            return;
        try {
            const { txs } = await this.handleBlock(msg);
            txs.forEach((tx) => this.onTransaction(tx));
        }
        catch (err) {
            this.logger.error(err, 'failed to handle block');
        }
    }
    async onTransaction(msg) {
        if (!Object.keys(this.clients).length)
            return;
        try {
            const { addresses, tx } = await this.handleTransaction(msg);
            addresses.forEach((address) => {
                address = this.formatAddress(address);
                if (!this.addresses[address])
                    return;
                for (const [id, connection] of this.addresses[address].entries()) {
                    const { subscriptionId } = Registry.fromId(id);
                    connection.publish(subscriptionId, address, tx);
                }
            });
        }
        catch (err) {
            this.logger.error(err, 'failed to handle transaction');
        }
    }
}
exports.Registry = Registry;
//# sourceMappingURL=registry.js.map