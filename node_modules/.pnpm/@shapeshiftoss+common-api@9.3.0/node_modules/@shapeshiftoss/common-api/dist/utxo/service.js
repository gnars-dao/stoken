"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Service = void 0;
const axios_1 = __importDefault(require("axios"));
const axios_retry_1 = __importDefault(require("axios-retry"));
const blockbook_1 = require("@shapeshiftoss/blockbook");
const __1 = require("../");
const utils_1 = require("../utils");
(0, axios_retry_1.default)(axios_1.default, { retries: 5, retryDelay: axios_retry_1.default.exponentialDelay });
const handleError = (err) => {
    if (err instanceof blockbook_1.ApiError) {
        return new __1.ApiError(err.response?.statusText ?? 'Internal Server Error', err.response?.status ?? 500, err.message);
    }
    if (err instanceof Error) {
        return new __1.ApiError('Internal Server Error', 500, err.message);
    }
    return new __1.ApiError('Internal Server Error', 500, 'unknown error');
};
class Service {
    constructor(args) {
        this.formatAddress = (address) => address.toLowerCase();
        this.blockbook = args.blockbook;
        this.rpcUrl = args.rpcUrl;
        this.isXpub = args.isXpub;
        if (args.addressFormatter)
            this.formatAddress = args.addressFormatter;
    }
    async getAccount(pubkey) {
        try {
            const data = await (() => {
                if (this.isXpub(pubkey)) {
                    return this.blockbook.getXpub(pubkey, undefined, undefined, undefined, undefined, 'tokenBalances', 'derived');
                }
                const address = this.formatAddress(pubkey);
                return this.blockbook.getAddress(address, undefined, undefined, undefined, undefined, 'basic');
            })();
            // list of all used addresses with additional derived addresses up to gap limit of 20, including any detected balances
            const addresses = data.tokens?.map((token) => ({
                balance: token.balance ?? '0',
                pubkey: token.name,
            }));
            // For any change indexes detected by blockbook, we want to find the next unused address.
            // To do this we will add 1 to any address indexes found and keep track of the highest index.
            const nextAddressIndexes = (data.tokens ?? []).reduce((prev, token) => {
                if (!token.path || token.transfers === 0)
                    return prev;
                const [, , , , change, addressIndex] = token.path.split('/');
                const changeIndex = Number(change);
                const nextAddressIndex = Number(addressIndex) + 1;
                if (!prev[changeIndex] || nextAddressIndex > prev[changeIndex]) {
                    prev[changeIndex] = nextAddressIndex;
                }
                return prev;
            }, []);
            return {
                pubkey: data.address,
                balance: data.balance,
                unconfirmedBalance: data.unconfirmedBalance,
                addresses,
                nextReceiveAddressIndex: nextAddressIndexes[0] ?? 0,
                nextChangeAddressIndex: nextAddressIndexes[1] ?? 0,
            };
        }
        catch (err) {
            throw handleError(err);
        }
    }
    async getTxHistory(pubkey, cursor, pageSize = 10) {
        (0, utils_1.validatePageSize)(pageSize);
        try {
            const curCursor = (() => {
                try {
                    if (!cursor)
                        return { page: 1 };
                    return JSON.parse(Buffer.from(cursor, 'base64').toString('binary'));
                }
                catch (err) {
                    const e = { error: `invalid base64 cursor: ${cursor}` };
                    throw new __1.ApiError('Bad Request', 422, JSON.stringify(e));
                }
            })();
            const data = await (() => {
                if (this.isXpub(pubkey)) {
                    return this.blockbook.getXpub(pubkey, curCursor.page, pageSize, undefined, undefined, 'txs');
                }
                const address = this.formatAddress(pubkey);
                return this.blockbook.getAddress(address, curCursor.page, pageSize, undefined, undefined, 'txs');
            })();
            curCursor.page++;
            let nextCursor;
            if (curCursor.page <= (data.totalPages ?? 0)) {
                nextCursor = Buffer.from(JSON.stringify(curCursor), 'binary').toString('base64');
            }
            return {
                pubkey: pubkey,
                cursor: nextCursor,
                txs: data.transactions?.map(this.handleTransaction) ?? [],
            };
        }
        catch (err) {
            throw handleError(err);
        }
    }
    async getTransaction(txid) {
        try {
            const data = await this.blockbook.getTransaction(txid);
            return this.handleTransaction(data);
        }
        catch (err) {
            throw handleError(err);
        }
    }
    async getRawTransaction(txid) {
        try {
            const data = await this.blockbook.getTransactionSpecific(txid);
            return data;
        }
        catch (err) {
            throw handleError(err);
        }
    }
    async getUtxos(pubkey) {
        try {
            const data = await this.blockbook.getUtxo(pubkey);
            return data;
        }
        catch (err) {
            throw handleError(err);
        }
    }
    async sendTx(body) {
        try {
            const { result } = await this.blockbook.sendTransaction(body.hex);
            return result;
        }
        catch (err) {
            throw handleError(err);
        }
    }
    async getNetworkFees() {
        try {
            const blockTimes = { fast: 2, average: 5, slow: 10 };
            const result = await this.blockbook.estimateFees(Object.values(blockTimes));
            return Object.entries(blockTimes).reduce((prev, [key, val], index) => {
                const networkFee = {
                    blocksUntilConfirmation: val,
                    satsPerKiloByte: Number(result[index].feePerUnit),
                };
                return { ...prev, [key]: networkFee };
            }, {});
        }
        catch (err) {
            throw handleError(err);
        }
    }
    async handleBlock(hash) {
        const request = {
            jsonrpc: '2.0',
            id: `getblock-${hash}`,
            method: 'getblock',
            params: [hash],
        };
        const { data } = await axios_1.default.post(this.rpcUrl, request);
        if (data.error)
            throw new Error(`failed to get block: ${hash}: ${data.error.message}`);
        if (!data.result)
            throw new Error(`failed to get block: ${hash}: ${JSON.stringify(data)}`);
        const block = data.result;
        // make best effort to fetch all transactions, but don't fail handling block if a single transaction fails
        const txs = await Promise.allSettled(block.tx.map((hash) => this.blockbook.getTransaction(hash)));
        return txs
            .filter((tx) => tx.status === 'fulfilled')
            .map((tx) => tx.value);
    }
    handleTransaction(tx) {
        return {
            txid: tx.txid,
            blockHash: tx.blockHash,
            blockHeight: tx.blockHeight,
            timestamp: tx.blockTime,
            confirmations: tx.confirmations,
            value: tx.value,
            fee: tx.fees ?? '0',
            hex: tx.hex ?? '',
            vin: tx.vin.map((vin) => ({
                txid: vin.txid,
                vout: vin.vout?.toString(),
                sequence: vin.sequence,
                coinbase: vin.coinbase,
                ...(vin.hex && {
                    scriptSig: {
                        hex: vin.hex,
                    },
                }),
                addresses: vin.addresses,
                value: vin.value,
            })),
            vout: tx.vout.map((vout) => ({
                value: vout.value ?? '0',
                n: vout.n,
                ...(!vout.isAddress &&
                    vout.addresses?.length &&
                    vout.addresses[0]?.includes('OP_RETURN') && {
                    opReturn: vout.addresses[0],
                }),
                scriptPubKey: {
                    hex: vout.hex,
                },
                ...(vout.isAddress && {
                    addresses: vout.addresses ?? undefined,
                }),
            })),
        };
    }
}
exports.Service = Service;
//# sourceMappingURL=service.js.map