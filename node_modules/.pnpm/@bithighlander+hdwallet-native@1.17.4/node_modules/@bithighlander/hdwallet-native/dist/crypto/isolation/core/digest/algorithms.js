"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports._initializeAlgorithms = exports.fromWordArray = exports.toWordArray = exports.AlgorithmLength = void 0;
const crypto_js_1 = __importDefault(require("crypto-js"));
exports.AlgorithmLength = {
    "sha1": 20,
    "ripemd160": 20,
    "hash160": 20,
    "sha256": 32,
    "hash256": 32,
    "keccak256": 32,
    "sha512": 64,
};
function toWordArray(x) {
    // TODO: avoid this conversion
    return crypto_js_1.default.enc.Hex.parse(Buffer.from(x).toString("hex"));
    // return (CryptoJS.lib.WordArray.create as unknown as (x: Uint8Array) => CryptoJS.lib.WordArray)(x);
}
exports.toWordArray = toWordArray;
function fromWordArray(x) {
    // TODO: avoid this conversion
    return Buffer.from(crypto_js_1.default.enc.Hex.stringify(x), "hex");
    // return Buffer.alloc(x.sigBytes).map((_, i) => (x.words[i >>> 2] >>> (32 - (((i + 1) & 0x03) << 3))) & 0xff);
}
exports.fromWordArray = fromWordArray;
function _initializeAlgorithms(register) {
    // Using an "any" return value overrides static type checking of the length of the digest. This
    // is OK because there's no ambiguity as to what it should be and it will be checked at runtime.
    try {
        const crypto = require("crypto");
        register("sha1", (x) => crypto.createHash("sha1").update(x).digest());
        register("ripemd160", (x) => crypto.createHash("ripemd160").update(x).digest());
        register("hash160", (x) => crypto.createHash("ripemd160").update(crypto.createHash("sha256").update(x).digest()).digest());
        register("sha256", (x) => crypto.createHash("sha256").update(x).digest());
        register("hash256", (x) => crypto.createHash("sha256").update(crypto.createHash("sha256").update(x).digest()).digest());
        // register("keccak256", (x): any => crypto.createHash("sha3-256").update(x).digest());
        register("keccak256", (x) => fromWordArray(crypto_js_1.default.SHA3(toWordArray(x), { outputLength: 256 })));
        register("sha512", (x) => crypto.createHash("sha512").update(x).digest());
    }
    catch (_a) {
        register("sha1", (x) => fromWordArray(crypto_js_1.default.SHA1(toWordArray(x))));
        register("ripemd160", (x) => fromWordArray(crypto_js_1.default.RIPEMD160(toWordArray(x))));
        register("hash160", (x) => fromWordArray(crypto_js_1.default.RIPEMD160(crypto_js_1.default.SHA256(toWordArray(x)))));
        register("sha256", (x) => fromWordArray(crypto_js_1.default.SHA256(toWordArray(x))));
        register("hash256", (x) => fromWordArray(crypto_js_1.default.SHA256(crypto_js_1.default.SHA256(toWordArray(x)))));
        register("keccak256", (x) => fromWordArray(crypto_js_1.default.SHA3(toWordArray(x), { outputLength: 256 })));
        register("sha512", (x) => fromWordArray(crypto_js_1.default.SHA512(toWordArray(x))));
    }
}
exports._initializeAlgorithms = _initializeAlgorithms;
//# sourceMappingURL=algorithms.js.map