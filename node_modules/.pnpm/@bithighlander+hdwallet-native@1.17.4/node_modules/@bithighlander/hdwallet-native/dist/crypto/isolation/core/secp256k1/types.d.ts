import { Literal, Partial, Object as Obj, Static, Union } from "funtypes";
import { BigEndianInteger, ByteArray } from "../../types";
import { ECDSAKey } from "./interfaces";
declare const fieldElementBase: import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<32>;
}, false>]>, Uint8Array & {
    length: 32;
}, unknown>;
export declare type FieldElement = Static<typeof fieldElementBase>;
declare const fieldElement: import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<32>;
}, false>]>, Uint8Array & {
    length: 32;
}, unknown> & (<T extends number | undefined = undefined>(length?: T | undefined) => T extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T>;
}, false>]>) & (<T_1 extends number | undefined = undefined>(length?: T_1 | undefined) => T_1 extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T_1 ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T_1>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
} & {
    isHigh: <T_2 extends number>(x: BigEndianInteger<T_2>) => boolean;
    isOdd: <T_3 extends number>(x: BigEndianInteger<T_3>) => boolean;
};
export declare const FieldElement: typeof fieldElement;
declare const compressedPointBase: import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<33>;
}, false>]>, Obj<{
    0: Union<[Literal<2>, Literal<3>]>;
}, false>]>, Uint8Array & {
    length: 33;
} & {
    0: 2 | 3;
}, unknown>;
export declare type CompressedPoint = Static<typeof compressedPointBase>;
declare const compressedPoint: import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<33>;
}, false>]>, Obj<{
    0: Union<[Literal<2>, Literal<3>]>;
}, false>]>, Uint8Array & {
    length: 33;
} & {
    0: 2 | 3;
}, unknown> & (<T_1 extends number | undefined = undefined>(length?: T_1 | undefined) => T_1 extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T_1 ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T_1>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
} & {
    from: (p: CurvePoint) => CompressedPoint;
    fromUncompressed: (p: UncompressedPoint) => CompressedPoint;
    x: (p: CompressedPoint) => FieldElement;
    yIsOdd: (p: CompressedPoint) => boolean;
};
export declare const CompressedPoint: typeof compressedPoint;
declare const uncompressedPointBase: import("funtypes").Constraint<import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<65>;
}, false>]>, Obj<{
    0: Literal<4>;
}, false>]>, Uint8Array & {
    length: 65;
} & {
    0: 4;
}, unknown>, Uint8Array & {
    length: 65;
} & {
    0: 4;
}, unknown>;
export declare type UncompressedPoint = Static<typeof uncompressedPointBase>;
declare const uncompressedPoint: import("funtypes").Constraint<import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<65>;
}, false>]>, Obj<{
    0: Literal<4>;
}, false>]>, Uint8Array & {
    length: 65;
} & {
    0: 4;
}, unknown>, Uint8Array & {
    length: 65;
} & {
    0: 4;
}, unknown> & (<T_1 extends number | undefined = undefined>(length?: T_1 | undefined) => T_1 extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T_1 ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T_1>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
} & {
    from: (p: CurvePoint) => UncompressedPoint;
    fromCompressed: (p: CompressedPoint) => UncompressedPoint;
    x: (p: UncompressedPoint) => FieldElement;
    y: (p: UncompressedPoint) => FieldElement;
    yIsOdd: (p: UncompressedPoint) => boolean;
};
export declare const UncompressedPoint: typeof uncompressedPoint;
export declare type CurvePoint = CompressedPoint | UncompressedPoint;
declare const curvePoint: Union<[import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<33>;
}, false>]>, Obj<{
    0: Union<[Literal<2>, Literal<3>]>;
}, false>]>, Uint8Array & {
    length: 33;
} & {
    0: 2 | 3;
}, unknown> & (<T_1 extends number | undefined = undefined>(length?: T_1 | undefined) => T_1 extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T_1 ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T_1>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
} & {
    from: (p: CurvePoint) => CompressedPoint;
    fromUncompressed: (p: UncompressedPoint) => CompressedPoint;
    x: (p: CompressedPoint) => FieldElement;
    yIsOdd: (p: CompressedPoint) => boolean;
}, import("funtypes").Constraint<import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<65>;
}, false>]>, Obj<{
    0: Literal<4>;
}, false>]>, Uint8Array & {
    length: 65;
} & {
    0: 4;
}, unknown>, Uint8Array & {
    length: 65;
} & {
    0: 4;
}, unknown> & (<T_1 extends number | undefined = undefined>(length?: T_1 | undefined) => T_1 extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T_1 ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T_1>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
} & {
    from: (p: CurvePoint) => UncompressedPoint;
    fromCompressed: (p: CompressedPoint) => UncompressedPoint;
    x: (p: UncompressedPoint) => FieldElement;
    y: (p: UncompressedPoint) => FieldElement;
    yIsOdd: (p: UncompressedPoint) => boolean;
}]> & {
    x: (p: CurvePoint) => FieldElement;
    yIsOdd: (p: CurvePoint) => boolean;
    equal: (lhs: CurvePoint, rhs: CurvePoint) => boolean;
};
export declare const CurvePoint: typeof curvePoint;
declare const recoveryParamBase: Union<[Literal<0>, Literal<1>, Literal<2>, Literal<3>]>;
export declare type RecoveryParam = Static<typeof recoveryParamBase>;
declare const recoveryParam: Union<[Literal<0>, Literal<1>, Literal<2>, Literal<3>]>;
export declare const RecoveryParam: typeof recoveryParam;
declare const messageWithPreimageBase: import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<32>;
}, false>]>, import("funtypes").Constraint<import("funtypes").Runtype<(Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "sha1";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "ripemd160";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "hash160";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "sha256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "hash256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "keccak256";
}) | (Uint8Array & {
    length: 64;
} & {
    preimage: Uint8Array;
    algorithm: "sha512";
})>, (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "sha1";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "ripemd160";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "hash160";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "sha256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "hash256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "keccak256";
}) | (Uint8Array & {
    length: 64;
} & {
    preimage: Uint8Array;
    algorithm: "sha512";
}), unknown>]>;
export declare type MessageWithPreimage = Static<typeof messageWithPreimageBase>;
declare const messageWithPreimage: import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<32>;
}, false>]>, import("funtypes").Constraint<import("funtypes").Runtype<(Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "sha1";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "ripemd160";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "hash160";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "sha256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "hash256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "keccak256";
}) | (Uint8Array & {
    length: 64;
} & {
    preimage: Uint8Array;
    algorithm: "sha512";
})>, (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "sha1";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "ripemd160";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "hash160";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "sha256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "hash256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "keccak256";
}) | (Uint8Array & {
    length: 64;
} & {
    preimage: Uint8Array;
    algorithm: "sha512";
}), unknown>]> & (<T_1 extends number | undefined = undefined>(length?: T_1 | undefined) => T_1 extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T_1 ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T_1>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
};
export declare const MessageWithPreimage: typeof messageWithPreimage;
declare const messageBase: Union<[import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<32>;
}, false>]>, import("funtypes").Constraint<import("funtypes").Runtype<(Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "sha1";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "ripemd160";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "hash160";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "sha256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "hash256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "keccak256";
}) | (Uint8Array & {
    length: 64;
} & {
    preimage: Uint8Array;
    algorithm: "sha512";
})>, (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "sha1";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "ripemd160";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "hash160";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "sha256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "hash256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "keccak256";
}) | (Uint8Array & {
    length: 64;
} & {
    preimage: Uint8Array;
    algorithm: "sha512";
}), unknown>]> & (<T_1 extends number | undefined = undefined>(length?: T_1 | undefined) => T_1 extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T_1 ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T_1>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
}, import("funtypes").InstanceOf<Uint8Array>]>;
export declare type Message = Static<typeof messageBase>;
declare const message: Union<[import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<32>;
}, false>]>, import("funtypes").Constraint<import("funtypes").Runtype<(Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "sha1";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "ripemd160";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "hash160";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "sha256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "hash256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "keccak256";
}) | (Uint8Array & {
    length: 64;
} & {
    preimage: Uint8Array;
    algorithm: "sha512";
})>, (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "sha1";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "ripemd160";
}) | (Uint8Array & {
    length: 20;
} & {
    preimage: Uint8Array;
    algorithm: "hash160";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "sha256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "hash256";
}) | (Uint8Array & {
    length: 32;
} & {
    preimage: Uint8Array;
    algorithm: "keccak256";
}) | (Uint8Array & {
    length: 64;
} & {
    preimage: Uint8Array;
    algorithm: "sha512";
}), unknown>]> & (<T_1 extends number | undefined = undefined>(length?: T_1 | undefined) => T_1 extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T_1 ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T_1>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
}, import("funtypes").InstanceOf<Uint8Array>]> & (<T_1 extends number | undefined = undefined>(length?: T_1 | undefined) => T_1 extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T_1 ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T_1>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
};
export declare const Message: typeof message;
declare const signatureBase: import("funtypes").Intersect<[import("funtypes").Constraint<import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<64>;
}, false>]>, Uint8Array & {
    length: 64;
}, unknown>, Uint8Array & {
    length: 64;
}, unknown>, Partial<{
    recoveryParam: Union<[Literal<0>, Literal<1>, Literal<2>, Literal<3>]>;
}, false>]>;
export declare type Signature = Static<typeof signatureBase>;
declare const signature: import("funtypes").Intersect<[import("funtypes").Constraint<import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<64>;
}, false>]>, Uint8Array & {
    length: 64;
}, unknown>, Uint8Array & {
    length: 64;
}, unknown>, Partial<{
    recoveryParam: Union<[Literal<0>, Literal<1>, Literal<2>, Literal<3>]>;
}, false>]> & (<T_1 extends number | undefined = undefined>(length?: T_1 | undefined) => T_1 extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T_1 ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T_1>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
} & {
    r: (x: Signature) => FieldElement;
    s: (x: Signature) => FieldElement;
    isLowR: (x: Signature) => boolean;
    isLowS: (x: Signature) => boolean;
    isCanonical: (x: Signature) => boolean;
    signCanonically: (x: ECDSAKey, message: Message, counter?: number | undefined) => Promise<Signature>;
    verify: (x: Signature, message: Message, publicKey: CurvePoint) => boolean;
};
export declare const Signature: typeof signature;
declare const recoverableSignatureBase: import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").Constraint<import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<64>;
}, false>]>, Uint8Array & {
    length: 64;
}, unknown>, Uint8Array & {
    length: 64;
}, unknown>, Partial<{
    recoveryParam: Union<[Literal<0>, Literal<1>, Literal<2>, Literal<3>]>;
}, false>]> & (<T_1 extends number | undefined = undefined>(length?: T_1 | undefined) => T_1 extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T_1 ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T_1>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
} & {
    r: (x: Signature) => FieldElement;
    s: (x: Signature) => FieldElement;
    isLowR: (x: Signature) => boolean;
    isLowS: (x: Signature) => boolean;
    isCanonical: (x: Signature) => boolean;
    signCanonically: (x: ECDSAKey, message: Message, counter?: number | undefined) => Promise<Signature>;
    verify: (x: Signature, message: Message, publicKey: CurvePoint) => boolean;
}, Obj<{
    recoveryParam: Union<[Literal<0>, Literal<1>, Literal<2>, Literal<3>]>;
}, false>]>;
export declare type RecoverableSignature = Static<typeof recoverableSignatureBase>;
declare const recoverableSignature: import("funtypes").Intersect<[import("funtypes").Intersect<[import("funtypes").Constraint<import("funtypes").Constraint<import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<64>;
}, false>]>, Uint8Array & {
    length: 64;
}, unknown>, Uint8Array & {
    length: 64;
}, unknown>, Partial<{
    recoveryParam: Union<[Literal<0>, Literal<1>, Literal<2>, Literal<3>]>;
}, false>]> & (<T_1 extends number | undefined = undefined>(length?: T_1 | undefined) => T_1 extends undefined ? import("funtypes").InstanceOf<Uint8Array> : unknown extends T_1 ? import("funtypes").InstanceOf<Uint8Array> : import("funtypes").Intersect<[import("funtypes").InstanceOf<Uint8Array>, Obj<{
    length: Literal<T_1>;
}, false>]>) & {
    equal(lhs: Uint8Array, rhs: Uint8Array): boolean;
} & {
    r: (x: Signature) => FieldElement;
    s: (x: Signature) => FieldElement;
    isLowR: (x: Signature) => boolean;
    isLowS: (x: Signature) => boolean;
    isCanonical: (x: Signature) => boolean;
    signCanonically: (x: ECDSAKey, message: Message, counter?: number | undefined) => Promise<Signature>;
    verify: (x: Signature, message: Message, publicKey: CurvePoint) => boolean;
}, Obj<{
    recoveryParam: Union<[Literal<0>, Literal<1>, Literal<2>, Literal<3>]>;
}, false>]> & Omit<{
    r: (x: Signature) => FieldElement;
    s: (x: Signature) => FieldElement;
    isLowR: (x: Signature) => boolean;
    isLowS: (x: Signature) => boolean;
    isCanonical: (x: Signature) => boolean;
    signCanonically: (x: ECDSAKey, message: Message, counter?: number | undefined) => Promise<Signature>;
    verify: (x: Signature, message: Message, publicKey: CurvePoint) => boolean;
}, "from" | "fromSignature" | "isLowRecoveryParam" | "isCanonical" | "signCanonically" | "recoverPublicKey"> & {
    from: (x: ByteArray<65>) => Uint8Array & {
        length: 64;
    } & {
        recoveryParam?: 0 | 2 | 3 | 1 | undefined;
    } & {
        recoveryParam: 0 | 2 | 3 | 1;
    };
    fromSignature: (x: Signature, message: Message, publicKey: CurvePoint) => RecoverableSignature;
    isLowRecoveryParam: (x: RecoverableSignature) => boolean;
    isCanonical: (x: RecoverableSignature) => boolean;
    signCanonically: (x: ECDSAKey, message: Message, counter?: number | undefined) => Promise<RecoverableSignature>;
    recoverPublicKey: (x: RecoverableSignature, message: Message) => CurvePoint;
};
export declare const RecoverableSignature: typeof recoverableSignature;
export {};
//# sourceMappingURL=types.d.ts.map