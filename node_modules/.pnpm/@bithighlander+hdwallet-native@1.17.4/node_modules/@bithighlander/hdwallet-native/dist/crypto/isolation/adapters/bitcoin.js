"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ECPairAdapter = void 0;
const networks_1 = require("@bithighlander/bitcoin-cash-js-lib/src/networks");
const core_1 = require("../core");
const DigestSourceHint = Symbol.for("hdwallet_isolation_digest_source_hint");
class ECPairAdapter {
    constructor(isolatedKey, network) {
        this.compressed = false;
        this.lowR = false;
        this._isolatedKey = isolatedKey;
        this._network = network;
    }
    get network() {
        var _a;
        return (_a = this._network) !== null && _a !== void 0 ? _a : networks_1.bitcoin;
    }
    get ecdsaSign() {
        return this._isolatedKey.ecdsaSign.bind(this._isolatedKey);
    }
    get ecdh() {
        const isolatedKey = this._isolatedKey;
        if (!("ecdh" in isolatedKey && typeof isolatedKey.ecdh === "function"))
            return undefined;
        return isolatedKey.ecdh.bind(isolatedKey);
    }
    get ecdhRaw() {
        const isolatedKey = this._isolatedKey;
        if (!("ecdhRaw" in isolatedKey && typeof isolatedKey.ecdhRaw === "function"))
            return undefined;
        return isolatedKey.ecdhRaw.bind(isolatedKey);
    }
    sign(hash, lowR) {
        return __awaiter(this, void 0, void 0, function* () {
            const hint = (DigestSourceHint in hash ? hash[DigestSourceHint] : undefined);
            const msg = Object.assign(Buffer.from(hash), hint !== null && hint !== void 0 ? hint : {});
            lowR = lowR !== null && lowR !== void 0 ? lowR : this.lowR;
            const sig = (!lowR ? yield this._isolatedKey.ecdsaSign(msg) : yield core_1.SecP256K1.Signature.signCanonically(this._isolatedKey, hash));
            return Buffer.from(sig);
        });
    }
    get publicKey() { return this.getPublicKey(); }
    getPublicKey() {
        const publicKey = this._isolatedKey.publicKey;
        const key = (this.compressed ? core_1.SecP256K1.CompressedPoint.from(publicKey) : core_1.SecP256K1.UncompressedPoint.from(publicKey));
        return Buffer.from(key);
    }
    toWIF() { throw new core_1.IsolationError("WIF"); }
    verify(hash, signature) {
        core_1.SecP256K1.Signature.assert(signature);
        return core_1.SecP256K1.Signature.verify(signature, hash, this._isolatedKey.publicKey);
    }
}
exports.ECPairAdapter = ECPairAdapter;
exports.default = ECPairAdapter;
//# sourceMappingURL=bitcoin.js.map