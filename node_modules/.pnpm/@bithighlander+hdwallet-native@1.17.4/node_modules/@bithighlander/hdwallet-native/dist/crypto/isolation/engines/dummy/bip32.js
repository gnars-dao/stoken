"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Seed_seed, _Node_privateKey, _Node_publicKey;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Node = exports.Seed = void 0;
__exportStar(require("../../core/bip32"), exports);
const BIP32 = __importStar(require("../../core/bip32"));
const bip32crypto = __importStar(require("bip32/src/crypto"));
const tinyecc = __importStar(require("tiny-secp256k1"));
const web_encoding_1 = require("web-encoding");
const types_1 = require("../../types");
const core_1 = require("../../core");
class Seed {
    constructor(seed) {
        _Seed_seed.set(this, void 0);
        __classPrivateFieldSet(this, _Seed_seed, (0, types_1.safeBufferFrom)(seed), "f");
    }
    toMasterKey(hmacKey) {
        if (hmacKey !== undefined && typeof hmacKey !== "string" && !(hmacKey instanceof Uint8Array))
            throw new Error("bad hmacKey type");
        // AFIAK all BIP32 implementations use the "Bitcoin seed" string for this derivation, even if they aren't otherwise Bitcoin-related
        hmacKey = hmacKey !== null && hmacKey !== void 0 ? hmacKey : "Bitcoin seed";
        if (typeof hmacKey === "string")
            hmacKey = new web_encoding_1.TextEncoder().encode(hmacKey.normalize("NFKD"));
        const I = (0, types_1.safeBufferFrom)(bip32crypto.hmacSHA512((0, types_1.safeBufferFrom)(hmacKey), __classPrivateFieldGet(this, _Seed_seed, "f")));
        const IL = I.slice(0, 32);
        const IR = I.slice(32, 64);
        return new Node(IL, IR);
    }
}
exports.Seed = Seed;
_Seed_seed = new WeakMap();
class Node {
    constructor(privateKey, chainCode) {
        _Node_privateKey.set(this, void 0);
        _Node_publicKey.set(this, void 0);
        // We avoid handing the private key to any non-platform code -- including our type-checking machinery.
        if (privateKey.length !== 32)
            throw new Error("bad private key length");
        __classPrivateFieldSet(this, _Node_privateKey, (0, types_1.safeBufferFrom)(privateKey), "f");
        this.chainCode = (0, types_1.safeBufferFrom)((0, types_1.checkType)(BIP32.ChainCode, chainCode));
    }
    get publicKey() {
        var _a;
        __classPrivateFieldSet(this, _Node_publicKey, (_a = __classPrivateFieldGet(this, _Node_publicKey, "f")) !== null && _a !== void 0 ? _a : (0, types_1.checkType)(core_1.SecP256K1.CompressedPoint, tinyecc.pointFromScalar(__classPrivateFieldGet(this, _Node_privateKey, "f"), true)), "f");
        return __classPrivateFieldGet(this, _Node_publicKey, "f");
    }
    ecdsaSign(msg, counter) {
        return __awaiter(this, void 0, void 0, function* () {
            core_1.SecP256K1.Message.assert(msg);
            counter === undefined || types_1.Uint32.assert(counter);
            // When running tests, this will keep us aware of any codepaths that don't pass in the preimage
            if (typeof expect === "function")
                expect(core_1.SecP256K1.MessageWithPreimage.test(msg)).toBeTruthy();
            const entropy = (counter === undefined ? undefined : Buffer.alloc(32));
            entropy === null || entropy === void 0 ? void 0 : entropy.writeUInt32BE(counter !== null && counter !== void 0 ? counter : 0, 24);
            return core_1.SecP256K1.RecoverableSignature.fromSignature((0, types_1.checkType)(core_1.SecP256K1.Signature, tinyecc.signWithEntropy(Buffer.from(msg), __classPrivateFieldGet(this, _Node_privateKey, "f"), entropy)), msg, this.publicKey);
        });
    }
    derive(index) {
        types_1.Uint32.assert(index);
        let serP = Buffer.alloc(37);
        if (index < 0x80000000) {
            serP.set(core_1.SecP256K1.CompressedPoint.from(this.publicKey), 0);
        }
        else {
            serP.set(__classPrivateFieldGet(this, _Node_privateKey, "f"), 1);
        }
        serP.writeUInt32BE(index, 33);
        const I = bip32crypto.hmacSHA512(this.chainCode, serP);
        const IL = I.slice(0, 32);
        const IR = I.slice(32, 64);
        const ki = tinyecc.privateAdd(__classPrivateFieldGet(this, _Node_privateKey, "f"), IL);
        if (ki === null)
            throw new Error("ki is null; this should be cryptographically impossible");
        return new Node(ki, IR);
    }
    ecdh(publicKey, digestAlgorithm) {
        return __awaiter(this, void 0, void 0, function* () {
            core_1.SecP256K1.CurvePoint.assert(publicKey);
            digestAlgorithm === undefined || core_1.Digest.AlgorithmName(32).assert(digestAlgorithm);
            return (0, types_1.checkType)((0, types_1.ByteArray)(32), yield this._ecdh(publicKey, digestAlgorithm));
        });
    }
    ecdhRaw(publicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, types_1.checkType)(core_1.SecP256K1.UncompressedPoint, yield this._ecdh(publicKey, null));
        });
    }
    _ecdh(publicKey, digestAlgorithm) {
        return __awaiter(this, void 0, void 0, function* () {
            core_1.SecP256K1.CurvePoint.assert(publicKey);
            digestAlgorithm === undefined || digestAlgorithm === null || core_1.Digest.AlgorithmName(32).assert(digestAlgorithm);
            const sharedFieldElement = (0, types_1.checkType)(core_1.SecP256K1.UncompressedPoint, tinyecc.pointMultiply(Buffer.from(publicKey), __classPrivateFieldGet(this, _Node_privateKey, "f"), false));
            if (digestAlgorithm === null)
                return sharedFieldElement;
            let out = core_1.SecP256K1.CurvePoint.x(sharedFieldElement);
            if (digestAlgorithm !== undefined)
                out = core_1.Digest.Algorithms[digestAlgorithm](out);
            return out;
        });
    }
}
exports.Node = Node;
_Node_privateKey = new WeakMap(), _Node_publicKey = new WeakMap();
//# sourceMappingURL=bip32.js.map