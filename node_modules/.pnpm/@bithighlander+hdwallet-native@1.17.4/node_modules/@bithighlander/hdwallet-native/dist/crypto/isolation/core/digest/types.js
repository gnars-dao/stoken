"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Algorithms = exports.Digest = exports.AlgorithmName = void 0;
const funtypes_1 = require("funtypes");
const types_1 = require("../../types");
const algorithms_1 = require("./algorithms");
const types_2 = require("../../types");
// These names come from the keys on the AlgorithmLength object. We'd prefer not
// to repeat them here, which means we have to build the Enum object in a way that
// type inference can't follow. Luckily, because the names are statically known,
// we can assert the type even though it can't be inferred.
function algorithmNameBase(length) {
    return (0, funtypes_1.Enum)(`AlgorithmName(${length !== null && length !== void 0 ? length : ""})`, Object.entries(algorithms_1.AlgorithmLength)
        .filter(x => length === undefined || length === x[1])
        .map(x => x[0])
        .reduce((a, x) => Object.assign(a, { [x]: x }), {}));
}
;
const algorithmNameStatic = {
    forEach(callbackfn, thisarg) {
        Object.keys((0, exports.AlgorithmName)().enumObject).forEach(callbackfn, thisarg);
    },
};
const algorithmName = Object.assign(algorithmNameBase, algorithmNameBase(), algorithmNameStatic);
exports.AlgorithmName = algorithmName;
function specificUnverifiedDigest(name) {
    return (0, funtypes_1.Object)({
        preimage: (0, types_1.ByteArray)(),
        algorithm: (0, funtypes_1.Literal)(name),
    }).And((0, types_1.ByteArray)(algorithms_1.AlgorithmLength[name]));
}
function unverifiedDigestBase(name) {
    if (name !== undefined)
        return specificUnverifiedDigest(name);
    return Object.keys(exports.AlgorithmName.enumObject).reduce((a, x) => {
        return a.Or(specificUnverifiedDigest(x));
    }, funtypes_1.Never);
}
const unverifiedDigestStatic = {};
const unverifiedDigest = Object.assign(unverifiedDigestBase, types_1.ByteArray, unverifiedDigestStatic);
// We need the UnverifiedDigest type to enable us to build the Algorithm contract without
// trying to recursively verify verified verifications. That said, it's not exported; only
// actual algorithm functions we're wrapping should be able to use it.
const UnverifiedDigest = unverifiedDigest;
function digestBase(name) {
    return UnverifiedDigest(name).withConstraint(x => types_1.ByteArray.equal(x, exports.Algorithms[x.algorithm](x.preimage)) || `expected ${x} to equal the ${x.algorithm} digest of ${x.preimage}`, { name: `Digest(${name})` });
}
const digestStatic = {};
const digest = Object.assign(digestBase, UnverifiedDigest, digestStatic);
exports.Digest = digest;
// We use UnverifiedDigest instead of Digest in the contract because the result is implicitly trusted.
function algorithmBase(name) {
    return (0, funtypes_1.Contract)([(0, types_1.ByteArray)()], UnverifiedDigest(name));
}
const algorithmStatic = {};
const algorithm = Object.assign(algorithmBase, algorithmStatic);
// This isn't exported; only the registration function below should be using it.
const Algorithm = algorithm;
exports.Algorithms = (() => {
    const algorithms = {};
    (0, algorithms_1._initializeAlgorithms)((name, fn) => {
        exports.AlgorithmName.assert(name);
        if (name in algorithms)
            throw new Error(`digest algorithm implementation already provided for ${name}`);
        algorithms[name] = Algorithm(name).enforce((x) => {
            const out = (0, types_2.checkType)((0, types_1.ByteArray)(algorithms_1.AlgorithmLength[name]), fn(x));
            out.preimage = x;
            out.algorithm = name;
            return (0, types_2.checkType)(UnverifiedDigest(name), out);
        });
    });
    Object.freeze(algorithms);
    exports.AlgorithmName.forEach(x => {
        if (!algorithms[x])
            throw new Error(`digest algorithm implementation missing for ${x}`);
    });
    return algorithms;
})();
//# sourceMappingURL=types.js.map