"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CipherString = void 0;
/*
 Copied from portis: packages/portis-crypto/src/models/cipherString.ts
 */
const utils_1 = require("../utils");
const encryptedObject_1 = require("./encryptedObject");
const encryptionType_1 = require("./encryptionType");
class CipherString {
    constructor(cipher) {
        this.encryptionType = encryptionType_1.EncryptionType.AesCbc256_HmacSha256_B64;
        let data, iv, mac;
        if (typeof cipher === "string") {
            try {
                const header = cipher.split(".");
                this.encryptionType = Number(header[0]);
                [data, iv, mac] = header[1].split("|");
            }
            catch (e) {
                throw new Error("Invalid cipher string");
            }
        }
        else if (cipher instanceof encryptedObject_1.EncryptedObject) {
            try {
                this.encryptionType = cipher.key.encType;
                if (cipher.iv)
                    iv = (0, utils_1.fromBufferToB64)(cipher.iv);
                if (cipher.data)
                    data = (0, utils_1.fromBufferToB64)(cipher.data);
                if (cipher.mac)
                    mac = (0, utils_1.fromBufferToB64)(cipher.mac);
            }
            catch (_a) {
                throw new Error("Invalid encryption object");
            }
        }
        else {
            throw new Error("Invalid cipher data. You must provide a string or Encrypted Object");
        }
        if (!encryptionType_1.EncryptionType[this.encryptionType]) {
            throw new Error("Unsupported encryption method");
        }
        if (!data)
            throw new Error("Encrypted data is missing");
        this.data = data;
        if (!iv)
            throw new Error("IV is missing");
        this.iv = iv;
        if (!mac)
            throw new Error("HMAC signature is missing");
        this.mac = mac;
    }
    get encryptedString() {
        return `${this.encryptionType}.${[this.data, this.iv, this.mac].join("|")}`;
    }
    toEncryptedObject(key) {
        return new encryptedObject_1.EncryptedObject({
            data: (0, utils_1.fromB64ToArray)(this.data),
            iv: (0, utils_1.fromB64ToArray)(this.iv),
            mac: (0, utils_1.fromB64ToArray)(this.mac),
            key,
        });
    }
}
exports.CipherString = CipherString;
//# sourceMappingURL=cipherString.js.map