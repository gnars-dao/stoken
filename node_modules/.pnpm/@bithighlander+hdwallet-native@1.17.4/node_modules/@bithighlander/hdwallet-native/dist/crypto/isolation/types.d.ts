/// <reference types="node" />
import { Number as Num, InstanceOf, Object as Obj, Literal, Static, String as Str, Never, Runtype } from "funtypes";
declare const positive: import("funtypes").Constraint<Num, number, unknown>;
export declare type Positive = Static<typeof positive>;
export declare const Positive: typeof positive;
declare const negative: import("funtypes").Constraint<Num, number, unknown>;
export declare type Negative = Static<typeof negative>;
export declare const Negative: typeof negative;
declare const nonNegative: import("funtypes").Constraint<Num, number, unknown>;
export declare type NonNegative = Static<typeof nonNegative>;
export declare const NonNegative: typeof nonNegative;
declare const nonPositive: import("funtypes").Constraint<Num, number, unknown>;
export declare type NonPositive = Static<typeof nonPositive>;
export declare const NonPositive: typeof nonPositive;
export declare const integer: import("funtypes").Constraint<Num, number, unknown>;
export declare type Integer = Static<typeof integer>;
export declare const Integer: typeof integer;
declare const positiveInteger: import("funtypes").Intersect<[import("funtypes").Constraint<Num, number, unknown>, import("funtypes").Constraint<Num, number, unknown>]>;
export declare type PositiveInteger = Static<typeof positiveInteger>;
export declare const PositiveInteger: typeof positiveInteger;
declare const negativeInteger: import("funtypes").Intersect<[import("funtypes").Constraint<Num, number, unknown>, import("funtypes").Constraint<Num, number, unknown>]>;
export declare type NegativeInteger = Static<typeof negativeInteger>;
export declare const NegativeInteger: typeof negativeInteger;
declare const nonPositiveInteger: import("funtypes").Intersect<[import("funtypes").Constraint<Num, number, unknown>, import("funtypes").Constraint<Num, number, unknown>]>;
export declare type NonPositiveInteger = Static<typeof nonPositiveInteger>;
export declare const NonPositiveInteger: typeof nonPositiveInteger;
declare const nonNegativeInteger: import("funtypes").Intersect<[import("funtypes").Constraint<Num, number, unknown>, import("funtypes").Constraint<Num, number, unknown>]>;
export declare type NonNegativeInteger = Static<typeof nonNegativeInteger>;
export declare const NonNegativeInteger: typeof nonNegativeInteger;
declare const uint: import("funtypes").Union<[import("funtypes").Intersect<[import("funtypes").Constraint<Num, number, unknown>, import("funtypes").Constraint<Num, number, unknown>]>, Never]>;
export declare type Uint = Static<typeof uint>;
export declare const Uint: typeof uint;
declare const uint32: import("funtypes").Constraint<Num, number, unknown>;
export declare type Uint32 = Static<typeof uint32>;
export declare const Uint32: typeof uint32;
declare const uint16: import("funtypes").Constraint<Num, number, unknown>;
export declare type Uint16 = Static<typeof uint16>;
export declare const Uint16: typeof uint16;
declare const uint8: import("funtypes").Constraint<Num, number, unknown>;
export declare type Uint8 = Static<typeof uint8>;
export declare const Uint8: typeof uint8;
declare function boundedUintBase<T extends NonNegativeInteger>(max: T): import("funtypes").Constraint<import("funtypes").Union<[import("funtypes").Intersect<[import("funtypes").Constraint<Num, number, unknown>, import("funtypes").Constraint<Num, number, unknown>]>, Never]>, number, unknown> & {
    max: T;
};
export declare type BoundedUint<T extends NonNegativeInteger> = Static<typeof Uint> & {
    max: T;
};
declare const boundedUint: typeof boundedUintBase;
export declare const BoundedUint: typeof boundedUint;
declare function boundedStringBase<T extends RegExp>(regex: T): import("funtypes").Constraint<Str, string, unknown> & {
    regex: T;
};
export declare type BoundedString<T extends RegExp> = Static<typeof Str> & {
    regex: T;
};
declare const boundedString: typeof boundedStringBase;
export declare const BoundedString: typeof boundedString;
export declare function checkType<T extends Runtype<unknown>>(rt: T, value: any): Static<T>;
declare type Ternary<T, U, V> = T extends undefined ? V : unknown extends T ? V : U;
declare function byteArrayBase<T extends NonNegativeInteger | undefined = undefined>(length?: T): Ternary<T, import("funtypes").Intersect<[InstanceOf<Uint8Array>, Obj<{
    length: Literal<T>;
}, false>]>, InstanceOf<Uint8Array>>;
export declare type ByteArray<T extends NonNegativeInteger | undefined = undefined> = Uint8Array & (T extends undefined ? unknown : {
    length: T;
});
declare const byteArray: typeof byteArrayBase & {
    equal(lhs: ByteArray, rhs: ByteArray): boolean;
};
export declare const ByteArray: typeof byteArray;
declare function bigEndianIntegerBase<T extends NonNegativeInteger | undefined = undefined>(length?: T): Ternary<T, import("funtypes").Intersect<[InstanceOf<Uint8Array>, Obj<{
    length: Literal<T>;
}, false>]>, InstanceOf<Uint8Array>>;
export declare type BigEndianInteger<T extends NonNegativeInteger | undefined> = ByteArray<T>;
declare const bigEndianInteger: typeof bigEndianIntegerBase & typeof byteArrayBase & {
    equal(lhs: ByteArray, rhs: ByteArray): boolean;
} & {
    isHigh: <T extends number>(x: BigEndianInteger<T>) => boolean;
    isOdd: <T_1 extends number>(x: BigEndianInteger<T_1>) => boolean;
};
export declare const BigEndianInteger: typeof bigEndianInteger;
export declare function safeBufferFrom<T extends NonNegativeInteger | undefined = undefined>(input: ByteArray<T>): Buffer & ByteArray<T>;
export {};
//# sourceMappingURL=types.d.ts.map