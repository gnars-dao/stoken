"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecoverableSignature = exports.Signature = exports.Message = exports.MessageWithPreimage = exports.RecoveryParam = exports.CurvePoint = exports.UncompressedPoint = exports.CompressedPoint = exports.FieldElement = void 0;
const core = __importStar(require("@bithighlander/hdwallet-core"));
const ethers = __importStar(require("ethers"));
const funtypes_1 = require("funtypes");
const tinyecc = __importStar(require("tiny-secp256k1"));
const digest_1 = require("../digest");
const types_1 = require("../../types");
const fieldElementBase = (0, types_1.BigEndianInteger)(32).withConstraint(x => tinyecc.isPrivate((0, types_1.safeBufferFrom)(x)) || `expected ${x} to be within the order of the curve`, { name: "FieldElement" });
const fieldElementStatic = {};
const fieldElement = Object.assign(fieldElementBase, types_1.BigEndianInteger, fieldElementStatic);
exports.FieldElement = fieldElement;
const compressedPointBase = (0, types_1.ByteArray)(33).And((0, funtypes_1.Object)({
    0: (0, funtypes_1.Literal)(0x02).Or((0, funtypes_1.Literal)(0x03)),
})).withConstraint(p => exports.FieldElement.test(p.slice(1)) || `expected ${p}.x to be within the order of the curve`, { name: "CompressedPoint.x" });
const compressedPointStatic = {
    from: (p) => {
        return (p.length === 33 ? p : exports.CompressedPoint.fromUncompressed((0, types_1.checkType)(exports.UncompressedPoint, p)));
    },
    fromUncompressed: (p) => {
        const out = new Uint8Array(33);
        out[0] = (exports.UncompressedPoint.yIsOdd(p) ? 0x03 : 0x02);
        out.set(exports.UncompressedPoint.x(p), 1);
        exports.CompressedPoint.assert(out);
        return out;
    },
    x: (p) => { return (0, types_1.checkType)(exports.FieldElement, p.slice(1)); },
    yIsOdd: (p) => { return p[0] === 0x03; }
};
const compressedPoint = Object.assign(compressedPointBase, types_1.ByteArray, compressedPointStatic);
exports.CompressedPoint = compressedPoint;
const uncompressedPointBase = (0, types_1.ByteArray)(65).And((0, funtypes_1.Object)({
    0: (0, funtypes_1.Literal)(0x04),
})).withConstraint(p => exports.FieldElement.test(p.slice(1, 33)) || `expected ${p}.x to be within the order of the curve`, { name: "UncompressedPoint.x" }).withConstraint(p => {
    if (!exports.FieldElement.test(p.slice(33, 65)))
        return `expected ${p}.y to be within the order of the curve`;
    const pBuf = Buffer.from(p);
    if (!types_1.ByteArray.equal(tinyecc.pointCompress(tinyecc.pointCompress(pBuf, true), false), pBuf))
        return `expected ${p} to be on the curve`;
    return true;
}, { name: "UncompressedPoint.y" });
const uncompressedPointStatic = {
    from: (p) => {
        return (p.length === 65 ? p : exports.UncompressedPoint.fromCompressed((0, types_1.checkType)(exports.CompressedPoint, p)));
    },
    fromCompressed: (p) => {
        return (0, types_1.checkType)(exports.UncompressedPoint, tinyecc.pointCompress(Buffer.from(p), false));
    },
    x: (p) => { return (0, types_1.checkType)(exports.FieldElement, p.slice(1, 33)); },
    y: (p) => { return (0, types_1.checkType)(exports.FieldElement, p.slice(33, 65)); },
    yIsOdd: (p) => { return exports.FieldElement.isOdd(exports.UncompressedPoint.y(p)); },
};
const uncompressedPoint = Object.assign(uncompressedPointBase, types_1.ByteArray, uncompressedPointStatic);
exports.UncompressedPoint = uncompressedPoint;
const curvePointBase = exports.CompressedPoint.Or(exports.UncompressedPoint);
const curvePointStatic = {
    x: (p) => (p[0] === 0x04 ? exports.UncompressedPoint.x(p) : exports.CompressedPoint.x(p)),
    yIsOdd: (p) => (p[0] === 0x04 ? exports.UncompressedPoint.yIsOdd(p) : exports.CompressedPoint.yIsOdd(p)),
    // Equivalent to CompressedPoint.equal(CompressedPoint.from(lhs), CompressedPoint.from(rhs)), but avoids allocations
    equal: (lhs, rhs) => exports.CurvePoint.yIsOdd(lhs) === exports.CurvePoint.yIsOdd(rhs) && exports.FieldElement.equal(exports.CurvePoint.x(lhs), exports.CurvePoint.x(rhs)),
};
const curvePoint = Object.assign(curvePointBase, curvePointStatic);
exports.CurvePoint = curvePoint;
const recoveryParamBase = (0, funtypes_1.Union)((0, funtypes_1.Literal)(0), (0, funtypes_1.Literal)(1), (0, funtypes_1.Literal)(2), (0, funtypes_1.Literal)(3));
const recoveryParamStatic = {};
const recoveryParam = Object.assign(recoveryParamBase, recoveryParamStatic);
exports.RecoveryParam = recoveryParam;
const messageWithPreimageBase = (0, types_1.ByteArray)(32).And((0, digest_1.Digest)());
const messageWithPreimageStatic = {};
const messageWithPreimage = Object.assign(messageWithPreimageBase, types_1.ByteArray, messageWithPreimageStatic);
exports.MessageWithPreimage = messageWithPreimage;
const messageBase = exports.MessageWithPreimage.Or((0, types_1.ByteArray)());
const messageStatic = {};
const message = Object.assign(messageBase, types_1.ByteArray, messageWithPreimageStatic, messageStatic);
exports.Message = message;
const signatureBase = (0, types_1.ByteArray)(64).withConstraint(x => exports.FieldElement.test(x.slice(0, 32)) || `expected ${x}.r to be within the order of the curve`, { name: "Signature.r" }).withConstraint(x => exports.FieldElement.test(x.slice(32, 64)) || `expected ${x}.s to be within the order of the curve`, { name: "Signature.s" }).And((0, funtypes_1.Partial)({
    recoveryParam: exports.RecoveryParam,
}));
const signatureStatic = {
    r: (x) => { return (0, types_1.checkType)(exports.FieldElement, x.slice(0, 32)); },
    s: (x) => { return (0, types_1.checkType)(exports.FieldElement, x.slice(32, 64)); },
    isLowR: (x) => { return !exports.FieldElement.isHigh(exports.Signature.r(x)); },
    isLowS: (x) => { return !exports.FieldElement.isHigh(exports.Signature.s(x)); },
    isCanonical: (x) => { return exports.Signature.isLowR(x) && exports.Signature.isLowS(x); },
    signCanonically: (x, message, counter) => __awaiter(void 0, void 0, void 0, function* () {
        counter === undefined || types_1.Uint32.assert(counter);
        for (let i = counter; i === undefined || i < (counter !== null && counter !== void 0 ? counter : 0) + 128; i = (i !== null && i !== void 0 ? i : -1) + 1) {
            const sig = i === undefined ? yield x.ecdsaSign(message) : yield x.ecdsaSign(message, i);
            if (sig === undefined)
                break;
            //TODO: do integrated lowS correction
            if (exports.Signature.isCanonical(sig))
                return sig;
        }
        // This is cryptographically impossible (2^-128 chance) if the key is implemented correctly.
        throw new Error(`Unable to generate canonical signature with public key ${x} over message ${message}; is your key implementation broken?`);
    }),
    verify: (x, message, publicKey) => {
        return tinyecc.verify(Buffer.from(message), Buffer.from(publicKey), Buffer.from(x));
    },
};
const signature = Object.assign(signatureBase, types_1.ByteArray, signatureStatic);
exports.Signature = signature;
const recoverableSignatureBase = exports.Signature.And((0, funtypes_1.Object)({
    recoveryParam: exports.RecoveryParam,
}));
const recoverableSignatureStatic = {
    from: (x) => {
        const out = (0, types_1.checkType)(exports.Signature, x.slice(0, 64));
        out.recoveryParam = (0, types_1.checkType)(exports.RecoveryParam, x[64]);
        return (0, types_1.checkType)(exports.RecoverableSignature, out);
    },
    fromSignature: (x, message, publicKey) => {
        if (exports.RecoverableSignature.test(x))
            return x;
        const out = Buffer.from(x);
        for (out.recoveryParam = 0; out.recoveryParam < 4; out.recoveryParam++) {
            if (!exports.CurvePoint.equal(publicKey, exports.RecoverableSignature.recoverPublicKey(out, message)))
                continue;
            return (0, types_1.checkType)(exports.RecoverableSignature, out);
        }
        throw new Error(`couldn't find recovery parameter producing public key ${publicKey} for signature ${x} over message ${message}`);
    },
    isLowRecoveryParam: (x) => x.recoveryParam === 0 || x.recoveryParam === 1,
    isCanonical: (x) => exports.Signature.isCanonical(x) && exports.RecoverableSignature.isLowRecoveryParam(x),
    signCanonically: (x, message, counter) => __awaiter(void 0, void 0, void 0, function* () {
        counter === undefined || types_1.Uint32.assert(counter);
        for (let i = counter; i === undefined || i < (counter !== null && counter !== void 0 ? counter : 0) + 128; i = (i !== null && i !== void 0 ? i : -1) + 1) {
            const sig = i === undefined ? yield x.ecdsaSign(message) : yield x.ecdsaSign(message, i);
            if (sig === undefined)
                break;
            const recoverableSig = exports.RecoverableSignature.fromSignature(sig, message, x.publicKey);
            //TODO: do integrated lowS correction
            if (exports.RecoverableSignature.isCanonical(recoverableSig))
                return recoverableSig;
        }
        // This is cryptographically impossible (2^-128 chance) if the key is implemented correctly.
        throw new Error(`Unable to generate canonical recoverable signature with public key ${Buffer.from(x.publicKey).toString("hex")} over message ${Buffer.from(message).toString("hex")}; is your key implementation broken?`);
    }),
    recoverPublicKey: (x, message) => {
        // TODO: do this better
        const ethSigBytes = core.compatibleBufferConcat([x, Buffer.from([x.recoveryParam])]);
        const ethRecovered = ethers.utils.recoverPublicKey(message, ethers.utils.splitSignature(ethSigBytes));
        return (0, types_1.checkType)(exports.UncompressedPoint, Buffer.from(ethRecovered.slice(2), "hex"));
    },
};
const recoverableSignature = Object.assign(recoverableSignatureBase, signatureStatic, recoverableSignatureStatic);
exports.RecoverableSignature = recoverableSignature;
//# sourceMappingURL=types.js.map