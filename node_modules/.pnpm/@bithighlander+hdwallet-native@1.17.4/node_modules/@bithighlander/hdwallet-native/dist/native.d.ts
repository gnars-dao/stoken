/// <reference types="node" />
import * as core from "@bithighlander/hdwallet-core";
import * as eventemitter2 from "eventemitter2";
import type { NativeAdapterArgs } from "./adapter";
import * as Isolation from "./crypto/isolation";
export declare enum NativeEvents {
    MNEMONIC_REQUIRED = "MNEMONIC_REQUIRED",
    READY = "READY"
}
interface LoadDevice extends Omit<core.LoadDevice, "mnemonic"> {
    deviceId?: string;
    mnemonic: string | Isolation.Core.BIP39.Mnemonic;
}
export declare class NativeHDWalletInfoBase implements core.HDWalletInfo {
    getVendor(): string;
    hasOnDevicePinEntry(): boolean;
    hasOnDevicePassphrase(): boolean;
    hasOnDeviceDisplay(): boolean;
    hasOnDeviceRecovery(): boolean;
    describePath(msg: core.DescribePath): core.PathDescription;
}
export declare class NativeHDWalletBase extends NativeHDWalletInfoBase {
    #private;
    constructor();
    get events(): eventemitter2.EventEmitter2;
    /**
     * Wrap a function call that needs a mnemonic seed
     * Raise an event if the wallet hasn't been initialized with a mnemonic seed
     */
    needsMnemonic<T>(hasMnemonic: boolean, callback: () => T): T | null;
}
declare const NativeHDWalletInfo_base: {
    new (...args: any[]): {
        readonly _supportsBTCInfo: true;
        btcSupportsCoin(coin: string): Promise<boolean>;
        btcSupportsScriptType(coin: string, scriptType: core.BTCScriptType): Promise<boolean>;
        btcSupportsSecureTransfer(): Promise<boolean>;
        btcGetAccountPaths(msg: core.BTCGetAccountPaths): core.BTCAccountPath[];
        btcIsSameAccount(msg: core.BTCAccountPath[]): boolean;
        btcNextAccountPath(msg: core.BTCAccountPath): core.BTCAccountPath | undefined;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsFioInfo: true;
        fioSupportsNetwork(): Promise<boolean>;
        fioSupportsSecureTransfer(): Promise<boolean>;
        fioGetAccountPaths(msg: core.FioGetAccountPaths): core.FioAccountPath[];
        fioNextAccountPath(msg: core.FioAccountPath): core.FioAccountPath | undefined;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsETHInfo: true;
        ethSupportsNetwork(): Promise<boolean>;
        ethSupportsSecureTransfer(): Promise<boolean>;
        ethSupportsEIP1559(): Promise<boolean>;
        ethGetAccountPaths(msg: core.ETHGetAccountPath): core.ETHAccountPath[];
        ethNextAccountPath(msg: core.ETHAccountPath): core.ETHAccountPath | undefined;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsCosmosInfo: true;
        cosmosSupportsNetwork(): Promise<boolean>;
        cosmosSupportsSecureTransfer(): Promise<boolean>;
        cosmosGetAccountPaths(msg: core.CosmosGetAccountPaths): core.CosmosAccountPath[];
        cosmosNextAccountPath(msg: core.CosmosAccountPath): core.CosmosAccountPath | undefined;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsBinanceInfo: true;
        binanceSupportsNetwork(): Promise<boolean>;
        binanceSupportsSecureTransfer(): Promise<boolean>;
        binanceGetAccountPaths(msg: core.BinanceGetAccountPaths): core.BinanceAccountPath[];
        binanceNextAccountPath(msg: core.BinanceAccountPath): core.BinanceAccountPath | undefined;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        _supportsThorchainInfo: boolean;
        thorchainSupportsNetwork(): Promise<boolean>;
        thorchainSupportsSecureTransfer(): Promise<boolean>;
        thorchainGetAccountPaths(msg: core.ThorchainGetAccountPaths): core.ThorchainAccountPath[];
        thorchainNextAccountPath(msg: core.ThorchainAccountPath): core.ThorchainAccountPath | undefined;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsSecretInfo: true;
        secretSupportsNetwork(): Promise<boolean>;
        secretSupportsSecureTransfer(): Promise<boolean>;
        secretGetAccountPaths(msg: core.SecretGetAccountPaths): core.SecretAccountPath[];
        secretNextAccountPath(msg: core.SecretAccountPath): core.SecretAccountPath | undefined;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsTerraInfo: true;
        terraSupportsNetwork(): Promise<boolean>;
        terraSupportsSecureTransfer(): Promise<boolean>;
        terraGetAccountPaths(msg: core.TerraGetAccountPaths): core.TerraAccountPath[];
        terraNextAccountPath(msg: core.TerraAccountPath): core.TerraAccountPath | undefined;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsKavaInfo: true;
        kavaSupportsNetwork(): Promise<boolean>;
        kavaSupportsSecureTransfer(): Promise<boolean>;
        kavaGetAccountPaths(msg: core.KavaGetAccountPaths): core.KavaAccountPath[];
        kavaNextAccountPath(msg: core.KavaAccountPath): core.KavaAccountPath | undefined;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsOsmosisInfo: true;
        osmosisSupportsNetwork(): Promise<boolean>;
        osmosisSupportsSecureTransfer(): Promise<boolean>;
        osmosisGetAccountPaths(msg: core.OsmosisGetAccountPaths): core.OsmosisAccountPath[];
        osmosisNextAccountPath(msg: core.OsmosisAccountPath): core.OsmosisAccountPath | undefined;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & typeof NativeHDWalletBase;
declare class NativeHDWalletInfo extends NativeHDWalletInfo_base implements core.HDWalletInfo {
}
declare const NativeHDWallet_base: {
    new (...args: any[]): {
        readonly _supportsBTC: true;
        "__#5@#seed": Isolation.Core.BIP32.Seed | undefined;
        btcInitializeWallet(seed: Isolation.Core.BIP32.Seed): Promise<void>;
        btcWipe(): void;
        createPayment(pubkey: Buffer, scriptType: core.BTCScriptType, network?: import("@bithighlander/bitcoin-cash-js-lib").Network | undefined): import("@bithighlander/bitcoin-cash-js-lib").Payment;
        validateVoutOrdering(msg: core.BTCSignTxNative, tx: import("@bithighlander/bitcoin-cash-js-lib").Transaction): boolean;
        buildInput(coin: string, input: core.BTCSignTxInputNative): ((Buffer | {
            script: Buffer;
            amount: Number;
        }) | {
            redeemScript?: Buffer | undefined;
            witnessScript?: Buffer | undefined;
        } | {
            sighashType?: number | undefined;
        }) | null;
        btcGetAddress(msg: core.BTCGetAddress): Promise<string | null>;
        btcSignTx(msg: core.BTCSignTxNative): Promise<core.BTCSignedTx | null>;
        btcSignMessage(msg: core.BTCSignMessage): Promise<core.BTCSignedMessage>;
        btcVerifyMessage(msg: core.BTCVerifyMessage): Promise<boolean>;
        readonly "__#14@#events": eventemitter2.EventEmitter2;
        readonly events: eventemitter2.EventEmitter2;
        /**
         * Wrap a function call that needs a mnemonic seed
         * Raise an event if the wallet hasn't been initialized with a mnemonic seed
         */
        needsMnemonic<T>(hasMnemonic: boolean, callback: () => T): T | null;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsFio: true;
        baseUrl: string;
        "__#9@#seed": Isolation.Core.BIP32.Seed | undefined;
        fioInitializeWallet(seed: Buffer | Isolation.Core.BIP32.Seed): Promise<void>;
        fioWipe(): void;
        getFioSdk(addressNList: core.BIP32Path): Promise<import("@shapeshiftoss/fiosdk").FIOSDK | null>;
        fioGetAddress(msg: core.FioGetAddress): Promise<string | null>;
        fioSignTx(msg: core.FioSignTx): Promise<core.FioSignedTx | null>;
        fioEncryptRequestContent<T_1 extends core.Fio.ContentType>(msg: core.FioEncryptRequestContentMsg<T_1>): Promise<string | null>;
        fioDecryptRequestContent<T_2 extends core.Fio.ContentType>(msg: core.FioDecryptRequestContentMsg<T_2>): Promise<core.Fio.Content<T_2> | null>;
        readonly "__#14@#events": eventemitter2.EventEmitter2;
        readonly events: eventemitter2.EventEmitter2;
        /**
         * Wrap a function call that needs a mnemonic seed
         * Raise an event if the wallet hasn't been initialized with a mnemonic seed
         */
        needsMnemonic<T>(hasMnemonic: boolean, callback: () => T): T | null;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsETH: true;
        "__#8@#ethSigner": import("ethers").Signer | undefined;
        ethInitializeWallet(seed: Isolation.Core.BIP32.Seed): Promise<void>;
        ethWipe(): void;
        ethGetAddress(msg: core.ETHGetAddress): Promise<string | null>;
        ethSignTx(msg: core.ETHSignTx): Promise<core.ETHSignedTx | null>;
        ethSignMessage(msg: core.ETHSignMessage): Promise<core.ETHSignedMessage | null>;
        ethVerifyMessage(msg: core.ETHVerifyMessage): Promise<boolean>;
        readonly "__#14@#events": eventemitter2.EventEmitter2;
        readonly events: eventemitter2.EventEmitter2;
        /**
         * Wrap a function call that needs a mnemonic seed
         * Raise an event if the wallet hasn't been initialized with a mnemonic seed
         */
        needsMnemonic<T>(hasMnemonic: boolean, callback: () => T): T | null;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsCosmos: true;
        "__#6@#seed": Isolation.Core.BIP32.Seed | undefined;
        cosmosInitializeWallet(seed: Isolation.Core.BIP32.Seed): Promise<void>;
        cosmosWipe(): void;
        cosmosBech32ify(address: ArrayLike<number>, prefix: string): string;
        createCosmosAddress(publicKey: string): string;
        cosmosGetAddress(msg: core.CosmosGetAddress): Promise<string | null>;
        cosmosSignTx(msg: core.CosmosSignTx): Promise<core.CosmosTx | null>;
        readonly "__#14@#events": eventemitter2.EventEmitter2;
        readonly events: eventemitter2.EventEmitter2;
        /**
         * Wrap a function call that needs a mnemonic seed
         * Raise an event if the wallet hasn't been initialized with a mnemonic seed
         */
        needsMnemonic<T>(hasMnemonic: boolean, callback: () => T): T | null;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsBinance: true;
        "__#4@#seed": Isolation.Core.BIP32.Seed | undefined;
        binanceInitializeWallet(seed: Isolation.Core.BIP32.Seed): Promise<void>;
        binanceWipe(): void;
        binanceBech32ify(address: ArrayLike<number>, prefix: string): string;
        createBinanceAddress(publicKey: string, testnet?: boolean | undefined): string;
        binanceGetAddress(msg: core.BinanceGetAddress & {
            testnet?: boolean | undefined;
        }): Promise<string | null>;
        binanceSignTx(msg: core.BinanceSignTx & {
            testnet?: boolean | undefined;
        }): Promise<core.BinanceSignedTx | null>;
        readonly "__#14@#events": eventemitter2.EventEmitter2;
        readonly events: eventemitter2.EventEmitter2;
        /**
         * Wrap a function call that needs a mnemonic seed
         * Raise an event if the wallet hasn't been initialized with a mnemonic seed
         */
        needsMnemonic<T>(hasMnemonic: boolean, callback: () => T): T | null;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        _supportsThorchain: boolean;
        "__#13@#seed": Isolation.Core.BIP32.Seed | undefined;
        thorchainInitializeWallet(seed: Isolation.Core.BIP32.Seed): Promise<void>;
        thorchainWipe(): void;
        thorchainBech32ify(address: ArrayLike<number>, prefix: string): string;
        createThorchainAddress(publicKey: string): string;
        thorchainGetAddress(msg: core.ThorchainGetAddress): Promise<string | null>;
        thorchainSignTx(msg: core.ThorchainSignTx): Promise<core.ThorchainTx | null>;
        readonly "__#14@#events": eventemitter2.EventEmitter2;
        readonly events: eventemitter2.EventEmitter2;
        /**
         * Wrap a function call that needs a mnemonic seed
         * Raise an event if the wallet hasn't been initialized with a mnemonic seed
         */
        needsMnemonic<T>(hasMnemonic: boolean, callback: () => T): T | null;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsSecret: true;
        "__#11@#seed": Isolation.Core.BIP32.Seed | undefined;
        secretInitializeWallet(seed: Isolation.Core.BIP32.Seed): Promise<void>;
        secretWipe(): void;
        secretBech32ify(address: ArrayLike<number>, prefix: string): string;
        createSecretAddress(publicKey: string): string;
        secretGetAddress(msg: core.SecretGetAddress): Promise<string | null>; /**
         * Wrap a function call that needs a mnemonic seed
         * Raise an event if the wallet hasn't been initialized with a mnemonic seed
         */
        secretSignTx(msg: core.SecretSignTx): Promise<any>;
        readonly "__#14@#events": eventemitter2.EventEmitter2;
        readonly events: eventemitter2.EventEmitter2;
        /**
         * Wrap a function call that needs a mnemonic seed
         * Raise an event if the wallet hasn't been initialized with a mnemonic seed
         */
        needsMnemonic<T>(hasMnemonic: boolean, callback: () => T): T | null;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsTerra: true;
        "__#12@#seed": Isolation.Core.BIP32.Seed | undefined;
        terraInitializeWallet(seed: Isolation.Core.BIP32.Seed): Promise<void>;
        terraWipe(): void;
        terraBech32ify(address: ArrayLike<number>, prefix: string): string;
        createTerraAddress(publicKey: string): string;
        terraGetAddress(msg: core.TerraGetAddress): Promise<string | null>;
        terraSignTx(msg: core.TerraSignTx): Promise<any>;
        readonly "__#14@#events": eventemitter2.EventEmitter2;
        readonly events: eventemitter2.EventEmitter2;
        /**
         * Wrap a function call that needs a mnemonic seed
         * Raise an event if the wallet hasn't been initialized with a mnemonic seed
         */
        needsMnemonic<T>(hasMnemonic: boolean, callback: () => T): T | null;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsKava: true;
        "__#10@#seed": Isolation.Core.BIP32.Seed | undefined;
        kavaInitializeWallet(seed: Isolation.Core.BIP32.Seed): Promise<void>;
        kavaWipe(): void;
        kavaBech32ify(address: ArrayLike<number>, prefix: string): string;
        createKavaAddress(publicKey: string): string;
        kavaGetAddress(msg: core.KavaGetAddress): Promise<string | null>;
        kavaSignTx(msg: core.KavaSignTx): Promise<core.KavaTx | null>;
        readonly "__#14@#events": eventemitter2.EventEmitter2;
        readonly events: eventemitter2.EventEmitter2;
        /**
         * Wrap a function call that needs a mnemonic seed
         * Raise an event if the wallet hasn't been initialized with a mnemonic seed
         */
        needsMnemonic<T>(hasMnemonic: boolean, callback: () => T): T | null;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & {
    new (...args: any[]): {
        readonly _supportsOsmosis: true;
        "__#7@#seed": Isolation.Core.BIP32.Seed | undefined;
        osmosisInitializeWallet(seed: Isolation.Core.BIP32.Seed): Promise<void>;
        osmosisWipe(): void;
        osmosisBech32ify(address: ArrayLike<number>, prefix: string): string;
        createOsmosisAddress(publicKey: string): string;
        osmosisGetAddress(msg: core.OsmosisGetAddress): Promise<string | null>;
        osmosisSignTx(msg: core.OsmosisSignTx): Promise<core.OsmosisTx | null>;
        readonly "__#14@#events": eventemitter2.EventEmitter2;
        readonly events: eventemitter2.EventEmitter2;
        /**
         * Wrap a function call that needs a mnemonic seed
         * Raise an event if the wallet hasn't been initialized with a mnemonic seed
         */
        needsMnemonic<T>(hasMnemonic: boolean, callback: () => T): T | null;
        getVendor(): string;
        hasOnDevicePinEntry(): boolean;
        hasOnDevicePassphrase(): boolean;
        hasOnDeviceDisplay(): boolean;
        hasOnDeviceRecovery(): boolean;
        describePath(msg: core.DescribePath): core.PathDescription;
    };
} & typeof NativeHDWalletInfo;
export declare class NativeHDWallet extends NativeHDWallet_base implements core.HDWallet, core.BTCWallet, core.ETHWallet, core.CosmosWallet, core.OsmosisWallet, core.FioWallet, core.ThorchainWallet, core.SecretWallet, core.TerraWallet, core.KavaWallet {
    #private;
    readonly _supportsBTC = true;
    readonly _supportsETH = true;
    readonly _supportsCosmos = true;
    readonly _supportsOsmosis = true;
    readonly _supportsBinance = true;
    readonly _supportsFio = true;
    readonly _supportsThorchain = true;
    readonly _supportsSecret = true;
    readonly _supportsTerra = true;
    readonly _supportsKava = true;
    constructor({ mnemonic, deviceId }: NativeAdapterArgs);
    getFeatures(): Promise<Record<string, any>>;
    getDeviceID(): Promise<string>;
    getFirmwareVersion(): Promise<string>;
    getModel(): Promise<string>;
    getLabel(): Promise<string>;
    getAddress(msg: core.GetAddress): Promise<string>;
    getPublicKeys(msg: Array<core.GetPublicKey>): Promise<any>;
    isInitialized(): Promise<boolean>;
    isLocked(): Promise<boolean>;
    clearSession(): Promise<void>;
    initialize(): Promise<boolean>;
    ping(msg: core.Ping): Promise<core.Pong>;
    sendPin(): Promise<void>;
    sendPassphrase(): Promise<void>;
    sendCharacter(): Promise<void>;
    sendWord(): Promise<void>;
    cancel(): Promise<void>;
    wipe(): Promise<void>;
    reset(): Promise<void>;
    recover(): Promise<void>;
    loadDevice(msg: LoadDevice): Promise<void>;
    disconnect(): Promise<void>;
}
export declare function info(): NativeHDWalletInfo;
export declare function create(args: NativeAdapterArgs): NativeHDWallet;
export {};
//# sourceMappingURL=native.d.ts.map