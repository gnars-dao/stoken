"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _NativeHDWalletBase_events, _NativeHDWallet_deviceId, _NativeHDWallet_initialized, _NativeHDWallet_mnemonic;
Object.defineProperty(exports, "__esModule", { value: true });
exports.create = exports.info = exports.NativeHDWallet = exports.NativeHDWalletBase = exports.NativeHDWalletInfoBase = exports.NativeEvents = void 0;
const core = __importStar(require("@bithighlander/hdwallet-core"));
const bip39 = __importStar(require("bip39"));
const eventemitter2 = __importStar(require("eventemitter2"));
const binance_1 = require("./binance");
const bitcoin_1 = require("./bitcoin");
const cosmos_1 = require("./cosmos");
const osmosis_1 = require("./osmosis");
const ethereum_1 = require("./ethereum");
const fio_1 = require("./fio");
const kava_1 = require("./kava");
const networks_1 = require("./networks");
const secret_1 = require("./secret");
const terra_1 = require("./terra");
const thorchain_1 = require("./thorchain");
const Isolation = __importStar(require("./crypto/isolation"));
var NativeEvents;
(function (NativeEvents) {
    NativeEvents["MNEMONIC_REQUIRED"] = "MNEMONIC_REQUIRED";
    NativeEvents["READY"] = "READY";
})(NativeEvents = exports.NativeEvents || (exports.NativeEvents = {}));
function isMnemonicInterface(x) {
    return ["object", "function"].includes(typeof x) && "toSeed" in x && typeof x.toSeed === "function";
}
class NativeHDWalletInfoBase {
    getVendor() {
        return "Native";
    }
    hasOnDevicePinEntry() {
        return false;
    }
    hasOnDevicePassphrase() {
        return false;
    }
    hasOnDeviceDisplay() {
        return false;
    }
    hasOnDeviceRecovery() {
        return false;
    }
    describePath(msg) {
        return core.describePath(msg);
    }
}
exports.NativeHDWalletInfoBase = NativeHDWalletInfoBase;
class NativeHDWalletBase extends NativeHDWalletInfoBase {
    constructor() {
        super();
        _NativeHDWalletBase_events.set(this, void 0);
        __classPrivateFieldSet(this, _NativeHDWalletBase_events, new eventemitter2.EventEmitter2(), "f");
    }
    get events() {
        return __classPrivateFieldGet(this, _NativeHDWalletBase_events, "f");
    }
    /**
     * Wrap a function call that needs a mnemonic seed
     * Raise an event if the wallet hasn't been initialized with a mnemonic seed
     */
    needsMnemonic(hasMnemonic, callback) {
        if (hasMnemonic) {
            return callback();
        }
        __classPrivateFieldGet(this, _NativeHDWalletBase_events, "f").emit(NativeEvents.MNEMONIC_REQUIRED, core.makeEvent({
            message_type: NativeEvents.MNEMONIC_REQUIRED,
            from_wallet: true,
        }));
        return null;
    }
}
exports.NativeHDWalletBase = NativeHDWalletBase;
_NativeHDWalletBase_events = new WeakMap();
class NativeHDWalletInfo extends (0, bitcoin_1.MixinNativeBTCWalletInfo)((0, fio_1.MixinNativeFioWalletInfo)((0, ethereum_1.MixinNativeETHWalletInfo)((0, cosmos_1.MixinNativeCosmosWalletInfo)((0, binance_1.MixinNativeBinanceWalletInfo)((0, thorchain_1.MixinNativeThorchainWalletInfo)((0, secret_1.MixinNativeSecretWalletInfo)((0, terra_1.MixinNativeTerraWalletInfo)((0, kava_1.MixinNativeKavaWalletInfo)((0, osmosis_1.MixinNativeOsmosisWalletInfo)(NativeHDWalletBase)))))))))) {
}
class NativeHDWallet extends (0, bitcoin_1.MixinNativeBTCWallet)((0, fio_1.MixinNativeFioWallet)((0, ethereum_1.MixinNativeETHWallet)((0, cosmos_1.MixinNativeCosmosWallet)((0, binance_1.MixinNativeBinanceWallet)((0, thorchain_1.MixinNativeThorchainWallet)((0, secret_1.MixinNativeSecretWallet)((0, terra_1.MixinNativeTerraWallet)((0, kava_1.MixinNativeKavaWallet)((0, osmosis_1.MixinNativeOsmosisWallet)(NativeHDWalletInfo)))))))))) {
    constructor({ mnemonic, deviceId }) {
        super();
        this._supportsBTC = true;
        this._supportsETH = true;
        this._supportsCosmos = true;
        this._supportsOsmosis = true;
        this._supportsBinance = true;
        this._supportsFio = true;
        this._supportsThorchain = true;
        this._supportsSecret = true;
        this._supportsTerra = true;
        this._supportsKava = true;
        _NativeHDWallet_deviceId.set(this, void 0);
        _NativeHDWallet_initialized.set(this, false);
        _NativeHDWallet_mnemonic.set(this, void 0);
        __classPrivateFieldSet(this, _NativeHDWallet_mnemonic, (typeof mnemonic == "string" ? new Isolation.Engines.Dummy.BIP39.Mnemonic(mnemonic) : mnemonic), "f");
        __classPrivateFieldSet(this, _NativeHDWallet_deviceId, deviceId, "f");
    }
    getFeatures() {
        return __awaiter(this, void 0, void 0, function* () {
            return {};
        });
    }
    getDeviceID() {
        return __awaiter(this, void 0, void 0, function* () {
            return __classPrivateFieldGet(this, _NativeHDWallet_deviceId, "f");
        });
    }
    getFirmwareVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            return "Software";
        });
    }
    getModel() {
        return __awaiter(this, void 0, void 0, function* () {
            return "Native";
        });
    }
    getLabel() {
        return __awaiter(this, void 0, void 0, function* () {
            return "Native";
        });
    }
    getAddress(msg) {
        const _super = Object.create(null, {
            btcGetAddress: { get: () => super.btcGetAddress },
            ethGetAddress: { get: () => super.ethGetAddress },
            fioGetAddress: { get: () => super.fioGetAddress },
            osmosisGetAddress: { get: () => super.osmosisGetAddress },
            cosmosGetAddress: { get: () => super.cosmosGetAddress },
            thorchainGetAddress: { get: () => super.thorchainGetAddress },
            binanceGetAddress: { get: () => super.binanceGetAddress }
        });
        return __awaiter(this, void 0, void 0, function* () {
            switch (msg.blockchain.toLowerCase()) {
                case "bitcoin":
                case "bitcoincash":
                case "dash":
                case "digibyte":
                case "dogecoin":
                case "litecoin":
                case "testnet":
                    let inputClone = {
                        addressNList: msg.path,
                        coin: msg.blockchain,
                        scriptType: msg.scriptType,
                    };
                    // @ts-ignore
                    return _super.btcGetAddress.call(this, inputClone);
                case "ethereum":
                    let inputETH = {
                        addressNList: msg.path,
                        coin: msg.blockchain,
                        scriptType: msg.scriptType,
                    };
                    // @ts-ignore
                    return _super.ethGetAddress.call(this, inputETH);
                case "fio":
                    let inputFIO = {
                        addressNList: msg.path,
                    };
                    // @ts-ignore
                    return _super.fioGetAddress.call(this, inputFIO);
                // case "eos":
                //   let inputEOS: core.EosAccountPath = {
                //     addressNList: msg.path,
                //   };
                //   return super.eosGetAddress(inputEOS);
                case "osmosis":
                    let inputOSMO = {
                        addressNList: msg.path,
                    };
                    // @ts-ignore
                    return _super.osmosisGetAddress.call(this, inputOSMO);
                case "cosmos":
                    let inputATOM = {
                        addressNList: msg.path,
                    };
                    // @ts-ignore
                    return _super.cosmosGetAddress.call(this, inputATOM);
                case "thorchain":
                    let inputRUNE = {
                        addressNList: msg.path,
                    };
                    // @ts-ignore
                    return _super.thorchainGetAddress.call(this, inputRUNE);
                case "binance":
                    let inputBNB = {
                        addressNList: msg.path,
                    };
                    // @ts-ignore
                    return _super.binanceGetAddress.call(this, inputBNB);
                default:
                    throw new Error("Unsupported path " + msg.blockchain);
            }
        });
    }
    /*
     * @Feature: Verbose pubkey info
     *  intake in a map of pubkeys and verbose pathing and master info
     *  return hydrated set with pubkey matrial
     *              -Highlander
     *
     * @see: https://github.com/satoshilabs/slips/blob/master/slip-0132.md
     * to supports different styles of xpubs as can be defined by passing in a network to `fromSeed`
     */
    getPublicKeys(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.needsMnemonic(!!__classPrivateFieldGet(this, _NativeHDWallet_mnemonic, "f"), () => __awaiter(this, void 0, void 0, function* () {
                return Promise.all(msg.map((getPublicKey) => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    let { addressNList, addressNListMaster } = getPublicKey;
                    const seed = __classPrivateFieldGet(this, _NativeHDWallet_mnemonic, "f").toSeed();
                    console.log(getPublicKey.symbol, "seed: ", seed);
                    // @ts-ignore
                    const network = (0, networks_1.getNetwork)("bitcoin", getPublicKey.scriptType);
                    console.log(getPublicKey.symbol, "network: ", network);
                    const hardenedPath = core.hardenedPath(addressNList);
                    let node = new Isolation.Adapters.BIP32(seed.toMasterKey(), network);
                    if (hardenedPath.length > 0)
                        node = node.derivePath(core.addressNListToBIP32(hardenedPath));
                    const xpub = node.neutered().toBase58();
                    console.log("xpub: ", xpub);
                    let addressInfo = {
                        path: addressNListMaster,
                        // @ts-ignore
                        blockchain: (_a = getPublicKey === null || getPublicKey === void 0 ? void 0 : getPublicKey.blockchain) === null || _a === void 0 ? void 0 : _a.toLowerCase(),
                        scriptType: getPublicKey.script_type,
                    };
                    //TODO type me. @ref: https://github.com/BitHighlander/pioneer/blob/develop/modules/pioneer/pioneer-types/src/pioneer.ts#L75
                    let pubkey = {
                        coin: getPublicKey.network,
                        blockchain: getPublicKey.blockchain,
                        network: getPublicKey.network,
                        script_type: getPublicKey.script_type,
                        path: core.addressNListToBIP32(addressNList),
                        pathMaster: core.addressNListToBIP32(addressNListMaster),
                        long: getPublicKey.blockchain,
                        address: yield this.getAddress(addressInfo),
                        master: yield this.getAddress(addressInfo),
                        type: getPublicKey.type,
                    };
                    //TODO @feature testnets bro
                    // @ts-ignore
                    // if(this.#isTestnet){
                    //   throw Error('testnet smeshnet')
                    //   //pubkey.tpub = await crypto.xpubConvert(xpub,'tpub')
                    // }else{
                    //   pubkey.xpub = xpub
                    // }
                    pubkey.xpub = xpub;
                    switch (getPublicKey.type) {
                        case "address":
                            pubkey.pubkey = pubkey.address;
                            break;
                        case 'xpub':
                            pubkey.pubkey = pubkey.xpub;
                            break;
                        case 'tpub':
                            pubkey.pubkey = pubkey.tpub;
                            break;
                        case 'zpub':
                            //TODO fixme!
                            //Why is the seed empty!!! {} wtf???
                            //what is this witchcraft
                            // let root = new BIP84.fromMnemonic(seed)
                            // let child0 = root.deriveAccount(0)
                            // let account0 = new BIP84.fromZPrv(child0)
                            // let zpub = account0.getAccountPublicKey()
                            // pubkey.address = account0.getAddress(0)
                            // pubkey.master = account0.getAddress(0)
                            // pubkey.zpub = zpub
                            // pubkey.pubkey = pubkey.zpub
                            pubkey.address = "fobar";
                            pubkey.master = "foobar";
                            pubkey.zpub = "zpubfoobar";
                            pubkey.pubkey = "zpubfoobar";
                            break;
                        default:
                            // @ts-ignore
                            throw Error("Unhandled pubkey type! :" + getPublicKey.type);
                    }
                    return pubkey;
                })));
            }));
        });
    }
    isInitialized() {
        return __awaiter(this, void 0, void 0, function* () {
            return !!__classPrivateFieldGet(this, _NativeHDWallet_initialized, "f");
        });
    }
    isLocked() {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    clearSession() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    initialize() {
        const _super = Object.create(null, {
            btcInitializeWallet: { get: () => super.btcInitializeWallet },
            ethInitializeWallet: { get: () => super.ethInitializeWallet },
            cosmosInitializeWallet: { get: () => super.cosmosInitializeWallet },
            osmosisInitializeWallet: { get: () => super.osmosisInitializeWallet },
            binanceInitializeWallet: { get: () => super.binanceInitializeWallet },
            fioInitializeWallet: { get: () => super.fioInitializeWallet },
            thorchainInitializeWallet: { get: () => super.thorchainInitializeWallet },
            secretInitializeWallet: { get: () => super.secretInitializeWallet },
            terraInitializeWallet: { get: () => super.terraInitializeWallet },
            kavaInitializeWallet: { get: () => super.kavaInitializeWallet }
        });
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return (_a = yield this.needsMnemonic(!!__classPrivateFieldGet(this, _NativeHDWallet_mnemonic, "f"), () => __awaiter(this, void 0, void 0, function* () {
                try {
                    const seed = __classPrivateFieldGet(this, _NativeHDWallet_mnemonic, "f").toSeed();
                    yield Promise.all([
                        _super.btcInitializeWallet.call(this, seed),
                        _super.ethInitializeWallet.call(this, seed),
                        _super.cosmosInitializeWallet.call(this, seed),
                        _super.osmosisInitializeWallet.call(this, seed),
                        _super.binanceInitializeWallet.call(this, seed),
                        _super.fioInitializeWallet.call(this, seed),
                        _super.thorchainInitializeWallet.call(this, seed),
                        _super.secretInitializeWallet.call(this, seed),
                        _super.terraInitializeWallet.call(this, seed),
                        _super.kavaInitializeWallet.call(this, seed),
                    ]);
                    __classPrivateFieldSet(this, _NativeHDWallet_initialized, true, "f");
                }
                catch (e) {
                    console.error("NativeHDWallet:initialize:error", e);
                    __classPrivateFieldSet(this, _NativeHDWallet_initialized, false, "f");
                    yield this.wipe();
                }
                return yield this.isInitialized();
            }))) !== null && _a !== void 0 ? _a : false;
        });
    }
    ping(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            return { msg: msg.msg };
        });
    }
    sendPin() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    sendPassphrase() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    sendCharacter() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    sendWord() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    cancel() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    wipe() {
        const _super = Object.create(null, {
            btcWipe: { get: () => super.btcWipe },
            ethWipe: { get: () => super.ethWipe },
            cosmosWipe: { get: () => super.cosmosWipe },
            osmosisWipe: { get: () => super.osmosisWipe },
            binanceWipe: { get: () => super.binanceWipe },
            fioWipe: { get: () => super.fioWipe },
            thorchainWipe: { get: () => super.thorchainWipe },
            secretWipe: { get: () => super.secretWipe },
            terraWipe: { get: () => super.terraWipe },
            kavaWipe: { get: () => super.kavaWipe }
        });
        return __awaiter(this, void 0, void 0, function* () {
            __classPrivateFieldSet(this, _NativeHDWallet_initialized, false, "f");
            __classPrivateFieldSet(this, _NativeHDWallet_mnemonic, undefined, "f");
            _super.btcWipe.call(this);
            _super.ethWipe.call(this);
            _super.cosmosWipe.call(this);
            _super.osmosisWipe.call(this);
            _super.binanceWipe.call(this);
            _super.fioWipe.call(this);
            _super.thorchainWipe.call(this);
            _super.secretWipe.call(this);
            _super.terraWipe.call(this);
            _super.kavaWipe.call(this);
        });
    }
    reset() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    recover() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    loadDevice(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            __classPrivateFieldSet(this, _NativeHDWallet_mnemonic, (x => {
                if (x) {
                    if (isMnemonicInterface(x))
                        return x;
                    if (typeof x === "string" && bip39.validateMnemonic(x))
                        return new Isolation.Engines.Dummy.BIP39.Mnemonic(x);
                }
                throw new Error("Required property [mnemonic] is missing or invalid");
            })(msg === null || msg === void 0 ? void 0 : msg.mnemonic), "f");
            if (typeof msg.deviceId === "string")
                __classPrivateFieldSet(this, _NativeHDWallet_deviceId, msg.deviceId, "f");
            __classPrivateFieldSet(this, _NativeHDWallet_initialized, false, "f");
            yield this.initialize();
            // Once we've been seeded with a mnemonic we re-emit the connected event
            this.events.emit(NativeEvents.READY, core.makeEvent({
                message_type: NativeEvents.READY,
                from_wallet: true,
            }));
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
}
exports.NativeHDWallet = NativeHDWallet;
_NativeHDWallet_deviceId = new WeakMap(), _NativeHDWallet_initialized = new WeakMap(), _NativeHDWallet_mnemonic = new WeakMap();
function info() {
    return new NativeHDWalletInfo();
}
exports.info = info;
function create(args) {
    return new NativeHDWallet(args);
}
exports.create = create;
// This prevents any malicious code from overwriting the prototype
// to potentially steal the mnemonic when calling "loadDevice"
Object.freeze(Object.getPrototypeOf(NativeHDWallet));
//# sourceMappingURL=native.js.map