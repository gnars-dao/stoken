"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MixinNativeBTCWallet = exports.MixinNativeBTCWalletInfo = void 0;
const core = __importStar(require("@bithighlander/hdwallet-core"));
const bchAddr = __importStar(require("bchaddrjs"));
const bitcoin = __importStar(require("@bithighlander/bitcoin-cash-js-lib"));
const networks_1 = require("./networks");
const util_1 = __importDefault(require("./util"));
const supportedCoins = ["bitcoin", "dash", "digibyte", "dogecoin", "litecoin", "bitcoincash", "testnet"];
function MixinNativeBTCWalletInfo(Base) {
    return class MixinNativeBTCWalletInfo extends Base {
        constructor() {
            super(...arguments);
            this._supportsBTCInfo = true;
        }
        btcSupportsCoin(coin) {
            return __awaiter(this, void 0, void 0, function* () {
                return supportedCoins.includes(String(coin).toLowerCase());
            });
        }
        btcSupportsScriptType(coin, scriptType) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!(yield this.btcSupportsCoin(coin)))
                    return false;
                switch (scriptType) {
                    case core.BTCScriptType.ScriptHash:
                    case core.BTCScriptType.KeyHash:
                    case core.BTCScriptType.Witness:
                    case core.BTCScriptType.ScriptHashWitness:
                        return true;
                    default:
                        return false;
                }
            });
        }
        btcSupportsSecureTransfer() {
            return __awaiter(this, void 0, void 0, function* () {
                return false;
            });
        }
        btcGetAccountPaths(msg) {
            const slip44 = core.slip44ByCoin(msg.coin);
            if (slip44 === undefined)
                return [];
            const bip44 = core.legacyAccount(msg.coin, slip44, msg.accountIdx);
            const bip49 = core.segwitAccount(msg.coin, slip44, msg.accountIdx);
            const bip84 = core.segwitNativeAccount(msg.coin, slip44, msg.accountIdx);
            const coinPaths = {
                bitcoin: [bip44, bip49, bip84],
                bitcoincash: [bip44, bip49, bip84],
                dash: [bip44],
                digibyte: [bip44, bip49, bip84],
                dogecoin: [bip44],
                litecoin: [bip44, bip49, bip84],
                testnet: [bip44, bip49, bip84],
            };
            let paths = coinPaths[msg.coin.toLowerCase()] || [];
            if (msg.scriptType !== undefined) {
                paths = paths.filter((path) => {
                    return path.scriptType === msg.scriptType;
                });
            }
            return paths;
        }
        btcIsSameAccount(msg) {
            // TODO: support at some point
            return false;
        }
        btcNextAccountPath(msg) {
            const description = core.btcDescribePath(msg.addressNList, msg.coin, msg.scriptType);
            if (!description.isKnown) {
                return undefined;
            }
            let addressNList = msg.addressNList;
            if ((addressNList[0] === 0x80000000 + 44 && msg.scriptType == core.BTCScriptType.KeyHash) ||
                (addressNList[0] === 0x80000000 + 49 && msg.scriptType == core.BTCScriptType.ScriptHashWitness) ||
                (addressNList[0] === 0x80000000 + 84 && msg.scriptType == core.BTCScriptType.Witness)) {
                addressNList[2] += 1;
                return Object.assign(Object.assign({}, msg), { addressNList });
            }
            return undefined;
        }
    };
}
exports.MixinNativeBTCWalletInfo = MixinNativeBTCWalletInfo;
function MixinNativeBTCWallet(Base) {
    var _MixinNativeBTCWallet_seed, _a;
    return _a = class MixinNativeBTCWallet extends Base {
            constructor() {
                super(...arguments);
                this._supportsBTC = true;
                _MixinNativeBTCWallet_seed.set(this, void 0);
            }
            btcInitializeWallet(seed) {
                return __awaiter(this, void 0, void 0, function* () {
                    __classPrivateFieldSet(this, _MixinNativeBTCWallet_seed, seed, "f");
                });
            }
            btcWipe() {
                __classPrivateFieldSet(this, _MixinNativeBTCWallet_seed, undefined, "f");
            }
            createPayment(pubkey, scriptType, network) {
                switch (scriptType) {
                    case core.BTCScriptType.ScriptHash:
                        return bitcoin.payments.p2sh({ pubkey, network });
                    case core.BTCScriptType.KeyHash:
                        return bitcoin.payments.p2pkh({ pubkey, network });
                    case core.BTCScriptType.Witness:
                        return bitcoin.payments.p2wpkh({ pubkey, network });
                    case core.BTCScriptType.ScriptHashWitness:
                        return bitcoin.payments.p2sh({
                            redeem: bitcoin.payments.p2wpkh({ pubkey, network }),
                            network,
                        });
                    default:
                        throw new Error(`no implementation for script type: ${scriptType}`);
                }
            }
            validateVoutOrdering(msg, tx) {
                // From THORChain specification:
                /* ignoreTx checks if we can already ignore a tx according to preset rules
          
                   we expect array of "vout" for a BTC to have this format
                   OP_RETURN is mandatory only on inbound tx
                   vout:0 is our vault
                   vout:1 is any any change back to themselves
                   vout:2 is OP_RETURN (first 80 bytes)
                   vout:3 is OP_RETURN (next 80 bytes)
          
                   Rules to ignore a tx are:
                   - vout:0 doesn't have coins (value)
                   - vout:0 doesn't have address
                   - count vouts > 4
                   - count vouts with coins (value) > 2
                */
                var _a;
                // Check that vout:0 contains the vault address
                if (bitcoin.address.fromOutputScript(tx.outs[0].script) != msg.vaultAddress) {
                    console.error("Vout:0 does not contain vault address.");
                    return false;
                }
                // TODO: Can we check and  make sure vout:1 is our address?
                // Check and make sure vout:2 exists
                if (tx.outs.length < 3) {
                    console.error("Not enough outputs found in transaction.", msg);
                    return false;
                }
                // Check and make sure vout:2 has OP_RETURN data
                let opcode = (_a = bitcoin.script.decompile(tx.outs[2].script)) === null || _a === void 0 ? void 0 : _a[0];
                if (Object.keys(bitcoin.script.OPS).find((k) => bitcoin.script.OPS[k] === opcode) != "OP_RETURN") {
                    console.error("OP_RETURN output not found for transaction.");
                    return false;
                }
                // Make sure vout:3 does not exist
                if (tx.outs[3]) {
                    console.error("Illegal second op_return output found.");
                    return false;
                }
                return true;
            }
            buildInput(coin, input) {
                return this.needsMnemonic(!!__classPrivateFieldGet(this, _MixinNativeBTCWallet_seed, "f"), () => {
                    var _a, _b;
                    const { addressNList, amount, hex, scriptType } = input;
                    const keyPair = util_1.default.getKeyPair(__classPrivateFieldGet(this, _MixinNativeBTCWallet_seed, "f"), addressNList, coin, scriptType);
                    const isSegwit = core.isSegwitScript(scriptType);
                    const nonWitnessUtxo = hex && Buffer.from(hex, "hex");
                    const witnessUtxo = input.tx && {
                        script: Buffer.from(input.tx.vout[input.vout].scriptPubKey.hex, "hex"),
                        value: Number(amount),
                    };
                    const utxoData = isSegwit && witnessUtxo ? { witnessUtxo } : { nonWitnessUtxo };
                    if (!(utxoData.witnessUtxo || utxoData.nonWitnessUtxo)) {
                        throw new Error("failed to build input - must provide prev rawTx (segwit input can provide scriptPubKey hex and value instead)");
                    }
                    const { publicKey, network } = keyPair;
                    const payment = this.createPayment(publicKey, scriptType, network);
                    let scriptData = {};
                    if (isSegwit && ((_a = payment.redeem) === null || _a === void 0 ? void 0 : _a.output))
                        scriptData.redeemScript = (_b = payment.redeem) === null || _b === void 0 ? void 0 : _b.output;
                    let bchData = {};
                    if (coin.toLowerCase() === "bitcoincash") {
                        bchData.sighashType = bitcoin.Transaction.SIGHASH_ALL | bitcoin.Transaction.SIGHASH_BITCOINCASHBIP143;
                    }
                    return Object.assign(Object.assign(Object.assign({}, utxoData), bchData), scriptData);
                });
            }
            btcGetAddress(msg) {
                return __awaiter(this, void 0, void 0, function* () {
                    return this.needsMnemonic(!!__classPrivateFieldGet(this, _MixinNativeBTCWallet_seed, "f"), () => {
                        const { addressNList, coin, scriptType } = msg;
                        const keyPair = util_1.default.getKeyPair(__classPrivateFieldGet(this, _MixinNativeBTCWallet_seed, "f"), addressNList, coin, scriptType);
                        const { address } = this.createPayment(keyPair.publicKey, scriptType, keyPair.network);
                        if (!address)
                            return null;
                        return coin.toLowerCase() === "bitcoincash" ? bchAddr.toCashAddress(address) : address;
                    });
                });
            }
            btcSignTx(msg) {
                return __awaiter(this, void 0, void 0, function* () {
                    return this.needsMnemonic(!!__classPrivateFieldGet(this, _MixinNativeBTCWallet_seed, "f"), () => __awaiter(this, void 0, void 0, function* () {
                        const { coin, inputs, outputs, version, locktime } = msg;
                        const psbt = new bitcoin.Psbt({ network: (0, networks_1.getNetwork)(coin) });
                        psbt.setVersion(version !== null && version !== void 0 ? version : 1);
                        locktime && psbt.setLocktime(locktime);
                        inputs.forEach((input) => {
                            try {
                                const inputData = this.buildInput(coin, input);
                                psbt.addInput(Object.assign({ hash: input.txid, index: input.vout }, inputData));
                            }
                            catch (e) {
                                throw new Error(`failed to add input: ${e}`);
                            }
                        });
                        outputs.map((output) => {
                            try {
                                const { amount } = output;
                                let address;
                                if (output.address !== undefined) {
                                    address = output.address;
                                }
                                else if (output.addressNList !== undefined) {
                                    const keyPair = util_1.default.getKeyPair(__classPrivateFieldGet(this, _MixinNativeBTCWallet_seed, "f"), output.addressNList, coin, output.scriptType);
                                    const { publicKey, network } = keyPair;
                                    const payment = this.createPayment(publicKey, output.scriptType, network);
                                    if (!payment.address)
                                        throw new Error("could not get payment address");
                                    address = payment.address;
                                }
                                else {
                                    throw new Error("unsupported output type");
                                }
                                if (coin.toLowerCase() === "bitcoincash") {
                                    address = bchAddr.toLegacyAddress(address);
                                }
                                psbt.addOutput({ address, value: Number(amount) });
                            }
                            catch (e) {
                                throw new Error(`failed to add output: ${e}`);
                            }
                        });
                        if (msg.opReturnData) {
                            const data = Buffer.from(msg.opReturnData, "utf-8");
                            const embed = bitcoin.payments.embed({ data: [data] });
                            const script = embed.output;
                            if (!script)
                                throw new Error("unable to build OP_RETURN script");
                            psbt.addOutput({ script, value: 0 });
                        }
                        yield Promise.all(inputs.map((input, idx) => __awaiter(this, void 0, void 0, function* () {
                            try {
                                const { addressNList, scriptType } = input;
                                const keyPair = util_1.default.getKeyPair(__classPrivateFieldGet(this, _MixinNativeBTCWallet_seed, "f"), addressNList, coin, scriptType);
                                yield psbt.signInputAsync(idx, keyPair);
                            }
                            catch (e) {
                                throw new Error(`failed to sign input: ${e}`);
                            }
                        })));
                        psbt.finalizeAllInputs();
                        const tx = psbt.extractTransaction(true);
                        // If this is a THORChain transaction, validate the vout ordering
                        if (msg.vaultAddress && !this.validateVoutOrdering(msg, tx)) {
                            throw new Error("Improper vout ordering for BTC Thorchain transaction");
                        }
                        const signatures = tx.ins.map((input) => {
                            if (input.witness.length > 0) {
                                return input.witness[0].toString("hex");
                            }
                            else {
                                const sigLen = input.script[0];
                                return input.script.slice(1, sigLen).toString("hex");
                            }
                        });
                        return {
                            signatures,
                            serializedTx: tx.toHex(),
                        };
                    }));
                });
            }
            btcSignMessage(msg) {
                return __awaiter(this, void 0, void 0, function* () {
                    throw new Error("function not implemented");
                });
            }
            btcVerifyMessage(msg) {
                return __awaiter(this, void 0, void 0, function* () {
                    throw new Error("function not implemented");
                });
            }
        },
        _MixinNativeBTCWallet_seed = new WeakMap(),
        _a;
}
exports.MixinNativeBTCWallet = MixinNativeBTCWallet;
//# sourceMappingURL=bitcoin.js.map