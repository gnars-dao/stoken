"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const native = __importStar(require("./native"));
const Isolation = __importStar(require("./crypto/isolation"));
const MNEMONIC = "all all all all all all all all all all all all";
const mswMock = require("mswMock")().startServer();
afterEach(() => expect(mswMock).not.toHaveBeenCalled());
const untouchable = require("untouchableMock");
//TODO fix types
// describe("NativeHDWalletInfo", () => {
//   it("should have correct metadata", () => {
//     const info = native.info();
//     expect(info.getVendor()).toBe("Native");
//     expect(info.hasOnDevicePinEntry()).toBe(false);
//     expect(info.hasOnDevicePassphrase()).toBe(false);
//     expect(info.hasOnDeviceDisplay()).toBe(false);
//     expect(info.hasOnDeviceRecovery()).toBe(false);
//   });
//   it("should produce correct path descriptions", () => {
//     const info = native.info();
//     // @ts-ignore
//     [
//       {
//         msg: { coin: "bitcoin", path: [1, 2, 3] },
//         out: { coin: "bitcoin", verbose: "m/1/2/3", isKnown: false },
//       },
//       {
//         msg: {
//           coin: "bitcoin",
//           path: [44 + 0x80000000, 0 + 0x80000000, 0 + 0x80000000, 0, 0],
//           scriptType: core.BTCScriptType.KeyHash,
//         },
//         out: { coin: "bitcoin", verbose: "m/44'/0'/0'/0/0", isKnown: false },
//       },
//       {
//         msg: {
//           coin: "Bitcoin",
//           path: [44 + 0x80000000, 0 + 0x80000000, 0 + 0x80000000],
//           scriptType: core.BTCScriptType.KeyHash,
//         },
//         out: { coin: "Bitcoin", verbose: "Bitcoin Account #0 (Legacy)", isKnown: true, wholeAccount: true },
//       },
//       {
//         msg: {
//           coin: "Bitcoin",
//           path: [44 + 0x80000000, 0 + 0x80000000, 0 + 0x80000000, 0, 0],
//           scriptType: core.BTCScriptType.KeyHash,
//         },
//         out: { coin: "Bitcoin", verbose: "Bitcoin Account #0, Address #0 (Legacy)", isKnown: true },
//       },
//       {
//         msg: { coin: "dash", path: [1, 2, 3], scriptType: core.BTCScriptType.Witness },
//         out: { coin: "dash", verbose: "m/1/2/3", scriptType: core.BTCScriptType.Witness, isKnown: false },
//       },
//       {
//         msg: { coin: "bitcoincash", path: [1, 2, 3] },
//         out: { coin: "bitcoincash", verbose: "m/1/2/3", isKnown: false },
//       },
//       {
//         msg: { coin: "ethereum", path: [44 + 0x80000000, 60 + 0x80000000, 0 + 0x80000000, 0, 0] },
//         out: { coin: "Ethereum", verbose: "Ethereum Account #0", isKnown: true },
//       },
//       {
//         msg: { coin: "atom", path: [44 + 0x80000000, 118 + 0x80000000, 0 + 0x80000000, 0, 0] },
//         out: { coin: "Atom", verbose: "Cosmos Account #0", isKnown: true },
//       },
//       {
//         msg: { coin: "binance", path: [44 + 0x80000000, 714 + 0x80000000, 0 + 0x80000000, 0, 0] },
//         out: { coin: "Binance", verbose: "Binance Account #0", isKnown: true },
//       },
//       {
//         msg: { coin: "fio", path: [44 + 0x80000000, 235 + 0x80000000, 0 + 0x80000000, 0, 0] },
//         out: { coin: "Fio", verbose: "Fio Account #0", isKnown: true },
//       },
//       {
//         msg: { coin: "rune", path: [44 + 0x80000000, 931 + 0x80000000, 0 + 0x80000000, 0, 0] },
//         out: { coin: "Thorchain", verbose: "Thorchain Account #0", isKnown: true },
//       },
//       {
//         msg: { coin: "secret", path: [44 + 0x80000000, 529 + 0x80000000, 0 + 0x80000000, 0, 0] },
//         out: { coin: "Secret", verbose: "Secret Account #0", isKnown: true },
//       },
//       {
//         msg: { coin: "luna", path: [44 + 0x80000000, 330 + 0x80000000, 0 + 0x80000000, 0, 0] },
//         out: { coin: "Terra", verbose: "Terra Account #0", isKnown: true },
//       },
//       {
//         msg: { coin: "kava", path: [44 + 0x80000000, 459 + 0x80000000, 0 + 0x80000000, 0, 0] },
//         out: { coin: "Kava", verbose: "Kava Account #0", isKnown: true },
//       },
//       {
//         msg: { coin: "Osmo", path: [44 + 0x80000000, 118 + 0x80000000, 0 + 0x80000000, 0, 0] },
//         out: { coin: "Osmo", verbose: "Osmosis Account #0", isKnown: true },
//       },
//       {
//         msg: { coin: "foobar", path: [1, 2, 3] },
//         out: { coin: "foobar", verbose: "m/1/2/3", isKnown: false },
//       }
//     ].forEach((x) => expect(info.describePath(x.msg)).toMatchObject(x.out));
//   });
// });
describe("NativeHDWallet", () => {
    it("should keep mnemonic private", () => {
        const wallet = native.create({ mnemonic: MNEMONIC, deviceId: "deviceId" });
        const json = JSON.stringify(wallet);
        expect(json).not.toMatch(/mnemonic|all/);
        expect(Object.getOwnPropertyNames(wallet).filter((p) => p.includes("mnemonic")).length).toBe(0);
        expect(require("util").inspect(wallet, { showHidden: true }).includes("mnemonic")).toBe(false);
    });
    //TODO fixme
    describe("loadDevice", () => {
        it.skip("should load wallet with a mnemonic", () => __awaiter(void 0, void 0, void 0, function* () {
            const wallet = native.create({ deviceId: "native" });
            expect(yield wallet.isInitialized()).toBe(false);
            expect(yield wallet.isLocked()).toBe(false);
            yield wallet.loadDevice({ mnemonic: MNEMONIC });
            expect(yield wallet.initialize()).toBe(true);
            expect(yield wallet.isInitialized()).toBe(true);
            expect(yield wallet.isLocked()).toBe(false);
            const testCases = [
                {
                    in: [{ coin: "bitcoin", addressNList: [] }],
                    out: [
                        {
                            xpub: "xpub661MyMwAqRbcFLgDU7wpcEVubSF7NkswwmXBUkDiGUW6uopeUMys4AqKXNgpfZKRTLnpKQgffd6a2c3J8JxLkF1AQN17Pm9QYHEqEfo1Rsx",
                        },
                    ],
                },
                {
                    in: [{ coin: "bitcoin", addressNList: [1 + 0x80000000, 2 + 0x80000000] }],
                    out: [
                        {
                            xpub: "xpub6A4ydEAik39rFLs1hcm6XiwpFN5XKEf9tdAZWK23tkXmSr8bHmfYyfVt2nTskZQj3yYydcST2DLUFq2iJAELtTVfW9UNnnK8zBi8bzFcQVB",
                        },
                    ],
                },
                // Note how this produces the same xpub as the path above. This is not intuitive behavior, and is probably a bug.
                {
                    in: [{ coin: "bitcoin", addressNList: [1 + 0x80000000, 2 + 0x80000000, 3] }],
                    out: [
                        {
                            xpub: "xpub6A4ydEAik39rFLs1hcm6XiwpFN5XKEf9tdAZWK23tkXmSr8bHmfYyfVt2nTskZQj3yYydcST2DLUFq2iJAELtTVfW9UNnnK8zBi8bzFcQVB",
                        },
                    ],
                },
            ];
            for (const params of testCases) {
                expect(yield wallet.getPublicKeys(params.in)).toStrictEqual(params.out);
            }
            ;
        }));
        it("should load wallet with a mnemonic and deviceId", () => __awaiter(void 0, void 0, void 0, function* () {
            const wallet = native.create({ deviceId: "native" });
            yield wallet.loadDevice({ mnemonic: MNEMONIC, deviceId: "0SUnRnGkhCt0T5qk5YmK10v5u+lgHiMMu1R76uD7kHE=" });
            expect(yield wallet.initialize()).toBe(true);
            expect(yield wallet.getDeviceID()).toBe("0SUnRnGkhCt0T5qk5YmK10v5u+lgHiMMu1R76uD7kHE=");
        }));
        it.each([[undefined], [null], [0], [[1, 2, 3]], [{}]])("should not update the deviceId if it's not a string (%o)", (param) => __awaiter(void 0, void 0, void 0, function* () {
            const wallet = native.create({ deviceId: "native" });
            yield wallet.loadDevice({ mnemonic: MNEMONIC, deviceId: param });
            expect(yield wallet.getDeviceID()).toBe("native");
        }));
        it("should throw an error when loadDevice is missing its parameters", () => __awaiter(void 0, void 0, void 0, function* () {
            const wallet = native.create({ deviceId: "native" });
            yield expect(wallet.loadDevice(undefined)).rejects.toThrow("Required property [mnemonic] is missing");
        }));
        it.each([[undefined], [null], [0], [[1, 2, 3]], [{}], [""], ["all all all all all all"]])("should throw an error if mnemonic is not a string (%o)", (param) => __awaiter(void 0, void 0, void 0, function* () {
            const wallet = native.create({ deviceId: "native" });
            yield expect(wallet.loadDevice({ mnemonic: param })).rejects.toThrow("Required property [mnemonic] is missing or invalid");
        }));
    });
    it("should wipe if an error occurs during initialization", () => __awaiter(void 0, void 0, void 0, function* () {
        expect.assertions(7);
        const wallet = native.create({ deviceId: "native" });
        const mockMnemonic = new Isolation.Engines.Dummy.BIP39.Mnemonic(MNEMONIC);
        yield wallet.loadDevice({ mnemonic: mockMnemonic });
        const mocks = [
            jest.spyOn(mockMnemonic, "toSeed").mockImplementationOnce(() => {
                throw "mock error";
            }),
            jest.spyOn(console, "error").mockImplementationOnce((msg, error) => {
                expect(msg).toMatch("NativeHDWallet:initialize:error");
                expect(error).toEqual("mock error");
            }),
            jest.spyOn(wallet, "wipe"),
        ];
        expect(yield wallet.initialize()).toBe(false);
        mocks.forEach((x) => {
            expect(x).toHaveBeenCalled();
            x.mockRestore();
        });
    }));
    it("should have correct metadata", () => __awaiter(void 0, void 0, void 0, function* () {
        const deviceId = "foobar";
        const wallet = native.create({ deviceId });
        expect(yield wallet.getFeatures()).toEqual({});
        expect(yield wallet.getDeviceID()).toEqual(deviceId);
        expect(yield wallet.getFirmwareVersion()).toEqual("Software");
        expect(yield wallet.getModel()).toEqual("Native");
        expect(yield wallet.getLabel()).toEqual("Native");
    }));
    it("should emit MNEMONIC_REQUIRED when initialized without a mnemonic", () => __awaiter(void 0, void 0, void 0, function* () {
        const wallet = native.create({ deviceId: "native" });
        const mnemonicRequiredMock = jest.fn(({ message_type }) => {
            expect(message_type).toBe(native.NativeEvents.MNEMONIC_REQUIRED);
        });
        const readyMock = jest.fn(({ message_type }) => {
            expect(message_type).toBe(native.NativeEvents.READY);
        });
        wallet.events.addListener(native.NativeEvents.READY, readyMock);
        wallet.events.addListener(native.NativeEvents.MNEMONIC_REQUIRED, mnemonicRequiredMock);
        expect(yield wallet.initialize()).toBe(false);
        expect(mnemonicRequiredMock).toHaveBeenCalled();
        expect(readyMock).not.toHaveBeenCalled();
    }));
    it("should emit READY when initialized with a mnemonic", () => __awaiter(void 0, void 0, void 0, function* () {
        const wallet = native.create({ deviceId: "native" });
        const mnemonicRequiredMock = jest.fn(({ message_type }) => {
            expect(message_type).toBe(native.NativeEvents.MNEMONIC_REQUIRED);
        });
        const readyMock = jest.fn(({ message_type }) => {
            expect(message_type).toBe(native.NativeEvents.READY);
        });
        wallet.events.addListener(native.NativeEvents.READY, readyMock);
        wallet.events.addListener(native.NativeEvents.MNEMONIC_REQUIRED, mnemonicRequiredMock);
        yield wallet.loadDevice({ mnemonic: MNEMONIC });
        expect(yield wallet.initialize()).toBe(true);
        expect(mnemonicRequiredMock).not.toHaveBeenCalled();
        expect(readyMock).toHaveBeenCalled();
    }));
    it("should emit MNEMONIC_REQUIRED when initialized after a wipe", () => __awaiter(void 0, void 0, void 0, function* () {
        const wallet = native.create({ deviceId: "native" });
        const mock = jest.fn();
        wallet.events.addListener(native.NativeEvents.MNEMONIC_REQUIRED, mock);
        yield wallet.loadDevice({ mnemonic: MNEMONIC });
        expect(yield wallet.initialize()).toBe(true);
        yield wallet.wipe();
        expect(mock).not.toHaveBeenCalled();
        expect(yield wallet.initialize()).toBe(false);
        expect(mock).toHaveBeenCalled();
    }));
    it("should respond to .ping()", () => __awaiter(void 0, void 0, void 0, function* () {
        const wallet = native.create({ deviceId: "native" });
        expect(yield wallet.ping({ msg: "pong" })).toEqual({ msg: "pong" });
    }));
    describe("nothing happens", () => {
        const wallet = native.create({ deviceId: "native" });
        it.each([
            ["clearSession"],
            ["sendPin"],
            ["sendPassphrase"],
            ["sendCharacter"],
            ["sendWord"],
            ["cancel"],
            ["reset"],
            ["recover"],
            ["disconnect"],
        ])("when %s is called", (methodName) => __awaiter(void 0, void 0, void 0, function* () {
            expect(yield untouchable.call(wallet, methodName)).toBe(undefined);
        }));
    });
});
//# sourceMappingURL=native.test.js.map