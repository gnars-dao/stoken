import { t as fe, c as m, l as Ue, s as Je, d as X, m as L, h as G, a as le, b as ye } from "./index-d653805f.js";
import { b as Z } from "./index-8e30cada.js";
import { b as Ee, d as Q, a as De } from "./index-005ea00d.js";
function Ce(e, t) {
  for (var o = 0; o < t.length; o++) {
    const c = t[o];
    if (typeof c != "string" && !Array.isArray(c)) {
      for (const u in c)
        if (u !== "default" && !(u in e)) {
          const f = Object.getOwnPropertyDescriptor(c, u);
          f && Object.defineProperty(e, u, f.get ? f : {
            enumerable: !0,
            get: () => c[u]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var Be = {}, Y = {};
Object.defineProperty(Y, "__esModule", { value: !0 });
Y.parseCoins = void 0;
function Ie(e) {
  return e.replace(/\s/g, "").split(",").filter(Boolean).map((t) => {
    const o = t.match(/^([0-9]+)([a-zA-Z][a-zA-Z0-9/]{2,127})$/);
    if (!o)
      throw new Error("Got an invalid coin string");
    return {
      amount: o[1].replace(/^0+/, "") || "0",
      denom: o[2]
    };
  });
}
Y.parseCoins = Ie;
var j = {};
Object.defineProperty(j, "__esModule", { value: !0 });
j.decodeTxRaw = void 0;
const te = fe;
function $e(e) {
  const t = te.TxRaw.decode(e);
  return {
    authInfo: te.AuthInfo.decode(t.authInfoBytes),
    body: te.TxBody.decode(t.bodyBytes),
    signatures: t.signatures
  };
}
j.decodeTxRaw = $e;
var J = {}, w = {}, We = m && m.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(w, "__esModule", { value: !0 });
w.makeSignBytes = w.makeSignDoc = w.makeAuthInfoBytes = void 0;
const ge = Ee, Fe = Je, V = fe, pe = We(Ue);
function ze(e, t) {
  return e.map(({ pubkey: o, sequence: c }) => ({
    publicKey: o,
    modeInfo: {
      single: { mode: t }
    },
    sequence: pe.default.fromNumber(c)
  }));
}
function Le(e, t, o, c, u, f = Fe.SignMode.SIGN_MODE_DIRECT) {
  (0, ge.assert)(c === void 0 || typeof c == "string", "feeGranter must be undefined or string"), (0, ge.assert)(u === void 0 || typeof u == "string", "feePayer must be undefined or string");
  const l = V.AuthInfo.fromPartial({
    signerInfos: ze(e, f),
    fee: {
      amount: [...t],
      gasLimit: pe.default.fromNumber(o),
      granter: c,
      payer: u
    }
  });
  return V.AuthInfo.encode(l).finish();
}
w.makeAuthInfoBytes = Le;
function Ge(e, t, o, c) {
  return {
    bodyBytes: e,
    authInfoBytes: t,
    chainId: o,
    accountNumber: pe.default.fromNumber(c)
  };
}
w.makeSignDoc = Ge;
function He({ accountNumber: e, authInfoBytes: t, bodyBytes: o, chainId: c }) {
  const u = V.SignDoc.fromPartial({
    accountNumber: e,
    authInfoBytes: t,
    bodyBytes: o,
    chainId: c
  });
  return V.SignDoc.encode(u).finish();
}
w.makeSignBytes = He;
var me = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.decrypt = e.encrypt = e.supportedAlgorithms = e.executeKdf = e.cosmjsSalt = void 0;
  const t = Q, o = X;
  e.cosmjsSalt = (0, o.toAscii)("The CosmJS salt.");
  async function c(l, b) {
    switch (b.algorithm) {
      case "argon2id": {
        const h = b.params;
        if (!(0, t.isArgon2idOptions)(h))
          throw new Error("Invalid format of argon2id params");
        return t.Argon2id.execute(l, e.cosmjsSalt, h);
      }
      default:
        throw new Error("Unsupported KDF algorithm");
    }
  }
  e.executeKdf = c, e.supportedAlgorithms = {
    xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
  };
  async function u(l, b, h) {
    switch (h.algorithm) {
      case e.supportedAlgorithms.xchacha20poly1305Ietf: {
        const S = t.Random.getBytes(t.xchacha20NonceLength);
        return new Uint8Array([
          ...S,
          ...await t.Xchacha20poly1305Ietf.encrypt(l, b, S)
        ]);
      }
      default:
        throw new Error(`Unsupported encryption algorithm: '${h.algorithm}'`);
    }
  }
  e.encrypt = u;
  async function f(l, b, h) {
    switch (h.algorithm) {
      case e.supportedAlgorithms.xchacha20poly1305Ietf: {
        const S = l.slice(0, t.xchacha20NonceLength);
        return t.Xchacha20poly1305Ietf.decrypt(l.slice(t.xchacha20NonceLength), b, S);
      }
      default:
        throw new Error(`Unsupported encryption algorithm: '${h.algorithm}'`);
    }
  }
  e.decrypt = f;
})(me);
Object.defineProperty(J, "__esModule", { value: !0 });
J.DirectSecp256k1HdWallet = J.extractKdfConfiguration = void 0;
const ie = Z, P = Q, I = X, N = Ee, qe = w, $ = me, q = "directsecp256k1hdwallet-v1", Ve = {
  algorithm: "argon2id",
  params: {
    outputLength: 32,
    opsLimit: 24,
    memLimitKib: 12 * 1024
  }
};
function Xe(e) {
  return !(!(0, N.isNonNullObject)(e) || typeof e.hdPath != "string" || typeof e.prefix != "string");
}
function Ze(e) {
  return e.kdf;
}
function Qe(e) {
  const t = JSON.parse(e);
  if (!(0, N.isNonNullObject)(t))
    throw new Error("Root document is not an object.");
  switch (t.type) {
    case q:
      return Ze(t);
    default:
      throw new Error("Unsupported serialization type");
  }
}
J.extractKdfConfiguration = Qe;
const Se = {
  bip39Password: "",
  hdPaths: [(0, ie.makeCosmoshubPath)(0)],
  prefix: "cosmos"
};
class B {
  /**
   * Restores a wallet from the given BIP39 mnemonic.
   *
   * @param mnemonic Any valid English mnemonic.
   * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
   */
  static async fromMnemonic(t, o = {}) {
    const c = new P.EnglishMnemonic(t), u = await P.Bip39.mnemonicToSeed(c, o.bip39Password);
    return new B(c, {
      ...o,
      seed: u
    });
  }
  /**
   * Generates a new wallet with a BIP39 mnemonic of the given length.
   *
   * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
   * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
   */
  static async generate(t = 12, o = {}) {
    const c = 4 * Math.floor(11 * t / 33), u = P.Random.getBytes(c), f = P.Bip39.encode(u);
    return B.fromMnemonic(f.toString(), o);
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * @param password The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  static async deserialize(t, o) {
    const c = JSON.parse(t);
    if (!(0, N.isNonNullObject)(c))
      throw new Error("Root document is not an object.");
    switch (c.type) {
      case q:
        return B.deserializeTypeV1(t, o);
      default:
        throw new Error("Unsupported serialization type");
    }
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
   * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
   * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
   */
  static async deserializeWithEncryptionKey(t, o) {
    const c = JSON.parse(t);
    if (!(0, N.isNonNullObject)(c))
      throw new Error("Root document is not an object.");
    const u = c;
    switch (u.type) {
      case q: {
        const f = await (0, $.decrypt)((0, I.fromBase64)(u.data), o, u.encryption), l = JSON.parse((0, I.fromUtf8)(f)), { mnemonic: b, accounts: h } = l;
        if ((0, N.assert)(typeof b == "string"), !Array.isArray(h))
          throw new Error("Property 'accounts' is not an array");
        if (!h.every((k) => Xe(k)))
          throw new Error("Account is not in the correct format.");
        const S = h[0].prefix;
        if (!h.every(({ prefix: k }) => k === S))
          throw new Error("Accounts do not all have the same prefix");
        const _ = h.map(({ hdPath: k }) => (0, P.stringToPath)(k));
        return B.fromMnemonic(b, {
          hdPaths: _,
          prefix: S
        });
      }
      default:
        throw new Error("Unsupported serialization type");
    }
  }
  static async deserializeTypeV1(t, o) {
    const c = JSON.parse(t);
    if (!(0, N.isNonNullObject)(c))
      throw new Error("Root document is not an object.");
    const u = await (0, $.executeKdf)(o, c.kdf);
    return B.deserializeWithEncryptionKey(t, u);
  }
  constructor(t, o) {
    const c = o.prefix ?? Se.prefix, u = o.hdPaths ?? Se.hdPaths;
    this.secret = t, this.seed = o.seed, this.accounts = u.map((f) => ({
      hdPath: f,
      prefix: c
    }));
  }
  get mnemonic() {
    return this.secret.toString();
  }
  async getAccounts() {
    return (await this.getAccountsWithPrivkeys()).map(({ algo: o, pubkey: c, address: u }) => ({
      algo: o,
      pubkey: c,
      address: u
    }));
  }
  async signDirect(t, o) {
    const u = (await this.getAccountsWithPrivkeys()).find(({ address: E }) => E === t);
    if (u === void 0)
      throw new Error(`Address ${t} not found in wallet`);
    const { privkey: f, pubkey: l } = u, b = (0, qe.makeSignBytes)(o), h = (0, P.sha256)(b), S = await P.Secp256k1.createSignature(h, f), _ = new Uint8Array([...S.r(32), ...S.s(32)]), k = (0, ie.encodeSecp256k1Signature)(l, _);
    return {
      signed: o,
      signature: k
    };
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * @param password The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  async serialize(t) {
    const o = Ve, c = await (0, $.executeKdf)(t, o);
    return this.serializeWithEncryptionKey(c, o);
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
   * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF options. If this
   * is not the case, the wallet cannot be restored with the original password.
   */
  async serializeWithEncryptionKey(t, o) {
    const c = {
      mnemonic: this.mnemonic,
      accounts: this.accounts.map(({ hdPath: h, prefix: S }) => ({
        hdPath: (0, P.pathToString)(h),
        prefix: S
      }))
    }, u = (0, I.toUtf8)(JSON.stringify(c)), f = {
      algorithm: $.supportedAlgorithms.xchacha20poly1305Ietf
    }, l = await (0, $.encrypt)(u, t, f), b = {
      type: q,
      kdf: o,
      encryption: f,
      data: (0, I.toBase64)(l)
    };
    return JSON.stringify(b);
  }
  async getKeyPair(t) {
    const { privkey: o } = P.Slip10.derivePath(P.Slip10Curve.Secp256k1, this.seed, t), { pubkey: c } = await P.Secp256k1.makeKeypair(o);
    return {
      privkey: o,
      pubkey: P.Secp256k1.compressPubkey(c)
    };
  }
  async getAccountsWithPrivkeys() {
    return Promise.all(this.accounts.map(async ({ hdPath: t, prefix: o }) => {
      const { privkey: c, pubkey: u } = await this.getKeyPair(t), f = (0, I.toBech32)(o, (0, ie.rawSecp256k1PubkeyToRawAddress)(u));
      return {
        algo: "secp256k1",
        privkey: c,
        pubkey: u,
        address: f
      };
    }));
  }
}
J.DirectSecp256k1HdWallet = B;
var x = {};
Object.defineProperty(x, "__esModule", { value: !0 });
x.DirectSecp256k1Wallet = void 0;
const ke = Z, H = Q, Ye = X, je = w;
class be {
  /**
   * Creates a DirectSecp256k1Wallet from the given private key
   *
   * @param privkey The private key.
   * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
   */
  static async fromKey(t, o = "cosmos") {
    const c = (await H.Secp256k1.makeKeypair(t)).pubkey;
    return new be(t, H.Secp256k1.compressPubkey(c), o);
  }
  constructor(t, o, c) {
    this.privkey = t, this.pubkey = o, this.prefix = c;
  }
  get address() {
    return (0, Ye.toBech32)(this.prefix, (0, ke.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
  }
  async getAccounts() {
    return [
      {
        algo: "secp256k1",
        address: this.address,
        pubkey: this.pubkey
      }
    ];
  }
  async signDirect(t, o) {
    const c = (0, je.makeSignBytes)(o);
    if (t !== this.address)
      throw new Error(`Address ${t} not found in wallet`);
    const u = (0, H.sha256)(c), f = await H.Secp256k1.createSignature(u, this.privkey), l = new Uint8Array([...f.r(32), ...f.s(32)]), b = (0, ke.encodeSecp256k1Signature)(this.pubkey, l);
    return {
      signed: o,
      signature: b
    };
  }
}
x.DirectSecp256k1Wallet = be;
var ee = {};
Object.defineProperty(ee, "__esModule", { value: !0 });
ee.makeCosmoshubPath = void 0;
const W = Q;
function xe(e) {
  return [
    W.Slip10RawIndex.hardened(44),
    W.Slip10RawIndex.hardened(118),
    W.Slip10RawIndex.hardened(0),
    W.Slip10RawIndex.normal(0),
    W.Slip10RawIndex.normal(e)
  ];
}
ee.makeCosmoshubPath = xe;
var v = {}, A = {}, en = m && m.__createBinding || (Object.create ? function(e, t, o, c) {
  c === void 0 && (c = o);
  var u = Object.getOwnPropertyDescriptor(t, o);
  (!u || ("get" in u ? !t.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
    return t[o];
  } }), Object.defineProperty(e, c, u);
} : function(e, t, o, c) {
  c === void 0 && (c = o), e[c] = t[o];
}), nn = m && m.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), tn = m && m.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var t = {};
  if (e != null)
    for (var o in e)
      o !== "default" && Object.prototype.hasOwnProperty.call(e, o) && en(t, e, o);
  return nn(t, e), t;
};
Object.defineProperty(A, "__esModule", { value: !0 });
A.PrivKey = A.PubKey = A.protobufPackage = void 0;
const R = tn(L), T = G;
A.protobufPackage = "cosmos.crypto.ed25519";
function Pe() {
  return {
    key: new Uint8Array()
  };
}
A.PubKey = {
  encode(e, t = R.Writer.create()) {
    return e.key.length !== 0 && t.uint32(10).bytes(e.key), t;
  },
  decode(e, t) {
    const o = e instanceof R.Reader ? e : new R.Reader(e);
    let c = t === void 0 ? o.len : o.pos + t;
    const u = Pe();
    for (; o.pos < c; ) {
      const f = o.uint32();
      switch (f >>> 3) {
        case 1:
          u.key = o.bytes();
          break;
        default:
          o.skipType(f & 7);
          break;
      }
    }
    return u;
  },
  fromJSON(e) {
    return {
      key: (0, T.isSet)(e.key) ? (0, T.bytesFromBase64)(e.key) : new Uint8Array()
    };
  },
  toJSON(e) {
    const t = {};
    return e.key !== void 0 && (t.key = (0, T.base64FromBytes)(e.key !== void 0 ? e.key : new Uint8Array())), t;
  },
  fromPartial(e) {
    const t = Pe();
    return t.key = e.key ?? new Uint8Array(), t;
  }
};
function _e() {
  return {
    key: new Uint8Array()
  };
}
A.PrivKey = {
  encode(e, t = R.Writer.create()) {
    return e.key.length !== 0 && t.uint32(10).bytes(e.key), t;
  },
  decode(e, t) {
    const o = e instanceof R.Reader ? e : new R.Reader(e);
    let c = t === void 0 ? o.len : o.pos + t;
    const u = _e();
    for (; o.pos < c; ) {
      const f = o.uint32();
      switch (f >>> 3) {
        case 1:
          u.key = o.bytes();
          break;
        default:
          o.skipType(f & 7);
          break;
      }
    }
    return u;
  },
  fromJSON(e) {
    return {
      key: (0, T.isSet)(e.key) ? (0, T.bytesFromBase64)(e.key) : new Uint8Array()
    };
  },
  toJSON(e) {
    const t = {};
    return e.key !== void 0 && (t.key = (0, T.base64FromBytes)(e.key !== void 0 ? e.key : new Uint8Array())), t;
  },
  fromPartial(e) {
    const t = _e();
    return t.key = e.key ?? new Uint8Array(), t;
  }
};
var D = {}, rn = m && m.__createBinding || (Object.create ? function(e, t, o, c) {
  c === void 0 && (c = o);
  var u = Object.getOwnPropertyDescriptor(t, o);
  (!u || ("get" in u ? !t.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
    return t[o];
  } }), Object.defineProperty(e, c, u);
} : function(e, t, o, c) {
  c === void 0 && (c = o), e[c] = t[o];
}), an = m && m.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), on = m && m.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var t = {};
  if (e != null)
    for (var o in e)
      o !== "default" && Object.prototype.hasOwnProperty.call(e, o) && rn(t, e, o);
  return an(t, e), t;
};
Object.defineProperty(D, "__esModule", { value: !0 });
D.LegacyAminoPubKey = D.protobufPackage = void 0;
const F = le, re = on(L), sn = G;
D.protobufPackage = "cosmos.crypto.multisig";
function Oe() {
  return {
    threshold: 0,
    publicKeys: []
  };
}
D.LegacyAminoPubKey = {
  encode(e, t = re.Writer.create()) {
    e.threshold !== 0 && t.uint32(8).uint32(e.threshold);
    for (const o of e.publicKeys)
      F.Any.encode(o, t.uint32(18).fork()).ldelim();
    return t;
  },
  decode(e, t) {
    const o = e instanceof re.Reader ? e : new re.Reader(e);
    let c = t === void 0 ? o.len : o.pos + t;
    const u = Oe();
    for (; o.pos < c; ) {
      const f = o.uint32();
      switch (f >>> 3) {
        case 1:
          u.threshold = o.uint32();
          break;
        case 2:
          u.publicKeys.push(F.Any.decode(o, o.uint32()));
          break;
        default:
          o.skipType(f & 7);
          break;
      }
    }
    return u;
  },
  fromJSON(e) {
    return {
      threshold: (0, sn.isSet)(e.threshold) ? Number(e.threshold) : 0,
      publicKeys: Array.isArray(e == null ? void 0 : e.publicKeys) ? e.publicKeys.map((t) => F.Any.fromJSON(t)) : []
    };
  },
  toJSON(e) {
    const t = {};
    return e.threshold !== void 0 && (t.threshold = Math.round(e.threshold)), e.publicKeys ? t.publicKeys = e.publicKeys.map((o) => o ? F.Any.toJSON(o) : void 0) : t.publicKeys = [], t;
  },
  fromPartial(e) {
    var o;
    const t = Oe();
    return t.threshold = e.threshold ?? 0, t.publicKeys = ((o = e.publicKeys) == null ? void 0 : o.map((c) => F.Any.fromPartial(c))) || [], t;
  }
};
var M = {}, dn = m && m.__createBinding || (Object.create ? function(e, t, o, c) {
  c === void 0 && (c = o);
  var u = Object.getOwnPropertyDescriptor(t, o);
  (!u || ("get" in u ? !t.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {
    return t[o];
  } }), Object.defineProperty(e, c, u);
} : function(e, t, o, c) {
  c === void 0 && (c = o), e[c] = t[o];
}), un = m && m.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), cn = m && m.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var t = {};
  if (e != null)
    for (var o in e)
      o !== "default" && Object.prototype.hasOwnProperty.call(e, o) && dn(t, e, o);
  return un(t, e), t;
};
Object.defineProperty(M, "__esModule", { value: !0 });
M.PrivKey = M.PubKey = M.protobufPackage = void 0;
const K = cn(L), U = G;
M.protobufPackage = "cosmos.crypto.secp256k1";
function we() {
  return {
    key: new Uint8Array()
  };
}
M.PubKey = {
  encode(e, t = K.Writer.create()) {
    return e.key.length !== 0 && t.uint32(10).bytes(e.key), t;
  },
  decode(e, t) {
    const o = e instanceof K.Reader ? e : new K.Reader(e);
    let c = t === void 0 ? o.len : o.pos + t;
    const u = we();
    for (; o.pos < c; ) {
      const f = o.uint32();
      switch (f >>> 3) {
        case 1:
          u.key = o.bytes();
          break;
        default:
          o.skipType(f & 7);
          break;
      }
    }
    return u;
  },
  fromJSON(e) {
    return {
      key: (0, U.isSet)(e.key) ? (0, U.bytesFromBase64)(e.key) : new Uint8Array()
    };
  },
  toJSON(e) {
    const t = {};
    return e.key !== void 0 && (t.key = (0, U.base64FromBytes)(e.key !== void 0 ? e.key : new Uint8Array())), t;
  },
  fromPartial(e) {
    const t = we();
    return t.key = e.key ?? new Uint8Array(), t;
  }
};
function ve() {
  return {
    key: new Uint8Array()
  };
}
M.PrivKey = {
  encode(e, t = K.Writer.create()) {
    return e.key.length !== 0 && t.uint32(10).bytes(e.key), t;
  },
  decode(e, t) {
    const o = e instanceof K.Reader ? e : new K.Reader(e);
    let c = t === void 0 ? o.len : o.pos + t;
    const u = ve();
    for (; o.pos < c; ) {
      const f = o.uint32();
      switch (f >>> 3) {
        case 1:
          u.key = o.bytes();
          break;
        default:
          o.skipType(f & 7);
          break;
      }
    }
    return u;
  },
  fromJSON(e) {
    return {
      key: (0, U.isSet)(e.key) ? (0, U.bytesFromBase64)(e.key) : new Uint8Array()
    };
  },
  toJSON(e) {
    const t = {};
    return e.key !== void 0 && (t.key = (0, U.base64FromBytes)(e.key !== void 0 ? e.key : new Uint8Array())), t;
  },
  fromPartial(e) {
    const t = ve();
    return t.key = e.key ?? new Uint8Array(), t;
  }
};
Object.defineProperty(v, "__esModule", { value: !0 });
v.decodePubkey = v.anyToSinglePubkey = v.encodePubkey = void 0;
const z = Z, Ae = X, fn = De, se = A, de = D, ue = M, ae = le;
function Ne(e) {
  if ((0, z.isSecp256k1Pubkey)(e)) {
    const t = ue.PubKey.fromPartial({
      key: (0, Ae.fromBase64)(e.value)
    });
    return ae.Any.fromPartial({
      typeUrl: "/cosmos.crypto.secp256k1.PubKey",
      value: Uint8Array.from(ue.PubKey.encode(t).finish())
    });
  } else if ((0, z.isEd25519Pubkey)(e)) {
    const t = se.PubKey.fromPartial({
      key: (0, Ae.fromBase64)(e.value)
    });
    return ae.Any.fromPartial({
      typeUrl: "/cosmos.crypto.ed25519.PubKey",
      value: Uint8Array.from(se.PubKey.encode(t).finish())
    });
  } else if ((0, z.isMultisigThresholdPubkey)(e)) {
    const t = de.LegacyAminoPubKey.fromPartial({
      threshold: fn.Uint53.fromString(e.value.threshold).toNumber(),
      publicKeys: e.value.pubkeys.map(Ne)
    });
    return ae.Any.fromPartial({
      typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
      value: Uint8Array.from(de.LegacyAminoPubKey.encode(t).finish())
    });
  } else
    throw new Error(`Pubkey type ${e.type} not recognized`);
}
v.encodePubkey = Ne;
function ce(e) {
  switch (e.typeUrl) {
    case "/cosmos.crypto.secp256k1.PubKey": {
      const { key: t } = ue.PubKey.decode(e.value);
      return (0, z.encodeSecp256k1Pubkey)(t);
    }
    case "/cosmos.crypto.ed25519.PubKey": {
      const { key: t } = se.PubKey.decode(e.value);
      return (0, z.encodeEd25519Pubkey)(t);
    }
    default:
      throw new Error(`Pubkey type_url ${e.typeUrl} not recognized as single public key type`);
  }
}
v.anyToSinglePubkey = ce;
function ln(e) {
  switch (e.typeUrl) {
    case "/cosmos.crypto.secp256k1.PubKey":
    case "/cosmos.crypto.ed25519.PubKey":
      return ce(e);
    case "/cosmos.crypto.multisig.LegacyAminoPubKey": {
      const { threshold: t, publicKeys: o } = de.LegacyAminoPubKey.decode(e.value);
      return {
        type: "tendermint/PubKeyMultisigThreshold",
        value: {
          threshold: t.toString(),
          pubkeys: o.map(ce)
        }
      };
    }
    default:
      throw new Error(`Pubkey type_url ${e.typeUrl} not recognized`);
  }
}
v.decodePubkey = ln;
var O = {}, Re = {}, Te = {};
(function(e) {
  var t = m && m.__createBinding || (Object.create ? function(n, i, d, r) {
    r === void 0 && (r = d);
    var a = Object.getOwnPropertyDescriptor(i, d);
    (!a || ("get" in a ? !i.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
      return i[d];
    } }), Object.defineProperty(n, r, a);
  } : function(n, i, d, r) {
    r === void 0 && (r = d), n[r] = i[d];
  }), o = m && m.__setModuleDefault || (Object.create ? function(n, i) {
    Object.defineProperty(n, "default", { enumerable: !0, value: i });
  } : function(n, i) {
    n.default = i;
  }), c = m && m.__importStar || function(n) {
    if (n && n.__esModule)
      return n;
    var i = {};
    if (n != null)
      for (var d in n)
        d !== "default" && Object.prototype.hasOwnProperty.call(n, d) && t(i, n, d);
    return o(i, n), i;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Metadata = e.DenomUnit = e.Supply = e.Output = e.Input = e.SendEnabled = e.Params = e.protobufPackage = void 0;
  const u = ye, f = c(L), l = G;
  e.protobufPackage = "cosmos.bank.v1beta1";
  function b() {
    return {
      sendEnabled: [],
      defaultSendEnabled: !1
    };
  }
  e.Params = {
    encode(n, i = f.Writer.create()) {
      for (const d of n.sendEnabled)
        e.SendEnabled.encode(d, i.uint32(10).fork()).ldelim();
      return n.defaultSendEnabled === !0 && i.uint32(16).bool(n.defaultSendEnabled), i;
    },
    decode(n, i) {
      const d = n instanceof f.Reader ? n : new f.Reader(n);
      let r = i === void 0 ? d.len : d.pos + i;
      const a = b();
      for (; d.pos < r; ) {
        const s = d.uint32();
        switch (s >>> 3) {
          case 1:
            a.sendEnabled.push(e.SendEnabled.decode(d, d.uint32()));
            break;
          case 2:
            a.defaultSendEnabled = d.bool();
            break;
          default:
            d.skipType(s & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(n) {
      return {
        sendEnabled: Array.isArray(n == null ? void 0 : n.sendEnabled) ? n.sendEnabled.map((i) => e.SendEnabled.fromJSON(i)) : [],
        defaultSendEnabled: (0, l.isSet)(n.defaultSendEnabled) ? !!n.defaultSendEnabled : !1
      };
    },
    toJSON(n) {
      const i = {};
      return n.sendEnabled ? i.sendEnabled = n.sendEnabled.map((d) => d ? e.SendEnabled.toJSON(d) : void 0) : i.sendEnabled = [], n.defaultSendEnabled !== void 0 && (i.defaultSendEnabled = n.defaultSendEnabled), i;
    },
    fromPartial(n) {
      var d;
      const i = b();
      return i.sendEnabled = ((d = n.sendEnabled) == null ? void 0 : d.map((r) => e.SendEnabled.fromPartial(r))) || [], i.defaultSendEnabled = n.defaultSendEnabled ?? !1, i;
    }
  };
  function h() {
    return {
      denom: "",
      enabled: !1
    };
  }
  e.SendEnabled = {
    encode(n, i = f.Writer.create()) {
      return n.denom !== "" && i.uint32(10).string(n.denom), n.enabled === !0 && i.uint32(16).bool(n.enabled), i;
    },
    decode(n, i) {
      const d = n instanceof f.Reader ? n : new f.Reader(n);
      let r = i === void 0 ? d.len : d.pos + i;
      const a = h();
      for (; d.pos < r; ) {
        const s = d.uint32();
        switch (s >>> 3) {
          case 1:
            a.denom = d.string();
            break;
          case 2:
            a.enabled = d.bool();
            break;
          default:
            d.skipType(s & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(n) {
      return {
        denom: (0, l.isSet)(n.denom) ? String(n.denom) : "",
        enabled: (0, l.isSet)(n.enabled) ? !!n.enabled : !1
      };
    },
    toJSON(n) {
      const i = {};
      return n.denom !== void 0 && (i.denom = n.denom), n.enabled !== void 0 && (i.enabled = n.enabled), i;
    },
    fromPartial(n) {
      const i = h();
      return i.denom = n.denom ?? "", i.enabled = n.enabled ?? !1, i;
    }
  };
  function S() {
    return {
      address: "",
      coins: []
    };
  }
  e.Input = {
    encode(n, i = f.Writer.create()) {
      n.address !== "" && i.uint32(10).string(n.address);
      for (const d of n.coins)
        u.Coin.encode(d, i.uint32(18).fork()).ldelim();
      return i;
    },
    decode(n, i) {
      const d = n instanceof f.Reader ? n : new f.Reader(n);
      let r = i === void 0 ? d.len : d.pos + i;
      const a = S();
      for (; d.pos < r; ) {
        const s = d.uint32();
        switch (s >>> 3) {
          case 1:
            a.address = d.string();
            break;
          case 2:
            a.coins.push(u.Coin.decode(d, d.uint32()));
            break;
          default:
            d.skipType(s & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(n) {
      return {
        address: (0, l.isSet)(n.address) ? String(n.address) : "",
        coins: Array.isArray(n == null ? void 0 : n.coins) ? n.coins.map((i) => u.Coin.fromJSON(i)) : []
      };
    },
    toJSON(n) {
      const i = {};
      return n.address !== void 0 && (i.address = n.address), n.coins ? i.coins = n.coins.map((d) => d ? u.Coin.toJSON(d) : void 0) : i.coins = [], i;
    },
    fromPartial(n) {
      var d;
      const i = S();
      return i.address = n.address ?? "", i.coins = ((d = n.coins) == null ? void 0 : d.map((r) => u.Coin.fromPartial(r))) || [], i;
    }
  };
  function _() {
    return {
      address: "",
      coins: []
    };
  }
  e.Output = {
    encode(n, i = f.Writer.create()) {
      n.address !== "" && i.uint32(10).string(n.address);
      for (const d of n.coins)
        u.Coin.encode(d, i.uint32(18).fork()).ldelim();
      return i;
    },
    decode(n, i) {
      const d = n instanceof f.Reader ? n : new f.Reader(n);
      let r = i === void 0 ? d.len : d.pos + i;
      const a = _();
      for (; d.pos < r; ) {
        const s = d.uint32();
        switch (s >>> 3) {
          case 1:
            a.address = d.string();
            break;
          case 2:
            a.coins.push(u.Coin.decode(d, d.uint32()));
            break;
          default:
            d.skipType(s & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(n) {
      return {
        address: (0, l.isSet)(n.address) ? String(n.address) : "",
        coins: Array.isArray(n == null ? void 0 : n.coins) ? n.coins.map((i) => u.Coin.fromJSON(i)) : []
      };
    },
    toJSON(n) {
      const i = {};
      return n.address !== void 0 && (i.address = n.address), n.coins ? i.coins = n.coins.map((d) => d ? u.Coin.toJSON(d) : void 0) : i.coins = [], i;
    },
    fromPartial(n) {
      var d;
      const i = _();
      return i.address = n.address ?? "", i.coins = ((d = n.coins) == null ? void 0 : d.map((r) => u.Coin.fromPartial(r))) || [], i;
    }
  };
  function k() {
    return {
      total: []
    };
  }
  e.Supply = {
    encode(n, i = f.Writer.create()) {
      for (const d of n.total)
        u.Coin.encode(d, i.uint32(10).fork()).ldelim();
      return i;
    },
    decode(n, i) {
      const d = n instanceof f.Reader ? n : new f.Reader(n);
      let r = i === void 0 ? d.len : d.pos + i;
      const a = k();
      for (; d.pos < r; ) {
        const s = d.uint32();
        switch (s >>> 3) {
          case 1:
            a.total.push(u.Coin.decode(d, d.uint32()));
            break;
          default:
            d.skipType(s & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(n) {
      return {
        total: Array.isArray(n == null ? void 0 : n.total) ? n.total.map((i) => u.Coin.fromJSON(i)) : []
      };
    },
    toJSON(n) {
      const i = {};
      return n.total ? i.total = n.total.map((d) => d ? u.Coin.toJSON(d) : void 0) : i.total = [], i;
    },
    fromPartial(n) {
      var d;
      const i = k();
      return i.total = ((d = n.total) == null ? void 0 : d.map((r) => u.Coin.fromPartial(r))) || [], i;
    }
  };
  function E() {
    return {
      denom: "",
      exponent: 0,
      aliases: []
    };
  }
  e.DenomUnit = {
    encode(n, i = f.Writer.create()) {
      n.denom !== "" && i.uint32(10).string(n.denom), n.exponent !== 0 && i.uint32(16).uint32(n.exponent);
      for (const d of n.aliases)
        i.uint32(26).string(d);
      return i;
    },
    decode(n, i) {
      const d = n instanceof f.Reader ? n : new f.Reader(n);
      let r = i === void 0 ? d.len : d.pos + i;
      const a = E();
      for (; d.pos < r; ) {
        const s = d.uint32();
        switch (s >>> 3) {
          case 1:
            a.denom = d.string();
            break;
          case 2:
            a.exponent = d.uint32();
            break;
          case 3:
            a.aliases.push(d.string());
            break;
          default:
            d.skipType(s & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(n) {
      return {
        denom: (0, l.isSet)(n.denom) ? String(n.denom) : "",
        exponent: (0, l.isSet)(n.exponent) ? Number(n.exponent) : 0,
        aliases: Array.isArray(n == null ? void 0 : n.aliases) ? n.aliases.map((i) => String(i)) : []
      };
    },
    toJSON(n) {
      const i = {};
      return n.denom !== void 0 && (i.denom = n.denom), n.exponent !== void 0 && (i.exponent = Math.round(n.exponent)), n.aliases ? i.aliases = n.aliases.map((d) => d) : i.aliases = [], i;
    },
    fromPartial(n) {
      var d;
      const i = E();
      return i.denom = n.denom ?? "", i.exponent = n.exponent ?? 0, i.aliases = ((d = n.aliases) == null ? void 0 : d.map((r) => r)) || [], i;
    }
  };
  function C() {
    return {
      description: "",
      denomUnits: [],
      base: "",
      display: "",
      name: "",
      symbol: "",
      uri: "",
      uriHash: ""
    };
  }
  e.Metadata = {
    encode(n, i = f.Writer.create()) {
      n.description !== "" && i.uint32(10).string(n.description);
      for (const d of n.denomUnits)
        e.DenomUnit.encode(d, i.uint32(18).fork()).ldelim();
      return n.base !== "" && i.uint32(26).string(n.base), n.display !== "" && i.uint32(34).string(n.display), n.name !== "" && i.uint32(42).string(n.name), n.symbol !== "" && i.uint32(50).string(n.symbol), n.uri !== "" && i.uint32(58).string(n.uri), n.uriHash !== "" && i.uint32(66).string(n.uriHash), i;
    },
    decode(n, i) {
      const d = n instanceof f.Reader ? n : new f.Reader(n);
      let r = i === void 0 ? d.len : d.pos + i;
      const a = C();
      for (; d.pos < r; ) {
        const s = d.uint32();
        switch (s >>> 3) {
          case 1:
            a.description = d.string();
            break;
          case 2:
            a.denomUnits.push(e.DenomUnit.decode(d, d.uint32()));
            break;
          case 3:
            a.base = d.string();
            break;
          case 4:
            a.display = d.string();
            break;
          case 5:
            a.name = d.string();
            break;
          case 6:
            a.symbol = d.string();
            break;
          case 7:
            a.uri = d.string();
            break;
          case 8:
            a.uriHash = d.string();
            break;
          default:
            d.skipType(s & 7);
            break;
        }
      }
      return a;
    },
    fromJSON(n) {
      return {
        description: (0, l.isSet)(n.description) ? String(n.description) : "",
        denomUnits: Array.isArray(n == null ? void 0 : n.denomUnits) ? n.denomUnits.map((i) => e.DenomUnit.fromJSON(i)) : [],
        base: (0, l.isSet)(n.base) ? String(n.base) : "",
        display: (0, l.isSet)(n.display) ? String(n.display) : "",
        name: (0, l.isSet)(n.name) ? String(n.name) : "",
        symbol: (0, l.isSet)(n.symbol) ? String(n.symbol) : "",
        uri: (0, l.isSet)(n.uri) ? String(n.uri) : "",
        uriHash: (0, l.isSet)(n.uriHash) ? String(n.uriHash) : ""
      };
    },
    toJSON(n) {
      const i = {};
      return n.description !== void 0 && (i.description = n.description), n.denomUnits ? i.denomUnits = n.denomUnits.map((d) => d ? e.DenomUnit.toJSON(d) : void 0) : i.denomUnits = [], n.base !== void 0 && (i.base = n.base), n.display !== void 0 && (i.display = n.display), n.name !== void 0 && (i.name = n.name), n.symbol !== void 0 && (i.symbol = n.symbol), n.uri !== void 0 && (i.uri = n.uri), n.uriHash !== void 0 && (i.uriHash = n.uriHash), i;
    },
    fromPartial(n) {
      var d;
      const i = C();
      return i.description = n.description ?? "", i.denomUnits = ((d = n.denomUnits) == null ? void 0 : d.map((r) => e.DenomUnit.fromPartial(r))) || [], i.base = n.base ?? "", i.display = n.display ?? "", i.name = n.name ?? "", i.symbol = n.symbol ?? "", i.uri = n.uri ?? "", i.uriHash = n.uriHash ?? "", i;
    }
  };
})(Te);
(function(e) {
  var t = m && m.__createBinding || (Object.create ? function(r, a, s, p) {
    p === void 0 && (p = s);
    var y = Object.getOwnPropertyDescriptor(a, s);
    (!y || ("get" in y ? !a.__esModule : y.writable || y.configurable)) && (y = { enumerable: !0, get: function() {
      return a[s];
    } }), Object.defineProperty(r, p, y);
  } : function(r, a, s, p) {
    p === void 0 && (p = s), r[p] = a[s];
  }), o = m && m.__setModuleDefault || (Object.create ? function(r, a) {
    Object.defineProperty(r, "default", { enumerable: !0, value: a });
  } : function(r, a) {
    r.default = a;
  }), c = m && m.__importStar || function(r) {
    if (r && r.__esModule)
      return r;
    var a = {};
    if (r != null)
      for (var s in r)
        s !== "default" && Object.prototype.hasOwnProperty.call(r, s) && t(a, r, s);
    return o(a, r), a;
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MsgClientImpl = e.MsgSetSendEnabledResponse = e.MsgSetSendEnabled = e.MsgUpdateParamsResponse = e.MsgUpdateParams = e.MsgMultiSendResponse = e.MsgMultiSend = e.MsgSendResponse = e.MsgSend = e.protobufPackage = void 0;
  const u = ye, f = Te, l = c(L), b = G;
  e.protobufPackage = "cosmos.bank.v1beta1";
  function h() {
    return {
      fromAddress: "",
      toAddress: "",
      amount: []
    };
  }
  e.MsgSend = {
    encode(r, a = l.Writer.create()) {
      r.fromAddress !== "" && a.uint32(10).string(r.fromAddress), r.toAddress !== "" && a.uint32(18).string(r.toAddress);
      for (const s of r.amount)
        u.Coin.encode(s, a.uint32(26).fork()).ldelim();
      return a;
    },
    decode(r, a) {
      const s = r instanceof l.Reader ? r : new l.Reader(r);
      let p = a === void 0 ? s.len : s.pos + a;
      const y = h();
      for (; s.pos < p; ) {
        const g = s.uint32();
        switch (g >>> 3) {
          case 1:
            y.fromAddress = s.string();
            break;
          case 2:
            y.toAddress = s.string();
            break;
          case 3:
            y.amount.push(u.Coin.decode(s, s.uint32()));
            break;
          default:
            s.skipType(g & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(r) {
      return {
        fromAddress: (0, b.isSet)(r.fromAddress) ? String(r.fromAddress) : "",
        toAddress: (0, b.isSet)(r.toAddress) ? String(r.toAddress) : "",
        amount: Array.isArray(r == null ? void 0 : r.amount) ? r.amount.map((a) => u.Coin.fromJSON(a)) : []
      };
    },
    toJSON(r) {
      const a = {};
      return r.fromAddress !== void 0 && (a.fromAddress = r.fromAddress), r.toAddress !== void 0 && (a.toAddress = r.toAddress), r.amount ? a.amount = r.amount.map((s) => s ? u.Coin.toJSON(s) : void 0) : a.amount = [], a;
    },
    fromPartial(r) {
      var s;
      const a = h();
      return a.fromAddress = r.fromAddress ?? "", a.toAddress = r.toAddress ?? "", a.amount = ((s = r.amount) == null ? void 0 : s.map((p) => u.Coin.fromPartial(p))) || [], a;
    }
  };
  function S() {
    return {};
  }
  e.MsgSendResponse = {
    encode(r, a = l.Writer.create()) {
      return a;
    },
    decode(r, a) {
      const s = r instanceof l.Reader ? r : new l.Reader(r);
      let p = a === void 0 ? s.len : s.pos + a;
      const y = S();
      for (; s.pos < p; ) {
        const g = s.uint32();
        switch (g >>> 3) {
          default:
            s.skipType(g & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(r) {
      return {};
    },
    toJSON(r) {
      return {};
    },
    fromPartial(r) {
      return S();
    }
  };
  function _() {
    return {
      inputs: [],
      outputs: []
    };
  }
  e.MsgMultiSend = {
    encode(r, a = l.Writer.create()) {
      for (const s of r.inputs)
        f.Input.encode(s, a.uint32(10).fork()).ldelim();
      for (const s of r.outputs)
        f.Output.encode(s, a.uint32(18).fork()).ldelim();
      return a;
    },
    decode(r, a) {
      const s = r instanceof l.Reader ? r : new l.Reader(r);
      let p = a === void 0 ? s.len : s.pos + a;
      const y = _();
      for (; s.pos < p; ) {
        const g = s.uint32();
        switch (g >>> 3) {
          case 1:
            y.inputs.push(f.Input.decode(s, s.uint32()));
            break;
          case 2:
            y.outputs.push(f.Output.decode(s, s.uint32()));
            break;
          default:
            s.skipType(g & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(r) {
      return {
        inputs: Array.isArray(r == null ? void 0 : r.inputs) ? r.inputs.map((a) => f.Input.fromJSON(a)) : [],
        outputs: Array.isArray(r == null ? void 0 : r.outputs) ? r.outputs.map((a) => f.Output.fromJSON(a)) : []
      };
    },
    toJSON(r) {
      const a = {};
      return r.inputs ? a.inputs = r.inputs.map((s) => s ? f.Input.toJSON(s) : void 0) : a.inputs = [], r.outputs ? a.outputs = r.outputs.map((s) => s ? f.Output.toJSON(s) : void 0) : a.outputs = [], a;
    },
    fromPartial(r) {
      var s, p;
      const a = _();
      return a.inputs = ((s = r.inputs) == null ? void 0 : s.map((y) => f.Input.fromPartial(y))) || [], a.outputs = ((p = r.outputs) == null ? void 0 : p.map((y) => f.Output.fromPartial(y))) || [], a;
    }
  };
  function k() {
    return {};
  }
  e.MsgMultiSendResponse = {
    encode(r, a = l.Writer.create()) {
      return a;
    },
    decode(r, a) {
      const s = r instanceof l.Reader ? r : new l.Reader(r);
      let p = a === void 0 ? s.len : s.pos + a;
      const y = k();
      for (; s.pos < p; ) {
        const g = s.uint32();
        switch (g >>> 3) {
          default:
            s.skipType(g & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(r) {
      return {};
    },
    toJSON(r) {
      return {};
    },
    fromPartial(r) {
      return k();
    }
  };
  function E() {
    return {
      authority: "",
      params: void 0
    };
  }
  e.MsgUpdateParams = {
    encode(r, a = l.Writer.create()) {
      return r.authority !== "" && a.uint32(10).string(r.authority), r.params !== void 0 && f.Params.encode(r.params, a.uint32(18).fork()).ldelim(), a;
    },
    decode(r, a) {
      const s = r instanceof l.Reader ? r : new l.Reader(r);
      let p = a === void 0 ? s.len : s.pos + a;
      const y = E();
      for (; s.pos < p; ) {
        const g = s.uint32();
        switch (g >>> 3) {
          case 1:
            y.authority = s.string();
            break;
          case 2:
            y.params = f.Params.decode(s, s.uint32());
            break;
          default:
            s.skipType(g & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(r) {
      return {
        authority: (0, b.isSet)(r.authority) ? String(r.authority) : "",
        params: (0, b.isSet)(r.params) ? f.Params.fromJSON(r.params) : void 0
      };
    },
    toJSON(r) {
      const a = {};
      return r.authority !== void 0 && (a.authority = r.authority), r.params !== void 0 && (a.params = r.params ? f.Params.toJSON(r.params) : void 0), a;
    },
    fromPartial(r) {
      const a = E();
      return a.authority = r.authority ?? "", a.params = r.params !== void 0 && r.params !== null ? f.Params.fromPartial(r.params) : void 0, a;
    }
  };
  function C() {
    return {};
  }
  e.MsgUpdateParamsResponse = {
    encode(r, a = l.Writer.create()) {
      return a;
    },
    decode(r, a) {
      const s = r instanceof l.Reader ? r : new l.Reader(r);
      let p = a === void 0 ? s.len : s.pos + a;
      const y = C();
      for (; s.pos < p; ) {
        const g = s.uint32();
        switch (g >>> 3) {
          default:
            s.skipType(g & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(r) {
      return {};
    },
    toJSON(r) {
      return {};
    },
    fromPartial(r) {
      return C();
    }
  };
  function n() {
    return {
      authority: "",
      sendEnabled: [],
      useDefaultFor: []
    };
  }
  e.MsgSetSendEnabled = {
    encode(r, a = l.Writer.create()) {
      r.authority !== "" && a.uint32(10).string(r.authority);
      for (const s of r.sendEnabled)
        f.SendEnabled.encode(s, a.uint32(18).fork()).ldelim();
      for (const s of r.useDefaultFor)
        a.uint32(26).string(s);
      return a;
    },
    decode(r, a) {
      const s = r instanceof l.Reader ? r : new l.Reader(r);
      let p = a === void 0 ? s.len : s.pos + a;
      const y = n();
      for (; s.pos < p; ) {
        const g = s.uint32();
        switch (g >>> 3) {
          case 1:
            y.authority = s.string();
            break;
          case 2:
            y.sendEnabled.push(f.SendEnabled.decode(s, s.uint32()));
            break;
          case 3:
            y.useDefaultFor.push(s.string());
            break;
          default:
            s.skipType(g & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(r) {
      return {
        authority: (0, b.isSet)(r.authority) ? String(r.authority) : "",
        sendEnabled: Array.isArray(r == null ? void 0 : r.sendEnabled) ? r.sendEnabled.map((a) => f.SendEnabled.fromJSON(a)) : [],
        useDefaultFor: Array.isArray(r == null ? void 0 : r.useDefaultFor) ? r.useDefaultFor.map((a) => String(a)) : []
      };
    },
    toJSON(r) {
      const a = {};
      return r.authority !== void 0 && (a.authority = r.authority), r.sendEnabled ? a.sendEnabled = r.sendEnabled.map((s) => s ? f.SendEnabled.toJSON(s) : void 0) : a.sendEnabled = [], r.useDefaultFor ? a.useDefaultFor = r.useDefaultFor.map((s) => s) : a.useDefaultFor = [], a;
    },
    fromPartial(r) {
      var s, p;
      const a = n();
      return a.authority = r.authority ?? "", a.sendEnabled = ((s = r.sendEnabled) == null ? void 0 : s.map((y) => f.SendEnabled.fromPartial(y))) || [], a.useDefaultFor = ((p = r.useDefaultFor) == null ? void 0 : p.map((y) => y)) || [], a;
    }
  };
  function i() {
    return {};
  }
  e.MsgSetSendEnabledResponse = {
    encode(r, a = l.Writer.create()) {
      return a;
    },
    decode(r, a) {
      const s = r instanceof l.Reader ? r : new l.Reader(r);
      let p = a === void 0 ? s.len : s.pos + a;
      const y = i();
      for (; s.pos < p; ) {
        const g = s.uint32();
        switch (g >>> 3) {
          default:
            s.skipType(g & 7);
            break;
        }
      }
      return y;
    },
    fromJSON(r) {
      return {};
    },
    toJSON(r) {
      return {};
    },
    fromPartial(r) {
      return i();
    }
  };
  class d {
    constructor(a) {
      this.rpc = a, this.Send = this.Send.bind(this), this.MultiSend = this.MultiSend.bind(this), this.UpdateParams = this.UpdateParams.bind(this), this.SetSendEnabled = this.SetSendEnabled.bind(this);
    }
    Send(a) {
      const s = e.MsgSend.encode(a).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Msg", "Send", s).then((y) => e.MsgSendResponse.decode(new l.Reader(y)));
    }
    MultiSend(a) {
      const s = e.MsgMultiSend.encode(a).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Msg", "MultiSend", s).then((y) => e.MsgMultiSendResponse.decode(new l.Reader(y)));
    }
    UpdateParams(a) {
      const s = e.MsgUpdateParams.encode(a).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Msg", "UpdateParams", s).then((y) => e.MsgUpdateParamsResponse.decode(new l.Reader(y)));
    }
    SetSendEnabled(a) {
      const s = e.MsgSetSendEnabled.encode(a).finish();
      return this.rpc.request("cosmos.bank.v1beta1.Msg", "SetSendEnabled", s).then((y) => e.MsgSetSendEnabledResponse.decode(new l.Reader(y)));
    }
  }
  e.MsgClientImpl = d;
})(Re);
Object.defineProperty(O, "__esModule", { value: !0 });
O.Registry = O.isTxBodyEncodeObject = O.isPbjsGeneratedType = O.isTsProtoGeneratedType = void 0;
const yn = Re, pn = ye, oe = fe, mn = le;
function he(e) {
  return typeof e.fromPartial == "function";
}
O.isTsProtoGeneratedType = he;
function bn(e) {
  return !he(e);
}
O.isPbjsGeneratedType = bn;
const Me = {
  cosmosCoin: "/cosmos.base.v1beta1.Coin",
  cosmosMsgSend: "/cosmos.bank.v1beta1.MsgSend",
  cosmosTxBody: "/cosmos.tx.v1beta1.TxBody",
  googleAny: "/google.protobuf.Any"
};
function Ke(e) {
  return e.typeUrl === "/cosmos.tx.v1beta1.TxBody";
}
O.isTxBodyEncodeObject = Ke;
class hn {
  /**
   * Creates a new Registry for mapping protobuf type identifiers/type URLs to
   * actual implementations. Those implementations are typically generated with ts-proto
   * but we also support protobuf.js as a type generator.
   *
   * If there is no parameter given, a `new Registry()` adds the types `Coin` and `MsgSend`
   * for historic reasons. Those can be overriden by customTypes.
   *
   * There are currently two methods for adding new types:
   * 1. Passing types to the constructor.
   * 2. Using the `register()` method
   */
  constructor(t) {
    const { cosmosCoin: o, cosmosMsgSend: c } = Me;
    this.types = t ? new Map([...t]) : /* @__PURE__ */ new Map([
      [o, pn.Coin],
      [c, yn.MsgSend]
    ]);
  }
  register(t, o) {
    this.types.set(t, o);
  }
  /**
   * Looks up a type that was previously added to the registry.
   *
   * The generator information (ts-proto or pbjs) gets lost along the way.
   * If you need to work with the result type in TypeScript, you can use:
   *
   * ```
   * import { assert } from "@cosmjs/utils";
   *
   * const Coin = registry.lookupType("/cosmos.base.v1beta1.Coin");
   * assert(Coin); // Ensures not unset
   * assert(isTsProtoGeneratedType(Coin)); // Ensures this is the type we expect
   *
   * // Coin is typed TsProtoGeneratedType now.
   * ```
   */
  lookupType(t) {
    return this.types.get(t);
  }
  lookupTypeWithError(t) {
    const o = this.lookupType(t);
    if (!o)
      throw new Error(`Unregistered type url: ${t}`);
    return o;
  }
  /**
   * Takes a typeUrl/value pair and encodes the value to protobuf if
   * the given type was previously registered.
   *
   * If the value has to be wrapped in an Any, this needs to be done
   * manually after this call. Or use `encodeAsAny` instead.
   */
  encode(t) {
    const { value: o, typeUrl: c } = t;
    if (Ke(t))
      return this.encodeTxBody(o);
    const u = this.lookupTypeWithError(c), f = he(u) ? u.fromPartial(o) : u.create(o);
    return u.encode(f).finish();
  }
  /**
   * Takes a typeUrl/value pair and encodes the value to an Any if
   * the given type was previously registered.
   */
  encodeAsAny(t) {
    const o = this.encode(t);
    return mn.Any.fromPartial({
      typeUrl: t.typeUrl,
      value: o
    });
  }
  encodeTxBody(t) {
    const o = t.messages.map((u) => this.encodeAsAny(u)), c = oe.TxBody.fromPartial({
      ...t,
      messages: o
    });
    return oe.TxBody.encode(c).finish();
  }
  decode({ typeUrl: t, value: o }) {
    if (t === Me.cosmosTxBody)
      return this.decodeTxBody(o);
    const u = this.lookupTypeWithError(t).decode(o);
    return Object.entries(u).forEach(([f, l]) => {
      typeof Buffer < "u" && typeof Buffer.isBuffer < "u" && Buffer.isBuffer(l) && (u[f] = Uint8Array.from(l));
    }), u;
  }
  decodeTxBody(t) {
    const o = oe.TxBody.decode(t);
    return {
      ...o,
      messages: o.messages.map(({ typeUrl: c, value: u }) => {
        if (!c)
          throw new Error("Missing type_url in Any");
        if (!u)
          throw new Error("Missing value in Any");
        return this.decode({ typeUrl: c, value: u });
      })
    };
  }
}
O.Registry = hn;
var ne = {};
Object.defineProperty(ne, "__esModule", { value: !0 });
ne.isOfflineDirectSigner = void 0;
function gn(e) {
  return e.signDirect !== void 0;
}
ne.isOfflineDirectSigner = gn;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.coins = e.coin = e.executeKdf = e.makeSignDoc = e.makeSignBytes = e.makeAuthInfoBytes = e.isOfflineDirectSigner = e.Registry = e.isTxBodyEncodeObject = e.isTsProtoGeneratedType = e.isPbjsGeneratedType = e.encodePubkey = e.decodePubkey = e.anyToSinglePubkey = e.makeCosmoshubPath = e.DirectSecp256k1Wallet = e.extractKdfConfiguration = e.DirectSecp256k1HdWallet = e.decodeTxRaw = e.parseCoins = void 0;
  var t = Y;
  Object.defineProperty(e, "parseCoins", { enumerable: !0, get: function() {
    return t.parseCoins;
  } });
  var o = j;
  Object.defineProperty(e, "decodeTxRaw", { enumerable: !0, get: function() {
    return o.decodeTxRaw;
  } });
  var c = J;
  Object.defineProperty(e, "DirectSecp256k1HdWallet", { enumerable: !0, get: function() {
    return c.DirectSecp256k1HdWallet;
  } }), Object.defineProperty(e, "extractKdfConfiguration", { enumerable: !0, get: function() {
    return c.extractKdfConfiguration;
  } });
  var u = x;
  Object.defineProperty(e, "DirectSecp256k1Wallet", { enumerable: !0, get: function() {
    return u.DirectSecp256k1Wallet;
  } });
  var f = ee;
  Object.defineProperty(e, "makeCosmoshubPath", { enumerable: !0, get: function() {
    return f.makeCosmoshubPath;
  } });
  var l = v;
  Object.defineProperty(e, "anyToSinglePubkey", { enumerable: !0, get: function() {
    return l.anyToSinglePubkey;
  } }), Object.defineProperty(e, "decodePubkey", { enumerable: !0, get: function() {
    return l.decodePubkey;
  } }), Object.defineProperty(e, "encodePubkey", { enumerable: !0, get: function() {
    return l.encodePubkey;
  } });
  var b = O;
  Object.defineProperty(e, "isPbjsGeneratedType", { enumerable: !0, get: function() {
    return b.isPbjsGeneratedType;
  } }), Object.defineProperty(e, "isTsProtoGeneratedType", { enumerable: !0, get: function() {
    return b.isTsProtoGeneratedType;
  } }), Object.defineProperty(e, "isTxBodyEncodeObject", { enumerable: !0, get: function() {
    return b.isTxBodyEncodeObject;
  } }), Object.defineProperty(e, "Registry", { enumerable: !0, get: function() {
    return b.Registry;
  } });
  var h = ne;
  Object.defineProperty(e, "isOfflineDirectSigner", { enumerable: !0, get: function() {
    return h.isOfflineDirectSigner;
  } });
  var S = w;
  Object.defineProperty(e, "makeAuthInfoBytes", { enumerable: !0, get: function() {
    return S.makeAuthInfoBytes;
  } }), Object.defineProperty(e, "makeSignBytes", { enumerable: !0, get: function() {
    return S.makeSignBytes;
  } }), Object.defineProperty(e, "makeSignDoc", { enumerable: !0, get: function() {
    return S.makeSignDoc;
  } });
  var _ = me;
  Object.defineProperty(e, "executeKdf", { enumerable: !0, get: function() {
    return _.executeKdf;
  } });
  var k = Z;
  Object.defineProperty(e, "coin", { enumerable: !0, get: function() {
    return k.coin;
  } }), Object.defineProperty(e, "coins", { enumerable: !0, get: function() {
    return k.coins;
  } });
})(Be);
const _n = /* @__PURE__ */ Ce({
  __proto__: null
}, [Be]);
export {
  Te as a,
  Be as b,
  _n as i,
  Re as t
};
