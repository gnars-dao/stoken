import { b as re, a as N, d as C } from "./index-005ea00d.js";
import { d as k } from "./index-d653805f.js";
function he(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const o in r)
        if (o !== "default" && !(o in e)) {
          const i = Object.getOwnPropertyDescriptor(r, o);
          i && Object.defineProperty(e, o, i.get ? i : {
            enumerable: !0,
            get: () => r[o]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var oe = {}, l = {}, d = {}, B = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.isMultisigThresholdPubkey = e.isSinglePubkey = e.pubkeyType = e.isSecp256k1Pubkey = e.isEd25519Pubkey = void 0;
  function t(i) {
    return i.type === "tendermint/PubKeyEd25519";
  }
  e.isEd25519Pubkey = t;
  function n(i) {
    return i.type === "tendermint/PubKeySecp256k1";
  }
  e.isSecp256k1Pubkey = n, e.pubkeyType = {
    /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/ed25519/ed25519.go#L22 */
    secp256k1: "tendermint/PubKeySecp256k1",
    /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/secp256k1/secp256k1.go#L23 */
    ed25519: "tendermint/PubKeyEd25519",
    /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/sr25519/codec.go#L12 */
    sr25519: "tendermint/PubKeySr25519",
    multisigThreshold: "tendermint/PubKeyMultisigThreshold"
  };
  function r(i) {
    return [e.pubkeyType.ed25519, e.pubkeyType.secp256k1, e.pubkeyType.sr25519].includes(i.type);
  }
  e.isSinglePubkey = r;
  function o(i) {
    return i.type === "tendermint/PubKeyMultisigThreshold";
  }
  e.isMultisigThresholdPubkey = o;
})(B);
Object.defineProperty(d, "__esModule", { value: !0 });
d.encodeBech32Pubkey = d.encodeAminoPubkey = d.decodeBech32Pubkey = d.decodeAminoPubkey = d.encodeEd25519Pubkey = d.encodeSecp256k1Pubkey = void 0;
const y = k, fe = N, j = re, b = B;
function pe(e) {
  if (e.length !== 33 || e[0] !== 2 && e[0] !== 3)
    throw new Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");
  return {
    type: b.pubkeyType.secp256k1,
    value: (0, y.toBase64)(e)
  };
}
d.encodeSecp256k1Pubkey = pe;
function be(e) {
  if (e.length !== 32)
    throw new Error("Ed25519 public key must be 32 bytes long");
  return {
    type: b.pubkeyType.ed25519,
    value: (0, y.toBase64)(e)
  };
}
d.encodeEd25519Pubkey = be;
const D = (0, y.fromHex)(
  "eb5ae98721"
  /* fixed length */
), W = (0, y.fromHex)(
  "1624de6420"
  /* fixed length */
), q = (0, y.fromHex)(
  "0dfb100520"
  /* fixed length */
), $ = (0, y.fromHex)(
  "22c1f7e2"
  /* variable length not included */
);
function G(e) {
  if ((0, j.arrayContentStartsWith)(e, D)) {
    const t = e.slice(D.length);
    if (t.length !== 33)
      throw new Error("Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).");
    return {
      type: b.pubkeyType.secp256k1,
      value: (0, y.toBase64)(t)
    };
  } else if ((0, j.arrayContentStartsWith)(e, W)) {
    const t = e.slice(W.length);
    if (t.length !== 32)
      throw new Error("Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).");
    return {
      type: b.pubkeyType.ed25519,
      value: (0, y.toBase64)(t)
    };
  } else if ((0, j.arrayContentStartsWith)(e, q)) {
    const t = e.slice(q.length);
    if (t.length !== 32)
      throw new Error("Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).");
    return {
      type: b.pubkeyType.sr25519,
      value: (0, y.toBase64)(t)
    };
  } else {
    if ((0, j.arrayContentStartsWith)(e, $))
      return ge(e);
    throw new Error("Unsupported public key type. Amino data starts with: " + (0, y.toHex)(e.slice(0, 5)));
  }
}
d.decodeAminoPubkey = G;
function me(e) {
  const { data: t } = (0, y.fromBech32)(e);
  return G(t);
}
d.decodeBech32Pubkey = me;
function Z(e) {
  if (e.length < 1)
    throw new Error("Can't decode varint. EOF");
  if (e[0] > 127)
    throw new Error("Decoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.Varint implementation from the Go standard library and write some tests.");
  return [e[0], 1];
}
function ge(e) {
  const t = Array.from(e), n = t.splice(0, $.length);
  if (!(0, j.arrayContentStartsWith)(n, $))
    throw new Error("Invalid multisig prefix.");
  if (t.shift() != 8)
    throw new Error("Invalid multisig data. Expecting 0x08 prefix before threshold.");
  const [r, o] = Z(t);
  t.splice(0, o);
  const i = [];
  for (; t.length > 0; ) {
    if (t.shift() != 18)
      throw new Error("Invalid multisig data. Expecting 0x12 prefix before participant pubkey length.");
    const [c, u] = Z(t);
    if (t.splice(0, u), t.length < c)
      throw new Error("Invalid multisig data length.");
    const s = t.splice(0, c), a = G(Uint8Array.from(s));
    i.push(a);
  }
  return {
    type: b.pubkeyType.multisigThreshold,
    value: {
      threshold: r.toString(),
      pubkeys: i
    }
  };
}
function Q(e) {
  const t = fe.Uint53.fromString(e.toString()).toNumber();
  if (t > 127)
    throw new Error("Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.");
  return [t];
}
function x(e) {
  if ((0, b.isMultisigThresholdPubkey)(e)) {
    const t = Array.from($);
    t.push(8), t.push(...Q(e.value.threshold));
    for (const n of e.value.pubkeys.map((r) => x(r)))
      t.push(18), t.push(...Q(n.length)), t.push(...n);
    return new Uint8Array(t);
  } else {
    if ((0, b.isEd25519Pubkey)(e))
      return new Uint8Array([...W, ...(0, y.fromBase64)(e.value)]);
    if ((0, b.isSecp256k1Pubkey)(e))
      return new Uint8Array([...D, ...(0, y.fromBase64)(e.value)]);
    throw new Error("Unsupported pubkey type");
  }
}
d.encodeAminoPubkey = x;
function ke(e, t) {
  return (0, y.toBech32)(t, x(e));
}
d.encodeBech32Pubkey = ke;
Object.defineProperty(l, "__esModule", { value: !0 });
l.pubkeyToAddress = l.pubkeyToRawAddress = l.rawSecp256k1PubkeyToRawAddress = l.rawEd25519PubkeyToRawAddress = void 0;
const U = C, J = k, Pe = d, I = B;
function ie(e) {
  if (e.length !== 32)
    throw new Error(`Invalid Ed25519 pubkey length: ${e.length}`);
  return (0, U.sha256)(e).slice(0, 20);
}
l.rawEd25519PubkeyToRawAddress = ie;
function se(e) {
  if (e.length !== 33)
    throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${e.length}`);
  return (0, U.ripemd160)((0, U.sha256)(e));
}
l.rawSecp256k1PubkeyToRawAddress = se;
function ce(e) {
  if ((0, I.isSecp256k1Pubkey)(e)) {
    const t = (0, J.fromBase64)(e.value);
    return se(t);
  } else if ((0, I.isEd25519Pubkey)(e)) {
    const t = (0, J.fromBase64)(e.value);
    return ie(t);
  } else if ((0, I.isMultisigThresholdPubkey)(e)) {
    const t = (0, Pe.encodeAminoPubkey)(e);
    return (0, U.sha256)(t).slice(0, 20);
  } else
    throw new Error("Unsupported public key type");
}
l.pubkeyToRawAddress = ce;
function we(e, t) {
  return (0, J.toBech32)(t, ce(e));
}
l.pubkeyToAddress = we;
var p = {};
Object.defineProperty(p, "__esModule", { value: !0 });
p.addCoins = p.parseCoins = p.coins = p.coin = void 0;
const H = N;
function ue(e, t) {
  let n;
  if (typeof e == "number")
    try {
      n = new H.Uint53(e).toString();
    } catch {
      throw new Error("Given amount is not a safe integer. Consider using a string instead to overcome the limitations of JS numbers.");
    }
  else {
    if (!e.match(/^[0-9]+$/))
      throw new Error("Invalid unsigned integer string format");
    n = e.replace(/^0*/, "") || "0";
  }
  return {
    amount: n,
    denom: t
  };
}
p.coin = ue;
function Se(e, t) {
  return [ue(e, t)];
}
p.coins = Se;
function ve(e) {
  return e.replace(/\s/g, "").split(",").filter(Boolean).map((t) => {
    const n = t.match(/^([0-9]+)([a-zA-Z]+)/);
    if (!n)
      throw new Error("Got an invalid coin string");
    return {
      amount: n[1].replace(/^0+/, "") || "0",
      denom: n[2]
    };
  });
}
p.parseCoins = ve;
function Ae(e, t) {
  if (e.denom !== t.denom)
    throw new Error("Trying to add two coins with different denoms");
  return {
    amount: H.Decimal.fromAtomics(e.amount, 0).plus(H.Decimal.fromAtomics(t.amount, 0)).atomics,
    denom: e.denom
  };
}
p.addCoins = Ae;
var v = {};
Object.defineProperty(v, "__esModule", { value: !0 });
v.createMultisigThresholdPubkey = v.compareArrays = void 0;
const Y = k, Te = N, ee = l;
function ae(e, t) {
  const n = (0, Y.toHex)(e), r = (0, Y.toHex)(t);
  return n === r ? 0 : n < r ? -1 : 1;
}
v.compareArrays = ae;
function Ee(e, t, n = !1) {
  const r = new Te.Uint53(t);
  if (r.toNumber() > e.length)
    throw new Error(`Threshold k = ${r.toNumber()} exceeds number of keys n = ${e.length}`);
  const o = n ? e : Array.from(e).sort((i, c) => {
    const u = (0, ee.pubkeyToRawAddress)(i), s = (0, ee.pubkeyToRawAddress)(c);
    return ae(u, s);
  });
  return {
    type: "tendermint/PubKeyMultisigThreshold",
    value: {
      threshold: r.toString(),
      pubkeys: o
    }
  };
}
v.createMultisigThresholdPubkey = Ee;
var K = {};
Object.defineProperty(K, "__esModule", { value: !0 });
K.makeCosmoshubPath = void 0;
const E = C;
function _e(e) {
  return [
    E.Slip10RawIndex.hardened(44),
    E.Slip10RawIndex.hardened(118),
    E.Slip10RawIndex.hardened(0),
    E.Slip10RawIndex.normal(0),
    E.Slip10RawIndex.normal(e)
  ];
}
K.makeCosmoshubPath = _e;
var A = {}, g = {};
Object.defineProperty(g, "__esModule", { value: !0 });
g.decodeSignature = g.encodeSecp256k1Signature = void 0;
const L = k, Oe = d, je = B;
function Ce(e, t) {
  if (t.length !== 64)
    throw new Error("Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.");
  return {
    pub_key: (0, Oe.encodeSecp256k1Pubkey)(e),
    signature: (0, L.toBase64)(t)
  };
}
g.encodeSecp256k1Signature = Ce;
function Be(e) {
  switch (e.pub_key.type) {
    case je.pubkeyType.secp256k1:
      return {
        pubkey: (0, L.fromBase64)(e.pub_key.value),
        signature: (0, L.fromBase64)(e.signature)
      };
    default:
      throw new Error("Unsupported pubkey type");
  }
}
g.decodeSignature = Be;
var f = {};
Object.defineProperty(f, "__esModule", { value: !0 });
f.serializeSignDoc = f.escapeCharacters = f.makeSignDoc = f.sortedJsonStringify = void 0;
const Ke = k, te = N;
function V(e) {
  if (typeof e != "object" || e === null)
    return e;
  if (Array.isArray(e))
    return e.map(V);
  const t = Object.keys(e).sort(), n = {};
  return t.forEach((r) => {
    n[r] = V(e[r]);
  }), n;
}
function de(e) {
  return JSON.stringify(V(e));
}
f.sortedJsonStringify = de;
function Me(e, t, n, r, o, i) {
  return {
    chain_id: n,
    account_number: te.Uint53.fromString(o.toString()).toString(),
    sequence: te.Uint53.fromString(i.toString()).toString(),
    fee: t,
    msgs: e,
    memo: r || ""
  };
}
f.makeSignDoc = Me;
function ye(e) {
  const t = /&/g, n = /</g, r = />/g;
  return e.replace(t, "\\u0026").replace(n, "\\u003c").replace(r, "\\u003e");
}
f.escapeCharacters = ye;
function Re(e) {
  const t = ye(de(e));
  return (0, Ke.toUtf8)(t);
}
f.serializeSignDoc = Re;
var F = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.decrypt = e.encrypt = e.supportedAlgorithms = e.executeKdf = e.cosmjsSalt = void 0;
  const t = C, n = k;
  e.cosmjsSalt = (0, n.toAscii)("The CosmJS salt.");
  async function r(c, u) {
    switch (u.algorithm) {
      case "argon2id": {
        const s = u.params;
        if (!(0, t.isArgon2idOptions)(s))
          throw new Error("Invalid format of argon2id params");
        return t.Argon2id.execute(c, e.cosmjsSalt, s);
      }
      default:
        throw new Error("Unsupported KDF algorithm");
    }
  }
  e.executeKdf = r, e.supportedAlgorithms = {
    xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
  };
  async function o(c, u, s) {
    switch (s.algorithm) {
      case e.supportedAlgorithms.xchacha20poly1305Ietf: {
        const a = t.Random.getBytes(t.xchacha20NonceLength);
        return new Uint8Array([
          ...a,
          ...await t.Xchacha20poly1305Ietf.encrypt(c, u, a)
        ]);
      }
      default:
        throw new Error(`Unsupported encryption algorithm: '${s.algorithm}'`);
    }
  }
  e.encrypt = o;
  async function i(c, u, s) {
    switch (s.algorithm) {
      case e.supportedAlgorithms.xchacha20poly1305Ietf: {
        const a = c.slice(0, t.xchacha20NonceLength);
        return t.Xchacha20poly1305Ietf.decrypt(c.slice(t.xchacha20NonceLength), u, a);
      }
      default:
        throw new Error(`Unsupported encryption algorithm: '${s.algorithm}'`);
    }
  }
  e.decrypt = i;
})(F);
Object.defineProperty(A, "__esModule", { value: !0 });
A.Secp256k1HdWallet = A.extractKdfConfiguration = void 0;
const h = C, _ = k, S = re, $e = l, Ue = K, Ne = g, ze = f, O = F, R = "secp256k1wallet-v1", Ie = {
  algorithm: "argon2id",
  params: {
    outputLength: 32,
    opsLimit: 24,
    memLimitKib: 12 * 1024
  }
};
function De(e) {
  return !(!(0, S.isNonNullObject)(e) || typeof e.hdPath != "string" || typeof e.prefix != "string");
}
function We(e) {
  return e.kdf;
}
function Je(e) {
  const t = JSON.parse(e);
  if (!(0, S.isNonNullObject)(t))
    throw new Error("Root document is not an object.");
  switch (t.type) {
    case R:
      return We(t);
    default:
      throw new Error("Unsupported serialization type");
  }
}
A.extractKdfConfiguration = Je;
const ne = {
  bip39Password: "",
  hdPaths: [(0, Ue.makeCosmoshubPath)(0)],
  prefix: "cosmos"
};
class P {
  /**
   * Restores a wallet from the given BIP39 mnemonic.
   *
   * @param mnemonic Any valid English mnemonic.
   * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
   */
  static async fromMnemonic(t, n = {}) {
    const r = new h.EnglishMnemonic(t), o = await h.Bip39.mnemonicToSeed(r, n.bip39Password);
    return new P(r, {
      ...n,
      seed: o
    });
  }
  /**
   * Generates a new wallet with a BIP39 mnemonic of the given length.
   *
   * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
   * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
   */
  static async generate(t = 12, n = {}) {
    const r = 4 * Math.floor(11 * t / 33), o = h.Random.getBytes(r), i = h.Bip39.encode(o);
    return P.fromMnemonic(i.toString(), n);
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * @param password The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  static async deserialize(t, n) {
    const r = JSON.parse(t);
    if (!(0, S.isNonNullObject)(r))
      throw new Error("Root document is not an object.");
    switch (r.type) {
      case R:
        return P.deserializeTypeV1(t, n);
      default:
        throw new Error("Unsupported serialization type");
    }
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
   * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
   * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
   */
  static async deserializeWithEncryptionKey(t, n) {
    const r = JSON.parse(t);
    if (!(0, S.isNonNullObject)(r))
      throw new Error("Root document is not an object.");
    const o = r;
    switch (o.type) {
      case R: {
        const i = await (0, O.decrypt)((0, _.fromBase64)(o.data), n, o.encryption), c = JSON.parse((0, _.fromUtf8)(i)), { mnemonic: u, accounts: s } = c;
        if ((0, S.assert)(typeof u == "string"), !Array.isArray(s))
          throw new Error("Property 'accounts' is not an array");
        if (!s.every((m) => De(m)))
          throw new Error("Account is not in the correct format.");
        const a = s[0].prefix;
        if (!s.every(({ prefix: m }) => m === a))
          throw new Error("Accounts do not all have the same prefix");
        const w = s.map(({ hdPath: m }) => (0, h.stringToPath)(m));
        return P.fromMnemonic(u, {
          hdPaths: w,
          prefix: a
        });
      }
      default:
        throw new Error("Unsupported serialization type");
    }
  }
  static async deserializeTypeV1(t, n) {
    const r = JSON.parse(t);
    if (!(0, S.isNonNullObject)(r))
      throw new Error("Root document is not an object.");
    const o = await (0, O.executeKdf)(n, r.kdf);
    return P.deserializeWithEncryptionKey(t, o);
  }
  constructor(t, n) {
    const r = n.hdPaths ?? ne.hdPaths, o = n.prefix ?? ne.prefix;
    this.secret = t, this.seed = n.seed, this.accounts = r.map((i) => ({
      hdPath: i,
      prefix: o
    }));
  }
  get mnemonic() {
    return this.secret.toString();
  }
  async getAccounts() {
    return (await this.getAccountsWithPrivkeys()).map(({ algo: n, pubkey: r, address: o }) => ({
      algo: n,
      pubkey: r,
      address: o
    }));
  }
  async signAmino(t, n) {
    const o = (await this.getAccountsWithPrivkeys()).find(({ address: w }) => w === t);
    if (o === void 0)
      throw new Error(`Address ${t} not found in wallet`);
    const { privkey: i, pubkey: c } = o, u = (0, h.sha256)((0, ze.serializeSignDoc)(n)), s = await h.Secp256k1.createSignature(u, i), a = new Uint8Array([...s.r(32), ...s.s(32)]);
    return {
      signed: n,
      signature: (0, Ne.encodeSecp256k1Signature)(c, a)
    };
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * @param password The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  async serialize(t) {
    const n = Ie, r = await (0, O.executeKdf)(t, n);
    return this.serializeWithEncryptionKey(r, n);
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
   * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF options. If this
   * is not the case, the wallet cannot be restored with the original password.
   */
  async serializeWithEncryptionKey(t, n) {
    const r = {
      mnemonic: this.mnemonic,
      accounts: this.accounts.map(({ hdPath: s, prefix: a }) => ({
        hdPath: (0, h.pathToString)(s),
        prefix: a
      }))
    }, o = (0, _.toUtf8)(JSON.stringify(r)), i = {
      algorithm: O.supportedAlgorithms.xchacha20poly1305Ietf
    }, c = await (0, O.encrypt)(o, t, i), u = {
      type: R,
      kdf: n,
      encryption: i,
      data: (0, _.toBase64)(c)
    };
    return JSON.stringify(u);
  }
  async getKeyPair(t) {
    const { privkey: n } = h.Slip10.derivePath(h.Slip10Curve.Secp256k1, this.seed, t), { pubkey: r } = await h.Secp256k1.makeKeypair(n);
    return {
      privkey: n,
      pubkey: h.Secp256k1.compressPubkey(r)
    };
  }
  async getAccountsWithPrivkeys() {
    return Promise.all(this.accounts.map(async ({ hdPath: t, prefix: n }) => {
      const { privkey: r, pubkey: o } = await this.getKeyPair(t), i = (0, _.toBech32)(n, (0, $e.rawSecp256k1PubkeyToRawAddress)(o));
      return {
        algo: "secp256k1",
        privkey: r,
        pubkey: o,
        address: i
      };
    }));
  }
}
A.Secp256k1HdWallet = P;
var z = {};
Object.defineProperty(z, "__esModule", { value: !0 });
z.Secp256k1Wallet = void 0;
const M = C, He = k, Le = l, Ve = g, Ge = f;
class X {
  /**
   * Creates a Secp256k1Wallet from the given private key
   *
   * @param privkey The private key.
   * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
   */
  static async fromKey(t, n = "cosmos") {
    const r = (await M.Secp256k1.makeKeypair(t)).pubkey;
    return new X(t, M.Secp256k1.compressPubkey(r), n);
  }
  constructor(t, n, r) {
    this.privkey = t, this.pubkey = n, this.prefix = r;
  }
  get address() {
    return (0, He.toBech32)(this.prefix, (0, Le.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
  }
  async getAccounts() {
    return [
      {
        algo: "secp256k1",
        address: this.address,
        pubkey: this.pubkey
      }
    ];
  }
  async signAmino(t, n) {
    if (t !== this.address)
      throw new Error(`Address ${t} not found in wallet`);
    const r = new M.Sha256((0, Ge.serializeSignDoc)(n)).digest(), o = await M.Secp256k1.createSignature(r, this.privkey), i = new Uint8Array([...o.r(32), ...o.s(32)]);
    return {
      signed: n,
      signature: (0, Ve.encodeSecp256k1Signature)(this.pubkey, i)
    };
  }
}
z.Secp256k1Wallet = X;
var T = {};
Object.defineProperty(T, "__esModule", { value: !0 });
T.makeStdTx = T.isStdTx = void 0;
function xe(e) {
  const { memo: t, msg: n, fee: r, signatures: o } = e;
  return typeof t == "string" && Array.isArray(n) && typeof r == "object" && Array.isArray(o);
}
T.isStdTx = xe;
function Fe(e, t) {
  return {
    msg: e.msgs,
    fee: e.fee,
    memo: e.memo,
    signatures: Array.isArray(t) ? t : [t]
  };
}
T.makeStdTx = Fe;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.executeKdf = e.makeStdTx = e.isStdTx = e.serializeSignDoc = e.makeSignDoc = e.encodeSecp256k1Signature = e.decodeSignature = e.Secp256k1Wallet = e.Secp256k1HdWallet = e.extractKdfConfiguration = e.pubkeyType = e.isSinglePubkey = e.isSecp256k1Pubkey = e.isMultisigThresholdPubkey = e.isEd25519Pubkey = e.makeCosmoshubPath = e.createMultisigThresholdPubkey = e.encodeSecp256k1Pubkey = e.encodeEd25519Pubkey = e.encodeBech32Pubkey = e.encodeAminoPubkey = e.decodeBech32Pubkey = e.decodeAminoPubkey = e.parseCoins = e.coins = e.coin = e.addCoins = e.rawSecp256k1PubkeyToRawAddress = e.rawEd25519PubkeyToRawAddress = e.pubkeyToRawAddress = e.pubkeyToAddress = void 0;
  var t = l;
  Object.defineProperty(e, "pubkeyToAddress", { enumerable: !0, get: function() {
    return t.pubkeyToAddress;
  } }), Object.defineProperty(e, "pubkeyToRawAddress", { enumerable: !0, get: function() {
    return t.pubkeyToRawAddress;
  } }), Object.defineProperty(e, "rawEd25519PubkeyToRawAddress", { enumerable: !0, get: function() {
    return t.rawEd25519PubkeyToRawAddress;
  } }), Object.defineProperty(e, "rawSecp256k1PubkeyToRawAddress", { enumerable: !0, get: function() {
    return t.rawSecp256k1PubkeyToRawAddress;
  } });
  var n = p;
  Object.defineProperty(e, "addCoins", { enumerable: !0, get: function() {
    return n.addCoins;
  } }), Object.defineProperty(e, "coin", { enumerable: !0, get: function() {
    return n.coin;
  } }), Object.defineProperty(e, "coins", { enumerable: !0, get: function() {
    return n.coins;
  } }), Object.defineProperty(e, "parseCoins", { enumerable: !0, get: function() {
    return n.parseCoins;
  } });
  var r = d;
  Object.defineProperty(e, "decodeAminoPubkey", { enumerable: !0, get: function() {
    return r.decodeAminoPubkey;
  } }), Object.defineProperty(e, "decodeBech32Pubkey", { enumerable: !0, get: function() {
    return r.decodeBech32Pubkey;
  } }), Object.defineProperty(e, "encodeAminoPubkey", { enumerable: !0, get: function() {
    return r.encodeAminoPubkey;
  } }), Object.defineProperty(e, "encodeBech32Pubkey", { enumerable: !0, get: function() {
    return r.encodeBech32Pubkey;
  } }), Object.defineProperty(e, "encodeEd25519Pubkey", { enumerable: !0, get: function() {
    return r.encodeEd25519Pubkey;
  } }), Object.defineProperty(e, "encodeSecp256k1Pubkey", { enumerable: !0, get: function() {
    return r.encodeSecp256k1Pubkey;
  } });
  var o = v;
  Object.defineProperty(e, "createMultisigThresholdPubkey", { enumerable: !0, get: function() {
    return o.createMultisigThresholdPubkey;
  } });
  var i = K;
  Object.defineProperty(e, "makeCosmoshubPath", { enumerable: !0, get: function() {
    return i.makeCosmoshubPath;
  } });
  var c = B;
  Object.defineProperty(e, "isEd25519Pubkey", { enumerable: !0, get: function() {
    return c.isEd25519Pubkey;
  } }), Object.defineProperty(e, "isMultisigThresholdPubkey", { enumerable: !0, get: function() {
    return c.isMultisigThresholdPubkey;
  } }), Object.defineProperty(e, "isSecp256k1Pubkey", { enumerable: !0, get: function() {
    return c.isSecp256k1Pubkey;
  } }), Object.defineProperty(e, "isSinglePubkey", { enumerable: !0, get: function() {
    return c.isSinglePubkey;
  } }), Object.defineProperty(e, "pubkeyType", { enumerable: !0, get: function() {
    return c.pubkeyType;
  } });
  var u = A;
  Object.defineProperty(e, "extractKdfConfiguration", { enumerable: !0, get: function() {
    return u.extractKdfConfiguration;
  } }), Object.defineProperty(e, "Secp256k1HdWallet", { enumerable: !0, get: function() {
    return u.Secp256k1HdWallet;
  } });
  var s = z;
  Object.defineProperty(e, "Secp256k1Wallet", { enumerable: !0, get: function() {
    return s.Secp256k1Wallet;
  } });
  var a = g;
  Object.defineProperty(e, "decodeSignature", { enumerable: !0, get: function() {
    return a.decodeSignature;
  } }), Object.defineProperty(e, "encodeSecp256k1Signature", { enumerable: !0, get: function() {
    return a.encodeSecp256k1Signature;
  } });
  var w = f;
  Object.defineProperty(e, "makeSignDoc", { enumerable: !0, get: function() {
    return w.makeSignDoc;
  } }), Object.defineProperty(e, "serializeSignDoc", { enumerable: !0, get: function() {
    return w.serializeSignDoc;
  } });
  var m = T;
  Object.defineProperty(e, "isStdTx", { enumerable: !0, get: function() {
    return m.isStdTx;
  } }), Object.defineProperty(e, "makeStdTx", { enumerable: !0, get: function() {
    return m.makeStdTx;
  } });
  var le = F;
  Object.defineProperty(e, "executeKdf", { enumerable: !0, get: function() {
    return le.executeKdf;
  } });
})(oe);
const Ze = /* @__PURE__ */ he({
  __proto__: null
}, [oe]);
export {
  oe as b,
  Ze as i
};
